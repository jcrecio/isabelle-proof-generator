{"file_name": "/home/qj213/afp-2021-10-22/thys/Formal_SSA/Construct_SSA_code.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Formal_SSA", "problem_names": ["lemma length_filter_less2:\n    assumes \"x \\<in> set xs\" \"\\<not>P x\" \"Q x\" \"\\<And>x. P x \\<Longrightarrow> Q x\"\n    shows \"length (filter P xs) < length (filter Q xs)\"", "lemma length_filter_le2:\n    assumes \"\\<And>x. P x \\<Longrightarrow> Q x\"\n    shows \"length (filter P xs) \\<le> length (filter Q xs)\"", "lemma phis_measure_update_le: \"phis_measure g v (Mapping.update k a p) \\<le> phis_measure g v p\"", "lemma phis_measure_update_le': \"phis_measure g v p \\<le> phis_measure g v (Mapping.update k [] phis) \\<Longrightarrow>\n       phis_measure g v (Mapping.update k a p) \\<le> phis_measure g v phis\"", "lemma readArgs_phis_le:\n    \"readVariableRecursive_readArgs_dom (Inl (g, v, n, phis)) \\<Longrightarrow> (val,p) = readVariableRecursive g v n phis \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v phis\"\n    \"readVariableRecursive_readArgs_dom (Inr (g, v, n, phis, ms)) \\<Longrightarrow> (p,u) = readArgs g v n phis ms \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v phis\"", "lemma fst_readVariableRecursive:\n    assumes \"n \\<in> set (\\<alpha>n g)\"\n    shows \"fst (readVariableRecursive g v n phis) = lookupDef g n v\"", "lemma phis'_aux_keys_super: \"Mapping.keys (phis'_aux g v ns phis) \\<supseteq> Mapping.keys phis\"", "lemma phiDefNodes_aux_in_unvisited:\n    shows \"phiDefNodes_aux g v un n \\<subseteq> set un\"", "lemma phiDefNodes_aux_unvisited_monotonic:\n    assumes \"set un \\<subseteq> set un'\"\n    shows \"phiDefNodes_aux g v un n \\<subseteq> phiDefNodes_aux g v un' n\"", "lemma phiDefNodes_aux_single_pred:\n    assumes \"predecessors g n = [m]\"\n    shows \"phiDefNodes_aux g v (removeAll n un) m = phiDefNodes_aux g v un m\"", "lemma phis'_aux_finite:\n    assumes \"finite (Mapping.keys phis)\"\n    shows \"finite (Mapping.keys (phis'_aux g v ns phis))\"", "lemma phiDefNodes_aux_redirect:\n    assumes asm: \"g \\<turnstile> n-ns\\<rightarrow>m\"  \"\\<forall>n \\<in> set ns. v \\<notin> defs g n\" \"length (predecessors g n) \\<noteq> 1\" \"unvisitedPath un ns\"\n    assumes n': \"n' \\<in> set ns\" \"n' \\<in> phiDefNodes_aux g v un m'\" \"m' \\<in> set (\\<alpha>n g)\"\n    shows \"n \\<in> phiDefNodes_aux g v un m'\"", "lemma snd_readVariableRecursive:\n    assumes \"v \\<in> vars g\" \"n \\<in> set (\\<alpha>n g)\" \"finite (Mapping.keys phis)\"\n    \"\\<And>n. (n,v) \\<in> Mapping.keys phis \\<Longrightarrow> length (predecessors g n) \\<noteq> 1\" \"Mapping.lookup phis (Entry g,v) \\<in> {None, Some []}\"\n    shows\n      \"phis'_aux g v {n} phis = snd (readVariableRecursive g v n phis)\"\n      \"set ms \\<subseteq> set (\\<alpha>n g) \\<Longrightarrow> (phis'_aux g v (set ms) phis, map (\\<lambda>m. lookupDef g m v) ms) = readArgs g v n phis ms\"", "lemma from_sparse_inj: \"inj from_sparse\"", "lemma foldr_prod: \"foldr (\\<lambda>x y. (f1 x (fst y), f2 x (snd y))) xs y = (foldr f1 xs (fst y), foldr f2 xs (snd y))\"", "lemma foldr_aux_1:\n    assumes \"set us \\<subseteq> uses g n\" \"Mapping.lookup u n = None\" \"foldr (aux_1 g n) us (u,p) = (u',p')\" (is \"foldr ?f _ _ = _\")\n    assumes \"finite (Mapping.keys p)\" \"\\<And>n v. (n,v) \\<in> Mapping.keys p \\<Longrightarrow> length (predecessors g n) \\<noteq> 1\" \"\\<And>v. Mapping.lookup p (Entry g,v) \\<in> {None, Some []}\"\n    shows \"lookupDef g n ` set us = lookup_multimap u' n\" \"\\<And>m. m \\<noteq> n \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\"\n      \"\\<And>m v. (if m \\<in> phiDefNodes_aux g v [n \\<leftarrow> \\<alpha>n g. (n,v) \\<notin> Mapping.keys p] n \\<and> v \\<in> set us then\n        Some (map (\\<lambda>m. lookupDef g m v) (predecessors g m)) else\n        (Mapping.lookup p (m,v))) = Mapping.lookup p' (m,v)\"", "lemma foldr_aux_2:\n    assumes \"set ns \\<subseteq> set (\\<alpha>n g)\" \"distinct ns\" \"foldr (aux_2 g) ns init_state = (u',p')\"\n    shows \"\\<And>n. n \\<in> set ns \\<Longrightarrow> uses' g n = lookup_multimap u' n\" \"\\<And>n. n \\<notin> set ns \\<Longrightarrow> Mapping.lookup u' n = None\"\n      \"\\<And>m v. (if \\<exists>n \\<in> set ns. m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<and> v \\<in> uses g n then\n        Some (map (\\<lambda>m. lookupDef g m v) (predecessors g m)) else\n        None) = Mapping.lookup p' (m,v)\"", "lemma fst_uses'_phis': \"uses' g = lookup_multimap (fst (uses'_phis' g))\"", "lemma fst_uses'_phis'_in_\\<alpha>n: \"Mapping.keys (fst (uses'_phis' g)) \\<subseteq> set (\\<alpha>n g)\"", "lemma snd_uses'_phis': \"phis'_code g = snd (uses'_phis' g)\""], "translations": [["", "lemma length_filter_less2:\n    assumes \"x \\<in> set xs\" \"\\<not>P x\" \"Q x\" \"\\<And>x. P x \\<Longrightarrow> Q x\"\n    shows \"length (filter P xs) < length (filter Q xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter P xs) < length (filter Q xs)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. length (filter P xs) < length (filter Q xs)", "have \"\\<And>x. (Q x \\<and> P x) = P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (Q x \\<and> P x) = P x", "using assms(4)"], ["proof (prove)\nusing this:\n  P ?x1 \\<Longrightarrow> Q ?x1\n\ngoal (1 subgoal):\n 1. \\<And>x. (Q x \\<and> P x) = P x", "by auto"], ["proof (state)\nthis:\n  (Q ?x1 \\<and> P ?x1) = P ?x1\n\ngoal (1 subgoal):\n 1. length (filter P xs) < length (filter Q xs)", "hence \"filter P xs = filter P (filter Q xs)\""], ["proof (prove)\nusing this:\n  (Q ?x1 \\<and> P ?x1) = P ?x1\n\ngoal (1 subgoal):\n 1. filter P xs = filter P (filter Q xs)", "by auto"], ["proof (state)\nthis:\n  filter P xs = filter P (filter Q xs)\n\ngoal (1 subgoal):\n 1. length (filter P xs) < length (filter Q xs)", "also"], ["proof (state)\nthis:\n  filter P xs = filter P (filter Q xs)\n\ngoal (1 subgoal):\n 1. length (filter P xs) < length (filter Q xs)", "have \"length (...) < length (filter Q xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter P (filter Q xs)) < length (filter Q xs)", "using assms(1-3)"], ["proof (prove)\nusing this:\n  x \\<in> set xs\n  \\<not> P x\n  Q x\n\ngoal (1 subgoal):\n 1. length (filter P (filter Q xs)) < length (filter Q xs)", "by - (rule length_filter_less, auto)"], ["proof (state)\nthis:\n  length (filter P (filter Q xs)) < length (filter Q xs)\n\ngoal (1 subgoal):\n 1. length (filter P xs) < length (filter Q xs)", "finally"], ["proof (chain)\npicking this:\n  length (filter P xs) < length (filter Q xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  length (filter P xs) < length (filter Q xs)\n\ngoal (1 subgoal):\n 1. length (filter P xs) < length (filter Q xs)", "."], ["proof (state)\nthis:\n  length (filter P xs) < length (filter Q xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_filter_le2:\n    assumes \"\\<And>x. P x \\<Longrightarrow> Q x\"\n    shows \"length (filter P xs) \\<le> length (filter Q xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter P xs) \\<le> length (filter Q xs)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. length (filter P xs) \\<le> length (filter Q xs)", "have \"\\<And>x. (Q x \\<and> P x) = P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (Q x \\<and> P x) = P x", "using assms"], ["proof (prove)\nusing this:\n  P ?x1 \\<Longrightarrow> Q ?x1\n\ngoal (1 subgoal):\n 1. \\<And>x. (Q x \\<and> P x) = P x", "by auto"], ["proof (state)\nthis:\n  (Q ?x1 \\<and> P ?x1) = P ?x1\n\ngoal (1 subgoal):\n 1. length (filter P xs) \\<le> length (filter Q xs)", "hence \"filter P xs = filter P (filter Q xs)\""], ["proof (prove)\nusing this:\n  (Q ?x1 \\<and> P ?x1) = P ?x1\n\ngoal (1 subgoal):\n 1. filter P xs = filter P (filter Q xs)", "by auto"], ["proof (state)\nthis:\n  filter P xs = filter P (filter Q xs)\n\ngoal (1 subgoal):\n 1. length (filter P xs) \\<le> length (filter Q xs)", "also"], ["proof (state)\nthis:\n  filter P xs = filter P (filter Q xs)\n\ngoal (1 subgoal):\n 1. length (filter P xs) \\<le> length (filter Q xs)", "have \"length (...) \\<le> length (filter Q xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter P (filter Q xs)) \\<le> length (filter Q xs)", "by - (rule length_filter_le)"], ["proof (state)\nthis:\n  length (filter P (filter Q xs)) \\<le> length (filter Q xs)\n\ngoal (1 subgoal):\n 1. length (filter P xs) \\<le> length (filter Q xs)", "finally"], ["proof (chain)\npicking this:\n  length (filter P xs) \\<le> length (filter Q xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  length (filter P xs) \\<le> length (filter Q xs)\n\ngoal (1 subgoal):\n 1. length (filter P xs) \\<le> length (filter Q xs)", "."], ["proof (state)\nthis:\n  length (filter P xs) \\<le> length (filter Q xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation \"phis_measure g v phis \\<equiv> length [n \\<leftarrow> \\<alpha>n g. Mapping.lookup phis (n,v) = None]\""], ["", "lemma phis_measure_update_le: \"phis_measure g v (Mapping.update k a p) \\<le> phis_measure g v p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phis_measure g v (Mapping.update k a p) \\<le> phis_measure g v p", "apply (rule length_filter_le2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       Mapping.lookup (Mapping.update k a p) (x, v) = None \\<Longrightarrow>\n       Mapping.lookup p (x, v) = None", "apply (case_tac \"k = (x, v)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>Mapping.lookup (Mapping.update k a p) (x, v) = None;\n        k = (x, v)\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup p (x, v) = None\n 2. \\<And>x.\n       \\<lbrakk>Mapping.lookup (Mapping.update k a p) (x, v) = None;\n        k \\<noteq> (x, v)\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup p (x, v) = None", "apply (auto simp: lookup_update lookup_update_neq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma phis_measure_update_le': \"phis_measure g v p \\<le> phis_measure g v (Mapping.update k [] phis) \\<Longrightarrow>\n       phis_measure g v (Mapping.update k a p) \\<le> phis_measure g v phis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phis_measure g v p\n    \\<le> phis_measure g v (Mapping.update k [] phis) \\<Longrightarrow>\n    phis_measure g v (Mapping.update k a p) \\<le> phis_measure g v phis", "apply (rule le_trans, rule phis_measure_update_le)"], ["proof (prove)\ngoal (1 subgoal):\n 1. phis_measure g v p\n    \\<le> phis_measure g v (Mapping.update k [] phis) \\<Longrightarrow>\n    phis_measure g v p \\<le> phis_measure g v phis", "apply (rule le_trans, assumption, rule phis_measure_update_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma readArgs_phis_le:\n    \"readVariableRecursive_readArgs_dom (Inl (g, v, n, phis)) \\<Longrightarrow> (val,p) = readVariableRecursive g v n phis \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v phis\"\n    \"readVariableRecursive_readArgs_dom (Inr (g, v, n, phis, ms)) \\<Longrightarrow> (p,u) = readArgs g v n phis ms \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v phis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>readVariableRecursive_readArgs_dom (Inl (g, v, n, phis));\n      (val, p) = readVariableRecursive g v n phis\\<rbrakk>\n     \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v phis) &&&\n    (\\<lbrakk>readVariableRecursive_readArgs_dom (Inr (g, v, n, phis, ms));\n      (p, u) = readArgs g v n phis ms\\<rbrakk>\n     \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v phis)", "proof (induction arbitrary: val p and p u rule: readVariableRecursive_readArgs.pinduct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>g v n phis val p.\n       \\<lbrakk>readVariableRecursive_readArgs_dom (Inl (g, v, n, phis));\n        \\<And>x21 x22 val p.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n            x22 = []; (val, p) = readVariableRecursive g v x21 phis\\<rbrakk>\n           \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v phis;\n        \\<And>x21 x22 x21a x22a x p u.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n            x22 = x21a # x22a; Mapping.lookup phis (n, v) = None;\n            x = Mapping.update (n, v) [] phis;\n            (p, u) = readArgs g v n x (x21 # x21a # x22a)\\<rbrakk>\n           \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v x;\n        (val, p) = readVariableRecursive g v n phis\\<rbrakk>\n       \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v phis\n 2. \\<And>g v n phis p u.\n       \\<lbrakk>readVariableRecursive_readArgs_dom\n                 (Inr (g, v, n, phis, []));\n        (p, u) = readArgs g v n phis []\\<rbrakk>\n       \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v phis\n 3. \\<And>g v n phis m ms p u.\n       \\<lbrakk>readVariableRecursive_readArgs_dom\n                 (Inr (g, v, n, phis, m # ms));\n        \\<And>p u.\n           (p, u) = readArgs g v n phis ms \\<Longrightarrow>\n           phis_measure g v p \\<le> phis_measure g v phis;\n        \\<And>x xa y val p.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x;\n            (val, p) = readVariableRecursive g v m xa\\<rbrakk>\n           \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v xa;\n        (p, u) = readArgs g v n phis (m # ms)\\<rbrakk>\n       \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v phis", "case (1 g v n phis)"], ["proof (state)\nthis:\n  readVariableRecursive_readArgs_dom (Inl (g, v, n, phis))\n  \\<lbrakk>v \\<notin> defs g n; predecessors g n = ?x21.2 # ?x22.2;\n   ?x22.2 = [];\n   (?val2, ?p2) = readVariableRecursive g v ?x21.2 phis\\<rbrakk>\n  \\<Longrightarrow> phis_measure g v ?p2 \\<le> phis_measure g v phis\n  \\<lbrakk>v \\<notin> defs g n; predecessors g n = ?x21.2 # ?x22.2;\n   ?x22.2 = ?x21a2 # ?x22a2; Mapping.lookup phis (n, v) = None;\n   ?x2 = Mapping.update (n, v) [] phis;\n   (?p2, ?u2) = readArgs g v n ?x2 (?x21.2 # ?x21a2 # ?x22a2)\\<rbrakk>\n  \\<Longrightarrow> phis_measure g v ?p2 \\<le> phis_measure g v ?x2\n  (val, p) = readVariableRecursive g v n phis\n\ngoal (3 subgoals):\n 1. \\<And>g v n phis val p.\n       \\<lbrakk>readVariableRecursive_readArgs_dom (Inl (g, v, n, phis));\n        \\<And>x21 x22 val p.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n            x22 = []; (val, p) = readVariableRecursive g v x21 phis\\<rbrakk>\n           \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v phis;\n        \\<And>x21 x22 x21a x22a x p u.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n            x22 = x21a # x22a; Mapping.lookup phis (n, v) = None;\n            x = Mapping.update (n, v) [] phis;\n            (p, u) = readArgs g v n x (x21 # x21a # x22a)\\<rbrakk>\n           \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v x;\n        (val, p) = readVariableRecursive g v n phis\\<rbrakk>\n       \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v phis\n 2. \\<And>g v n phis p u.\n       \\<lbrakk>readVariableRecursive_readArgs_dom\n                 (Inr (g, v, n, phis, []));\n        (p, u) = readArgs g v n phis []\\<rbrakk>\n       \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v phis\n 3. \\<And>g v n phis m ms p u.\n       \\<lbrakk>readVariableRecursive_readArgs_dom\n                 (Inr (g, v, n, phis, m # ms));\n        \\<And>p u.\n           (p, u) = readArgs g v n phis ms \\<Longrightarrow>\n           phis_measure g v p \\<le> phis_measure g v phis;\n        \\<And>x xa y val p.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x;\n            (val, p) = readVariableRecursive g v m xa\\<rbrakk>\n           \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v xa;\n        (p, u) = readArgs g v n phis (m # ms)\\<rbrakk>\n       \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v phis", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. phis_measure g v p \\<le> phis_measure g v phis", "using \"1.IH\"(1,2) \"1.prems\""], ["proof (prove)\nusing this:\n  readVariableRecursive_readArgs_dom (Inl (g, v, n, phis))\n  \\<lbrakk>v \\<notin> defs g n; predecessors g n = ?x21.2 # ?x22.2;\n   ?x22.2 = [];\n   (?val2, ?p2) = readVariableRecursive g v ?x21.2 phis\\<rbrakk>\n  \\<Longrightarrow> phis_measure g v ?p2 \\<le> phis_measure g v phis\n  (val, p) = readVariableRecursive g v n phis\n\ngoal (1 subgoal):\n 1. phis_measure g v p \\<le> phis_measure g v phis", "apply (auto simp: readVariableRecursive.psimps Let_def phis_measure_update_le split: if_split_asm list.splits option.splits prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x21 x21a x22a x1 x2.\n       \\<lbrakk>readVariableRecursive_readArgs_dom (Inl (g, v, n, phis));\n        v \\<notin> defs g n; predecessors g n = x21 # x21a # x22a;\n        Mapping.lookup phis (n, v) = None;\n        readArgs g v n (Mapping.update (n, v) [] phis) (x21 # x21a # x22a) =\n        (x1, x2);\n        val = (v, n, PhiDef); p = Mapping.update (n, v) x2 x1\\<rbrakk>\n       \\<Longrightarrow> phis_measure g v (Mapping.update (n, v) x2 x1)\n                         \\<le> phis_measure g v phis", "apply (subgoal_tac \"phis_measure g v x1 \\<le> phis_measure g v (Mapping.update (n,v) [] phis)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x21a x22a x1 x2.\n       \\<lbrakk>readVariableRecursive_readArgs_dom (Inl (g, v, n, phis));\n        v \\<notin> defs g n; predecessors g n = x21 # x21a # x22a;\n        Mapping.lookup phis (n, v) = None;\n        readArgs g v n (Mapping.update (n, v) [] phis) (x21 # x21a # x22a) =\n        (x1, x2);\n        val = (v, n, PhiDef); p = Mapping.update (n, v) x2 x1;\n        phis_measure g v x1\n        \\<le> phis_measure g v (Mapping.update (n, v) [] phis)\\<rbrakk>\n       \\<Longrightarrow> phis_measure g v (Mapping.update (n, v) x2 x1)\n                         \\<le> phis_measure g v phis\n 2. \\<And>x21 x21a x22a x1 x2.\n       \\<lbrakk>readVariableRecursive_readArgs_dom (Inl (g, v, n, phis));\n        v \\<notin> defs g n; predecessors g n = x21 # x21a # x22a;\n        Mapping.lookup phis (n, v) = None;\n        readArgs g v n (Mapping.update (n, v) [] phis) (x21 # x21a # x22a) =\n        (x1, x2);\n        val = (v, n, PhiDef); p = Mapping.update (n, v) x2 x1\\<rbrakk>\n       \\<Longrightarrow> phis_measure g v x1\n                         \\<le> phis_measure g v\n                                (Mapping.update (n, v) [] phis)", "defer"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x21a x22a x1 x2.\n       \\<lbrakk>readVariableRecursive_readArgs_dom (Inl (g, v, n, phis));\n        v \\<notin> defs g n; predecessors g n = x21 # x21a # x22a;\n        Mapping.lookup phis (n, v) = None;\n        readArgs g v n (Mapping.update (n, v) [] phis) (x21 # x21a # x22a) =\n        (x1, x2);\n        val = (v, n, PhiDef); p = Mapping.update (n, v) x2 x1\\<rbrakk>\n       \\<Longrightarrow> phis_measure g v x1\n                         \\<le> phis_measure g v\n                                (Mapping.update (n, v) [] phis)\n 2. \\<And>x21 x21a x22a x1 x2.\n       \\<lbrakk>readVariableRecursive_readArgs_dom (Inl (g, v, n, phis));\n        v \\<notin> defs g n; predecessors g n = x21 # x21a # x22a;\n        Mapping.lookup phis (n, v) = None;\n        readArgs g v n (Mapping.update (n, v) [] phis) (x21 # x21a # x22a) =\n        (x1, x2);\n        val = (v, n, PhiDef); p = Mapping.update (n, v) x2 x1;\n        phis_measure g v x1\n        \\<le> phis_measure g v (Mapping.update (n, v) [] phis)\\<rbrakk>\n       \\<Longrightarrow> phis_measure g v (Mapping.update (n, v) x2 x1)\n                         \\<le> phis_measure g v phis", "apply (rule \"1.IH\"(3))"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x21 x21a x22a x1 x2.\n       \\<lbrakk>readVariableRecursive_readArgs_dom (Inl (g, v, n, phis));\n        v \\<notin> defs g n; predecessors g n = x21 # x21a # x22a;\n        Mapping.lookup phis (n, v) = None;\n        readArgs g v n (Mapping.update (n, v) [] phis) (x21 # x21a # x22a) =\n        (x1, x2);\n        val = (v, n, PhiDef); p = Mapping.update (n, v) x2 x1\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> defs g n\n 2. \\<And>x21 x21a x22a x1 x2.\n       \\<lbrakk>readVariableRecursive_readArgs_dom (Inl (g, v, n, phis));\n        v \\<notin> defs g n; predecessors g n = x21 # x21a # x22a;\n        Mapping.lookup phis (n, v) = None;\n        readArgs g v n (Mapping.update (n, v) [] phis) (x21 # x21a # x22a) =\n        (x1, x2);\n        val = (v, n, PhiDef); p = Mapping.update (n, v) x2 x1\\<rbrakk>\n       \\<Longrightarrow> predecessors g n =\n                         ?x21.70 x21 x21a x22a x1 x2 #\n                         ?x22.70 x21 x21a x22a x1 x2\n 3. \\<And>x21 x21a x22a x1 x2.\n       \\<lbrakk>readVariableRecursive_readArgs_dom (Inl (g, v, n, phis));\n        v \\<notin> defs g n; predecessors g n = x21 # x21a # x22a;\n        Mapping.lookup phis (n, v) = None;\n        readArgs g v n (Mapping.update (n, v) [] phis) (x21 # x21a # x22a) =\n        (x1, x2);\n        val = (v, n, PhiDef); p = Mapping.update (n, v) x2 x1\\<rbrakk>\n       \\<Longrightarrow> ?x22.70 x21 x21a x22a x1 x2 =\n                         ?x21a70 x21 x21a x22a x1 x2 #\n                         ?x22a70 x21 x21a x22a x1 x2\n 4. \\<And>x21 x21a x22a x1 x2.\n       \\<lbrakk>readVariableRecursive_readArgs_dom (Inl (g, v, n, phis));\n        v \\<notin> defs g n; predecessors g n = x21 # x21a # x22a;\n        Mapping.lookup phis (n, v) = None;\n        readArgs g v n (Mapping.update (n, v) [] phis) (x21 # x21a # x22a) =\n        (x1, x2);\n        val = (v, n, PhiDef); p = Mapping.update (n, v) x2 x1\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (n, v) = None\n 5. \\<And>x21 x21a x22a x1 x2.\n       \\<lbrakk>readVariableRecursive_readArgs_dom (Inl (g, v, n, phis));\n        v \\<notin> defs g n; predecessors g n = x21 # x21a # x22a;\n        Mapping.lookup phis (n, v) = None;\n        readArgs g v n (Mapping.update (n, v) [] phis) (x21 # x21a # x22a) =\n        (x1, x2);\n        val = (v, n, PhiDef); p = Mapping.update (n, v) x2 x1\\<rbrakk>\n       \\<Longrightarrow> Mapping.update (n, v) [] phis =\n                         Mapping.update (n, v) [] phis\n 6. \\<And>x21 x21a x22a x1 x2.\n       \\<lbrakk>readVariableRecursive_readArgs_dom (Inl (g, v, n, phis));\n        v \\<notin> defs g n; predecessors g n = x21 # x21a # x22a;\n        Mapping.lookup phis (n, v) = None;\n        readArgs g v n (Mapping.update (n, v) [] phis) (x21 # x21a # x22a) =\n        (x1, x2);\n        val = (v, n, PhiDef); p = Mapping.update (n, v) x2 x1\\<rbrakk>\n       \\<Longrightarrow> (x1, ?u70 x21 x21a x22a x1 x2) =\n                         readArgs g v n (Mapping.update (n, v) [] phis)\n                          (?x21.70 x21 x21a x22a x1 x2 #\n                           ?x21a70 x21 x21a x22a x1 x2 #\n                           ?x22a70 x21 x21a x22a x1 x2)\n 7. \\<And>x21 x21a x22a x1 x2.\n       \\<lbrakk>readVariableRecursive_readArgs_dom (Inl (g, v, n, phis));\n        v \\<notin> defs g n; predecessors g n = x21 # x21a # x22a;\n        Mapping.lookup phis (n, v) = None;\n        readArgs g v n (Mapping.update (n, v) [] phis) (x21 # x21a # x22a) =\n        (x1, x2);\n        val = (v, n, PhiDef); p = Mapping.update (n, v) x2 x1;\n        phis_measure g v x1\n        \\<le> phis_measure g v (Mapping.update (n, v) [] phis)\\<rbrakk>\n       \\<Longrightarrow> phis_measure g v (Mapping.update (n, v) x2 x1)\n                         \\<le> phis_measure g v phis", "apply (auto simp: phis_measure_update_le')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  phis_measure g v p \\<le> phis_measure g v phis\n\ngoal (2 subgoals):\n 1. \\<And>g v n phis p u.\n       \\<lbrakk>readVariableRecursive_readArgs_dom\n                 (Inr (g, v, n, phis, []));\n        (p, u) = readArgs g v n phis []\\<rbrakk>\n       \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v phis\n 2. \\<And>g v n phis m ms p u.\n       \\<lbrakk>readVariableRecursive_readArgs_dom\n                 (Inr (g, v, n, phis, m # ms));\n        \\<And>p u.\n           (p, u) = readArgs g v n phis ms \\<Longrightarrow>\n           phis_measure g v p \\<le> phis_measure g v phis;\n        \\<And>x xa y val p.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x;\n            (val, p) = readVariableRecursive g v m xa\\<rbrakk>\n           \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v xa;\n        (p, u) = readArgs g v n phis (m # ms)\\<rbrakk>\n       \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v phis", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g v n phis p u.\n       \\<lbrakk>readVariableRecursive_readArgs_dom\n                 (Inr (g, v, n, phis, []));\n        (p, u) = readArgs g v n phis []\\<rbrakk>\n       \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v phis\n 2. \\<And>g v n phis m ms p u.\n       \\<lbrakk>readVariableRecursive_readArgs_dom\n                 (Inr (g, v, n, phis, m # ms));\n        \\<And>p u.\n           (p, u) = readArgs g v n phis ms \\<Longrightarrow>\n           phis_measure g v p \\<le> phis_measure g v phis;\n        \\<And>x xa y val p.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x;\n            (val, p) = readVariableRecursive g v m xa\\<rbrakk>\n           \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v xa;\n        (p, u) = readArgs g v n phis (m # ms)\\<rbrakk>\n       \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v phis", "case (3 g v n m ms phis)"], ["proof (state)\nthis:\n  readVariableRecursive_readArgs_dom (Inr (g, v, n, m, ms # phis))\n  (?p2, ?u2) = readArgs g v n m phis \\<Longrightarrow>\n  phis_measure g v ?p2 \\<le> phis_measure g v m\n  \\<lbrakk>?x2 = readArgs g v n m phis; (?xa2, ?y2) = ?x2;\n   (?val2, ?p2) = readVariableRecursive g v ms ?xa2\\<rbrakk>\n  \\<Longrightarrow> phis_measure g v ?p2 \\<le> phis_measure g v ?xa2\n  (p, u) = readArgs g v n m (ms # phis)\n\ngoal (2 subgoals):\n 1. \\<And>g v n phis p u.\n       \\<lbrakk>readVariableRecursive_readArgs_dom\n                 (Inr (g, v, n, phis, []));\n        (p, u) = readArgs g v n phis []\\<rbrakk>\n       \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v phis\n 2. \\<And>g v n phis m ms p u.\n       \\<lbrakk>readVariableRecursive_readArgs_dom\n                 (Inr (g, v, n, phis, m # ms));\n        \\<And>p u.\n           (p, u) = readArgs g v n phis ms \\<Longrightarrow>\n           phis_measure g v p \\<le> phis_measure g v phis;\n        \\<And>x xa y val p.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x;\n            (val, p) = readVariableRecursive g v m xa\\<rbrakk>\n           \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v xa;\n        (p, u) = readArgs g v n phis (m # ms)\\<rbrakk>\n       \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v phis", "from \"3.IH\"(1) \"3.prems\""], ["proof (chain)\npicking this:\n  readVariableRecursive_readArgs_dom (Inr (g, v, n, m, ms # phis))\n  (p, u) = readArgs g v n m (ms # phis)", "show ?case"], ["proof (prove)\nusing this:\n  readVariableRecursive_readArgs_dom (Inr (g, v, n, m, ms # phis))\n  (p, u) = readArgs g v n m (ms # phis)\n\ngoal (1 subgoal):\n 1. phis_measure g v p \\<le> phis_measure g v m", "apply (auto simp: readArgs.psimps split: prod.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 a aa b.\n       \\<lbrakk>readVariableRecursive_readArgs_dom\n                 (Inr (g, v, n, m, ms # phis));\n        readArgs g v n m phis = (x1, x2);\n        readVariableRecursive g v ms x1 = ((a, aa, b), p);\n        u = (a, aa, b) # x2\\<rbrakk>\n       \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v m", "apply (rule le_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 a aa b.\n       \\<lbrakk>readVariableRecursive_readArgs_dom\n                 (Inr (g, v, n, m, ms # phis));\n        readArgs g v n m phis = (x1, x2);\n        readVariableRecursive g v ms x1 = ((a, aa, b), p);\n        u = (a, aa, b) # x2\\<rbrakk>\n       \\<Longrightarrow> phis_measure g v p \\<le> ?j22 x1 x2 a aa b\n 2. \\<And>x1 x2 a aa b.\n       \\<lbrakk>readVariableRecursive_readArgs_dom\n                 (Inr (g, v, n, m, ms # phis));\n        readArgs g v n m phis = (x1, x2);\n        readVariableRecursive g v ms x1 = ((a, aa, b), p);\n        u = (a, aa, b) # x2\\<rbrakk>\n       \\<Longrightarrow> ?j22 x1 x2 a aa b \\<le> phis_measure g v m", "apply (rule \"3.IH\"(3))"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x1 x2 a aa b.\n       \\<lbrakk>readVariableRecursive_readArgs_dom\n                 (Inr (g, v, n, m, ms # phis));\n        readArgs g v n m phis = (x1, x2);\n        readVariableRecursive g v ms x1 = ((a, aa, b), p);\n        u = (a, aa, b) # x2\\<rbrakk>\n       \\<Longrightarrow> ?x27 x1 x2 a aa b = readArgs g v n m phis\n 2. \\<And>x1 x2 a aa b.\n       \\<lbrakk>readVariableRecursive_readArgs_dom\n                 (Inr (g, v, n, m, ms # phis));\n        readArgs g v n m phis = (x1, x2);\n        readVariableRecursive g v ms x1 = ((a, aa, b), p);\n        u = (a, aa, b) # x2\\<rbrakk>\n       \\<Longrightarrow> (?xa27 x1 x2 a aa b, ?y27 x1 x2 a aa b) =\n                         ?x27 x1 x2 a aa b\n 3. \\<And>x1 x2 a aa b.\n       \\<lbrakk>readVariableRecursive_readArgs_dom\n                 (Inr (g, v, n, m, ms # phis));\n        readArgs g v n m phis = (x1, x2);\n        readVariableRecursive g v ms x1 = ((a, aa, b), p);\n        u = (a, aa, b) # x2\\<rbrakk>\n       \\<Longrightarrow> (?val27 x1 x2 a aa b, p) =\n                         readVariableRecursive g v ms (?xa27 x1 x2 a aa b)\n 4. \\<And>x1 x2 a aa b.\n       \\<lbrakk>readVariableRecursive_readArgs_dom\n                 (Inr (g, v, n, m, ms # phis));\n        readArgs g v n m phis = (x1, x2);\n        readVariableRecursive g v ms x1 = ((a, aa, b), p);\n        u = (a, aa, b) # x2\\<rbrakk>\n       \\<Longrightarrow> phis_measure g v (?xa27 x1 x2 a aa b)\n                         \\<le> phis_measure g v m", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 a aa b.\n       \\<lbrakk>readVariableRecursive_readArgs_dom\n                 (Inr (g, v, n, m, ms # phis));\n        readArgs g v n m phis = (x1, x2);\n        readVariableRecursive g v ms x1 = ((a, aa, b), p);\n        u = (a, aa, b) # x2\\<rbrakk>\n       \\<Longrightarrow> phis_measure g v x1 \\<le> phis_measure g v m", "apply (rule \"3.IH\"(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 a aa b.\n       \\<lbrakk>readVariableRecursive_readArgs_dom\n                 (Inr (g, v, n, m, ms # phis));\n        readArgs g v n m phis = (x1, x2);\n        readVariableRecursive g v ms x1 = ((a, aa, b), p);\n        u = (a, aa, b) # x2\\<rbrakk>\n       \\<Longrightarrow> (x1, ?u40 x1 x2 a aa b) = readArgs g v n m phis", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  phis_measure g v p \\<le> phis_measure g v m\n\ngoal (1 subgoal):\n 1. \\<And>g v n phis p u.\n       \\<lbrakk>readVariableRecursive_readArgs_dom\n                 (Inr (g, v, n, phis, []));\n        (p, u) = readArgs g v n phis []\\<rbrakk>\n       \\<Longrightarrow> phis_measure g v p \\<le> phis_measure g v phis", "qed (auto simp: readArgs.psimps split: prod.splits)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All readVariableRecursive_readArgs_dom", "apply (relation \"measures [\n    \\<lambda>args. let (g,v,phis) = case args of Inl((g,v,n,phis)) \\<Rightarrow> (g,v,phis) | Inr((g,v,n,phis,ms)) \\<Rightarrow> (g,v,phis) in\n      phis_measure g v phis,\n    \\<lambda>args. case args of Inl(_) \\<Rightarrow> 0 | Inr((g,v,n,phis,ms)) \\<Rightarrow> length ms,\n    \\<lambda>args. let (g,n) = case args of Inl((g,v,n,phis)) \\<Rightarrow> (g,n) | Inr((g,v,n,ms,phis)) \\<Rightarrow> (g,n) in\n      shortestPath g n\n    ]\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. wf (measures\n         [\\<lambda>args.\n             let (g, v, phis) =\n                   case args of\n                   Inl (g, v, n, phis) \\<Rightarrow> (g, v, phis)\n                   | Inr (g, v, n, phis, ms) \\<Rightarrow> (g, v, phis)\n             in phis_measure g v phis,\n          \\<lambda>args.\n             case args of Inl x \\<Rightarrow> 0\n             | Inr (g, v, n, phis, x) \\<Rightarrow> length x,\n          \\<lambda>args.\n             let (x, y) =\n                   case args of Inl (g, v, n, phis) \\<Rightarrow> (g, n)\n                   | Inr (g, v, n, ms, phis) \\<Rightarrow> (g, n)\n             in shortestPath x y])\n 2. \\<And>g v n phis x21 x22.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n        x22 = []\\<rbrakk>\n       \\<Longrightarrow> (Inl (g, v, x21, phis), Inl (g, v, n, phis))\n                         \\<in> measures\n                                [\\<lambda>args.\n                                    let (g, v, phis) =\n    case args of Inl (g, v, n, phis) \\<Rightarrow> (g, v, phis)\n    | Inr (g, v, n, phis, ms) \\<Rightarrow> (g, v, phis)\n                                    in phis_measure g v phis,\n                                 \\<lambda>args.\n                                    case args of Inl x \\<Rightarrow> 0\n                                    | Inr (g, v, n, phis, x) \\<Rightarrow>\n  length x,\n                                 \\<lambda>args.\n                                    let (x, y) =\n    case args of Inl (g, v, n, phis) \\<Rightarrow> (g, n)\n    | Inr (g, v, n, ms, phis) \\<Rightarrow> (g, n)\n                                    in shortestPath x y]\n 3. \\<And>g v n phis x21 x22 x21a x22a x.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n        x22 = x21a # x22a; Mapping.lookup phis (n, v) = None;\n        x = Mapping.update (n, v) [] phis\\<rbrakk>\n       \\<Longrightarrow> (Inr (g, v, n, x, x21 # x21a # x22a),\n                          Inl (g, v, n, phis))\n                         \\<in> measures\n                                [\\<lambda>args.\n                                    let (g, v, phis) =\n    case args of Inl (g, v, n, phis) \\<Rightarrow> (g, v, phis)\n    | Inr (g, v, n, phis, ms) \\<Rightarrow> (g, v, phis)\n                                    in phis_measure g v phis,\n                                 \\<lambda>args.\n                                    case args of Inl x \\<Rightarrow> 0\n                                    | Inr (g, v, n, phis, x) \\<Rightarrow>\n  length x,\n                                 \\<lambda>args.\n                                    let (x, y) =\n    case args of Inl (g, v, n, phis) \\<Rightarrow> (g, n)\n    | Inr (g, v, n, ms, phis) \\<Rightarrow> (g, n)\n                                    in shortestPath x y]\n 4. \\<And>g v n phis m ms.\n       (Inr (g, v, n, phis, ms), Inr (g, v, n, phis, m # ms))\n       \\<in> measures\n              [\\<lambda>args.\n                  let (g, v, phis) =\n                        case args of\n                        Inl (g, v, n, phis) \\<Rightarrow> (g, v, phis)\n                        | Inr (g, v, n, phis, ms) \\<Rightarrow> (g, v, phis)\n                  in phis_measure g v phis,\n               \\<lambda>args.\n                  case args of Inl x \\<Rightarrow> 0\n                  | Inr (g, v, n, phis, x) \\<Rightarrow> length x,\n               \\<lambda>args.\n                  let (x, y) =\n                        case args of\n                        Inl (g, v, n, phis) \\<Rightarrow> (g, n)\n                        | Inr (g, v, n, ms, phis) \\<Rightarrow> (g, n)\n                  in shortestPath x y]\n 5. \\<And>g v n phis m ms x xa y.\n       \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x;\n        readVariableRecursive_readArgs_dom\n         (Inr (g, v, n, phis, ms))\\<rbrakk>\n       \\<Longrightarrow> (Inl (g, v, m, xa), Inr (g, v, n, phis, m # ms))\n                         \\<in> measures\n                                [\\<lambda>args.\n                                    let (g, v, phis) =\n    case args of Inl (g, v, n, phis) \\<Rightarrow> (g, v, phis)\n    | Inr (g, v, n, phis, ms) \\<Rightarrow> (g, v, phis)\n                                    in phis_measure g v phis,\n                                 \\<lambda>args.\n                                    case args of Inl x \\<Rightarrow> 0\n                                    | Inr (g, v, n, phis, x) \\<Rightarrow>\n  length x,\n                                 \\<lambda>args.\n                                    let (x, y) =\n    case args of Inl (g, v, n, phis) \\<Rightarrow> (g, n)\n    | Inr (g, v, n, ms, phis) \\<Rightarrow> (g, n)\n                                    in shortestPath x y]", "apply (auto intro: shortestPath_single_predecessor)[2]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>g v n phis x21 x22 x21a x22a x.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n        x22 = x21a # x22a; Mapping.lookup phis (n, v) = None;\n        x = Mapping.update (n, v) [] phis\\<rbrakk>\n       \\<Longrightarrow> (Inr (g, v, n, x, x21 # x21a # x22a),\n                          Inl (g, v, n, phis))\n                         \\<in> measures\n                                [\\<lambda>args.\n                                    let (g, v, phis) =\n    case args of Inl (g, v, n, phis) \\<Rightarrow> (g, v, phis)\n    | Inr (g, v, n, phis, ms) \\<Rightarrow> (g, v, phis)\n                                    in phis_measure g v phis,\n                                 \\<lambda>args.\n                                    case args of Inl x \\<Rightarrow> 0\n                                    | Inr (g, v, n, phis, x) \\<Rightarrow>\n  length x,\n                                 \\<lambda>args.\n                                    let (x, y) =\n    case args of Inl (g, v, n, phis) \\<Rightarrow> (g, n)\n    | Inr (g, v, n, ms, phis) \\<Rightarrow> (g, n)\n                                    in shortestPath x y]\n 2. \\<And>g v n phis m ms.\n       (Inr (g, v, n, phis, ms), Inr (g, v, n, phis, m # ms))\n       \\<in> measures\n              [\\<lambda>args.\n                  let (g, v, phis) =\n                        case args of\n                        Inl (g, v, n, phis) \\<Rightarrow> (g, v, phis)\n                        | Inr (g, v, n, phis, ms) \\<Rightarrow> (g, v, phis)\n                  in phis_measure g v phis,\n               \\<lambda>args.\n                  case args of Inl x \\<Rightarrow> 0\n                  | Inr (g, v, n, phis, x) \\<Rightarrow> length x,\n               \\<lambda>args.\n                  let (x, y) =\n                        case args of\n                        Inl (g, v, n, phis) \\<Rightarrow> (g, n)\n                        | Inr (g, v, n, ms, phis) \\<Rightarrow> (g, n)\n                  in shortestPath x y]\n 3. \\<And>g v n phis m ms x xa y.\n       \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x;\n        readVariableRecursive_readArgs_dom\n         (Inr (g, v, n, phis, ms))\\<rbrakk>\n       \\<Longrightarrow> (Inl (g, v, m, xa), Inr (g, v, n, phis, m # ms))\n                         \\<in> measures\n                                [\\<lambda>args.\n                                    let (g, v, phis) =\n    case args of Inl (g, v, n, phis) \\<Rightarrow> (g, v, phis)\n    | Inr (g, v, n, phis, ms) \\<Rightarrow> (g, v, phis)\n                                    in phis_measure g v phis,\n                                 \\<lambda>args.\n                                    case args of Inl x \\<Rightarrow> 0\n                                    | Inr (g, v, n, phis, x) \\<Rightarrow>\n  length x,\n                                 \\<lambda>args.\n                                    let (x, y) =\n    case args of Inl (g, v, n, phis) \\<Rightarrow> (g, n)\n    | Inr (g, v, n, ms, phis) \\<Rightarrow> (g, n)\n                                    in shortestPath x y]", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>g v n phis x21 x21a x22a.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x21a # x22a;\n        Mapping.lookup phis (n, v) = None\\<rbrakk>\n       \\<Longrightarrow> phis_measure g v (Mapping.update (n, v) [] phis)\n                         < phis_measure g v phis\n 2. \\<And>g v n phis m ms.\n       (Inr (g, v, n, phis, ms), Inr (g, v, n, phis, m # ms))\n       \\<in> measures\n              [\\<lambda>args.\n                  let (g, v, phis) =\n                        case args of\n                        Inl (g, v, n, phis) \\<Rightarrow> (g, v, phis)\n                        | Inr (g, v, n, phis, ms) \\<Rightarrow> (g, v, phis)\n                  in phis_measure g v phis,\n               \\<lambda>args.\n                  case args of Inl x \\<Rightarrow> 0\n                  | Inr (g, v, n, phis, x) \\<Rightarrow> length x,\n               \\<lambda>args.\n                  let (x, y) =\n                        case args of\n                        Inl (g, v, n, phis) \\<Rightarrow> (g, n)\n                        | Inr (g, v, n, ms, phis) \\<Rightarrow> (g, n)\n                  in shortestPath x y]\n 3. \\<And>g v n phis m ms x xa y.\n       \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x;\n        readVariableRecursive_readArgs_dom\n         (Inr (g, v, n, phis, ms))\\<rbrakk>\n       \\<Longrightarrow> (Inl (g, v, m, xa), Inr (g, v, n, phis, m # ms))\n                         \\<in> measures\n                                [\\<lambda>args.\n                                    let (g, v, phis) =\n    case args of Inl (g, v, n, phis) \\<Rightarrow> (g, v, phis)\n    | Inr (g, v, n, phis, ms) \\<Rightarrow> (g, v, phis)\n                                    in phis_measure g v phis,\n                                 \\<lambda>args.\n                                    case args of Inl x \\<Rightarrow> 0\n                                    | Inr (g, v, n, phis, x) \\<Rightarrow>\n  length x,\n                                 \\<lambda>args.\n                                    let (x, y) =\n    case args of Inl (g, v, n, phis) \\<Rightarrow> (g, n)\n    | Inr (g, v, n, ms, phis) \\<Rightarrow> (g, n)\n                                    in shortestPath x y]", "apply (rule_tac x=n in length_filter_less2)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>g v n phis x21 x21a x22a.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x21a # x22a;\n        Mapping.lookup phis (n, v) = None\\<rbrakk>\n       \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 2. \\<And>g v n phis x21 x21a x22a.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x21a # x22a;\n        Mapping.lookup phis (n, v) = None\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup (Mapping.update (n, v) [] phis)\n                          (n, v) \\<noteq>\n                         None\n 3. \\<And>g v n phis x21 x21a x22a.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x21a # x22a;\n        Mapping.lookup phis (n, v) = None\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (n, v) = None\n 4. \\<And>g v n phis x21 x21a x22a x.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x21a # x22a;\n        Mapping.lookup phis (n, v) = None;\n        Mapping.lookup (Mapping.update (n, v) [] phis) (x, v) =\n        None\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (x, v) = None\n 5. \\<And>g v n phis m ms.\n       (Inr (g, v, n, phis, ms), Inr (g, v, n, phis, m # ms))\n       \\<in> measures\n              [\\<lambda>args.\n                  let (g, v, phis) =\n                        case args of\n                        Inl (g, v, n, phis) \\<Rightarrow> (g, v, phis)\n                        | Inr (g, v, n, phis, ms) \\<Rightarrow> (g, v, phis)\n                  in phis_measure g v phis,\n               \\<lambda>args.\n                  case args of Inl x \\<Rightarrow> 0\n                  | Inr (g, v, n, phis, x) \\<Rightarrow> length x,\n               \\<lambda>args.\n                  let (x, y) =\n                        case args of\n                        Inl (g, v, n, phis) \\<Rightarrow> (g, n)\n                        | Inr (g, v, n, ms, phis) \\<Rightarrow> (g, n)\n                  in shortestPath x y]\n 6. \\<And>g v n phis m ms x xa y.\n       \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x;\n        readVariableRecursive_readArgs_dom\n         (Inr (g, v, n, phis, ms))\\<rbrakk>\n       \\<Longrightarrow> (Inl (g, v, m, xa), Inr (g, v, n, phis, m # ms))\n                         \\<in> measures\n                                [\\<lambda>args.\n                                    let (g, v, phis) =\n    case args of Inl (g, v, n, phis) \\<Rightarrow> (g, v, phis)\n    | Inr (g, v, n, phis, ms) \\<Rightarrow> (g, v, phis)\n                                    in phis_measure g v phis,\n                                 \\<lambda>args.\n                                    case args of Inl x \\<Rightarrow> 0\n                                    | Inr (g, v, n, phis, x) \\<Rightarrow>\n  length x,\n                                 \\<lambda>args.\n                                    let (x, y) =\n    case args of Inl (g, v, n, phis) \\<Rightarrow> (g, n)\n    | Inr (g, v, n, ms, phis) \\<Rightarrow> (g, n)\n                                    in shortestPath x y]", "apply (rule successor_in_\\<alpha>n; auto)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>g v n phis x21 x21a x22a.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x21a # x22a;\n        Mapping.lookup phis (n, v) = None\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup (Mapping.update (n, v) [] phis)\n                          (n, v) \\<noteq>\n                         None\n 2. \\<And>g v n phis x21 x21a x22a.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x21a # x22a;\n        Mapping.lookup phis (n, v) = None\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (n, v) = None\n 3. \\<And>g v n phis x21 x21a x22a x.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x21a # x22a;\n        Mapping.lookup phis (n, v) = None;\n        Mapping.lookup (Mapping.update (n, v) [] phis) (x, v) =\n        None\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (x, v) = None\n 4. \\<And>g v n phis m ms.\n       (Inr (g, v, n, phis, ms), Inr (g, v, n, phis, m # ms))\n       \\<in> measures\n              [\\<lambda>args.\n                  let (g, v, phis) =\n                        case args of\n                        Inl (g, v, n, phis) \\<Rightarrow> (g, v, phis)\n                        | Inr (g, v, n, phis, ms) \\<Rightarrow> (g, v, phis)\n                  in phis_measure g v phis,\n               \\<lambda>args.\n                  case args of Inl x \\<Rightarrow> 0\n                  | Inr (g, v, n, phis, x) \\<Rightarrow> length x,\n               \\<lambda>args.\n                  let (x, y) =\n                        case args of\n                        Inl (g, v, n, phis) \\<Rightarrow> (g, n)\n                        | Inr (g, v, n, ms, phis) \\<Rightarrow> (g, n)\n                  in shortestPath x y]\n 5. \\<And>g v n phis m ms x xa y.\n       \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x;\n        readVariableRecursive_readArgs_dom\n         (Inr (g, v, n, phis, ms))\\<rbrakk>\n       \\<Longrightarrow> (Inl (g, v, m, xa), Inr (g, v, n, phis, m # ms))\n                         \\<in> measures\n                                [\\<lambda>args.\n                                    let (g, v, phis) =\n    case args of Inl (g, v, n, phis) \\<Rightarrow> (g, v, phis)\n    | Inr (g, v, n, phis, ms) \\<Rightarrow> (g, v, phis)\n                                    in phis_measure g v phis,\n                                 \\<lambda>args.\n                                    case args of Inl x \\<Rightarrow> 0\n                                    | Inr (g, v, n, phis, x) \\<Rightarrow>\n  length x,\n                                 \\<lambda>args.\n                                    let (x, y) =\n    case args of Inl (g, v, n, phis) \\<Rightarrow> (g, n)\n    | Inr (g, v, n, ms, phis) \\<Rightarrow> (g, n)\n                                    in shortestPath x y]", "apply (auto simp: lookup_update)[2]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>g v n phis x21 x21a x22a x.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x21a # x22a;\n        Mapping.lookup phis (n, v) = None;\n        Mapping.lookup (Mapping.update (n, v) [] phis) (x, v) =\n        None\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (x, v) = None\n 2. \\<And>g v n phis m ms.\n       (Inr (g, v, n, phis, ms), Inr (g, v, n, phis, m # ms))\n       \\<in> measures\n              [\\<lambda>args.\n                  let (g, v, phis) =\n                        case args of\n                        Inl (g, v, n, phis) \\<Rightarrow> (g, v, phis)\n                        | Inr (g, v, n, phis, ms) \\<Rightarrow> (g, v, phis)\n                  in phis_measure g v phis,\n               \\<lambda>args.\n                  case args of Inl x \\<Rightarrow> 0\n                  | Inr (g, v, n, phis, x) \\<Rightarrow> length x,\n               \\<lambda>args.\n                  let (x, y) =\n                        case args of\n                        Inl (g, v, n, phis) \\<Rightarrow> (g, n)\n                        | Inr (g, v, n, ms, phis) \\<Rightarrow> (g, n)\n                  in shortestPath x y]\n 3. \\<And>g v n phis m ms x xa y.\n       \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x;\n        readVariableRecursive_readArgs_dom\n         (Inr (g, v, n, phis, ms))\\<rbrakk>\n       \\<Longrightarrow> (Inl (g, v, m, xa), Inr (g, v, n, phis, m # ms))\n                         \\<in> measures\n                                [\\<lambda>args.\n                                    let (g, v, phis) =\n    case args of Inl (g, v, n, phis) \\<Rightarrow> (g, v, phis)\n    | Inr (g, v, n, phis, ms) \\<Rightarrow> (g, v, phis)\n                                    in phis_measure g v phis,\n                                 \\<lambda>args.\n                                    case args of Inl x \\<Rightarrow> 0\n                                    | Inr (g, v, n, phis, x) \\<Rightarrow>\n  length x,\n                                 \\<lambda>args.\n                                    let (x, y) =\n    case args of Inl (g, v, n, phis) \\<Rightarrow> (g, n)\n    | Inr (g, v, n, ms, phis) \\<Rightarrow> (g, n)\n                                    in shortestPath x y]", "apply (case_tac \"x=n\"; auto simp: lookup_update_neq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g v n phis m ms.\n       (Inr (g, v, n, phis, ms), Inr (g, v, n, phis, m # ms))\n       \\<in> measures\n              [\\<lambda>args.\n                  let (g, v, phis) =\n                        case args of\n                        Inl (g, v, n, phis) \\<Rightarrow> (g, v, phis)\n                        | Inr (g, v, n, phis, ms) \\<Rightarrow> (g, v, phis)\n                  in phis_measure g v phis,\n               \\<lambda>args.\n                  case args of Inl x \\<Rightarrow> 0\n                  | Inr (g, v, n, phis, x) \\<Rightarrow> length x,\n               \\<lambda>args.\n                  let (x, y) =\n                        case args of\n                        Inl (g, v, n, phis) \\<Rightarrow> (g, n)\n                        | Inr (g, v, n, ms, phis) \\<Rightarrow> (g, n)\n                  in shortestPath x y]\n 2. \\<And>g v n phis m ms x xa y.\n       \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x;\n        readVariableRecursive_readArgs_dom\n         (Inr (g, v, n, phis, ms))\\<rbrakk>\n       \\<Longrightarrow> (Inl (g, v, m, xa), Inr (g, v, n, phis, m # ms))\n                         \\<in> measures\n                                [\\<lambda>args.\n                                    let (g, v, phis) =\n    case args of Inl (g, v, n, phis) \\<Rightarrow> (g, v, phis)\n    | Inr (g, v, n, phis, ms) \\<Rightarrow> (g, v, phis)\n                                    in phis_measure g v phis,\n                                 \\<lambda>args.\n                                    case args of Inl x \\<Rightarrow> 0\n                                    | Inr (g, v, n, phis, x) \\<Rightarrow>\n  length x,\n                                 \\<lambda>args.\n                                    let (x, y) =\n    case args of Inl (g, v, n, phis) \\<Rightarrow> (g, n)\n    | Inr (g, v, n, ms, phis) \\<Rightarrow> (g, n)\n                                    in shortestPath x y]", "apply (auto dest: readArgs_phis_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare readVariableRecursive.simps[simp del] readArgs.simps[simp del]"], ["", "lemma fst_readVariableRecursive:\n    assumes \"n \\<in> set (\\<alpha>n g)\"\n    shows \"fst (readVariableRecursive g v n phis) = lookupDef g n v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (readVariableRecursive g v n phis) = lookupDef g n v", "using assms"], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. fst (readVariableRecursive g v n phis) = lookupDef g n v", "apply (induction rule: lookupDef_induct[where v=v])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<in> defs g n;\n        lookupDef g n v = (v, n, SimpleDef)\\<rbrakk>\n       \\<Longrightarrow> fst (readVariableRecursive g v n phis) =\n                         lookupDef g n v\n 2. \\<And>n.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        lookupDef g n v = (v, n, PhiDef)\\<rbrakk>\n       \\<Longrightarrow> fst (readVariableRecursive g v n phis) =\n                         lookupDef g n v\n 3. \\<And>n m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n        fst (readVariableRecursive g v m phis) = lookupDef g m v\\<rbrakk>\n       \\<Longrightarrow> fst (readVariableRecursive g v n phis) =\n                         lookupDef g n v", "apply (simp add: readVariableRecursive.simps)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       \\<lbrakk>n \\<in> set (\\<alpha>n g); v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        lookupDef g n v = (v, n, PhiDef)\\<rbrakk>\n       \\<Longrightarrow> fst (readVariableRecursive g v n phis) =\n                         lookupDef g n v\n 2. \\<And>n m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n        fst (readVariableRecursive g v m phis) = lookupDef g m v\\<rbrakk>\n       \\<Longrightarrow> fst (readVariableRecursive g v n phis) =\n                         lookupDef g n v", "apply (simp add: readVariableRecursive.simps; auto simp: split_def Let_def split: list.split option.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n        m \\<in> set (\\<alpha>n g); lookupDef g n v = lookupDef g m v;\n        fst (readVariableRecursive g v m phis) = lookupDef g m v\\<rbrakk>\n       \\<Longrightarrow> fst (readVariableRecursive g v n phis) =\n                         lookupDef g n v", "apply (auto simp add: readVariableRecursive.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"phis'_aux g v ns (phis:: ('node,'var) sparse_phis) \\<equiv> Mapping.Mapping (\\<lambda>(m,v\\<^sub>2).\n    (if v\\<^sub>2=v \\<and> m \\<in> \\<Union>(phiDefNodes_aux g v [n \\<leftarrow> \\<alpha>n g. (n,v) \\<notin> Mapping.keys phis] ` ns) \\<and> v \\<in> vars g then Some (map (\\<lambda>m. lookupDef g m v) (predecessors g m)) else (Mapping.lookup phis (m,v\\<^sub>2))))\""], ["", "lemma phis'_aux_keys_super: \"Mapping.keys (phis'_aux g v ns phis) \\<supseteq> Mapping.keys phis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.keys phis \\<subseteq> Mapping.keys (phis'_aux g v ns phis)", "by (auto simp: keys_dom_lookup phis'_aux_def)"], ["", "lemma phiDefNodes_aux_in_unvisited:\n    shows \"phiDefNodes_aux g v un n \\<subseteq> set un\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phiDefNodes_aux g v un n \\<subseteq> set un", "proof (induction un arbitrary: n rule:removeAll_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs n.\n       (\\<And>x n.\n           x \\<in> set xs \\<Longrightarrow>\n           phiDefNodes_aux g v (removeAll x xs) n\n           \\<subseteq> set (removeAll x xs)) \\<Longrightarrow>\n       phiDefNodes_aux g v xs n \\<subseteq> set xs", "case (1 un)"], ["proof (state)\nthis:\n  ?x2 \\<in> set un \\<Longrightarrow>\n  phiDefNodes_aux g v (removeAll ?x2 un) ?n2\n  \\<subseteq> set (removeAll ?x2 un)\n\ngoal (1 subgoal):\n 1. \\<And>xs n.\n       (\\<And>x n.\n           x \\<in> set xs \\<Longrightarrow>\n           phiDefNodes_aux g v (removeAll x xs) n\n           \\<subseteq> set (removeAll x xs)) \\<Longrightarrow>\n       phiDefNodes_aux g v xs n \\<subseteq> set xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. phiDefNodes_aux g v un n \\<subseteq> set un", "apply (simp only: phiDefNodes_aux.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if n \\<notin> set un \\<or> v \\<in> defs g n then {}\n     else fold (\\<union>)\n           (map (phiDefNodes_aux g v (removeAll n un)) (predecessors g n))\n           (if length (predecessors g n) \\<noteq> 1 then {n} else {}))\n    \\<subseteq> set un", "apply (auto elim!: fold_union_elem)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>length (predecessors g n) = Suc 0;\n        x \\<in> phiDefNodes_aux g v (removeAll n un) xa; n \\<in> set un;\n        v \\<notin> defs g n; xa \\<in> set (predecessors g n)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set un\n 2. \\<And>x xa.\n       \\<lbrakk>length (predecessors g n) \\<noteq> Suc 0;\n        x \\<in> phiDefNodes_aux g v (removeAll n un) xa; n \\<in> set un;\n        v \\<notin> defs g n; xa \\<in> set (predecessors g n)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set un", "apply (rename_tac m n')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m n'.\n       \\<lbrakk>length (predecessors g n) = Suc 0;\n        m \\<in> phiDefNodes_aux g v (removeAll n un) n'; n \\<in> set un;\n        v \\<notin> defs g n; n' \\<in> set (predecessors g n)\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set un\n 2. \\<And>x xa.\n       \\<lbrakk>length (predecessors g n) \\<noteq> Suc 0;\n        x \\<in> phiDefNodes_aux g v (removeAll n un) xa; n \\<in> set un;\n        v \\<notin> defs g n; xa \\<in> set (predecessors g n)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set un", "apply (drule_tac x2=n and n2=n' in 1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m n'.\n       \\<lbrakk>length (predecessors g n) = Suc 0;\n        m \\<in> phiDefNodes_aux g v (removeAll n un) n';\n        v \\<notin> defs g n; n' \\<in> set (predecessors g n);\n        phiDefNodes_aux g v (removeAll n un) n'\n        \\<subseteq> set (removeAll n un)\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set un\n 2. \\<And>x xa.\n       \\<lbrakk>length (predecessors g n) \\<noteq> Suc 0;\n        x \\<in> phiDefNodes_aux g v (removeAll n un) xa; n \\<in> set un;\n        v \\<notin> defs g n; xa \\<in> set (predecessors g n)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set un", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>length (predecessors g n) \\<noteq> Suc 0;\n        x \\<in> phiDefNodes_aux g v (removeAll n un) xa; n \\<in> set un;\n        v \\<notin> defs g n; xa \\<in> set (predecessors g n)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set un", "apply (rename_tac m n')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m n'.\n       \\<lbrakk>length (predecessors g n) \\<noteq> Suc 0;\n        m \\<in> phiDefNodes_aux g v (removeAll n un) n'; n \\<in> set un;\n        v \\<notin> defs g n; n' \\<in> set (predecessors g n)\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set un", "apply (drule_tac x2=n and n2=n' in 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m n'.\n       \\<lbrakk>length (predecessors g n) \\<noteq> Suc 0;\n        m \\<in> phiDefNodes_aux g v (removeAll n un) n';\n        v \\<notin> defs g n; n' \\<in> set (predecessors g n);\n        phiDefNodes_aux g v (removeAll n un) n'\n        \\<subseteq> set (removeAll n un)\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set un", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  phiDefNodes_aux g v un n \\<subseteq> set un\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma phiDefNodes_aux_unvisited_monotonic:\n    assumes \"set un \\<subseteq> set un'\"\n    shows \"phiDefNodes_aux g v un n \\<subseteq> phiDefNodes_aux g v un' n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phiDefNodes_aux g v un n \\<subseteq> phiDefNodes_aux g v un' n", "using assms"], ["proof (prove)\nusing this:\n  set un \\<subseteq> set un'\n\ngoal (1 subgoal):\n 1. phiDefNodes_aux g v un n \\<subseteq> phiDefNodes_aux g v un' n", "proof (induction un arbitrary: un' n rule:removeAll_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs un' n.\n       \\<lbrakk>\\<And>x un' n.\n                   \\<lbrakk>x \\<in> set xs;\n                    set (removeAll x xs) \\<subseteq> set un'\\<rbrakk>\n                   \\<Longrightarrow> phiDefNodes_aux g v (removeAll x xs) n\n                                     \\<subseteq> phiDefNodes_aux g v un' n;\n        set xs \\<subseteq> set un'\\<rbrakk>\n       \\<Longrightarrow> phiDefNodes_aux g v xs n\n                         \\<subseteq> phiDefNodes_aux g v un' n", "case (1 un)"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<in> set un;\n   set (removeAll ?x2 un) \\<subseteq> set ?un'2\\<rbrakk>\n  \\<Longrightarrow> phiDefNodes_aux g v (removeAll ?x2 un) ?n2\n                    \\<subseteq> phiDefNodes_aux g v ?un'2 ?n2\n  set un \\<subseteq> set un'\n\ngoal (1 subgoal):\n 1. \\<And>xs un' n.\n       \\<lbrakk>\\<And>x un' n.\n                   \\<lbrakk>x \\<in> set xs;\n                    set (removeAll x xs) \\<subseteq> set un'\\<rbrakk>\n                   \\<Longrightarrow> phiDefNodes_aux g v (removeAll x xs) n\n                                     \\<subseteq> phiDefNodes_aux g v un' n;\n        set xs \\<subseteq> set un'\\<rbrakk>\n       \\<Longrightarrow> phiDefNodes_aux g v xs n\n                         \\<subseteq> phiDefNodes_aux g v un' n", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<in> set un;\n   set (removeAll ?x2 un) \\<subseteq> set ?un'2\\<rbrakk>\n  \\<Longrightarrow> phiDefNodes_aux g v (removeAll ?x2 un) ?n2\n                    \\<subseteq> phiDefNodes_aux g v ?un'2 ?n2\n  set un \\<subseteq> set un'\n\ngoal (1 subgoal):\n 1. \\<And>xs un' n.\n       \\<lbrakk>\\<And>x un' n.\n                   \\<lbrakk>x \\<in> set xs;\n                    set (removeAll x xs) \\<subseteq> set un'\\<rbrakk>\n                   \\<Longrightarrow> phiDefNodes_aux g v (removeAll x xs) n\n                                     \\<subseteq> phiDefNodes_aux g v un' n;\n        set xs \\<subseteq> set un'\\<rbrakk>\n       \\<Longrightarrow> phiDefNodes_aux g v xs n\n                         \\<subseteq> phiDefNodes_aux g v un' n", "fix m A"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs un' n.\n       \\<lbrakk>\\<And>x un' n.\n                   \\<lbrakk>x \\<in> set xs;\n                    set (removeAll x xs) \\<subseteq> set un'\\<rbrakk>\n                   \\<Longrightarrow> phiDefNodes_aux g v (removeAll x xs) n\n                                     \\<subseteq> phiDefNodes_aux g v un' n;\n        set xs \\<subseteq> set un'\\<rbrakk>\n       \\<Longrightarrow> phiDefNodes_aux g v xs n\n                         \\<subseteq> phiDefNodes_aux g v un' n", "assume \"n \\<in> set un\""], ["proof (state)\nthis:\n  n \\<in> set un\n\ngoal (1 subgoal):\n 1. \\<And>xs un' n.\n       \\<lbrakk>\\<And>x un' n.\n                   \\<lbrakk>x \\<in> set xs;\n                    set (removeAll x xs) \\<subseteq> set un'\\<rbrakk>\n                   \\<Longrightarrow> phiDefNodes_aux g v (removeAll x xs) n\n                                     \\<subseteq> phiDefNodes_aux g v un' n;\n        set xs \\<subseteq> set un'\\<rbrakk>\n       \\<Longrightarrow> phiDefNodes_aux g v xs n\n                         \\<subseteq> phiDefNodes_aux g v un' n", "hence a: \"\\<And>m. phiDefNodes_aux g v (removeAll n un) m \\<subseteq> phiDefNodes_aux g v (removeAll n un') m\""], ["proof (prove)\nusing this:\n  n \\<in> set un\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       phiDefNodes_aux g v (removeAll n un) m\n       \\<subseteq> phiDefNodes_aux g v (removeAll n un') m", "apply (rule 1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m. set (removeAll n un) \\<subseteq> set (removeAll n un')", "using 1(2)"], ["proof (prove)\nusing this:\n  set un \\<subseteq> set un'\n\ngoal (1 subgoal):\n 1. \\<And>m. set (removeAll n un) \\<subseteq> set (removeAll n un')", "by auto"], ["proof (state)\nthis:\n  phiDefNodes_aux g v (removeAll n un) ?m2\n  \\<subseteq> phiDefNodes_aux g v (removeAll n un') ?m2\n\ngoal (1 subgoal):\n 1. \\<And>xs un' n.\n       \\<lbrakk>\\<And>x un' n.\n                   \\<lbrakk>x \\<in> set xs;\n                    set (removeAll x xs) \\<subseteq> set un'\\<rbrakk>\n                   \\<Longrightarrow> phiDefNodes_aux g v (removeAll x xs) n\n                                     \\<subseteq> phiDefNodes_aux g v un' n;\n        set xs \\<subseteq> set un'\\<rbrakk>\n       \\<Longrightarrow> phiDefNodes_aux g v xs n\n                         \\<subseteq> phiDefNodes_aux g v un' n", "assume \"m \\<in> fold (\\<union>) (map (phiDefNodes_aux g v (removeAll n un)) (predecessors g n)) A\""], ["proof (state)\nthis:\n  m \\<in> fold (\\<union>)\n           (map (phiDefNodes_aux g v (removeAll n un)) (predecessors g n)) A\n\ngoal (1 subgoal):\n 1. \\<And>xs un' n.\n       \\<lbrakk>\\<And>x un' n.\n                   \\<lbrakk>x \\<in> set xs;\n                    set (removeAll x xs) \\<subseteq> set un'\\<rbrakk>\n                   \\<Longrightarrow> phiDefNodes_aux g v (removeAll x xs) n\n                                     \\<subseteq> phiDefNodes_aux g v un' n;\n        set xs \\<subseteq> set un'\\<rbrakk>\n       \\<Longrightarrow> phiDefNodes_aux g v xs n\n                         \\<subseteq> phiDefNodes_aux g v un' n", "hence \"m \\<in> fold (\\<union>) (map (phiDefNodes_aux g v (removeAll n un')) (predecessors g n)) A\""], ["proof (prove)\nusing this:\n  m \\<in> fold (\\<union>)\n           (map (phiDefNodes_aux g v (removeAll n un)) (predecessors g n)) A\n\ngoal (1 subgoal):\n 1. m \\<in> fold (\\<union>)\n             (map (phiDefNodes_aux g v (removeAll n un'))\n               (predecessors g n))\n             A", "apply (rule fold_union_elem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys.\n       \\<lbrakk>m \\<in> ys;\n        ys \\<in> set (map (phiDefNodes_aux g v (removeAll n un))\n                       (predecessors g n)) \\<union>\n                 {A}\\<rbrakk>\n       \\<Longrightarrow> m \\<in> fold (\\<union>)\n                                  (map (phiDefNodes_aux g v\n   (removeAll n un'))\n                                    (predecessors g n))\n                                  A", "apply (rule fold_union_elemI')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys.\n       \\<lbrakk>m \\<in> ys;\n        ys \\<in> set (map (phiDefNodes_aux g v (removeAll n un))\n                       (predecessors g n)) \\<union>\n                 {A}\\<rbrakk>\n       \\<Longrightarrow> m \\<in> A \\<or>\n                         (\\<exists>xs\\<in>set\n     (map (phiDefNodes_aux g v (removeAll n un')) (predecessors g n)).\n                             m \\<in> xs)", "apply (auto simp: image_def dest: a[THEN subsetD])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  m \\<in> fold (\\<union>)\n           (map (phiDefNodes_aux g v (removeAll n un')) (predecessors g n))\n           A\n\ngoal (1 subgoal):\n 1. \\<And>xs un' n.\n       \\<lbrakk>\\<And>x un' n.\n                   \\<lbrakk>x \\<in> set xs;\n                    set (removeAll x xs) \\<subseteq> set un'\\<rbrakk>\n                   \\<Longrightarrow> phiDefNodes_aux g v (removeAll x xs) n\n                                     \\<subseteq> phiDefNodes_aux g v un' n;\n        set xs \\<subseteq> set un'\\<rbrakk>\n       \\<Longrightarrow> phiDefNodes_aux g v xs n\n                         \\<subseteq> phiDefNodes_aux g v un' n", "}"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<in> set un;\n   ?m4\n   \\<in> fold (\\<union>)\n          (map (phiDefNodes_aux g v (removeAll n un)) (predecessors g n))\n          ?A4\\<rbrakk>\n  \\<Longrightarrow> ?m4\n                    \\<in> fold (\\<union>)\n                           (map (phiDefNodes_aux g v (removeAll n un'))\n                             (predecessors g n))\n                           ?A4\n\ngoal (1 subgoal):\n 1. \\<And>xs un' n.\n       \\<lbrakk>\\<And>x un' n.\n                   \\<lbrakk>x \\<in> set xs;\n                    set (removeAll x xs) \\<subseteq> set un'\\<rbrakk>\n                   \\<Longrightarrow> phiDefNodes_aux g v (removeAll x xs) n\n                                     \\<subseteq> phiDefNodes_aux g v un' n;\n        set xs \\<subseteq> set un'\\<rbrakk>\n       \\<Longrightarrow> phiDefNodes_aux g v xs n\n                         \\<subseteq> phiDefNodes_aux g v un' n", "with 1(2)"], ["proof (chain)\npicking this:\n  set un \\<subseteq> set un'\n  \\<lbrakk>n \\<in> set un;\n   ?m4\n   \\<in> fold (\\<union>)\n          (map (phiDefNodes_aux g v (removeAll n un)) (predecessors g n))\n          ?A4\\<rbrakk>\n  \\<Longrightarrow> ?m4\n                    \\<in> fold (\\<union>)\n                           (map (phiDefNodes_aux g v (removeAll n un'))\n                             (predecessors g n))\n                           ?A4", "show ?case"], ["proof (prove)\nusing this:\n  set un \\<subseteq> set un'\n  \\<lbrakk>n \\<in> set un;\n   ?m4\n   \\<in> fold (\\<union>)\n          (map (phiDefNodes_aux g v (removeAll n un)) (predecessors g n))\n          ?A4\\<rbrakk>\n  \\<Longrightarrow> ?m4\n                    \\<in> fold (\\<union>)\n                           (map (phiDefNodes_aux g v (removeAll n un'))\n                             (predecessors g n))\n                           ?A4\n\ngoal (1 subgoal):\n 1. phiDefNodes_aux g v un n \\<subseteq> phiDefNodes_aux g v un' n", "apply (subst(1 2) phiDefNodes_aux.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set un \\<subseteq> set un';\n     \\<And>m A.\n        \\<lbrakk>n \\<in> set un;\n         m \\<in> fold (\\<union>)\n                  (map (phiDefNodes_aux g v (removeAll n un))\n                    (predecessors g n))\n                  A\\<rbrakk>\n        \\<Longrightarrow> m \\<in> fold (\\<union>)\n                                   (map (phiDefNodes_aux g v\n    (removeAll n un'))\n                                     (predecessors g n))\n                                   A\\<rbrakk>\n    \\<Longrightarrow> (if n \\<notin> set un \\<or> v \\<in> defs g n then {}\n                       else fold (\\<union>)\n                             (map (phiDefNodes_aux g v (removeAll n un))\n                               (predecessors g n))\n                             (if length (predecessors g n) \\<noteq> 1\n                              then {n} else {}))\n                      \\<subseteq> (if n \\<notin> set un' \\<or>\nv \\<in> defs g n\n                                   then {}\n                                   else fold (\\<union>)\n   (map (phiDefNodes_aux g v (removeAll n un')) (predecessors g n))\n   (if length (predecessors g n) \\<noteq> 1 then {n} else {}))", "by auto"], ["proof (state)\nthis:\n  phiDefNodes_aux g v un n \\<subseteq> phiDefNodes_aux g v un' n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma phiDefNodes_aux_single_pred:\n    assumes \"predecessors g n = [m]\"\n    shows \"phiDefNodes_aux g v (removeAll n un) m = phiDefNodes_aux g v un m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phiDefNodes_aux g v (removeAll n un) m = phiDefNodes_aux g v un m", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. phiDefNodes_aux g v (removeAll n un) m = phiDefNodes_aux g v un m", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. phiDefNodes_aux g v (removeAll n un) m = phiDefNodes_aux g v un m", "fix n' ns"], ["proof (state)\ngoal (1 subgoal):\n 1. phiDefNodes_aux g v (removeAll n un) m = phiDefNodes_aux g v un m", "assume asm: \"g \\<turnstile> n'-ns\\<rightarrow>m\" \"distinct ns\" \"length (predecessors g n') \\<noteq> 1\" \"n \\<in> set ns\""], ["proof (state)\nthis:\n  g \\<turnstile> n'-ns\\<rightarrow>m\n  distinct ns\n  length (predecessors g n') \\<noteq> 1\n  n \\<in> set ns\n\ngoal (1 subgoal):\n 1. phiDefNodes_aux g v (removeAll n un) m = phiDefNodes_aux g v un m", "then"], ["proof (chain)\npicking this:\n  g \\<turnstile> n'-ns\\<rightarrow>m\n  distinct ns\n  length (predecessors g n') \\<noteq> 1\n  n \\<in> set ns", "obtain ns\\<^sub>1 ns\\<^sub>2 where split: \"g \\<turnstile> n'-ns\\<^sub>1\\<rightarrow>n\" \"g \\<turnstile> n-ns\\<^sub>2\\<rightarrow>m\" \"ns = butlast ns\\<^sub>1 @ ns\\<^sub>2\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n'-ns\\<rightarrow>m\n  distinct ns\n  length (predecessors g n') \\<noteq> 1\n  n \\<in> set ns\n\ngoal (1 subgoal):\n 1. (\\<And>ns\\<^sub>1 ns\\<^sub>2.\n        \\<lbrakk>g \\<turnstile> n'-ns\\<^sub>1\\<rightarrow>n;\n         g \\<turnstile> n-ns\\<^sub>2\\<rightarrow>m;\n         ns = butlast ns\\<^sub>1 @ ns\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by - (rule path2_split_ex)"], ["proof (state)\nthis:\n  g \\<turnstile> n'-ns\\<^sub>1\\<rightarrow>n\n  g \\<turnstile> n-ns\\<^sub>2\\<rightarrow>m\n  ns = butlast ns\\<^sub>1 @ ns\\<^sub>2\n\ngoal (1 subgoal):\n 1. phiDefNodes_aux g v (removeAll n un) m = phiDefNodes_aux g v un m", "with \\<open>distinct ns\\<close>"], ["proof (chain)\npicking this:\n  distinct ns\n  g \\<turnstile> n'-ns\\<^sub>1\\<rightarrow>n\n  g \\<turnstile> n-ns\\<^sub>2\\<rightarrow>m\n  ns = butlast ns\\<^sub>1 @ ns\\<^sub>2", "have \"m \\<notin> set (butlast ns\\<^sub>1)\""], ["proof (prove)\nusing this:\n  distinct ns\n  g \\<turnstile> n'-ns\\<^sub>1\\<rightarrow>n\n  g \\<turnstile> n-ns\\<^sub>2\\<rightarrow>m\n  ns = butlast ns\\<^sub>1 @ ns\\<^sub>2\n\ngoal (1 subgoal):\n 1. m \\<notin> set (butlast ns\\<^sub>1)", "by (auto dest: path2_last_in_ns)"], ["proof (state)\nthis:\n  m \\<notin> set (butlast ns\\<^sub>1)\n\ngoal (1 subgoal):\n 1. phiDefNodes_aux g v (removeAll n un) m = phiDefNodes_aux g v un m", "from split(1,2)"], ["proof (chain)\npicking this:\n  g \\<turnstile> n'-ns\\<^sub>1\\<rightarrow>n\n  g \\<turnstile> n-ns\\<^sub>2\\<rightarrow>m", "have False"], ["proof (prove)\nusing this:\n  g \\<turnstile> n'-ns\\<^sub>1\\<rightarrow>n\n  g \\<turnstile> n-ns\\<^sub>2\\<rightarrow>m\n\ngoal (1 subgoal):\n 1. False", "apply-"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g \\<turnstile> n'-ns\\<^sub>1\\<rightarrow>n;\n     g \\<turnstile> n-ns\\<^sub>2\\<rightarrow>m\\<rbrakk>\n    \\<Longrightarrow> False", "apply (frule path2_unsnoc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>g \\<turnstile> n'-ns\\<^sub>1\\<rightarrow>n;\n     g \\<turnstile> n-ns\\<^sub>2\\<rightarrow>m\\<rbrakk>\n    \\<Longrightarrow> 2 \\<le> length ns\\<^sub>1\n 2. \\<lbrakk>g \\<turnstile> n'-ns\\<^sub>1\\<rightarrow>n;\n     g \\<turnstile> n-ns\\<^sub>2\\<rightarrow>m;\n     g \\<turnstile> n'-butlast\n                        ns\\<^sub>1\\<rightarrow>last (butlast ns\\<^sub>1);\n     last (butlast ns\\<^sub>1) \\<in> set (predecessors g n)\\<rbrakk>\n    \\<Longrightarrow> ?thesis2\n 3. \\<lbrakk>g \\<turnstile> n'-ns\\<^sub>1\\<rightarrow>n;\n     g \\<turnstile> n-ns\\<^sub>2\\<rightarrow>m; ?thesis2\\<rbrakk>\n    \\<Longrightarrow> False", "apply (erule path2_nontrivial)"], ["proof (prove)\ngoal (3 subgoals):\n 1. g \\<turnstile> n-ns\\<^sub>2\\<rightarrow>m \\<Longrightarrow>\n    n' \\<noteq> n\n 2. \\<lbrakk>g \\<turnstile> n'-ns\\<^sub>1\\<rightarrow>n;\n     g \\<turnstile> n-ns\\<^sub>2\\<rightarrow>m;\n     g \\<turnstile> n'-butlast\n                        ns\\<^sub>1\\<rightarrow>last (butlast ns\\<^sub>1);\n     last (butlast ns\\<^sub>1) \\<in> set (predecessors g n)\\<rbrakk>\n    \\<Longrightarrow> ?thesis2\n 3. \\<lbrakk>g \\<turnstile> n'-ns\\<^sub>1\\<rightarrow>n;\n     g \\<turnstile> n-ns\\<^sub>2\\<rightarrow>m; ?thesis2\\<rbrakk>\n    \\<Longrightarrow> False", "using assms asm(3) \\<open>m \\<notin> set (butlast ns\\<^sub>1)\\<close>"], ["proof (prove)\nusing this:\n  predecessors g n = [m]\n  length (predecessors g n') \\<noteq> 1\n  m \\<notin> set (butlast ns\\<^sub>1)\n\ngoal (3 subgoals):\n 1. g \\<turnstile> n-ns\\<^sub>2\\<rightarrow>m \\<Longrightarrow>\n    n' \\<noteq> n\n 2. \\<lbrakk>g \\<turnstile> n'-ns\\<^sub>1\\<rightarrow>n;\n     g \\<turnstile> n-ns\\<^sub>2\\<rightarrow>m;\n     g \\<turnstile> n'-butlast\n                        ns\\<^sub>1\\<rightarrow>last (butlast ns\\<^sub>1);\n     last (butlast ns\\<^sub>1) \\<in> set (predecessors g n)\\<rbrakk>\n    \\<Longrightarrow> ?thesis2\n 3. \\<lbrakk>g \\<turnstile> n'-ns\\<^sub>1\\<rightarrow>n;\n     g \\<turnstile> n-ns\\<^sub>2\\<rightarrow>m; ?thesis2\\<rbrakk>\n    \\<Longrightarrow> False", "apply (auto dest: path2_not_Nil)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. phiDefNodes_aux g v (removeAll n un) m = phiDefNodes_aux g v un m", "}"], ["proof (state)\nthis:\n  \\<lbrakk>g \\<turnstile> ?n'4-?ns4\\<rightarrow>m; distinct ?ns4;\n   length (predecessors g ?n'4) \\<noteq> 1; n \\<in> set ?ns4\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. phiDefNodes_aux g v (removeAll n un) m = phiDefNodes_aux g v un m", "with assms"], ["proof (chain)\npicking this:\n  predecessors g n = [m]\n  \\<lbrakk>g \\<turnstile> ?n'4-?ns4\\<rightarrow>m; distinct ?ns4;\n   length (predecessors g ?n'4) \\<noteq> 1; n \\<in> set ?ns4\\<rbrakk>\n  \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\nusing this:\n  predecessors g n = [m]\n  \\<lbrakk>g \\<turnstile> ?n'4-?ns4\\<rightarrow>m; distinct ?ns4;\n   length (predecessors g ?n'4) \\<noteq> 1; n \\<in> set ?ns4\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. phiDefNodes_aux g v (removeAll n un) m = phiDefNodes_aux g v un m", "apply-"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>predecessors g n = [m];\n     \\<And>n' ns.\n        \\<lbrakk>g \\<turnstile> n'-ns\\<rightarrow>m; distinct ns;\n         length (predecessors g n') \\<noteq> 1; n \\<in> set ns\\<rbrakk>\n        \\<Longrightarrow> False\\<rbrakk>\n    \\<Longrightarrow> phiDefNodes_aux g v (removeAll n un) m =\n                      phiDefNodes_aux g v un m", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>predecessors g n = [m];\n     \\<And>n' ns.\n        \\<lbrakk>g \\<turnstile> n'-ns\\<rightarrow>m; distinct ns;\n         length (predecessors g n') \\<noteq> 1; n \\<in> set ns\\<rbrakk>\n        \\<Longrightarrow> False\\<rbrakk>\n    \\<Longrightarrow> phiDefNodes_aux g v (removeAll n un) m\n                      \\<subseteq> phiDefNodes_aux g v un m\n 2. \\<lbrakk>predecessors g n = [m];\n     \\<And>n' ns.\n        \\<lbrakk>g \\<turnstile> n'-ns\\<rightarrow>m; distinct ns;\n         length (predecessors g n') \\<noteq> 1; n \\<in> set ns\\<rbrakk>\n        \\<Longrightarrow> False\\<rbrakk>\n    \\<Longrightarrow> phiDefNodes_aux g v un m\n                      \\<subseteq> phiDefNodes_aux g v (removeAll n un) m", "apply (rule phiDefNodes_aux_unvisited_monotonic; auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>predecessors g n = [m];\n     \\<And>n' ns.\n        \\<lbrakk>g \\<turnstile> n'-ns\\<rightarrow>m; distinct ns;\n         length (predecessors g n') \\<noteq> 1; n \\<in> set ns\\<rbrakk>\n        \\<Longrightarrow> False\\<rbrakk>\n    \\<Longrightarrow> phiDefNodes_aux g v un m\n                      \\<subseteq> phiDefNodes_aux g v (removeAll n un) m", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>predecessors g n = [m];\n        \\<And>n' ns.\n           \\<lbrakk>g \\<turnstile> n'-ns\\<rightarrow>m; distinct ns;\n            length (predecessors g n') \\<noteq> 1; n \\<in> set ns\\<rbrakk>\n           \\<Longrightarrow> False;\n        x \\<in> phiDefNodes_aux g v un m\\<rbrakk>\n       \\<Longrightarrow> x \\<in> phiDefNodes_aux g v (removeAll n un) m", "apply (rename_tac n')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n'.\n       \\<lbrakk>predecessors g n = [m];\n        \\<And>n' ns.\n           \\<lbrakk>g \\<turnstile> n'-ns\\<rightarrow>m; distinct ns;\n            length (predecessors g n') \\<noteq> 1; n \\<in> set ns\\<rbrakk>\n           \\<Longrightarrow> False;\n        n' \\<in> phiDefNodes_aux g v un m\\<rbrakk>\n       \\<Longrightarrow> n' \\<in> phiDefNodes_aux g v (removeAll n un) m", "apply (erule phiDefNodes_auxE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n'.\n       \\<lbrakk>predecessors g n = [m];\n        \\<And>n' ns.\n           \\<lbrakk>g \\<turnstile> n'-ns\\<rightarrow>m; distinct ns;\n            length (predecessors g n') \\<noteq> 1; n \\<in> set ns\\<rbrakk>\n           \\<Longrightarrow> False\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (\\<alpha>n g)\n 2. \\<And>n' ns.\n       \\<lbrakk>predecessors g n = [m];\n        \\<And>n' ns.\n           \\<lbrakk>g \\<turnstile> n'-ns\\<rightarrow>m; distinct ns;\n            length (predecessors g n') \\<noteq> 1; n \\<in> set ns\\<rbrakk>\n           \\<Longrightarrow> False;\n        g \\<turnstile> n'-ns\\<rightarrow>m;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n') \\<noteq> 1; unvisitedPath un ns\\<rbrakk>\n       \\<Longrightarrow> n' \\<in> phiDefNodes_aux g v (removeAll n un) m", "apply (rule predecessor_is_node[where n'=n]; auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n' ns.\n       \\<lbrakk>predecessors g n = [m];\n        \\<And>n' ns.\n           \\<lbrakk>g \\<turnstile> n'-ns\\<rightarrow>m; distinct ns;\n            length (predecessors g n') \\<noteq> 1; n \\<in> set ns\\<rbrakk>\n           \\<Longrightarrow> False;\n        g \\<turnstile> n'-ns\\<rightarrow>m;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n') \\<noteq> 1; unvisitedPath un ns\\<rbrakk>\n       \\<Longrightarrow> n' \\<in> phiDefNodes_aux g v (removeAll n un) m", "apply (rule phiDefNodes_auxI; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  phiDefNodes_aux g v (removeAll n un) m = phiDefNodes_aux g v un m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma phis'_aux_finite:\n    assumes \"finite (Mapping.keys phis)\"\n    shows \"finite (Mapping.keys (phis'_aux g v ns phis))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Mapping.keys (phis'_aux g v ns phis))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (Mapping.keys (phis'_aux g v ns phis))", "have a: \"\\<And>n. phiDefNodes_aux g v [n\\<leftarrow>\\<alpha>n g . (n, v) \\<notin> dom (Mapping.lookup phis)] n \\<subseteq> (set (\\<alpha>n g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       phiDefNodes_aux g v\n        (filter (\\<lambda>n. (n, v) \\<notin> dom (Mapping.lookup phis))\n          (\\<alpha>n g))\n        n\n       \\<subseteq> set (\\<alpha>n g)", "by (rule subset_trans, rule phiDefNodes_aux_in_unvisited, auto)"], ["proof (state)\nthis:\n  phiDefNodes_aux g v\n   (filter (\\<lambda>n. (n, v) \\<notin> dom (Mapping.lookup phis))\n     (\\<alpha>n g))\n   ?n2\n  \\<subseteq> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. finite (Mapping.keys (phis'_aux g v ns phis))", "have \"Mapping.keys (phis'_aux g v ns phis) \\<subseteq> set (\\<alpha>n g) \\<times> vars g \\<union> Mapping.keys phis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.keys (phis'_aux g v ns phis)\n    \\<subseteq> set (\\<alpha>n g) \\<times> vars g \\<union> Mapping.keys phis", "by (auto simp: phis'_aux_def keys_dom_lookup split: if_split_asm dest: subsetD[OF a])"], ["proof (state)\nthis:\n  Mapping.keys (phis'_aux g v ns phis)\n  \\<subseteq> set (\\<alpha>n g) \\<times> vars g \\<union> Mapping.keys phis\n\ngoal (1 subgoal):\n 1. finite (Mapping.keys (phis'_aux g v ns phis))", "thus ?thesis"], ["proof (prove)\nusing this:\n  Mapping.keys (phis'_aux g v ns phis)\n  \\<subseteq> set (\\<alpha>n g) \\<times> vars g \\<union> Mapping.keys phis\n\ngoal (1 subgoal):\n 1. finite (Mapping.keys (phis'_aux g v ns phis))", "by (rule finite_subset, auto intro: assms)"], ["proof (state)\nthis:\n  finite (Mapping.keys (phis'_aux g v ns phis))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma phiDefNodes_aux_redirect:\n    assumes asm: \"g \\<turnstile> n-ns\\<rightarrow>m\"  \"\\<forall>n \\<in> set ns. v \\<notin> defs g n\" \"length (predecessors g n) \\<noteq> 1\" \"unvisitedPath un ns\"\n    assumes n': \"n' \\<in> set ns\" \"n' \\<in> phiDefNodes_aux g v un m'\" \"m' \\<in> set (\\<alpha>n g)\"\n    shows \"n \\<in> phiDefNodes_aux g v un m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes_aux g v un m'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes_aux g v un m'", "from asm(1) n'(1)"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  n' \\<in> set ns", "obtain ns\\<^sub>1 where ns\\<^sub>1: \"g \\<turnstile> n-ns\\<^sub>1\\<rightarrow>n'\" \"set ns\\<^sub>1 \\<subseteq> set ns\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<rightarrow>m\n  n' \\<in> set ns\n\ngoal (1 subgoal):\n 1. (\\<And>ns\\<^sub>1.\n        \\<lbrakk>g \\<turnstile> n-ns\\<^sub>1\\<rightarrow>n';\n         set ns\\<^sub>1 \\<subseteq> set ns\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule path2_split_ex, simp)"], ["proof (state)\nthis:\n  g \\<turnstile> n-ns\\<^sub>1\\<rightarrow>n'\n  set ns\\<^sub>1 \\<subseteq> set ns\n\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes_aux g v un m'", "from n'(2-3)"], ["proof (chain)\npicking this:\n  n' \\<in> phiDefNodes_aux g v un m'\n  m' \\<in> set (\\<alpha>n g)", "obtain ns' where ns': \"g \\<turnstile> n'-ns'\\<rightarrow>m'\" \"\\<forall>n \\<in> set ns'. v \\<notin> defs g n\" \"length (predecessors g n') \\<noteq> 1\"\n      \"unvisitedPath un ns'\""], ["proof (prove)\nusing this:\n  n' \\<in> phiDefNodes_aux g v un m'\n  m' \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. (\\<And>ns'.\n        \\<lbrakk>g \\<turnstile> n'-ns'\\<rightarrow>m';\n         \\<forall>n\\<in>set ns'. v \\<notin> defs g n;\n         length (predecessors g n') \\<noteq> 1;\n         unvisitedPath un ns'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule phiDefNodes_auxE)"], ["proof (state)\nthis:\n  g \\<turnstile> n'-ns'\\<rightarrow>m'\n  \\<forall>n\\<in>set ns'. v \\<notin> defs g n\n  length (predecessors g n') \\<noteq> 1\n  unvisitedPath un ns'\n\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes_aux g v un m'", "from ns\\<^sub>1(1) ns'(1)"], ["proof (chain)\npicking this:\n  g \\<turnstile> n-ns\\<^sub>1\\<rightarrow>n'\n  g \\<turnstile> n'-ns'\\<rightarrow>m'", "obtain ms where ms: \"g \\<turnstile> n-ms\\<rightarrow>m'\" \"distinct ms\" \"set ms \\<subseteq> set ns\\<^sub>1 \\<union> set (tl ns')\""], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ns\\<^sub>1\\<rightarrow>n'\n  g \\<turnstile> n'-ns'\\<rightarrow>m'\n\ngoal (1 subgoal):\n 1. (\\<And>ms.\n        \\<lbrakk>g \\<turnstile> n-ms\\<rightarrow>m'; distinct ms;\n         set ms \\<subseteq> set ns\\<^sub>1 \\<union> set (tl ns')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by - (drule path2_app, auto elim: simple_path2)"], ["proof (state)\nthis:\n  g \\<turnstile> n-ms\\<rightarrow>m'\n  distinct ms\n  set ms \\<subseteq> set ns\\<^sub>1 \\<union> set (tl ns')\n\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes_aux g v un m'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes_aux g v un m'", "using ms(1)"], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ms\\<rightarrow>m'\n\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes_aux g v un m'", "apply (rule phiDefNodes_auxI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. unvisitedPath un ms\n 2. \\<forall>n\\<in>set ms. v \\<notin> defs g n\n 3. length (predecessors g n) \\<noteq> 1", "using ms asm(4) ns\\<^sub>1(2) ns'(4)"], ["proof (prove)\nusing this:\n  g \\<turnstile> n-ms\\<rightarrow>m'\n  distinct ms\n  set ms \\<subseteq> set ns\\<^sub>1 \\<union> set (tl ns')\n  unvisitedPath un ns\n  set ns\\<^sub>1 \\<subseteq> set ns\n  unvisitedPath un ns'\n\ngoal (3 subgoals):\n 1. unvisitedPath un ms\n 2. \\<forall>n\\<in>set ms. v \\<notin> defs g n\n 3. length (predecessors g n) \\<noteq> 1", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>g \\<turnstile> n-ms\\<rightarrow>m'; distinct ms;\n        set ms \\<subseteq> set ns\\<^sub>1 \\<union> set (tl ns');\n        set ns\\<^sub>1 \\<subseteq> set ns; x \\<in> set ms; distinct ns;\n        set ns \\<subseteq> set un; distinct ns';\n        set ns' \\<subseteq> set un\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set un\n 2. \\<forall>n\\<in>set ms. v \\<notin> defs g n\n 3. length (predecessors g n) \\<noteq> 1", "apply (rename_tac x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>g \\<turnstile> n-ms\\<rightarrow>m'; distinct ms;\n        set ms \\<subseteq> set ns\\<^sub>1 \\<union> set (tl ns');\n        set ns\\<^sub>1 \\<subseteq> set ns; x \\<in> set ms; distinct ns;\n        set ns \\<subseteq> set un; distinct ns';\n        set ns' \\<subseteq> set un\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set un\n 2. \\<forall>n\\<in>set ms. v \\<notin> defs g n\n 3. length (predecessors g n) \\<noteq> 1", "apply (case_tac \"x \\<in> set ns\\<^sub>1\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>g \\<turnstile> n-ms\\<rightarrow>m'; distinct ms;\n        set ms \\<subseteq> set ns\\<^sub>1 \\<union> set (tl ns');\n        set ns\\<^sub>1 \\<subseteq> set ns; x \\<in> set ms; distinct ns;\n        set ns \\<subseteq> set un; distinct ns'; set ns' \\<subseteq> set un;\n        x \\<in> set ns\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set un\n 2. \\<And>x.\n       \\<lbrakk>g \\<turnstile> n-ms\\<rightarrow>m'; distinct ms;\n        set ms \\<subseteq> set ns\\<^sub>1 \\<union> set (tl ns');\n        set ns\\<^sub>1 \\<subseteq> set ns; x \\<in> set ms; distinct ns;\n        set ns \\<subseteq> set un; distinct ns'; set ns' \\<subseteq> set un;\n        x \\<notin> set ns\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set un\n 3. \\<forall>n\\<in>set ms. v \\<notin> defs g n\n 4. length (predecessors g n) \\<noteq> 1", "apply (drule_tac A=\"set ns\" and c=x in subsetD; auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>g \\<turnstile> n-ms\\<rightarrow>m'; distinct ms;\n        set ms \\<subseteq> set ns\\<^sub>1 \\<union> set (tl ns');\n        set ns\\<^sub>1 \\<subseteq> set ns; x \\<in> set ms; distinct ns;\n        set ns \\<subseteq> set un; distinct ns'; set ns' \\<subseteq> set un;\n        x \\<notin> set ns\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set un\n 2. \\<forall>n\\<in>set ms. v \\<notin> defs g n\n 3. length (predecessors g n) \\<noteq> 1", "apply (drule_tac A=\"set ns'\" and c=x in subsetD; auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>n\\<in>set ms. v \\<notin> defs g n\n 2. length (predecessors g n) \\<noteq> 1", "using asm(2-3) ns\\<^sub>1(2) ns'(2) ms(3)"], ["proof (prove)\nusing this:\n  \\<forall>n\\<in>set ns. v \\<notin> defs g n\n  length (predecessors g n) \\<noteq> 1\n  set ns\\<^sub>1 \\<subseteq> set ns\n  \\<forall>n\\<in>set ns'. v \\<notin> defs g n\n  set ms \\<subseteq> set ns\\<^sub>1 \\<union> set (tl ns')\n\ngoal (2 subgoals):\n 1. \\<forall>n\\<in>set ms. v \\<notin> defs g n\n 2. length (predecessors g n) \\<noteq> 1", "apply (auto dest!: bspec)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  n \\<in> phiDefNodes_aux g v un m'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma snd_readVariableRecursive:\n    assumes \"v \\<in> vars g\" \"n \\<in> set (\\<alpha>n g)\" \"finite (Mapping.keys phis)\"\n    \"\\<And>n. (n,v) \\<in> Mapping.keys phis \\<Longrightarrow> length (predecessors g n) \\<noteq> 1\" \"Mapping.lookup phis (Entry g,v) \\<in> {None, Some []}\"\n    shows\n      \"phis'_aux g v {n} phis = snd (readVariableRecursive g v n phis)\"\n      \"set ms \\<subseteq> set (\\<alpha>n g) \\<Longrightarrow> (phis'_aux g v (set ms) phis, map (\\<lambda>m. lookupDef g m v) ms) = readArgs g v n phis ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phis'_aux g v {n} phis = snd (readVariableRecursive g v n phis) &&&\n    (set ms \\<subseteq> set (\\<alpha>n g) \\<Longrightarrow>\n     (phis'_aux g v (set ms) phis, map (\\<lambda>m. lookupDef g m v) ms) =\n     readArgs g v n phis ms)", "using assms"], ["proof (prove)\nusing this:\n  v \\<in> vars g\n  n \\<in> set (\\<alpha>n g)\n  finite (Mapping.keys phis)\n  (?n2, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n  Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\n\ngoal (1 subgoal):\n 1. phis'_aux g v {n} phis = snd (readVariableRecursive g v n phis) &&&\n    (set ms \\<subseteq> set (\\<alpha>n g) \\<Longrightarrow>\n     (phis'_aux g v (set ms) phis, map (\\<lambda>m. lookupDef g m v) ms) =\n     readArgs g v n phis ms)", "proof (induction g v n phis and g v n phis ms rule: readVariableRecursive_readArgs.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>v \\<notin> defs g n;\n                    predecessors g n = x21 # x22; x22 = []; v \\<in> vars g;\n                    x21 \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n                    \\<And>n.\n                       (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    Mapping.lookup phis (Entry g, v)\n                    \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> phis'_aux g v {x21} phis =\n                                     snd\n(readVariableRecursive g v x21 phis);\n        \\<And>x21 x22 x21a x22a x.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n            x22 = x21a # x22a; Mapping.lookup phis (n, v) = None;\n            x = Mapping.update (n, v) [] phis;\n            set (x21 # x21a # x22a) \\<subseteq> set (\\<alpha>n g);\n            v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n            finite (Mapping.keys x);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys x \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup x (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (phis'_aux g v (set (x21 # x21a # x22a)) x,\n                              map (\\<lambda>m. lookupDef g m v)\n                               (x21 # x21a # x22a)) =\n                             readArgs g v n x (x21 # x21a # x22a);\n        v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n        finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> phis'_aux g v {n} phis =\n                         snd (readVariableRecursive g v n phis)\n 2. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 3. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "case (1 g v n phis)"], ["proof (state)\nthis:\n  \\<lbrakk>v \\<notin> defs g n; predecessors g n = ?x21.2 # ?x22.2;\n   ?x22.2 = []; v \\<in> vars g; ?x21.2 \\<in> set (\\<alpha>n g);\n   finite (Mapping.keys phis);\n   \\<And>n.\n      (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n      length (predecessors g n) \\<noteq> 1;\n   Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n  \\<Longrightarrow> phis'_aux g v {?x21.2} phis =\n                    snd (readVariableRecursive g v ?x21.2 phis)\n  \\<lbrakk>v \\<notin> defs g n; predecessors g n = ?x21.2 # ?x22.2;\n   ?x22.2 = ?x21a2 # ?x22a2; Mapping.lookup phis (n, v) = None;\n   ?x2 = Mapping.update (n, v) [] phis;\n   set (?x21.2 # ?x21a2 # ?x22a2) \\<subseteq> set (\\<alpha>n g);\n   v \\<in> vars g; n \\<in> set (\\<alpha>n g); finite (Mapping.keys ?x2);\n   \\<And>n.\n      (n, v) \\<in> Mapping.keys ?x2 \\<Longrightarrow>\n      length (predecessors g n) \\<noteq> 1;\n   Mapping.lookup ?x2 (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n  \\<Longrightarrow> (phis'_aux g v (set (?x21.2 # ?x21a2 # ?x22a2)) ?x2,\n                     map (\\<lambda>m. lookupDef g m v)\n                      (?x21.2 # ?x21a2 # ?x22a2)) =\n                    readArgs g v n ?x2 (?x21.2 # ?x21a2 # ?x22a2)\n  v \\<in> vars g\n  n \\<in> set (\\<alpha>n g)\n  finite (Mapping.keys phis)\n  (?n2, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n  Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\n\ngoal (3 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>v \\<notin> defs g n;\n                    predecessors g n = x21 # x22; x22 = []; v \\<in> vars g;\n                    x21 \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n                    \\<And>n.\n                       (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    Mapping.lookup phis (Entry g, v)\n                    \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> phis'_aux g v {x21} phis =\n                                     snd\n(readVariableRecursive g v x21 phis);\n        \\<And>x21 x22 x21a x22a x.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n            x22 = x21a # x22a; Mapping.lookup phis (n, v) = None;\n            x = Mapping.update (n, v) [] phis;\n            set (x21 # x21a # x22a) \\<subseteq> set (\\<alpha>n g);\n            v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n            finite (Mapping.keys x);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys x \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup x (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (phis'_aux g v (set (x21 # x21a # x22a)) x,\n                              map (\\<lambda>m. lookupDef g m v)\n                               (x21 # x21a # x22a)) =\n                             readArgs g v n x (x21 # x21a # x22a);\n        v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n        finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> phis'_aux g v {n} phis =\n                         snd (readVariableRecursive g v n phis)\n 2. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 3. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "note \"1.prems\"(1-3)[simp]"], ["proof (state)\nthis:\n  v \\<in> vars g\n  n \\<in> set (\\<alpha>n g)\n  finite (Mapping.keys phis)\n\ngoal (3 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>v \\<notin> defs g n;\n                    predecessors g n = x21 # x22; x22 = []; v \\<in> vars g;\n                    x21 \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n                    \\<And>n.\n                       (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    Mapping.lookup phis (Entry g, v)\n                    \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> phis'_aux g v {x21} phis =\n                                     snd\n(readVariableRecursive g v x21 phis);\n        \\<And>x21 x22 x21a x22a x.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n            x22 = x21a # x22a; Mapping.lookup phis (n, v) = None;\n            x = Mapping.update (n, v) [] phis;\n            set (x21 # x21a # x22a) \\<subseteq> set (\\<alpha>n g);\n            v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n            finite (Mapping.keys x);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys x \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup x (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (phis'_aux g v (set (x21 # x21a # x22a)) x,\n                              map (\\<lambda>m. lookupDef g m v)\n                               (x21 # x21a # x22a)) =\n                             readArgs g v n x (x21 # x21a # x22a);\n        v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n        finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> phis'_aux g v {n} phis =\n                         snd (readVariableRecursive g v n phis)\n 2. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 3. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "note phis_wf = \"1.prems\"(4)[rule_format]"], ["proof (state)\nthis:\n  (?n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n  length (predecessors g ?n) \\<noteq> 1\n\ngoal (3 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>v \\<notin> defs g n;\n                    predecessors g n = x21 # x22; x22 = []; v \\<in> vars g;\n                    x21 \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n                    \\<And>n.\n                       (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    Mapping.lookup phis (Entry g, v)\n                    \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> phis'_aux g v {x21} phis =\n                                     snd\n(readVariableRecursive g v x21 phis);\n        \\<And>x21 x22 x21a x22a x.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n            x22 = x21a # x22a; Mapping.lookup phis (n, v) = None;\n            x = Mapping.update (n, v) [] phis;\n            set (x21 # x21a # x22a) \\<subseteq> set (\\<alpha>n g);\n            v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n            finite (Mapping.keys x);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys x \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup x (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (phis'_aux g v (set (x21 # x21a # x22a)) x,\n                              map (\\<lambda>m. lookupDef g m v)\n                               (x21 # x21a # x22a)) =\n                             readArgs g v n x (x21 # x21a # x22a);\n        v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n        finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> phis'_aux g v {n} phis =\n                         snd (readVariableRecursive g v n phis)\n 2. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 3. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "from \"1.prems\"(5)"], ["proof (chain)\npicking this:\n  Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}", "have a: \"(Entry g,v) \\<in> Mapping.keys phis \\<Longrightarrow> Mapping.lookup phis (Entry g, v) = Some []\""], ["proof (prove)\nusing this:\n  Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\n\ngoal (1 subgoal):\n 1. (Entry g, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n    Mapping.lookup phis (Entry g, v) = Some []", "by (auto simp: keys_dom_lookup)"], ["proof (state)\nthis:\n  (Entry g, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n  Mapping.lookup phis (Entry g, v) = Some []\n\ngoal (3 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>v \\<notin> defs g n;\n                    predecessors g n = x21 # x22; x22 = []; v \\<in> vars g;\n                    x21 \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n                    \\<And>n.\n                       (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    Mapping.lookup phis (Entry g, v)\n                    \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> phis'_aux g v {x21} phis =\n                                     snd\n(readVariableRecursive g v x21 phis);\n        \\<And>x21 x22 x21a x22a x.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n            x22 = x21a # x22a; Mapping.lookup phis (n, v) = None;\n            x = Mapping.update (n, v) [] phis;\n            set (x21 # x21a # x22a) \\<subseteq> set (\\<alpha>n g);\n            v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n            finite (Mapping.keys x);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys x \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup x (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (phis'_aux g v (set (x21 # x21a # x22a)) x,\n                              map (\\<lambda>m. lookupDef g m v)\n                               (x21 # x21a # x22a)) =\n                             readArgs g v n x (x21 # x21a # x22a);\n        v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n        finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> phis'_aux g v {n} phis =\n                         snd (readVariableRecursive g v n phis)\n 2. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 3. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "have IH1: \"\\<And>m. v \\<notin> defs g n \\<Longrightarrow> predecessors g n = [m] \\<Longrightarrow> phis'_aux g v {m} phis = snd (readVariableRecursive g v m phis)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m]\\<rbrakk>\n       \\<Longrightarrow> phis'_aux g v {m} phis =\n                         snd (readVariableRecursive g v m phis)", "apply (rule \"1.IH\"[rule_format])"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m]\\<rbrakk>\n       \\<Longrightarrow> v \\<notin> defs g n\n 2. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m]\\<rbrakk>\n       \\<Longrightarrow> predecessors g n = m # ?x22.0 m\n 3. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m]\\<rbrakk>\n       \\<Longrightarrow> ?x22.0 m = []\n 4. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m]\\<rbrakk>\n       \\<Longrightarrow> v \\<in> vars g\n 5. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m]\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (\\<alpha>n g)\n 6. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m]\\<rbrakk>\n       \\<Longrightarrow> finite (Mapping.keys phis)\n 7. \\<And>m n.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n        (n, v) \\<in> Mapping.keys phis\\<rbrakk>\n       \\<Longrightarrow> length (predecessors g n) \\<noteq> 1\n 8. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m]\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (Entry g, v)\n                         \\<in> {None, Some []}", "apply auto[4]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m]\\<rbrakk>\n       \\<Longrightarrow> m \\<in> set (\\<alpha>n g)\n 2. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m]\\<rbrakk>\n       \\<Longrightarrow> finite (Mapping.keys phis)\n 3. \\<And>m n.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n        (n, v) \\<in> Mapping.keys phis\\<rbrakk>\n       \\<Longrightarrow> length (predecessors g n) \\<noteq> 1\n 4. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m]\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (Entry g, v)\n                         \\<in> {None, Some []}", "apply (rule_tac n'=n in predecessor_is_node; auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m]\\<rbrakk>\n       \\<Longrightarrow> finite (Mapping.keys phis)\n 2. \\<And>m n.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n        (n, v) \\<in> Mapping.keys phis\\<rbrakk>\n       \\<Longrightarrow> length (predecessors g n) \\<noteq> 1\n 3. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m]\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (Entry g, v)\n                         \\<in> {None, Some []}", "using \"1.prems\"(5)"], ["proof (prove)\nusing this:\n  Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\n\ngoal (3 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m]\\<rbrakk>\n       \\<Longrightarrow> finite (Mapping.keys phis)\n 2. \\<And>m n.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m];\n        (n, v) \\<in> Mapping.keys phis\\<rbrakk>\n       \\<Longrightarrow> length (predecessors g n) \\<noteq> 1\n 3. \\<And>m.\n       \\<lbrakk>v \\<notin> defs g n; predecessors g n = [m]\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (Entry g, v)\n                         \\<in> {None, Some []}", "apply (auto dest: phis_wf)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>v \\<notin> defs g n; predecessors g n = [?m2]\\<rbrakk>\n  \\<Longrightarrow> phis'_aux g v {?m2} phis =\n                    snd (readVariableRecursive g v ?m2 phis)\n\ngoal (3 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>v \\<notin> defs g n;\n                    predecessors g n = x21 # x22; x22 = []; v \\<in> vars g;\n                    x21 \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n                    \\<And>n.\n                       (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    Mapping.lookup phis (Entry g, v)\n                    \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> phis'_aux g v {x21} phis =\n                                     snd\n(readVariableRecursive g v x21 phis);\n        \\<And>x21 x22 x21a x22a x.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n            x22 = x21a # x22a; Mapping.lookup phis (n, v) = None;\n            x = Mapping.update (n, v) [] phis;\n            set (x21 # x21a # x22a) \\<subseteq> set (\\<alpha>n g);\n            v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n            finite (Mapping.keys x);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys x \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup x (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (phis'_aux g v (set (x21 # x21a # x22a)) x,\n                              map (\\<lambda>m. lookupDef g m v)\n                               (x21 # x21a # x22a)) =\n                             readArgs g v n x (x21 # x21a # x22a);\n        v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n        finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> phis'_aux g v {n} phis =\n                         snd (readVariableRecursive g v n phis)\n 2. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 3. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>v \\<notin> defs g n; predecessors g n = [?m2]\\<rbrakk>\n  \\<Longrightarrow> phis'_aux g v {?m2} phis =\n                    snd (readVariableRecursive g v ?m2 phis)\n\ngoal (3 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>v \\<notin> defs g n;\n                    predecessors g n = x21 # x22; x22 = []; v \\<in> vars g;\n                    x21 \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n                    \\<And>n.\n                       (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    Mapping.lookup phis (Entry g, v)\n                    \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> phis'_aux g v {x21} phis =\n                                     snd\n(readVariableRecursive g v x21 phis);\n        \\<And>x21 x22 x21a x22a x.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n            x22 = x21a # x22a; Mapping.lookup phis (n, v) = None;\n            x = Mapping.update (n, v) [] phis;\n            set (x21 # x21a # x22a) \\<subseteq> set (\\<alpha>n g);\n            v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n            finite (Mapping.keys x);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys x \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup x (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (phis'_aux g v (set (x21 # x21a # x22a)) x,\n                              map (\\<lambda>m. lookupDef g m v)\n                               (x21 # x21a # x22a)) =\n                             readArgs g v n x (x21 # x21a # x22a);\n        v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n        finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> phis'_aux g v {n} phis =\n                         snd (readVariableRecursive g v n phis)\n 2. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 3. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "fix m\\<^sub>1 m\\<^sub>2 :: 'node"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>v \\<notin> defs g n;\n                    predecessors g n = x21 # x22; x22 = []; v \\<in> vars g;\n                    x21 \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n                    \\<And>n.\n                       (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    Mapping.lookup phis (Entry g, v)\n                    \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> phis'_aux g v {x21} phis =\n                                     snd\n(readVariableRecursive g v x21 phis);\n        \\<And>x21 x22 x21a x22a x.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n            x22 = x21a # x22a; Mapping.lookup phis (n, v) = None;\n            x = Mapping.update (n, v) [] phis;\n            set (x21 # x21a # x22a) \\<subseteq> set (\\<alpha>n g);\n            v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n            finite (Mapping.keys x);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys x \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup x (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (phis'_aux g v (set (x21 # x21a # x22a)) x,\n                              map (\\<lambda>m. lookupDef g m v)\n                               (x21 # x21a # x22a)) =\n                             readArgs g v n x (x21 # x21a # x22a);\n        v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n        finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> phis'_aux g v {n} phis =\n                         snd (readVariableRecursive g v n phis)\n 2. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 3. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "fix ms' :: \"'node list\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>v \\<notin> defs g n;\n                    predecessors g n = x21 # x22; x22 = []; v \\<in> vars g;\n                    x21 \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n                    \\<And>n.\n                       (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    Mapping.lookup phis (Entry g, v)\n                    \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> phis'_aux g v {x21} phis =\n                                     snd\n(readVariableRecursive g v x21 phis);\n        \\<And>x21 x22 x21a x22a x.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n            x22 = x21a # x22a; Mapping.lookup phis (n, v) = None;\n            x = Mapping.update (n, v) [] phis;\n            set (x21 # x21a # x22a) \\<subseteq> set (\\<alpha>n g);\n            v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n            finite (Mapping.keys x);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys x \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup x (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (phis'_aux g v (set (x21 # x21a # x22a)) x,\n                              map (\\<lambda>m. lookupDef g m v)\n                               (x21 # x21a # x22a)) =\n                             readArgs g v n x (x21 # x21a # x22a);\n        v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n        finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> phis'_aux g v {n} phis =\n                         snd (readVariableRecursive g v n phis)\n 2. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 3. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "let ?ms = \"m\\<^sub>1#m\\<^sub>2#ms'\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>v \\<notin> defs g n;\n                    predecessors g n = x21 # x22; x22 = []; v \\<in> vars g;\n                    x21 \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n                    \\<And>n.\n                       (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    Mapping.lookup phis (Entry g, v)\n                    \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> phis'_aux g v {x21} phis =\n                                     snd\n(readVariableRecursive g v x21 phis);\n        \\<And>x21 x22 x21a x22a x.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n            x22 = x21a # x22a; Mapping.lookup phis (n, v) = None;\n            x = Mapping.update (n, v) [] phis;\n            set (x21 # x21a # x22a) \\<subseteq> set (\\<alpha>n g);\n            v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n            finite (Mapping.keys x);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys x \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup x (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (phis'_aux g v (set (x21 # x21a # x22a)) x,\n                              map (\\<lambda>m. lookupDef g m v)\n                               (x21 # x21a # x22a)) =\n                             readArgs g v n x (x21 # x21a # x22a);\n        v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n        finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> phis'_aux g v {n} phis =\n                         snd (readVariableRecursive g v n phis)\n 2. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 3. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "let ?phis' = \"Mapping.update (n,v) [] phis\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>v \\<notin> defs g n;\n                    predecessors g n = x21 # x22; x22 = []; v \\<in> vars g;\n                    x21 \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n                    \\<And>n.\n                       (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    Mapping.lookup phis (Entry g, v)\n                    \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> phis'_aux g v {x21} phis =\n                                     snd\n(readVariableRecursive g v x21 phis);\n        \\<And>x21 x22 x21a x22a x.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n            x22 = x21a # x22a; Mapping.lookup phis (n, v) = None;\n            x = Mapping.update (n, v) [] phis;\n            set (x21 # x21a # x22a) \\<subseteq> set (\\<alpha>n g);\n            v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n            finite (Mapping.keys x);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys x \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup x (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (phis'_aux g v (set (x21 # x21a # x22a)) x,\n                              map (\\<lambda>m. lookupDef g m v)\n                               (x21 # x21a # x22a)) =\n                             readArgs g v n x (x21 # x21a # x22a);\n        v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n        finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> phis'_aux g v {n} phis =\n                         snd (readVariableRecursive g v n phis)\n 2. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 3. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "assume asm: \"v \\<notin> defs g n\" \"predecessors g n = ?ms\" \"Mapping.lookup phis (n, v) = None\""], ["proof (state)\nthis:\n  v \\<notin> defs g n\n  predecessors g n = m\\<^sub>1 # m\\<^sub>2 # ms'\n  Mapping.lookup phis (n, v) = None\n\ngoal (3 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>v \\<notin> defs g n;\n                    predecessors g n = x21 # x22; x22 = []; v \\<in> vars g;\n                    x21 \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n                    \\<And>n.\n                       (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    Mapping.lookup phis (Entry g, v)\n                    \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> phis'_aux g v {x21} phis =\n                                     snd\n(readVariableRecursive g v x21 phis);\n        \\<And>x21 x22 x21a x22a x.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n            x22 = x21a # x22a; Mapping.lookup phis (n, v) = None;\n            x = Mapping.update (n, v) [] phis;\n            set (x21 # x21a # x22a) \\<subseteq> set (\\<alpha>n g);\n            v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n            finite (Mapping.keys x);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys x \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup x (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (phis'_aux g v (set (x21 # x21a # x22a)) x,\n                              map (\\<lambda>m. lookupDef g m v)\n                               (x21 # x21a # x22a)) =\n                             readArgs g v n x (x21 # x21a # x22a);\n        v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n        finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> phis'_aux g v {n} phis =\n                         snd (readVariableRecursive g v n phis)\n 2. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 3. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "moreover"], ["proof (state)\nthis:\n  v \\<notin> defs g n\n  predecessors g n = m\\<^sub>1 # m\\<^sub>2 # ms'\n  Mapping.lookup phis (n, v) = None\n\ngoal (3 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>v \\<notin> defs g n;\n                    predecessors g n = x21 # x22; x22 = []; v \\<in> vars g;\n                    x21 \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n                    \\<And>n.\n                       (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    Mapping.lookup phis (Entry g, v)\n                    \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> phis'_aux g v {x21} phis =\n                                     snd\n(readVariableRecursive g v x21 phis);\n        \\<And>x21 x22 x21a x22a x.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n            x22 = x21a # x22a; Mapping.lookup phis (n, v) = None;\n            x = Mapping.update (n, v) [] phis;\n            set (x21 # x21a # x22a) \\<subseteq> set (\\<alpha>n g);\n            v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n            finite (Mapping.keys x);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys x \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup x (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (phis'_aux g v (set (x21 # x21a # x22a)) x,\n                              map (\\<lambda>m. lookupDef g m v)\n                               (x21 # x21a # x22a)) =\n                             readArgs g v n x (x21 # x21a # x22a);\n        v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n        finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> phis'_aux g v {n} phis =\n                         snd (readVariableRecursive g v n phis)\n 2. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 3. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "have \"set ?ms \\<subseteq> set (\\<alpha>n g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (m\\<^sub>1 # m\\<^sub>2 # ms') \\<subseteq> set (\\<alpha>n g)", "by (rule subsetI, rule predecessor_is_node[of _ g n]; auto simp: asm(2))"], ["proof (state)\nthis:\n  set (m\\<^sub>1 # m\\<^sub>2 # ms') \\<subseteq> set (\\<alpha>n g)\n\ngoal (3 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>v \\<notin> defs g n;\n                    predecessors g n = x21 # x22; x22 = []; v \\<in> vars g;\n                    x21 \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n                    \\<And>n.\n                       (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    Mapping.lookup phis (Entry g, v)\n                    \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> phis'_aux g v {x21} phis =\n                                     snd\n(readVariableRecursive g v x21 phis);\n        \\<And>x21 x22 x21a x22a x.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n            x22 = x21a # x22a; Mapping.lookup phis (n, v) = None;\n            x = Mapping.update (n, v) [] phis;\n            set (x21 # x21a # x22a) \\<subseteq> set (\\<alpha>n g);\n            v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n            finite (Mapping.keys x);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys x \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup x (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (phis'_aux g v (set (x21 # x21a # x22a)) x,\n                              map (\\<lambda>m. lookupDef g m v)\n                               (x21 # x21a # x22a)) =\n                             readArgs g v n x (x21 # x21a # x22a);\n        v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n        finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> phis'_aux g v {n} phis =\n                         snd (readVariableRecursive g v n phis)\n 2. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 3. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "ultimately"], ["proof (chain)\npicking this:\n  v \\<notin> defs g n\n  predecessors g n = m\\<^sub>1 # m\\<^sub>2 # ms'\n  Mapping.lookup phis (n, v) = None\n  set (m\\<^sub>1 # m\\<^sub>2 # ms') \\<subseteq> set (\\<alpha>n g)", "have \"readArgs g v n ?phis' ?ms = (phis'_aux g v (set ?ms) ?phis', map (\\<lambda>m. lookupDef g m v) ?ms)\""], ["proof (prove)\nusing this:\n  v \\<notin> defs g n\n  predecessors g n = m\\<^sub>1 # m\\<^sub>2 # ms'\n  Mapping.lookup phis (n, v) = None\n  set (m\\<^sub>1 # m\\<^sub>2 # ms') \\<subseteq> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. readArgs g v n (Mapping.update (n, v) [] phis)\n     (m\\<^sub>1 # m\\<^sub>2 # ms') =\n    (phis'_aux g v (set (m\\<^sub>1 # m\\<^sub>2 # ms'))\n      (Mapping.update (n, v) [] phis),\n     map (\\<lambda>m. lookupDef g m v) (m\\<^sub>1 # m\\<^sub>2 # ms'))", "using \"1.prems\"(5)"], ["proof (prove)\nusing this:\n  v \\<notin> defs g n\n  predecessors g n = m\\<^sub>1 # m\\<^sub>2 # ms'\n  Mapping.lookup phis (n, v) = None\n  set (m\\<^sub>1 # m\\<^sub>2 # ms') \\<subseteq> set (\\<alpha>n g)\n  Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\n\ngoal (1 subgoal):\n 1. readArgs g v n (Mapping.update (n, v) [] phis)\n     (m\\<^sub>1 # m\\<^sub>2 # ms') =\n    (phis'_aux g v (set (m\\<^sub>1 # m\\<^sub>2 # ms'))\n      (Mapping.update (n, v) [] phis),\n     map (\\<lambda>m. lookupDef g m v) (m\\<^sub>1 # m\\<^sub>2 # ms'))", "by - (rule \"1.IH\"(2)[symmetric, rule_format]; auto dest: phis_wf simp: lookup_update_cases)"], ["proof (state)\nthis:\n  readArgs g v n (Mapping.update (n, v) [] phis)\n   (m\\<^sub>1 # m\\<^sub>2 # ms') =\n  (phis'_aux g v (set (m\\<^sub>1 # m\\<^sub>2 # ms'))\n    (Mapping.update (n, v) [] phis),\n   map (\\<lambda>m. lookupDef g m v) (m\\<^sub>1 # m\\<^sub>2 # ms'))\n\ngoal (3 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>v \\<notin> defs g n;\n                    predecessors g n = x21 # x22; x22 = []; v \\<in> vars g;\n                    x21 \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n                    \\<And>n.\n                       (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    Mapping.lookup phis (Entry g, v)\n                    \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> phis'_aux g v {x21} phis =\n                                     snd\n(readVariableRecursive g v x21 phis);\n        \\<And>x21 x22 x21a x22a x.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n            x22 = x21a # x22a; Mapping.lookup phis (n, v) = None;\n            x = Mapping.update (n, v) [] phis;\n            set (x21 # x21a # x22a) \\<subseteq> set (\\<alpha>n g);\n            v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n            finite (Mapping.keys x);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys x \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup x (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (phis'_aux g v (set (x21 # x21a # x22a)) x,\n                              map (\\<lambda>m. lookupDef g m v)\n                               (x21 # x21a # x22a)) =\n                             readArgs g v n x (x21 # x21a # x22a);\n        v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n        finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> phis'_aux g v {n} phis =\n                         snd (readVariableRecursive g v n phis)\n 2. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 3. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>v \\<notin> defs g n;\n   predecessors g n = ?m\\<^sub>14 # ?m\\<^sub>24 # ?ms'4;\n   Mapping.lookup phis (n, v) = None\\<rbrakk>\n  \\<Longrightarrow> readArgs g v n (Mapping.update (n, v) [] phis)\n                     (?m\\<^sub>14 # ?m\\<^sub>24 # ?ms'4) =\n                    (phis'_aux g v (set (?m\\<^sub>14 # ?m\\<^sub>24 # ?ms'4))\n                      (Mapping.update (n, v) [] phis),\n                     map (\\<lambda>m. lookupDef g m v)\n                      (?m\\<^sub>14 # ?m\\<^sub>24 # ?ms'4))\n\ngoal (3 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>v \\<notin> defs g n;\n                    predecessors g n = x21 # x22; x22 = []; v \\<in> vars g;\n                    x21 \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n                    \\<And>n.\n                       (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    Mapping.lookup phis (Entry g, v)\n                    \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> phis'_aux g v {x21} phis =\n                                     snd\n(readVariableRecursive g v x21 phis);\n        \\<And>x21 x22 x21a x22a x.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n            x22 = x21a # x22a; Mapping.lookup phis (n, v) = None;\n            x = Mapping.update (n, v) [] phis;\n            set (x21 # x21a # x22a) \\<subseteq> set (\\<alpha>n g);\n            v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n            finite (Mapping.keys x);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys x \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup x (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (phis'_aux g v (set (x21 # x21a # x22a)) x,\n                              map (\\<lambda>m. lookupDef g m v)\n                               (x21 # x21a # x22a)) =\n                             readArgs g v n x (x21 # x21a # x22a);\n        v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n        finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> phis'_aux g v {n} phis =\n                         snd (readVariableRecursive g v n phis)\n 2. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 3. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "note IH2 = this"], ["proof (state)\nthis:\n  \\<lbrakk>v \\<notin> defs g n;\n   predecessors g n = ?m\\<^sub>14 # ?m\\<^sub>24 # ?ms'4;\n   Mapping.lookup phis (n, v) = None\\<rbrakk>\n  \\<Longrightarrow> readArgs g v n (Mapping.update (n, v) [] phis)\n                     (?m\\<^sub>14 # ?m\\<^sub>24 # ?ms'4) =\n                    (phis'_aux g v (set (?m\\<^sub>14 # ?m\\<^sub>24 # ?ms'4))\n                      (Mapping.update (n, v) [] phis),\n                     map (\\<lambda>m. lookupDef g m v)\n                      (?m\\<^sub>14 # ?m\\<^sub>24 # ?ms'4))\n\ngoal (3 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>v \\<notin> defs g n;\n                    predecessors g n = x21 # x22; x22 = []; v \\<in> vars g;\n                    x21 \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n                    \\<And>n.\n                       (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    Mapping.lookup phis (Entry g, v)\n                    \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> phis'_aux g v {x21} phis =\n                                     snd\n(readVariableRecursive g v x21 phis);\n        \\<And>x21 x22 x21a x22a x.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n            x22 = x21a # x22a; Mapping.lookup phis (n, v) = None;\n            x = Mapping.update (n, v) [] phis;\n            set (x21 # x21a # x22a) \\<subseteq> set (\\<alpha>n g);\n            v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n            finite (Mapping.keys x);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys x \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup x (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (phis'_aux g v (set (x21 # x21a # x22a)) x,\n                              map (\\<lambda>m. lookupDef g m v)\n                               (x21 # x21a # x22a)) =\n                             readArgs g v n x (x21 # x21a # x22a);\n        v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n        finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> phis'_aux g v {n} phis =\n                         snd (readVariableRecursive g v n phis)\n 2. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 3. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "note foldr_Cons[simp del] fold_Cons[simp del] list.map(2)[simp del] set_simps(2)[simp del]"], ["proof (state)\nthis:\n  foldr (#) ?xs [] = ?xs\n  fold ?f (?x # ?xs) = (fold ?f ?xs \\<circ>\\<circ> ?f) ?x\n  map ?f (?x21.0 # ?x22.0) = ?f ?x21.0 # map ?f ?x22.0\n  (?A - ?B = ?A) = (?A \\<inter> ?B = {})\n\ngoal (3 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>v \\<notin> defs g n;\n                    predecessors g n = x21 # x22; x22 = []; v \\<in> vars g;\n                    x21 \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n                    \\<And>n.\n                       (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    Mapping.lookup phis (Entry g, v)\n                    \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> phis'_aux g v {x21} phis =\n                                     snd\n(readVariableRecursive g v x21 phis);\n        \\<And>x21 x22 x21a x22a x.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n            x22 = x21a # x22a; Mapping.lookup phis (n, v) = None;\n            x = Mapping.update (n, v) [] phis;\n            set (x21 # x21a # x22a) \\<subseteq> set (\\<alpha>n g);\n            v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n            finite (Mapping.keys x);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys x \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup x (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (phis'_aux g v (set (x21 # x21a # x22a)) x,\n                              map (\\<lambda>m. lookupDef g m v)\n                               (x21 # x21a # x22a)) =\n                             readArgs g v n x (x21 # x21a # x22a);\n        v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n        finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> phis'_aux g v {n} phis =\n                         snd (readVariableRecursive g v n phis)\n 2. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 3. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "have c: \"\\<And>f x. \\<Union>(f ` {x}) = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f x. \\<Union> (f ` {x}) = f x", "by auto"], ["proof (state)\nthis:\n  \\<Union> (?f2 ` {?x2}) = ?f2 ?x2\n\ngoal (3 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>\\<And>x21 x22.\n                   \\<lbrakk>v \\<notin> defs g n;\n                    predecessors g n = x21 # x22; x22 = []; v \\<in> vars g;\n                    x21 \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n                    \\<And>n.\n                       (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    Mapping.lookup phis (Entry g, v)\n                    \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> phis'_aux g v {x21} phis =\n                                     snd\n(readVariableRecursive g v x21 phis);\n        \\<And>x21 x22 x21a x22a x.\n           \\<lbrakk>v \\<notin> defs g n; predecessors g n = x21 # x22;\n            x22 = x21a # x22a; Mapping.lookup phis (n, v) = None;\n            x = Mapping.update (n, v) [] phis;\n            set (x21 # x21a # x22a) \\<subseteq> set (\\<alpha>n g);\n            v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n            finite (Mapping.keys x);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys x \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup x (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (phis'_aux g v (set (x21 # x21a # x22a)) x,\n                              map (\\<lambda>m. lookupDef g m v)\n                               (x21 # x21a # x22a)) =\n                             readArgs g v n x (x21 # x21a # x22a);\n        v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n        finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> phis'_aux g v {n} phis =\n                         snd (readVariableRecursive g v n phis)\n 2. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 3. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. phis'_aux g v {n} phis = snd (readVariableRecursive g v n phis)", "unfolding phis'_aux_def c"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping\n     (\\<lambda>(m, v\\<^sub>2).\n         if v\\<^sub>2 = v \\<and>\n            m \\<in> phiDefNodes_aux g v\n                     (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))\n                     n \\<and>\n            v \\<in> vars g\n         then Some (map (\\<lambda>m. lookupDef g m v) (predecessors g m))\n         else Mapping.lookup phis (m, v\\<^sub>2)) =\n    snd (readVariableRecursive g v n phis)", "apply (subst readVariableRecursive.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping\n     (\\<lambda>(m, v\\<^sub>2).\n         if v\\<^sub>2 = v \\<and>\n            m \\<in> phiDefNodes_aux g v\n                     (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))\n                     n \\<and>\n            v \\<in> vars g\n         then Some (map (\\<lambda>m. lookupDef g m v) (predecessors g m))\n         else Mapping.lookup phis (m, v\\<^sub>2)) =\n    snd (if v \\<in> defs g n then ((v, n, SimpleDef), phis)\n         else case predecessors g n of\n              [] \\<Rightarrow>\n                ((v, n, PhiDef), Mapping.update (n, v) [] phis)\n              | [m] \\<Rightarrow> readVariableRecursive g v m phis\n              | m # ab # lista \\<Rightarrow>\n                  case Mapping.lookup phis (n, v) of\n                  None \\<Rightarrow>\n                    let phis = Mapping.update (n, v) [] phis;\n                        (phis, args) = readArgs g v n phis (m # ab # lista)\n                    in ((v, n, PhiDef), Mapping.update (n, v) args phis)\n                  | Some x \\<Rightarrow> ((v, n, PhiDef), phis))", "apply (subst phiDefNodes_aux.simps[abs_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping\n     (\\<lambda>(m, v\\<^sub>2).\n         if v\\<^sub>2 = v \\<and>\n            m \\<in> (if n \\<notin> set (filter\n   (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis) (\\<alpha>n g)) \\<or>\n                        v \\<in> defs g n\n                     then {}\n                     else fold (\\<union>)\n                           (map (phiDefNodes_aux g v\n                                  (removeAll n\n                                    (filter\n(\\<lambda>n. (n, v) \\<notin> Mapping.keys phis) (\\<alpha>n g))))\n                             (predecessors g n))\n                           (if length (predecessors g n) \\<noteq> 1 then {n}\n                            else {})) \\<and>\n            v \\<in> vars g\n         then Some (map (\\<lambda>m. lookupDef g m v) (predecessors g m))\n         else Mapping.lookup phis (m, v\\<^sub>2)) =\n    snd (if v \\<in> defs g n then ((v, n, SimpleDef), phis)\n         else case predecessors g n of\n              [] \\<Rightarrow>\n                ((v, n, PhiDef), Mapping.update (n, v) [] phis)\n              | [m] \\<Rightarrow> readVariableRecursive g v m phis\n              | m # ab # lista \\<Rightarrow>\n                  case Mapping.lookup phis (n, v) of\n                  None \\<Rightarrow>\n                    let phis = Mapping.update (n, v) [] phis;\n                        (phis, args) = readArgs g v n phis (m # ab # lista)\n                    in ((v, n, PhiDef), Mapping.update (n, v) args phis)\n                  | Some x \\<Rightarrow> ((v, n, PhiDef), phis))", "apply (cases \"predecessors g n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. predecessors g n = [] \\<Longrightarrow>\n    Mapping\n     (\\<lambda>(m, v\\<^sub>2).\n         if v\\<^sub>2 = v \\<and>\n            m \\<in> (if n \\<notin> set (filter\n   (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis) (\\<alpha>n g)) \\<or>\n                        v \\<in> defs g n\n                     then {}\n                     else fold (\\<union>)\n                           (map (phiDefNodes_aux g v\n                                  (removeAll n\n                                    (filter\n(\\<lambda>n. (n, v) \\<notin> Mapping.keys phis) (\\<alpha>n g))))\n                             (predecessors g n))\n                           (if length (predecessors g n) \\<noteq> 1 then {n}\n                            else {})) \\<and>\n            v \\<in> vars g\n         then Some (map (\\<lambda>m. lookupDef g m v) (predecessors g m))\n         else Mapping.lookup phis (m, v\\<^sub>2)) =\n    snd (if v \\<in> defs g n then ((v, n, SimpleDef), phis)\n         else case predecessors g n of\n              [] \\<Rightarrow>\n                ((v, n, PhiDef), Mapping.update (n, v) [] phis)\n              | [m] \\<Rightarrow> readVariableRecursive g v m phis\n              | m # ab # lista \\<Rightarrow>\n                  case Mapping.lookup phis (n, v) of\n                  None \\<Rightarrow>\n                    let phis = Mapping.update (n, v) [] phis;\n                        (phis, args) = readArgs g v n phis (m # ab # lista)\n                    in ((v, n, PhiDef), Mapping.update (n, v) args phis)\n                  | Some x \\<Rightarrow> ((v, n, PhiDef), phis))\n 2. \\<And>a list.\n       predecessors g n = a # list \\<Longrightarrow>\n       Mapping\n        (\\<lambda>(m, v\\<^sub>2).\n            if v\\<^sub>2 = v \\<and>\n               m \\<in> (if n \\<notin> set\n (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n   (\\<alpha>n g)) \\<or>\n                           v \\<in> defs g n\n                        then {}\n                        else fold (\\<union>)\n                              (map (phiDefNodes_aux g v\n                                     (removeAll n\n (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis) (\\<alpha>n g))))\n                                (predecessors g n))\n                              (if length (predecessors g n) \\<noteq> 1\n                               then {n} else {})) \\<and>\n               v \\<in> vars g\n            then Some (map (\\<lambda>m. lookupDef g m v) (predecessors g m))\n            else Mapping.lookup phis (m, v\\<^sub>2)) =\n       snd (if v \\<in> defs g n then ((v, n, SimpleDef), phis)\n            else case predecessors g n of\n                 [] \\<Rightarrow>\n                   ((v, n, PhiDef), Mapping.update (n, v) [] phis)\n                 | [m] \\<Rightarrow> readVariableRecursive g v m phis\n                 | m # ab # lista \\<Rightarrow>\n                     case Mapping.lookup phis (n, v) of\n                     None \\<Rightarrow>\n                       let phis = Mapping.update (n, v) [] phis;\n                           (phis, args) =\n                             readArgs g v n phis (m # ab # lista)\n                       in ((v, n, PhiDef), Mapping.update (n, v) args phis)\n                     | Some x \\<Rightarrow> ((v, n, PhiDef), phis))", "apply (auto simp: a Mapping_eq_lookup lookup_update_cases Entry_iff_unreachable[OF invar] split: list.split intro!: ext)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       predecessors g n = a # list \\<Longrightarrow>\n       Mapping\n        (\\<lambda>(m, v\\<^sub>2).\n            if v\\<^sub>2 = v \\<and>\n               m \\<in> (if n \\<notin> set\n (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n   (\\<alpha>n g)) \\<or>\n                           v \\<in> defs g n\n                        then {}\n                        else fold (\\<union>)\n                              (map (phiDefNodes_aux g v\n                                     (removeAll n\n (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis) (\\<alpha>n g))))\n                                (predecessors g n))\n                              (if length (predecessors g n) \\<noteq> 1\n                               then {n} else {})) \\<and>\n               v \\<in> vars g\n            then Some (map (\\<lambda>m. lookupDef g m v) (predecessors g m))\n            else Mapping.lookup phis (m, v\\<^sub>2)) =\n       snd (if v \\<in> defs g n then ((v, n, SimpleDef), phis)\n            else case predecessors g n of\n                 [] \\<Rightarrow>\n                   ((v, n, PhiDef), Mapping.update (n, v) [] phis)\n                 | [m] \\<Rightarrow> readVariableRecursive g v m phis\n                 | m # ab # lista \\<Rightarrow>\n                     case Mapping.lookup phis (n, v) of\n                     None \\<Rightarrow>\n                       let phis = Mapping.update (n, v) [] phis;\n                           (phis, args) =\n                             readArgs g v n phis (m # ab # lista)\n                       in ((v, n, PhiDef), Mapping.update (n, v) args phis)\n                     | Some x \\<Rightarrow> ((v, n, PhiDef), phis))", "apply (rename_tac m\\<^sub>1 ms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m\\<^sub>1 ms.\n       predecessors g n = m\\<^sub>1 # ms \\<Longrightarrow>\n       Mapping\n        (\\<lambda>(m, v\\<^sub>2).\n            if v\\<^sub>2 = v \\<and>\n               m \\<in> (if n \\<notin> set\n (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n   (\\<alpha>n g)) \\<or>\n                           v \\<in> defs g n\n                        then {}\n                        else fold (\\<union>)\n                              (map (phiDefNodes_aux g v\n                                     (removeAll n\n (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis) (\\<alpha>n g))))\n                                (predecessors g n))\n                              (if length (predecessors g n) \\<noteq> 1\n                               then {n} else {})) \\<and>\n               v \\<in> vars g\n            then Some (map (\\<lambda>m. lookupDef g m v) (predecessors g m))\n            else Mapping.lookup phis (m, v\\<^sub>2)) =\n       snd (if v \\<in> defs g n then ((v, n, SimpleDef), phis)\n            else case predecessors g n of\n                 [] \\<Rightarrow>\n                   ((v, n, PhiDef), Mapping.update (n, v) [] phis)\n                 | [m] \\<Rightarrow> readVariableRecursive g v m phis\n                 | m # ab # lista \\<Rightarrow>\n                     case Mapping.lookup phis (n, v) of\n                     None \\<Rightarrow>\n                       let phis = Mapping.update (n, v) [] phis;\n                           (phis, args) =\n                             readArgs g v n phis (m # ab # lista)\n                       in ((v, n, PhiDef), Mapping.update (n, v) args phis)\n                     | Some x \\<Rightarrow> ((v, n, PhiDef), phis))", "apply (case_tac ms)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m\\<^sub>1 ms.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # ms; ms = []\\<rbrakk>\n       \\<Longrightarrow> Mapping\n                          (\\<lambda>(m, v\\<^sub>2).\n                              if v\\<^sub>2 = v \\<and>\n                                 m \\<in> (if n\n       \\<notin> set (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g)) \\<or>\n       v \\<in> defs g n\n    then {}\n    else fold (\\<union>)\n          (map (phiDefNodes_aux g v\n                 (removeAll n\n                   (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                     (\\<alpha>n g))))\n            (predecessors g n))\n          (if length (predecessors g n) \\<noteq> 1 then {n} else {})) \\<and>\n                                 v \\<in> vars g\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup phis (m, v\\<^sub>2)) =\n                         snd (if v \\<in> defs g n\n                              then ((v, n, SimpleDef), phis)\n                              else case predecessors g n of\n                                   [] \\<Rightarrow>\n                                     ((v, n, PhiDef),\nMapping.update (n, v) [] phis)\n                                   | [m] \\<Rightarrow>\n readVariableRecursive g v m phis\n                                   | m # ab # lista \\<Rightarrow>\n case Mapping.lookup phis (n, v) of\n None \\<Rightarrow>\n   let phis = Mapping.update (n, v) [] phis;\n       (phis, args) = readArgs g v n phis (m # ab # lista)\n   in ((v, n, PhiDef), Mapping.update (n, v) args phis)\n | Some x \\<Rightarrow> ((v, n, PhiDef), phis))\n 2. \\<And>m\\<^sub>1 ms a list.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # ms; ms = a # list\\<rbrakk>\n       \\<Longrightarrow> Mapping\n                          (\\<lambda>(m, v\\<^sub>2).\n                              if v\\<^sub>2 = v \\<and>\n                                 m \\<in> (if n\n       \\<notin> set (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g)) \\<or>\n       v \\<in> defs g n\n    then {}\n    else fold (\\<union>)\n          (map (phiDefNodes_aux g v\n                 (removeAll n\n                   (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                     (\\<alpha>n g))))\n            (predecessors g n))\n          (if length (predecessors g n) \\<noteq> 1 then {n} else {})) \\<and>\n                                 v \\<in> vars g\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup phis (m, v\\<^sub>2)) =\n                         snd (if v \\<in> defs g n\n                              then ((v, n, SimpleDef), phis)\n                              else case predecessors g n of\n                                   [] \\<Rightarrow>\n                                     ((v, n, PhiDef),\nMapping.update (n, v) [] phis)\n                                   | [m] \\<Rightarrow>\n readVariableRecursive g v m phis\n                                   | m # ab # lista \\<Rightarrow>\n case Mapping.lookup phis (n, v) of\n None \\<Rightarrow>\n   let phis = Mapping.update (n, v) [] phis;\n       (phis, args) = readArgs g v n phis (m # ab # lista)\n   in ((v, n, PhiDef), Mapping.update (n, v) args phis)\n | Some x \\<Rightarrow> ((v, n, PhiDef), phis))", "apply (subst Mapping_eq_lookup)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m\\<^sub>1 ms.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # ms; ms = []\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup\n                          (Mapping\n                            (\\<lambda>(m, v\\<^sub>2).\n                                if v\\<^sub>2 = v \\<and>\n                                   m \\<in> (if n\n         \\<notin> set (filter\n                        (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                        (\\<alpha>n g)) \\<or>\n         v \\<in> defs g n\n      then {}\n      else fold (\\<union>)\n            (map (phiDefNodes_aux g v\n                   (removeAll n\n                     (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))))\n              (predecessors g n))\n            (if length (predecessors g n) \\<noteq> 1 then {n}\n             else {})) \\<and>\n                                   v \\<in> vars g\n                                then Some\n(map (\\<lambda>m. lookupDef g m v) (predecessors g m))\n                                else Mapping.lookup phis (m, v\\<^sub>2))) =\n                         Mapping.lookup\n                          (snd (if v \\<in> defs g n\n                                then ((v, n, SimpleDef), phis)\n                                else case predecessors g n of\n                                     [] \\<Rightarrow>\n ((v, n, PhiDef), Mapping.update (n, v) [] phis)\n                                     | [m] \\<Rightarrow>\n   readVariableRecursive g v m phis\n                                     | m # ab # lista \\<Rightarrow>\n   case Mapping.lookup phis (n, v) of\n   None \\<Rightarrow>\n     let phis = Mapping.update (n, v) [] phis;\n         (phis, args) = readArgs g v n phis (m # ab # lista)\n     in ((v, n, PhiDef), Mapping.update (n, v) args phis)\n   | Some x \\<Rightarrow> ((v, n, PhiDef), phis)))\n 2. \\<And>m\\<^sub>1 ms a list.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # ms; ms = a # list\\<rbrakk>\n       \\<Longrightarrow> Mapping\n                          (\\<lambda>(m, v\\<^sub>2).\n                              if v\\<^sub>2 = v \\<and>\n                                 m \\<in> (if n\n       \\<notin> set (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g)) \\<or>\n       v \\<in> defs g n\n    then {}\n    else fold (\\<union>)\n          (map (phiDefNodes_aux g v\n                 (removeAll n\n                   (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                     (\\<alpha>n g))))\n            (predecessors g n))\n          (if length (predecessors g n) \\<noteq> 1 then {n} else {})) \\<and>\n                                 v \\<in> vars g\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup phis (m, v\\<^sub>2)) =\n                         snd (if v \\<in> defs g n\n                              then ((v, n, SimpleDef), phis)\n                              else case predecessors g n of\n                                   [] \\<Rightarrow>\n                                     ((v, n, PhiDef),\nMapping.update (n, v) [] phis)\n                                   | [m] \\<Rightarrow>\n readVariableRecursive g v m phis\n                                   | m # ab # lista \\<Rightarrow>\n case Mapping.lookup phis (n, v) of\n None \\<Rightarrow>\n   let phis = Mapping.update (n, v) [] phis;\n       (phis, args) = readArgs g v n phis (m # ab # lista)\n   in ((v, n, PhiDef), Mapping.update (n, v) args phis)\n | Some x \\<Rightarrow> ((v, n, PhiDef), phis))", "apply (intro ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m\\<^sub>1 ms x.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # ms; ms = []\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup\n                          (Mapping\n                            (\\<lambda>(m, v\\<^sub>2).\n                                if v\\<^sub>2 = v \\<and>\n                                   m \\<in> (if n\n         \\<notin> set (filter\n                        (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                        (\\<alpha>n g)) \\<or>\n         v \\<in> defs g n\n      then {}\n      else fold (\\<union>)\n            (map (phiDefNodes_aux g v\n                   (removeAll n\n                     (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))))\n              (predecessors g n))\n            (if length (predecessors g n) \\<noteq> 1 then {n}\n             else {})) \\<and>\n                                   v \\<in> vars g\n                                then Some\n(map (\\<lambda>m. lookupDef g m v) (predecessors g m))\n                                else Mapping.lookup phis (m, v\\<^sub>2)))\n                          x =\n                         Mapping.lookup\n                          (snd (if v \\<in> defs g n\n                                then ((v, n, SimpleDef), phis)\n                                else case predecessors g n of\n                                     [] \\<Rightarrow>\n ((v, n, PhiDef), Mapping.update (n, v) [] phis)\n                                     | [m] \\<Rightarrow>\n   readVariableRecursive g v m phis\n                                     | m # ab # lista \\<Rightarrow>\n   case Mapping.lookup phis (n, v) of\n   None \\<Rightarrow>\n     let phis = Mapping.update (n, v) [] phis;\n         (phis, args) = readArgs g v n phis (m # ab # lista)\n     in ((v, n, PhiDef), Mapping.update (n, v) args phis)\n   | Some x \\<Rightarrow> ((v, n, PhiDef), phis)))\n                          x\n 2. \\<And>m\\<^sub>1 ms a list.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # ms; ms = a # list\\<rbrakk>\n       \\<Longrightarrow> Mapping\n                          (\\<lambda>(m, v\\<^sub>2).\n                              if v\\<^sub>2 = v \\<and>\n                                 m \\<in> (if n\n       \\<notin> set (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g)) \\<or>\n       v \\<in> defs g n\n    then {}\n    else fold (\\<union>)\n          (map (phiDefNodes_aux g v\n                 (removeAll n\n                   (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                     (\\<alpha>n g))))\n            (predecessors g n))\n          (if length (predecessors g n) \\<noteq> 1 then {n} else {})) \\<and>\n                                 v \\<in> vars g\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup phis (m, v\\<^sub>2)) =\n                         snd (if v \\<in> defs g n\n                              then ((v, n, SimpleDef), phis)\n                              else case predecessors g n of\n                                   [] \\<Rightarrow>\n                                     ((v, n, PhiDef),\nMapping.update (n, v) [] phis)\n                                   | [m] \\<Rightarrow>\n readVariableRecursive g v m phis\n                                   | m # ab # lista \\<Rightarrow>\n case Mapping.lookup phis (n, v) of\n None \\<Rightarrow>\n   let phis = Mapping.update (n, v) [] phis;\n       (phis, args) = readArgs g v n phis (m # ab # lista)\n   in ((v, n, PhiDef), Mapping.update (n, v) args phis)\n | Some x \\<Rightarrow> ((v, n, PhiDef), phis))", "apply (auto simp: fold_Cons list.map(2))[1]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>m\\<^sub>1 a b.\n       \\<lbrakk>predecessors g n = [m\\<^sub>1];\n        (n, v) \\<in> Mapping.keys phis; v \\<notin> defs g n\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (a, b) =\n                         Mapping.lookup\n                          (snd (readVariableRecursive g v m\\<^sub>1 phis))\n                          (a, b)\n 2. \\<And>m\\<^sub>1 a.\n       \\<lbrakk>predecessors g n = [m\\<^sub>1];\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        a \\<in> phiDefNodes_aux g v\n                 (removeAll n\n                   (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                     (\\<alpha>n g)))\n                 m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g a)) =\n                         Mapping.lookup\n                          (snd (readVariableRecursive g v m\\<^sub>1 phis))\n                          (a, v)\n 3. \\<And>m\\<^sub>1 a b.\n       \\<lbrakk>predecessors g n = [m\\<^sub>1];\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        b \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (a, b) =\n                         Mapping.lookup\n                          (snd (readVariableRecursive g v m\\<^sub>1 phis))\n                          (a, b)\n 4. \\<And>m\\<^sub>1 a b.\n       \\<lbrakk>predecessors g n = [m\\<^sub>1];\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        a \\<notin> phiDefNodes_aux g v\n                    (removeAll n\n                      (filter\n                        (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                        (\\<alpha>n g)))\n                    m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (a, b) =\n                         Mapping.lookup\n                          (snd (readVariableRecursive g v m\\<^sub>1 phis))\n                          (a, b)\n 5. \\<And>m\\<^sub>1 ms a list.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # ms; ms = a # list\\<rbrakk>\n       \\<Longrightarrow> Mapping\n                          (\\<lambda>(m, v\\<^sub>2).\n                              if v\\<^sub>2 = v \\<and>\n                                 m \\<in> (if n\n       \\<notin> set (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g)) \\<or>\n       v \\<in> defs g n\n    then {}\n    else fold (\\<union>)\n          (map (phiDefNodes_aux g v\n                 (removeAll n\n                   (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                     (\\<alpha>n g))))\n            (predecessors g n))\n          (if length (predecessors g n) \\<noteq> 1 then {n} else {})) \\<and>\n                                 v \\<in> vars g\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup phis (m, v\\<^sub>2)) =\n                         snd (if v \\<in> defs g n\n                              then ((v, n, SimpleDef), phis)\n                              else case predecessors g n of\n                                   [] \\<Rightarrow>\n                                     ((v, n, PhiDef),\nMapping.update (n, v) [] phis)\n                                   | [m] \\<Rightarrow>\n readVariableRecursive g v m phis\n                                   | m # ab # lista \\<Rightarrow>\n case Mapping.lookup phis (n, v) of\n None \\<Rightarrow>\n   let phis = Mapping.update (n, v) [] phis;\n       (phis, args) = readArgs g v n phis (m # ab # lista)\n   in ((v, n, PhiDef), Mapping.update (n, v) args phis)\n | Some x \\<Rightarrow> ((v, n, PhiDef), phis))", "apply (auto dest: phis_wf)[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m\\<^sub>1 a.\n       \\<lbrakk>predecessors g n = [m\\<^sub>1];\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        a \\<in> phiDefNodes_aux g v\n                 (removeAll n\n                   (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                     (\\<alpha>n g)))\n                 m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g a)) =\n                         Mapping.lookup\n                          (snd (readVariableRecursive g v m\\<^sub>1 phis))\n                          (a, v)\n 2. \\<And>m\\<^sub>1 a b.\n       \\<lbrakk>predecessors g n = [m\\<^sub>1];\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        b \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (a, b) =\n                         Mapping.lookup\n                          (snd (readVariableRecursive g v m\\<^sub>1 phis))\n                          (a, b)\n 3. \\<And>m\\<^sub>1 a b.\n       \\<lbrakk>predecessors g n = [m\\<^sub>1];\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        a \\<notin> phiDefNodes_aux g v\n                    (removeAll n\n                      (filter\n                        (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                        (\\<alpha>n g)))\n                    m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (a, b) =\n                         Mapping.lookup\n                          (snd (readVariableRecursive g v m\\<^sub>1 phis))\n                          (a, b)\n 4. \\<And>m\\<^sub>1 ms a list.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # ms; ms = a # list\\<rbrakk>\n       \\<Longrightarrow> Mapping\n                          (\\<lambda>(m, v\\<^sub>2).\n                              if v\\<^sub>2 = v \\<and>\n                                 m \\<in> (if n\n       \\<notin> set (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g)) \\<or>\n       v \\<in> defs g n\n    then {}\n    else fold (\\<union>)\n          (map (phiDefNodes_aux g v\n                 (removeAll n\n                   (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                     (\\<alpha>n g))))\n            (predecessors g n))\n          (if length (predecessors g n) \\<noteq> 1 then {n} else {})) \\<and>\n                                 v \\<in> vars g\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup phis (m, v\\<^sub>2)) =\n                         snd (if v \\<in> defs g n\n                              then ((v, n, SimpleDef), phis)\n                              else case predecessors g n of\n                                   [] \\<Rightarrow>\n                                     ((v, n, PhiDef),\nMapping.update (n, v) [] phis)\n                                   | [m] \\<Rightarrow>\n readVariableRecursive g v m phis\n                                   | m # ab # lista \\<Rightarrow>\n case Mapping.lookup phis (n, v) of\n None \\<Rightarrow>\n   let phis = Mapping.update (n, v) [] phis;\n       (phis, args) = readArgs g v n phis (m # ab # lista)\n   in ((v, n, PhiDef), Mapping.update (n, v) args phis)\n | Some x \\<Rightarrow> ((v, n, PhiDef), phis))", "apply (subst IH1[symmetric], assumption, assumption)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m\\<^sub>1 a.\n       \\<lbrakk>predecessors g n = [m\\<^sub>1];\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        a \\<in> phiDefNodes_aux g v\n                 (removeAll n\n                   (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                     (\\<alpha>n g)))\n                 m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g a)) =\n                         Mapping.lookup (phis'_aux g v {m\\<^sub>1} phis)\n                          (a, v)\n 2. \\<And>m\\<^sub>1 a b.\n       \\<lbrakk>predecessors g n = [m\\<^sub>1];\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        b \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (a, b) =\n                         Mapping.lookup\n                          (snd (readVariableRecursive g v m\\<^sub>1 phis))\n                          (a, b)\n 3. \\<And>m\\<^sub>1 a b.\n       \\<lbrakk>predecessors g n = [m\\<^sub>1];\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        a \\<notin> phiDefNodes_aux g v\n                    (removeAll n\n                      (filter\n                        (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                        (\\<alpha>n g)))\n                    m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (a, b) =\n                         Mapping.lookup\n                          (snd (readVariableRecursive g v m\\<^sub>1 phis))\n                          (a, b)\n 4. \\<And>m\\<^sub>1 ms a list.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # ms; ms = a # list\\<rbrakk>\n       \\<Longrightarrow> Mapping\n                          (\\<lambda>(m, v\\<^sub>2).\n                              if v\\<^sub>2 = v \\<and>\n                                 m \\<in> (if n\n       \\<notin> set (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g)) \\<or>\n       v \\<in> defs g n\n    then {}\n    else fold (\\<union>)\n          (map (phiDefNodes_aux g v\n                 (removeAll n\n                   (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                     (\\<alpha>n g))))\n            (predecessors g n))\n          (if length (predecessors g n) \\<noteq> 1 then {n} else {})) \\<and>\n                                 v \\<in> vars g\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup phis (m, v\\<^sub>2)) =\n                         snd (if v \\<in> defs g n\n                              then ((v, n, SimpleDef), phis)\n                              else case predecessors g n of\n                                   [] \\<Rightarrow>\n                                     ((v, n, PhiDef),\nMapping.update (n, v) [] phis)\n                                   | [m] \\<Rightarrow>\n readVariableRecursive g v m phis\n                                   | m # ab # lista \\<Rightarrow>\n case Mapping.lookup phis (n, v) of\n None \\<Rightarrow>\n   let phis = Mapping.update (n, v) [] phis;\n       (phis, args) = readArgs g v n phis (m # ab # lista)\n   in ((v, n, PhiDef), Mapping.update (n, v) args phis)\n | Some x \\<Rightarrow> ((v, n, PhiDef), phis))", "apply (auto simp: phis'_aux_def)[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m\\<^sub>1 a.\n       \\<lbrakk>predecessors g n = [m\\<^sub>1];\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        a \\<in> phiDefNodes_aux g v\n                 (removeAll n\n                   (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                     (\\<alpha>n g)))\n                 m\\<^sub>1;\n        a \\<notin> phiDefNodes_aux g v\n                    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g))\n                    m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g a)) =\n                         Mapping.lookup phis (a, v)\n 2. \\<And>m\\<^sub>1 a b.\n       \\<lbrakk>predecessors g n = [m\\<^sub>1];\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        b \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (a, b) =\n                         Mapping.lookup\n                          (snd (readVariableRecursive g v m\\<^sub>1 phis))\n                          (a, b)\n 3. \\<And>m\\<^sub>1 a b.\n       \\<lbrakk>predecessors g n = [m\\<^sub>1];\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        a \\<notin> phiDefNodes_aux g v\n                    (removeAll n\n                      (filter\n                        (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                        (\\<alpha>n g)))\n                    m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (a, b) =\n                         Mapping.lookup\n                          (snd (readVariableRecursive g v m\\<^sub>1 phis))\n                          (a, b)\n 4. \\<And>m\\<^sub>1 ms a list.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # ms; ms = a # list\\<rbrakk>\n       \\<Longrightarrow> Mapping\n                          (\\<lambda>(m, v\\<^sub>2).\n                              if v\\<^sub>2 = v \\<and>\n                                 m \\<in> (if n\n       \\<notin> set (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g)) \\<or>\n       v \\<in> defs g n\n    then {}\n    else fold (\\<union>)\n          (map (phiDefNodes_aux g v\n                 (removeAll n\n                   (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                     (\\<alpha>n g))))\n            (predecessors g n))\n          (if length (predecessors g n) \\<noteq> 1 then {n} else {})) \\<and>\n                                 v \\<in> vars g\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup phis (m, v\\<^sub>2)) =\n                         snd (if v \\<in> defs g n\n                              then ((v, n, SimpleDef), phis)\n                              else case predecessors g n of\n                                   [] \\<Rightarrow>\n                                     ((v, n, PhiDef),\nMapping.update (n, v) [] phis)\n                                   | [m] \\<Rightarrow>\n readVariableRecursive g v m phis\n                                   | m # ab # lista \\<Rightarrow>\n case Mapping.lookup phis (n, v) of\n None \\<Rightarrow>\n   let phis = Mapping.update (n, v) [] phis;\n       (phis, args) = readArgs g v n phis (m # ab # lista)\n   in ((v, n, PhiDef), Mapping.update (n, v) args phis)\n | Some x \\<Rightarrow> ((v, n, PhiDef), phis))", "apply (drule rev_subsetD, rule phiDefNodes_aux_unvisited_monotonic[where un'=\"[n\\<leftarrow>\\<alpha>n g . (n, v) \\<notin> Mapping.keys phis]\"]; auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m\\<^sub>1 a b.\n       \\<lbrakk>predecessors g n = [m\\<^sub>1];\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        b \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (a, b) =\n                         Mapping.lookup\n                          (snd (readVariableRecursive g v m\\<^sub>1 phis))\n                          (a, b)\n 2. \\<And>m\\<^sub>1 a b.\n       \\<lbrakk>predecessors g n = [m\\<^sub>1];\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        a \\<notin> phiDefNodes_aux g v\n                    (removeAll n\n                      (filter\n                        (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                        (\\<alpha>n g)))\n                    m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (a, b) =\n                         Mapping.lookup\n                          (snd (readVariableRecursive g v m\\<^sub>1 phis))\n                          (a, b)\n 3. \\<And>m\\<^sub>1 ms a list.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # ms; ms = a # list\\<rbrakk>\n       \\<Longrightarrow> Mapping\n                          (\\<lambda>(m, v\\<^sub>2).\n                              if v\\<^sub>2 = v \\<and>\n                                 m \\<in> (if n\n       \\<notin> set (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g)) \\<or>\n       v \\<in> defs g n\n    then {}\n    else fold (\\<union>)\n          (map (phiDefNodes_aux g v\n                 (removeAll n\n                   (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                     (\\<alpha>n g))))\n            (predecessors g n))\n          (if length (predecessors g n) \\<noteq> 1 then {n} else {})) \\<and>\n                                 v \\<in> vars g\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup phis (m, v\\<^sub>2)) =\n                         snd (if v \\<in> defs g n\n                              then ((v, n, SimpleDef), phis)\n                              else case predecessors g n of\n                                   [] \\<Rightarrow>\n                                     ((v, n, PhiDef),\nMapping.update (n, v) [] phis)\n                                   | [m] \\<Rightarrow>\n readVariableRecursive g v m phis\n                                   | m # ab # lista \\<Rightarrow>\n case Mapping.lookup phis (n, v) of\n None \\<Rightarrow>\n   let phis = Mapping.update (n, v) [] phis;\n       (phis, args) = readArgs g v n phis (m # ab # lista)\n   in ((v, n, PhiDef), Mapping.update (n, v) args phis)\n | Some x \\<Rightarrow> ((v, n, PhiDef), phis))", "apply (subst IH1[symmetric], assumption, assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m\\<^sub>1 a b.\n       \\<lbrakk>predecessors g n = [m\\<^sub>1];\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        b \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (a, b) =\n                         Mapping.lookup (phis'_aux g v {m\\<^sub>1} phis)\n                          (a, b)\n 2. \\<And>m\\<^sub>1 a b.\n       \\<lbrakk>predecessors g n = [m\\<^sub>1];\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        a \\<notin> phiDefNodes_aux g v\n                    (removeAll n\n                      (filter\n                        (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                        (\\<alpha>n g)))\n                    m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (a, b) =\n                         Mapping.lookup\n                          (snd (readVariableRecursive g v m\\<^sub>1 phis))\n                          (a, b)\n 3. \\<And>m\\<^sub>1 ms a list.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # ms; ms = a # list\\<rbrakk>\n       \\<Longrightarrow> Mapping\n                          (\\<lambda>(m, v\\<^sub>2).\n                              if v\\<^sub>2 = v \\<and>\n                                 m \\<in> (if n\n       \\<notin> set (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g)) \\<or>\n       v \\<in> defs g n\n    then {}\n    else fold (\\<union>)\n          (map (phiDefNodes_aux g v\n                 (removeAll n\n                   (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                     (\\<alpha>n g))))\n            (predecessors g n))\n          (if length (predecessors g n) \\<noteq> 1 then {n} else {})) \\<and>\n                                 v \\<in> vars g\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup phis (m, v\\<^sub>2)) =\n                         snd (if v \\<in> defs g n\n                              then ((v, n, SimpleDef), phis)\n                              else case predecessors g n of\n                                   [] \\<Rightarrow>\n                                     ((v, n, PhiDef),\nMapping.update (n, v) [] phis)\n                                   | [m] \\<Rightarrow>\n readVariableRecursive g v m phis\n                                   | m # ab # lista \\<Rightarrow>\n case Mapping.lookup phis (n, v) of\n None \\<Rightarrow>\n   let phis = Mapping.update (n, v) [] phis;\n       (phis, args) = readArgs g v n phis (m # ab # lista)\n   in ((v, n, PhiDef), Mapping.update (n, v) args phis)\n | Some x \\<Rightarrow> ((v, n, PhiDef), phis))", "apply (auto simp: phis'_aux_def)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m\\<^sub>1 a b.\n       \\<lbrakk>predecessors g n = [m\\<^sub>1];\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        a \\<notin> phiDefNodes_aux g v\n                    (removeAll n\n                      (filter\n                        (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                        (\\<alpha>n g)))\n                    m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (a, b) =\n                         Mapping.lookup\n                          (snd (readVariableRecursive g v m\\<^sub>1 phis))\n                          (a, b)\n 2. \\<And>m\\<^sub>1 ms a list.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # ms; ms = a # list\\<rbrakk>\n       \\<Longrightarrow> Mapping\n                          (\\<lambda>(m, v\\<^sub>2).\n                              if v\\<^sub>2 = v \\<and>\n                                 m \\<in> (if n\n       \\<notin> set (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g)) \\<or>\n       v \\<in> defs g n\n    then {}\n    else fold (\\<union>)\n          (map (phiDefNodes_aux g v\n                 (removeAll n\n                   (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                     (\\<alpha>n g))))\n            (predecessors g n))\n          (if length (predecessors g n) \\<noteq> 1 then {n} else {})) \\<and>\n                                 v \\<in> vars g\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup phis (m, v\\<^sub>2)) =\n                         snd (if v \\<in> defs g n\n                              then ((v, n, SimpleDef), phis)\n                              else case predecessors g n of\n                                   [] \\<Rightarrow>\n                                     ((v, n, PhiDef),\nMapping.update (n, v) [] phis)\n                                   | [m] \\<Rightarrow>\n readVariableRecursive g v m phis\n                                   | m # ab # lista \\<Rightarrow>\n case Mapping.lookup phis (n, v) of\n None \\<Rightarrow>\n   let phis = Mapping.update (n, v) [] phis;\n       (phis, args) = readArgs g v n phis (m # ab # lista)\n   in ((v, n, PhiDef), Mapping.update (n, v) args phis)\n | Some x \\<Rightarrow> ((v, n, PhiDef), phis))", "apply (subst IH1[symmetric], assumption, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m\\<^sub>1 a b.\n       \\<lbrakk>predecessors g n = [m\\<^sub>1];\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        a \\<notin> phiDefNodes_aux g v\n                    (removeAll n\n                      (filter\n                        (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                        (\\<alpha>n g)))\n                    m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (a, b) =\n                         Mapping.lookup (phis'_aux g v {m\\<^sub>1} phis)\n                          (a, b)\n 2. \\<And>m\\<^sub>1 ms a list.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # ms; ms = a # list\\<rbrakk>\n       \\<Longrightarrow> Mapping\n                          (\\<lambda>(m, v\\<^sub>2).\n                              if v\\<^sub>2 = v \\<and>\n                                 m \\<in> (if n\n       \\<notin> set (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g)) \\<or>\n       v \\<in> defs g n\n    then {}\n    else fold (\\<union>)\n          (map (phiDefNodes_aux g v\n                 (removeAll n\n                   (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                     (\\<alpha>n g))))\n            (predecessors g n))\n          (if length (predecessors g n) \\<noteq> 1 then {n} else {})) \\<and>\n                                 v \\<in> vars g\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup phis (m, v\\<^sub>2)) =\n                         snd (if v \\<in> defs g n\n                              then ((v, n, SimpleDef), phis)\n                              else case predecessors g n of\n                                   [] \\<Rightarrow>\n                                     ((v, n, PhiDef),\nMapping.update (n, v) [] phis)\n                                   | [m] \\<Rightarrow>\n readVariableRecursive g v m phis\n                                   | m # ab # lista \\<Rightarrow>\n case Mapping.lookup phis (n, v) of\n None \\<Rightarrow>\n   let phis = Mapping.update (n, v) [] phis;\n       (phis, args) = readArgs g v n phis (m # ab # lista)\n   in ((v, n, PhiDef), Mapping.update (n, v) args phis)\n | Some x \\<Rightarrow> ((v, n, PhiDef), phis))", "apply (auto simp: phis'_aux_def phiDefNodes_aux_single_pred)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m\\<^sub>1 ms a list.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # ms; ms = a # list\\<rbrakk>\n       \\<Longrightarrow> Mapping\n                          (\\<lambda>(m, v\\<^sub>2).\n                              if v\\<^sub>2 = v \\<and>\n                                 m \\<in> (if n\n       \\<notin> set (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g)) \\<or>\n       v \\<in> defs g n\n    then {}\n    else fold (\\<union>)\n          (map (phiDefNodes_aux g v\n                 (removeAll n\n                   (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                     (\\<alpha>n g))))\n            (predecessors g n))\n          (if length (predecessors g n) \\<noteq> 1 then {n} else {})) \\<and>\n                                 v \\<in> vars g\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup phis (m, v\\<^sub>2)) =\n                         snd (if v \\<in> defs g n\n                              then ((v, n, SimpleDef), phis)\n                              else case predecessors g n of\n                                   [] \\<Rightarrow>\n                                     ((v, n, PhiDef),\nMapping.update (n, v) [] phis)\n                                   | [m] \\<Rightarrow>\n readVariableRecursive g v m phis\n                                   | m # ab # lista \\<Rightarrow>\n case Mapping.lookup phis (n, v) of\n None \\<Rightarrow>\n   let phis = Mapping.update (n, v) [] phis;\n       (phis, args) = readArgs g v n phis (m # ab # lista)\n   in ((v, n, PhiDef), Mapping.update (n, v) args phis)\n | Some x \\<Rightarrow> ((v, n, PhiDef), phis))", "apply (auto simp: Mapping_eq_lookup lookup_update_cases intro!: ext)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<in> Mapping.keys phis; v \\<notin> defs g n\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)\n 2. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<in> fold (\\<union>)\n                  (map (phiDefNodes_aux g v\n                         (removeAll n\n                           (filter\n                             (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                             (\\<alpha>n g))))\n                    (m\\<^sub>1 # a # list))\n                  {n}\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, v)\n 3. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        b \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)\n 4. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (removeAll n\n                              (filter\n                                (\\<lambda>n.\n                                    (n, v) \\<notin> Mapping.keys phis)\n                                (\\<alpha>n g))))\n                       (m\\<^sub>1 # a # list))\n                     {n}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)", "apply (auto simp: keys_dom_lookup)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<in> fold (\\<union>)\n                  (map (phiDefNodes_aux g v\n                         (removeAll n\n                           (filter\n                             (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                             (\\<alpha>n g))))\n                    (m\\<^sub>1 # a # list))\n                  {n}\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, v)\n 2. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        b \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)\n 3. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (removeAll n\n                              (filter\n                                (\\<lambda>n.\n                                    (n, v) \\<notin> Mapping.keys phis)\n                                (\\<alpha>n g))))\n                       (m\\<^sub>1 # a # list))\n                     {n}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)", "apply (auto split: option.split prod.split)[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa x1 x2.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<in> fold (\\<union>)\n                  (map (phiDefNodes_aux g v\n                         (removeAll n\n                           (filter\n                             (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                             (\\<alpha>n g))))\n                    (m\\<^sub>1 # a # list))\n                  {n};\n        readArgs g v n (Mapping.update (n, v) [] phis)\n         (m\\<^sub>1 # a # list) =\n        (x1, x2);\n        Mapping.lookup phis (n, v) = None\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup (Mapping.update (n, v) x2 x1)\n                          (aa, v)\n 2. \\<And>m\\<^sub>1 a list aa x1 x2 x2a.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<in> fold (\\<union>)\n                  (map (phiDefNodes_aux g v\n                         (removeAll n\n                           (filter\n                             (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                             (\\<alpha>n g))))\n                    (m\\<^sub>1 # a # list))\n                  {n};\n        readArgs g v n (Mapping.update (n, v) [] phis)\n         (m\\<^sub>1 # a # list) =\n        (x1, x2);\n        Mapping.lookup phis (n, v) = Some x2a\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup phis (aa, v)\n 3. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        b \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)\n 4. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (removeAll n\n                              (filter\n                                (\\<lambda>n.\n                                    (n, v) \\<notin> Mapping.keys phis)\n                                (\\<alpha>n g))))\n                       (m\\<^sub>1 # a # list))\n                     {n}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)", "apply (subst(asm) IH2, assumption, assumption, assumption)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa x1 x2.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<in> fold (\\<union>)\n                  (map (phiDefNodes_aux g v\n                         (removeAll n\n                           (filter\n                             (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                             (\\<alpha>n g))))\n                    (m\\<^sub>1 # a # list))\n                  {n};\n        (phis'_aux g v (set (m\\<^sub>1 # a # list))\n          (Mapping.update (n, v) [] phis),\n         map (\\<lambda>m. lookupDef g m v) (m\\<^sub>1 # a # list)) =\n        (x1, x2);\n        Mapping.lookup phis (n, v) = None\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup (Mapping.update (n, v) x2 x1)\n                          (aa, v)\n 2. \\<And>m\\<^sub>1 a list aa x1 x2 x2a.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<in> fold (\\<union>)\n                  (map (phiDefNodes_aux g v\n                         (removeAll n\n                           (filter\n                             (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                             (\\<alpha>n g))))\n                    (m\\<^sub>1 # a # list))\n                  {n};\n        readArgs g v n (Mapping.update (n, v) [] phis)\n         (m\\<^sub>1 # a # list) =\n        (x1, x2);\n        Mapping.lookup phis (n, v) = Some x2a\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup phis (aa, v)\n 3. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        b \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)\n 4. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (removeAll n\n                              (filter\n                                (\\<lambda>n.\n                                    (n, v) \\<notin> Mapping.keys phis)\n                                (\\<alpha>n g))))\n                       (m\\<^sub>1 # a # list))\n                     {n}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)", "apply (erule fold_union_elem)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa x1 x2 ys.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        (phis'_aux g v (set (m\\<^sub>1 # a # list))\n          (Mapping.update (n, v) [] phis),\n         map (\\<lambda>m. lookupDef g m v) (m\\<^sub>1 # a # list)) =\n        (x1, x2);\n        Mapping.lookup phis (n, v) = None; aa \\<in> ys;\n        ys \\<in> set (map (phiDefNodes_aux g v\n                            (removeAll n\n                              (filter\n                                (\\<lambda>n.\n                                    (n, v) \\<notin> Mapping.keys phis)\n                                (\\<alpha>n g))))\n                       (m\\<^sub>1 # a # list)) \\<union>\n                 {{n}}\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup (Mapping.update (n, v) x2 x1)\n                          (aa, v)\n 2. \\<And>m\\<^sub>1 a list aa x1 x2 x2a.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<in> fold (\\<union>)\n                  (map (phiDefNodes_aux g v\n                         (removeAll n\n                           (filter\n                             (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                             (\\<alpha>n g))))\n                    (m\\<^sub>1 # a # list))\n                  {n};\n        readArgs g v n (Mapping.update (n, v) [] phis)\n         (m\\<^sub>1 # a # list) =\n        (x1, x2);\n        Mapping.lookup phis (n, v) = Some x2a\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup phis (aa, v)\n 3. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        b \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)\n 4. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (removeAll n\n                              (filter\n                                (\\<lambda>n.\n                                    (n, v) \\<notin> Mapping.keys phis)\n                                (\\<alpha>n g))))\n                       (m\\<^sub>1 # a # list))\n                     {n}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)", "apply (auto simp: lookup_update_cases phis'_aux_def[abs_def])[1]"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        Mapping.lookup phis (n, v) = None;\n        aa \\<in> phiDefNodes_aux g v\n                  (removeAll n\n                    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g)))\n                  m\\<^sub>1;\n        n \\<noteq> aa;\n        aa \\<notin> phiDefNodes_aux g v\n                     (filter\n                       (\\<lambda>n.\n                           n \\<noteq> n \\<and>\n                           (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))\n                     m\\<^sub>1;\n        aa \\<notin> phiDefNodes_aux g v\n                     (filter\n                       (\\<lambda>n.\n                           n \\<noteq> n \\<and>\n                           (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))\n                     a;\n        \\<forall>x\\<in>set list.\n           aa \\<notin> phiDefNodes_aux g v\n                        (filter\n                          (\\<lambda>n.\n                              n \\<noteq> n \\<and>\n                              (n, v) \\<notin> Mapping.keys phis)\n                          (\\<alpha>n g))\n                        x\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup phis (aa, v)\n 2. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        Mapping.lookup phis (n, v) = None;\n        aa \\<in> phiDefNodes_aux g v\n                  (removeAll n\n                    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g)))\n                  a;\n        n \\<noteq> aa;\n        aa \\<notin> phiDefNodes_aux g v\n                     (filter\n                       (\\<lambda>n.\n                           n \\<noteq> n \\<and>\n                           (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))\n                     m\\<^sub>1;\n        aa \\<notin> phiDefNodes_aux g v\n                     (filter\n                       (\\<lambda>n.\n                           n \\<noteq> n \\<and>\n                           (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))\n                     a;\n        \\<forall>x\\<in>set list.\n           aa \\<notin> phiDefNodes_aux g v\n                        (filter\n                          (\\<lambda>n.\n                              n \\<noteq> n \\<and>\n                              (n, v) \\<notin> Mapping.keys phis)\n                          (\\<alpha>n g))\n                        x\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup phis (aa, v)\n 3. \\<And>m\\<^sub>1 a list aa x.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        Mapping.lookup phis (n, v) = None;\n        aa \\<in> phiDefNodes_aux g v\n                  (removeAll n\n                    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g)))\n                  x;\n        x \\<in> set list; n \\<noteq> aa;\n        aa \\<notin> phiDefNodes_aux g v\n                     (filter\n                       (\\<lambda>n.\n                           n \\<noteq> n \\<and>\n                           (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))\n                     m\\<^sub>1;\n        aa \\<notin> phiDefNodes_aux g v\n                     (filter\n                       (\\<lambda>n.\n                           n \\<noteq> n \\<and>\n                           (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))\n                     a;\n        \\<forall>x\\<in>set list.\n           aa \\<notin> phiDefNodes_aux g v\n                        (filter\n                          (\\<lambda>n.\n                              n \\<noteq> n \\<and>\n                              (n, v) \\<notin> Mapping.keys phis)\n                          (\\<alpha>n g))\n                        x\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup phis (aa, v)\n 4. \\<And>m\\<^sub>1 a list aa x1 x2 x2a.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<in> fold (\\<union>)\n                  (map (phiDefNodes_aux g v\n                         (removeAll n\n                           (filter\n                             (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                             (\\<alpha>n g))))\n                    (m\\<^sub>1 # a # list))\n                  {n};\n        readArgs g v n (Mapping.update (n, v) [] phis)\n         (m\\<^sub>1 # a # list) =\n        (x1, x2);\n        Mapping.lookup phis (n, v) = Some x2a\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup phis (aa, v)\n 5. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        b \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)\n 6. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (removeAll n\n                              (filter\n                                (\\<lambda>n.\n                                    (n, v) \\<notin> Mapping.keys phis)\n                                (\\<alpha>n g))))\n                       (m\\<^sub>1 # a # list))\n                     {n}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)", "apply (drule rev_subsetD, rule phiDefNodes_aux_unvisited_monotonic[where un'=\"[n'\\<leftarrow>\\<alpha>n g . n' \\<noteq> n \\<and> (n', v) \\<notin> Mapping.keys phis]\"]; auto)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        Mapping.lookup phis (n, v) = None;\n        aa \\<in> phiDefNodes_aux g v\n                  (removeAll n\n                    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g)))\n                  a;\n        n \\<noteq> aa;\n        aa \\<notin> phiDefNodes_aux g v\n                     (filter\n                       (\\<lambda>n.\n                           n \\<noteq> n \\<and>\n                           (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))\n                     m\\<^sub>1;\n        aa \\<notin> phiDefNodes_aux g v\n                     (filter\n                       (\\<lambda>n.\n                           n \\<noteq> n \\<and>\n                           (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))\n                     a;\n        \\<forall>x\\<in>set list.\n           aa \\<notin> phiDefNodes_aux g v\n                        (filter\n                          (\\<lambda>n.\n                              n \\<noteq> n \\<and>\n                              (n, v) \\<notin> Mapping.keys phis)\n                          (\\<alpha>n g))\n                        x\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup phis (aa, v)\n 2. \\<And>m\\<^sub>1 a list aa x.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        Mapping.lookup phis (n, v) = None;\n        aa \\<in> phiDefNodes_aux g v\n                  (removeAll n\n                    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g)))\n                  x;\n        x \\<in> set list; n \\<noteq> aa;\n        aa \\<notin> phiDefNodes_aux g v\n                     (filter\n                       (\\<lambda>n.\n                           n \\<noteq> n \\<and>\n                           (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))\n                     m\\<^sub>1;\n        aa \\<notin> phiDefNodes_aux g v\n                     (filter\n                       (\\<lambda>n.\n                           n \\<noteq> n \\<and>\n                           (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))\n                     a;\n        \\<forall>x\\<in>set list.\n           aa \\<notin> phiDefNodes_aux g v\n                        (filter\n                          (\\<lambda>n.\n                              n \\<noteq> n \\<and>\n                              (n, v) \\<notin> Mapping.keys phis)\n                          (\\<alpha>n g))\n                        x\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup phis (aa, v)\n 3. \\<And>m\\<^sub>1 a list aa x1 x2 x2a.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<in> fold (\\<union>)\n                  (map (phiDefNodes_aux g v\n                         (removeAll n\n                           (filter\n                             (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                             (\\<alpha>n g))))\n                    (m\\<^sub>1 # a # list))\n                  {n};\n        readArgs g v n (Mapping.update (n, v) [] phis)\n         (m\\<^sub>1 # a # list) =\n        (x1, x2);\n        Mapping.lookup phis (n, v) = Some x2a\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup phis (aa, v)\n 4. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        b \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)\n 5. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (removeAll n\n                              (filter\n                                (\\<lambda>n.\n                                    (n, v) \\<notin> Mapping.keys phis)\n                                (\\<alpha>n g))))\n                       (m\\<^sub>1 # a # list))\n                     {n}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)", "apply (drule rev_subsetD, rule phiDefNodes_aux_unvisited_monotonic[where un'=\"[n'\\<leftarrow>\\<alpha>n g . n' \\<noteq> n \\<and> (n', v) \\<notin> Mapping.keys phis]\"]; auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa x.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        Mapping.lookup phis (n, v) = None;\n        aa \\<in> phiDefNodes_aux g v\n                  (removeAll n\n                    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g)))\n                  x;\n        x \\<in> set list; n \\<noteq> aa;\n        aa \\<notin> phiDefNodes_aux g v\n                     (filter\n                       (\\<lambda>n.\n                           n \\<noteq> n \\<and>\n                           (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))\n                     m\\<^sub>1;\n        aa \\<notin> phiDefNodes_aux g v\n                     (filter\n                       (\\<lambda>n.\n                           n \\<noteq> n \\<and>\n                           (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))\n                     a;\n        \\<forall>x\\<in>set list.\n           aa \\<notin> phiDefNodes_aux g v\n                        (filter\n                          (\\<lambda>n.\n                              n \\<noteq> n \\<and>\n                              (n, v) \\<notin> Mapping.keys phis)\n                          (\\<alpha>n g))\n                        x\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup phis (aa, v)\n 2. \\<And>m\\<^sub>1 a list aa x1 x2 x2a.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<in> fold (\\<union>)\n                  (map (phiDefNodes_aux g v\n                         (removeAll n\n                           (filter\n                             (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                             (\\<alpha>n g))))\n                    (m\\<^sub>1 # a # list))\n                  {n};\n        readArgs g v n (Mapping.update (n, v) [] phis)\n         (m\\<^sub>1 # a # list) =\n        (x1, x2);\n        Mapping.lookup phis (n, v) = Some x2a\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup phis (aa, v)\n 3. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        b \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)\n 4. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (removeAll n\n                              (filter\n                                (\\<lambda>n.\n                                    (n, v) \\<notin> Mapping.keys phis)\n                                (\\<alpha>n g))))\n                       (m\\<^sub>1 # a # list))\n                     {n}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)", "apply (rename_tac m)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa m.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        Mapping.lookup phis (n, v) = None;\n        aa \\<in> phiDefNodes_aux g v\n                  (removeAll n\n                    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g)))\n                  m;\n        m \\<in> set list; n \\<noteq> aa;\n        aa \\<notin> phiDefNodes_aux g v\n                     (filter\n                       (\\<lambda>n.\n                           n \\<noteq> n \\<and>\n                           (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))\n                     m\\<^sub>1;\n        aa \\<notin> phiDefNodes_aux g v\n                     (filter\n                       (\\<lambda>n.\n                           n \\<noteq> n \\<and>\n                           (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))\n                     a;\n        \\<forall>x\\<in>set list.\n           aa \\<notin> phiDefNodes_aux g v\n                        (filter\n                          (\\<lambda>n.\n                              n \\<noteq> n \\<and>\n                              (n, v) \\<notin> Mapping.keys phis)\n                          (\\<alpha>n g))\n                        x\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup phis (aa, v)\n 2. \\<And>m\\<^sub>1 a list aa x1 x2 x2a.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<in> fold (\\<union>)\n                  (map (phiDefNodes_aux g v\n                         (removeAll n\n                           (filter\n                             (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                             (\\<alpha>n g))))\n                    (m\\<^sub>1 # a # list))\n                  {n};\n        readArgs g v n (Mapping.update (n, v) [] phis)\n         (m\\<^sub>1 # a # list) =\n        (x1, x2);\n        Mapping.lookup phis (n, v) = Some x2a\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup phis (aa, v)\n 3. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        b \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)\n 4. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (removeAll n\n                              (filter\n                                (\\<lambda>n.\n                                    (n, v) \\<notin> Mapping.keys phis)\n                                (\\<alpha>n g))))\n                       (m\\<^sub>1 # a # list))\n                     {n}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)", "apply (erule_tac x=m in ballE)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa m.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        Mapping.lookup phis (n, v) = None;\n        aa \\<in> phiDefNodes_aux g v\n                  (removeAll n\n                    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g)))\n                  m;\n        m \\<in> set list; n \\<noteq> aa;\n        aa \\<notin> phiDefNodes_aux g v\n                     (filter\n                       (\\<lambda>n.\n                           n \\<noteq> n \\<and>\n                           (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))\n                     m\\<^sub>1;\n        aa \\<notin> phiDefNodes_aux g v\n                     (filter\n                       (\\<lambda>n.\n                           n \\<noteq> n \\<and>\n                           (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))\n                     a;\n        aa \\<notin> phiDefNodes_aux g v\n                     (filter\n                       (\\<lambda>n.\n                           n \\<noteq> n \\<and>\n                           (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))\n                     m\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup phis (aa, v)\n 2. \\<And>m\\<^sub>1 a list aa m.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        Mapping.lookup phis (n, v) = None;\n        aa \\<in> phiDefNodes_aux g v\n                  (removeAll n\n                    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g)))\n                  m;\n        m \\<in> set list; n \\<noteq> aa;\n        aa \\<notin> phiDefNodes_aux g v\n                     (filter\n                       (\\<lambda>n.\n                           n \\<noteq> n \\<and>\n                           (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))\n                     m\\<^sub>1;\n        aa \\<notin> phiDefNodes_aux g v\n                     (filter\n                       (\\<lambda>n.\n                           n \\<noteq> n \\<and>\n                           (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))\n                     a;\n        m \\<notin> set list\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup phis (aa, v)\n 3. \\<And>m\\<^sub>1 a list aa x1 x2 x2a.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<in> fold (\\<union>)\n                  (map (phiDefNodes_aux g v\n                         (removeAll n\n                           (filter\n                             (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                             (\\<alpha>n g))))\n                    (m\\<^sub>1 # a # list))\n                  {n};\n        readArgs g v n (Mapping.update (n, v) [] phis)\n         (m\\<^sub>1 # a # list) =\n        (x1, x2);\n        Mapping.lookup phis (n, v) = Some x2a\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup phis (aa, v)\n 4. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        b \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)\n 5. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (removeAll n\n                              (filter\n                                (\\<lambda>n.\n                                    (n, v) \\<notin> Mapping.keys phis)\n                                (\\<alpha>n g))))\n                       (m\\<^sub>1 # a # list))\n                     {n}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)", "apply (drule rev_subsetD, rule phiDefNodes_aux_unvisited_monotonic[where un'=\"[n'\\<leftarrow>\\<alpha>n g . n' \\<noteq> n \\<and> (n', v) \\<notin> Mapping.keys phis]\"]; auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa m.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        Mapping.lookup phis (n, v) = None;\n        aa \\<in> phiDefNodes_aux g v\n                  (removeAll n\n                    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g)))\n                  m;\n        m \\<in> set list; n \\<noteq> aa;\n        aa \\<notin> phiDefNodes_aux g v\n                     (filter\n                       (\\<lambda>n.\n                           n \\<noteq> n \\<and>\n                           (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))\n                     m\\<^sub>1;\n        aa \\<notin> phiDefNodes_aux g v\n                     (filter\n                       (\\<lambda>n.\n                           n \\<noteq> n \\<and>\n                           (n, v) \\<notin> Mapping.keys phis)\n                       (\\<alpha>n g))\n                     a;\n        m \\<notin> set list\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup phis (aa, v)\n 2. \\<And>m\\<^sub>1 a list aa x1 x2 x2a.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<in> fold (\\<union>)\n                  (map (phiDefNodes_aux g v\n                         (removeAll n\n                           (filter\n                             (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                             (\\<alpha>n g))))\n                    (m\\<^sub>1 # a # list))\n                  {n};\n        readArgs g v n (Mapping.update (n, v) [] phis)\n         (m\\<^sub>1 # a # list) =\n        (x1, x2);\n        Mapping.lookup phis (n, v) = Some x2a\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup phis (aa, v)\n 3. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        b \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)\n 4. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (removeAll n\n                              (filter\n                                (\\<lambda>n.\n                                    (n, v) \\<notin> Mapping.keys phis)\n                                (\\<alpha>n g))))\n                       (m\\<^sub>1 # a # list))\n                     {n}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)", "apply auto[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa x1 x2 x2a.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<in> fold (\\<union>)\n                  (map (phiDefNodes_aux g v\n                         (removeAll n\n                           (filter\n                             (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                             (\\<alpha>n g))))\n                    (m\\<^sub>1 # a # list))\n                  {n};\n        readArgs g v n (Mapping.update (n, v) [] phis)\n         (m\\<^sub>1 # a # list) =\n        (x1, x2);\n        Mapping.lookup phis (n, v) = Some x2a\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup phis (aa, v)\n 2. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        b \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)\n 3. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (removeAll n\n                              (filter\n                                (\\<lambda>n.\n                                    (n, v) \\<notin> Mapping.keys phis)\n                                (\\<alpha>n g))))\n                       (m\\<^sub>1 # a # list))\n                     {n}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)", "apply (subst(asm) IH2, assumption, assumption)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa x1 x2 x2a.\n       \\<lbrakk>Mapping.lookup phis (n, v) = Some x2a;\n        predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<in> fold (\\<union>)\n                  (map (phiDefNodes_aux g v\n                         (removeAll n\n                           (filter\n                             (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                             (\\<alpha>n g))))\n                    (m\\<^sub>1 # a # list))\n                  {n}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (n, v) = None\n 2. \\<And>m\\<^sub>1 a list aa x1 x2 x2a.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<in> fold (\\<union>)\n                  (map (phiDefNodes_aux g v\n                         (removeAll n\n                           (filter\n                             (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                             (\\<alpha>n g))))\n                    (m\\<^sub>1 # a # list))\n                  {n};\n        (phis'_aux g v (set (m\\<^sub>1 # a # list))\n          (Mapping.update (n, v) [] phis),\n         map (\\<lambda>m. lookupDef g m v) (m\\<^sub>1 # a # list)) =\n        (x1, x2);\n        Mapping.lookup phis (n, v) = Some x2a\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa)) =\n                         Mapping.lookup phis (aa, v)\n 3. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        b \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)\n 4. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (removeAll n\n                              (filter\n                                (\\<lambda>n.\n                                    (n, v) \\<notin> Mapping.keys phis)\n                                (\\<alpha>n g))))\n                       (m\\<^sub>1 # a # list))\n                     {n}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)", "apply (auto simp: keys_dom_lookup)[2]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        b \\<noteq> v\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)\n 2. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (removeAll n\n                              (filter\n                                (\\<lambda>n.\n                                    (n, v) \\<notin> Mapping.keys phis)\n                                (\\<alpha>n g))))\n                       (m\\<^sub>1 # a # list))\n                     {n}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)", "apply (auto split: option.split prod.split)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa b x1 x2.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        b \\<noteq> v;\n        readArgs g v n (Mapping.update (n, v) [] phis)\n         (m\\<^sub>1 # a # list) =\n        (x1, x2);\n        Mapping.lookup phis (n, v) = None\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup (Mapping.update (n, v) x2 x1)\n                          (aa, b)\n 2. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (removeAll n\n                              (filter\n                                (\\<lambda>n.\n                                    (n, v) \\<notin> Mapping.keys phis)\n                                (\\<alpha>n g))))\n                       (m\\<^sub>1 # a # list))\n                     {n}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)", "apply (subst(asm) IH2, assumption, assumption, assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa b x1 x2.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        b \\<noteq> v;\n        (phis'_aux g v (set (m\\<^sub>1 # a # list))\n          (Mapping.update (n, v) [] phis),\n         map (\\<lambda>m. lookupDef g m v) (m\\<^sub>1 # a # list)) =\n        (x1, x2);\n        Mapping.lookup phis (n, v) = None\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup (Mapping.update (n, v) x2 x1)\n                          (aa, b)\n 2. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (removeAll n\n                              (filter\n                                (\\<lambda>n.\n                                    (n, v) \\<notin> Mapping.keys phis)\n                                (\\<alpha>n g))))\n                       (m\\<^sub>1 # a # list))\n                     {n}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)", "apply (auto simp: lookup_update_neq phis'_aux_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m\\<^sub>1 a list aa b.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (removeAll n\n                              (filter\n                                (\\<lambda>n.\n                                    (n, v) \\<notin> Mapping.keys phis)\n                                (\\<alpha>n g))))\n                       (m\\<^sub>1 # a # list))\n                     {n}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup\n                          (snd (case Mapping.lookup phis (n, v) of\n                                None \\<Rightarrow>\n                                  let phis = Mapping.update (n, v) [] phis;\n(phis, args) = readArgs g v n phis (m\\<^sub>1 # a # list)\n                                  in ((v, n, PhiDef),\nMapping.update (n, v) args phis)\n                                | Some x \\<Rightarrow>\n                                    ((v, n, PhiDef), phis)))\n                          (aa, b)", "apply (auto split: option.splits prod.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m\\<^sub>1 a list aa b x1 x2.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (removeAll n\n                              (filter\n                                (\\<lambda>n.\n                                    (n, v) \\<notin> Mapping.keys phis)\n                                (\\<alpha>n g))))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        readArgs g v n (Mapping.update (n, v) [] phis)\n         (m\\<^sub>1 # a # list) =\n        (x1, x2);\n        Mapping.lookup phis (n, v) = None\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup (Mapping.update (n, v) x2 x1)\n                          (aa, b)", "apply (subst(asm) IH2, assumption, assumption, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m\\<^sub>1 a list aa b x1 x2.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (removeAll n\n                              (filter\n                                (\\<lambda>n.\n                                    (n, v) \\<notin> Mapping.keys phis)\n                                (\\<alpha>n g))))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        (phis'_aux g v (set (m\\<^sub>1 # a # list))\n          (Mapping.update (n, v) [] phis),\n         map (\\<lambda>m. lookupDef g m v) (m\\<^sub>1 # a # list)) =\n        (x1, x2);\n        Mapping.lookup phis (n, v) = None\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, b) =\n                         Mapping.lookup (Mapping.update (n, v) x2 x1)\n                          (aa, b)", "apply (auto simp: lookup_update_cases phis'_aux_def removeAll_filter_not_eq image_def split: if_split_asm)[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m\\<^sub>1 a list.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        n \\<notin> fold (\\<union>)\n                    (map (phiDefNodes_aux g v\n                           (filter\n                             (\\<lambda>x.\n                                 (x, v) \\<notin> Mapping.keys phis \\<and>\n                                 n \\<noteq> x)\n                             (\\<alpha>n g)))\n                      (m\\<^sub>1 # a # list))\n                    {n};\n        Mapping.lookup phis (n, v) = None\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))\n 3. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  a\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))\n 4. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))", "apply (cut_tac fold_union_elemI)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>m\\<^sub>1 a list.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        n \\<notin> fold (\\<union>)\n                    (map (phiDefNodes_aux g v\n                           (filter\n                             (\\<lambda>x.\n                                 (x, v) \\<notin> Mapping.keys phis \\<and>\n                                 n \\<noteq> x)\n                             (\\<alpha>n g)))\n                      (m\\<^sub>1 # a # list))\n                    {n};\n        Mapping.lookup phis (n, v) = None;\n        ?x385 m\\<^sub>1 a list\n        \\<in> fold (\\<union>) (?xss385 m\\<^sub>1 a list)\n               (?xs385 m\\<^sub>1 a list)\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>m\\<^sub>1 a list.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        n \\<notin> fold (\\<union>)\n                    (map (phiDefNodes_aux g v\n                           (filter\n                             (\\<lambda>x.\n                                 (x, v) \\<notin> Mapping.keys phis \\<and>\n                                 n \\<noteq> x)\n                             (\\<alpha>n g)))\n                      (m\\<^sub>1 # a # list))\n                    {n};\n        Mapping.lookup phis (n, v) = None\\<rbrakk>\n       \\<Longrightarrow> ?x385 m\\<^sub>1 a list\n                         \\<in> ?ys385 m\\<^sub>1 a list\n 3. \\<And>m\\<^sub>1 a list.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        n \\<notin> fold (\\<union>)\n                    (map (phiDefNodes_aux g v\n                           (filter\n                             (\\<lambda>x.\n                                 (x, v) \\<notin> Mapping.keys phis \\<and>\n                                 n \\<noteq> x)\n                             (\\<alpha>n g)))\n                      (m\\<^sub>1 # a # list))\n                    {n};\n        Mapping.lookup phis (n, v) = None\\<rbrakk>\n       \\<Longrightarrow> ?ys385 m\\<^sub>1 a list\n                         \\<in> set (?xss385 m\\<^sub>1 a list) \\<union>\n                               {?xs385 m\\<^sub>1 a list}\n 4. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))\n 5. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  a\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))\n 6. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))", "apply auto[3]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))\n 2. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  a\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))\n 3. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))", "apply (cut_tac fold_union_elemI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  m\\<^sub>1;\n        ?x401 m\\<^sub>1 a list aa\n        \\<in> fold (\\<union>) (?xss401 m\\<^sub>1 a list aa)\n               (?xs401 m\\<^sub>1 a list aa)\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))\n 2. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> ?x401 m\\<^sub>1 a list aa\n                         \\<in> ?ys401 m\\<^sub>1 a list aa\n 3. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> ?ys401 m\\<^sub>1 a list aa\n                         \\<in> set (?xss401 m\\<^sub>1 a list aa) \\<union>\n                               {?xs401 m\\<^sub>1 a list aa}\n 4. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  a\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))\n 5. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))", "apply auto[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> aa \\<in> ?ys401 m\\<^sub>1 a list aa\n 2. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> ?ys401 m\\<^sub>1 a list aa\n                         \\<in> set (map (phiDefNodes_aux g v\n    (filter\n      (\\<lambda>x. (x, v) \\<notin> Mapping.keys phis \\<and> n \\<noteq> x)\n      (\\<alpha>n g)))\n                                     (m\\<^sub>1 # a # list)) \\<union>\n                               {{n}}\n 3. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  a\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))\n 4. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> phiDefNodes_aux g v\n                          (filter\n                            (\\<lambda>n.\n                                n \\<noteq> n \\<and>\n                                (n, v) \\<notin> Mapping.keys phis)\n                            (\\<alpha>n g))\n                          m\\<^sub>1\n                         \\<in> set (map (phiDefNodes_aux g v\n    (filter\n      (\\<lambda>x. (x, v) \\<notin> Mapping.keys phis \\<and> n \\<noteq> x)\n      (\\<alpha>n g)))\n                                     (m\\<^sub>1 # a # list)) \\<union>\n                               {{n}}\n 2. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  a\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))\n 3. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))", "apply (subgoal_tac \"[x\\<leftarrow>\\<alpha>n g . x \\<noteq> n \\<and> (x, v) \\<notin> Mapping.keys phis] = [x\\<leftarrow>\\<alpha>n g . (x, v) \\<notin> Mapping.keys phis \\<and> n \\<noteq> x]\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  m\\<^sub>1;\n        filter\n         (\\<lambda>x. x \\<noteq> n \\<and> (x, v) \\<notin> Mapping.keys phis)\n         (\\<alpha>n g) =\n        filter\n         (\\<lambda>x. (x, v) \\<notin> Mapping.keys phis \\<and> n \\<noteq> x)\n         (\\<alpha>n g)\\<rbrakk>\n       \\<Longrightarrow> phiDefNodes_aux g v\n                          (filter\n                            (\\<lambda>n.\n                                n \\<noteq> n \\<and>\n                                (n, v) \\<notin> Mapping.keys phis)\n                            (\\<alpha>n g))\n                          m\\<^sub>1\n                         \\<in> set (map (phiDefNodes_aux g v\n    (filter\n      (\\<lambda>x. (x, v) \\<notin> Mapping.keys phis \\<and> n \\<noteq> x)\n      (\\<alpha>n g)))\n                                     (m\\<^sub>1 # a # list)) \\<union>\n                               {{n}}\n 2. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> filter\n                          (\\<lambda>x.\n                              x \\<noteq> n \\<and>\n                              (x, v) \\<notin> Mapping.keys phis)\n                          (\\<alpha>n g) =\n                         filter\n                          (\\<lambda>x.\n                              (x, v) \\<notin> Mapping.keys phis \\<and>\n                              n \\<noteq> x)\n                          (\\<alpha>n g)\n 3. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  a\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))\n 4. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))", "apply auto[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> filter\n                          (\\<lambda>x.\n                              x \\<noteq> n \\<and>\n                              (x, v) \\<notin> Mapping.keys phis)\n                          (\\<alpha>n g) =\n                         filter\n                          (\\<lambda>x.\n                              (x, v) \\<notin> Mapping.keys phis \\<and>\n                              n \\<noteq> x)\n                          (\\<alpha>n g)\n 2. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  a\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))\n 3. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))", "apply (rule arg_cong2[where f=filter])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x.\n                             x \\<noteq> n \\<and>\n                             (x, v) \\<notin> Mapping.keys phis) =\n                         (\\<lambda>x.\n                             (x, v) \\<notin> Mapping.keys phis \\<and>\n                             n \\<noteq> x)\n 2. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  m\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>n g = \\<alpha>n g\n 3. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  a\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))\n 4. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))", "apply auto[2]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  a\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))\n 2. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))", "apply (cut_tac fold_union_elemI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  a;\n        ?x479 m\\<^sub>1 a list aa\n        \\<in> fold (\\<union>) (?xss479 m\\<^sub>1 a list aa)\n               (?xs479 m\\<^sub>1 a list aa)\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))\n 2. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  a\\<rbrakk>\n       \\<Longrightarrow> ?x479 m\\<^sub>1 a list aa\n                         \\<in> ?ys479 m\\<^sub>1 a list aa\n 3. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  a\\<rbrakk>\n       \\<Longrightarrow> ?ys479 m\\<^sub>1 a list aa\n                         \\<in> set (?xss479 m\\<^sub>1 a list aa) \\<union>\n                               {?xs479 m\\<^sub>1 a list aa}\n 4. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))", "apply auto[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  a\\<rbrakk>\n       \\<Longrightarrow> aa \\<in> ?ys479 m\\<^sub>1 a list aa\n 2. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  a\\<rbrakk>\n       \\<Longrightarrow> ?ys479 m\\<^sub>1 a list aa\n                         \\<in> set (map (phiDefNodes_aux g v\n    (filter\n      (\\<lambda>x. (x, v) \\<notin> Mapping.keys phis \\<and> n \\<noteq> x)\n      (\\<alpha>n g)))\n                                     (m\\<^sub>1 # a # list)) \\<union>\n                               {{n}}\n 3. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  a\\<rbrakk>\n       \\<Longrightarrow> phiDefNodes_aux g v\n                          (filter\n                            (\\<lambda>n.\n                                n \\<noteq> n \\<and>\n                                (n, v) \\<notin> Mapping.keys phis)\n                            (\\<alpha>n g))\n                          a\n                         \\<in> set (map (phiDefNodes_aux g v\n    (filter\n      (\\<lambda>x. (x, v) \\<notin> Mapping.keys phis \\<and> n \\<noteq> x)\n      (\\<alpha>n g)))\n                                     (m\\<^sub>1 # a # list)) \\<union>\n                               {{n}}\n 2. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))", "apply (subgoal_tac \"[x\\<leftarrow>\\<alpha>n g . x \\<noteq> n \\<and> (x, v) \\<notin> Mapping.keys phis] = [x\\<leftarrow>\\<alpha>n g . (x, v) \\<notin> Mapping.keys phis \\<and> n \\<noteq> x]\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  a;\n        filter\n         (\\<lambda>x. x \\<noteq> n \\<and> (x, v) \\<notin> Mapping.keys phis)\n         (\\<alpha>n g) =\n        filter\n         (\\<lambda>x. (x, v) \\<notin> Mapping.keys phis \\<and> n \\<noteq> x)\n         (\\<alpha>n g)\\<rbrakk>\n       \\<Longrightarrow> phiDefNodes_aux g v\n                          (filter\n                            (\\<lambda>n.\n                                n \\<noteq> n \\<and>\n                                (n, v) \\<notin> Mapping.keys phis)\n                            (\\<alpha>n g))\n                          a\n                         \\<in> set (map (phiDefNodes_aux g v\n    (filter\n      (\\<lambda>x. (x, v) \\<notin> Mapping.keys phis \\<and> n \\<noteq> x)\n      (\\<alpha>n g)))\n                                     (m\\<^sub>1 # a # list)) \\<union>\n                               {{n}}\n 2. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  a\\<rbrakk>\n       \\<Longrightarrow> filter\n                          (\\<lambda>x.\n                              x \\<noteq> n \\<and>\n                              (x, v) \\<notin> Mapping.keys phis)\n                          (\\<alpha>n g) =\n                         filter\n                          (\\<lambda>x.\n                              (x, v) \\<notin> Mapping.keys phis \\<and>\n                              n \\<noteq> x)\n                          (\\<alpha>n g)\n 3. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  a\\<rbrakk>\n       \\<Longrightarrow> filter\n                          (\\<lambda>x.\n                              x \\<noteq> n \\<and>\n                              (x, v) \\<notin> Mapping.keys phis)\n                          (\\<alpha>n g) =\n                         filter\n                          (\\<lambda>x.\n                              (x, v) \\<notin> Mapping.keys phis \\<and>\n                              n \\<noteq> x)\n                          (\\<alpha>n g)\n 2. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))", "apply (rule arg_cong2[where f=filter])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  a\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x.\n                             x \\<noteq> n \\<and>\n                             (x, v) \\<notin> Mapping.keys phis) =\n                         (\\<lambda>x.\n                             (x, v) \\<notin> Mapping.keys phis \\<and>\n                             n \\<noteq> x)\n 2. \\<And>m\\<^sub>1 a list aa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  a\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>n g = \\<alpha>n g\n 3. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))", "apply auto[2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))", "apply (cut_tac fold_union_elemI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list;\n        ?x557 m\\<^sub>1 a list aa xa\n        \\<in> fold (\\<union>) (?xss557 m\\<^sub>1 a list aa xa)\n               (?xs557 m\\<^sub>1 a list aa xa)\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup phis (aa, v) =\n                         Some\n                          (map (\\<lambda>m. lookupDef g m v)\n                            (predecessors g aa))\n 2. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> ?x557 m\\<^sub>1 a list aa xa\n                         \\<in> ?ys557 m\\<^sub>1 a list aa xa\n 3. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> ?ys557 m\\<^sub>1 a list aa xa\n                         \\<in> set (?xss557 m\\<^sub>1 a list aa xa) \\<union>\n                               {?xs557 m\\<^sub>1 a list aa xa}", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> aa \\<in> ?ys557 m\\<^sub>1 a list aa xa\n 2. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> ?ys557 m\\<^sub>1 a list aa xa\n                         \\<in> set (map (phiDefNodes_aux g v\n    (filter\n      (\\<lambda>x. (x, v) \\<notin> Mapping.keys phis \\<and> n \\<noteq> x)\n      (\\<alpha>n g)))\n                                     (m\\<^sub>1 # a # list)) \\<union>\n                               {{n}}", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> phiDefNodes_aux g v\n                          (filter\n                            (\\<lambda>n.\n                                n \\<noteq> n \\<and>\n                                (n, v) \\<notin> Mapping.keys phis)\n                            (\\<alpha>n g))\n                          xa\n                         \\<in> set (map (phiDefNodes_aux g v\n    (filter\n      (\\<lambda>x. (x, v) \\<notin> Mapping.keys phis \\<and> n \\<noteq> x)\n      (\\<alpha>n g)))\n                                     (m\\<^sub>1 # a # list)) \\<union>\n                               {{n}}", "apply (subgoal_tac \"[x\\<leftarrow>\\<alpha>n g . x \\<noteq> n \\<and> (x, v) \\<notin> Mapping.keys phis] = [x\\<leftarrow>\\<alpha>n g . (x, v) \\<notin> Mapping.keys phis \\<and> n \\<noteq> x]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list;\n        filter\n         (\\<lambda>x. x \\<noteq> n \\<and> (x, v) \\<notin> Mapping.keys phis)\n         (\\<alpha>n g) =\n        filter\n         (\\<lambda>x. (x, v) \\<notin> Mapping.keys phis \\<and> n \\<noteq> x)\n         (\\<alpha>n g)\\<rbrakk>\n       \\<Longrightarrow> phiDefNodes_aux g v\n                          (filter\n                            (\\<lambda>n.\n                                n \\<noteq> n \\<and>\n                                (n, v) \\<notin> Mapping.keys phis)\n                            (\\<alpha>n g))\n                          xa\n                         \\<in> set (map (phiDefNodes_aux g v\n    (filter\n      (\\<lambda>x. (x, v) \\<notin> Mapping.keys phis \\<and> n \\<noteq> x)\n      (\\<alpha>n g)))\n                                     (m\\<^sub>1 # a # list)) \\<union>\n                               {{n}}\n 2. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> filter\n                          (\\<lambda>x.\n                              x \\<noteq> n \\<and>\n                              (x, v) \\<notin> Mapping.keys phis)\n                          (\\<alpha>n g) =\n                         filter\n                          (\\<lambda>x.\n                              (x, v) \\<notin> Mapping.keys phis \\<and>\n                              n \\<noteq> x)\n                          (\\<alpha>n g)", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> filter\n                          (\\<lambda>x.\n                              x \\<noteq> n \\<and>\n                              (x, v) \\<notin> Mapping.keys phis)\n                          (\\<alpha>n g) =\n                         filter\n                          (\\<lambda>x.\n                              (x, v) \\<notin> Mapping.keys phis \\<and>\n                              n \\<noteq> x)\n                          (\\<alpha>n g)", "apply (rule arg_cong2[where f=filter])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x.\n                             x \\<noteq> n \\<and>\n                             (x, v) \\<notin> Mapping.keys phis) =\n                         (\\<lambda>x.\n                             (x, v) \\<notin> Mapping.keys phis \\<and>\n                             n \\<noteq> x)\n 2. \\<And>m\\<^sub>1 a list aa xa.\n       \\<lbrakk>predecessors g n = m\\<^sub>1 # a # list;\n        (n, v) \\<notin> Mapping.keys phis; v \\<notin> defs g n;\n        aa \\<notin> fold (\\<union>)\n                     (map (phiDefNodes_aux g v\n                            (filter\n                              (\\<lambda>x.\n                                  (x, v) \\<notin> Mapping.keys phis \\<and>\n                                  n \\<noteq> x)\n                              (\\<alpha>n g)))\n                       (m\\<^sub>1 # a # list))\n                     {n};\n        Mapping.lookup phis (n, v) = None; n \\<noteq> aa;\n        aa \\<in> phiDefNodes_aux g v\n                  (filter\n                    (\\<lambda>n.\n                        n \\<noteq> n \\<and>\n                        (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  xa;\n        xa \\<in> set list\\<rbrakk>\n       \\<Longrightarrow> \\<alpha>n g = \\<alpha>n g", "apply auto[2]"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  phis'_aux g v {n} phis = snd (readVariableRecursive g v n phis)\n\ngoal (2 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 2. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 2. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "case (3 g v n phis m ms)"], ["proof (state)\nthis:\n  \\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n   n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n   \\<And>n.\n      (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n      length (predecessors g n) \\<noteq> 1;\n   Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n  \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                     map (\\<lambda>m. lookupDef g m v) ms) =\n                    readArgs g v n phis ms\n  \\<lbrakk>?x2 = readArgs g v n phis ms; (?xa2, ?y2) = ?x2; v \\<in> vars g;\n   m \\<in> set (\\<alpha>n g); finite (Mapping.keys ?xa2);\n   \\<And>n.\n      (n, v) \\<in> Mapping.keys ?xa2 \\<Longrightarrow>\n      length (predecessors g n) \\<noteq> 1;\n   Mapping.lookup ?xa2 (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n  \\<Longrightarrow> phis'_aux g v {m} ?xa2 =\n                    snd (readVariableRecursive g v m ?xa2)\n  set (m # ms) \\<subseteq> set (\\<alpha>n g)\n  v \\<in> vars g\n  n \\<in> set (\\<alpha>n g)\n  finite (Mapping.keys phis)\n  (?n2, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n  Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\n\ngoal (2 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 2. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "note \"3.prems\"(2-4)[simp]"], ["proof (state)\nthis:\n  v \\<in> vars g\n  n \\<in> set (\\<alpha>n g)\n  finite (Mapping.keys phis)\n\ngoal (2 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 2. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "from \"3.prems\"(1)"], ["proof (chain)\npicking this:\n  set (m # ms) \\<subseteq> set (\\<alpha>n g)", "have[simp]: \"m \\<in> set (\\<alpha>n g)\""], ["proof (prove)\nusing this:\n  set (m # ms) \\<subseteq> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. m \\<in> set (\\<alpha>n g)", "by auto"], ["proof (state)\nthis:\n  m \\<in> set (\\<alpha>n g)\n\ngoal (2 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 2. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "from 3"], ["proof (chain)\npicking this:\n  \\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n   n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n   \\<And>n.\n      (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n      length (predecessors g n) \\<noteq> 1;\n   Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n  \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                     map (\\<lambda>m. lookupDef g m v) ms) =\n                    readArgs g v n phis ms\n  \\<lbrakk>?x2 = readArgs g v n phis ms; (?xa2, ?y2) = ?x2; v \\<in> vars g;\n   m \\<in> set (\\<alpha>n g); finite (Mapping.keys ?xa2);\n   \\<And>n.\n      (n, v) \\<in> Mapping.keys ?xa2 \\<Longrightarrow>\n      length (predecessors g n) \\<noteq> 1;\n   Mapping.lookup ?xa2 (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n  \\<Longrightarrow> phis'_aux g v {m} ?xa2 =\n                    snd (readVariableRecursive g v m ?xa2)\n  set (m # ms) \\<subseteq> set (\\<alpha>n g)\n  v \\<in> vars g\n  n \\<in> set (\\<alpha>n g)\n  finite (Mapping.keys phis)\n  (?n2, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n  Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}", "have IH1: \"readArgs g v n phis ms = (phis'_aux g v (set ms) phis, map (\\<lambda>m. lookupDef g m v) ms)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n   n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n   \\<And>n.\n      (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n      length (predecessors g n) \\<noteq> 1;\n   Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n  \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                     map (\\<lambda>m. lookupDef g m v) ms) =\n                    readArgs g v n phis ms\n  \\<lbrakk>?x2 = readArgs g v n phis ms; (?xa2, ?y2) = ?x2; v \\<in> vars g;\n   m \\<in> set (\\<alpha>n g); finite (Mapping.keys ?xa2);\n   \\<And>n.\n      (n, v) \\<in> Mapping.keys ?xa2 \\<Longrightarrow>\n      length (predecessors g n) \\<noteq> 1;\n   Mapping.lookup ?xa2 (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n  \\<Longrightarrow> phis'_aux g v {m} ?xa2 =\n                    snd (readVariableRecursive g v m ?xa2)\n  set (m # ms) \\<subseteq> set (\\<alpha>n g)\n  v \\<in> vars g\n  n \\<in> set (\\<alpha>n g)\n  finite (Mapping.keys phis)\n  (?n2, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n  Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\n\ngoal (1 subgoal):\n 1. readArgs g v n phis ms =\n    (phis'_aux g v (set ms) phis, map (\\<lambda>m. lookupDef g m v) ms)", "by auto"], ["proof (state)\nthis:\n  readArgs g v n phis ms =\n  (phis'_aux g v (set ms) phis, map (\\<lambda>m. lookupDef g m v) ms)\n\ngoal (2 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 2. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "have IH2: \"phis'_aux g v {m} (phis'_aux g v (set ms) phis) = snd (readVariableRecursive g v m (phis'_aux g v (set ms) phis))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phis'_aux g v {m} (phis'_aux g v (set ms) phis) =\n    snd (readVariableRecursive g v m (phis'_aux g v (set ms) phis))", "apply (rule \"3.IH\"(2))"], ["proof (prove)\ngoal (7 subgoals):\n 1. ?x2 = readArgs g v n phis ms\n 2. (phis'_aux g v (set ms) phis, ?y2) = ?x2\n 3. v \\<in> vars g\n 4. m \\<in> set (\\<alpha>n g)\n 5. finite (Mapping.keys (phis'_aux g v (set ms) phis))\n 6. \\<And>n.\n       (n, v)\n       \\<in> Mapping.keys (phis'_aux g v (set ms) phis) \\<Longrightarrow>\n       length (predecessors g n) \\<noteq> 1\n 7. Mapping.lookup (phis'_aux g v (set ms) phis) (Entry g, v)\n    \\<in> {None, Some []}", "apply (auto simp: IH1 intro: phis'_aux_finite)[5]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>n.\n       (n, v)\n       \\<in> Mapping.keys (phis'_aux g v (set ms) phis) \\<Longrightarrow>\n       length (predecessors g n) \\<noteq> 1\n 2. Mapping.lookup (phis'_aux g v (set ms) phis) (Entry g, v)\n    \\<in> {None, Some []}", "apply (simp add: phis'_aux_def keys_dom_lookup dom_def split: if_split_asm)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n.\n       \\<exists>x\\<in>set ms.\n          n \\<in> phiDefNodes_aux g v\n                   (filter (\\<lambda>n. Mapping.lookup phis (n, v) = None)\n                     (\\<alpha>n g))\n                   x \\<Longrightarrow>\n       length (predecessors g n) \\<noteq> Suc 0\n 2. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<in>set ms.\n                   n \\<notin> phiDefNodes_aux g v\n                               (filter\n                                 (\\<lambda>n.\n                                     Mapping.lookup phis (n, v) = None)\n                                 (\\<alpha>n g))\n                               x;\n        \\<exists>y. Mapping.lookup phis (n, v) = Some y\\<rbrakk>\n       \\<Longrightarrow> length (predecessors g n) \\<noteq> Suc 0\n 3. Mapping.lookup (phis'_aux g v (set ms) phis) (Entry g, v)\n    \\<in> {None, Some []}", "apply safe"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n x.\n       \\<lbrakk>x \\<in> set ms;\n        n \\<in> phiDefNodes_aux g v\n                 (filter (\\<lambda>n. Mapping.lookup phis (n, v) = None)\n                   (\\<alpha>n g))\n                 x;\n        length (predecessors g n) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>n y.\n       \\<lbrakk>\\<forall>x\\<in>set ms.\n                   n \\<notin> phiDefNodes_aux g v\n                               (filter\n                                 (\\<lambda>n.\n                                     Mapping.lookup phis (n, v) = None)\n                                 (\\<alpha>n g))\n                               x;\n        Mapping.lookup phis (n, v) = Some y;\n        length (predecessors g n) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>y.\n       \\<lbrakk>Mapping.lookup (phis'_aux g v (set ms) phis) (Entry g, v)\n                \\<notin> {};\n        Mapping.lookup (phis'_aux g v (set ms) phis) (Entry g, v) =\n        Some y\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup (phis'_aux g v (set ms) phis)\n                          (Entry g, v) =\n                         Some []", "apply (erule phiDefNodes_auxE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>n x.\n       \\<lbrakk>x \\<in> set ms; length (predecessors g n) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (\\<alpha>n g)\n 2. \\<And>n x ns.\n       \\<lbrakk>x \\<in> set ms; length (predecessors g n) = Suc 0;\n        g \\<turnstile> n-ns\\<rightarrow>x;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        unvisitedPath\n         (filter (\\<lambda>n. Mapping.lookup phis (n, v) = None)\n           (\\<alpha>n g))\n         ns\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n y.\n       \\<lbrakk>\\<forall>x\\<in>set ms.\n                   n \\<notin> phiDefNodes_aux g v\n                               (filter\n                                 (\\<lambda>n.\n                                     Mapping.lookup phis (n, v) = None)\n                                 (\\<alpha>n g))\n                               x;\n        Mapping.lookup phis (n, v) = Some y;\n        length (predecessors g n) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>y.\n       \\<lbrakk>Mapping.lookup (phis'_aux g v (set ms) phis) (Entry g, v)\n                \\<notin> {};\n        Mapping.lookup (phis'_aux g v (set ms) phis) (Entry g, v) =\n        Some y\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup (phis'_aux g v (set ms) phis)\n                          (Entry g, v) =\n                         Some []", "using \"3.prems\"(1,5)"], ["proof (prove)\nusing this:\n  set (m # ms) \\<subseteq> set (\\<alpha>n g)\n  (?n2, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n\ngoal (4 subgoals):\n 1. \\<And>n x.\n       \\<lbrakk>x \\<in> set ms; length (predecessors g n) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (\\<alpha>n g)\n 2. \\<And>n x ns.\n       \\<lbrakk>x \\<in> set ms; length (predecessors g n) = Suc 0;\n        g \\<turnstile> n-ns\\<rightarrow>x;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        unvisitedPath\n         (filter (\\<lambda>n. Mapping.lookup phis (n, v) = None)\n           (\\<alpha>n g))\n         ns\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>n y.\n       \\<lbrakk>\\<forall>x\\<in>set ms.\n                   n \\<notin> phiDefNodes_aux g v\n                               (filter\n                                 (\\<lambda>n.\n                                     Mapping.lookup phis (n, v) = None)\n                                 (\\<alpha>n g))\n                               x;\n        Mapping.lookup phis (n, v) = Some y;\n        length (predecessors g n) = Suc 0\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>y.\n       \\<lbrakk>Mapping.lookup (phis'_aux g v (set ms) phis) (Entry g, v)\n                \\<notin> {};\n        Mapping.lookup (phis'_aux g v (set ms) phis) (Entry g, v) =\n        Some y\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup (phis'_aux g v (set ms) phis)\n                          (Entry g, v) =\n                         Some []", "apply (auto simp: keys_dom_lookup)[3]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>Mapping.lookup (phis'_aux g v (set ms) phis) (Entry g, v)\n                \\<notin> {};\n        Mapping.lookup (phis'_aux g v (set ms) phis) (Entry g, v) =\n        Some y\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup (phis'_aux g v (set ms) phis)\n                          (Entry g, v) =\n                         Some []", "using \"3.prems\"(6)"], ["proof (prove)\nusing this:\n  Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>Mapping.lookup (phis'_aux g v (set ms) phis) (Entry g, v)\n                \\<notin> {};\n        Mapping.lookup (phis'_aux g v (set ms) phis) (Entry g, v) =\n        Some y\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup (phis'_aux g v (set ms) phis)\n                          (Entry g, v) =\n                         Some []", "apply (auto simp: phis'_aux_def split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  phis'_aux g v {m} (phis'_aux g v (set ms) phis) =\n  snd (readVariableRecursive g v m (phis'_aux g v (set ms) phis))\n\ngoal (2 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 2. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "have a: \"phiDefNodes_aux g v [n\\<leftarrow>\\<alpha>n g . (n, v) \\<notin> Mapping.keys (phis'_aux g v (set ms) phis)] m \\<subseteq> phiDefNodes_aux g v [n\\<leftarrow>\\<alpha>n g . (n, v) \\<notin> Mapping.keys phis] m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phiDefNodes_aux g v\n     (filter\n       (\\<lambda>n.\n           (n, v) \\<notin> Mapping.keys (phis'_aux g v (set ms) phis))\n       (\\<alpha>n g))\n     m\n    \\<subseteq> phiDefNodes_aux g v\n                 (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                   (\\<alpha>n g))\n                 m", "apply (rule phiDefNodes_aux_unvisited_monotonic)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (filter\n          (\\<lambda>n.\n              (n, v) \\<notin> Mapping.keys (phis'_aux g v (set ms) phis))\n          (\\<alpha>n g))\n    \\<subseteq> set (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g))", "by (auto dest: phis'_aux_keys_super[THEN subsetD])"], ["proof (state)\nthis:\n  phiDefNodes_aux g v\n   (filter\n     (\\<lambda>n.\n         (n, v) \\<notin> Mapping.keys (phis'_aux g v (set ms) phis))\n     (\\<alpha>n g))\n   m\n  \\<subseteq> phiDefNodes_aux g v\n               (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                 (\\<alpha>n g))\n               m\n\ngoal (2 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 2. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "{"], ["proof (state)\nthis:\n  phiDefNodes_aux g v\n   (filter\n     (\\<lambda>n.\n         (n, v) \\<notin> Mapping.keys (phis'_aux g v (set ms) phis))\n     (\\<alpha>n g))\n   m\n  \\<subseteq> phiDefNodes_aux g v\n               (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                 (\\<alpha>n g))\n               m\n\ngoal (2 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 2. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "fix n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 2. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "assume m:  \"n \\<in> phiDefNodes_aux g v [n\\<leftarrow>\\<alpha>n g . (n, v) \\<notin> Mapping.keys phis] m\" and\n             ms: \"\\<forall>x\\<in>set ms. n \\<notin> phiDefNodes_aux g v [n\\<leftarrow>\\<alpha>n g . (n, v) \\<notin> Mapping.keys phis] x\""], ["proof (state)\nthis:\n  n \\<in> phiDefNodes_aux g v\n           (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n             (\\<alpha>n g))\n           m\n  \\<forall>x\\<in>set ms.\n     n \\<notin> phiDefNodes_aux g v\n                 (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                   (\\<alpha>n g))\n                 x\n\ngoal (2 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 2. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "have \"n \\<in> phiDefNodes_aux g v [n\\<leftarrow>\\<alpha>n g . (n, v) \\<notin> Mapping.keys (phis'_aux g v (set ms) phis)] m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes_aux g v\n             (filter\n               (\\<lambda>n.\n                   (n, v)\n                   \\<notin> Mapping.keys (phis'_aux g v (set ms) phis))\n               (\\<alpha>n g))\n             m", "using m"], ["proof (prove)\nusing this:\n  n \\<in> phiDefNodes_aux g v\n           (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n             (\\<alpha>n g))\n           m\n\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes_aux g v\n             (filter\n               (\\<lambda>n.\n                   (n, v)\n                   \\<notin> Mapping.keys (phis'_aux g v (set ms) phis))\n               (\\<alpha>n g))\n             m", "apply-"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> phiDefNodes_aux g v\n             (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n               (\\<alpha>n g))\n             m \\<Longrightarrow>\n    n \\<in> phiDefNodes_aux g v\n             (filter\n               (\\<lambda>n.\n                   (n, v)\n                   \\<notin> Mapping.keys (phis'_aux g v (set ms) phis))\n               (\\<alpha>n g))\n             m", "apply (erule phiDefNodes_auxE, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ns.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        unvisitedPath\n         (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n           (\\<alpha>n g))\n         ns\\<rbrakk>\n       \\<Longrightarrow> n \\<in> phiDefNodes_aux g v\n                                  (filter\n                                    (\\<lambda>n.\n  (n, v) \\<notin> Mapping.keys (phis'_aux g v (set ms) phis))\n                                    (\\<alpha>n g))\n                                  m", "apply (rule phiDefNodes_auxI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ns.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        unvisitedPath\n         (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n           (\\<alpha>n g))\n         ns\\<rbrakk>\n       \\<Longrightarrow> g \\<turnstile> n-?ns4 ns\\<rightarrow>m\n 2. \\<And>ns.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        unvisitedPath\n         (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n           (\\<alpha>n g))\n         ns\\<rbrakk>\n       \\<Longrightarrow> unvisitedPath\n                          (filter\n                            (\\<lambda>n.\n                                (n, v)\n                                \\<notin> Mapping.keys\n    (phis'_aux g v (set ms) phis))\n                            (\\<alpha>n g))\n                          (?ns4 ns)\n 3. \\<And>ns.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        unvisitedPath\n         (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n           (\\<alpha>n g))\n         ns\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>set (?ns4 ns). v \\<notin> defs g n\n 4. \\<And>ns.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        unvisitedPath\n         (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n           (\\<alpha>n g))\n         ns\\<rbrakk>\n       \\<Longrightarrow> length (predecessors g n) \\<noteq> 1", "apply (auto simp: phis'_aux_def keys_dom_lookup split: if_split_asm)[3]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ns x xa.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> Suc 0; x \\<in> set ns;\n        distinct ns;\n        set ns\n        \\<subseteq> {x \\<in> set (\\<alpha>n g).\n                     (x, v) \\<notin> dom (Mapping.lookup phis)};\n        xa \\<in> set ms;\n        x \\<in> phiDefNodes_aux g v\n                 (filter\n                   (\\<lambda>n. (n, v) \\<notin> dom (Mapping.lookup phis))\n                   (\\<alpha>n g))\n                 xa\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ns x y.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> Suc 0; x \\<in> set ns;\n        distinct ns;\n        set ns\n        \\<subseteq> {x \\<in> set (\\<alpha>n g).\n                     (x, v) \\<notin> dom (Mapping.lookup phis)};\n        \\<forall>xa\\<in>set ms.\n           x \\<notin> phiDefNodes_aux g v\n                       (filter\n                         (\\<lambda>n.\n                             (n, v) \\<notin> dom (Mapping.lookup phis))\n                         (\\<alpha>n g))\n                       xa;\n        Mapping.lookup phis (x, v) = Some y\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>ns.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        unvisitedPath\n         (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n           (\\<alpha>n g))\n         ns\\<rbrakk>\n       \\<Longrightarrow> length (predecessors g n) \\<noteq> 1", "apply (drule phiDefNodes_aux_redirect)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>ns x xa.\n       \\<lbrakk>\\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> Suc 0; x \\<in> set ns;\n        distinct ns;\n        set ns\n        \\<subseteq> {x \\<in> set (\\<alpha>n g).\n                     (x, v) \\<notin> dom (Mapping.lookup phis)};\n        xa \\<in> set ms;\n        x \\<in> phiDefNodes_aux g v\n                 (filter\n                   (\\<lambda>n. (n, v) \\<notin> dom (Mapping.lookup phis))\n                   (\\<alpha>n g))\n                 xa\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>set ns.\n                            ?v62 ns x xa \\<notin> defs g n\n 2. \\<And>ns x xa.\n       \\<lbrakk>\\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> Suc 0; x \\<in> set ns;\n        distinct ns;\n        set ns\n        \\<subseteq> {x \\<in> set (\\<alpha>n g).\n                     (x, v) \\<notin> dom (Mapping.lookup phis)};\n        xa \\<in> set ms;\n        x \\<in> phiDefNodes_aux g v\n                 (filter\n                   (\\<lambda>n. (n, v) \\<notin> dom (Mapping.lookup phis))\n                   (\\<alpha>n g))\n                 xa\\<rbrakk>\n       \\<Longrightarrow> length (predecessors g n) \\<noteq> 1\n 3. \\<And>ns x xa.\n       \\<lbrakk>\\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> Suc 0; x \\<in> set ns;\n        distinct ns;\n        set ns\n        \\<subseteq> {x \\<in> set (\\<alpha>n g).\n                     (x, v) \\<notin> dom (Mapping.lookup phis)};\n        xa \\<in> set ms;\n        x \\<in> phiDefNodes_aux g v\n                 (filter\n                   (\\<lambda>n. (n, v) \\<notin> dom (Mapping.lookup phis))\n                   (\\<alpha>n g))\n                 xa\\<rbrakk>\n       \\<Longrightarrow> unvisitedPath (?un62 ns x xa) ns\n 4. \\<And>ns x xa.\n       \\<lbrakk>\\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> Suc 0; x \\<in> set ns;\n        distinct ns;\n        set ns\n        \\<subseteq> {x \\<in> set (\\<alpha>n g).\n                     (x, v) \\<notin> dom (Mapping.lookup phis)};\n        xa \\<in> set ms;\n        x \\<in> phiDefNodes_aux g v\n                 (filter\n                   (\\<lambda>n. (n, v) \\<notin> dom (Mapping.lookup phis))\n                   (\\<alpha>n g))\n                 xa\\<rbrakk>\n       \\<Longrightarrow> ?n'62 ns x xa \\<in> set ns\n 5. \\<And>ns x xa.\n       \\<lbrakk>\\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> Suc 0; x \\<in> set ns;\n        distinct ns;\n        set ns\n        \\<subseteq> {x \\<in> set (\\<alpha>n g).\n                     (x, v) \\<notin> dom (Mapping.lookup phis)};\n        xa \\<in> set ms;\n        x \\<in> phiDefNodes_aux g v\n                 (filter\n                   (\\<lambda>n. (n, v) \\<notin> dom (Mapping.lookup phis))\n                   (\\<alpha>n g))\n                 xa\\<rbrakk>\n       \\<Longrightarrow> ?n'62 ns x xa\n                         \\<in> phiDefNodes_aux g (?v62 ns x xa)\n                                (?un62 ns x xa) (?m'62 ns x xa)\n 6. \\<And>ns x xa.\n       \\<lbrakk>\\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> Suc 0; x \\<in> set ns;\n        distinct ns;\n        set ns\n        \\<subseteq> {x \\<in> set (\\<alpha>n g).\n                     (x, v) \\<notin> dom (Mapping.lookup phis)};\n        xa \\<in> set ms;\n        x \\<in> phiDefNodes_aux g v\n                 (filter\n                   (\\<lambda>n. (n, v) \\<notin> dom (Mapping.lookup phis))\n                   (\\<alpha>n g))\n                 xa\\<rbrakk>\n       \\<Longrightarrow> ?m'62 ns x xa \\<in> set (\\<alpha>n g)\n 7. \\<And>ns x xa.\n       \\<lbrakk>\\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> Suc 0; x \\<in> set ns;\n        distinct ns;\n        set ns\n        \\<subseteq> {x \\<in> set (\\<alpha>n g).\n                     (x, v) \\<notin> dom (Mapping.lookup phis)};\n        xa \\<in> set ms;\n        x \\<in> phiDefNodes_aux g v\n                 (filter\n                   (\\<lambda>n. (n, v) \\<notin> dom (Mapping.lookup phis))\n                   (\\<alpha>n g))\n                 xa;\n        n \\<in> phiDefNodes_aux g (?v62 ns x xa) (?un62 ns x xa)\n                 (?m'62 ns x xa)\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>ns x y.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> Suc 0; x \\<in> set ns;\n        distinct ns;\n        set ns\n        \\<subseteq> {x \\<in> set (\\<alpha>n g).\n                     (x, v) \\<notin> dom (Mapping.lookup phis)};\n        \\<forall>xa\\<in>set ms.\n           x \\<notin> phiDefNodes_aux g v\n                       (filter\n                         (\\<lambda>n.\n                             (n, v) \\<notin> dom (Mapping.lookup phis))\n                         (\\<alpha>n g))\n                       xa;\n        Mapping.lookup phis (x, v) = Some y\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>ns.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        unvisitedPath\n         (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n           (\\<alpha>n g))\n         ns\\<rbrakk>\n       \\<Longrightarrow> length (predecessors g n) \\<noteq> 1", "using \"3.prems\"(1)"], ["proof (prove)\nusing this:\n  set (m # ms) \\<subseteq> set (\\<alpha>n g)\n\ngoal (9 subgoals):\n 1. \\<And>ns x xa.\n       \\<lbrakk>\\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> Suc 0; x \\<in> set ns;\n        distinct ns;\n        set ns\n        \\<subseteq> {x \\<in> set (\\<alpha>n g).\n                     (x, v) \\<notin> dom (Mapping.lookup phis)};\n        xa \\<in> set ms;\n        x \\<in> phiDefNodes_aux g v\n                 (filter\n                   (\\<lambda>n. (n, v) \\<notin> dom (Mapping.lookup phis))\n                   (\\<alpha>n g))\n                 xa\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>set ns.\n                            ?v62 ns x xa \\<notin> defs g n\n 2. \\<And>ns x xa.\n       \\<lbrakk>\\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> Suc 0; x \\<in> set ns;\n        distinct ns;\n        set ns\n        \\<subseteq> {x \\<in> set (\\<alpha>n g).\n                     (x, v) \\<notin> dom (Mapping.lookup phis)};\n        xa \\<in> set ms;\n        x \\<in> phiDefNodes_aux g v\n                 (filter\n                   (\\<lambda>n. (n, v) \\<notin> dom (Mapping.lookup phis))\n                   (\\<alpha>n g))\n                 xa\\<rbrakk>\n       \\<Longrightarrow> length (predecessors g n) \\<noteq> 1\n 3. \\<And>ns x xa.\n       \\<lbrakk>\\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> Suc 0; x \\<in> set ns;\n        distinct ns;\n        set ns\n        \\<subseteq> {x \\<in> set (\\<alpha>n g).\n                     (x, v) \\<notin> dom (Mapping.lookup phis)};\n        xa \\<in> set ms;\n        x \\<in> phiDefNodes_aux g v\n                 (filter\n                   (\\<lambda>n. (n, v) \\<notin> dom (Mapping.lookup phis))\n                   (\\<alpha>n g))\n                 xa\\<rbrakk>\n       \\<Longrightarrow> unvisitedPath (?un62 ns x xa) ns\n 4. \\<And>ns x xa.\n       \\<lbrakk>\\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> Suc 0; x \\<in> set ns;\n        distinct ns;\n        set ns\n        \\<subseteq> {x \\<in> set (\\<alpha>n g).\n                     (x, v) \\<notin> dom (Mapping.lookup phis)};\n        xa \\<in> set ms;\n        x \\<in> phiDefNodes_aux g v\n                 (filter\n                   (\\<lambda>n. (n, v) \\<notin> dom (Mapping.lookup phis))\n                   (\\<alpha>n g))\n                 xa\\<rbrakk>\n       \\<Longrightarrow> ?n'62 ns x xa \\<in> set ns\n 5. \\<And>ns x xa.\n       \\<lbrakk>\\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> Suc 0; x \\<in> set ns;\n        distinct ns;\n        set ns\n        \\<subseteq> {x \\<in> set (\\<alpha>n g).\n                     (x, v) \\<notin> dom (Mapping.lookup phis)};\n        xa \\<in> set ms;\n        x \\<in> phiDefNodes_aux g v\n                 (filter\n                   (\\<lambda>n. (n, v) \\<notin> dom (Mapping.lookup phis))\n                   (\\<alpha>n g))\n                 xa\\<rbrakk>\n       \\<Longrightarrow> ?n'62 ns x xa\n                         \\<in> phiDefNodes_aux g (?v62 ns x xa)\n                                (?un62 ns x xa) (?m'62 ns x xa)\n 6. \\<And>ns x xa.\n       \\<lbrakk>\\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> Suc 0; x \\<in> set ns;\n        distinct ns;\n        set ns\n        \\<subseteq> {x \\<in> set (\\<alpha>n g).\n                     (x, v) \\<notin> dom (Mapping.lookup phis)};\n        xa \\<in> set ms;\n        x \\<in> phiDefNodes_aux g v\n                 (filter\n                   (\\<lambda>n. (n, v) \\<notin> dom (Mapping.lookup phis))\n                   (\\<alpha>n g))\n                 xa\\<rbrakk>\n       \\<Longrightarrow> ?m'62 ns x xa \\<in> set (\\<alpha>n g)\n 7. \\<And>ns x xa.\n       \\<lbrakk>\\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> Suc 0; x \\<in> set ns;\n        distinct ns;\n        set ns\n        \\<subseteq> {x \\<in> set (\\<alpha>n g).\n                     (x, v) \\<notin> dom (Mapping.lookup phis)};\n        xa \\<in> set ms;\n        x \\<in> phiDefNodes_aux g v\n                 (filter\n                   (\\<lambda>n. (n, v) \\<notin> dom (Mapping.lookup phis))\n                   (\\<alpha>n g))\n                 xa;\n        n \\<in> phiDefNodes_aux g (?v62 ns x xa) (?un62 ns x xa)\n                 (?m'62 ns x xa)\\<rbrakk>\n       \\<Longrightarrow> False\n 8. \\<And>ns x y.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> Suc 0; x \\<in> set ns;\n        distinct ns;\n        set ns\n        \\<subseteq> {x \\<in> set (\\<alpha>n g).\n                     (x, v) \\<notin> dom (Mapping.lookup phis)};\n        \\<forall>xa\\<in>set ms.\n           x \\<notin> phiDefNodes_aux g v\n                       (filter\n                         (\\<lambda>n.\n                             (n, v) \\<notin> dom (Mapping.lookup phis))\n                         (\\<alpha>n g))\n                       xa;\n        Mapping.lookup phis (x, v) = Some y\\<rbrakk>\n       \\<Longrightarrow> False\n 9. \\<And>ns.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        unvisitedPath\n         (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n           (\\<alpha>n g))\n         ns\\<rbrakk>\n       \\<Longrightarrow> length (predecessors g n) \\<noteq> 1", "apply auto[6]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>ns x xa.\n       \\<lbrakk>\\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> Suc 0; x \\<in> set ns;\n        distinct ns;\n        set ns\n        \\<subseteq> {x \\<in> set (\\<alpha>n g).\n                     (x, v) \\<notin> dom (Mapping.lookup phis)};\n        xa \\<in> set ms;\n        x \\<in> phiDefNodes_aux g v\n                 (filter\n                   (\\<lambda>n. (n, v) \\<notin> dom (Mapping.lookup phis))\n                   (\\<alpha>n g))\n                 xa;\n        n \\<in> phiDefNodes_aux g v\n                 (filter\n                   (\\<lambda>n. (n, v) \\<notin> dom (Mapping.lookup phis))\n                   (\\<alpha>n g))\n                 xa\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ns x y.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> Suc 0; x \\<in> set ns;\n        distinct ns;\n        set ns\n        \\<subseteq> {x \\<in> set (\\<alpha>n g).\n                     (x, v) \\<notin> dom (Mapping.lookup phis)};\n        \\<forall>xa\\<in>set ms.\n           x \\<notin> phiDefNodes_aux g v\n                       (filter\n                         (\\<lambda>n.\n                             (n, v) \\<notin> dom (Mapping.lookup phis))\n                         (\\<alpha>n g))\n                       xa;\n        Mapping.lookup phis (x, v) = Some y\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>ns.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        unvisitedPath\n         (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n           (\\<alpha>n g))\n         ns\\<rbrakk>\n       \\<Longrightarrow> length (predecessors g n) \\<noteq> 1", "apply (rule ms[THEN ballE]; auto simp: keys_dom_lookup)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ns x y.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> Suc 0; x \\<in> set ns;\n        distinct ns;\n        set ns\n        \\<subseteq> {x \\<in> set (\\<alpha>n g).\n                     (x, v) \\<notin> dom (Mapping.lookup phis)};\n        \\<forall>xa\\<in>set ms.\n           x \\<notin> phiDefNodes_aux g v\n                       (filter\n                         (\\<lambda>n.\n                             (n, v) \\<notin> dom (Mapping.lookup phis))\n                         (\\<alpha>n g))\n                       xa;\n        Mapping.lookup phis (x, v) = Some y\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>ns.\n       \\<lbrakk>g \\<turnstile> n-ns\\<rightarrow>m;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g n) \\<noteq> 1;\n        unvisitedPath\n         (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n           (\\<alpha>n g))\n         ns\\<rbrakk>\n       \\<Longrightarrow> length (predecessors g n) \\<noteq> 1", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  n \\<in> phiDefNodes_aux g v\n           (filter\n             (\\<lambda>n.\n                 (n, v) \\<notin> Mapping.keys (phis'_aux g v (set ms) phis))\n             (\\<alpha>n g))\n           m\n\ngoal (2 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 2. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?nb4\n           \\<in> phiDefNodes_aux g v\n                  (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  m;\n   \\<forall>x\\<in>set ms.\n      ?nb4\n      \\<notin> phiDefNodes_aux g v\n                (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                  (\\<alpha>n g))\n                x\\<rbrakk>\n  \\<Longrightarrow> ?nb4\n                    \\<in> phiDefNodes_aux g v\n                           (filter\n                             (\\<lambda>n.\n                                 (n, v)\n                                 \\<notin> Mapping.keys\n     (phis'_aux g v (set ms) phis))\n                             (\\<alpha>n g))\n                           m\n\ngoal (2 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 2. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "note b = this"], ["proof (state)\nthis:\n  \\<lbrakk>?nb4\n           \\<in> phiDefNodes_aux g v\n                  (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                    (\\<alpha>n g))\n                  m;\n   \\<forall>x\\<in>set ms.\n      ?nb4\n      \\<notin> phiDefNodes_aux g v\n                (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                  (\\<alpha>n g))\n                x\\<rbrakk>\n  \\<Longrightarrow> ?nb4\n                    \\<in> phiDefNodes_aux g v\n                           (filter\n                             (\\<lambda>n.\n                                 (n, v)\n                                 \\<notin> Mapping.keys\n     (phis'_aux g v (set ms) phis))\n                             (\\<alpha>n g))\n                           m\n\ngoal (2 subgoals):\n 1. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []\n 2. \\<And>g v n phis m ms.\n       \\<lbrakk>\\<lbrakk>set ms \\<subseteq> set (\\<alpha>n g);\n                 v \\<in> vars g; n \\<in> set (\\<alpha>n g);\n                 finite (Mapping.keys phis);\n                 \\<And>n.\n                    (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n                    length (predecessors g n) \\<noteq> 1;\n                 Mapping.lookup phis (Entry g, v)\n                 \\<in> {None, Some []}\\<rbrakk>\n                \\<Longrightarrow> (phis'_aux g v (set ms) phis,\n                                   map (\\<lambda>m. lookupDef g m v) ms) =\n                                  readArgs g v n phis ms;\n        \\<And>x xa y.\n           \\<lbrakk>x = readArgs g v n phis ms; (xa, y) = x; v \\<in> vars g;\n            m \\<in> set (\\<alpha>n g); finite (Mapping.keys xa);\n            \\<And>n.\n               (n, v) \\<in> Mapping.keys xa \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            Mapping.lookup xa (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> phis'_aux g v {m} xa =\n                             snd (readVariableRecursive g v m xa);\n        set (m # ms) \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set (m # ms)) phis,\n                          map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n                         readArgs g v n phis (m # ms)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (phis'_aux g v (set (m # ms)) phis,\n     map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n    readArgs g v n phis (m # ms)", "unfolding readArgs.simps phis'_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mapping\n      (\\<lambda>(ma, v\\<^sub>2).\n          if v\\<^sub>2 = v \\<and>\n             ma \\<in> \\<Union>\n                       (phiDefNodes_aux g v\n                         (filter\n                           (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                           (\\<alpha>n g)) `\n                        set (m # ms)) \\<and>\n             v \\<in> vars g\n          then Some (map (\\<lambda>m. lookupDef g m v) (predecessors g ma))\n          else Mapping.lookup phis (ma, v\\<^sub>2)),\n     map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n    (let (phis, args) = readArgs g v n phis ms;\n         (v, phis) = readVariableRecursive g v m phis\n     in (phis, v # args))", "unfolding IH1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mapping\n      (\\<lambda>(ma, v\\<^sub>2).\n          if v\\<^sub>2 = v \\<and>\n             ma \\<in> \\<Union>\n                       (phiDefNodes_aux g v\n                         (filter\n                           (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                           (\\<alpha>n g)) `\n                        set (m # ms)) \\<and>\n             v \\<in> vars g\n          then Some (map (\\<lambda>m. lookupDef g m v) (predecessors g ma))\n          else Mapping.lookup phis (ma, v\\<^sub>2)),\n     map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n    (let (phis, args) =\n           (phis'_aux g v (set ms) phis,\n            map (\\<lambda>m. lookupDef g m v) ms);\n         (v, phis) = readVariableRecursive g v m phis\n     in (phis, v # args))", "apply (simp add: split_def Let_def IH2[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping\n     (\\<lambda>p.\n         if snd p = v \\<and>\n            (fst p\n             \\<in> phiDefNodes_aux g v\n                    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g))\n                    m \\<or>\n             (\\<exists>x\\<in>set ms.\n                 fst p\n                 \\<in> phiDefNodes_aux g v\n                        (filter\n                          (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                          (\\<alpha>n g))\n                        x))\n         then Some\n               (map (\\<lambda>m. lookupDef g m v) (predecessors g (fst p)))\n         else Mapping.lookup phis (fst p, snd p)) =\n    phis'_aux g v {m} (phis'_aux g v (set ms) phis) \\<and>\n    lookupDef g m v =\n    fst (readVariableRecursive g v m (phis'_aux g v (set ms) phis))", "apply (subst phis'_aux_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping\n     (\\<lambda>p.\n         if snd p = v \\<and>\n            (fst p\n             \\<in> phiDefNodes_aux g v\n                    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g))\n                    m \\<or>\n             (\\<exists>x\\<in>set ms.\n                 fst p\n                 \\<in> phiDefNodes_aux g v\n                        (filter\n                          (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                          (\\<alpha>n g))\n                        x))\n         then Some\n               (map (\\<lambda>m. lookupDef g m v) (predecessors g (fst p)))\n         else Mapping.lookup phis (fst p, snd p)) =\n    Mapping\n     (\\<lambda>(ma, v\\<^sub>2).\n         if v\\<^sub>2 = v \\<and>\n            ma \\<in> \\<Union>\n                      (phiDefNodes_aux g v\n                        (filter\n                          (\\<lambda>n.\n                              (n, v)\n                              \\<notin> Mapping.keys\n  (phis'_aux g v (set ms) phis))\n                          (\\<alpha>n g)) `\n                       {m}) \\<and>\n            v \\<in> vars g\n         then Some (map (\\<lambda>m. lookupDef g m v) (predecessors g ma))\n         else Mapping.lookup (phis'_aux g v (set ms) phis)\n               (ma, v\\<^sub>2)) \\<and>\n    lookupDef g m v =\n    fst (readVariableRecursive g v m (phis'_aux g v (set ms) phis))", "apply (subst(2) phis'_aux_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping\n     (\\<lambda>p.\n         if snd p = v \\<and>\n            (fst p\n             \\<in> phiDefNodes_aux g v\n                    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                      (\\<alpha>n g))\n                    m \\<or>\n             (\\<exists>x\\<in>set ms.\n                 fst p\n                 \\<in> phiDefNodes_aux g v\n                        (filter\n                          (\\<lambda>n. (n, v) \\<notin> Mapping.keys phis)\n                          (\\<alpha>n g))\n                        x))\n         then Some\n               (map (\\<lambda>m. lookupDef g m v) (predecessors g (fst p)))\n         else Mapping.lookup phis (fst p, snd p)) =\n    Mapping\n     (\\<lambda>(ma, v\\<^sub>2).\n         if v\\<^sub>2 = v \\<and>\n            ma \\<in> \\<Union>\n                      (phiDefNodes_aux g v\n                        (filter\n                          (\\<lambda>n.\n                              (n, v)\n                              \\<notin> Mapping.keys\n  (phis'_aux g v (set ms) phis))\n                          (\\<alpha>n g)) `\n                       {m}) \\<and>\n            v \\<in> vars g\n         then Some (map (\\<lambda>m. lookupDef g m v) (predecessors g ma))\n         else Mapping.lookup\n               (Mapping\n                 (\\<lambda>(m, v\\<^sub>2).\n                     if v\\<^sub>2 = v \\<and>\n                        m \\<in> \\<Union>\n                                 (phiDefNodes_aux g v\n                                   (filter\n                                     (\\<lambda>n.\n   (n, v) \\<notin> Mapping.keys phis)\n                                     (\\<alpha>n g)) `\n                                  set ms) \\<and>\n                        v \\<in> vars g\n                     then Some\n                           (map (\\<lambda>m. lookupDef g m v)\n                             (predecessors g m))\n                     else Mapping.lookup phis (m, v\\<^sub>2)))\n               (ma, v\\<^sub>2)) \\<and>\n    lookupDef g m v =\n    fst (readVariableRecursive g v m (phis'_aux g v (set ms) phis))", "apply (auto simp: Mapping_eq_lookup fst_readVariableRecursive split: prod.splits intro!: ext dest!: a[THEN subsetD] b)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (phis'_aux g v (set (m # ms)) phis,\n   map (\\<lambda>m. lookupDef g m v) (m # ms)) =\n  readArgs g v n phis (m # ms)\n\ngoal (1 subgoal):\n 1. \\<And>g v n phis.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); v \\<in> vars g;\n        n \\<in> set (\\<alpha>n g); finite (Mapping.keys phis);\n        \\<And>n.\n           (n, v) \\<in> Mapping.keys phis \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        Mapping.lookup phis (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (phis'_aux g v (set []) phis,\n                          map (\\<lambda>m. lookupDef g m v) []) =\n                         readArgs g v n phis []", "qed (auto simp: readArgs.simps phis'_aux_def)"], ["", "definition \"aux_1 g n = (\\<lambda>v (uses,phis).\n    let (use,phis') = readVariableRecursive g v n phis in\n    (Mapping.update n (insert use (lookup_multimap uses n)) uses, phis')\n  )\""], ["", "definition \"aux_2 g n = foldr (aux_1 g n) (sorted_list_of_set (uses g n))\""], ["", "abbreviation \"init_state \\<equiv> (Mapping.empty, Mapping.empty)\""], ["", "abbreviation \"from_sparse \\<equiv> \\<lambda>(n,v). (n,(v,n,PhiDef))\""], ["", "definition \"uses'_phis' g = (\n    let (u,p) = foldr (aux_2 g) (\\<alpha>n g) init_state in\n    (u, map_keys from_sparse p)\n  )\""], ["", "lemma from_sparse_inj: \"inj from_sparse\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>(n, v). (n, v, n, PhiDef))", "by (rule injI, auto)"], ["", "declare uses'_phis'_def[unfolded aux_2_def[abs_def] aux_1_def, code]"], ["", "lift_definition phis'_code :: \"'g \\<Rightarrow> ('node, ('node, 'var) ssaVal) phis_code\" is phis'"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma foldr_prod: \"foldr (\\<lambda>x y. (f1 x (fst y), f2 x (snd y))) xs y = (foldr f1 xs (fst y), foldr f2 xs (snd y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>x y. (f1 x (fst y), f2 x (snd y))) xs y =\n    (foldr f1 xs (fst y), foldr f2 xs (snd y))", "by (induction xs, auto)"], ["", "lemma foldr_aux_1:\n    assumes \"set us \\<subseteq> uses g n\" \"Mapping.lookup u n = None\" \"foldr (aux_1 g n) us (u,p) = (u',p')\" (is \"foldr ?f _ _ = _\")\n    assumes \"finite (Mapping.keys p)\" \"\\<And>n v. (n,v) \\<in> Mapping.keys p \\<Longrightarrow> length (predecessors g n) \\<noteq> 1\" \"\\<And>v. Mapping.lookup p (Entry g,v) \\<in> {None, Some []}\"\n    shows \"lookupDef g n ` set us = lookup_multimap u' n\" \"\\<And>m. m \\<noteq> n \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\"\n      \"\\<And>m v. (if m \\<in> phiDefNodes_aux g v [n \\<leftarrow> \\<alpha>n g. (n,v) \\<notin> Mapping.keys p] n \\<and> v \\<in> set us then\n        Some (map (\\<lambda>m. lookupDef g m v) (predecessors g m)) else\n        (Mapping.lookup p (m,v))) = Mapping.lookup p' (m,v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookupDef g n ` set us = lookup_multimap u' n &&&\n    (\\<And>m.\n        m \\<noteq> n \\<Longrightarrow>\n        Mapping.lookup u' m = Mapping.lookup u m) &&&\n    (\\<And>m v.\n        (if m \\<in> phiDefNodes_aux g v\n                     (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p)\n                       (\\<alpha>n g))\n                     n \\<and>\n            v \\<in> set us\n         then Some (map (\\<lambda>m. lookupDef g m v) (predecessors g m))\n         else Mapping.lookup p (m, v)) =\n        Mapping.lookup p' (m, v))", "using assms"], ["proof (prove)\nusing this:\n  set us \\<subseteq> uses g n\n  Mapping.lookup u n = None\n  foldr (aux_1 g n) us (u, p) = (u', p')\n  finite (Mapping.keys p)\n  (?n2, ?v2) \\<in> Mapping.keys p \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n  Mapping.lookup p (Entry g, ?v2) \\<in> {None, Some []}\n\ngoal (1 subgoal):\n 1. lookupDef g n ` set us = lookup_multimap u' n &&&\n    (\\<And>m.\n        m \\<noteq> n \\<Longrightarrow>\n        Mapping.lookup u' m = Mapping.lookup u m) &&&\n    (\\<And>m v.\n        (if m \\<in> phiDefNodes_aux g v\n                     (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p)\n                       (\\<alpha>n g))\n                     n \\<and>\n            v \\<in> set us\n         then Some (map (\\<lambda>m. lookupDef g m v) (predecessors g m))\n         else Mapping.lookup p (m, v)) =\n        Mapping.lookup p' (m, v))", "proof (induction us arbitrary: u' p')"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set [] = lookup_multimap u' n\n 2. \\<And>m u' p'.\n       \\<lbrakk>m \\<noteq> n; set [] \\<subseteq> uses g n;\n        Mapping.lookup u n = None; foldr (aux_1 g n) [] (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 3. \\<And>m v u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set []\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)\n 4. \\<And>a us u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set (a # us) = lookup_multimap u' n\n 5. \\<And>a us m u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        m \\<noteq> n; set (a # us) \\<subseteq> uses g n;\n        Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 6. \\<And>a us m v u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set (a # us)\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)", "case (Cons v us)"], ["proof (state)\nthis:\n  \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n   foldr (aux_1 g n) us (u, p) = (?u'2, ?p'2); finite (Mapping.keys p);\n   \\<And>n v.\n      (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n      length (predecessors g n) \\<noteq> 1;\n   \\<And>v. Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n  \\<Longrightarrow> lookupDef g n ` set us = lookup_multimap ?u'2 n\n  \\<lbrakk>?m2 \\<noteq> n; set us \\<subseteq> uses g n;\n   Mapping.lookup u n = None; foldr (aux_1 g n) us (u, p) = (?u'2, ?p'2);\n   finite (Mapping.keys p);\n   \\<And>n v.\n      (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n      length (predecessors g n) \\<noteq> 1;\n   \\<And>v. Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n  \\<Longrightarrow> Mapping.lookup ?u'2 ?m2 = Mapping.lookup u ?m2\n  \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n   foldr (aux_1 g n) us (u, p) = (?u'2, ?p'2); finite (Mapping.keys p);\n   \\<And>n v.\n      (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n      length (predecessors g n) \\<noteq> 1;\n   \\<And>v. Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n  \\<Longrightarrow> (if ?m2\n                        \\<in> phiDefNodes_aux g ?v2\n                               (filter\n                                 (\\<lambda>n.\n                                     (n, ?v2) \\<notin> Mapping.keys p)\n                                 (\\<alpha>n g))\n                               n \\<and>\n                        ?v2 \\<in> set us\n                     then Some\n                           (map (\\<lambda>m. lookupDef g m ?v2)\n                             (predecessors g ?m2))\n                     else Mapping.lookup p (?m2, ?v2)) =\n                    Mapping.lookup ?p'2 (?m2, ?v2)\n\ngoal (6 subgoals):\n 1. \\<And>u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set [] = lookup_multimap u' n\n 2. \\<And>m u' p'.\n       \\<lbrakk>m \\<noteq> n; set [] \\<subseteq> uses g n;\n        Mapping.lookup u n = None; foldr (aux_1 g n) [] (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 3. \\<And>m v u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set []\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)\n 4. \\<And>a us u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set (a # us) = lookup_multimap u' n\n 5. \\<And>a us m u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        m \\<noteq> n; set (a # us) \\<subseteq> uses g n;\n        Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 6. \\<And>a us m v u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set (a # us)\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)", "let ?u = \"fst (foldr ?f us (u,p))\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set [] = lookup_multimap u' n\n 2. \\<And>m u' p'.\n       \\<lbrakk>m \\<noteq> n; set [] \\<subseteq> uses g n;\n        Mapping.lookup u n = None; foldr (aux_1 g n) [] (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 3. \\<And>m v u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set []\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)\n 4. \\<And>a us u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set (a # us) = lookup_multimap u' n\n 5. \\<And>a us m u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        m \\<noteq> n; set (a # us) \\<subseteq> uses g n;\n        Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 6. \\<And>a us m v u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set (a # us)\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)", "let ?p = \"snd (foldr ?f us (u,p))\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set [] = lookup_multimap u' n\n 2. \\<And>m u' p'.\n       \\<lbrakk>m \\<noteq> n; set [] \\<subseteq> uses g n;\n        Mapping.lookup u n = None; foldr (aux_1 g n) [] (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 3. \\<And>m v u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set []\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)\n 4. \\<And>a us u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set (a # us) = lookup_multimap u' n\n 5. \\<And>a us m u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        m \\<noteq> n; set (a # us) \\<subseteq> uses g n;\n        Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 6. \\<And>a us m v u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set (a # us)\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)", "{"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set [] = lookup_multimap u' n\n 2. \\<And>m u' p'.\n       \\<lbrakk>m \\<noteq> n; set [] \\<subseteq> uses g n;\n        Mapping.lookup u n = None; foldr (aux_1 g n) [] (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 3. \\<And>m v u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set []\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)\n 4. \\<And>a us u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set (a # us) = lookup_multimap u' n\n 5. \\<And>a us m u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        m \\<noteq> n; set (a # us) \\<subseteq> uses g n;\n        Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 6. \\<And>a us m v u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set (a # us)\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)", "case 1"], ["proof (state)\nthis:\n  set (v # us) \\<subseteq> uses g n\n  Mapping.lookup u n = None\n  foldr (aux_1 g n) (v # us) (u, p) = (u', p')\n  finite (Mapping.keys p)\n  (?n2, ?v2) \\<in> Mapping.keys p \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n  Mapping.lookup p (Entry g, ?v2) \\<in> {None, Some []}\n\ngoal (6 subgoals):\n 1. \\<And>u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set [] = lookup_multimap u' n\n 2. \\<And>m u' p'.\n       \\<lbrakk>m \\<noteq> n; set [] \\<subseteq> uses g n;\n        Mapping.lookup u n = None; foldr (aux_1 g n) [] (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 3. \\<And>m v u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set []\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)\n 4. \\<And>a us u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set (a # us) = lookup_multimap u' n\n 5. \\<And>a us m u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        m \\<noteq> n; set (a # us) \\<subseteq> uses g n;\n        Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 6. \\<And>a us m v u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set (a # us)\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)", "have \"n \\<in> set (\\<alpha>n g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> set (\\<alpha>n g)", "using 1(1) uses_in_\\<alpha>n"], ["proof (prove)\nusing this:\n  set (v # us) \\<subseteq> uses g n\n  ?v \\<in> uses ?g ?n \\<Longrightarrow> ?n \\<in> set (\\<alpha>n ?g)\n\ngoal (1 subgoal):\n 1. n \\<in> set (\\<alpha>n g)", "by auto"], ["proof (state)\nthis:\n  n \\<in> set (\\<alpha>n g)\n\ngoal (6 subgoals):\n 1. \\<And>u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set [] = lookup_multimap u' n\n 2. \\<And>m u' p'.\n       \\<lbrakk>m \\<noteq> n; set [] \\<subseteq> uses g n;\n        Mapping.lookup u n = None; foldr (aux_1 g n) [] (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 3. \\<And>m v u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set []\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)\n 4. \\<And>a us u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set (a # us) = lookup_multimap u' n\n 5. \\<And>a us m u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        m \\<noteq> n; set (a # us) \\<subseteq> uses g n;\n        Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 6. \\<And>a us m v u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set (a # us)\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)", "hence \"lookupDef g n v = fst (readVariableRecursive g v n ?p)\""], ["proof (prove)\nusing this:\n  n \\<in> set (\\<alpha>n g)\n\ngoal (1 subgoal):\n 1. lookupDef g n v =\n    fst (readVariableRecursive g v n (snd (foldr (aux_1 g n) us (u, p))))", "by (rule fst_readVariableRecursive[symmetric])"], ["proof (state)\nthis:\n  lookupDef g n v =\n  fst (readVariableRecursive g v n (snd (foldr (aux_1 g n) us (u, p))))\n\ngoal (6 subgoals):\n 1. \\<And>u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set [] = lookup_multimap u' n\n 2. \\<And>m u' p'.\n       \\<lbrakk>m \\<noteq> n; set [] \\<subseteq> uses g n;\n        Mapping.lookup u n = None; foldr (aux_1 g n) [] (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 3. \\<And>m v u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set []\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)\n 4. \\<And>a us u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set (a # us) = lookup_multimap u' n\n 5. \\<And>a us m u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        m \\<noteq> n; set (a # us) \\<subseteq> uses g n;\n        Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 6. \\<And>a us m v u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set (a # us)\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)", "moreover"], ["proof (state)\nthis:\n  lookupDef g n v =\n  fst (readVariableRecursive g v n (snd (foldr (aux_1 g n) us (u, p))))\n\ngoal (6 subgoals):\n 1. \\<And>u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set [] = lookup_multimap u' n\n 2. \\<And>m u' p'.\n       \\<lbrakk>m \\<noteq> n; set [] \\<subseteq> uses g n;\n        Mapping.lookup u n = None; foldr (aux_1 g n) [] (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 3. \\<And>m v u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set []\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)\n 4. \\<And>a us u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set (a # us) = lookup_multimap u' n\n 5. \\<And>a us m u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        m \\<noteq> n; set (a # us) \\<subseteq> uses g n;\n        Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 6. \\<And>a us m v u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set (a # us)\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)", "have \"lookupDef g n ` set us = lookup_multimap ?u n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookupDef g n ` set us =\n    lookup_multimap (fst (foldr (aux_1 g n) us (u, p))) n", "using 1"], ["proof (prove)\nusing this:\n  set (v # us) \\<subseteq> uses g n\n  Mapping.lookup u n = None\n  foldr (aux_1 g n) (v # us) (u, p) = (u', p')\n  finite (Mapping.keys p)\n  (?n2, ?v2) \\<in> Mapping.keys p \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n  Mapping.lookup p (Entry g, ?v2) \\<in> {None, Some []}\n\ngoal (1 subgoal):\n 1. lookupDef g n ` set us =\n    lookup_multimap (fst (foldr (aux_1 g n) us (u, p))) n", "by - (rule Cons(1)[of ?u ?p], auto)"], ["proof (state)\nthis:\n  lookupDef g n ` set us =\n  lookup_multimap (fst (foldr (aux_1 g n) us (u, p))) n\n\ngoal (6 subgoals):\n 1. \\<And>u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set [] = lookup_multimap u' n\n 2. \\<And>m u' p'.\n       \\<lbrakk>m \\<noteq> n; set [] \\<subseteq> uses g n;\n        Mapping.lookup u n = None; foldr (aux_1 g n) [] (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 3. \\<And>m v u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set []\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)\n 4. \\<And>a us u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set (a # us) = lookup_multimap u' n\n 5. \\<And>a us m u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        m \\<noteq> n; set (a # us) \\<subseteq> uses g n;\n        Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 6. \\<And>a us m v u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set (a # us)\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)", "ultimately"], ["proof (chain)\npicking this:\n  lookupDef g n v =\n  fst (readVariableRecursive g v n (snd (foldr (aux_1 g n) us (u, p))))\n  lookupDef g n ` set us =\n  lookup_multimap (fst (foldr (aux_1 g n) us (u, p))) n", "show ?case"], ["proof (prove)\nusing this:\n  lookupDef g n v =\n  fst (readVariableRecursive g v n (snd (foldr (aux_1 g n) us (u, p))))\n  lookupDef g n ` set us =\n  lookup_multimap (fst (foldr (aux_1 g n) us (u, p))) n\n\ngoal (1 subgoal):\n 1. lookupDef g n ` set (v # us) = lookup_multimap u' n", "using 1(3)"], ["proof (prove)\nusing this:\n  lookupDef g n v =\n  fst (readVariableRecursive g v n (snd (foldr (aux_1 g n) us (u, p))))\n  lookupDef g n ` set us =\n  lookup_multimap (fst (foldr (aux_1 g n) us (u, p))) n\n  foldr (aux_1 g n) (v # us) (u, p) = (u', p')\n\ngoal (1 subgoal):\n 1. lookupDef g n ` set (v # us) = lookup_multimap u' n", "by (auto simp: aux_1_def split_def Let_def lookup_multimap_def lookup_update split: option.splits)"], ["proof (state)\nthis:\n  lookupDef g n ` set (v # us) = lookup_multimap u' n\n\ngoal (5 subgoals):\n 1. \\<And>u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set [] = lookup_multimap u' n\n 2. \\<And>m u' p'.\n       \\<lbrakk>m \\<noteq> n; set [] \\<subseteq> uses g n;\n        Mapping.lookup u n = None; foldr (aux_1 g n) [] (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 3. \\<And>m v u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set []\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)\n 4. \\<And>a us m u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        m \\<noteq> n; set (a # us) \\<subseteq> uses g n;\n        Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 5. \\<And>a us m v u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set (a # us)\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set [] = lookup_multimap u' n\n 2. \\<And>m u' p'.\n       \\<lbrakk>m \\<noteq> n; set [] \\<subseteq> uses g n;\n        Mapping.lookup u n = None; foldr (aux_1 g n) [] (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 3. \\<And>m v u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set []\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)\n 4. \\<And>a us m u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        m \\<noteq> n; set (a # us) \\<subseteq> uses g n;\n        Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 5. \\<And>a us m v u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set (a # us)\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)", "case 2"], ["proof (state)\nthis:\n  m \\<noteq> n\n  set (v # us) \\<subseteq> uses g n\n  Mapping.lookup u n = None\n  foldr (aux_1 g n) (v # us) (u, p) = (u', p')\n  finite (Mapping.keys p)\n  (?n2, ?v2) \\<in> Mapping.keys p \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n  Mapping.lookup p (Entry g, ?v2) \\<in> {None, Some []}\n\ngoal (5 subgoals):\n 1. \\<And>u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set [] = lookup_multimap u' n\n 2. \\<And>m u' p'.\n       \\<lbrakk>m \\<noteq> n; set [] \\<subseteq> uses g n;\n        Mapping.lookup u n = None; foldr (aux_1 g n) [] (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 3. \\<And>m v u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set []\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)\n 4. \\<And>a us m u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        m \\<noteq> n; set (a # us) \\<subseteq> uses g n;\n        Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 5. \\<And>a us m v u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set (a # us)\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)", "have \"Mapping.lookup ?u m = Mapping.lookup u m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (fst (foldr (aux_1 g n) us (u, p))) m =\n    Mapping.lookup u m", "using 2"], ["proof (prove)\nusing this:\n  m \\<noteq> n\n  set (v # us) \\<subseteq> uses g n\n  Mapping.lookup u n = None\n  foldr (aux_1 g n) (v # us) (u, p) = (u', p')\n  finite (Mapping.keys p)\n  (?n2, ?v2) \\<in> Mapping.keys p \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n  Mapping.lookup p (Entry g, ?v2) \\<in> {None, Some []}\n\ngoal (1 subgoal):\n 1. Mapping.lookup (fst (foldr (aux_1 g n) us (u, p))) m =\n    Mapping.lookup u m", "by - (rule Cons(2)[of _ ?u ?p], auto)"], ["proof (state)\nthis:\n  Mapping.lookup (fst (foldr (aux_1 g n) us (u, p))) m = Mapping.lookup u m\n\ngoal (5 subgoals):\n 1. \\<And>u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set [] = lookup_multimap u' n\n 2. \\<And>m u' p'.\n       \\<lbrakk>m \\<noteq> n; set [] \\<subseteq> uses g n;\n        Mapping.lookup u n = None; foldr (aux_1 g n) [] (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 3. \\<And>m v u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set []\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)\n 4. \\<And>a us m u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        m \\<noteq> n; set (a # us) \\<subseteq> uses g n;\n        Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 5. \\<And>a us m v u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set (a # us)\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)", "thus ?case"], ["proof (prove)\nusing this:\n  Mapping.lookup (fst (foldr (aux_1 g n) us (u, p))) m = Mapping.lookup u m\n\ngoal (1 subgoal):\n 1. Mapping.lookup u' m = Mapping.lookup u m", "using 2"], ["proof (prove)\nusing this:\n  Mapping.lookup (fst (foldr (aux_1 g n) us (u, p))) m = Mapping.lookup u m\n  m \\<noteq> n\n  set (v # us) \\<subseteq> uses g n\n  Mapping.lookup u n = None\n  foldr (aux_1 g n) (v # us) (u, p) = (u', p')\n  finite (Mapping.keys p)\n  (?n2, ?v2) \\<in> Mapping.keys p \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n  Mapping.lookup p (Entry g, ?v2) \\<in> {None, Some []}\n\ngoal (1 subgoal):\n 1. Mapping.lookup u' m = Mapping.lookup u m", "by (auto simp: aux_1_def split_def Let_def lookup_multimap_def lookup_update_neq split: option.splits)"], ["proof (state)\nthis:\n  Mapping.lookup u' m = Mapping.lookup u m\n\ngoal (4 subgoals):\n 1. \\<And>u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set [] = lookup_multimap u' n\n 2. \\<And>m u' p'.\n       \\<lbrakk>m \\<noteq> n; set [] \\<subseteq> uses g n;\n        Mapping.lookup u n = None; foldr (aux_1 g n) [] (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 3. \\<And>m v u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set []\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)\n 4. \\<And>a us m v u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set (a # us)\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set [] = lookup_multimap u' n\n 2. \\<And>m u' p'.\n       \\<lbrakk>m \\<noteq> n; set [] \\<subseteq> uses g n;\n        Mapping.lookup u n = None; foldr (aux_1 g n) [] (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 3. \\<And>m v u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set []\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)\n 4. \\<And>a us m v u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set (a # us)\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)", "case (3 m v' u' p')"], ["proof (state)\nthis:\n  set (v # us) \\<subseteq> uses g n\n  Mapping.lookup u n = None\n  foldr (aux_1 g n) (v # us) (u, p) = (u', p')\n  finite (Mapping.keys p)\n  (?n2, ?v2) \\<in> Mapping.keys p \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n  Mapping.lookup p (Entry g, ?v2) \\<in> {None, Some []}\n\ngoal (4 subgoals):\n 1. \\<And>u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set [] = lookup_multimap u' n\n 2. \\<And>m u' p'.\n       \\<lbrakk>m \\<noteq> n; set [] \\<subseteq> uses g n;\n        Mapping.lookup u n = None; foldr (aux_1 g n) [] (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 3. \\<And>m v u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set []\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)\n 4. \\<And>a us m v u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set (a # us)\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)", "from 3(1)"], ["proof (chain)\npicking this:\n  set (v # us) \\<subseteq> uses g n", "have[simp]: \"\\<And>v. v \\<in> set us \\<Longrightarrow> v \\<in> vars g\""], ["proof (prove)\nusing this:\n  set (v # us) \\<subseteq> uses g n\n\ngoal (1 subgoal):\n 1. \\<And>v. v \\<in> set us \\<Longrightarrow> v \\<in> vars g", "by auto"], ["proof (state)\nthis:\n  ?v2 \\<in> set us \\<Longrightarrow> ?v2 \\<in> vars g\n\ngoal (4 subgoals):\n 1. \\<And>u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set [] = lookup_multimap u' n\n 2. \\<And>m u' p'.\n       \\<lbrakk>m \\<noteq> n; set [] \\<subseteq> uses g n;\n        Mapping.lookup u n = None; foldr (aux_1 g n) [] (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 3. \\<And>m v u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set []\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)\n 4. \\<And>a us m v u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set (a # us)\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)", "from 3"], ["proof (chain)\npicking this:\n  set (v # us) \\<subseteq> uses g n\n  Mapping.lookup u n = None\n  foldr (aux_1 g n) (v # us) (u, p) = (u', p')\n  finite (Mapping.keys p)\n  (?n2, ?v2) \\<in> Mapping.keys p \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n  Mapping.lookup p (Entry g, ?v2) \\<in> {None, Some []}", "have IH: \"\\<And>m v'. (if m \\<in> phiDefNodes_aux g v' [n \\<leftarrow> \\<alpha>n g. (n,v') \\<notin> Mapping.keys p] n \\<and> v' \\<in> set us then\n        Some (map (\\<lambda>m. lookupDef g m v') (predecessors g m)) else\n        (Mapping.lookup p (m,v'))) = Mapping.lookup ?p (m,v')\""], ["proof (prove)\nusing this:\n  set (v # us) \\<subseteq> uses g n\n  Mapping.lookup u n = None\n  foldr (aux_1 g n) (v # us) (u, p) = (u', p')\n  finite (Mapping.keys p)\n  (?n2, ?v2) \\<in> Mapping.keys p \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n  Mapping.lookup p (Entry g, ?v2) \\<in> {None, Some []}\n\ngoal (1 subgoal):\n 1. \\<And>m v'.\n       (if m \\<in> phiDefNodes_aux g v'\n                    (filter (\\<lambda>n. (n, v') \\<notin> Mapping.keys p)\n                      (\\<alpha>n g))\n                    n \\<and>\n           v' \\<in> set us\n        then Some (map (\\<lambda>m. lookupDef g m v') (predecessors g m))\n        else Mapping.lookup p (m, v')) =\n       Mapping.lookup (snd (foldr (aux_1 g n) us (u, p))) (m, v')", "by - (rule Cons(3)[of ?u ?p], auto)"], ["proof (state)\nthis:\n  (if ?m2\n      \\<in> phiDefNodes_aux g ?v'2\n             (filter (\\<lambda>n. (n, ?v'2) \\<notin> Mapping.keys p)\n               (\\<alpha>n g))\n             n \\<and>\n      ?v'2 \\<in> set us\n   then Some (map (\\<lambda>m. lookupDef g m ?v'2) (predecessors g ?m2))\n   else Mapping.lookup p (?m2, ?v'2)) =\n  Mapping.lookup (snd (foldr (aux_1 g n) us (u, p))) (?m2, ?v'2)\n\ngoal (4 subgoals):\n 1. \\<And>u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set [] = lookup_multimap u' n\n 2. \\<And>m u' p'.\n       \\<lbrakk>m \\<noteq> n; set [] \\<subseteq> uses g n;\n        Mapping.lookup u n = None; foldr (aux_1 g n) [] (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 3. \\<And>m v u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set []\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)\n 4. \\<And>a us m v u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set (a # us)\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)", "have rVV: \"phis'_aux g v {n} ?p = snd (readVariableRecursive g v n ?p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phis'_aux g v {n} (snd (foldr (aux_1 g n) us (u, p))) =\n    snd (readVariableRecursive g v n (snd (foldr (aux_1 g n) us (u, p))))", "apply (rule snd_readVariableRecursive(1))"], ["proof (prove)\ngoal (5 subgoals):\n 1. v \\<in> vars g\n 2. n \\<in> set (\\<alpha>n g)\n 3. finite (Mapping.keys (snd (foldr (aux_1 g n) us (u, p))))\n 4. \\<And>na.\n       (na, v)\n       \\<in> Mapping.keys\n              (snd (foldr (aux_1 g n) us (u, p))) \\<Longrightarrow>\n       length (predecessors g na) \\<noteq> 1\n 5. Mapping.lookup (snd (foldr (aux_1 g n) us (u, p))) (Entry g, v)\n    \\<in> {None, Some []}", "using 3"], ["proof (prove)\nusing this:\n  set (v # us) \\<subseteq> uses g n\n  Mapping.lookup u n = None\n  foldr (aux_1 g n) (v # us) (u, p) = (u', p')\n  finite (Mapping.keys p)\n  (?n2, ?v2) \\<in> Mapping.keys p \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n  Mapping.lookup p (Entry g, ?v2) \\<in> {None, Some []}\n\ngoal (5 subgoals):\n 1. v \\<in> vars g\n 2. n \\<in> set (\\<alpha>n g)\n 3. finite (Mapping.keys (snd (foldr (aux_1 g n) us (u, p))))\n 4. \\<And>na.\n       (na, v)\n       \\<in> Mapping.keys\n              (snd (foldr (aux_1 g n) us (u, p))) \\<Longrightarrow>\n       length (predecessors g na) \\<noteq> 1\n 5. Mapping.lookup (snd (foldr (aux_1 g n) us (u, p))) (Entry g, v)\n    \\<in> {None, Some []}", "apply (auto simp: uses_in_\\<alpha>n)[2]"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite (Mapping.keys (snd (foldr (aux_1 g n) us (u, p))))\n 2. \\<And>na.\n       (na, v)\n       \\<in> Mapping.keys\n              (snd (foldr (aux_1 g n) us (u, p))) \\<Longrightarrow>\n       length (predecessors g na) \\<noteq> 1\n 3. Mapping.lookup (snd (foldr (aux_1 g n) us (u, p))) (Entry g, v)\n    \\<in> {None, Some []}", "apply (rule finite_subset[where B=\"set (\\<alpha>n g) \\<times> vars g \\<union> Mapping.keys p\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. Mapping.keys (snd (foldr (aux_1 g n) us (u, p)))\n    \\<subseteq> set (\\<alpha>n g) \\<times> vars g \\<union> Mapping.keys p\n 2. finite (set (\\<alpha>n g) \\<times> vars g \\<union> Mapping.keys p)\n 3. \\<And>na.\n       (na, v)\n       \\<in> Mapping.keys\n              (snd (foldr (aux_1 g n) us (u, p))) \\<Longrightarrow>\n       length (predecessors g na) \\<noteq> 1\n 4. Mapping.lookup (snd (foldr (aux_1 g n) us (u, p))) (Entry g, v)\n    \\<in> {None, Some []}", "apply (auto simp: keys_dom_lookup IH[symmetric] split: if_split_asm dest!: phiDefNodes_aux_in_unvisited[THEN subsetD])[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite (set (\\<alpha>n g) \\<times> vars g \\<union> Mapping.keys p)\n 2. \\<And>na.\n       (na, v)\n       \\<in> Mapping.keys\n              (snd (foldr (aux_1 g n) us (u, p))) \\<Longrightarrow>\n       length (predecessors g na) \\<noteq> 1\n 3. Mapping.lookup (snd (foldr (aux_1 g n) us (u, p))) (Entry g, v)\n    \\<in> {None, Some []}", "apply (simp add: 3(4))[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       (na, v)\n       \\<in> Mapping.keys\n              (snd (foldr (aux_1 g n) us (u, p))) \\<Longrightarrow>\n       length (predecessors g na) \\<noteq> 1\n 2. Mapping.lookup (snd (foldr (aux_1 g n) us (u, p))) (Entry g, v)\n    \\<in> {None, Some []}", "using 3(5-6)"], ["proof (prove)\nusing this:\n  (?n2, ?v2) \\<in> Mapping.keys p \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n  Mapping.lookup p (Entry g, ?v2) \\<in> {None, Some []}\n\ngoal (2 subgoals):\n 1. \\<And>na.\n       (na, v)\n       \\<in> Mapping.keys\n              (snd (foldr (aux_1 g n) us (u, p))) \\<Longrightarrow>\n       length (predecessors g na) \\<noteq> 1\n 2. Mapping.lookup (snd (foldr (aux_1 g n) us (u, p))) (Entry g, v)\n    \\<in> {None, Some []}", "apply (auto simp: keys_dom_lookup dom_def IH[symmetric] split: if_split_asm dest!: phiDefNode_aux_is_join_node)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  phis'_aux g v {n} (snd (foldr (aux_1 g n) us (u, p))) =\n  snd (readVariableRecursive g v n (snd (foldr (aux_1 g n) us (u, p))))\n\ngoal (4 subgoals):\n 1. \\<And>u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set [] = lookup_multimap u' n\n 2. \\<And>m u' p'.\n       \\<lbrakk>m \\<noteq> n; set [] \\<subseteq> uses g n;\n        Mapping.lookup u n = None; foldr (aux_1 g n) [] (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 3. \\<And>m v u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set []\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)\n 4. \\<And>a us m v u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set (a # us)\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)", "have a: \"m \\<in> phiDefNodes_aux g v [n\\<leftarrow>\\<alpha>n g . (n, v) \\<notin> Mapping.keys ?p] n \\<Longrightarrow> m \\<in> phiDefNodes_aux g v [n\\<leftarrow>\\<alpha>n g . (n, v) \\<notin> Mapping.keys p] n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> phiDefNodes_aux g v\n             (filter\n               (\\<lambda>na.\n                   (na, v)\n                   \\<notin> Mapping.keys\n                             (snd (foldr (aux_1 g n) us (u, p))))\n               (\\<alpha>n g))\n             n \\<Longrightarrow>\n    m \\<in> phiDefNodes_aux g v\n             (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p)\n               (\\<alpha>n g))\n             n", "apply (erule rev_subsetD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. phiDefNodes_aux g v\n     (filter\n       (\\<lambda>na.\n           (na, v)\n           \\<notin> Mapping.keys (snd (foldr (aux_1 g n) us (u, p))))\n       (\\<alpha>n g))\n     n\n    \\<subseteq> phiDefNodes_aux g v\n                 (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p)\n                   (\\<alpha>n g))\n                 n", "apply (rule phiDefNodes_aux_unvisited_monotonic)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (filter\n          (\\<lambda>na.\n              (na, v)\n              \\<notin> Mapping.keys (snd (foldr (aux_1 g n) us (u, p))))\n          (\\<alpha>n g))\n    \\<subseteq> set (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p)\n                      (\\<alpha>n g))", "by (auto simp: IH[symmetric] keys_dom_lookup split: if_split_asm)"], ["proof (state)\nthis:\n  m \\<in> phiDefNodes_aux g v\n           (filter\n             (\\<lambda>na.\n                 (na, v)\n                 \\<notin> Mapping.keys (snd (foldr (aux_1 g n) us (u, p))))\n             (\\<alpha>n g))\n           n \\<Longrightarrow>\n  m \\<in> phiDefNodes_aux g v\n           (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p)\n             (\\<alpha>n g))\n           n\n\ngoal (4 subgoals):\n 1. \\<And>u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set [] = lookup_multimap u' n\n 2. \\<And>m u' p'.\n       \\<lbrakk>m \\<noteq> n; set [] \\<subseteq> uses g n;\n        Mapping.lookup u n = None; foldr (aux_1 g n) [] (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 3. \\<And>m v u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set []\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)\n 4. \\<And>a us m v u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set (a # us)\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)", "have b: \"v \\<notin> set us \\<Longrightarrow> [n\\<leftarrow>\\<alpha>n g . (n, v) \\<notin> Mapping.keys ?p] = [n\\<leftarrow>\\<alpha>n g . (n, v) \\<notin> Mapping.keys p]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> set us \\<Longrightarrow>\n    filter\n     (\\<lambda>na.\n         (na, v) \\<notin> Mapping.keys (snd (foldr (aux_1 g n) us (u, p))))\n     (\\<alpha>n g) =\n    filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)", "by (rule arg_cong2[where f=filter], auto simp: keys_dom_lookup IH[symmetric])"], ["proof (state)\nthis:\n  v \\<notin> set us \\<Longrightarrow>\n  filter\n   (\\<lambda>na.\n       (na, v) \\<notin> Mapping.keys (snd (foldr (aux_1 g n) us (u, p))))\n   (\\<alpha>n g) =\n  filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)\n\ngoal (4 subgoals):\n 1. \\<And>u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set [] = lookup_multimap u' n\n 2. \\<And>m u' p'.\n       \\<lbrakk>m \\<noteq> n; set [] \\<subseteq> uses g n;\n        Mapping.lookup u n = None; foldr (aux_1 g n) [] (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 3. \\<And>m v u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set []\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)\n 4. \\<And>a us m v u' p'.\n       \\<lbrakk>\\<And>u' p'.\n                   \\<lbrakk>set us \\<subseteq> uses g n;\n                    Mapping.lookup u n = None;\n                    foldr (aux_1 g n) us (u, p) = (u', p');\n                    finite (Mapping.keys p);\n                    \\<And>n v.\n                       (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n                       length (predecessors g n) \\<noteq> 1;\n                    \\<And>v.\n                       Mapping.lookup p (Entry g, v)\n                       \\<in> {None, Some []}\\<rbrakk>\n                   \\<Longrightarrow> lookupDef g n ` set us =\n                                     lookup_multimap u' n;\n        \\<And>m u' p'.\n           \\<lbrakk>m \\<noteq> n; set us \\<subseteq> uses g n;\n            Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m;\n        \\<And>m v u' p'.\n           \\<lbrakk>set us \\<subseteq> uses g n; Mapping.lookup u n = None;\n            foldr (aux_1 g n) us (u, p) = (u', p'); finite (Mapping.keys p);\n            \\<And>n v.\n               (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n               length (predecessors g n) \\<noteq> 1;\n            \\<And>v.\n               Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n           \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n    (filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g))\n    n \\<and>\n                                 v \\<in> set us\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g m))\n                              else Mapping.lookup p (m, v)) =\n                             Mapping.lookup p' (m, v);\n        set (a # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) (a # us) (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set (a # us)\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)", "from 3"], ["proof (chain)\npicking this:\n  set (v # us) \\<subseteq> uses g n\n  Mapping.lookup u n = None\n  foldr (aux_1 g n) (v # us) (u, p) = (u', p')\n  finite (Mapping.keys p)\n  (?n2, ?v2) \\<in> Mapping.keys p \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n  Mapping.lookup p (Entry g, ?v2) \\<in> {None, Some []}", "show ?case"], ["proof (prove)\nusing this:\n  set (v # us) \\<subseteq> uses g n\n  Mapping.lookup u n = None\n  foldr (aux_1 g n) (v # us) (u, p) = (u', p')\n  finite (Mapping.keys p)\n  (?n2, ?v2) \\<in> Mapping.keys p \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n  Mapping.lookup p (Entry g, ?v2) \\<in> {None, Some []}\n\ngoal (1 subgoal):\n 1. (if m \\<in> phiDefNodes_aux g v'\n                 (filter (\\<lambda>n. (n, v') \\<notin> Mapping.keys p)\n                   (\\<alpha>n g))\n                 n \\<and>\n        v' \\<in> set (v # us)\n     then Some (map (\\<lambda>m. lookupDef g m v') (predecessors g m))\n     else Mapping.lookup p (m, v')) =\n    Mapping.lookup p' (m, v')", "unfolding aux_1_def"], ["proof (prove)\nusing this:\n  set (v # us) \\<subseteq> uses g n\n  Mapping.lookup u n = None\n  foldr\n   (\\<lambda>a aa.\n       case aa of\n       (uses, phis) \\<Rightarrow>\n         let (use, y) = readVariableRecursive g a n phis\n         in (Mapping.update n (insert use (lookup_multimap uses n)) uses,\n             y))\n   (v # us) (u, p) =\n  (u', p')\n  finite (Mapping.keys p)\n  (?n2, ?v2) \\<in> Mapping.keys p \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n  Mapping.lookup p (Entry g, ?v2) \\<in> {None, Some []}\n\ngoal (1 subgoal):\n 1. (if m \\<in> phiDefNodes_aux g v'\n                 (filter (\\<lambda>n. (n, v') \\<notin> Mapping.keys p)\n                   (\\<alpha>n g))\n                 n \\<and>\n        v' \\<in> set (v # us)\n     then Some (map (\\<lambda>m. lookupDef g m v') (predecessors g m))\n     else Mapping.lookup p (m, v')) =\n    Mapping.lookup p' (m, v')", "unfolding foldr.foldr_Cons"], ["proof (prove)\nusing this:\n  set (v # us) \\<subseteq> uses g n\n  Mapping.lookup u n = None\n  ((\\<lambda>(uses, phis).\n       let (use, y) = readVariableRecursive g v n phis\n       in (Mapping.update n (insert use (lookup_multimap uses n)) uses,\n           y)) \\<circ>\\<circ>\\<circ>\n   foldr)\n   (\\<lambda>a (uses, phis).\n       let (use, y) = readVariableRecursive g a n phis\n       in (Mapping.update n (insert use (lookup_multimap uses n)) uses, y))\n   us (u, p) =\n  (u', p')\n  finite (Mapping.keys p)\n  (?n2, ?v2) \\<in> Mapping.keys p \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n  Mapping.lookup p (Entry g, ?v2) \\<in> {None, Some []}\n\ngoal (1 subgoal):\n 1. (if m \\<in> phiDefNodes_aux g v'\n                 (filter (\\<lambda>n. (n, v') \\<notin> Mapping.keys p)\n                   (\\<alpha>n g))\n                 n \\<and>\n        v' \\<in> set (v # us)\n     then Some (map (\\<lambda>m. lookupDef g m v') (predecessors g m))\n     else Mapping.lookup p (m, v')) =\n    Mapping.lookup p' (m, v')", "unfolding aux_1_def[symmetric]"], ["proof (prove)\nusing this:\n  set (v # us) \\<subseteq> uses g n\n  Mapping.lookup u n = None\n  ((\\<lambda>(uses, phis).\n       let (use, y) = readVariableRecursive g v n phis\n       in (Mapping.update n (insert use (lookup_multimap uses n)) uses,\n           y)) \\<circ>\\<circ>\\<circ>\n   foldr)\n   (aux_1 g n) us (u, p) =\n  (u', p')\n  finite (Mapping.keys p)\n  (?n2, ?v2) \\<in> Mapping.keys p \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n  Mapping.lookup p (Entry g, ?v2) \\<in> {None, Some []}\n\ngoal (1 subgoal):\n 1. (if m \\<in> phiDefNodes_aux g v'\n                 (filter (\\<lambda>n. (n, v') \\<notin> Mapping.keys p)\n                   (\\<alpha>n g))\n                 n \\<and>\n        v' \\<in> set (v # us)\n     then Some (map (\\<lambda>m. lookupDef g m v') (predecessors g m))\n     else Mapping.lookup p (m, v')) =\n    Mapping.lookup p' (m, v')", "by (auto simp: Let_def split_def IH[symmetric] rVV[symmetric] phis'_aux_def b dest: a uses_in_vars split: if_split_asm)"], ["proof (state)\nthis:\n  (if m \\<in> phiDefNodes_aux g v'\n               (filter (\\<lambda>n. (n, v') \\<notin> Mapping.keys p)\n                 (\\<alpha>n g))\n               n \\<and>\n      v' \\<in> set (v # us)\n   then Some (map (\\<lambda>m. lookupDef g m v') (predecessors g m))\n   else Mapping.lookup p (m, v')) =\n  Mapping.lookup p' (m, v')\n\ngoal (3 subgoals):\n 1. \\<And>u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set [] = lookup_multimap u' n\n 2. \\<And>m u' p'.\n       \\<lbrakk>m \\<noteq> n; set [] \\<subseteq> uses g n;\n        Mapping.lookup u n = None; foldr (aux_1 g n) [] (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 3. \\<And>m v u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set []\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>set (v # us) \\<subseteq> uses g n; Mapping.lookup u n = None;\n   foldr (aux_1 g n) (v # us) (u, p) = (?u'a4, ?p'a4);\n   finite (Mapping.keys p);\n   \\<And>n v.\n      (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n      length (predecessors g n) \\<noteq> 1;\n   \\<And>v. Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n  \\<Longrightarrow> (if ?m4\n                        \\<in> phiDefNodes_aux g ?v'4\n                               (filter\n                                 (\\<lambda>n.\n                                     (n, ?v'4) \\<notin> Mapping.keys p)\n                                 (\\<alpha>n g))\n                               n \\<and>\n                        ?v'4 \\<in> set (v # us)\n                     then Some\n                           (map (\\<lambda>m. lookupDef g m ?v'4)\n                             (predecessors g ?m4))\n                     else Mapping.lookup p (?m4, ?v'4)) =\n                    Mapping.lookup ?p'a4 (?m4, ?v'4)\n\ngoal (3 subgoals):\n 1. \\<And>u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> lookupDef g n ` set [] = lookup_multimap u' n\n 2. \\<And>m u' p'.\n       \\<lbrakk>m \\<noteq> n; set [] \\<subseteq> uses g n;\n        Mapping.lookup u n = None; foldr (aux_1 g n) [] (u, p) = (u', p');\n        finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup u m\n 3. \\<And>m v u' p'.\n       \\<lbrakk>set [] \\<subseteq> uses g n; Mapping.lookup u n = None;\n        foldr (aux_1 g n) [] (u, p) = (u', p'); finite (Mapping.keys p);\n        \\<And>n v.\n           (n, v) \\<in> Mapping.keys p \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup p (Entry g, v) \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter (\\<lambda>n. (n, v) \\<notin> Mapping.keys p) (\\<alpha>n g)) n \\<and>\n                             v \\<in> set []\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup p (m, v)) =\n                         Mapping.lookup p' (m, v)", "qed (auto simp: lookup_multimap_def)"], ["", "lemma foldr_aux_2:\n    assumes \"set ns \\<subseteq> set (\\<alpha>n g)\" \"distinct ns\" \"foldr (aux_2 g) ns init_state = (u',p')\"\n    shows \"\\<And>n. n \\<in> set ns \\<Longrightarrow> uses' g n = lookup_multimap u' n\" \"\\<And>n. n \\<notin> set ns \\<Longrightarrow> Mapping.lookup u' n = None\"\n      \"\\<And>m v. (if \\<exists>n \\<in> set ns. m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<and> v \\<in> uses g n then\n        Some (map (\\<lambda>m. lookupDef g m v) (predecessors g m)) else\n        None) = Mapping.lookup p' (m,v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        n \\<in> set ns \\<Longrightarrow>\n        uses' g n = lookup_multimap u' n) &&&\n    (\\<And>n.\n        n \\<notin> set ns \\<Longrightarrow> Mapping.lookup u' n = None) &&&\n    (\\<And>m v.\n        (if \\<exists>n\\<in>set ns.\n               m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<and>\n               v \\<in> uses g n\n         then Some (map (\\<lambda>m. lookupDef g m v) (predecessors g m))\n         else None) =\n        Mapping.lookup p' (m, v))", "using assms"], ["proof (prove)\nusing this:\n  set ns \\<subseteq> set (\\<alpha>n g)\n  distinct ns\n  foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) = (u', p')\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        n \\<in> set ns \\<Longrightarrow>\n        uses' g n = lookup_multimap u' n) &&&\n    (\\<And>n.\n        n \\<notin> set ns \\<Longrightarrow> Mapping.lookup u' n = None) &&&\n    (\\<And>m v.\n        (if \\<exists>n\\<in>set ns.\n               m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<and>\n               v \\<in> uses g n\n         then Some (map (\\<lambda>m. lookupDef g m v) (predecessors g m))\n         else None) =\n        Mapping.lookup p' (m, v))", "proof (induction ns arbitrary: u' p')"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)\n 4. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<in> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 5. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<notin> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 6. \\<And>a ns n v u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        set (a # ns) \\<subseteq> set (\\<alpha>n g); distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set (a # ns).\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "case (Cons n ns)"], ["proof (state)\nthis:\n  \\<lbrakk>?n2 \\<in> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n   distinct ns;\n   foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) = (?u'2, ?p'2)\\<rbrakk>\n  \\<Longrightarrow> uses' g ?n2 = lookup_multimap ?u'2 ?n2\n  \\<lbrakk>?n2 \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n   distinct ns;\n   foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) = (?u'2, ?p'2)\\<rbrakk>\n  \\<Longrightarrow> Mapping.lookup ?u'2 ?n2 = None\n  \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n   foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) = (?u'2, ?p'2)\\<rbrakk>\n  \\<Longrightarrow> (if \\<exists>n\\<in>set ns.\n                           ?n2\n                           \\<in> phiDefNodes_aux g ?v2 (\\<alpha>n g)\n                                  n \\<and>\n                           ?v2 \\<in> uses g n\n                     then Some\n                           (map (\\<lambda>m. lookupDef g m ?v2)\n                             (predecessors g ?n2))\n                     else None) =\n                    Mapping.lookup ?p'2 (?n2, ?v2)\n\ngoal (6 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)\n 4. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<in> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 5. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<notin> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 6. \\<And>a ns n v u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        set (a # ns) \\<subseteq> set (\\<alpha>n g); distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set (a # ns).\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "let ?u = \"fst (foldr (aux_2 g) ns init_state)\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)\n 4. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<in> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 5. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<notin> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 6. \\<And>a ns n v u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        set (a # ns) \\<subseteq> set (\\<alpha>n g); distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set (a # ns).\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "let ?p = \"snd (foldr (aux_2 g) ns init_state)\""], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)\n 4. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<in> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 5. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<notin> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 6. \\<And>a ns n v u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        set (a # ns) \\<subseteq> set (\\<alpha>n g); distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set (a # ns).\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "fix m u' p'"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)\n 4. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<in> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 5. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<notin> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 6. \\<And>a ns n v u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        set (a # ns) \\<subseteq> set (\\<alpha>n g); distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set (a # ns).\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "assume asm: \"set (n#ns) \\<subseteq> set (\\<alpha>n g)\" \"distinct (n#ns)\" \"foldr (aux_2 g) (n#ns) init_state = (u', p')\""], ["proof (state)\nthis:\n  set (n # ns) \\<subseteq> set (\\<alpha>n g)\n  distinct (n # ns)\n  foldr (aux_2 g) (n # ns) (Mapping.empty, Mapping.empty) = (u', p')\n\ngoal (6 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)\n 4. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<in> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 5. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<notin> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 6. \\<And>a ns n v u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        set (a # ns) \\<subseteq> set (\\<alpha>n g); distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set (a # ns).\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "hence IH:\n      \"\\<And>n. n \\<in> set ns \\<Longrightarrow> uses' g n = lookup_multimap ?u n\"\n      \"\\<And>n. n \\<notin> set ns \\<Longrightarrow> Mapping.lookup ?u n = None\"\n      \"\\<And>m v. (if \\<exists>n \\<in> set ns. m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<and> v \\<in> uses g n then\n        Some (map (\\<lambda>m. lookupDef g m v) (predecessors g m)) else\n        None) = Mapping.lookup ?p (m,v)\""], ["proof (prove)\nusing this:\n  set (n # ns) \\<subseteq> set (\\<alpha>n g)\n  distinct (n # ns)\n  foldr (aux_2 g) (n # ns) (Mapping.empty, Mapping.empty) = (u', p')\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        n \\<in> set ns \\<Longrightarrow>\n        uses' g n =\n        lookup_multimap\n         (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty))) n) &&&\n    (\\<And>n.\n        n \\<notin> set ns \\<Longrightarrow>\n        Mapping.lookup\n         (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty))) n =\n        None) &&&\n    (\\<And>m v.\n        (if \\<exists>n\\<in>set ns.\n               m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<and>\n               v \\<in> uses g n\n         then Some (map (\\<lambda>m. lookupDef g m v) (predecessors g m))\n         else None) =\n        Mapping.lookup\n         (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty))) (m, v))", "apply -"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>na \\<in> set ns; set (n # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (n # ns);\n        foldr (aux_2 g) (n # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g na =\n                         lookup_multimap\n                          (fst (foldr (aux_2 g) ns\n                                 (Mapping.empty, Mapping.empty)))\n                          na\n 2. \\<And>na.\n       \\<lbrakk>na \\<notin> set ns;\n        set (n # ns) \\<subseteq> set (\\<alpha>n g); distinct (n # ns);\n        foldr (aux_2 g) (n # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup\n                          (fst (foldr (aux_2 g) ns\n                                 (Mapping.empty, Mapping.empty)))\n                          na =\n                         None\n 3. \\<And>m v.\n       \\<lbrakk>set (n # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (n # ns);\n        foldr (aux_2 g) (n # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>n\\<in>set ns.\n                                m \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   n \\<and>\n                                v \\<in> uses g n\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else None) =\n                         Mapping.lookup\n                          (snd (foldr (aux_2 g) ns\n                                 (Mapping.empty, Mapping.empty)))\n                          (m, v)", "apply (rule Cons.IH(1)[where p'2=\"?p\"]; auto; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>na.\n       \\<lbrakk>na \\<notin> set ns;\n        set (n # ns) \\<subseteq> set (\\<alpha>n g); distinct (n # ns);\n        foldr (aux_2 g) (n # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup\n                          (fst (foldr (aux_2 g) ns\n                                 (Mapping.empty, Mapping.empty)))\n                          na =\n                         None\n 2. \\<And>m v.\n       \\<lbrakk>set (n # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (n # ns);\n        foldr (aux_2 g) (n # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>n\\<in>set ns.\n                                m \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   n \\<and>\n                                v \\<in> uses g n\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else None) =\n                         Mapping.lookup\n                          (snd (foldr (aux_2 g) ns\n                                 (Mapping.empty, Mapping.empty)))\n                          (m, v)", "apply (rule Cons.IH(2)[where p'2=\"?p\"]; auto; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m v.\n       \\<lbrakk>set (n # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (n # ns);\n        foldr (aux_2 g) (n # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>n\\<in>set ns.\n                                m \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   n \\<and>\n                                v \\<in> uses g n\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else None) =\n                         Mapping.lookup\n                          (snd (foldr (aux_2 g) ns\n                                 (Mapping.empty, Mapping.empty)))\n                          (m, v)", "by (rule Cons.IH(3)[where u'2=\"?u\"], auto)"], ["proof (state)\nthis:\n  ?n2 \\<in> set ns \\<Longrightarrow>\n  uses' g ?n2 =\n  lookup_multimap (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n   ?n2\n  ?n2 \\<notin> set ns \\<Longrightarrow>\n  Mapping.lookup (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n   ?n2 =\n  None\n  (if \\<exists>n\\<in>set ns.\n         ?m2 \\<in> phiDefNodes_aux g ?v2 (\\<alpha>n g) n \\<and>\n         ?v2 \\<in> uses g n\n   then Some (map (\\<lambda>m. lookupDef g m ?v2) (predecessors g ?m2))\n   else None) =\n  Mapping.lookup (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n   (?m2, ?v2)\n\ngoal (6 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)\n 4. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<in> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 5. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<notin> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 6. \\<And>a ns n v u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        set (a # ns) \\<subseteq> set (\\<alpha>n g); distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set (a # ns).\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "with this[of n] asm(2)"], ["proof (chain)\npicking this:\n  n \\<in> set ns \\<Longrightarrow>\n  uses' g n =\n  lookup_multimap (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n   n\n  n \\<notin> set ns \\<Longrightarrow>\n  Mapping.lookup (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n   n =\n  None\n  (if \\<exists>na\\<in>set ns.\n         n \\<in> phiDefNodes_aux g ?v2 (\\<alpha>n g) na \\<and>\n         ?v2 \\<in> uses g na\n   then Some (map (\\<lambda>m. lookupDef g m ?v2) (predecessors g n))\n   else None) =\n  Mapping.lookup (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n   (n, ?v2)\n  distinct (n # ns)\n  ?n2 \\<in> set ns \\<Longrightarrow>\n  uses' g ?n2 =\n  lookup_multimap (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n   ?n2\n  ?n2 \\<notin> set ns \\<Longrightarrow>\n  Mapping.lookup (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n   ?n2 =\n  None\n  (if \\<exists>n\\<in>set ns.\n         ?m2 \\<in> phiDefNodes_aux g ?v2 (\\<alpha>n g) n \\<and>\n         ?v2 \\<in> uses g n\n   then Some (map (\\<lambda>m. lookupDef g m ?v2) (predecessors g ?m2))\n   else None) =\n  Mapping.lookup (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n   (?m2, ?v2)", "have a': \"Mapping.lookup ?u n = None\""], ["proof (prove)\nusing this:\n  n \\<in> set ns \\<Longrightarrow>\n  uses' g n =\n  lookup_multimap (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n   n\n  n \\<notin> set ns \\<Longrightarrow>\n  Mapping.lookup (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n   n =\n  None\n  (if \\<exists>na\\<in>set ns.\n         n \\<in> phiDefNodes_aux g ?v2 (\\<alpha>n g) na \\<and>\n         ?v2 \\<in> uses g na\n   then Some (map (\\<lambda>m. lookupDef g m ?v2) (predecessors g n))\n   else None) =\n  Mapping.lookup (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n   (n, ?v2)\n  distinct (n # ns)\n  ?n2 \\<in> set ns \\<Longrightarrow>\n  uses' g ?n2 =\n  lookup_multimap (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n   ?n2\n  ?n2 \\<notin> set ns \\<Longrightarrow>\n  Mapping.lookup (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n   ?n2 =\n  None\n  (if \\<exists>n\\<in>set ns.\n         ?m2 \\<in> phiDefNodes_aux g ?v2 (\\<alpha>n g) n \\<and>\n         ?v2 \\<in> uses g n\n   then Some (map (\\<lambda>m. lookupDef g m ?v2) (predecessors g ?m2))\n   else None) =\n  Mapping.lookup (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n   (?m2, ?v2)\n\ngoal (1 subgoal):\n 1. Mapping.lookup (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n     n =\n    None", "by simp"], ["proof (state)\nthis:\n  Mapping.lookup (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n   n =\n  None\n\ngoal (6 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)\n 4. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<in> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 5. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<notin> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 6. \\<And>a ns n v u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        set (a # ns) \\<subseteq> set (\\<alpha>n g); distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set (a # ns).\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "moreover"], ["proof (state)\nthis:\n  Mapping.lookup (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n   n =\n  None\n\ngoal (6 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)\n 4. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<in> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 5. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<notin> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 6. \\<And>a ns n v u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        set (a # ns) \\<subseteq> set (\\<alpha>n g); distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set (a # ns).\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "have \"finite (Mapping.keys ?p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (Mapping.keys\n       (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty))))", "by (rule finite_subset[where B=\"set (\\<alpha>n g) \\<times> vars g\"]) (auto simp: keys_dom_lookup IH[symmetric] split: if_split_asm dest!: phiDefNodes_aux_in_unvisited[THEN subsetD])"], ["proof (state)\nthis:\n  finite\n   (Mapping.keys (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty))))\n\ngoal (6 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)\n 4. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<in> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 5. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<notin> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 6. \\<And>a ns n v u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        set (a # ns) \\<subseteq> set (\\<alpha>n g); distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set (a # ns).\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "moreover"], ["proof (state)\nthis:\n  finite\n   (Mapping.keys (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty))))\n\ngoal (6 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)\n 4. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<in> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 5. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<notin> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 6. \\<And>a ns n v u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        set (a # ns) \\<subseteq> set (\\<alpha>n g); distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set (a # ns).\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "have \"\\<And>n v. (n,v) \\<in> Mapping.keys ?p \\<Longrightarrow> length (predecessors g n) \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n v.\n       (n, v)\n       \\<in> Mapping.keys\n              (snd (foldr (aux_2 g) ns\n                     (Mapping.empty, Mapping.empty))) \\<Longrightarrow>\n       length (predecessors g n) \\<noteq> 1", "by (auto simp: keys_dom_lookup dom_def IH[symmetric] split: if_split_asm dest!: phiDefNode_aux_is_join_node)"], ["proof (state)\nthis:\n  (?n2, ?v2)\n  \\<in> Mapping.keys\n         (snd (foldr (aux_2 g) ns\n                (Mapping.empty, Mapping.empty))) \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n\ngoal (6 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)\n 4. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<in> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 5. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<notin> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 6. \\<And>a ns n v u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        set (a # ns) \\<subseteq> set (\\<alpha>n g); distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set (a # ns).\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "moreover"], ["proof (state)\nthis:\n  (?n2, ?v2)\n  \\<in> Mapping.keys\n         (snd (foldr (aux_2 g) ns\n                (Mapping.empty, Mapping.empty))) \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n\ngoal (6 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)\n 4. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<in> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 5. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<notin> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 6. \\<And>a ns n v u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        set (a # ns) \\<subseteq> set (\\<alpha>n g); distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set (a # ns).\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "have \"\\<And>v. Mapping.lookup ?p (Entry g,v) \\<in> {None, Some []}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       Mapping.lookup\n        (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n        (Entry g, v)\n       \\<in> {None, Some []}", "by (auto simp: IH[symmetric])"], ["proof (state)\nthis:\n  Mapping.lookup (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n   (Entry g, ?v2)\n  \\<in> {None, Some []}\n\ngoal (6 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)\n 4. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<in> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 5. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<notin> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 6. \\<And>a ns n v u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        set (a # ns) \\<subseteq> set (\\<alpha>n g); distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set (a # ns).\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "ultimately"], ["proof (chain)\npicking this:\n  Mapping.lookup (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n   n =\n  None\n  finite\n   (Mapping.keys (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty))))\n  (?n2, ?v2)\n  \\<in> Mapping.keys\n         (snd (foldr (aux_2 g) ns\n                (Mapping.empty, Mapping.empty))) \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n  Mapping.lookup (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n   (Entry g, ?v2)\n  \\<in> {None, Some []}", "have aux_2: \"lookupDef g n ` uses g n = lookup_multimap u' n\" \"\\<And>m. m \\<noteq> n \\<Longrightarrow> Mapping.lookup u' m = Mapping.lookup ?u m\"\n      \"\\<And>m v. (if m \\<in> phiDefNodes_aux g v [n \\<leftarrow> \\<alpha>n g. (n,v) \\<notin> Mapping.keys ?p] n \\<and> v \\<in> uses g n then\n        Some (map (\\<lambda>m. lookupDef g m v) (predecessors g m)) else\n        (Mapping.lookup ?p (m,v))) = Mapping.lookup p' (m,v)\""], ["proof (prove)\nusing this:\n  Mapping.lookup (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n   n =\n  None\n  finite\n   (Mapping.keys (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty))))\n  (?n2, ?v2)\n  \\<in> Mapping.keys\n         (snd (foldr (aux_2 g) ns\n                (Mapping.empty, Mapping.empty))) \\<Longrightarrow>\n  length (predecessors g ?n2) \\<noteq> 1\n  Mapping.lookup (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n   (Entry g, ?v2)\n  \\<in> {None, Some []}\n\ngoal (1 subgoal):\n 1. lookupDef g n ` uses g n = lookup_multimap u' n &&&\n    (\\<And>m.\n        m \\<noteq> n \\<Longrightarrow>\n        Mapping.lookup u' m =\n        Mapping.lookup\n         (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty))) m) &&&\n    (\\<And>m v.\n        (if m \\<in> phiDefNodes_aux g v\n                     (filter\n                       (\\<lambda>n.\n                           (n, v)\n                           \\<notin> Mapping.keys\n                                     (snd\n (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty))))\n                       (\\<alpha>n g))\n                     n \\<and>\n            v \\<in> uses g n\n         then Some (map (\\<lambda>m. lookupDef g m v) (predecessors g m))\n         else Mapping.lookup\n               (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n               (m, v)) =\n        Mapping.lookup p' (m, v))", "apply-"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Mapping.lookup\n              (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty))) n =\n             None;\n     finite\n      (Mapping.keys\n        (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty))));\n     \\<And>n v.\n        (n, v)\n        \\<in> Mapping.keys\n               (snd (foldr (aux_2 g) ns\n                      (Mapping.empty, Mapping.empty))) \\<Longrightarrow>\n        length (predecessors g n) \\<noteq> 1;\n     \\<And>v.\n        Mapping.lookup\n         (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n         (Entry g, v)\n        \\<in> {None, Some []}\\<rbrakk>\n    \\<Longrightarrow> lookupDef g n ` uses g n = lookup_multimap u' n\n 2. \\<And>m.\n       \\<lbrakk>m \\<noteq> n;\n        Mapping.lookup\n         (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty))) n =\n        None;\n        finite\n         (Mapping.keys\n           (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty))));\n        \\<And>n v.\n           (n, v)\n           \\<in> Mapping.keys\n                  (snd (foldr (aux_2 g) ns\n                         (Mapping.empty, Mapping.empty))) \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup\n            (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n            (Entry g, v)\n           \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m =\n                         Mapping.lookup\n                          (fst (foldr (aux_2 g) ns\n                                 (Mapping.empty, Mapping.empty)))\n                          m\n 3. \\<And>m v.\n       \\<lbrakk>Mapping.lookup\n                 (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n                 n =\n                None;\n        finite\n         (Mapping.keys\n           (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty))));\n        \\<And>n v.\n           (n, v)\n           \\<in> Mapping.keys\n                  (snd (foldr (aux_2 g) ns\n                         (Mapping.empty, Mapping.empty))) \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup\n            (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n            (Entry g, v)\n           \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter\n  (\\<lambda>n.\n      (n, v)\n      \\<notin> Mapping.keys\n                (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty))))\n  (\\<alpha>n g))\nn \\<and>\n                             v \\<in> uses g n\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup\n                                (snd (foldr (aux_2 g) ns\n (Mapping.empty, Mapping.empty)))\n                                (m, v)) =\n                         Mapping.lookup p' (m, v)", "apply (rule foldr_aux_1(1)[of \"sorted_list_of_set (uses g n)\" g n ?u ?p u' p', simplified]; simp add: aux_2_def[symmetric] asm(3)[simplified]; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m.\n       \\<lbrakk>m \\<noteq> n;\n        Mapping.lookup\n         (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty))) n =\n        None;\n        finite\n         (Mapping.keys\n           (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty))));\n        \\<And>n v.\n           (n, v)\n           \\<in> Mapping.keys\n                  (snd (foldr (aux_2 g) ns\n                         (Mapping.empty, Mapping.empty))) \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup\n            (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n            (Entry g, v)\n           \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' m =\n                         Mapping.lookup\n                          (fst (foldr (aux_2 g) ns\n                                 (Mapping.empty, Mapping.empty)))\n                          m\n 2. \\<And>m v.\n       \\<lbrakk>Mapping.lookup\n                 (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n                 n =\n                None;\n        finite\n         (Mapping.keys\n           (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty))));\n        \\<And>n v.\n           (n, v)\n           \\<in> Mapping.keys\n                  (snd (foldr (aux_2 g) ns\n                         (Mapping.empty, Mapping.empty))) \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup\n            (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n            (Entry g, v)\n           \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter\n  (\\<lambda>n.\n      (n, v)\n      \\<notin> Mapping.keys\n                (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty))))\n  (\\<alpha>n g))\nn \\<and>\n                             v \\<in> uses g n\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup\n                                (snd (foldr (aux_2 g) ns\n (Mapping.empty, Mapping.empty)))\n                                (m, v)) =\n                         Mapping.lookup p' (m, v)", "apply (rule foldr_aux_1(2)[of \"sorted_list_of_set (uses g n)\" g n ?u ?p u' p', simplified]; simp add: aux_2_def[symmetric] asm(3)[simplified]; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m v.\n       \\<lbrakk>Mapping.lookup\n                 (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n                 n =\n                None;\n        finite\n         (Mapping.keys\n           (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty))));\n        \\<And>n v.\n           (n, v)\n           \\<in> Mapping.keys\n                  (snd (foldr (aux_2 g) ns\n                         (Mapping.empty, Mapping.empty))) \\<Longrightarrow>\n           length (predecessors g n) \\<noteq> 1;\n        \\<And>v.\n           Mapping.lookup\n            (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n            (Entry g, v)\n           \\<in> {None, Some []}\\<rbrakk>\n       \\<Longrightarrow> (if m \\<in> phiDefNodes_aux g v\n(filter\n  (\\<lambda>n.\n      (n, v)\n      \\<notin> Mapping.keys\n                (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty))))\n  (\\<alpha>n g))\nn \\<and>\n                             v \\<in> uses g n\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g m))\n                          else Mapping.lookup\n                                (snd (foldr (aux_2 g) ns\n (Mapping.empty, Mapping.empty)))\n                                (m, v)) =\n                         Mapping.lookup p' (m, v)", "apply (rule foldr_aux_1(3)[of \"sorted_list_of_set (uses g n)\" g n ?u ?p u' p', simplified]; simp add: aux_2_def[symmetric] asm(3)[simplified]; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  lookupDef g n ` uses g n = lookup_multimap u' n\n  ?m2 \\<noteq> n \\<Longrightarrow>\n  Mapping.lookup u' ?m2 =\n  Mapping.lookup (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n   ?m2\n  (if ?m2\n      \\<in> phiDefNodes_aux g ?v2\n             (filter\n               (\\<lambda>n.\n                   (n, ?v2)\n                   \\<notin> Mapping.keys\n                             (snd (foldr (aux_2 g) ns\n                                    (Mapping.empty, Mapping.empty))))\n               (\\<alpha>n g))\n             n \\<and>\n      ?v2 \\<in> uses g n\n   then Some (map (\\<lambda>m. lookupDef g m ?v2) (predecessors g ?m2))\n   else Mapping.lookup\n         (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n         (?m2, ?v2)) =\n  Mapping.lookup p' (?m2, ?v2)\n\ngoal (6 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)\n 4. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<in> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 5. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<notin> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 6. \\<And>a ns n v u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        set (a # ns) \\<subseteq> set (\\<alpha>n g); distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set (a # ns).\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "{"], ["proof (state)\nthis:\n  lookupDef g n ` uses g n = lookup_multimap u' n\n  ?m2 \\<noteq> n \\<Longrightarrow>\n  Mapping.lookup u' ?m2 =\n  Mapping.lookup (fst (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n   ?m2\n  (if ?m2\n      \\<in> phiDefNodes_aux g ?v2\n             (filter\n               (\\<lambda>n.\n                   (n, ?v2)\n                   \\<notin> Mapping.keys\n                             (snd (foldr (aux_2 g) ns\n                                    (Mapping.empty, Mapping.empty))))\n               (\\<alpha>n g))\n             n \\<and>\n      ?v2 \\<in> uses g n\n   then Some (map (\\<lambda>m. lookupDef g m ?v2) (predecessors g ?m2))\n   else Mapping.lookup\n         (snd (foldr (aux_2 g) ns (Mapping.empty, Mapping.empty)))\n         (?m2, ?v2)) =\n  Mapping.lookup p' (?m2, ?v2)\n\ngoal (6 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)\n 4. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<in> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 5. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<notin> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 6. \\<And>a ns n v u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        set (a # ns) \\<subseteq> set (\\<alpha>n g); distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set (a # ns).\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "assume 1: \"m \\<in> set (n#ns)\""], ["proof (state)\nthis:\n  m \\<in> set (n # ns)\n\ngoal (6 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)\n 4. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<in> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 5. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<notin> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 6. \\<And>a ns n v u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        set (a # ns) \\<subseteq> set (\\<alpha>n g); distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set (a # ns).\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "show \"uses' g m = lookup_multimap u' m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uses' g m = lookup_multimap u' m", "apply (cases \"m = n\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. m = n \\<Longrightarrow> uses' g m = lookup_multimap u' m\n 2. m \\<noteq> n \\<Longrightarrow> uses' g m = lookup_multimap u' m", "apply (simp add: uses'_def aux_2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<noteq> n \\<Longrightarrow> uses' g m = lookup_multimap u' m", "using 1 asm(2)"], ["proof (prove)\nusing this:\n  m \\<in> set (n # ns)\n  distinct (n # ns)\n\ngoal (1 subgoal):\n 1. m \\<noteq> n \\<Longrightarrow> uses' g m = lookup_multimap u' m", "apply (auto simp: IH(1) lookup_multimap_def aux_2(2))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  uses' g m = lookup_multimap u' m\n\ngoal (5 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)\n 4. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<notin> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 5. \\<And>a ns n v u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        set (a # ns) \\<subseteq> set (\\<alpha>n g); distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set (a # ns).\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)\n 4. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<notin> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 5. \\<And>a ns n v u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        set (a # ns) \\<subseteq> set (\\<alpha>n g); distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set (a # ns).\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "assume 2: \"m \\<notin> set (n#ns)\""], ["proof (state)\nthis:\n  m \\<notin> set (n # ns)\n\ngoal (5 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)\n 4. \\<And>a ns n u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        n \\<notin> set (a # ns); set (a # ns) \\<subseteq> set (\\<alpha>n g);\n        distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 5. \\<And>a ns n v u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        set (a # ns) \\<subseteq> set (\\<alpha>n g); distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set (a # ns).\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "thus \"Mapping.lookup u' m = None\""], ["proof (prove)\nusing this:\n  m \\<notin> set (n # ns)\n\ngoal (1 subgoal):\n 1. Mapping.lookup u' m = None", "by (simp add: aux_2(2) IH(2))"], ["proof (state)\nthis:\n  Mapping.lookup u' m = None\n\ngoal (4 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)\n 4. \\<And>a ns n v u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        set (a # ns) \\<subseteq> set (\\<alpha>n g); distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set (a # ns).\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)\n 4. \\<And>a ns n v u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        set (a # ns) \\<subseteq> set (\\<alpha>n g); distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set (a # ns).\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "fix v"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)\n 4. \\<And>a ns n v u' p'.\n       \\<lbrakk>\\<And>n u' p'.\n                   \\<lbrakk>n \\<in> set ns;\n                    set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n                    foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n                    (u', p')\\<rbrakk>\n                   \\<Longrightarrow> uses' g n = lookup_multimap u' n;\n        \\<And>n u' p'.\n           \\<lbrakk>n \\<notin> set ns; set ns \\<subseteq> set (\\<alpha>n g);\n            distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> Mapping.lookup u' n = None;\n        \\<And>n v u' p'.\n           \\<lbrakk>set ns \\<subseteq> set (\\<alpha>n g); distinct ns;\n            foldr (aux_2 g) ns (Mapping.empty, Mapping.empty) =\n            (u', p')\\<rbrakk>\n           \\<Longrightarrow> (if \\<exists>na\\<in>set ns.\n                                    n \\<in> phiDefNodes_aux g v\n       (\\<alpha>n g) na \\<and>\n                                    v \\<in> uses g na\n                              then Some\n                                    (map (\\<lambda>m. lookupDef g m v)\n(predecessors g n))\n                              else None) =\n                             Mapping.lookup p' (n, v);\n        set (a # ns) \\<subseteq> set (\\<alpha>n g); distinct (a # ns);\n        foldr (aux_2 g) (a # ns) (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set (a # ns).\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "show \"(if \\<exists>n \\<in> set (n#ns). m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<and> v \\<in> uses g n then\n        Some (map (\\<lambda>m. lookupDef g m v) (predecessors g m)) else\n        None) = Mapping.lookup p' (m,v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<exists>n\\<in>set (n # ns).\n           m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<and>\n           v \\<in> uses g n\n     then Some (map (\\<lambda>m. lookupDef g m v) (predecessors g m))\n     else None) =\n    Mapping.lookup p' (m, v)", "apply (auto simp: aux_2(3)[symmetric] IH(3)[symmetric] keys_dom_lookup dom_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n; v \\<in> uses g n;\n     \\<forall>n\\<in>set ns.\n        m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<longrightarrow>\n        v \\<notin> uses g n\\<rbrakk>\n    \\<Longrightarrow> m \\<in> phiDefNodes_aux g v\n                               (filter\n                                 (\\<lambda>n.\n                                     \\<forall>na\\<in>set ns.\n  n \\<in> phiDefNodes_aux g v (\\<alpha>n g) na \\<longrightarrow>\n  v \\<notin> uses g na)\n                                 (\\<alpha>n g))\n                               n\n 2. \\<lbrakk>m \\<notin> phiDefNodes_aux g v (\\<alpha>n g) n;\n     \\<forall>n\\<in>set ns.\n        m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<longrightarrow>\n        v \\<notin> uses g n;\n     m \\<in> phiDefNodes_aux g v\n              (filter\n                (\\<lambda>n.\n                    \\<forall>na\\<in>set ns.\n                       n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n                                na \\<longrightarrow>\n                       v \\<notin> uses g na)\n                (\\<alpha>n g))\n              n;\n     v \\<in> uses g n\\<rbrakk>\n    \\<Longrightarrow> False", "apply (erule phiDefNodes_auxE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>v \\<in> uses g n;\n     \\<forall>n\\<in>set ns.\n        m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<longrightarrow>\n        v \\<notin> uses g n\\<rbrakk>\n    \\<Longrightarrow> n \\<in> set (\\<alpha>n g)\n 2. \\<And>ns.\n       \\<lbrakk>v \\<in> uses g n;\n        \\<forall>n\\<in>set ns.\n           m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<longrightarrow>\n           v \\<notin> uses g n;\n        g \\<turnstile> m-ns\\<rightarrow>n;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g m) \\<noteq> 1;\n        unvisitedPath (\\<alpha>n g) ns\\<rbrakk>\n       \\<Longrightarrow> m \\<in> phiDefNodes_aux g v\n                                  (filter\n                                    (\\<lambda>n.\n  \\<forall>na\\<in>set ns.\n     n \\<in> phiDefNodes_aux g v (\\<alpha>n g) na \\<longrightarrow>\n     v \\<notin> uses g na)\n                                    (\\<alpha>n g))\n                                  n\n 3. \\<lbrakk>m \\<notin> phiDefNodes_aux g v (\\<alpha>n g) n;\n     \\<forall>n\\<in>set ns.\n        m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<longrightarrow>\n        v \\<notin> uses g n;\n     m \\<in> phiDefNodes_aux g v\n              (filter\n                (\\<lambda>n.\n                    \\<forall>na\\<in>set ns.\n                       n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n                                na \\<longrightarrow>\n                       v \\<notin> uses g na)\n                (\\<alpha>n g))\n              n;\n     v \\<in> uses g n\\<rbrakk>\n    \\<Longrightarrow> False", "apply (erule uses_in_\\<alpha>n)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ns.\n       \\<lbrakk>v \\<in> uses g n;\n        \\<forall>n\\<in>set ns.\n           m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<longrightarrow>\n           v \\<notin> uses g n;\n        g \\<turnstile> m-ns\\<rightarrow>n;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g m) \\<noteq> 1;\n        unvisitedPath (\\<alpha>n g) ns\\<rbrakk>\n       \\<Longrightarrow> m \\<in> phiDefNodes_aux g v\n                                  (filter\n                                    (\\<lambda>n.\n  \\<forall>na\\<in>set ns.\n     n \\<in> phiDefNodes_aux g v (\\<alpha>n g) na \\<longrightarrow>\n     v \\<notin> uses g na)\n                                    (\\<alpha>n g))\n                                  n\n 2. \\<lbrakk>m \\<notin> phiDefNodes_aux g v (\\<alpha>n g) n;\n     \\<forall>n\\<in>set ns.\n        m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<longrightarrow>\n        v \\<notin> uses g n;\n     m \\<in> phiDefNodes_aux g v\n              (filter\n                (\\<lambda>n.\n                    \\<forall>na\\<in>set ns.\n                       n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n                                na \\<longrightarrow>\n                       v \\<notin> uses g na)\n                (\\<alpha>n g))\n              n;\n     v \\<in> uses g n\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule phiDefNodes_auxI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>ns.\n       \\<lbrakk>v \\<in> uses g n;\n        \\<forall>n\\<in>set ns.\n           m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<longrightarrow>\n           v \\<notin> uses g n;\n        g \\<turnstile> m-ns\\<rightarrow>n;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g m) \\<noteq> 1;\n        unvisitedPath (\\<alpha>n g) ns\\<rbrakk>\n       \\<Longrightarrow> g \\<turnstile> m-?ns173 ns\\<rightarrow>n\n 2. \\<And>ns.\n       \\<lbrakk>v \\<in> uses g n;\n        \\<forall>n\\<in>set ns.\n           m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<longrightarrow>\n           v \\<notin> uses g n;\n        g \\<turnstile> m-ns\\<rightarrow>n;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g m) \\<noteq> 1;\n        unvisitedPath (\\<alpha>n g) ns\\<rbrakk>\n       \\<Longrightarrow> unvisitedPath\n                          (filter\n                            (\\<lambda>n.\n                                \\<forall>na\\<in>set ns.\n                                   n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n      na \\<longrightarrow>\n                                   v \\<notin> uses g na)\n                            (\\<alpha>n g))\n                          (?ns173 ns)\n 3. \\<And>ns.\n       \\<lbrakk>v \\<in> uses g n;\n        \\<forall>n\\<in>set ns.\n           m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<longrightarrow>\n           v \\<notin> uses g n;\n        g \\<turnstile> m-ns\\<rightarrow>n;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g m) \\<noteq> 1;\n        unvisitedPath (\\<alpha>n g) ns\\<rbrakk>\n       \\<Longrightarrow> \\<forall>n\\<in>set (?ns173 ns). v \\<notin> defs g n\n 4. \\<And>ns.\n       \\<lbrakk>v \\<in> uses g n;\n        \\<forall>n\\<in>set ns.\n           m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<longrightarrow>\n           v \\<notin> uses g n;\n        g \\<turnstile> m-ns\\<rightarrow>n;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g m) \\<noteq> 1;\n        unvisitedPath (\\<alpha>n g) ns\\<rbrakk>\n       \\<Longrightarrow> length (predecessors g m) \\<noteq> 1\n 5. \\<lbrakk>m \\<notin> phiDefNodes_aux g v (\\<alpha>n g) n;\n     \\<forall>n\\<in>set ns.\n        m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<longrightarrow>\n        v \\<notin> uses g n;\n     m \\<in> phiDefNodes_aux g v\n              (filter\n                (\\<lambda>n.\n                    \\<forall>na\\<in>set ns.\n                       n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n                                na \\<longrightarrow>\n                       v \\<notin> uses g na)\n                (\\<alpha>n g))\n              n;\n     v \\<in> uses g n\\<rbrakk>\n    \\<Longrightarrow> False", "apply auto[4]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ns x na.\n       \\<lbrakk>v \\<in> uses g n;\n        \\<forall>n\\<in>set ns.\n           m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<longrightarrow>\n           v \\<notin> uses g n;\n        g \\<turnstile> m-ns\\<rightarrow>n;\n        \\<forall>n\\<in>set ns. v \\<notin> defs g n;\n        length (predecessors g m) \\<noteq> Suc 0; x \\<in> set ns;\n        distinct ns; set ns \\<subseteq> set (\\<alpha>n g); na \\<in> set ns;\n        x \\<in> phiDefNodes_aux g v (\\<alpha>n g) na;\n        v \\<in> uses g na\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<lbrakk>m \\<notin> phiDefNodes_aux g v (\\<alpha>n g) n;\n     \\<forall>n\\<in>set ns.\n        m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<longrightarrow>\n        v \\<notin> uses g n;\n     m \\<in> phiDefNodes_aux g v\n              (filter\n                (\\<lambda>n.\n                    \\<forall>na\\<in>set ns.\n                       n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n                                na \\<longrightarrow>\n                       v \\<notin> uses g na)\n                (\\<alpha>n g))\n              n;\n     v \\<in> uses g n\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule phiDefNodes_aux_redirect; auto simp: uses_in_\\<alpha>n; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<notin> phiDefNodes_aux g v (\\<alpha>n g) n;\n     \\<forall>n\\<in>set ns.\n        m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<longrightarrow>\n        v \\<notin> uses g n;\n     m \\<in> phiDefNodes_aux g v\n              (filter\n                (\\<lambda>n.\n                    \\<forall>na\\<in>set ns.\n                       n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n                                na \\<longrightarrow>\n                       v \\<notin> uses g na)\n                (\\<alpha>n g))\n              n;\n     v \\<in> uses g n\\<rbrakk>\n    \\<Longrightarrow> False", "apply (drule rev_subsetD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<notin> phiDefNodes_aux g v (\\<alpha>n g) n;\n     \\<forall>n\\<in>set ns.\n        m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<longrightarrow>\n        v \\<notin> uses g n;\n     v \\<in> uses g n\\<rbrakk>\n    \\<Longrightarrow> phiDefNodes_aux g v\n                       (filter\n                         (\\<lambda>n.\n                             \\<forall>na\\<in>set ns.\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<longrightarrow>\n                                v \\<notin> uses g na)\n                         (\\<alpha>n g))\n                       n\n                      \\<subseteq> ?B242\n 2. \\<lbrakk>m \\<notin> phiDefNodes_aux g v (\\<alpha>n g) n;\n     \\<forall>n\\<in>set ns.\n        m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<longrightarrow>\n        v \\<notin> uses g n;\n     v \\<in> uses g n; m \\<in> ?B242\\<rbrakk>\n    \\<Longrightarrow> False", "apply (rule phiDefNodes_aux_unvisited_monotonic)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>m \\<notin> phiDefNodes_aux g v (\\<alpha>n g) n;\n     \\<forall>n\\<in>set ns.\n        m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<longrightarrow>\n        v \\<notin> uses g n;\n     v \\<in> uses g n\\<rbrakk>\n    \\<Longrightarrow> set (filter\n                            (\\<lambda>n.\n                                \\<forall>na\\<in>set ns.\n                                   n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n      na \\<longrightarrow>\n                                   v \\<notin> uses g na)\n                            (\\<alpha>n g))\n                      \\<subseteq> set ?un'245\n 2. \\<lbrakk>m \\<notin> phiDefNodes_aux g v (\\<alpha>n g) n;\n     \\<forall>n\\<in>set ns.\n        m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<longrightarrow>\n        v \\<notin> uses g n;\n     v \\<in> uses g n; m \\<in> phiDefNodes_aux g v ?un'245 n\\<rbrakk>\n    \\<Longrightarrow> False", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (if \\<exists>n\\<in>set (n # ns).\n         m \\<in> phiDefNodes_aux g v (\\<alpha>n g) n \\<and> v \\<in> uses g n\n   then Some (map (\\<lambda>m. lookupDef g m v) (predecessors g m))\n   else None) =\n  Mapping.lookup p' (m, v)\n\ngoal (3 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "}"], ["proof (state)\nthis:\n  (if \\<exists>n\\<in>set (n # ns).\n         m \\<in> phiDefNodes_aux g ?v4 (\\<alpha>n g) n \\<and>\n         ?v4 \\<in> uses g n\n   then Some (map (\\<lambda>m. lookupDef g m ?v4) (predecessors g m))\n   else None) =\n  Mapping.lookup p' (m, ?v4)\n\ngoal (3 subgoals):\n 1. \\<And>n u' p'.\n       \\<lbrakk>n \\<in> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> uses' g n = lookup_multimap u' n\n 2. \\<And>n u' p'.\n       \\<lbrakk>n \\<notin> set []; set [] \\<subseteq> set (\\<alpha>n g);\n        distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> Mapping.lookup u' n = None\n 3. \\<And>n v u' p'.\n       \\<lbrakk>set [] \\<subseteq> set (\\<alpha>n g); distinct [];\n        foldr (aux_2 g) [] (Mapping.empty, Mapping.empty) =\n        (u', p')\\<rbrakk>\n       \\<Longrightarrow> (if \\<exists>na\\<in>set [].\n                                n \\<in> phiDefNodes_aux g v (\\<alpha>n g)\n   na \\<and>\n                                v \\<in> uses g na\n                          then Some\n                                (map (\\<lambda>m. lookupDef g m v)\n                                  (predecessors g n))\n                          else None) =\n                         Mapping.lookup p' (n, v)", "qed (auto simp: lookup_empty)"], ["", "lemma fst_uses'_phis': \"uses' g = lookup_multimap (fst (uses'_phis' g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uses' g = lookup_multimap (fst (uses'_phis' g))", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. uses' g x = lookup_multimap (fst (uses'_phis' g)) x", "apply (simp add: uses'_phis'_def Let_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       uses' g x =\n       lookup_multimap\n        (fst (foldr (aux_2 g) (\\<alpha>n g) (Mapping.empty, Mapping.empty)))\n        x", "apply (case_tac \"x \\<in> set (\\<alpha>n g)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> set (\\<alpha>n g) \\<Longrightarrow>\n       uses' g x =\n       lookup_multimap\n        (fst (foldr (aux_2 g) (\\<alpha>n g) (Mapping.empty, Mapping.empty)))\n        x\n 2. \\<And>x.\n       x \\<notin> set (\\<alpha>n g) \\<Longrightarrow>\n       uses' g x =\n       lookup_multimap\n        (fst (foldr (aux_2 g) (\\<alpha>n g) (Mapping.empty, Mapping.empty)))\n        x", "apply (rule foldr_aux_2(1)[OF _ _ surjective_pairing]; auto simp: lookup_empty intro: \\<alpha>n_distinct; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> set (\\<alpha>n g) \\<Longrightarrow>\n       uses' g x =\n       lookup_multimap\n        (fst (foldr (aux_2 g) (\\<alpha>n g) (Mapping.empty, Mapping.empty)))\n        x", "unfolding lookup_multimap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> set (\\<alpha>n g) \\<Longrightarrow>\n       uses' g x =\n       (case Mapping.lookup\n              (fst (foldr (aux_2 g) (\\<alpha>n g)\n                     (Mapping.empty, Mapping.empty)))\n              x of\n        None \\<Rightarrow> {} | Some x \\<Rightarrow> id x)", "apply (subst foldr_aux_2(2)[OF _ _ surjective_pairing]; auto simp: lookup_empty uses_in_\\<alpha>n uses'_def intro: \\<alpha>n_distinct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fst_uses'_phis'_in_\\<alpha>n: \"Mapping.keys (fst (uses'_phis' g)) \\<subseteq> set (\\<alpha>n g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.keys (fst (uses'_phis' g)) \\<subseteq> set (\\<alpha>n g)", "apply (rule subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Mapping.keys (fst (uses'_phis' g)) \\<Longrightarrow>\n       x \\<in> set (\\<alpha>n g)", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> Mapping.keys (fst (uses'_phis' g));\n        x \\<notin> set (\\<alpha>n g)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (simp add: uses'_phis'_def Let_def split_def keys_dom_lookup dom_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<exists>y.\n                   Mapping.lookup\n                    (fst (foldr (aux_2 g) (\\<alpha>n g)\n                           (Mapping.empty, Mapping.empty)))\n                    x =\n                   Some y;\n        x \\<notin> set (\\<alpha>n g)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (subst(asm) foldr_aux_2(2)[OF _ _ surjective_pairing]; auto intro: \\<alpha>n_distinct)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma snd_uses'_phis': \"phis'_code g = snd (uses'_phis' g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phis'_code g = snd (uses'_phis' g)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. phis'_code g = snd (uses'_phis' g)", "have a: \"\\<And>n v. (THE k. (\\<lambda>p. (fst p, snd p, fst p, PhiDef)) -` {(n, v, n, PhiDef)} = {k}) = (n,v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n v.\n       (THE k.\n           (\\<lambda>p. (fst p, snd p, fst p, PhiDef)) -`\n           {(n, v, n, PhiDef)} =\n           {k}) =\n       (n, v)", "by (rule the1_equality) (auto simp: vimage_def)"], ["proof (state)\nthis:\n  (THE k.\n      (\\<lambda>p. (fst p, snd p, fst p, PhiDef)) -`\n      {(?n2, ?v2, ?n2, PhiDef)} =\n      {k}) =\n  (?n2, ?v2)\n\ngoal (1 subgoal):\n 1. phis'_code g = snd (uses'_phis' g)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. phis'_code g = snd (uses'_phis' g)", "apply (subst Mapping_eq_lookup)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Mapping.lookup (phis'_code g) = Mapping.lookup (snd (uses'_phis' g))", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g. phis' g = Mapping.lookup (snd (uses'_phis' g))", "apply (simp add: phis'_def uses'_phis'_def Let_def split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g.\n       (\\<lambda>p.\n           if defNode (snd p) = fst p \\<and>\n              fst p \\<in> phiDefNodes g (fst (snd p)) \\<and>\n              fst (snd p) \\<in> vars g \\<and> defKind (snd p) = PhiDef\n           then Some\n                 (map (\\<lambda>m. lookupDef g m (fst (snd p)))\n                   (predecessors g (fst p)))\n           else None) =\n       Mapping.lookup\n        (map_keys (\\<lambda>p. (fst p, snd p, fst p, PhiDef))\n          (snd (foldr (aux_2 g) (\\<alpha>n g)\n                 (Mapping.empty, Mapping.empty))))", "apply (auto simp: lookup_map_keys a intro!: ext)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>g a aa.\n       \\<lbrakk>a \\<in> phiDefNodes g aa; aa \\<in> vars g;\n        (\\<lambda>p. (fst p, snd p, fst p, PhiDef)) -`\n        {(a, aa, a, PhiDef)} =\n        {}\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>g a aa.\n       \\<lbrakk>a \\<in> phiDefNodes g aa; aa \\<in> vars g\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m aa)\n                            (predecessors g a)) =\n                         Mapping.lookup\n                          (snd (foldr (aux_2 g) (\\<alpha>n g)\n                                 (Mapping.empty, Mapping.empty)))\n                          (a, aa)\n 3. \\<And>g ac ba.\n       \\<lbrakk>None \\<noteq>\n                Mapping.lookup\n                 (snd (foldr (aux_2 g) (\\<alpha>n g)\n                        (Mapping.empty, Mapping.empty)))\n                 (ac, ba);\n        ba \\<notin> vars g\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>g ac ba.\n       \\<lbrakk>None \\<noteq>\n                Mapping.lookup\n                 (snd (foldr (aux_2 g) (\\<alpha>n g)\n                        (Mapping.empty, Mapping.empty)))\n                 (ac, ba);\n        ac \\<notin> phiDefNodes g ba\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a_ \\<in> phiDefNodes g_ aa_; aa_ \\<in> vars g_;\n     (\\<lambda>p. (fst p, snd p, fst p, PhiDef)) -`\n     {(a_, aa_, a_, PhiDef)} =\n     {}\\<rbrakk>\n    \\<Longrightarrow> False", "by (auto simp: vimage_def)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>g a aa.\n       \\<lbrakk>a \\<in> phiDefNodes g aa; aa \\<in> vars g\\<rbrakk>\n       \\<Longrightarrow> Some\n                          (map (\\<lambda>m. lookupDef g m aa)\n                            (predecessors g a)) =\n                         Mapping.lookup\n                          (snd (foldr (aux_2 g) (\\<alpha>n g)\n                                 (Mapping.empty, Mapping.empty)))\n                          (a, aa)\n 2. \\<And>g ac ba.\n       \\<lbrakk>None \\<noteq>\n                Mapping.lookup\n                 (snd (foldr (aux_2 g) (\\<alpha>n g)\n                        (Mapping.empty, Mapping.empty)))\n                 (ac, ba);\n        ba \\<notin> vars g\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>g ac ba.\n       \\<lbrakk>None \\<noteq>\n                Mapping.lookup\n                 (snd (foldr (aux_2 g) (\\<alpha>n g)\n                        (Mapping.empty, Mapping.empty)))\n                 (ac, ba);\n        ac \\<notin> phiDefNodes g ba\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a_ \\<in> phiDefNodes g_ aa_; aa_ \\<in> vars g_\\<rbrakk>\n    \\<Longrightarrow> Some\n                       (map (\\<lambda>m. lookupDef g_ m aa_)\n                         (predecessors g_ a_)) =\n                      Mapping.lookup\n                       (snd (foldr (aux_2 g_) (\\<alpha>n g_)\n                              (Mapping.empty, Mapping.empty)))\n                       (a_, aa_)", "apply (subst foldr_aux_2(3)[OF _ _ surjective_pairing, symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>a_ \\<in> phiDefNodes g_ aa_; aa_ \\<in> vars g_\\<rbrakk>\n    \\<Longrightarrow> set (\\<alpha>n g_) \\<subseteq> set (\\<alpha>n g_)\n 2. \\<lbrakk>a_ \\<in> phiDefNodes g_ aa_; aa_ \\<in> vars g_\\<rbrakk>\n    \\<Longrightarrow> distinct (\\<alpha>n g_)\n 3. \\<lbrakk>a_ \\<in> phiDefNodes g_ aa_; aa_ \\<in> vars g_\\<rbrakk>\n    \\<Longrightarrow> Some\n                       (map (\\<lambda>m. lookupDef g_ m aa_)\n                         (predecessors g_ a_)) =\n                      (if \\<exists>n\\<in>set (\\<alpha>n g_).\n                             a_ \\<in> phiDefNodes_aux g_ aa_ (\\<alpha>n g_)\n n \\<and>\n                             aa_ \\<in> uses g_ n\n                       then Some\n                             (map (\\<lambda>m. lookupDef g_ m aa_)\n                               (predecessors g_ a_))\n                       else None)", "by (auto simp: phiDefNodes_def vimage_def elim!: fold_union_elem intro!: \\<alpha>n_distinct split: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>g ac ba.\n       \\<lbrakk>None \\<noteq>\n                Mapping.lookup\n                 (snd (foldr (aux_2 g) (\\<alpha>n g)\n                        (Mapping.empty, Mapping.empty)))\n                 (ac, ba);\n        ba \\<notin> vars g\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>g ac ba.\n       \\<lbrakk>None \\<noteq>\n                Mapping.lookup\n                 (snd (foldr (aux_2 g) (\\<alpha>n g)\n                        (Mapping.empty, Mapping.empty)))\n                 (ac, ba);\n        ac \\<notin> phiDefNodes g ba\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>None \\<noteq>\n             Mapping.lookup\n              (snd (foldr (aux_2 g_) (\\<alpha>n g_)\n                     (Mapping.empty, Mapping.empty)))\n              (ac_, ba_);\n     ba_ \\<notin> vars g_\\<rbrakk>\n    \\<Longrightarrow> False", "apply (subst(asm) foldr_aux_2(3)[OF _ _ surjective_pairing, symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. ba_ \\<notin> vars g_ \\<Longrightarrow>\n    set (\\<alpha>n g_) \\<subseteq> set (\\<alpha>n g_)\n 2. ba_ \\<notin> vars g_ \\<Longrightarrow> distinct (\\<alpha>n g_)\n 3. \\<lbrakk>None \\<noteq>\n             (if \\<exists>n\\<in>set (\\<alpha>n g_).\n                    ac_ \\<in> phiDefNodes_aux g_ ba_ (\\<alpha>n g_) n \\<and>\n                    ba_ \\<in> uses g_ n\n              then Some\n                    (map (\\<lambda>m. lookupDef g_ m ba_)\n                      (predecessors g_ ac_))\n              else None);\n     ba_ \\<notin> vars g_\\<rbrakk>\n    \\<Longrightarrow> False", "by (auto simp: phiDefNodes_def vimage_def elim!: fold_union_elem intro!: \\<alpha>n_distinct split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g ac ba.\n       \\<lbrakk>None \\<noteq>\n                Mapping.lookup\n                 (snd (foldr (aux_2 g) (\\<alpha>n g)\n                        (Mapping.empty, Mapping.empty)))\n                 (ac, ba);\n        ac \\<notin> phiDefNodes g ba\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>None \\<noteq>\n             Mapping.lookup\n              (snd (foldr (aux_2 g_) (\\<alpha>n g_)\n                     (Mapping.empty, Mapping.empty)))\n              (ac_, ba_);\n     ac_ \\<notin> phiDefNodes g_ ba_\\<rbrakk>\n    \\<Longrightarrow> False", "apply (subst(asm) foldr_aux_2(3)[OF _ _ surjective_pairing, symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. ac_ \\<notin> phiDefNodes g_ ba_ \\<Longrightarrow>\n    set (\\<alpha>n g_) \\<subseteq> set (\\<alpha>n g_)\n 2. ac_ \\<notin> phiDefNodes g_ ba_ \\<Longrightarrow>\n    distinct (\\<alpha>n g_)\n 3. \\<lbrakk>None \\<noteq>\n             (if \\<exists>n\\<in>set (\\<alpha>n g_).\n                    ac_ \\<in> phiDefNodes_aux g_ ba_ (\\<alpha>n g_) n \\<and>\n                    ba_ \\<in> uses g_ n\n              then Some\n                    (map (\\<lambda>m. lookupDef g_ m ba_)\n                      (predecessors g_ ac_))\n              else None);\n     ac_ \\<notin> phiDefNodes g_ ba_\\<rbrakk>\n    \\<Longrightarrow> False", "by (auto simp: phiDefNodes_def vimage_def elim!: fold_union_elem intro!: \\<alpha>n_distinct fold_union_elemI split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  phis'_code g = snd (uses'_phis' g)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}