{"file_name": "/home/qj213/afp-2021-10-22/thys/Relational_Forests/Forests.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Relational_Forests", "problem_names": ["lemma irreflexive_inf_arc_asymmetric:\n  \"irreflexive_inf x \\<Longrightarrow> arc x \\<Longrightarrow> asymmetric x\"", "lemma asymmetric_inf:\n  \"asymmetric x \\<longleftrightarrow> irreflexive_inf (x * x)\"", "lemma asymmetric_irreflexive_inf:\n  \"asymmetric x \\<Longrightarrow> irreflexive_inf x\"", "lemma transitive_asymmetric_irreflexive_inf:\n  \"transitive x \\<Longrightarrow> asymmetric x \\<longleftrightarrow> irreflexive_inf x\"", "lemma orientation_symmetric:\n  \"orientation x y \\<Longrightarrow> symmetric x\"", "lemma orientation_irreflexive_inf:\n  \"orientation x y \\<Longrightarrow> irreflexive_inf x\"", "lemma loop_orientation_symmetric:\n  \"loop_orientation x y \\<Longrightarrow> symmetric x\"", "lemma loop_orientation_diagonal:\n  \"loop_orientation x y \\<Longrightarrow> y \\<sqinter> y\\<^sup>T = x \\<sqinter> 1\"", "lemma super_orientation_irreflexive_inf:\n  \"super_orientation x y \\<Longrightarrow> irreflexive_inf x\"", "lemma loop_super_orientation_diagonal:\n  \"loop_super_orientation x y \\<Longrightarrow> x \\<sqinter> 1 \\<le> y \\<sqinter> y\\<^sup>T\"", "lemma orientable_symmetric:\n  \"orientable x \\<Longrightarrow> symmetric x\"", "lemma orientable_irreflexive_inf:\n  \"orientable x \\<Longrightarrow> irreflexive_inf x\"", "lemma loop_orientable_symmetric:\n  \"loop_orientable x \\<Longrightarrow> symmetric x\"", "lemma super_orientable_irreflexive_inf:\n  \"super_orientable x \\<Longrightarrow> irreflexive_inf x\"", "lemma orientable_down_closed:\n  assumes \"symmetric x\"\n      and \"x \\<le> y\"\n      and \"orientable y\"\n    shows \"orientable x\"", "lemma loop_orientable_down_closed:\n  assumes \"symmetric x\"\n      and \"x \\<le> y\"\n      and \"loop_orientable y\"\n    shows \"loop_orientable x\"", "lemma super_orientable_down_closed:\n  assumes \"x \\<le> y\"\n      and \"super_orientable y\"\n    shows \"super_orientable x\"", "lemma loop_super_orientable_down_closed:\n  assumes \"x \\<le> y\"\n      and \"loop_super_orientable y\"\n    shows \"loop_super_orientable x\"", "lemma super_orientation_diagonal:\n  \"x \\<le> y \\<squnion> y\\<^sup>T \\<Longrightarrow> y \\<sqinter> y\\<^sup>T \\<le> x \\<sqinter> 1 \\<Longrightarrow> y \\<sqinter> y\\<^sup>T = x \\<sqinter> 1\"", "lemma orientable_2_implies_1:\n  \"orientable_2 x \\<Longrightarrow> orientable_1 x\"", "lemma orientable_2_3:\n  \"orientable_2 x \\<longleftrightarrow> orientable_3 x\"", "lemma orientable_5_6:\n  \"orientable_5 x \\<longleftrightarrow> orientable_6 x\"", "lemma orientable_6_7:\n  \"orientable_6 x \\<longleftrightarrow> orientable_7 x\"", "lemma orientable_7_implies_8:\n  \"orientable_7 x \\<Longrightarrow> orientable_8 x\"", "lemma orientable_5_implies_1:\n  \"orientable_5 (x \\<squnion> x\\<^sup>T) \\<Longrightarrow> orientable_1 x\"", "lemma orientation_split:\n  \"orientation x y \\<longleftrightarrow> split bot y x\"", "lemma split_1_loop_orientation:\n  \"split 1 y x \\<Longrightarrow> loop_orientation x y\"", "lemma loop_orientation_split:\n  \"loop_orientation x y \\<longleftrightarrow> split (x \\<sqinter> 1) y x\"", "lemma loop_orientation_split_inf_1:\n  \"loop_orientation x y \\<longleftrightarrow> split (y \\<sqinter> 1) y x\"", "lemma loop_orientation_top_split:\n  \"loop_orientation top y \\<longleftrightarrow> split 1 y top\"", "lemma injectively_orientable_orientable:\n  \"injectively_orientable x \\<Longrightarrow> orientable x\"", "lemma orientable_orientable_1:\n  \"orientable x \\<Longrightarrow> orientable_1 x\"", "lemma injectively_orientable_down_closed:\n  assumes \"symmetric x\"\n      and \"x \\<le> y\"\n      and \"injectively_orientable y\"\n    shows \"injectively_orientable x\"", "lemma transitively_orientable_orientable:\n  \"transitively_orientable x \\<Longrightarrow> orientable x\"", "lemma irreflexive_transitive_orientation_asymmetric:\n  assumes \"irreflexive_inf x\"\n      and \"transitive y\"\n      and \"y \\<squnion> y\\<^sup>T = x\"\n    shows \"asymmetric y\"", "lemma transitively_orientable_2:\n  \"transitively_orientable x \\<longleftrightarrow> irreflexive_inf x \\<and> (\\<exists>y . y \\<squnion> y\\<^sup>T = x \\<and> transitive y)\"", "lemma asymmetric_var:\n  \"asymmetric x \\<longleftrightarrow> asymmetric_var x\"", "lemma transitive_asymmetric_irreflexive:\n  \"transitive x \\<Longrightarrow> asymmetric x \\<longleftrightarrow> irreflexive x\"", "lemma orientable_irreflexive:\n  \"orientable x \\<Longrightarrow> irreflexive x\"", "lemma super_orientable_irreflexive:\n  \"super_orientable x \\<Longrightarrow> irreflexive x\"", "lemma orientation_diversity_split:\n  \"orientation (-1) y \\<longleftrightarrow> split bot y (-1)\"", "lemma linear_strict_order_split:\n  \"linear_strict_order x \\<longleftrightarrow> transitive x \\<and> split bot x (-1)\"", "lemma linear_strict_order_without_irreflexive:\n  \"linear_strict_order x \\<longleftrightarrow> transitive x \\<and> strict_linear x\"", "lemma linear_order_without_reflexive:\n  \"linear_order x \\<longleftrightarrow> antisymmetric x \\<and> transitive x \\<and> linear x\"", "lemma linear_orderable_1_implies_2:\n  \"linear_orderable_1 x \\<Longrightarrow> linear_orderable_2 (x \\<sqinter> -1)\"", "lemma linear_orderable_2_3:\n  \"linear_orderable_2 x \\<longleftrightarrow> linear_orderable_3 x\"", "lemma linear_orderable_3_3a:\n  \"linear_orderable_3 x \\<longleftrightarrow> linear_orderable_3a x\"", "lemma linear_orderable_3_implies_orientable_12:\n  \"linear_orderable_3 x \\<Longrightarrow> orientable_12 x\"", "lemma orientable_11_implies_12:\n  \"orientable_11 x \\<Longrightarrow> orientable_12 (x \\<sqinter> -1)\"", "lemma split_symmetric_asymmetric:\n  assumes \"regular x\"\n    shows \"split x y z \\<longleftrightarrow> y \\<sqinter> y\\<^sup>T = x \\<and> (y \\<sqinter> -y\\<^sup>T) \\<squnion> (y \\<sqinter> -y\\<^sup>T)\\<^sup>T = z \\<sqinter> -x \\<and> x \\<le> z\"", "lemma orientable_1_2:\n  \"orientable_1 x \\<longleftrightarrow> orientable_2 x\"", "lemma orientable_8_implies_5:\n  assumes \"orientable_8 (x \\<sqinter> -1)\"\n  shows \"orientable_5 x\"", "lemma orientable_4_implies_1:\n  assumes \"orientable_4 (x \\<sqinter> -1)\"\n  shows \"orientable_1 x\"", "lemma orientable_1_implies_4:\n  assumes \"orientable_1 (x \\<squnion> 1)\"\n  shows \"orientable_4 x\"", "lemma orientable_1_implies_5:\n  assumes \"orientable_1 x\"\n  shows \"orientable_5 x\"", "lemma all_orientable_characterisations:\n  shows \"(\\<forall>x . orientable_1 x) \\<longleftrightarrow> (\\<forall>x . orientable_2 x)\"\n    and \"(\\<forall>x . orientable_1 x) \\<longleftrightarrow> (\\<forall>x . orientable_3 x)\"\n    and \"(\\<forall>x . orientable_1 x) \\<longleftrightarrow> (\\<forall>x . orientable_4 x)\"\n    and \"(\\<forall>x . orientable_1 x) \\<longleftrightarrow> (\\<forall>x . orientable_5 x)\"\n    and \"(\\<forall>x . orientable_1 x) \\<longleftrightarrow> (\\<forall>x . orientable_6 x)\"\n    and \"(\\<forall>x . orientable_1 x) \\<longleftrightarrow> (\\<forall>x . orientable_7 x)\"\n    and \"(\\<forall>x . orientable_1 x) \\<longleftrightarrow> (\\<forall>x . orientable_8 x)\"", "lemma orientable_12_implies_11:\n  \"orientable_12 x \\<Longrightarrow> orientable_11 (x \\<squnion> 1)\"", "lemma linear_strict_order_order:\n  \"linear_strict_order x \\<Longrightarrow> linear_order (x \\<squnion> 1)\"", "lemma linear_orderable_2_implies_1:\n  \"linear_orderable_2 x \\<Longrightarrow> linear_orderable_1 (x \\<squnion> 1)\"", "lemma exists_split_characterisations:\n  shows \"(\\<exists>x . linear_orderable_1 x) \\<longleftrightarrow> (\\<exists>x . linear_orderable_2 x)\"\n  and \"(\\<exists>x . linear_orderable_1 x) \\<longleftrightarrow> (\\<exists>x . linear_orderable_3 x)\"\n  and \"(\\<exists>x . linear_orderable_1 x) \\<longleftrightarrow> (\\<exists>x . linear_orderable_3a x)\"\n  and \"(\\<exists>x . linear_orderable_1 x) \\<longleftrightarrow> transitively_orientable (-1)\"\n  and \"(\\<exists>x . linear_orderable_1 x) \\<Longrightarrow> (\\<exists>x . orientable_11 x)\"\n  and \"(\\<exists>x . orientable_11 x) \\<longleftrightarrow> (\\<exists>x . orientable_12 x)\"", "lemma exists_all_orientable:\n  shows \"(\\<exists>x . orientable_11 x) \\<longleftrightarrow> (\\<forall>x . orientable_1 x)\"\n    and \"transitively_orientable (-1) \\<Longrightarrow> (\\<forall>x . orientable_8 x)\"", "lemma plus_separate_comp_bot:\n  assumes \"x * y = bot\"\n  shows \"(x \\<squnion> y)\\<^sup>+ = x\\<^sup>+ \\<squnion> y\\<^sup>+ \\<squnion> y\\<^sup>+ * x\\<^sup>+\"", "lemma reflexive_inf_plus_star:\n  assumes \"reflexive x\"\n  shows \"x \\<sqinter> y\\<^sup>+ \\<le> 1 \\<longleftrightarrow> x \\<sqinter> y\\<^sup>\\<star> = 1\"", "lemma acyclic_star_inf_conv_iff:\n  assumes \"irreflexive w\"\n  shows \"acyclic w \\<longleftrightarrow> w\\<^sup>\\<star> \\<sqinter> w\\<^sup>T\\<^sup>\\<star> = 1\"", "lemma acyclic_irreflexive_star_antisymmetric:\n  \"acyclic x \\<longleftrightarrow> irreflexive x \\<and> antisymmetric (x\\<^sup>\\<star>)\"", "lemma acyclic_plus_asymmetric:\n  \"acyclic x \\<longleftrightarrow> asymmetric (x\\<^sup>+)\"", "lemma transitive_acyclic_irreflexive:\n  \"transitive x \\<Longrightarrow> acyclic x \\<longleftrightarrow> irreflexive x\"", "lemma transitive_acyclic_asymmetric:\n  \"transitive x \\<Longrightarrow> acyclic x \\<longleftrightarrow> asymmetric x\"", "lemma strict_order_transitive_acyclic:\n  \"strict_order x \\<longleftrightarrow> transitive x \\<and> acyclic x\"", "lemma linear_strict_order_transitive_acyclic:\n  \"linear_strict_order x \\<longleftrightarrow> transitive x \\<and> acyclic x \\<and> strict_linear x\"", "lemma acyclic_2_2a:\n  assumes \"symmetric x\"\n  shows \"acyclic_2 x \\<longleftrightarrow> acyclic_2a x\"", "lemma acyclic_2a_2b:\n  shows \"acyclic_2a x \\<longleftrightarrow> acyclic_2b x\"", "lemma acyclic_1_1b:\n  shows \"acyclic_1 x \\<longleftrightarrow> acyclic_1b x\"", "lemma acyclic_6_1_injectively_orientable:\n  \"acyclic_6 x \\<longleftrightarrow> acyclic_1 x \\<and> injectively_orientable x\"", "lemma acyclic_6_symmetric:\n  \"acyclic_6 x \\<Longrightarrow> symmetric x\"", "lemma acyclic_6_irreflexive:\n  \"acyclic_6 x \\<Longrightarrow> irreflexive x\"", "lemma acyclic_4_irreflexive:\n  \"acyclic_4 x \\<Longrightarrow> irreflexive x\"", "lemma acyclic_2_implies_1:\n  \"acyclic_2 x \\<Longrightarrow> acyclic_1 x\"", "lemma acyclic_4a_4b:\n  \"acyclic_4a x \\<longleftrightarrow> acyclic_4b x\"", "lemma acyclic_3a_3b:\n  \"acyclic_3a x \\<longleftrightarrow> acyclic_3b x\"", "lemma acyclic_3a_3c:\n  assumes \"irreflexive x\"\n  shows \"acyclic_3a x \\<longleftrightarrow> acyclic_3c x\"", "lemma acyclic_3c_3d:\n  shows \"acyclic_3c x \\<longleftrightarrow> acyclic_3d x\"", "lemma acyclic_4a_implies_3a:\n  \"acyclic_4a x \\<Longrightarrow> acyclic_3a x\"", "lemma acyclic_4a_implies_4:\n  \"acyclic_4a x \\<Longrightarrow> acyclic_4 x\"", "lemma acyclic_4b_implies_4c:\n  \"acyclic_4b x \\<Longrightarrow> acyclic_4c x\"", "lemma acyclic_4_implies_2:\n  assumes \"symmetric x\"\n  shows \"acyclic_4 x \\<Longrightarrow> acyclic_2 x\"", "lemma acyclic_6_implies_4a:\n  \"acyclic_6 x \\<Longrightarrow> acyclic_4a x\"", "lemma top_injective_inf_complement:\n  assumes \"injective x\"\n  shows \"top * (x \\<sqinter> y) \\<sqinter> top * (x \\<sqinter> -y) = bot\"", "lemma top_injective_inf_complement_2:\n  assumes \"injective x\"\n  shows \"(x\\<^sup>T \\<sqinter> y) * top \\<sqinter> (x\\<^sup>T \\<sqinter> -y) * top = bot\"", "lemma acyclic_6_implies_5a:\n  \"acyclic_6 x \\<Longrightarrow> acyclic_5a x\"", "lemma acyclic_5b_implies_4:\n  assumes \"irreflexive x\"\n      and \"acyclic_5b x\"\n    shows \"acyclic_4 x\"", "lemma acyclic_5a_5b:\n  \"acyclic_5a x \\<longleftrightarrow> acyclic_5b x\"", "lemma acyclic_5a_5c:\n  \"acyclic_5a x \\<longleftrightarrow> acyclic_5c x\"", "lemma acyclic_5b_5d:\n  \"acyclic_5b x \\<longleftrightarrow> acyclic_5d x\"", "lemma acyclic_5a_5e:\n  \"acyclic_5a x \\<longleftrightarrow> acyclic_5e x\"", "lemma acyclic_5e_5f:\n  \"acyclic_5e x \\<longleftrightarrow> acyclic_5f x\"", "lemma acyclic_5e_down_closed:\n  assumes \"x \\<le> y\"\n      and \"acyclic_5e y\"\n    shows \"acyclic_5e x\"", "lemma acyclic_5a_down_closed:\n  assumes \"x \\<le> y\"\n      and \"acyclic_5a y\"\n    shows \"acyclic_5a x\"", "lemma linear_orderable_3_4:\n  \"linear_orderable_3 x \\<longleftrightarrow> linear_orderable_4 x\"", "lemma linear_orderable_5_implies_6:\n  \"linear_orderable_5 x \\<Longrightarrow> linear_orderable_6 x\"", "lemma linear_orderable_6_implies_3:\n  assumes \"linear_orderable_6 x\"\n  shows \"linear_orderable_3 (x\\<^sup>+)\"", "lemma linear_orderable_7_implies_1:\n  \"linear_orderable_7 x \\<Longrightarrow> linear_orderable_1 (x\\<^sup>\\<star>)\"", "lemma linear_orderable_6_implies_8:\n  \"linear_orderable_6 x \\<Longrightarrow> linear_orderable_8 x\"", "lemma path_orderable_implies_linear_orderable_6:\n  \"path_orderable x \\<Longrightarrow> linear_orderable_6 x\"", "lemma simple_paths_acyclic_6:\n  \"simple_paths x \\<Longrightarrow> acyclic_6 x\"", "lemma simple_paths_transitively_orientable:\n  assumes \"simple_paths x\"\n  shows \"transitively_orientable (x\\<^sup>+ \\<sqinter> -1)\"", "lemma acyclic_6_implies_spannable:\n  \"acyclic_6 x \\<Longrightarrow> spannable x\"", "lemma acyclic_3a_spannable_implies_6:\n  assumes \"acyclic_3a x\"\n      and \"spannable x\"\n      and \"symmetric x\"\n    shows \"acyclic_6 x\"", "lemma acyclic_6_implies_3a:\n  \"acyclic_6 x \\<Longrightarrow> acyclic_3a x\"", "lemma acyclic_6_implies_2:\n  \"acyclic_6 x \\<Longrightarrow> acyclic_2 x\"", "lemma acyclic_6_3a_spannable:\n  \"acyclic_6 x \\<longleftrightarrow> symmetric x \\<and> spannable x \\<and> acyclic_3a x\"", "lemma point_spanning:\n  assumes \"point p\"\n  shows \"spanning (-1) (p \\<sqinter> -1)\"\n        \"spannable (-1)\"", "lemma irreflexive_star:\n  \"(x \\<sqinter> -1)\\<^sup>\\<star> = x\\<^sup>\\<star>\"", "lemma acyclic_2_1:\n  assumes \"orientable x\"\n  shows \"acyclic_2 x \\<longleftrightarrow> acyclic_1 x\"", "lemma acyclic_4_4c:\n  \"acyclic_4 x \\<longleftrightarrow> acyclic_4c x\"", "lemma acyclic_5f_5g:\n  \"acyclic_5f x \\<longleftrightarrow> acyclic_5g x\"", "lemma linear_orderable_3_implies_5:\n  assumes \"linear_orderable_3 x\"\n  shows \"linear_orderable_5 x\"", "lemma linear_orderable_8_implies_7:\n  \"linear_orderable_8 x \\<Longrightarrow> linear_orderable_7 x\"", "lemma exists_split_characterisations_2:\n  shows \"(\\<exists>x . linear_orderable_1 x) \\<longleftrightarrow> (\\<exists>x . linear_orderable_4 x)\"\n  and \"(\\<exists>x . linear_orderable_1 x) \\<longleftrightarrow> (\\<exists>x . linear_orderable_5 x)\"\n  and \"(\\<exists>x . linear_orderable_1 x) \\<longleftrightarrow> (\\<exists>x . linear_orderable_6 x)\"\n  and \"(\\<exists>x . linear_orderable_1 x) \\<longleftrightarrow> (\\<exists>x . linear_orderable_7 x)\"\n  and \"(\\<exists>x . linear_orderable_1 x) \\<longleftrightarrow> (\\<exists>x . linear_orderable_8 x)\"", "lemma acyclic_2_4:\n  assumes \"irreflexive x\"\n      and \"symmetric x\"\n    shows \"acyclic_2 x \\<longleftrightarrow> acyclic_4 x\"", "lemma acyclic_3a_implies_4b:\n  assumes \"acyclic_3a x\"\n    shows \"acyclic_4b x\"", "lemma acyclic_3a_4b:\n  \"acyclic_3a x \\<longleftrightarrow> acyclic_4b x\"", "lemma acyclic_4_4a:\n  \"acyclic_4 x \\<longleftrightarrow> acyclic_4a x\"", "lemma \"symmetric x \\<Longrightarrow> irreflexive_inf x \\<Longrightarrow> orientable x\"", "lemma \"linear_orderable_6 x \\<Longrightarrow> path_orderable x\"", "lemma \"symmetric x \\<Longrightarrow> irreflexive x \\<Longrightarrow> acyclic_5a x \\<Longrightarrow> acyclic_6 x\"", "lemma \"symmetric x \\<Longrightarrow> irreflexive x \\<Longrightarrow> acyclic_2 x \\<Longrightarrow> acyclic_4 x\""], "translations": [["", "lemma irreflexive_inf_arc_asymmetric:\n  \"irreflexive_inf x \\<Longrightarrow> arc x \\<Longrightarrow> asymmetric x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>irreflexive_inf x; arc x\\<rbrakk>\n    \\<Longrightarrow> asymmetric x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>irreflexive_inf x; arc x\\<rbrakk>\n    \\<Longrightarrow> asymmetric x", "assume \"irreflexive_inf x\" \"arc x\""], ["proof (state)\nthis:\n  irreflexive_inf x\n  arc x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>irreflexive_inf x; arc x\\<rbrakk>\n    \\<Longrightarrow> asymmetric x", "hence \"bot = (x * top)\\<^sup>T \\<sqinter> x\""], ["proof (prove)\nusing this:\n  irreflexive_inf x\n  arc x\n\ngoal (1 subgoal):\n 1. bot = (x * top)\\<^sup>T \\<sqinter> x", "by (metis arc_top_arc comp_right_one schroeder_1)"], ["proof (state)\nthis:\n  bot = (x * top)\\<^sup>T \\<sqinter> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>irreflexive_inf x; arc x\\<rbrakk>\n    \\<Longrightarrow> asymmetric x", "thus ?thesis"], ["proof (prove)\nusing this:\n  bot = (x * top)\\<^sup>T \\<sqinter> x\n\ngoal (1 subgoal):\n 1. asymmetric x", "by (metis comp_inf.semiring.mult_zero_right conv_inf_bot_iff inf.sup_relative_same_increasing top_right_mult_increasing)"], ["proof (state)\nthis:\n  asymmetric x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma asymmetric_inf:\n  \"asymmetric x \\<longleftrightarrow> irreflexive_inf (x * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. asymmetric x = irreflexive_inf (x * x)", "using inf.sup_monoid.add_commute schroeder_2"], ["proof (prove)\nusing this:\n  ?a \\<sqinter> ?b = ?b \\<sqinter> ?a\n  (?x * ?y \\<sqinter> ?z = bot) = (?z * ?y\\<^sup>T \\<sqinter> ?x = bot)\n\ngoal (1 subgoal):\n 1. asymmetric x = irreflexive_inf (x * x)", "by force"], ["", "lemma asymmetric_irreflexive_inf:\n  \"asymmetric x \\<Longrightarrow> irreflexive_inf x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. asymmetric x \\<Longrightarrow> irreflexive_inf x", "by (metis asymmetric_inf_closed coreflexive_symmetric inf.idem inf_le2)"], ["", "lemma transitive_asymmetric_irreflexive_inf:\n  \"transitive x \\<Longrightarrow> asymmetric x \\<longleftrightarrow> irreflexive_inf x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitive x \\<Longrightarrow> asymmetric x = irreflexive_inf x", "by (smt asymmetric_inf asymmetric_irreflexive_inf inf.absorb2 inf.cobounded1 inf.sup_monoid.add_commute inf_assoc le_bot)"], ["", "abbreviation \"orientation x y \\<equiv> y \\<squnion> y\\<^sup>T = x \\<and> asymmetric y\""], ["", "abbreviation \"loop_orientation x y \\<equiv> y \\<squnion> y\\<^sup>T = x \\<and> antisymmetric y\""], ["", "abbreviation \"super_orientation x y \\<equiv> x \\<le> y \\<squnion> y\\<^sup>T \\<and> asymmetric y\""], ["", "abbreviation \"loop_super_orientation x y \\<equiv> x \\<le> y \\<squnion> y\\<^sup>T \\<and> antisymmetric y\""], ["", "lemma orientation_symmetric:\n  \"orientation x y \\<Longrightarrow> symmetric x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orientation x y \\<Longrightarrow> symmetric x", "using conv_dist_sup sup_commute"], ["proof (prove)\nusing this:\n  (?x \\<squnion> ?y)\\<^sup>T = ?x\\<^sup>T \\<squnion> ?y\\<^sup>T\n  ?x \\<squnion> ?y = ?y \\<squnion> ?x\n\ngoal (1 subgoal):\n 1. orientation x y \\<Longrightarrow> symmetric x", "by auto"], ["", "lemma orientation_irreflexive_inf:\n  \"orientation x y \\<Longrightarrow> irreflexive_inf x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orientation x y \\<Longrightarrow> irreflexive_inf x", "using asymmetric_irreflexive_inf asymmetric_conv_closed inf_sup_distrib2"], ["proof (prove)\nusing this:\n  asymmetric ?x \\<Longrightarrow> irreflexive_inf ?x\n  asymmetric ?x \\<Longrightarrow> asymmetric (?x\\<^sup>T)\n  (?y \\<squnion> ?z) \\<sqinter> ?x =\n  ?y \\<sqinter> ?x \\<squnion> ?z \\<sqinter> ?x\n\ngoal (1 subgoal):\n 1. orientation x y \\<Longrightarrow> irreflexive_inf x", "by auto"], ["", "lemma loop_orientation_symmetric:\n  \"loop_orientation x y \\<Longrightarrow> symmetric x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loop_orientation x y \\<Longrightarrow> symmetric x", "using conv_dist_sup sup_commute"], ["proof (prove)\nusing this:\n  (?x \\<squnion> ?y)\\<^sup>T = ?x\\<^sup>T \\<squnion> ?y\\<^sup>T\n  ?x \\<squnion> ?y = ?y \\<squnion> ?x\n\ngoal (1 subgoal):\n 1. loop_orientation x y \\<Longrightarrow> symmetric x", "by auto"], ["", "lemma loop_orientation_diagonal:\n  \"loop_orientation x y \\<Longrightarrow> y \\<sqinter> y\\<^sup>T = x \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loop_orientation x y \\<Longrightarrow>\n    y \\<sqinter> y\\<^sup>T = x \\<sqinter> (1::'a)", "by (metis inf.sup_monoid.add_commute inf.sup_same_context inf_le2 inf_sup_distrib1 one_inf_conv sup.idem)"], ["", "lemma super_orientation_irreflexive_inf:\n  \"super_orientation x y \\<Longrightarrow> irreflexive_inf x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. super_orientation x y \\<Longrightarrow> irreflexive_inf x", "using coreflexive_bot_closed inf.sup_monoid.add_assoc inf.sup_right_divisibility inf_bot_right loop_orientation_diagonal"], ["proof (prove)\nusing this:\n  coreflexive bot\n  ?a \\<sqinter> ?b \\<sqinter> ?c = ?a \\<sqinter> (?b \\<sqinter> ?c)\n  (?y \\<le> ?x) = (\\<exists>z. z \\<sqinter> ?x = ?y)\n  ?x \\<sqinter> bot = bot\n  loop_orientation ?x ?y \\<Longrightarrow>\n  ?y \\<sqinter> ?y\\<^sup>T = ?x \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. super_orientation x y \\<Longrightarrow> irreflexive_inf x", "by fastforce"], ["", "lemma loop_super_orientation_diagonal:\n  \"loop_super_orientation x y \\<Longrightarrow> x \\<sqinter> 1 \\<le> y \\<sqinter> y\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loop_super_orientation x y \\<Longrightarrow>\n    x \\<sqinter> (1::'a) \\<le> y \\<sqinter> y\\<^sup>T", "using inf.sup_right_divisibility inf_assoc loop_orientation_diagonal"], ["proof (prove)\nusing this:\n  (?y \\<le> ?x) = (\\<exists>z. z \\<sqinter> ?x = ?y)\n  ?x \\<sqinter> ?y \\<sqinter> ?z = ?x \\<sqinter> (?y \\<sqinter> ?z)\n  loop_orientation ?x ?y \\<Longrightarrow>\n  ?y \\<sqinter> ?y\\<^sup>T = ?x \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. loop_super_orientation x y \\<Longrightarrow>\n    x \\<sqinter> (1::'a) \\<le> y \\<sqinter> y\\<^sup>T", "by fastforce"], ["", "definition \"orientable x \\<equiv> \\<exists>y . orientation x y\""], ["", "definition \"loop_orientable x \\<equiv> \\<exists>y . loop_orientation x y\""], ["", "definition \"super_orientable x \\<equiv> \\<exists>y . super_orientation x y\""], ["", "definition \"loop_super_orientable x \\<equiv> \\<exists>y . loop_super_orientation x y\""], ["", "lemma orientable_symmetric:\n  \"orientable x \\<Longrightarrow> symmetric x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orientable x \\<Longrightarrow> symmetric x", "using orientable_def orientation_symmetric"], ["proof (prove)\nusing this:\n  orientable ?x \\<equiv> \\<exists>y. orientation ?x y\n  orientation ?x ?y \\<Longrightarrow> symmetric ?x\n\ngoal (1 subgoal):\n 1. orientable x \\<Longrightarrow> symmetric x", "by blast"], ["", "lemma orientable_irreflexive_inf:\n  \"orientable x \\<Longrightarrow> irreflexive_inf x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orientable x \\<Longrightarrow> irreflexive_inf x", "using orientable_def orientation_irreflexive_inf"], ["proof (prove)\nusing this:\n  orientable ?x \\<equiv> \\<exists>y. orientation ?x y\n  orientation ?x ?y \\<Longrightarrow> irreflexive_inf ?x\n\ngoal (1 subgoal):\n 1. orientable x \\<Longrightarrow> irreflexive_inf x", "by blast"], ["", "lemma loop_orientable_symmetric:\n  \"loop_orientable x \\<Longrightarrow> symmetric x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loop_orientable x \\<Longrightarrow> symmetric x", "using loop_orientable_def loop_orientation_symmetric"], ["proof (prove)\nusing this:\n  loop_orientable ?x \\<equiv> \\<exists>y. loop_orientation ?x y\n  loop_orientation ?x ?y \\<Longrightarrow> symmetric ?x\n\ngoal (1 subgoal):\n 1. loop_orientable x \\<Longrightarrow> symmetric x", "by blast"], ["", "lemma super_orientable_irreflexive_inf:\n  \"super_orientable x \\<Longrightarrow> irreflexive_inf x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. super_orientable x \\<Longrightarrow> irreflexive_inf x", "using super_orientable_def super_orientation_irreflexive_inf"], ["proof (prove)\nusing this:\n  super_orientable ?x \\<equiv> \\<exists>y. super_orientation ?x y\n  super_orientation ?x ?y \\<Longrightarrow> irreflexive_inf ?x\n\ngoal (1 subgoal):\n 1. super_orientable x \\<Longrightarrow> irreflexive_inf x", "by blast"], ["", "lemma orientable_down_closed:\n  assumes \"symmetric x\"\n      and \"x \\<le> y\"\n      and \"orientable y\"\n    shows \"orientable x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orientable x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. orientable x", "from assms(3)"], ["proof (chain)\npicking this:\n  orientable y", "obtain z where 1: \"z \\<squnion> z\\<^sup>T = y \\<and> asymmetric z\""], ["proof (prove)\nusing this:\n  orientable y\n\ngoal (1 subgoal):\n 1. (\\<And>z. orientation y z \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using orientable_def"], ["proof (prove)\nusing this:\n  orientable y\n  orientable ?x \\<equiv> \\<exists>y. orientation ?x y\n\ngoal (1 subgoal):\n 1. (\\<And>z. orientation y z \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  orientation y z\n\ngoal (1 subgoal):\n 1. orientable x", "let ?z = \"x \\<sqinter> z\""], ["proof (state)\ngoal (1 subgoal):\n 1. orientable x", "have \"orientation x ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orientation x (x \\<sqinter> z)", "proof (rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<sqinter> z \\<squnion> (x \\<sqinter> z)\\<^sup>T = x\n 2. asymmetric (x \\<sqinter> z)", "show \"asymmetric ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. asymmetric (x \\<sqinter> z)", "using 1"], ["proof (prove)\nusing this:\n  orientation y z\n\ngoal (1 subgoal):\n 1. asymmetric (x \\<sqinter> z)", "by (simp add: conv_dist_inf inf.left_commute inf.sup_monoid.add_assoc)"], ["proof (state)\nthis:\n  asymmetric (x \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. x \\<sqinter> z \\<squnion> (x \\<sqinter> z)\\<^sup>T = x", "thus \"?z \\<squnion> ?z\\<^sup>T = x\""], ["proof (prove)\nusing this:\n  asymmetric (x \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. x \\<sqinter> z \\<squnion> (x \\<sqinter> z)\\<^sup>T = x", "using 1"], ["proof (prove)\nusing this:\n  asymmetric (x \\<sqinter> z)\n  orientation y z\n\ngoal (1 subgoal):\n 1. x \\<sqinter> z \\<squnion> (x \\<sqinter> z)\\<^sup>T = x", "by (metis assms(1,2) conv_dist_inf inf.orderE inf_sup_distrib1)"], ["proof (state)\nthis:\n  x \\<sqinter> z \\<squnion> (x \\<sqinter> z)\\<^sup>T = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  orientation x (x \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. orientable x", "thus ?thesis"], ["proof (prove)\nusing this:\n  orientation x (x \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. orientable x", "using orientable_def"], ["proof (prove)\nusing this:\n  orientation x (x \\<sqinter> z)\n  orientable ?x \\<equiv> \\<exists>y. orientation ?x y\n\ngoal (1 subgoal):\n 1. orientable x", "by blast"], ["proof (state)\nthis:\n  orientable x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma loop_orientable_down_closed:\n  assumes \"symmetric x\"\n      and \"x \\<le> y\"\n      and \"loop_orientable y\"\n    shows \"loop_orientable x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loop_orientable x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. loop_orientable x", "from assms(3)"], ["proof (chain)\npicking this:\n  loop_orientable y", "obtain z where 1: \"z \\<squnion> z\\<^sup>T = y \\<and> antisymmetric z\""], ["proof (prove)\nusing this:\n  loop_orientable y\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        loop_orientation y z \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using loop_orientable_def"], ["proof (prove)\nusing this:\n  loop_orientable y\n  loop_orientable ?x \\<equiv> \\<exists>y. loop_orientation ?x y\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        loop_orientation y z \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  loop_orientation y z\n\ngoal (1 subgoal):\n 1. loop_orientable x", "let ?z = \"x \\<sqinter> z\""], ["proof (state)\ngoal (1 subgoal):\n 1. loop_orientable x", "have \"loop_orientation x ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loop_orientation x (x \\<sqinter> z)", "proof (rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<sqinter> z \\<squnion> (x \\<sqinter> z)\\<^sup>T = x\n 2. antisymmetric (x \\<sqinter> z)", "show \"antisymmetric ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antisymmetric (x \\<sqinter> z)", "using 1 antisymmetric_inf_closed inf_commute"], ["proof (prove)\nusing this:\n  loop_orientation y z\n  antisymmetric ?x \\<Longrightarrow> antisymmetric (?x \\<sqinter> ?y)\n  ?x \\<sqinter> ?y = ?y \\<sqinter> ?x\n\ngoal (1 subgoal):\n 1. antisymmetric (x \\<sqinter> z)", "by fastforce"], ["proof (state)\nthis:\n  antisymmetric (x \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. x \\<sqinter> z \\<squnion> (x \\<sqinter> z)\\<^sup>T = x", "thus \"?z \\<squnion> ?z\\<^sup>T = x\""], ["proof (prove)\nusing this:\n  antisymmetric (x \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. x \\<sqinter> z \\<squnion> (x \\<sqinter> z)\\<^sup>T = x", "using 1"], ["proof (prove)\nusing this:\n  antisymmetric (x \\<sqinter> z)\n  loop_orientation y z\n\ngoal (1 subgoal):\n 1. x \\<sqinter> z \\<squnion> (x \\<sqinter> z)\\<^sup>T = x", "by (metis assms(1,2) conv_dist_inf inf.orderE inf_sup_distrib1)"], ["proof (state)\nthis:\n  x \\<sqinter> z \\<squnion> (x \\<sqinter> z)\\<^sup>T = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  loop_orientation x (x \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. loop_orientable x", "thus ?thesis"], ["proof (prove)\nusing this:\n  loop_orientation x (x \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. loop_orientable x", "using loop_orientable_def"], ["proof (prove)\nusing this:\n  loop_orientation x (x \\<sqinter> z)\n  loop_orientable ?x \\<equiv> \\<exists>y. loop_orientation ?x y\n\ngoal (1 subgoal):\n 1. loop_orientable x", "by blast"], ["proof (state)\nthis:\n  loop_orientable x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma super_orientable_down_closed:\n  assumes \"x \\<le> y\"\n      and \"super_orientable y\"\n    shows \"super_orientable x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. super_orientable x", "using assms order_lesseq_imp super_orientable_def"], ["proof (prove)\nusing this:\n  x \\<le> y\n  super_orientable y\n  (\\<forall>z\\<ge>?x. ?y \\<le> z) = (?y \\<le> ?x)\n  super_orientable ?x \\<equiv> \\<exists>y. super_orientation ?x y\n\ngoal (1 subgoal):\n 1. super_orientable x", "by auto"], ["", "lemma loop_super_orientable_down_closed:\n  assumes \"x \\<le> y\"\n      and \"loop_super_orientable y\"\n    shows \"loop_super_orientable x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loop_super_orientable x", "using assms order_lesseq_imp loop_super_orientable_def"], ["proof (prove)\nusing this:\n  x \\<le> y\n  loop_super_orientable y\n  (\\<forall>z\\<ge>?x. ?y \\<le> z) = (?y \\<le> ?x)\n  loop_super_orientable ?x \\<equiv> \\<exists>y. loop_super_orientation ?x y\n\ngoal (1 subgoal):\n 1. loop_super_orientable x", "by auto"], ["", "abbreviation \"orientable_1 x \\<equiv> loop_super_orientable x\""], ["", "abbreviation \"orientable_2 x \\<equiv> \\<exists>y . x \\<le> y \\<squnion> y\\<^sup>T \\<and> y \\<sqinter> y\\<^sup>T \\<le> x \\<sqinter> 1\""], ["", "abbreviation \"orientable_3 x \\<equiv> \\<exists>y . x \\<le> y \\<squnion> y\\<^sup>T \\<and> y \\<sqinter> y\\<^sup>T = x \\<sqinter> 1\""], ["", "abbreviation \"orientable_4 x \\<equiv> irreflexive_inf x \\<longrightarrow> super_orientable x\""], ["", "abbreviation \"orientable_5 x \\<equiv> symmetric x \\<longrightarrow> loop_orientable x\""], ["", "abbreviation \"orientable_6 x \\<equiv> symmetric x \\<longrightarrow> (\\<exists>y . y \\<squnion> y\\<^sup>T = x \\<and> y \\<sqinter> y\\<^sup>T \\<le> x \\<sqinter> 1)\""], ["", "abbreviation \"orientable_7 x \\<equiv> symmetric x \\<longrightarrow> (\\<exists>y . y \\<squnion> y\\<^sup>T = x \\<and> y \\<sqinter> y\\<^sup>T = x \\<sqinter> 1)\""], ["", "abbreviation \"orientable_8 x \\<equiv> symmetric x \\<and> irreflexive_inf x \\<longrightarrow> orientable x\""], ["", "lemma super_orientation_diagonal:\n  \"x \\<le> y \\<squnion> y\\<^sup>T \\<Longrightarrow> y \\<sqinter> y\\<^sup>T \\<le> x \\<sqinter> 1 \\<Longrightarrow> y \\<sqinter> y\\<^sup>T = x \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y \\<squnion> y\\<^sup>T;\n     y \\<sqinter> y\\<^sup>T \\<le> x \\<sqinter> (1::'a)\\<rbrakk>\n    \\<Longrightarrow> y \\<sqinter> y\\<^sup>T = x \\<sqinter> (1::'a)", "using inf.antisym loop_super_orientation_diagonal"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<le> ?x; ?x \\<le> ?y\\<rbrakk> \\<Longrightarrow> ?x = ?y\n  loop_super_orientation ?x ?y \\<Longrightarrow>\n  ?x \\<sqinter> (1::'a) \\<le> ?y \\<sqinter> ?y\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y \\<squnion> y\\<^sup>T;\n     y \\<sqinter> y\\<^sup>T \\<le> x \\<sqinter> (1::'a)\\<rbrakk>\n    \\<Longrightarrow> y \\<sqinter> y\\<^sup>T = x \\<sqinter> (1::'a)", "by auto"], ["", "lemma orientable_2_implies_1:\n  \"orientable_2 x \\<Longrightarrow> orientable_1 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orientable_2 x \\<Longrightarrow> orientable_1 x", "using loop_super_orientable_def"], ["proof (prove)\nusing this:\n  orientable_1 ?x \\<equiv> \\<exists>y. loop_super_orientation ?x y\n\ngoal (1 subgoal):\n 1. orientable_2 x \\<Longrightarrow> orientable_1 x", "by auto"], ["", "lemma orientable_2_3:\n  \"orientable_2 x \\<longleftrightarrow> orientable_3 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orientable_2 x = orientable_3 x", "using eq_refl super_orientation_diagonal"], ["proof (prove)\nusing this:\n  ?x = ?y \\<Longrightarrow> ?x \\<le> ?y\n  \\<lbrakk>?x \\<le> ?y \\<squnion> ?y\\<^sup>T;\n   ?y \\<sqinter> ?y\\<^sup>T \\<le> ?x \\<sqinter> (1::'a)\\<rbrakk>\n  \\<Longrightarrow> ?y \\<sqinter> ?y\\<^sup>T = ?x \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. orientable_2 x = orientable_3 x", "by blast"], ["", "lemma orientable_5_6:\n  \"orientable_5 x \\<longleftrightarrow> orientable_6 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orientable_5 x = orientable_6 x", "using loop_orientable_def loop_orientation_diagonal"], ["proof (prove)\nusing this:\n  loop_orientable ?x \\<equiv> \\<exists>y. loop_orientation ?x y\n  loop_orientation ?x ?y \\<Longrightarrow>\n  ?y \\<sqinter> ?y\\<^sup>T = ?x \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. orientable_5 x = orientable_6 x", "by fastforce"], ["", "lemma orientable_6_7:\n  \"orientable_6 x \\<longleftrightarrow> orientable_7 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orientable_6 x = orientable_7 x", "using super_orientation_diagonal"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y \\<squnion> ?y\\<^sup>T;\n   ?y \\<sqinter> ?y\\<^sup>T \\<le> ?x \\<sqinter> (1::'a)\\<rbrakk>\n  \\<Longrightarrow> ?y \\<sqinter> ?y\\<^sup>T = ?x \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. orientable_6 x = orientable_7 x", "by fastforce"], ["", "lemma orientable_7_implies_8:\n  \"orientable_7 x \\<Longrightarrow> orientable_8 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orientable_7 x \\<Longrightarrow> orientable_8 x", "using orientable_def"], ["proof (prove)\nusing this:\n  orientable ?x \\<equiv> \\<exists>y. orientation ?x y\n\ngoal (1 subgoal):\n 1. orientable_7 x \\<Longrightarrow> orientable_8 x", "by blast"], ["", "lemma orientable_5_implies_1:\n  \"orientable_5 (x \\<squnion> x\\<^sup>T) \\<Longrightarrow> orientable_1 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orientable_5 (x \\<squnion> x\\<^sup>T) \\<Longrightarrow> orientable_1 x", "using conv_dist_sup loop_orientable_def loop_super_orientable_def sup_commute"], ["proof (prove)\nusing this:\n  (?x \\<squnion> ?y)\\<^sup>T = ?x\\<^sup>T \\<squnion> ?y\\<^sup>T\n  loop_orientable ?x \\<equiv> \\<exists>y. loop_orientation ?x y\n  orientable_1 ?x \\<equiv> \\<exists>y. loop_super_orientation ?x y\n  ?x \\<squnion> ?y = ?y \\<squnion> ?x\n\ngoal (1 subgoal):\n 1. orientable_5 (x \\<squnion> x\\<^sup>T) \\<Longrightarrow> orientable_1 x", "by fastforce"], ["", "text \\<open>ternary predicate S called \\<open>split\\<close> here\\<close>"], ["", "abbreviation \"split x y z \\<equiv> y \\<sqinter> y\\<^sup>T = x \\<and> y \\<squnion> y\\<^sup>T = z\""], ["", "text \\<open>Theorem 3.1\\<close>"], ["", "lemma orientation_split:\n  \"orientation x y \\<longleftrightarrow> split bot y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orientation x y = (asymmetric y \\<and> y \\<squnion> y\\<^sup>T = x)", "by auto"], ["", "text \\<open>Theorem 3.2\\<close>"], ["", "lemma split_1_loop_orientation:\n  \"split 1 y x \\<Longrightarrow> loop_orientation x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. split (1::'a) y x \\<Longrightarrow> loop_orientation x y", "by simp"], ["", "text \\<open>Theorem 3.3\\<close>"], ["", "lemma loop_orientation_split:\n  \"loop_orientation x y \\<longleftrightarrow> split (x \\<sqinter> 1) y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loop_orientation x y = split (x \\<sqinter> (1::'a)) y x", "by (metis inf.cobounded2 loop_orientation_diagonal)"], ["", "text \\<open>Theorem 3.4\\<close>"], ["", "lemma loop_orientation_split_inf_1:\n  \"loop_orientation x y \\<longleftrightarrow> split (y \\<sqinter> 1) y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loop_orientation x y = split (y \\<sqinter> (1::'a)) y x", "by (metis inf.sup_monoid.add_commute inf.sup_same_context inf_le2 one_inf_conv)"], ["", "lemma loop_orientation_top_split:\n  \"loop_orientation top y \\<longleftrightarrow> split 1 y top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (linear y \\<and> antisymmetric y) =\n    (y \\<sqinter> y\\<^sup>T = (1::'a) \\<and> linear y)", "by (simp add: loop_orientation_split)"], ["", "text \\<open>injective and transitive orientations\\<close>"], ["", "definition \"injectively_orientable x \\<equiv> \\<exists>y . orientation x y \\<and> injective y\""], ["", "lemma injectively_orientable_orientable:\n  \"injectively_orientable x \\<Longrightarrow> orientable x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. injectively_orientable x \\<Longrightarrow> orientable x", "using injectively_orientable_def orientable_def"], ["proof (prove)\nusing this:\n  injectively_orientable ?x \\<equiv>\n  \\<exists>y. orientation ?x y \\<and> injective y\n  orientable ?x \\<equiv> \\<exists>y. orientation ?x y\n\ngoal (1 subgoal):\n 1. injectively_orientable x \\<Longrightarrow> orientable x", "by auto"], ["", "lemma orientable_orientable_1:\n  \"orientable x \\<Longrightarrow> orientable_1 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orientable x \\<Longrightarrow> orientable_1 x", "by (metis bot_least order_refl loop_super_orientable_def orientable_def)"], ["", "lemma injectively_orientable_down_closed:\n  assumes \"symmetric x\"\n      and \"x \\<le> y\"\n      and \"injectively_orientable y\"\n    shows \"injectively_orientable x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. injectively_orientable x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. injectively_orientable x", "from assms(3)"], ["proof (chain)\npicking this:\n  injectively_orientable y", "obtain z where 1: \"z \\<squnion> z\\<^sup>T = y \\<and> asymmetric z \\<and> injective z\""], ["proof (prove)\nusing this:\n  injectively_orientable y\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        z \\<squnion> z\\<^sup>T = y \\<and>\n        asymmetric z \\<and> injective z \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using injectively_orientable_def"], ["proof (prove)\nusing this:\n  injectively_orientable y\n  injectively_orientable ?x \\<equiv>\n  \\<exists>y. orientation ?x y \\<and> injective y\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        z \\<squnion> z\\<^sup>T = y \\<and>\n        asymmetric z \\<and> injective z \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  z \\<squnion> z\\<^sup>T = y \\<and> asymmetric z \\<and> injective z\n\ngoal (1 subgoal):\n 1. injectively_orientable x", "let ?z = \"x \\<sqinter> z\""], ["proof (state)\ngoal (1 subgoal):\n 1. injectively_orientable x", "have 2: \"injective ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. injective (x \\<sqinter> z)", "using 1 inf_commute injective_inf_closed"], ["proof (prove)\nusing this:\n  z \\<squnion> z\\<^sup>T = y \\<and> asymmetric z \\<and> injective z\n  ?x \\<sqinter> ?y = ?y \\<sqinter> ?x\n  injective ?x \\<Longrightarrow> injective (?x \\<sqinter> ?y)\n\ngoal (1 subgoal):\n 1. injective (x \\<sqinter> z)", "by fastforce"], ["proof (state)\nthis:\n  injective (x \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. injectively_orientable x", "have \"orientation x ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orientation x (x \\<sqinter> z)", "proof (rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<sqinter> z \\<squnion> (x \\<sqinter> z)\\<^sup>T = x\n 2. asymmetric (x \\<sqinter> z)", "show \"asymmetric ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. asymmetric (x \\<sqinter> z)", "using 1"], ["proof (prove)\nusing this:\n  z \\<squnion> z\\<^sup>T = y \\<and> asymmetric z \\<and> injective z\n\ngoal (1 subgoal):\n 1. asymmetric (x \\<sqinter> z)", "by (simp add: conv_dist_inf inf.left_commute inf.sup_monoid.add_assoc)"], ["proof (state)\nthis:\n  asymmetric (x \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. x \\<sqinter> z \\<squnion> (x \\<sqinter> z)\\<^sup>T = x", "thus \"?z \\<squnion> ?z\\<^sup>T = x\""], ["proof (prove)\nusing this:\n  asymmetric (x \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. x \\<sqinter> z \\<squnion> (x \\<sqinter> z)\\<^sup>T = x", "using 1"], ["proof (prove)\nusing this:\n  asymmetric (x \\<sqinter> z)\n  z \\<squnion> z\\<^sup>T = y \\<and> asymmetric z \\<and> injective z\n\ngoal (1 subgoal):\n 1. x \\<sqinter> z \\<squnion> (x \\<sqinter> z)\\<^sup>T = x", "by (metis assms(1,2) conv_dist_inf inf.orderE inf_sup_distrib1)"], ["proof (state)\nthis:\n  x \\<sqinter> z \\<squnion> (x \\<sqinter> z)\\<^sup>T = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  orientation x (x \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. injectively_orientable x", "thus ?thesis"], ["proof (prove)\nusing this:\n  orientation x (x \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. injectively_orientable x", "using 2 injectively_orientable_def"], ["proof (prove)\nusing this:\n  orientation x (x \\<sqinter> z)\n  injective (x \\<sqinter> z)\n  injectively_orientable ?x \\<equiv>\n  \\<exists>y. orientation ?x y \\<and> injective y\n\ngoal (1 subgoal):\n 1. injectively_orientable x", "by blast"], ["proof (state)\nthis:\n  injectively_orientable x\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"transitively_orientable x \\<equiv> \\<exists>y . orientation x y \\<and> transitive y\""], ["", "lemma transitively_orientable_orientable:\n  \"transitively_orientable x \\<Longrightarrow> orientable x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitively_orientable x \\<Longrightarrow> orientable x", "using transitively_orientable_def orientable_def"], ["proof (prove)\nusing this:\n  transitively_orientable ?x \\<equiv>\n  \\<exists>y. orientation ?x y \\<and> transitive y\n  orientable ?x \\<equiv> \\<exists>y. orientation ?x y\n\ngoal (1 subgoal):\n 1. transitively_orientable x \\<Longrightarrow> orientable x", "by auto"], ["", "lemma irreflexive_transitive_orientation_asymmetric:\n  assumes \"irreflexive_inf x\"\n      and \"transitive y\"\n      and \"y \\<squnion> y\\<^sup>T = x\"\n    shows \"asymmetric y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. asymmetric y", "using assms comp_inf.mult_right_dist_sup transitive_asymmetric_irreflexive_inf"], ["proof (prove)\nusing this:\n  irreflexive_inf x\n  transitive y\n  y \\<squnion> y\\<^sup>T = x\n  (?x \\<squnion> ?y) \\<sqinter> ?z =\n  ?x \\<sqinter> ?z \\<squnion> ?y \\<sqinter> ?z\n  transitive ?x \\<Longrightarrow> asymmetric ?x = irreflexive_inf ?x\n\ngoal (1 subgoal):\n 1. asymmetric y", "by auto"], ["", "text \\<open>Theorem 12\\<close>"], ["", "lemma transitively_orientable_2:\n  \"transitively_orientable x \\<longleftrightarrow> irreflexive_inf x \\<and> (\\<exists>y . y \\<squnion> y\\<^sup>T = x \\<and> transitive y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitively_orientable x =\n    (irreflexive_inf x \\<and>\n     (\\<exists>y. y \\<squnion> y\\<^sup>T = x \\<and> transitive y))", "by (metis irreflexive_transitive_orientation_asymmetric coreflexive_bot_closed loop_orientation_split transitively_orientable_def)"], ["", "end"], ["", "context relation_algebra_signature\nbegin"], ["", "abbreviation asymmetric_var :: \"'a \\<Rightarrow> bool\" where \"asymmetric_var x \\<equiv> irreflexive (x * x)\""], ["", "end"], ["", "context pd_allegory\nbegin"], ["", "text \\<open>Theorem 1.4\\<close>"], ["", "lemma asymmetric_var:\n  \"asymmetric x \\<longleftrightarrow> asymmetric_var x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. asymmetric x = asymmetric_var x", "using asymmetric_inf pseudo_complement"], ["proof (prove)\nusing this:\n  asymmetric ?x = irreflexive_inf (?x * ?x)\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. asymmetric x = asymmetric_var x", "by auto"], ["", "text \\<open>Theorem 1.3\\<close>"], ["", "text \\<open>(Theorem 1.2 is \\<open>asymmetric_irreflexive\\<close> in \\<open>Relation_Algebras\\<close>)\\<close>"], ["", "lemma transitive_asymmetric_irreflexive:\n  \"transitive x \\<Longrightarrow> asymmetric x \\<longleftrightarrow> irreflexive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitive x \\<Longrightarrow> asymmetric x = irreflexive x", "using strict_order_var"], ["proof (prove)\nusing this:\n  strict_order ?x = (asymmetric ?x \\<and> transitive ?x)\n\ngoal (1 subgoal):\n 1. transitive x \\<Longrightarrow> asymmetric x = irreflexive x", "by blast"], ["", "lemma orientable_irreflexive:\n  \"orientable x \\<Longrightarrow> irreflexive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orientable x \\<Longrightarrow> irreflexive x", "using orientable_irreflexive_inf pseudo_complement"], ["proof (prove)\nusing this:\n  orientable ?x \\<Longrightarrow> irreflexive_inf ?x\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. orientable x \\<Longrightarrow> irreflexive x", "by blast"], ["", "lemma super_orientable_irreflexive:\n  \"super_orientable x \\<Longrightarrow> irreflexive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. super_orientable x \\<Longrightarrow> irreflexive x", "using pseudo_complement super_orientable_irreflexive_inf"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n  super_orientable ?x \\<Longrightarrow> irreflexive_inf ?x\n\ngoal (1 subgoal):\n 1. super_orientable x \\<Longrightarrow> irreflexive x", "by blast"], ["", "lemma orientation_diversity_split:\n  \"orientation (-1) y \\<longleftrightarrow> split bot y (-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (strict_linear y \\<and> asymmetric y) =\n    (asymmetric y \\<and> strict_linear y)", "by auto"], ["", "abbreviation \"linear_orderable_1 x \\<equiv> linear_order x\""], ["", "abbreviation \"linear_orderable_2 x \\<equiv> linear_strict_order x\""], ["", "abbreviation \"linear_orderable_3 x \\<equiv> transitive x \\<and> asymmetric x \\<and> strict_linear x\""], ["", "abbreviation \"linear_orderable_3a x \\<equiv> transitive x \\<and> strict_linear x\""], ["", "abbreviation \"orientable_11 x \\<equiv> split 1 x top\""], ["", "abbreviation \"orientable_12 x \\<equiv> split bot x (-1)\""], ["", "lemma linear_strict_order_split:\n  \"linear_strict_order x \\<longleftrightarrow> transitive x \\<and> split bot x (-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_orderable_2 x = linear_orderable_3 x", "using strict_order_var"], ["proof (prove)\nusing this:\n  strict_order ?x = (asymmetric ?x \\<and> transitive ?x)\n\ngoal (1 subgoal):\n 1. linear_orderable_2 x = linear_orderable_3 x", "by blast"], ["", "text \\<open>Theorem 1.6\\<close>"], ["", "lemma linear_strict_order_without_irreflexive:\n  \"linear_strict_order x \\<longleftrightarrow> transitive x \\<and> strict_linear x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_orderable_2 x = linear_orderable_3a x", "using strict_linear_irreflexive"], ["proof (prove)\nusing this:\n  strict_linear ?x \\<Longrightarrow> irreflexive ?x\n\ngoal (1 subgoal):\n 1. linear_orderable_2 x = linear_orderable_3a x", "by auto"], ["", "lemma linear_order_without_reflexive:\n  \"linear_order x \\<longleftrightarrow> antisymmetric x \\<and> transitive x \\<and> linear x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_orderable_1 x =\n    (antisymmetric x \\<and> transitive x \\<and> linear x)", "using linear_reflexive"], ["proof (prove)\nusing this:\n  linear ?x \\<Longrightarrow> reflexive ?x\n\ngoal (1 subgoal):\n 1. linear_orderable_1 x =\n    (antisymmetric x \\<and> transitive x \\<and> linear x)", "by blast"], ["", "lemma linear_orderable_1_implies_2:\n  \"linear_orderable_1 x \\<Longrightarrow> linear_orderable_2 (x \\<sqinter> -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_orderable_1 x \\<Longrightarrow>\n    linear_orderable_2 (x \\<sqinter> - (1::'a))", "using linear_order_strict_order"], ["proof (prove)\nusing this:\n  linear_orderable_1 ?x \\<Longrightarrow>\n  linear_orderable_2 (?x \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. linear_orderable_1 x \\<Longrightarrow>\n    linear_orderable_2 (x \\<sqinter> - (1::'a))", "by blast"], ["", "lemma linear_orderable_2_3:\n  \"linear_orderable_2 x \\<longleftrightarrow> linear_orderable_3 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_orderable_2 x = linear_orderable_3 x", "using linear_strict_order_split"], ["proof (prove)\nusing this:\n  linear_orderable_2 ?x = linear_orderable_3 ?x\n\ngoal (1 subgoal):\n 1. linear_orderable_2 x = linear_orderable_3 x", "by auto"], ["", "lemma linear_orderable_3_3a:\n  \"linear_orderable_3 x \\<longleftrightarrow> linear_orderable_3a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_orderable_3 x = linear_orderable_3a x", "using strict_linear_irreflexive strict_order_var"], ["proof (prove)\nusing this:\n  strict_linear ?x \\<Longrightarrow> irreflexive ?x\n  strict_order ?x = (asymmetric ?x \\<and> transitive ?x)\n\ngoal (1 subgoal):\n 1. linear_orderable_3 x = linear_orderable_3a x", "by blast"], ["", "lemma linear_orderable_3_implies_orientable_12:\n  \"linear_orderable_3 x \\<Longrightarrow> orientable_12 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_orderable_3 x \\<Longrightarrow>\n    asymmetric x \\<and> strict_linear x", "by simp"], ["", "lemma orientable_11_implies_12:\n  \"orientable_11 x \\<Longrightarrow> orientable_12 (x \\<sqinter> -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x \\<Longrightarrow>\n    asymmetric (x \\<sqinter> - (1::'a)) \\<and>\n    strict_linear (x \\<sqinter> - (1::'a))", "by (smt inf_sup_distrib2 conv_complement conv_dist_inf conv_involutive inf_import_p inf_top.left_neutral linear_asymmetric maddux_3_13 p_inf symmetric_one_closed)"], ["", "end"], ["", "context stone_relation_algebra\nbegin"], ["", "text \\<open>Theorem 3.5\\<close>"], ["", "lemma split_symmetric_asymmetric:\n  assumes \"regular x\"\n    shows \"split x y z \\<longleftrightarrow> y \\<sqinter> y\\<^sup>T = x \\<and> (y \\<sqinter> -y\\<^sup>T) \\<squnion> (y \\<sqinter> -y\\<^sup>T)\\<^sup>T = z \\<sqinter> -x \\<and> x \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. split x y z =\n    (y \\<sqinter> y\\<^sup>T = x \\<and>\n     y \\<sqinter> - y\\<^sup>T \\<squnion>\n     (y \\<sqinter> - y\\<^sup>T)\\<^sup>T =\n     z \\<sqinter> - x \\<and>\n     x \\<le> z)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. split x y z \\<Longrightarrow>\n    y \\<sqinter> y\\<^sup>T = x \\<and>\n    y \\<sqinter> - y\\<^sup>T \\<squnion> (y \\<sqinter> - y\\<^sup>T)\\<^sup>T =\n    z \\<sqinter> - x \\<and>\n    x \\<le> z\n 2. y \\<sqinter> y\\<^sup>T = x \\<and>\n    y \\<sqinter> - y\\<^sup>T \\<squnion> (y \\<sqinter> - y\\<^sup>T)\\<^sup>T =\n    z \\<sqinter> - x \\<and>\n    x \\<le> z \\<Longrightarrow>\n    split x y z", "assume \"split x y z\""], ["proof (state)\nthis:\n  split x y z\n\ngoal (2 subgoals):\n 1. split x y z \\<Longrightarrow>\n    y \\<sqinter> y\\<^sup>T = x \\<and>\n    y \\<sqinter> - y\\<^sup>T \\<squnion> (y \\<sqinter> - y\\<^sup>T)\\<^sup>T =\n    z \\<sqinter> - x \\<and>\n    x \\<le> z\n 2. y \\<sqinter> y\\<^sup>T = x \\<and>\n    y \\<sqinter> - y\\<^sup>T \\<squnion> (y \\<sqinter> - y\\<^sup>T)\\<^sup>T =\n    z \\<sqinter> - x \\<and>\n    x \\<le> z \\<Longrightarrow>\n    split x y z", "thus \"y \\<sqinter> y\\<^sup>T = x \\<and> (y \\<sqinter> -y\\<^sup>T) \\<squnion> (y \\<sqinter> -y\\<^sup>T)\\<^sup>T = z \\<sqinter> -x \\<and> x \\<le> z\""], ["proof (prove)\nusing this:\n  split x y z\n\ngoal (1 subgoal):\n 1. y \\<sqinter> y\\<^sup>T = x \\<and>\n    y \\<sqinter> - y\\<^sup>T \\<squnion> (y \\<sqinter> - y\\<^sup>T)\\<^sup>T =\n    z \\<sqinter> - x \\<and>\n    x \\<le> z", "by (metis conv_complement conv_dist_inf conv_involutive inf.cobounded1 inf.sup_monoid.add_commute inf_import_p inf_sup_distrib2 le_supI1)"], ["proof (state)\nthis:\n  y \\<sqinter> y\\<^sup>T = x \\<and>\n  y \\<sqinter> - y\\<^sup>T \\<squnion> (y \\<sqinter> - y\\<^sup>T)\\<^sup>T =\n  z \\<sqinter> - x \\<and>\n  x \\<le> z\n\ngoal (1 subgoal):\n 1. y \\<sqinter> y\\<^sup>T = x \\<and>\n    y \\<sqinter> - y\\<^sup>T \\<squnion> (y \\<sqinter> - y\\<^sup>T)\\<^sup>T =\n    z \\<sqinter> - x \\<and>\n    x \\<le> z \\<Longrightarrow>\n    split x y z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<sqinter> y\\<^sup>T = x \\<and>\n    y \\<sqinter> - y\\<^sup>T \\<squnion> (y \\<sqinter> - y\\<^sup>T)\\<^sup>T =\n    z \\<sqinter> - x \\<and>\n    x \\<le> z \\<Longrightarrow>\n    split x y z", "assume \"y \\<sqinter> y\\<^sup>T = x \\<and> (y \\<sqinter> -y\\<^sup>T) \\<squnion> (y \\<sqinter> -y\\<^sup>T)\\<^sup>T = z \\<sqinter> -x \\<and> x \\<le> z\""], ["proof (state)\nthis:\n  y \\<sqinter> y\\<^sup>T = x \\<and>\n  y \\<sqinter> - y\\<^sup>T \\<squnion> (y \\<sqinter> - y\\<^sup>T)\\<^sup>T =\n  z \\<sqinter> - x \\<and>\n  x \\<le> z\n\ngoal (1 subgoal):\n 1. y \\<sqinter> y\\<^sup>T = x \\<and>\n    y \\<sqinter> - y\\<^sup>T \\<squnion> (y \\<sqinter> - y\\<^sup>T)\\<^sup>T =\n    z \\<sqinter> - x \\<and>\n    x \\<le> z \\<Longrightarrow>\n    split x y z", "thus \"split x y z\""], ["proof (prove)\nusing this:\n  y \\<sqinter> y\\<^sup>T = x \\<and>\n  y \\<sqinter> - y\\<^sup>T \\<squnion> (y \\<sqinter> - y\\<^sup>T)\\<^sup>T =\n  z \\<sqinter> - x \\<and>\n  x \\<le> z\n\ngoal (1 subgoal):\n 1. split x y z", "by (smt (z3) assms conv_dist_sup conv_involutive inf.absorb2 inf.boundedE inf.cobounded1 inf.idem inf.sup_monoid.add_commute inf_import_p maddux_3_11_pp sup.left_commute sup_commute sup_inf_absorb)"], ["proof (state)\nthis:\n  split x y z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orientable_1_2:\n  \"orientable_1 x \\<longleftrightarrow> orientable_2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orientable_1 x = orientable_2 x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. orientable_1 x \\<Longrightarrow> orientable_2 x\n 2. orientable_2 x \\<Longrightarrow> orientable_1 x", "assume \"orientable_1 x\""], ["proof (state)\nthis:\n  orientable_1 x\n\ngoal (2 subgoals):\n 1. orientable_1 x \\<Longrightarrow> orientable_2 x\n 2. orientable_2 x \\<Longrightarrow> orientable_1 x", "from this"], ["proof (chain)\npicking this:\n  orientable_1 x", "obtain y where 1: \"x \\<le> y \\<squnion> y\\<^sup>T \\<and> y \\<sqinter> y\\<^sup>T \\<le> 1\""], ["proof (prove)\nusing this:\n  orientable_1 x\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        loop_super_orientation x y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using loop_super_orientable_def"], ["proof (prove)\nusing this:\n  orientable_1 x\n  orientable_1 ?x \\<equiv> \\<exists>y. loop_super_orientation ?x y\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        loop_super_orientation x y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  loop_super_orientation x y\n\ngoal (2 subgoals):\n 1. orientable_1 x \\<Longrightarrow> orientable_2 x\n 2. orientable_2 x \\<Longrightarrow> orientable_1 x", "let ?y = \"(x \\<sqinter> 1) \\<squnion> (y \\<sqinter> -1)\""], ["proof (state)\ngoal (2 subgoals):\n 1. orientable_1 x \\<Longrightarrow> orientable_2 x\n 2. orientable_2 x \\<Longrightarrow> orientable_1 x", "have \"x \\<le> ?y \\<squnion> ?y\\<^sup>T \\<and> ?y \\<sqinter> ?y\\<^sup>T \\<le> x \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x \\<sqinter> (1::'a) \\<squnion>\n            y \\<sqinter> - (1::'a) \\<squnion>\n            (x \\<sqinter> (1::'a) \\<squnion>\n             y \\<sqinter> - (1::'a))\\<^sup>T \\<and>\n    (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a)) \\<sqinter>\n    (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T\n    \\<le> x \\<sqinter> (1::'a)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<le> x \\<sqinter> (1::'a) \\<squnion>\n            y \\<sqinter> - (1::'a) \\<squnion>\n            (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T\n 2. (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a)) \\<sqinter>\n    (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T\n    \\<le> x \\<sqinter> (1::'a)", "have \"x \\<sqinter> -1 \\<le> (y \\<sqinter> -1) \\<squnion> (y\\<^sup>T \\<sqinter> -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> - (1::'a)\n    \\<le> y \\<sqinter> - (1::'a) \\<squnion> y\\<^sup>T \\<sqinter> - (1::'a)", "using 1 inf.sup_right_divisibility inf_commute inf_left_commute inf_sup_distrib2"], ["proof (prove)\nusing this:\n  loop_super_orientation x y\n  (?y \\<le> ?x) = (\\<exists>z. z \\<sqinter> ?x = ?y)\n  ?x \\<sqinter> ?y = ?y \\<sqinter> ?x\n  ?x \\<sqinter> (?y \\<sqinter> ?z) = ?y \\<sqinter> (?x \\<sqinter> ?z)\n  (?y \\<squnion> ?z) \\<sqinter> ?x =\n  ?y \\<sqinter> ?x \\<squnion> ?z \\<sqinter> ?x\n\ngoal (1 subgoal):\n 1. x \\<sqinter> - (1::'a)\n    \\<le> y \\<sqinter> - (1::'a) \\<squnion> y\\<^sup>T \\<sqinter> - (1::'a)", "by auto"], ["proof (state)\nthis:\n  x \\<sqinter> - (1::'a)\n  \\<le> y \\<sqinter> - (1::'a) \\<squnion> y\\<^sup>T \\<sqinter> - (1::'a)\n\ngoal (2 subgoals):\n 1. x \\<le> x \\<sqinter> (1::'a) \\<squnion>\n            y \\<sqinter> - (1::'a) \\<squnion>\n            (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T\n 2. (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a)) \\<sqinter>\n    (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T\n    \\<le> x \\<sqinter> (1::'a)", "also"], ["proof (state)\nthis:\n  x \\<sqinter> - (1::'a)\n  \\<le> y \\<sqinter> - (1::'a) \\<squnion> y\\<^sup>T \\<sqinter> - (1::'a)\n\ngoal (2 subgoals):\n 1. x \\<le> x \\<sqinter> (1::'a) \\<squnion>\n            y \\<sqinter> - (1::'a) \\<squnion>\n            (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T\n 2. (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a)) \\<sqinter>\n    (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T\n    \\<le> x \\<sqinter> (1::'a)", "have \"... \\<le> ?y \\<squnion> ?y\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sqinter> - (1::'a) \\<squnion> y\\<^sup>T \\<sqinter> - (1::'a)\n    \\<le> x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a) \\<squnion>\n          (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T", "by (metis comp_inf.semiring.add_mono conv_complement conv_dist_inf conv_isotone sup.cobounded2 symmetric_one_closed)"], ["proof (state)\nthis:\n  y \\<sqinter> - (1::'a) \\<squnion> y\\<^sup>T \\<sqinter> - (1::'a)\n  \\<le> x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a) \\<squnion>\n        (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T\n\ngoal (2 subgoals):\n 1. x \\<le> x \\<sqinter> (1::'a) \\<squnion>\n            y \\<sqinter> - (1::'a) \\<squnion>\n            (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T\n 2. (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a)) \\<sqinter>\n    (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T\n    \\<le> x \\<sqinter> (1::'a)", "finally"], ["proof (chain)\npicking this:\n  x \\<sqinter> - (1::'a)\n  \\<le> x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a) \\<squnion>\n        (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T", "show \"x \\<le> ?y \\<squnion> ?y\\<^sup>T\""], ["proof (prove)\nusing this:\n  x \\<sqinter> - (1::'a)\n  \\<le> x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a) \\<squnion>\n        (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T\n\ngoal (1 subgoal):\n 1. x \\<le> x \\<sqinter> (1::'a) \\<squnion>\n            y \\<sqinter> - (1::'a) \\<squnion>\n            (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T", "by (metis comp_inf.semiring.add_mono maddux_3_11_pp regular_one_closed sup.cobounded1 sup.left_idem)"], ["proof (state)\nthis:\n  x \\<le> x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a) \\<squnion>\n          (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a)) \\<sqinter>\n    (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T\n    \\<le> x \\<sqinter> (1::'a)", "have \"x = (x \\<sqinter> 1) \\<squnion> (x \\<sqinter> -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x \\<sqinter> (1::'a) \\<squnion> x \\<sqinter> - (1::'a)", "by (metis maddux_3_11_pp regular_one_closed)"], ["proof (state)\nthis:\n  x = x \\<sqinter> (1::'a) \\<squnion> x \\<sqinter> - (1::'a)\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a)) \\<sqinter>\n    (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T\n    \\<le> x \\<sqinter> (1::'a)", "have \"?y \\<sqinter> ?y\\<^sup>T = (x \\<sqinter> 1) \\<squnion> ((y \\<sqinter> -1) \\<sqinter> (y\\<^sup>T \\<sqinter> -1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a)) \\<sqinter>\n    (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T =\n    x \\<sqinter> (1::'a) \\<squnion>\n    y \\<sqinter> - (1::'a) \\<sqinter> (y\\<^sup>T \\<sqinter> - (1::'a))", "by (metis comp_inf.semiring.distrib_left conv_complement conv_dist_inf conv_dist_sup coreflexive_symmetric distrib_imp1 inf_le2 symmetric_one_closed)"], ["proof (state)\nthis:\n  (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a)) \\<sqinter>\n  (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T =\n  x \\<sqinter> (1::'a) \\<squnion>\n  y \\<sqinter> - (1::'a) \\<sqinter> (y\\<^sup>T \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a)) \\<sqinter>\n    (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T\n    \\<le> x \\<sqinter> (1::'a)", "also"], ["proof (state)\nthis:\n  (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a)) \\<sqinter>\n  (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T =\n  x \\<sqinter> (1::'a) \\<squnion>\n  y \\<sqinter> - (1::'a) \\<sqinter> (y\\<^sup>T \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a)) \\<sqinter>\n    (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T\n    \\<le> x \\<sqinter> (1::'a)", "have \"... = x \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> (1::'a) \\<squnion>\n    y \\<sqinter> - (1::'a) \\<sqinter> (y\\<^sup>T \\<sqinter> - (1::'a)) =\n    x \\<sqinter> (1::'a)", "by (metis 1 inf_assoc inf_commute pseudo_complement regular_one_closed selection_closed_id inf.cobounded2 maddux_3_11_pp)"], ["proof (state)\nthis:\n  x \\<sqinter> (1::'a) \\<squnion>\n  y \\<sqinter> - (1::'a) \\<sqinter> (y\\<^sup>T \\<sqinter> - (1::'a)) =\n  x \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a)) \\<sqinter>\n    (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T\n    \\<le> x \\<sqinter> (1::'a)", "finally"], ["proof (chain)\npicking this:\n  (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a)) \\<sqinter>\n  (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T =\n  x \\<sqinter> (1::'a)", "show \"?y \\<sqinter> ?y\\<^sup>T \\<le> x \\<sqinter> 1\""], ["proof (prove)\nusing this:\n  (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a)) \\<sqinter>\n  (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T =\n  x \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a)) \\<sqinter>\n    (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T\n    \\<le> x \\<sqinter> (1::'a)", "by simp"], ["proof (state)\nthis:\n  (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a)) \\<sqinter>\n  (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T\n  \\<le> x \\<sqinter> (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<le> x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a) \\<squnion>\n          (x \\<sqinter> (1::'a) \\<squnion>\n           y \\<sqinter> - (1::'a))\\<^sup>T \\<and>\n  (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a)) \\<sqinter>\n  (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T\n  \\<le> x \\<sqinter> (1::'a)\n\ngoal (2 subgoals):\n 1. orientable_1 x \\<Longrightarrow> orientable_2 x\n 2. orientable_2 x \\<Longrightarrow> orientable_1 x", "thus \"orientable_2 x\""], ["proof (prove)\nusing this:\n  x \\<le> x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a) \\<squnion>\n          (x \\<sqinter> (1::'a) \\<squnion>\n           y \\<sqinter> - (1::'a))\\<^sup>T \\<and>\n  (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a)) \\<sqinter>\n  (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> - (1::'a))\\<^sup>T\n  \\<le> x \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. orientable_2 x", "by blast"], ["proof (state)\nthis:\n  orientable_2 x\n\ngoal (1 subgoal):\n 1. orientable_2 x \\<Longrightarrow> orientable_1 x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. orientable_2 x \\<Longrightarrow> orientable_1 x", "assume \"orientable_2 x\""], ["proof (state)\nthis:\n  orientable_2 x\n\ngoal (1 subgoal):\n 1. orientable_2 x \\<Longrightarrow> orientable_1 x", "thus \"orientable_1 x\""], ["proof (prove)\nusing this:\n  orientable_2 x\n\ngoal (1 subgoal):\n 1. orientable_1 x", "using loop_super_orientable_def"], ["proof (prove)\nusing this:\n  orientable_2 x\n  orientable_1 ?x \\<equiv> \\<exists>y. loop_super_orientation ?x y\n\ngoal (1 subgoal):\n 1. orientable_1 x", "by auto"], ["proof (state)\nthis:\n  orientable_1 x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orientable_8_implies_5:\n  assumes \"orientable_8 (x \\<sqinter> -1)\"\n  shows \"orientable_5 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orientable_5 x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. symmetric x \\<Longrightarrow> loop_orientable x", "assume 1: \"symmetric x\""], ["proof (state)\nthis:\n  symmetric x\n\ngoal (1 subgoal):\n 1. symmetric x \\<Longrightarrow> loop_orientable x", "hence \"symmetric (x \\<sqinter> -1)\""], ["proof (prove)\nusing this:\n  symmetric x\n\ngoal (1 subgoal):\n 1. symmetric (x \\<sqinter> - (1::'a))", "by (simp add: conv_complement symmetric_inf_closed)"], ["proof (state)\nthis:\n  symmetric (x \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. symmetric x \\<Longrightarrow> loop_orientable x", "hence \"orientable (x \\<sqinter> -1)\""], ["proof (prove)\nusing this:\n  symmetric (x \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. orientable (x \\<sqinter> - (1::'a))", "by (simp add: assms pseudo_complement)"], ["proof (state)\nthis:\n  orientable (x \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. symmetric x \\<Longrightarrow> loop_orientable x", "from this"], ["proof (chain)\npicking this:\n  orientable (x \\<sqinter> - (1::'a))", "obtain y where 2: \"y \\<squnion> y\\<^sup>T = x \\<sqinter> -1 \\<and> asymmetric y\""], ["proof (prove)\nusing this:\n  orientable (x \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        orientation (x \\<sqinter> - (1::'a)) y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using orientable_def"], ["proof (prove)\nusing this:\n  orientable (x \\<sqinter> - (1::'a))\n  orientable ?x \\<equiv> \\<exists>y. orientation ?x y\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        orientation (x \\<sqinter> - (1::'a)) y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  orientation (x \\<sqinter> - (1::'a)) y\n\ngoal (1 subgoal):\n 1. symmetric x \\<Longrightarrow> loop_orientable x", "let ?y = \"y \\<squnion> (x \\<sqinter> 1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. symmetric x \\<Longrightarrow> loop_orientable x", "have \"loop_orientation x ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loop_orientation x (y \\<squnion> x \\<sqinter> (1::'a))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<squnion> x \\<sqinter> (1::'a) \\<squnion>\n    (y \\<squnion> x \\<sqinter> (1::'a))\\<^sup>T =\n    x\n 2. antisymmetric (y \\<squnion> x \\<sqinter> (1::'a))", "have \"?y \\<squnion> ?y\\<^sup>T = y \\<squnion> y\\<^sup>T \\<squnion> (x \\<sqinter> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<squnion> x \\<sqinter> (1::'a) \\<squnion>\n    (y \\<squnion> x \\<sqinter> (1::'a))\\<^sup>T =\n    y \\<squnion> y\\<^sup>T \\<squnion> x \\<sqinter> (1::'a)", "using 1 conv_dist_inf conv_dist_sup sup_assoc sup_commute"], ["proof (prove)\nusing this:\n  symmetric x\n  (?x \\<sqinter> ?y)\\<^sup>T = ?x\\<^sup>T \\<sqinter> ?y\\<^sup>T\n  (?x \\<squnion> ?y)\\<^sup>T = ?x\\<^sup>T \\<squnion> ?y\\<^sup>T\n  ?x \\<squnion> ?y \\<squnion> ?z = ?x \\<squnion> (?y \\<squnion> ?z)\n  ?x \\<squnion> ?y = ?y \\<squnion> ?x\n\ngoal (1 subgoal):\n 1. y \\<squnion> x \\<sqinter> (1::'a) \\<squnion>\n    (y \\<squnion> x \\<sqinter> (1::'a))\\<^sup>T =\n    y \\<squnion> y\\<^sup>T \\<squnion> x \\<sqinter> (1::'a)", "by auto"], ["proof (state)\nthis:\n  y \\<squnion> x \\<sqinter> (1::'a) \\<squnion>\n  (y \\<squnion> x \\<sqinter> (1::'a))\\<^sup>T =\n  y \\<squnion> y\\<^sup>T \\<squnion> x \\<sqinter> (1::'a)\n\ngoal (2 subgoals):\n 1. y \\<squnion> x \\<sqinter> (1::'a) \\<squnion>\n    (y \\<squnion> x \\<sqinter> (1::'a))\\<^sup>T =\n    x\n 2. antisymmetric (y \\<squnion> x \\<sqinter> (1::'a))", "thus \"?y \\<squnion> ?y\\<^sup>T = x\""], ["proof (prove)\nusing this:\n  y \\<squnion> x \\<sqinter> (1::'a) \\<squnion>\n  (y \\<squnion> x \\<sqinter> (1::'a))\\<^sup>T =\n  y \\<squnion> y\\<^sup>T \\<squnion> x \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. y \\<squnion> x \\<sqinter> (1::'a) \\<squnion>\n    (y \\<squnion> x \\<sqinter> (1::'a))\\<^sup>T =\n    x", "by (metis 2 maddux_3_11_pp regular_one_closed)"], ["proof (state)\nthis:\n  y \\<squnion> x \\<sqinter> (1::'a) \\<squnion>\n  (y \\<squnion> x \\<sqinter> (1::'a))\\<^sup>T =\n  x\n\ngoal (1 subgoal):\n 1. antisymmetric (y \\<squnion> x \\<sqinter> (1::'a))", "have \"?y \\<sqinter> ?y\\<^sup>T = (y \\<sqinter> y\\<^sup>T) \\<squnion> (x \\<sqinter> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<squnion> x \\<sqinter> (1::'a)) \\<sqinter>\n    (y \\<squnion> x \\<sqinter> (1::'a))\\<^sup>T =\n    y \\<sqinter> y\\<^sup>T \\<squnion> x \\<sqinter> (1::'a)", "by (simp add: 1 conv_dist_sup sup_inf_distrib2 symmetric_inf_closed)"], ["proof (state)\nthis:\n  (y \\<squnion> x \\<sqinter> (1::'a)) \\<sqinter>\n  (y \\<squnion> x \\<sqinter> (1::'a))\\<^sup>T =\n  y \\<sqinter> y\\<^sup>T \\<squnion> x \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. antisymmetric (y \\<squnion> x \\<sqinter> (1::'a))", "thus \"antisymmetric ?y\""], ["proof (prove)\nusing this:\n  (y \\<squnion> x \\<sqinter> (1::'a)) \\<sqinter>\n  (y \\<squnion> x \\<sqinter> (1::'a))\\<^sup>T =\n  y \\<sqinter> y\\<^sup>T \\<squnion> x \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. antisymmetric (y \\<squnion> x \\<sqinter> (1::'a))", "by (simp add: 2)"], ["proof (state)\nthis:\n  antisymmetric (y \\<squnion> x \\<sqinter> (1::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  loop_orientation x (y \\<squnion> x \\<sqinter> (1::'a))\n\ngoal (1 subgoal):\n 1. symmetric x \\<Longrightarrow> loop_orientable x", "thus \"loop_orientable x\""], ["proof (prove)\nusing this:\n  loop_orientation x (y \\<squnion> x \\<sqinter> (1::'a))\n\ngoal (1 subgoal):\n 1. loop_orientable x", "using loop_orientable_def"], ["proof (prove)\nusing this:\n  loop_orientation x (y \\<squnion> x \\<sqinter> (1::'a))\n  loop_orientable ?x \\<equiv> \\<exists>y. loop_orientation ?x y\n\ngoal (1 subgoal):\n 1. loop_orientable x", "by blast"], ["proof (state)\nthis:\n  loop_orientable x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orientable_4_implies_1:\n  assumes \"orientable_4 (x \\<sqinter> -1)\"\n  shows \"orientable_1 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orientable_1 x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. orientable_1 x", "obtain y where 1: \"x \\<sqinter> -1 \\<le> y \\<squnion> y\\<^sup>T \\<and> asymmetric y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        super_orientation (x \\<sqinter> - (1::'a)) y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms pseudo_complement super_orientable_def"], ["proof (prove)\nusing this:\n  orientable_4 (x \\<sqinter> - (1::'a))\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n  super_orientable ?x \\<equiv> \\<exists>y. super_orientation ?x y\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        super_orientation (x \\<sqinter> - (1::'a)) y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  super_orientation (x \\<sqinter> - (1::'a)) y\n\ngoal (1 subgoal):\n 1. orientable_1 x", "let ?y = \"y \\<squnion> 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. orientable_1 x", "have \"loop_super_orientation x ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loop_super_orientation x (y \\<squnion> (1::'a))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<le> y \\<squnion> (1::'a) \\<squnion> (y \\<squnion> (1::'a))\\<^sup>T\n 2. antisymmetric (y \\<squnion> (1::'a))", "show \"x \\<le> ?y \\<squnion> ?y\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<squnion> (1::'a) \\<squnion> (y \\<squnion> (1::'a))\\<^sup>T", "by (smt 1 comp_inf.semiring.add_mono conv_dist_sup inf_le2 maddux_3_11_pp reflexive_one_closed regular_one_closed sup.absorb1 sup.left_commute sup_assoc symmetric_one_closed)"], ["proof (state)\nthis:\n  x \\<le> y \\<squnion> (1::'a) \\<squnion> (y \\<squnion> (1::'a))\\<^sup>T\n\ngoal (1 subgoal):\n 1. antisymmetric (y \\<squnion> (1::'a))", "show \"antisymmetric ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antisymmetric (y \\<squnion> (1::'a))", "using 1 conv_dist_sup distrib_imp1 inf_sup_distrib1 sup_monoid.add_commute"], ["proof (prove)\nusing this:\n  super_orientation (x \\<sqinter> - (1::'a)) y\n  (?x \\<squnion> ?y)\\<^sup>T = ?x\\<^sup>T \\<squnion> ?y\\<^sup>T\n  (\\<And>x y z.\n      x \\<sqinter> (y \\<squnion> z) =\n      x \\<sqinter> y \\<squnion> x \\<sqinter> z) \\<Longrightarrow>\n  ?x \\<squnion> ?y \\<sqinter> ?z =\n  (?x \\<squnion> ?y) \\<sqinter> (?x \\<squnion> ?z)\n  ?x \\<sqinter> (?y \\<squnion> ?z) =\n  ?x \\<sqinter> ?y \\<squnion> ?x \\<sqinter> ?z\n  ?a \\<squnion> ?b = ?b \\<squnion> ?a\n\ngoal (1 subgoal):\n 1. antisymmetric (y \\<squnion> (1::'a))", "by auto"], ["proof (state)\nthis:\n  antisymmetric (y \\<squnion> (1::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  loop_super_orientation x (y \\<squnion> (1::'a))\n\ngoal (1 subgoal):\n 1. orientable_1 x", "thus ?thesis"], ["proof (prove)\nusing this:\n  loop_super_orientation x (y \\<squnion> (1::'a))\n\ngoal (1 subgoal):\n 1. orientable_1 x", "using loop_super_orientable_def"], ["proof (prove)\nusing this:\n  loop_super_orientation x (y \\<squnion> (1::'a))\n  orientable_1 ?x \\<equiv> \\<exists>y. loop_super_orientation ?x y\n\ngoal (1 subgoal):\n 1. orientable_1 x", "by blast"], ["proof (state)\nthis:\n  orientable_1 x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orientable_1_implies_4:\n  assumes \"orientable_1 (x \\<squnion> 1)\"\n  shows \"orientable_4 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orientable_4 x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. irreflexive_inf x \\<Longrightarrow> super_orientable x", "assume 1: \"irreflexive_inf x\""], ["proof (state)\nthis:\n  irreflexive_inf x\n\ngoal (1 subgoal):\n 1. irreflexive_inf x \\<Longrightarrow> super_orientable x", "obtain y where 2: \"x \\<squnion> 1 \\<le> y \\<squnion> y\\<^sup>T \\<and> antisymmetric y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        loop_super_orientation (x \\<squnion> (1::'a)) y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms loop_super_orientable_def"], ["proof (prove)\nusing this:\n  orientable_1 (x \\<squnion> (1::'a))\n  orientable_1 ?x \\<equiv> \\<exists>y. loop_super_orientation ?x y\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        loop_super_orientation (x \\<squnion> (1::'a)) y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  loop_super_orientation (x \\<squnion> (1::'a)) y\n\ngoal (1 subgoal):\n 1. irreflexive_inf x \\<Longrightarrow> super_orientable x", "let ?y = \"y \\<sqinter> -1\""], ["proof (state)\ngoal (1 subgoal):\n 1. irreflexive_inf x \\<Longrightarrow> super_orientable x", "have \"super_orientation x ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. super_orientation x (y \\<sqinter> - (1::'a))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<le> y \\<sqinter> - (1::'a) \\<squnion>\n            (y \\<sqinter> - (1::'a))\\<^sup>T\n 2. asymmetric (y \\<sqinter> - (1::'a))", "have \"x \\<le> (y \\<squnion> y\\<^sup>T) \\<sqinter> -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> (y \\<squnion> y\\<^sup>T) \\<sqinter> - (1::'a)", "using 1 2 pseudo_complement"], ["proof (prove)\nusing this:\n  irreflexive_inf x\n  loop_super_orientation (x \\<squnion> (1::'a)) y\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. x \\<le> (y \\<squnion> y\\<^sup>T) \\<sqinter> - (1::'a)", "by auto"], ["proof (state)\nthis:\n  x \\<le> (y \\<squnion> y\\<^sup>T) \\<sqinter> - (1::'a)\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<sqinter> - (1::'a) \\<squnion>\n            (y \\<sqinter> - (1::'a))\\<^sup>T\n 2. asymmetric (y \\<sqinter> - (1::'a))", "thus \"x \\<le> ?y \\<squnion> ?y\\<^sup>T\""], ["proof (prove)\nusing this:\n  x \\<le> (y \\<squnion> y\\<^sup>T) \\<sqinter> - (1::'a)\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<sqinter> - (1::'a) \\<squnion>\n            (y \\<sqinter> - (1::'a))\\<^sup>T", "by (simp add: conv_complement conv_dist_inf inf_sup_distrib2)"], ["proof (state)\nthis:\n  x \\<le> y \\<sqinter> - (1::'a) \\<squnion> (y \\<sqinter> - (1::'a))\\<^sup>T\n\ngoal (1 subgoal):\n 1. asymmetric (y \\<sqinter> - (1::'a))", "have \"?y \\<sqinter> ?y\\<^sup>T = y \\<sqinter> y\\<^sup>T \\<sqinter> -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sqinter> - (1::'a) \\<sqinter> (y \\<sqinter> - (1::'a))\\<^sup>T =\n    y \\<sqinter> y\\<^sup>T \\<sqinter> - (1::'a)", "using conv_complement conv_dist_inf inf_commute inf_left_commute"], ["proof (prove)\nusing this:\n  (- ?x)\\<^sup>T = - ?x\\<^sup>T\n  (?x \\<sqinter> ?y)\\<^sup>T = ?x\\<^sup>T \\<sqinter> ?y\\<^sup>T\n  ?x \\<sqinter> ?y = ?y \\<sqinter> ?x\n  ?x \\<sqinter> (?y \\<sqinter> ?z) = ?y \\<sqinter> (?x \\<sqinter> ?z)\n\ngoal (1 subgoal):\n 1. y \\<sqinter> - (1::'a) \\<sqinter> (y \\<sqinter> - (1::'a))\\<^sup>T =\n    y \\<sqinter> y\\<^sup>T \\<sqinter> - (1::'a)", "by auto"], ["proof (state)\nthis:\n  y \\<sqinter> - (1::'a) \\<sqinter> (y \\<sqinter> - (1::'a))\\<^sup>T =\n  y \\<sqinter> y\\<^sup>T \\<sqinter> - (1::'a)\n\ngoal (1 subgoal):\n 1. asymmetric (y \\<sqinter> - (1::'a))", "thus \"asymmetric ?y\""], ["proof (prove)\nusing this:\n  y \\<sqinter> - (1::'a) \\<sqinter> (y \\<sqinter> - (1::'a))\\<^sup>T =\n  y \\<sqinter> y\\<^sup>T \\<sqinter> - (1::'a)\n\ngoal (1 subgoal):\n 1. asymmetric (y \\<sqinter> - (1::'a))", "using 2 pseudo_complement"], ["proof (prove)\nusing this:\n  y \\<sqinter> - (1::'a) \\<sqinter> (y \\<sqinter> - (1::'a))\\<^sup>T =\n  y \\<sqinter> y\\<^sup>T \\<sqinter> - (1::'a)\n  loop_super_orientation (x \\<squnion> (1::'a)) y\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. asymmetric (y \\<sqinter> - (1::'a))", "by auto"], ["proof (state)\nthis:\n  asymmetric (y \\<sqinter> - (1::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  super_orientation x (y \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. irreflexive_inf x \\<Longrightarrow> super_orientable x", "thus \"super_orientable x\""], ["proof (prove)\nusing this:\n  super_orientation x (y \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. super_orientable x", "using super_orientable_def"], ["proof (prove)\nusing this:\n  super_orientation x (y \\<sqinter> - (1::'a))\n  super_orientable ?x \\<equiv> \\<exists>y. super_orientation ?x y\n\ngoal (1 subgoal):\n 1. super_orientable x", "by blast"], ["proof (state)\nthis:\n  super_orientable x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma orientable_1_implies_5:\n  assumes \"orientable_1 x\"\n  shows \"orientable_5 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orientable_5 x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. symmetric x \\<Longrightarrow> loop_orientable x", "assume 1: \"symmetric x\""], ["proof (state)\nthis:\n  symmetric x\n\ngoal (1 subgoal):\n 1. symmetric x \\<Longrightarrow> loop_orientable x", "obtain y where 2: \"x \\<le> y \\<squnion> y\\<^sup>T \\<and> antisymmetric y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        loop_super_orientation x y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms loop_super_orientable_def"], ["proof (prove)\nusing this:\n  orientable_1 x\n  orientable_1 ?x \\<equiv> \\<exists>y. loop_super_orientation ?x y\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        loop_super_orientation x y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  loop_super_orientation x y\n\ngoal (1 subgoal):\n 1. symmetric x \\<Longrightarrow> loop_orientable x", "let ?y = \"(x \\<sqinter> 1) \\<squnion> (y \\<sqinter> x \\<sqinter> -1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. symmetric x \\<Longrightarrow> loop_orientable x", "have \"loop_orientation x ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loop_orientation x\n     (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> x \\<sqinter> - (1::'a))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<sqinter> (1::'a) \\<squnion>\n    y \\<sqinter> x \\<sqinter> - (1::'a) \\<squnion>\n    (x \\<sqinter> (1::'a) \\<squnion>\n     y \\<sqinter> x \\<sqinter> - (1::'a))\\<^sup>T =\n    x\n 2. antisymmetric\n     (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> x \\<sqinter> - (1::'a))", "have \"?y \\<squnion> ?y\\<^sup>T = ((y \\<squnion> y\\<^sup>T) \\<sqinter> x \\<sqinter> -1) \\<squnion> (x \\<sqinter> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> (1::'a) \\<squnion>\n    y \\<sqinter> x \\<sqinter> - (1::'a) \\<squnion>\n    (x \\<sqinter> (1::'a) \\<squnion>\n     y \\<sqinter> x \\<sqinter> - (1::'a))\\<^sup>T =\n    (y \\<squnion> y\\<^sup>T) \\<sqinter> x \\<sqinter> - (1::'a) \\<squnion>\n    x \\<sqinter> (1::'a)", "by (simp add: 1 conv_complement conv_dist_inf conv_dist_sup inf_sup_distrib2 sup.left_commute sup_commute)"], ["proof (state)\nthis:\n  x \\<sqinter> (1::'a) \\<squnion>\n  y \\<sqinter> x \\<sqinter> - (1::'a) \\<squnion>\n  (x \\<sqinter> (1::'a) \\<squnion>\n   y \\<sqinter> x \\<sqinter> - (1::'a))\\<^sup>T =\n  (y \\<squnion> y\\<^sup>T) \\<sqinter> x \\<sqinter> - (1::'a) \\<squnion>\n  x \\<sqinter> (1::'a)\n\ngoal (2 subgoals):\n 1. x \\<sqinter> (1::'a) \\<squnion>\n    y \\<sqinter> x \\<sqinter> - (1::'a) \\<squnion>\n    (x \\<sqinter> (1::'a) \\<squnion>\n     y \\<sqinter> x \\<sqinter> - (1::'a))\\<^sup>T =\n    x\n 2. antisymmetric\n     (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> x \\<sqinter> - (1::'a))", "thus \"?y \\<squnion> ?y\\<^sup>T = x\""], ["proof (prove)\nusing this:\n  x \\<sqinter> (1::'a) \\<squnion>\n  y \\<sqinter> x \\<sqinter> - (1::'a) \\<squnion>\n  (x \\<sqinter> (1::'a) \\<squnion>\n   y \\<sqinter> x \\<sqinter> - (1::'a))\\<^sup>T =\n  (y \\<squnion> y\\<^sup>T) \\<sqinter> x \\<sqinter> - (1::'a) \\<squnion>\n  x \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. x \\<sqinter> (1::'a) \\<squnion>\n    y \\<sqinter> x \\<sqinter> - (1::'a) \\<squnion>\n    (x \\<sqinter> (1::'a) \\<squnion>\n     y \\<sqinter> x \\<sqinter> - (1::'a))\\<^sup>T =\n    x", "by (metis 2 inf_absorb2 maddux_3_11_pp regular_one_closed)"], ["proof (state)\nthis:\n  x \\<sqinter> (1::'a) \\<squnion>\n  y \\<sqinter> x \\<sqinter> - (1::'a) \\<squnion>\n  (x \\<sqinter> (1::'a) \\<squnion>\n   y \\<sqinter> x \\<sqinter> - (1::'a))\\<^sup>T =\n  x\n\ngoal (1 subgoal):\n 1. antisymmetric\n     (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> x \\<sqinter> - (1::'a))", "have \"?y \\<sqinter> ?y\\<^sup>T = (x \\<sqinter> 1) \\<squnion> ((y \\<sqinter> x \\<sqinter> -1) \\<sqinter> (y\\<^sup>T \\<sqinter> x\\<^sup>T \\<sqinter> -1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> (1::'a) \\<squnion>\n     y \\<sqinter> x \\<sqinter> - (1::'a)) \\<sqinter>\n    (x \\<sqinter> (1::'a) \\<squnion>\n     y \\<sqinter> x \\<sqinter> - (1::'a))\\<^sup>T =\n    x \\<sqinter> (1::'a) \\<squnion>\n    y \\<sqinter> x \\<sqinter> - (1::'a) \\<sqinter>\n    (y\\<^sup>T \\<sqinter> x\\<^sup>T \\<sqinter> - (1::'a))", "by (simp add: 1 conv_complement conv_dist_inf conv_dist_sup sup_inf_distrib1)"], ["proof (state)\nthis:\n  (x \\<sqinter> (1::'a) \\<squnion>\n   y \\<sqinter> x \\<sqinter> - (1::'a)) \\<sqinter>\n  (x \\<sqinter> (1::'a) \\<squnion>\n   y \\<sqinter> x \\<sqinter> - (1::'a))\\<^sup>T =\n  x \\<sqinter> (1::'a) \\<squnion>\n  y \\<sqinter> x \\<sqinter> - (1::'a) \\<sqinter>\n  (y\\<^sup>T \\<sqinter> x\\<^sup>T \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. antisymmetric\n     (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> x \\<sqinter> - (1::'a))", "thus \"antisymmetric ?y\""], ["proof (prove)\nusing this:\n  (x \\<sqinter> (1::'a) \\<squnion>\n   y \\<sqinter> x \\<sqinter> - (1::'a)) \\<sqinter>\n  (x \\<sqinter> (1::'a) \\<squnion>\n   y \\<sqinter> x \\<sqinter> - (1::'a))\\<^sup>T =\n  x \\<sqinter> (1::'a) \\<squnion>\n  y \\<sqinter> x \\<sqinter> - (1::'a) \\<sqinter>\n  (y\\<^sup>T \\<sqinter> x\\<^sup>T \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. antisymmetric\n     (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> x \\<sqinter> - (1::'a))", "by (metis 2 antisymmetric_inf_closed conv_complement conv_dist_inf inf_le2 le_supI symmetric_one_closed)"], ["proof (state)\nthis:\n  antisymmetric\n   (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> x \\<sqinter> - (1::'a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  loop_orientation x\n   (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> x \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. symmetric x \\<Longrightarrow> loop_orientable x", "thus \"loop_orientable x\""], ["proof (prove)\nusing this:\n  loop_orientation x\n   (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> x \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. loop_orientable x", "using loop_orientable_def"], ["proof (prove)\nusing this:\n  loop_orientation x\n   (x \\<sqinter> (1::'a) \\<squnion> y \\<sqinter> x \\<sqinter> - (1::'a))\n  loop_orientable ?x \\<equiv> \\<exists>y. loop_orientation ?x y\n\ngoal (1 subgoal):\n 1. loop_orientable x", "by blast"], ["proof (state)\nthis:\n  loop_orientable x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 2\\<close>"], ["", "lemma all_orientable_characterisations:\n  shows \"(\\<forall>x . orientable_1 x) \\<longleftrightarrow> (\\<forall>x . orientable_2 x)\"\n    and \"(\\<forall>x . orientable_1 x) \\<longleftrightarrow> (\\<forall>x . orientable_3 x)\"\n    and \"(\\<forall>x . orientable_1 x) \\<longleftrightarrow> (\\<forall>x . orientable_4 x)\"\n    and \"(\\<forall>x . orientable_1 x) \\<longleftrightarrow> (\\<forall>x . orientable_5 x)\"\n    and \"(\\<forall>x . orientable_1 x) \\<longleftrightarrow> (\\<forall>x . orientable_6 x)\"\n    and \"(\\<forall>x . orientable_1 x) \\<longleftrightarrow> (\\<forall>x . orientable_7 x)\"\n    and \"(\\<forall>x . orientable_1 x) \\<longleftrightarrow> (\\<forall>x . orientable_8 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_2 x) &&&\n     (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_3 x) &&&\n     (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_4 x)) &&&\n    ((\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_5 x) &&&\n     (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_6 x)) &&&\n    (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_7 x) &&&\n    (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_8 x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_2 x)", "using orientable_1_2"], ["proof (prove)\nusing this:\n  orientable_1 ?x = orientable_2 ?x\n\ngoal (1 subgoal):\n 1. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_2 x)", "by simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_3 x)\n 2. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_4 x)\n 3. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_5 x)\n 4. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_6 x)\n 5. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_7 x)\n 6. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_8 x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_3 x)", "using orientable_1_2 orientable_2_3"], ["proof (prove)\nusing this:\n  orientable_1 ?x = orientable_2 ?x\n  orientable_2 ?x = orientable_3 ?x\n\ngoal (1 subgoal):\n 1. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_3 x)", "by simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_4 x)\n 2. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_5 x)\n 3. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_6 x)\n 4. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_7 x)\n 5. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_8 x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_4 x)", "using orientable_1_implies_4 orientable_4_implies_1"], ["proof (prove)\nusing this:\n  orientable_1 (?x \\<squnion> (1::'a)) \\<Longrightarrow> orientable_4 ?x\n  orientable_4 (?x \\<sqinter> - (1::'a)) \\<Longrightarrow> orientable_1 ?x\n\ngoal (1 subgoal):\n 1. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_4 x)", "by blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_5 x)\n 2. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_6 x)\n 3. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_7 x)\n 4. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_8 x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_5 x)", "using orientable_5_implies_1 orientable_1_implies_5"], ["proof (prove)\nusing this:\n  orientable_5 (?x \\<squnion> ?x\\<^sup>T) \\<Longrightarrow> orientable_1 ?x\n  orientable_1 ?x \\<Longrightarrow> orientable_5 ?x\n\ngoal (1 subgoal):\n 1. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_5 x)", "by blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_6 x)\n 2. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_7 x)\n 3. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_8 x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_6 x)", "using orientable_5_6 orientable_5_implies_1 orientable_1_implies_5"], ["proof (prove)\nusing this:\n  orientable_5 ?x = orientable_6 ?x\n  orientable_5 (?x \\<squnion> ?x\\<^sup>T) \\<Longrightarrow> orientable_1 ?x\n  orientable_1 ?x \\<Longrightarrow> orientable_5 ?x\n\ngoal (1 subgoal):\n 1. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_6 x)", "by blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_7 x)\n 2. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_8 x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_7 x)", "using orientable_5_6 orientable_5_implies_1 orientable_6_7 orientable_1_implies_5"], ["proof (prove)\nusing this:\n  orientable_5 ?x = orientable_6 ?x\n  orientable_5 (?x \\<squnion> ?x\\<^sup>T) \\<Longrightarrow> orientable_1 ?x\n  orientable_6 ?x = orientable_7 ?x\n  orientable_1 ?x \\<Longrightarrow> orientable_5 ?x\n\ngoal (1 subgoal):\n 1. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_7 x)", "by force"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_8 x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_8 x)", "using orientable_5_6 orientable_5_implies_1 orientable_6_7 orientable_7_implies_8 orientable_1_implies_5 orientable_8_implies_5"], ["proof (prove)\nusing this:\n  orientable_5 ?x = orientable_6 ?x\n  orientable_5 (?x \\<squnion> ?x\\<^sup>T) \\<Longrightarrow> orientable_1 ?x\n  orientable_6 ?x = orientable_7 ?x\n  orientable_7 ?x \\<Longrightarrow> orientable_8 ?x\n  orientable_1 ?x \\<Longrightarrow> orientable_5 ?x\n  orientable_8 (?x \\<sqinter> - (1::'a)) \\<Longrightarrow> orientable_5 ?x\n\ngoal (1 subgoal):\n 1. (\\<forall>x. orientable_1 x) = (\\<forall>x. orientable_8 x)", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma orientable_12_implies_11:\n  \"orientable_12 x \\<Longrightarrow> orientable_11 (x \\<squnion> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. asymmetric x \\<and> strict_linear x \\<Longrightarrow>\n    (x \\<squnion> (1::'a)) \\<sqinter> (x \\<squnion> (1::'a))\\<^sup>T =\n    (1::'a) \\<and>\n    linear (x \\<squnion> (1::'a))", "by (smt inf_top.right_neutral conv_complement conv_dist_sup conv_involutive inf_import_p maddux_3_13 p_bot p_dist_inf p_dist_sup regular_one_closed symmetric_one_closed)"], ["", "(* The following lemma might go into Relation_Algebras. *)"], ["", "lemma linear_strict_order_order:\n  \"linear_strict_order x \\<Longrightarrow> linear_order (x \\<squnion> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_orderable_2 x \\<Longrightarrow>\n    linear_orderable_1 (x \\<squnion> (1::'a))", "by (simp add: strict_order_order transitive_asymmetric_irreflexive orientable_12_implies_11)"], ["", "lemma linear_orderable_2_implies_1:\n  \"linear_orderable_2 x \\<Longrightarrow> linear_orderable_1 (x \\<squnion> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_orderable_2 x \\<Longrightarrow>\n    linear_orderable_1 (x \\<squnion> (1::'a))", "using linear_strict_order_order"], ["proof (prove)\nusing this:\n  linear_orderable_2 ?x \\<Longrightarrow>\n  linear_orderable_1 (?x \\<squnion> (1::'a))\n\ngoal (1 subgoal):\n 1. linear_orderable_2 x \\<Longrightarrow>\n    linear_orderable_1 (x \\<squnion> (1::'a))", "by simp"], ["", "text \\<open>Theorem 4\\<close>"], ["", "text \\<open>Theorem 12\\<close>"], ["", "text \\<open>Theorem 13\\<close>"], ["", "lemma exists_split_characterisations:\n  shows \"(\\<exists>x . linear_orderable_1 x) \\<longleftrightarrow> (\\<exists>x . linear_orderable_2 x)\"\n  and \"(\\<exists>x . linear_orderable_1 x) \\<longleftrightarrow> (\\<exists>x . linear_orderable_3 x)\"\n  and \"(\\<exists>x . linear_orderable_1 x) \\<longleftrightarrow> (\\<exists>x . linear_orderable_3a x)\"\n  and \"(\\<exists>x . linear_orderable_1 x) \\<longleftrightarrow> transitively_orientable (-1)\"\n  and \"(\\<exists>x . linear_orderable_1 x) \\<Longrightarrow> (\\<exists>x . orientable_11 x)\"\n  and \"(\\<exists>x . orientable_11 x) \\<longleftrightarrow> (\\<exists>x . orientable_12 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>x. linear_orderable_1 x) =\n     (\\<exists>x. linear_orderable_2 x) &&&\n     (\\<exists>x. linear_orderable_1 x) =\n     (\\<exists>x. linear_orderable_3 x) &&&\n     (\\<exists>x. linear_orderable_1 x) =\n     (\\<exists>x. linear_orderable_3a x)) &&&\n    (\\<exists>x. linear_orderable_1 x) =\n    transitively_orientable (- (1::'a)) &&&\n    (\\<exists>x. linear_orderable_1 x \\<Longrightarrow>\n     \\<exists>x. x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x) &&&\n    (\\<exists>x. x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x) =\n    (\\<exists>x. asymmetric x \\<and> strict_linear x)", "subgoal 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. linear_orderable_1 x) = (\\<exists>x. linear_orderable_2 x)", "using linear_strict_order_order linear_order_strict_order"], ["proof (prove)\nusing this:\n  linear_orderable_2 ?x \\<Longrightarrow>\n  linear_orderable_1 (?x \\<squnion> (1::'a))\n  linear_orderable_1 ?x \\<Longrightarrow>\n  linear_orderable_2 (?x \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. linear_orderable_1 x) = (\\<exists>x. linear_orderable_2 x)", "by blast"], ["proof (prove)\ngoal (5 subgoals):\n 1. (\\<exists>x. linear_orderable_1 x) = (\\<exists>x. linear_orderable_3 x)\n 2. (\\<exists>x. linear_orderable_1 x) = (\\<exists>x. linear_orderable_3a x)\n 3. (\\<exists>x. linear_orderable_1 x) = transitively_orientable (- (1::'a))\n 4. \\<exists>x. linear_orderable_1 x \\<Longrightarrow>\n    \\<exists>x. x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x\n 5. (\\<exists>x. x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x) =\n    (\\<exists>x. asymmetric x \\<and> strict_linear x)", "subgoal 2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. linear_orderable_1 x) = (\\<exists>x. linear_orderable_3 x)", "using 1 strict_order_var"], ["proof (prove)\nusing this:\n  (\\<exists>x. linear_orderable_1 x) = (\\<exists>x. linear_orderable_2 x)\n  strict_order ?x = (asymmetric ?x \\<and> transitive ?x)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. linear_orderable_1 x) = (\\<exists>x. linear_orderable_3 x)", "by blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. (\\<exists>x. linear_orderable_1 x) = (\\<exists>x. linear_orderable_3a x)\n 2. (\\<exists>x. linear_orderable_1 x) = transitively_orientable (- (1::'a))\n 3. \\<exists>x. linear_orderable_1 x \\<Longrightarrow>\n    \\<exists>x. x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x\n 4. (\\<exists>x. x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x) =\n    (\\<exists>x. asymmetric x \\<and> strict_linear x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. linear_orderable_1 x) = (\\<exists>x. linear_orderable_3a x)", "using 1 linear_strict_order_without_irreflexive"], ["proof (prove)\nusing this:\n  (\\<exists>x. linear_orderable_1 x) = (\\<exists>x. linear_orderable_2 x)\n  linear_orderable_2 ?x = linear_orderable_3a ?x\n\ngoal (1 subgoal):\n 1. (\\<exists>x. linear_orderable_1 x) = (\\<exists>x. linear_orderable_3a x)", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<exists>x. linear_orderable_1 x) = transitively_orientable (- (1::'a))\n 2. \\<exists>x. linear_orderable_1 x \\<Longrightarrow>\n    \\<exists>x. x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x\n 3. (\\<exists>x. x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x) =\n    (\\<exists>x. asymmetric x \\<and> strict_linear x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. linear_orderable_1 x) = transitively_orientable (- (1::'a))", "using 2 transitively_orientable_def"], ["proof (prove)\nusing this:\n  (\\<exists>x. linear_orderable_1 x) = (\\<exists>x. linear_orderable_3 x)\n  transitively_orientable ?x \\<equiv>\n  \\<exists>y. orientation ?x y \\<and> transitive y\n\ngoal (1 subgoal):\n 1. (\\<exists>x. linear_orderable_1 x) = transitively_orientable (- (1::'a))", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>x. linear_orderable_1 x \\<Longrightarrow>\n    \\<exists>x. x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x\n 2. (\\<exists>x. x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x) =\n    (\\<exists>x. asymmetric x \\<and> strict_linear x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. linear_orderable_1 x \\<Longrightarrow>\n    \\<exists>x. x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x", "using loop_orientation_top_split"], ["proof (prove)\nusing this:\n  (linear ?y \\<and> antisymmetric ?y) =\n  (?y \\<sqinter> ?y\\<^sup>T = (1::'a) \\<and> linear ?y)\n\ngoal (1 subgoal):\n 1. \\<exists>x. linear_orderable_1 x \\<Longrightarrow>\n    \\<exists>x. x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x) =\n    (\\<exists>x. asymmetric x \\<and> strict_linear x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x) =\n    (\\<exists>x. asymmetric x \\<and> strict_linear x)", "using orientable_11_implies_12 orientable_12_implies_11"], ["proof (prove)\nusing this:\n  ?x \\<sqinter> ?x\\<^sup>T = (1::'a) \\<and> linear ?x \\<Longrightarrow>\n  asymmetric (?x \\<sqinter> - (1::'a)) \\<and>\n  strict_linear (?x \\<sqinter> - (1::'a))\n  asymmetric ?x \\<and> strict_linear ?x \\<Longrightarrow>\n  (?x \\<squnion> (1::'a)) \\<sqinter> (?x \\<squnion> (1::'a))\\<^sup>T =\n  (1::'a) \\<and>\n  linear (?x \\<squnion> (1::'a))\n\ngoal (1 subgoal):\n 1. (\\<exists>x. x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x) =\n    (\\<exists>x. asymmetric x \\<and> strict_linear x)", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Theorem 4\\<close>"], ["", "text \\<open>Theorem 12\\<close>"], ["", "lemma exists_all_orientable:\n  shows \"(\\<exists>x . orientable_11 x) \\<longleftrightarrow> (\\<forall>x . orientable_1 x)\"\n    and \"transitively_orientable (-1) \\<Longrightarrow> (\\<forall>x . orientable_8 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x) =\n    (\\<forall>x. orientable_1 x) &&&\n    (transitively_orientable (- (1::'a)) \\<Longrightarrow>\n     \\<forall>x. orientable_8 x)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x) =\n    (\\<forall>x. orientable_1 x)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<exists>x.\n       x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x \\<Longrightarrow>\n    \\<forall>x. orientable_1 x\n 2. \\<forall>x. orientable_1 x \\<Longrightarrow>\n    \\<exists>x. x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x \\<Longrightarrow>\n    \\<forall>x. orientable_1 x", "using loop_super_orientable_def top_greatest"], ["proof (prove)\nusing this:\n  orientable_1 ?x \\<equiv> \\<exists>y. loop_super_orientation ?x y\n  ?x \\<le> top\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x \\<Longrightarrow>\n    \\<forall>x. orientable_1 x", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. orientable_1 x \\<Longrightarrow>\n    \\<exists>x. x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. orientable_1 x \\<Longrightarrow>\n    \\<exists>x. x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x", "using loop_orientation_top_split loop_super_orientable_def top_le"], ["proof (prove)\nusing this:\n  (linear ?y \\<and> antisymmetric ?y) =\n  (?y \\<sqinter> ?y\\<^sup>T = (1::'a) \\<and> linear ?y)\n  orientable_1 ?x \\<equiv> \\<exists>y. loop_super_orientation ?x y\n  top \\<le> ?a \\<Longrightarrow> ?a = top\n\ngoal (1 subgoal):\n 1. \\<forall>x. orientable_1 x \\<Longrightarrow>\n    \\<exists>x. x \\<sqinter> x\\<^sup>T = (1::'a) \\<and> linear x", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. transitively_orientable (- (1::'a)) \\<Longrightarrow>\n    \\<forall>x. orientable_8 x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. transitively_orientable (- (1::'a)) \\<Longrightarrow>\n    \\<forall>x. orientable_8 x", "using orientable_down_closed pseudo_complement transitively_orientable_orientable"], ["proof (prove)\nusing this:\n  \\<lbrakk>symmetric ?x; ?x \\<le> ?y; orientable ?y\\<rbrakk>\n  \\<Longrightarrow> orientable ?x\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n  transitively_orientable ?x \\<Longrightarrow> orientable ?x\n\ngoal (1 subgoal):\n 1. transitively_orientable (- (1::'a)) \\<Longrightarrow>\n    \\<forall>x. orientable_8 x", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \\<open>Undirected forests\\<close>"], ["", "text \\<open>\nWe start with a few general results in Kleene algebras and a few basic properties of directed acyclic graphs.\n\\<close>"], ["", "(* move to Kleene_Algebras *)"], ["", "context kleene_algebra\nbegin"], ["", "text \\<open>Theorem 1.9\\<close>"], ["", "lemma plus_separate_comp_bot:\n  assumes \"x * y = bot\"\n  shows \"(x \\<squnion> y)\\<^sup>+ = x\\<^sup>+ \\<squnion> y\\<^sup>+ \\<squnion> y\\<^sup>+ * x\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>+ =\n    x\\<^sup>+ \\<squnion> y\\<^sup>+ \\<squnion> y\\<^sup>+ * x\\<^sup>+", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>+ =\n    x\\<^sup>+ \\<squnion> y\\<^sup>+ \\<squnion> y\\<^sup>+ * x\\<^sup>+", "have \"(x \\<squnion> y)\\<^sup>+ = x * y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<squnion> y\\<^sup>+ * x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>+ =\n    x * y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<squnion>\n    y\\<^sup>+ * x\\<^sup>\\<star>", "using assms cancel_separate_1 semiring.distrib_right mult_assoc"], ["proof (prove)\nusing this:\n  x * y = bot\n  coreflexive (?x * ?y) \\<Longrightarrow>\n  (?x \\<squnion> ?y)\\<^sup>\\<star> = ?y\\<^sup>\\<star> * ?x\\<^sup>\\<star>\n  (?a \\<squnion> ?b) * ?c = ?a * ?c \\<squnion> ?b * ?c\n  ?a * ?b * ?c = ?a * (?b * ?c)\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>+ =\n    x * y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<squnion>\n    y\\<^sup>+ * x\\<^sup>\\<star>", "by auto"], ["proof (state)\nthis:\n  (x \\<squnion> y)\\<^sup>+ =\n  x * y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<squnion>\n  y\\<^sup>+ * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>+ =\n    x\\<^sup>+ \\<squnion> y\\<^sup>+ \\<squnion> y\\<^sup>+ * x\\<^sup>+", "also"], ["proof (state)\nthis:\n  (x \\<squnion> y)\\<^sup>+ =\n  x * y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<squnion>\n  y\\<^sup>+ * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>+ =\n    x\\<^sup>+ \\<squnion> y\\<^sup>+ \\<squnion> y\\<^sup>+ * x\\<^sup>+", "have \"... = x\\<^sup>+ \\<squnion> y\\<^sup>+ * x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<squnion>\n    y\\<^sup>+ * x\\<^sup>\\<star> =\n    x\\<^sup>+ \\<squnion> y\\<^sup>+ * x\\<^sup>\\<star>", "by (simp add: assms star_absorb)"], ["proof (state)\nthis:\n  x * y\\<^sup>\\<star> * x\\<^sup>\\<star> \\<squnion>\n  y\\<^sup>+ * x\\<^sup>\\<star> =\n  x\\<^sup>+ \\<squnion> y\\<^sup>+ * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>+ =\n    x\\<^sup>+ \\<squnion> y\\<^sup>+ \\<squnion> y\\<^sup>+ * x\\<^sup>+", "finally"], ["proof (chain)\npicking this:\n  (x \\<squnion> y)\\<^sup>+ =\n  x\\<^sup>+ \\<squnion> y\\<^sup>+ * x\\<^sup>\\<star>", "show ?thesis"], ["proof (prove)\nusing this:\n  (x \\<squnion> y)\\<^sup>+ =\n  x\\<^sup>+ \\<squnion> y\\<^sup>+ * x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<squnion> y)\\<^sup>+ =\n    x\\<^sup>+ \\<squnion> y\\<^sup>+ \\<squnion> y\\<^sup>+ * x\\<^sup>+", "by (metis star.circ_back_loop_fixpoint star.circ_plus_same sup_assoc sup_commute mult_assoc)"], ["proof (state)\nthis:\n  (x \\<squnion> y)\\<^sup>+ =\n  x\\<^sup>+ \\<squnion> y\\<^sup>+ \\<squnion> y\\<^sup>+ * x\\<^sup>+\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* move to Kleene_Relation_Algebras *)"], ["", "context bounded_distrib_kleene_allegory\nbegin"], ["", "lemma reflexive_inf_plus_star:\n  assumes \"reflexive x\"\n  shows \"x \\<sqinter> y\\<^sup>+ \\<le> 1 \\<longleftrightarrow> x \\<sqinter> y\\<^sup>\\<star> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive (x \\<sqinter> y\\<^sup>+) =\n    (x \\<sqinter> y\\<^sup>\\<star> = (1::'a))", "using assms reflexive_inf_star sup.absorb_iff1"], ["proof (prove)\nusing this:\n  reflexive x\n  reflexive ?y \\<Longrightarrow>\n  ?y \\<sqinter> ?x\\<^sup>\\<star> =\n  (1::'a) \\<squnion> ?y \\<sqinter> ?x\\<^sup>+\n  (?b \\<le> ?a) = (?a \\<squnion> ?b = ?a)\n\ngoal (1 subgoal):\n 1. coreflexive (x \\<sqinter> y\\<^sup>+) =\n    (x \\<sqinter> y\\<^sup>\\<star> = (1::'a))", "by auto"], ["", "end"], ["", "context pd_kleene_allegory\nbegin"], ["", "(* move to Kleene_Relation_Algebras *)"], ["", "lemma acyclic_star_inf_conv_iff:\n  assumes \"irreflexive w\"\n  shows \"acyclic w \\<longleftrightarrow> w\\<^sup>\\<star> \\<sqinter> w\\<^sup>T\\<^sup>\\<star> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pd_kleene_allegory_class.acyclic w =\n    (w\\<^sup>\\<star> \\<sqinter> w\\<^sup>T\\<^sup>\\<star> = (1::'a))", "by (metis assms acyclic_star_below_complement_1 acyclic_star_inf_conv conv_complement conv_order equivalence_one_closed inf.absorb1 inf.left_commute pseudo_complement star.circ_increasing)"], ["", "text \\<open>Theorem 1.7\\<close>"], ["", "(* move to Kleene_Relation_Algebras *)"], ["", "lemma acyclic_irreflexive_star_antisymmetric:\n  \"acyclic x \\<longleftrightarrow> irreflexive x \\<and> antisymmetric (x\\<^sup>\\<star>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pd_kleene_allegory_class.acyclic x =\n    (irreflexive x \\<and> antisymmetric (x\\<^sup>\\<star>))", "by (metis acyclic_star_inf_conv_iff conv_star_commute dual_order.trans eq_iff reflexive_inf_closed star.circ_mult_increasing star.circ_reflexive)"], ["", "text \\<open>Theorem 1.8\\<close>"], ["", "(* move to Kleene_Relation_Algebras *)"], ["", "lemma acyclic_plus_asymmetric:\n  \"acyclic x \\<longleftrightarrow> asymmetric (x\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pd_kleene_allegory_class.acyclic x = asymmetric (x\\<^sup>+)", "using acyclic_asymmetric asymmetric_irreflexive star.circ_transitive_equal star.left_plus_circ mult_assoc"], ["proof (prove)\nusing this:\n  pd_kleene_allegory_class.acyclic ?w \\<Longrightarrow> asymmetric ?w\n  asymmetric ?x \\<Longrightarrow> irreflexive ?x\n  idempotent (?x\\<^sup>\\<star>)\n  ?x\\<^sup>+\\<^sup>\\<star> = ?x\\<^sup>\\<star>\n  ?a * ?b * ?c = ?a * (?b * ?c)\n\ngoal (1 subgoal):\n 1. pd_kleene_allegory_class.acyclic x = asymmetric (x\\<^sup>+)", "by auto"], ["", "text \\<open>Theorem 1.3\\<close>"], ["", "text \\<open>(Theorem 1.1 is \\<open>acyclic_asymmetric\\<close> in \\<open>Kleene_Relation_Algebras\\<close>)\\<close>"], ["", "lemma transitive_acyclic_irreflexive:\n  \"transitive x \\<Longrightarrow> acyclic x \\<longleftrightarrow> irreflexive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitive x \\<Longrightarrow>\n    pd_kleene_allegory_class.acyclic x = irreflexive x", "using antisym star.circ_mult_increasing star_right_induct_mult"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n  ?x \\<le> ?x\\<^sup>+\n  ?y * ?x \\<le> ?y \\<Longrightarrow> ?y * ?x\\<^sup>\\<star> \\<le> ?y\n\ngoal (1 subgoal):\n 1. transitive x \\<Longrightarrow>\n    pd_kleene_allegory_class.acyclic x = irreflexive x", "by fastforce"], ["", "lemma transitive_acyclic_asymmetric:\n  \"transitive x \\<Longrightarrow> acyclic x \\<longleftrightarrow> asymmetric x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitive x \\<Longrightarrow>\n    pd_kleene_allegory_class.acyclic x = asymmetric x", "using strict_order_var transitive_acyclic_irreflexive"], ["proof (prove)\nusing this:\n  strict_order ?x = (asymmetric ?x \\<and> transitive ?x)\n  transitive ?x \\<Longrightarrow>\n  pd_kleene_allegory_class.acyclic ?x = irreflexive ?x\n\ngoal (1 subgoal):\n 1. transitive x \\<Longrightarrow>\n    pd_kleene_allegory_class.acyclic x = asymmetric x", "by blast"], ["", "text \\<open>Theorem 1.5\\<close>"], ["", "lemma strict_order_transitive_acyclic:\n  \"strict_order x \\<longleftrightarrow> transitive x \\<and> acyclic x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_order x =\n    (transitive x \\<and> pd_kleene_allegory_class.acyclic x)", "using transitive_acyclic_irreflexive"], ["proof (prove)\nusing this:\n  transitive ?x \\<Longrightarrow>\n  pd_kleene_allegory_class.acyclic ?x = irreflexive ?x\n\ngoal (1 subgoal):\n 1. strict_order x =\n    (transitive x \\<and> pd_kleene_allegory_class.acyclic x)", "by auto"], ["", "lemma linear_strict_order_transitive_acyclic:\n  \"linear_strict_order x \\<longleftrightarrow> transitive x \\<and> acyclic x \\<and> strict_linear x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_orderable_2 x =\n    (transitive x \\<and>\n     pd_kleene_allegory_class.acyclic x \\<and> strict_linear x)", "using transitive_acyclic_irreflexive"], ["proof (prove)\nusing this:\n  transitive ?x \\<Longrightarrow>\n  pd_kleene_allegory_class.acyclic ?x = irreflexive ?x\n\ngoal (1 subgoal):\n 1. linear_orderable_2 x =\n    (transitive x \\<and>\n     pd_kleene_allegory_class.acyclic x \\<and> strict_linear x)", "by auto"], ["", "text \\<open>\nThe following are various specifications of an undirected graph being acyclic.\n\\<close>"], ["", "definition \"acyclic_1 x \\<equiv> \\<forall>y . orientation x y \\<longrightarrow> acyclic y\""], ["", "definition \"acyclic_1b x \\<equiv> \\<forall>y . orientation x y \\<longrightarrow> y\\<^sup>\\<star> \\<sqinter> y\\<^sup>T\\<^sup>\\<star> = 1\""], ["", "definition \"acyclic_2 x \\<equiv> \\<forall>y . y \\<le> x \\<and> asymmetric y \\<longrightarrow> acyclic y\""], ["", "definition \"acyclic_2a x \\<equiv> \\<forall>y . y \\<squnion> y\\<^sup>T \\<le> x \\<and> asymmetric y \\<longrightarrow> acyclic y\""], ["", "definition \"acyclic_2b x \\<equiv> \\<forall>y . y \\<squnion> y\\<^sup>T \\<le> x \\<and> asymmetric y \\<longrightarrow> y\\<^sup>\\<star> \\<sqinter> y\\<^sup>T\\<^sup>\\<star> = 1\""], ["", "definition \"acyclic_3a x \\<equiv> \\<forall>y . y \\<le> x \\<and> x \\<le> y\\<^sup>\\<star> \\<longrightarrow> y = x\""], ["", "definition \"acyclic_3b x \\<equiv> \\<forall>y . y \\<le> x \\<and> y\\<^sup>\\<star> = x\\<^sup>\\<star> \\<longrightarrow> y = x\""], ["", "definition \"acyclic_3c x \\<equiv> \\<forall>y . y \\<le> x \\<and> x \\<le> y\\<^sup>+ \\<longrightarrow> y = x\""], ["", "definition \"acyclic_3d x \\<equiv> \\<forall>y . y \\<le> x \\<and> y\\<^sup>+ = x\\<^sup>+ \\<longrightarrow> y = x\""], ["", "definition \"acyclic_4 x \\<equiv> \\<forall>y . y \\<le> x \\<longrightarrow> x \\<sqinter> y\\<^sup>\\<star> \\<le> --y\""], ["", "definition \"acyclic_4a x \\<equiv> \\<forall>y . y \\<le> x \\<longrightarrow> x \\<sqinter> y\\<^sup>\\<star> \\<le> y\""], ["", "definition \"acyclic_4b x \\<equiv> \\<forall>y . y \\<le> x \\<longrightarrow> x \\<sqinter> y\\<^sup>\\<star> = y\""], ["", "definition \"acyclic_4c x \\<equiv> \\<forall>y . y \\<le> x \\<longrightarrow> y \\<sqinter> (x \\<sqinter> -y)\\<^sup>\\<star> = bot\""], ["", "definition \"acyclic_5a x \\<equiv> \\<forall>y . y \\<le> x \\<longrightarrow> y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> -y)\\<^sup>\\<star> = 1\""], ["", "definition \"acyclic_5b x \\<equiv> \\<forall>y . y \\<le> x \\<longrightarrow> y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> -y)\\<^sup>+ \\<le> 1\""], ["", "definition \"acyclic_5c x \\<equiv> \\<forall>y . y \\<le> x \\<longrightarrow> y\\<^sup>+ \\<sqinter> (x \\<sqinter> -y)\\<^sup>\\<star> \\<le> 1\""], ["", "definition \"acyclic_5d x \\<equiv> \\<forall>y . y \\<le> x \\<longrightarrow> y\\<^sup>+ \\<sqinter> (x \\<sqinter> -y)\\<^sup>+ \\<le> 1\""], ["", "definition \"acyclic_5e x \\<equiv> \\<forall>y z . y \\<le> x \\<and> z \\<le> x \\<and> y \\<sqinter> z = bot \\<longrightarrow> y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = 1\""], ["", "definition \"acyclic_5f x \\<equiv> \\<forall>y z . y \\<squnion> z \\<le> x \\<and> y \\<sqinter> z = bot \\<longrightarrow> y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = 1\""], ["", "definition \"acyclic_5g x \\<equiv> \\<forall>y z . y \\<squnion> z = x \\<and> y \\<sqinter> z = bot \\<longrightarrow> y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = 1\""], ["", "definition \"acyclic_6 x \\<equiv> \\<exists>y . y \\<squnion> y\\<^sup>T = x \\<and> acyclic y \\<and> injective y\""], ["", "text \\<open>Theorem 6\\<close>"], ["", "lemma acyclic_2_2a:\n  assumes \"symmetric x\"\n  shows \"acyclic_2 x \\<longleftrightarrow> acyclic_2a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_2 x = acyclic_2a x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. acyclic_2 x = acyclic_2a x", "have \"\\<And>y . y \\<le> x \\<longleftrightarrow> y \\<squnion> y\\<^sup>T \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. (y \\<le> x) = (y \\<squnion> y\\<^sup>T \\<le> x)", "using assms conv_isotone"], ["proof (prove)\nusing this:\n  symmetric x\n  ?x \\<le> ?y \\<Longrightarrow> ?x\\<^sup>T \\<le> ?y\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<And>y. (y \\<le> x) = (y \\<squnion> y\\<^sup>T \\<le> x)", "by force"], ["proof (state)\nthis:\n  (?y1 \\<le> x) = (?y1 \\<squnion> ?y1\\<^sup>T \\<le> x)\n\ngoal (1 subgoal):\n 1. acyclic_2 x = acyclic_2a x", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?y1 \\<le> x) = (?y1 \\<squnion> ?y1\\<^sup>T \\<le> x)\n\ngoal (1 subgoal):\n 1. acyclic_2 x = acyclic_2a x", "by (simp add: acyclic_2_def acyclic_2a_def)"], ["proof (state)\nthis:\n  acyclic_2 x = acyclic_2a x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 6\\<close>"], ["", "lemma acyclic_2a_2b:\n  shows \"acyclic_2a x \\<longleftrightarrow> acyclic_2b x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_2a x = acyclic_2b x", "by (simp add: acyclic_2a_def acyclic_2b_def acyclic_star_inf_conv_iff asymmetric_irreflexive)"], ["", "text \\<open>Theorem 5\\<close>"], ["", "lemma acyclic_1_1b:\n  shows \"acyclic_1 x \\<longleftrightarrow> acyclic_1b x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_1 x = acyclic_1b x", "by (simp add: acyclic_1_def acyclic_1b_def acyclic_star_inf_conv_iff asymmetric_irreflexive)"], ["", "text \\<open>Theorem 10\\<close>"], ["", "lemma acyclic_6_1_injectively_orientable:\n  \"acyclic_6 x \\<longleftrightarrow> acyclic_1 x \\<and> injectively_orientable x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_6 x = (acyclic_1 x \\<and> injectively_orientable x)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. acyclic_6 x \\<Longrightarrow>\n    acyclic_1 x \\<and> injectively_orientable x\n 2. acyclic_1 x \\<and> injectively_orientable x \\<Longrightarrow>\n    acyclic_6 x", "assume \"acyclic_6 x\""], ["proof (state)\nthis:\n  acyclic_6 x\n\ngoal (2 subgoals):\n 1. acyclic_6 x \\<Longrightarrow>\n    acyclic_1 x \\<and> injectively_orientable x\n 2. acyclic_1 x \\<and> injectively_orientable x \\<Longrightarrow>\n    acyclic_6 x", "from this"], ["proof (chain)\npicking this:\n  acyclic_6 x", "obtain y where 1: \"y \\<squnion> y\\<^sup>T = x \\<and> acyclic y \\<and> injective y\""], ["proof (prove)\nusing this:\n  acyclic_6 x\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        y \\<squnion> y\\<^sup>T = x \\<and>\n        pd_kleene_allegory_class.acyclic y \\<and>\n        injective y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using acyclic_6_def"], ["proof (prove)\nusing this:\n  acyclic_6 x\n  acyclic_6 ?x \\<equiv>\n  \\<exists>y.\n     y \\<squnion> y\\<^sup>T = ?x \\<and>\n     pd_kleene_allegory_class.acyclic y \\<and> injective y\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        y \\<squnion> y\\<^sup>T = x \\<and>\n        pd_kleene_allegory_class.acyclic y \\<and>\n        injective y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y\n\ngoal (2 subgoals):\n 1. acyclic_6 x \\<Longrightarrow>\n    acyclic_1 x \\<and> injectively_orientable x\n 2. acyclic_1 x \\<and> injectively_orientable x \\<Longrightarrow>\n    acyclic_6 x", "have \"acyclic_1 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_1 x", "proof (unfold acyclic_1_def, rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       orientation x y \\<Longrightarrow> pd_kleene_allegory_class.acyclic y", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       orientation x y \\<Longrightarrow> pd_kleene_allegory_class.acyclic y", "assume 2: \"orientation x z\""], ["proof (state)\nthis:\n  orientation x z\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       orientation x y \\<Longrightarrow> pd_kleene_allegory_class.acyclic y", "hence 3: \"z = (z \\<sqinter> y) \\<squnion> (z \\<sqinter> y\\<^sup>T)\""], ["proof (prove)\nusing this:\n  orientation x z\n\ngoal (1 subgoal):\n 1. z = z \\<sqinter> y \\<squnion> z \\<sqinter> y\\<^sup>T", "by (metis 1 inf_sup_absorb inf_sup_distrib1)"], ["proof (state)\nthis:\n  z = z \\<sqinter> y \\<squnion> z \\<sqinter> y\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       orientation x y \\<Longrightarrow> pd_kleene_allegory_class.acyclic y", "have \"(z \\<sqinter> y) * (z \\<sqinter> y\\<^sup>T) \\<le> z * z \\<sqinter> y * y\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<sqinter> y) * (z \\<sqinter> y\\<^sup>T)\n    \\<le> z * z \\<sqinter> y * y\\<^sup>T", "by (simp add: comp_isotone)"], ["proof (state)\nthis:\n  (z \\<sqinter> y) * (z \\<sqinter> y\\<^sup>T)\n  \\<le> z * z \\<sqinter> y * y\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       orientation x y \\<Longrightarrow> pd_kleene_allegory_class.acyclic y", "also"], ["proof (state)\nthis:\n  (z \\<sqinter> y) * (z \\<sqinter> y\\<^sup>T)\n  \\<le> z * z \\<sqinter> y * y\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       orientation x y \\<Longrightarrow> pd_kleene_allegory_class.acyclic y", "have \"... \\<le> -1 \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * z \\<sqinter> y * y\\<^sup>T \\<le> (1::'a) '", "using 1 2 asymmetric_var comp_inf.mult_isotone"], ["proof (prove)\nusing this:\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y\n  orientation x z\n  asymmetric ?x = asymmetric_var ?x\n  \\<lbrakk>?w \\<le> ?y; ?x \\<le> ?z\\<rbrakk>\n  \\<Longrightarrow> ?w \\<sqinter> ?x \\<le> ?y \\<sqinter> ?z\n\ngoal (1 subgoal):\n 1. z * z \\<sqinter> y * y\\<^sup>T \\<le> (1::'a) '", "by blast"], ["proof (state)\nthis:\n  z * z \\<sqinter> y * y\\<^sup>T \\<le> (1::'a) '\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       orientation x y \\<Longrightarrow> pd_kleene_allegory_class.acyclic y", "finally"], ["proof (chain)\npicking this:\n  (z \\<sqinter> y) * (z \\<sqinter> y\\<^sup>T) \\<le> (1::'a) '", "have 4: \"(z \\<sqinter> y) * (z \\<sqinter> y\\<^sup>T) = bot\""], ["proof (prove)\nusing this:\n  (z \\<sqinter> y) * (z \\<sqinter> y\\<^sup>T) \\<le> (1::'a) '\n\ngoal (1 subgoal):\n 1. (z \\<sqinter> y) * (z \\<sqinter> y\\<^sup>T) = bot", "by (simp add: le_bot)"], ["proof (state)\nthis:\n  (z \\<sqinter> y) * (z \\<sqinter> y\\<^sup>T) = bot\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       orientation x y \\<Longrightarrow> pd_kleene_allegory_class.acyclic y", "have \"z\\<^sup>+ = (z \\<sqinter> y)\\<^sup>+ \\<squnion> (z \\<sqinter> y\\<^sup>T)\\<^sup>+ \\<squnion> (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z\\<^sup>+ =\n    (z \\<sqinter> y)\\<^sup>+ \\<squnion>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>+ \\<squnion>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+", "using 3 4 plus_separate_comp_bot"], ["proof (prove)\nusing this:\n  z = z \\<sqinter> y \\<squnion> z \\<sqinter> y\\<^sup>T\n  (z \\<sqinter> y) * (z \\<sqinter> y\\<^sup>T) = bot\n  ?x * ?y = bot \\<Longrightarrow>\n  (?x \\<squnion> ?y)\\<^sup>+ =\n  ?x\\<^sup>+ \\<squnion> ?y\\<^sup>+ \\<squnion> ?y\\<^sup>+ * ?x\\<^sup>+\n\ngoal (1 subgoal):\n 1. z\\<^sup>+ =\n    (z \\<sqinter> y)\\<^sup>+ \\<squnion>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>+ \\<squnion>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+", "by fastforce"], ["proof (state)\nthis:\n  z\\<^sup>+ =\n  (z \\<sqinter> y)\\<^sup>+ \\<squnion>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>+ \\<squnion>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       orientation x y \\<Longrightarrow> pd_kleene_allegory_class.acyclic y", "also"], ["proof (state)\nthis:\n  z\\<^sup>+ =\n  (z \\<sqinter> y)\\<^sup>+ \\<squnion>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>+ \\<squnion>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       orientation x y \\<Longrightarrow> pd_kleene_allegory_class.acyclic y", "have \"... \\<le> y\\<^sup>+ \\<squnion> (z \\<sqinter> y\\<^sup>T)\\<^sup>+ \\<squnion> (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<sqinter> y)\\<^sup>+ \\<squnion>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>+ \\<squnion>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\n    \\<le> y\\<^sup>+ \\<squnion> (z \\<sqinter> y\\<^sup>T)\\<^sup>+ \\<squnion>\n          (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+", "using comp_isotone semiring.add_right_mono star_isotone"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?w \\<le> ?z\\<rbrakk>\n  \\<Longrightarrow> ?x * ?w \\<le> ?y * ?z\n  ?a \\<le> ?b \\<Longrightarrow> ?a \\<squnion> ?c \\<le> ?b \\<squnion> ?c\n  ?x \\<le> ?y \\<Longrightarrow> ?x\\<^sup>\\<star> \\<le> ?y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (z \\<sqinter> y)\\<^sup>+ \\<squnion>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>+ \\<squnion>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\n    \\<le> y\\<^sup>+ \\<squnion> (z \\<sqinter> y\\<^sup>T)\\<^sup>+ \\<squnion>\n          (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  (z \\<sqinter> y)\\<^sup>+ \\<squnion>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>+ \\<squnion>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\n  \\<le> y\\<^sup>+ \\<squnion> (z \\<sqinter> y\\<^sup>T)\\<^sup>+ \\<squnion>\n        (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       orientation x y \\<Longrightarrow> pd_kleene_allegory_class.acyclic y", "also"], ["proof (state)\nthis:\n  (z \\<sqinter> y)\\<^sup>+ \\<squnion>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>+ \\<squnion>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\n  \\<le> y\\<^sup>+ \\<squnion> (z \\<sqinter> y\\<^sup>T)\\<^sup>+ \\<squnion>\n        (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       orientation x y \\<Longrightarrow> pd_kleene_allegory_class.acyclic y", "have \"... \\<le> y\\<^sup>+ \\<squnion> y\\<^sup>T\\<^sup>+ \\<squnion> (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>+ \\<squnion> (z \\<sqinter> y\\<^sup>T)\\<^sup>+ \\<squnion>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\n    \\<le> y\\<^sup>+ \\<squnion> y\\<^sup>T\\<^sup>+ \\<squnion>\n          (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+", "using comp_isotone semiring.add_left_mono semiring.add_right_mono star_isotone"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?w \\<le> ?z\\<rbrakk>\n  \\<Longrightarrow> ?x * ?w \\<le> ?y * ?z\n  ?a \\<le> ?b \\<Longrightarrow> ?c \\<squnion> ?a \\<le> ?c \\<squnion> ?b\n  ?a \\<le> ?b \\<Longrightarrow> ?a \\<squnion> ?c \\<le> ?b \\<squnion> ?c\n  ?x \\<le> ?y \\<Longrightarrow> ?x\\<^sup>\\<star> \\<le> ?y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. y\\<^sup>+ \\<squnion> (z \\<sqinter> y\\<^sup>T)\\<^sup>+ \\<squnion>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\n    \\<le> y\\<^sup>+ \\<squnion> y\\<^sup>T\\<^sup>+ \\<squnion>\n          (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  y\\<^sup>+ \\<squnion> (z \\<sqinter> y\\<^sup>T)\\<^sup>+ \\<squnion>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\n  \\<le> y\\<^sup>+ \\<squnion> y\\<^sup>T\\<^sup>+ \\<squnion>\n        (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       orientation x y \\<Longrightarrow> pd_kleene_allegory_class.acyclic y", "also"], ["proof (state)\nthis:\n  y\\<^sup>+ \\<squnion> (z \\<sqinter> y\\<^sup>T)\\<^sup>+ \\<squnion>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\n  \\<le> y\\<^sup>+ \\<squnion> y\\<^sup>T\\<^sup>+ \\<squnion>\n        (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       orientation x y \\<Longrightarrow> pd_kleene_allegory_class.acyclic y", "have \"... \\<le> -1 \\<squnion> (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>+ \\<squnion> y\\<^sup>T\\<^sup>+ \\<squnion>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\n    \\<le> - (1::'a) \\<squnion>\n          (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+", "by (smt 1 conv_complement conv_isotone conv_plus_commute inf.absorb2 inf.orderE order_conv_closed order_one_closed semiring.add_right_mono sup.absorb1)"], ["proof (state)\nthis:\n  y\\<^sup>+ \\<squnion> y\\<^sup>T\\<^sup>+ \\<squnion>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\n  \\<le> - (1::'a) \\<squnion>\n        (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       orientation x y \\<Longrightarrow> pd_kleene_allegory_class.acyclic y", "also"], ["proof (state)\nthis:\n  y\\<^sup>+ \\<squnion> y\\<^sup>T\\<^sup>+ \\<squnion>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\n  \\<le> - (1::'a) \\<squnion>\n        (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       orientation x y \\<Longrightarrow> pd_kleene_allegory_class.acyclic y", "have \"... = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (1::'a) \\<squnion>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+ =\n    - (1::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - (1::'a) \\<squnion>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+ =\n    - (1::'a)", "have \"(z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+ \\<le> (z \\<sqinter> y\\<^sup>T) * top * (z \\<sqinter> y)\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\n    \\<le> (z \\<sqinter> y\\<^sup>T) * top * (z \\<sqinter> y)\\<^sup>+", "using comp_isotone"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?w \\<le> ?z\\<rbrakk>\n  \\<Longrightarrow> ?x * ?w \\<le> ?y * ?z\n\ngoal (1 subgoal):\n 1. (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\n    \\<le> (z \\<sqinter> y\\<^sup>T) * top * (z \\<sqinter> y)\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\n  \\<le> (z \\<sqinter> y\\<^sup>T) * top * (z \\<sqinter> y)\\<^sup>+\n\ngoal (1 subgoal):\n 1. - (1::'a) \\<squnion>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+ =\n    - (1::'a)", "also"], ["proof (state)\nthis:\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+\n  \\<le> (z \\<sqinter> y\\<^sup>T) * top * (z \\<sqinter> y)\\<^sup>+\n\ngoal (1 subgoal):\n 1. - (1::'a) \\<squnion>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+ =\n    - (1::'a)", "have \"... \\<le> (z \\<sqinter> y\\<^sup>T) * top * (z \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<sqinter> y\\<^sup>T) * top * (z \\<sqinter> y)\\<^sup>+\n    \\<le> (z \\<sqinter> y\\<^sup>T) * top * (z \\<sqinter> y)", "by (metis inf.eq_refl star.circ_left_top star_plus mult_assoc)"], ["proof (state)\nthis:\n  (z \\<sqinter> y\\<^sup>T) * top * (z \\<sqinter> y)\\<^sup>+\n  \\<le> (z \\<sqinter> y\\<^sup>T) * top * (z \\<sqinter> y)\n\ngoal (1 subgoal):\n 1. - (1::'a) \\<squnion>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+ =\n    - (1::'a)", "also"], ["proof (state)\nthis:\n  (z \\<sqinter> y\\<^sup>T) * top * (z \\<sqinter> y)\\<^sup>+\n  \\<le> (z \\<sqinter> y\\<^sup>T) * top * (z \\<sqinter> y)\n\ngoal (1 subgoal):\n 1. - (1::'a) \\<squnion>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+ =\n    - (1::'a)", "have \"... \\<le> -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreflexive ((z \\<sqinter> y\\<^sup>T) * top * (z \\<sqinter> y))", "by (metis 4 bot_least comp_commute_below_diversity inf.absorb2 pseudo_complement schroeder_1 mult_assoc)"], ["proof (state)\nthis:\n  irreflexive ((z \\<sqinter> y\\<^sup>T) * top * (z \\<sqinter> y))\n\ngoal (1 subgoal):\n 1. - (1::'a) \\<squnion>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+ =\n    - (1::'a)", "finally"], ["proof (chain)\npicking this:\n  irreflexive ((z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+)", "show ?thesis"], ["proof (prove)\nusing this:\n  irreflexive ((z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+)\n\ngoal (1 subgoal):\n 1. - (1::'a) \\<squnion>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+ =\n    - (1::'a)", "using sup.absorb1"], ["proof (prove)\nusing this:\n  irreflexive ((z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+)\n  ?b \\<le> ?a \\<Longrightarrow> ?a \\<squnion> ?b = ?a\n\ngoal (1 subgoal):\n 1. - (1::'a) \\<squnion>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+ =\n    - (1::'a)", "by blast"], ["proof (state)\nthis:\n  - (1::'a) \\<squnion>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+ =\n  - (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  - (1::'a) \\<squnion>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>+ * (z \\<sqinter> y)\\<^sup>+ =\n  - (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       orientation x y \\<Longrightarrow> pd_kleene_allegory_class.acyclic y", "finally"], ["proof (chain)\npicking this:\n  pd_kleene_allegory_class.acyclic z", "show \"acyclic z\""], ["proof (prove)\nusing this:\n  pd_kleene_allegory_class.acyclic z\n\ngoal (1 subgoal):\n 1. pd_kleene_allegory_class.acyclic z", "by simp"], ["proof (state)\nthis:\n  pd_kleene_allegory_class.acyclic z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  acyclic_1 x\n\ngoal (2 subgoals):\n 1. acyclic_6 x \\<Longrightarrow>\n    acyclic_1 x \\<and> injectively_orientable x\n 2. acyclic_1 x \\<and> injectively_orientable x \\<Longrightarrow>\n    acyclic_6 x", "thus \"acyclic_1 x \\<and> injectively_orientable x\""], ["proof (prove)\nusing this:\n  acyclic_1 x\n\ngoal (1 subgoal):\n 1. acyclic_1 x \\<and> injectively_orientable x", "using 1 injectively_orientable_def acyclic_asymmetric"], ["proof (prove)\nusing this:\n  acyclic_1 x\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y\n  injectively_orientable ?x \\<equiv>\n  \\<exists>y. orientation ?x y \\<and> injective y\n  pd_kleene_allegory_class.acyclic ?w \\<Longrightarrow> asymmetric ?w\n\ngoal (1 subgoal):\n 1. acyclic_1 x \\<and> injectively_orientable x", "by blast"], ["proof (state)\nthis:\n  acyclic_1 x \\<and> injectively_orientable x\n\ngoal (1 subgoal):\n 1. acyclic_1 x \\<and> injectively_orientable x \\<Longrightarrow>\n    acyclic_6 x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. acyclic_1 x \\<and> injectively_orientable x \\<Longrightarrow>\n    acyclic_6 x", "assume \"acyclic_1 x \\<and> injectively_orientable x\""], ["proof (state)\nthis:\n  acyclic_1 x \\<and> injectively_orientable x\n\ngoal (1 subgoal):\n 1. acyclic_1 x \\<and> injectively_orientable x \\<Longrightarrow>\n    acyclic_6 x", "thus \"acyclic_6 x\""], ["proof (prove)\nusing this:\n  acyclic_1 x \\<and> injectively_orientable x\n\ngoal (1 subgoal):\n 1. acyclic_6 x", "using acyclic_6_def acyclic_1_def injectively_orientable_def"], ["proof (prove)\nusing this:\n  acyclic_1 x \\<and> injectively_orientable x\n  acyclic_6 ?x \\<equiv>\n  \\<exists>y.\n     y \\<squnion> y\\<^sup>T = ?x \\<and>\n     pd_kleene_allegory_class.acyclic y \\<and> injective y\n  acyclic_1 ?x \\<equiv>\n  \\<forall>y.\n     orientation ?x y \\<longrightarrow> pd_kleene_allegory_class.acyclic y\n  injectively_orientable ?x \\<equiv>\n  \\<exists>y. orientation ?x y \\<and> injective y\n\ngoal (1 subgoal):\n 1. acyclic_6 x", "by auto"], ["proof (state)\nthis:\n  acyclic_6 x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma acyclic_6_symmetric:\n  \"acyclic_6 x \\<Longrightarrow> symmetric x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_6 x \\<Longrightarrow> symmetric x", "by (simp add: acyclic_6_1_injectively_orientable injectively_orientable_orientable orientable_symmetric)"], ["", "lemma acyclic_6_irreflexive:\n  \"acyclic_6 x \\<Longrightarrow> irreflexive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_6 x \\<Longrightarrow> irreflexive x", "by (simp add: acyclic_6_1_injectively_orientable injectively_orientable_orientable orientable_irreflexive)"], ["", "lemma acyclic_4_irreflexive:\n  \"acyclic_4 x \\<Longrightarrow> irreflexive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_4 x \\<Longrightarrow> irreflexive x", "by (metis acyclic_4_def bot_least inf.absorb2 inf.sup_monoid.add_assoc p_bot pseudo_complement star.circ_reflexive)"], ["", "text \\<open>Theorem 6.4\\<close>"], ["", "lemma acyclic_2_implies_1:\n  \"acyclic_2 x \\<Longrightarrow> acyclic_1 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_2 x \\<Longrightarrow> acyclic_1 x", "using acyclic_2_def acyclic_1_def"], ["proof (prove)\nusing this:\n  acyclic_2 ?x \\<equiv>\n  \\<forall>y.\n     y \\<le> ?x \\<and> asymmetric y \\<longrightarrow>\n     pd_kleene_allegory_class.acyclic y\n  acyclic_1 ?x \\<equiv>\n  \\<forall>y.\n     orientation ?x y \\<longrightarrow> pd_kleene_allegory_class.acyclic y\n\ngoal (1 subgoal):\n 1. acyclic_2 x \\<Longrightarrow> acyclic_1 x", "by auto"], ["", "text \\<open>Theorem 8\\<close>"], ["", "lemma acyclic_4a_4b:\n  \"acyclic_4a x \\<longleftrightarrow> acyclic_4b x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_4a x = acyclic_4b x", "using acyclic_4a_def acyclic_4b_def eq_iff star.circ_increasing"], ["proof (prove)\nusing this:\n  acyclic_4a ?x \\<equiv>\n  \\<forall>y\\<le>?x. ?x \\<sqinter> y\\<^sup>\\<star> \\<le> y\n  acyclic_4b ?x \\<equiv>\n  \\<forall>y\\<le>?x. ?x \\<sqinter> y\\<^sup>\\<star> = y\n  (?x = ?y) = (?x \\<le> ?y \\<and> ?y \\<le> ?x)\n  ?x \\<le> ?x\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. acyclic_4a x = acyclic_4b x", "by auto"], ["", "text \\<open>Theorem 7\\<close>"], ["", "lemma acyclic_3a_3b:\n  \"acyclic_3a x \\<longleftrightarrow> acyclic_3b x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_3a x = acyclic_3b x", "by (metis acyclic_3a_def acyclic_3b_def antisym star.circ_increasing star_involutive star_isotone)"], ["", "text \\<open>Theorem 7\\<close>"], ["", "lemma acyclic_3a_3c:\n  assumes \"irreflexive x\"\n  shows \"acyclic_3a x \\<longleftrightarrow> acyclic_3c x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_3a x = acyclic_3c x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. acyclic_3a x \\<Longrightarrow> acyclic_3c x\n 2. acyclic_3c x \\<Longrightarrow> acyclic_3a x", "assume \"acyclic_3a x\""], ["proof (state)\nthis:\n  acyclic_3a x\n\ngoal (2 subgoals):\n 1. acyclic_3a x \\<Longrightarrow> acyclic_3c x\n 2. acyclic_3c x \\<Longrightarrow> acyclic_3a x", "thus \"acyclic_3c x\""], ["proof (prove)\nusing this:\n  acyclic_3a x\n\ngoal (1 subgoal):\n 1. acyclic_3c x", "by (meson acyclic_3a_def acyclic_3c_def order_lesseq_imp star.left_plus_below_circ)"], ["proof (state)\nthis:\n  acyclic_3c x\n\ngoal (1 subgoal):\n 1. acyclic_3c x \\<Longrightarrow> acyclic_3a x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. acyclic_3c x \\<Longrightarrow> acyclic_3a x", "assume 1: \"acyclic_3c x\""], ["proof (state)\nthis:\n  acyclic_3c x\n\ngoal (1 subgoal):\n 1. acyclic_3c x \\<Longrightarrow> acyclic_3a x", "show \"acyclic_3a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_3a x", "proof (unfold acyclic_3a_def, rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<and> x \\<le> y\\<^sup>\\<star> \\<Longrightarrow> y = x", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<and> x \\<le> y\\<^sup>\\<star> \\<Longrightarrow> y = x", "assume \"y \\<le> x \\<and> x \\<le> y\\<^sup>\\<star>\""], ["proof (state)\nthis:\n  y \\<le> x \\<and> x \\<le> y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<and> x \\<le> y\\<^sup>\\<star> \\<Longrightarrow> y = x", "hence \"y \\<le> x \\<and> x \\<le> y\\<^sup>+\""], ["proof (prove)\nusing this:\n  y \\<le> x \\<and> x \\<le> y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. y \\<le> x \\<and> x \\<le> y\\<^sup>+", "by (metis assms inf.order_lesseq_imp le_infI p_inf_sup_below star_left_unfold_equal)"], ["proof (state)\nthis:\n  y \\<le> x \\<and> x \\<le> y\\<^sup>+\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<and> x \\<le> y\\<^sup>\\<star> \\<Longrightarrow> y = x", "thus \"y = x\""], ["proof (prove)\nusing this:\n  y \\<le> x \\<and> x \\<le> y\\<^sup>+\n\ngoal (1 subgoal):\n 1. y = x", "using 1 acyclic_3c_def"], ["proof (prove)\nusing this:\n  y \\<le> x \\<and> x \\<le> y\\<^sup>+\n  acyclic_3c x\n  acyclic_3c ?x \\<equiv>\n  \\<forall>y. y \\<le> ?x \\<and> ?x \\<le> y\\<^sup>+ \\<longrightarrow> y = ?x\n\ngoal (1 subgoal):\n 1. y = x", "by blast"], ["proof (state)\nthis:\n  y = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  acyclic_3a x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 7\\<close>"], ["", "lemma acyclic_3c_3d:\n  shows \"acyclic_3c x \\<longleftrightarrow> acyclic_3d x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_3c x = acyclic_3d x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. acyclic_3c x = acyclic_3d x", "have \"\\<And>y z . y \\<le> z \\<and> z \\<le> y\\<^sup>+ \\<longleftrightarrow> y \\<le> z \\<and> y\\<^sup>+ = z\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       (y \\<le> z \\<and> z \\<le> y\\<^sup>+) =\n       (y \\<le> z \\<and> y\\<^sup>+ = z\\<^sup>+)", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y z.\n       y \\<le> z \\<and> z \\<le> y\\<^sup>+ \\<Longrightarrow>\n       y \\<le> z \\<and> y\\<^sup>+ = z\\<^sup>+\n 2. \\<And>y z.\n       y \\<le> z \\<and> y\\<^sup>+ = z\\<^sup>+ \\<Longrightarrow>\n       y \\<le> z \\<and> z \\<le> y\\<^sup>+", "apply (smt comp_associative plus_sup star.circ_transitive_equal star.left_plus_circ sup_absorb1 sup_absorb2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       y \\<le> z \\<and> y\\<^sup>+ = z\\<^sup>+ \\<Longrightarrow>\n       y \\<le> z \\<and> z \\<le> y\\<^sup>+", "by (simp add: star.circ_mult_increasing)"], ["proof (state)\nthis:\n  (?y1 \\<le> ?z1 \\<and> ?z1 \\<le> ?y1\\<^sup>+) =\n  (?y1 \\<le> ?z1 \\<and> ?y1\\<^sup>+ = ?z1\\<^sup>+)\n\ngoal (1 subgoal):\n 1. acyclic_3c x = acyclic_3d x", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?y1 \\<le> ?z1 \\<and> ?z1 \\<le> ?y1\\<^sup>+) =\n  (?y1 \\<le> ?z1 \\<and> ?y1\\<^sup>+ = ?z1\\<^sup>+)\n\ngoal (1 subgoal):\n 1. acyclic_3c x = acyclic_3d x", "by (simp add: acyclic_3c_def acyclic_3d_def)"], ["proof (state)\nthis:\n  acyclic_3c x = acyclic_3d x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 8\\<close>"], ["", "lemma acyclic_4a_implies_3a:\n  \"acyclic_4a x \\<Longrightarrow> acyclic_3a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_4a x \\<Longrightarrow> acyclic_3a x", "using acyclic_4a_def acyclic_3a_def inf.absorb1"], ["proof (prove)\nusing this:\n  acyclic_4a ?x \\<equiv>\n  \\<forall>y\\<le>?x. ?x \\<sqinter> y\\<^sup>\\<star> \\<le> y\n  acyclic_3a ?x \\<equiv>\n  \\<forall>y.\n     y \\<le> ?x \\<and> ?x \\<le> y\\<^sup>\\<star> \\<longrightarrow> y = ?x\n  ?a \\<le> ?b \\<Longrightarrow> ?a \\<sqinter> ?b = ?a\n\ngoal (1 subgoal):\n 1. acyclic_4a x \\<Longrightarrow> acyclic_3a x", "by auto"], ["", "lemma acyclic_4a_implies_4:\n  \"acyclic_4a x \\<Longrightarrow> acyclic_4 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_4a x \\<Longrightarrow> acyclic_4 x", "by (simp add: acyclic_4_def acyclic_4a_4b acyclic_4b_def pp_increasing)"], ["", "lemma acyclic_4b_implies_4c:\n  \"acyclic_4b x \\<Longrightarrow> acyclic_4c x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_4b x \\<Longrightarrow> acyclic_4c x", "by (simp add: acyclic_4b_def acyclic_4c_def inf.sup_relative_same_increasing)"], ["", "text \\<open>Theorem 8.5\\<close>"], ["", "lemma acyclic_4_implies_2:\n  assumes \"symmetric x\"\n  shows \"acyclic_4 x \\<Longrightarrow> acyclic_2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_4 x \\<Longrightarrow> acyclic_2 x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. acyclic_4 x \\<Longrightarrow> acyclic_2 x", "assume 1: \"acyclic_4 x\""], ["proof (state)\nthis:\n  acyclic_4 x\n\ngoal (1 subgoal):\n 1. acyclic_4 x \\<Longrightarrow> acyclic_2 x", "show \"acyclic_2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_2 x", "proof (unfold acyclic_2_def, rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<and> asymmetric y \\<Longrightarrow>\n       pd_kleene_allegory_class.acyclic y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<and> asymmetric y \\<Longrightarrow>\n       pd_kleene_allegory_class.acyclic y", "assume 2: \"y \\<le> x \\<and> asymmetric y\""], ["proof (state)\nthis:\n  y \\<le> x \\<and> asymmetric y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<and> asymmetric y \\<Longrightarrow>\n       pd_kleene_allegory_class.acyclic y", "hence \"y\\<^sup>T \\<le> x \\<sqinter> -y\""], ["proof (prove)\nusing this:\n  y \\<le> x \\<and> asymmetric y\n\ngoal (1 subgoal):\n 1. y\\<^sup>T \\<le> x \\<sqinter> - y", "using assms conv_inf_bot_iff conv_isotone pseudo_complement"], ["proof (prove)\nusing this:\n  y \\<le> x \\<and> asymmetric y\n  symmetric x\n  (bot = ?x\\<^sup>T \\<sqinter> ?y) = (bot = ?x \\<sqinter> ?y\\<^sup>T)\n  ?x \\<le> ?y \\<Longrightarrow> ?x\\<^sup>T \\<le> ?y\\<^sup>T\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. y\\<^sup>T \\<le> x \\<sqinter> - y", "by force"], ["proof (state)\nthis:\n  y\\<^sup>T \\<le> x \\<sqinter> - y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<and> asymmetric y \\<Longrightarrow>\n       pd_kleene_allegory_class.acyclic y", "hence \"y\\<^sup>\\<star> \\<sqinter> y\\<^sup>T \\<le> y\\<^sup>\\<star> \\<sqinter> x \\<sqinter> -y\""], ["proof (prove)\nusing this:\n  y\\<^sup>T \\<le> x \\<sqinter> - y\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> \\<sqinter> y\\<^sup>T\n    \\<le> y\\<^sup>\\<star> \\<sqinter> x \\<sqinter> - y", "using dual_order.trans"], ["proof (prove)\nusing this:\n  y\\<^sup>T \\<le> x \\<sqinter> - y\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> \\<sqinter> y\\<^sup>T\n    \\<le> y\\<^sup>\\<star> \\<sqinter> x \\<sqinter> - y", "by auto"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> \\<sqinter> y\\<^sup>T\n  \\<le> y\\<^sup>\\<star> \\<sqinter> x \\<sqinter> - y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<and> asymmetric y \\<Longrightarrow>\n       pd_kleene_allegory_class.acyclic y", "also"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> \\<sqinter> y\\<^sup>T\n  \\<le> y\\<^sup>\\<star> \\<sqinter> x \\<sqinter> - y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<and> asymmetric y \\<Longrightarrow>\n       pd_kleene_allegory_class.acyclic y", "have \"... \\<le> --y \\<sqinter> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> \\<sqinter> x \\<sqinter> - y \\<le> - - y \\<sqinter> - y", "using 1 2"], ["proof (prove)\nusing this:\n  acyclic_4 x\n  y \\<le> x \\<and> asymmetric y\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> \\<sqinter> x \\<sqinter> - y \\<le> - - y \\<sqinter> - y", "by (metis inf.commute acyclic_4_def comp_inf.mult_left_isotone)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> \\<sqinter> x \\<sqinter> - y \\<le> - - y \\<sqinter> - y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<and> asymmetric y \\<Longrightarrow>\n       pd_kleene_allegory_class.acyclic y", "finally"], ["proof (chain)\npicking this:\n  y\\<^sup>\\<star> \\<sqinter> y\\<^sup>T \\<le> - - y \\<sqinter> - y", "show \"acyclic y\""], ["proof (prove)\nusing this:\n  y\\<^sup>\\<star> \\<sqinter> y\\<^sup>T \\<le> - - y \\<sqinter> - y\n\ngoal (1 subgoal):\n 1. pd_kleene_allegory_class.acyclic y", "by (simp add: acyclic_star_below_complement_1 le_bot)"], ["proof (state)\nthis:\n  pd_kleene_allegory_class.acyclic y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  acyclic_2 x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 10.3\\<close>"], ["", "lemma acyclic_6_implies_4a:\n  \"acyclic_6 x \\<Longrightarrow> acyclic_4a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_6 x \\<Longrightarrow> acyclic_4a x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. acyclic_6 x \\<Longrightarrow> acyclic_4a x", "assume \"acyclic_6 x\""], ["proof (state)\nthis:\n  acyclic_6 x\n\ngoal (1 subgoal):\n 1. acyclic_6 x \\<Longrightarrow> acyclic_4a x", "from this"], ["proof (chain)\npicking this:\n  acyclic_6 x", "obtain y where 1: \"y \\<squnion> y\\<^sup>T = x \\<and> acyclic y \\<and> injective y\""], ["proof (prove)\nusing this:\n  acyclic_6 x\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        y \\<squnion> y\\<^sup>T = x \\<and>\n        pd_kleene_allegory_class.acyclic y \\<and>\n        injective y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using acyclic_6_def"], ["proof (prove)\nusing this:\n  acyclic_6 x\n  acyclic_6 ?x \\<equiv>\n  \\<exists>y.\n     y \\<squnion> y\\<^sup>T = ?x \\<and>\n     pd_kleene_allegory_class.acyclic y \\<and> injective y\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        y \\<squnion> y\\<^sup>T = x \\<and>\n        pd_kleene_allegory_class.acyclic y \\<and>\n        injective y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y\n\ngoal (1 subgoal):\n 1. acyclic_6 x \\<Longrightarrow> acyclic_4a x", "show \"acyclic_4a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_4a x", "proof (unfold acyclic_4a_def, rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> \\<le> y", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> \\<le> y", "assume \"z \\<le> x\""], ["proof (state)\nthis:\n  z \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> \\<le> y", "hence \"z = (z \\<sqinter> y) \\<squnion> (z \\<sqinter> y\\<^sup>T)\""], ["proof (prove)\nusing this:\n  z \\<le> x\n\ngoal (1 subgoal):\n 1. z = z \\<sqinter> y \\<squnion> z \\<sqinter> y\\<^sup>T", "using 1"], ["proof (prove)\nusing this:\n  z \\<le> x\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y\n\ngoal (1 subgoal):\n 1. z = z \\<sqinter> y \\<squnion> z \\<sqinter> y\\<^sup>T", "by (metis inf.orderE inf_sup_distrib1)"], ["proof (state)\nthis:\n  z = z \\<sqinter> y \\<squnion> z \\<sqinter> y\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> \\<le> y", "hence 2: \"z\\<^sup>\\<star> = (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  z = z \\<sqinter> y \\<squnion> z \\<sqinter> y\\<^sup>T\n\ngoal (1 subgoal):\n 1. z\\<^sup>\\<star> =\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>", "using 1"], ["proof (prove)\nusing this:\n  z = z \\<sqinter> y \\<squnion> z \\<sqinter> y\\<^sup>T\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y\n\ngoal (1 subgoal):\n 1. z\\<^sup>\\<star> =\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>", "by (metis cancel_separate_2)"], ["proof (state)\nthis:\n  z\\<^sup>\\<star> =\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> \\<le> y", "hence \"x \\<sqinter> z\\<^sup>\\<star> = (y \\<sqinter> (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>) \\<squnion> (y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>)\""], ["proof (prove)\nusing this:\n  z\\<^sup>\\<star> =\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x \\<sqinter> z\\<^sup>\\<star> =\n    y \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> *\n    (z \\<sqinter> y)\\<^sup>\\<star> \\<squnion>\n    y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>", "using 1 inf_sup_distrib2"], ["proof (prove)\nusing this:\n  z\\<^sup>\\<star> =\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y\n  (?y \\<squnion> ?z) \\<sqinter> ?x =\n  ?y \\<sqinter> ?x \\<squnion> ?z \\<sqinter> ?x\n\ngoal (1 subgoal):\n 1. x \\<sqinter> z\\<^sup>\\<star> =\n    y \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> *\n    (z \\<sqinter> y)\\<^sup>\\<star> \\<squnion>\n    y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>", "by auto"], ["proof (state)\nthis:\n  x \\<sqinter> z\\<^sup>\\<star> =\n  y \\<sqinter>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> *\n  (z \\<sqinter> y)\\<^sup>\\<star> \\<squnion>\n  y\\<^sup>T \\<sqinter>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> \\<le> y", "also"], ["proof (state)\nthis:\n  x \\<sqinter> z\\<^sup>\\<star> =\n  y \\<sqinter>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> *\n  (z \\<sqinter> y)\\<^sup>\\<star> \\<squnion>\n  y\\<^sup>T \\<sqinter>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> \\<le> y", "have \"... \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> *\n    (z \\<sqinter> y)\\<^sup>\\<star> \\<squnion>\n    y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "proof (rule sup_least)"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z\n 2. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "have \"y \\<sqinter> (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star> = (y \\<sqinter> (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star>) \\<squnion> (y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> *\n    (z \\<sqinter> y)\\<^sup>\\<star> =\n    y \\<sqinter> (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> \\<squnion>\n    y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y)", "using 2"], ["proof (prove)\nusing this:\n  z\\<^sup>\\<star> =\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. y \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> *\n    (z \\<sqinter> y)\\<^sup>\\<star> =\n    y \\<sqinter> (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> \\<squnion>\n    y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y)", "by (metis inf_sup_distrib1 star.circ_back_loop_fixpoint sup_commute)"], ["proof (state)\nthis:\n  y \\<sqinter>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star> =\n  y \\<sqinter> (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> \\<squnion>\n  y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y)\n\ngoal (2 subgoals):\n 1. y \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z\n 2. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "also"], ["proof (state)\nthis:\n  y \\<sqinter>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star> =\n  y \\<sqinter> (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> \\<squnion>\n  y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y)\n\ngoal (2 subgoals):\n 1. y \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z\n 2. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "have \"... \\<le> (y \\<sqinter> y\\<^sup>T\\<^sup>\\<star>) \\<squnion> (y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sqinter> (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> \\<squnion>\n    y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y)\n    \\<le> y \\<sqinter> y\\<^sup>T\\<^sup>\\<star> \\<squnion>\n          y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y)", "using inf.sup_right_isotone semiring.add_right_mono star_isotone"], ["proof (prove)\nusing this:\n  ?y \\<le> ?x \\<Longrightarrow> ?z \\<sqinter> ?y \\<le> ?z \\<sqinter> ?x\n  ?a \\<le> ?b \\<Longrightarrow> ?a \\<squnion> ?c \\<le> ?b \\<squnion> ?c\n  ?x \\<le> ?y \\<Longrightarrow> ?x\\<^sup>\\<star> \\<le> ?y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. y \\<sqinter> (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> \\<squnion>\n    y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y)\n    \\<le> y \\<sqinter> y\\<^sup>T\\<^sup>\\<star> \\<squnion>\n          y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y)", "by auto"], ["proof (state)\nthis:\n  y \\<sqinter> (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> \\<squnion>\n  y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y)\n  \\<le> y \\<sqinter> y\\<^sup>T\\<^sup>\\<star> \\<squnion>\n        y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y)\n\ngoal (2 subgoals):\n 1. y \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z\n 2. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "also"], ["proof (state)\nthis:\n  y \\<sqinter> (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> \\<squnion>\n  y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y)\n  \\<le> y \\<sqinter> y\\<^sup>T\\<^sup>\\<star> \\<squnion>\n        y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y)\n\ngoal (2 subgoals):\n 1. y \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z\n 2. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "have \"... = y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sqinter> y\\<^sup>T\\<^sup>\\<star> \\<squnion>\n    y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y) =\n    y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y)", "using 1"], ["proof (prove)\nusing this:\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y\n\ngoal (1 subgoal):\n 1. y \\<sqinter> y\\<^sup>T\\<^sup>\\<star> \\<squnion>\n    y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y) =\n    y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y)", "by (metis acyclic_star_below_complement bot_least inf.sup_monoid.add_commute pseudo_complement sup.absorb2)"], ["proof (state)\nthis:\n  y \\<sqinter> y\\<^sup>T\\<^sup>\\<star> \\<squnion>\n  y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y) =\n  y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y)\n\ngoal (2 subgoals):\n 1. y \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z\n 2. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "also"], ["proof (state)\nthis:\n  y \\<sqinter> y\\<^sup>T\\<^sup>\\<star> \\<squnion>\n  y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y) =\n  y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y)\n\ngoal (2 subgoals):\n 1. y \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z\n 2. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "have \"... \\<le> (z\\<^sup>\\<star> \\<sqinter> y * (z \\<sqinter> y)\\<^sup>T) * (z \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y)\n    \\<le> (z\\<^sup>\\<star> \\<sqinter> y * (z \\<sqinter> y)\\<^sup>T) *\n          (z \\<sqinter> y)", "using dedekind_2 inf_commute"], ["proof (prove)\nusing this:\n  ?y * ?x \\<sqinter> ?z \\<le> (?y \\<sqinter> ?z * ?x\\<^sup>T) * ?x\n  ?x \\<sqinter> ?y = ?y \\<sqinter> ?x\n\ngoal (1 subgoal):\n 1. y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y)\n    \\<le> (z\\<^sup>\\<star> \\<sqinter> y * (z \\<sqinter> y)\\<^sup>T) *\n          (z \\<sqinter> y)", "by auto"], ["proof (state)\nthis:\n  y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y)\n  \\<le> (z\\<^sup>\\<star> \\<sqinter> y * (z \\<sqinter> y)\\<^sup>T) *\n        (z \\<sqinter> y)\n\ngoal (2 subgoals):\n 1. y \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z\n 2. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "also"], ["proof (state)\nthis:\n  y \\<sqinter> z\\<^sup>\\<star> * (z \\<sqinter> y)\n  \\<le> (z\\<^sup>\\<star> \\<sqinter> y * (z \\<sqinter> y)\\<^sup>T) *\n        (z \\<sqinter> y)\n\ngoal (2 subgoals):\n 1. y \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z\n 2. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "have \"... \\<le> y * y\\<^sup>T * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z\\<^sup>\\<star> \\<sqinter> y * (z \\<sqinter> y)\\<^sup>T) *\n    (z \\<sqinter> y)\n    \\<le> y * y\\<^sup>T * z", "by (simp add: conv_isotone inf.coboundedI2 mult_isotone)"], ["proof (state)\nthis:\n  (z\\<^sup>\\<star> \\<sqinter> y * (z \\<sqinter> y)\\<^sup>T) *\n  (z \\<sqinter> y)\n  \\<le> y * y\\<^sup>T * z\n\ngoal (2 subgoals):\n 1. y \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z\n 2. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "also"], ["proof (state)\nthis:\n  (z\\<^sup>\\<star> \\<sqinter> y * (z \\<sqinter> y)\\<^sup>T) *\n  (z \\<sqinter> y)\n  \\<le> y * y\\<^sup>T * z\n\ngoal (2 subgoals):\n 1. y \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z\n 2. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "have \"... \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * y\\<^sup>T * z \\<le> z", "using 1 mult_left_isotone"], ["proof (prove)\nusing this:\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y\n  ?x \\<le> ?y \\<Longrightarrow> ?x * ?z \\<le> ?y * ?z\n\ngoal (1 subgoal):\n 1. y * y\\<^sup>T * z \\<le> z", "by fastforce"], ["proof (state)\nthis:\n  y * y\\<^sup>T * z \\<le> z\n\ngoal (2 subgoals):\n 1. y \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z\n 2. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "finally"], ["proof (chain)\npicking this:\n  y \\<sqinter>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n  \\<le> z", "show \"y \\<sqinter> (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star> \\<le> z\""], ["proof (prove)\nusing this:\n  y \\<sqinter>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n  \\<le> z\n\ngoal (1 subgoal):\n 1. y \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "."], ["proof (state)\nthis:\n  y \\<sqinter>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n  \\<le> z\n\ngoal (1 subgoal):\n 1. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "have \"y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star> = (y\\<^sup>T \\<sqinter> (z \\<sqinter> y)\\<^sup>\\<star>) \\<squnion> (y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> *\n    (z \\<sqinter> y)\\<^sup>\\<star> =\n    y\\<^sup>T \\<sqinter> (z \\<sqinter> y)\\<^sup>\\<star> \\<squnion>\n    y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star>", "using 2"], ["proof (prove)\nusing this:\n  z\\<^sup>\\<star> =\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> *\n    (z \\<sqinter> y)\\<^sup>\\<star> =\n    y\\<^sup>T \\<sqinter> (z \\<sqinter> y)\\<^sup>\\<star> \\<squnion>\n    y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star>", "by (metis inf_sup_distrib1 star.circ_loop_fixpoint sup_commute)"], ["proof (state)\nthis:\n  y\\<^sup>T \\<sqinter>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star> =\n  y\\<^sup>T \\<sqinter> (z \\<sqinter> y)\\<^sup>\\<star> \\<squnion>\n  y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "also"], ["proof (state)\nthis:\n  y\\<^sup>T \\<sqinter>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star> =\n  y\\<^sup>T \\<sqinter> (z \\<sqinter> y)\\<^sup>\\<star> \\<squnion>\n  y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "have \"... \\<le> (y\\<^sup>T \\<sqinter> y\\<^sup>\\<star>) \\<squnion> (y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>T \\<sqinter> (z \\<sqinter> y)\\<^sup>\\<star> \\<squnion>\n    y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star>\n    \\<le> y\\<^sup>T \\<sqinter> y\\<^sup>\\<star> \\<squnion>\n          y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star>", "using inf.sup_right_isotone semiring.add_right_mono star_isotone"], ["proof (prove)\nusing this:\n  ?y \\<le> ?x \\<Longrightarrow> ?z \\<sqinter> ?y \\<le> ?z \\<sqinter> ?x\n  ?a \\<le> ?b \\<Longrightarrow> ?a \\<squnion> ?c \\<le> ?b \\<squnion> ?c\n  ?x \\<le> ?y \\<Longrightarrow> ?x\\<^sup>\\<star> \\<le> ?y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. y\\<^sup>T \\<sqinter> (z \\<sqinter> y)\\<^sup>\\<star> \\<squnion>\n    y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star>\n    \\<le> y\\<^sup>T \\<sqinter> y\\<^sup>\\<star> \\<squnion>\n          y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star>", "by auto"], ["proof (state)\nthis:\n  y\\<^sup>T \\<sqinter> (z \\<sqinter> y)\\<^sup>\\<star> \\<squnion>\n  y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star>\n  \\<le> y\\<^sup>T \\<sqinter> y\\<^sup>\\<star> \\<squnion>\n        y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "also"], ["proof (state)\nthis:\n  y\\<^sup>T \\<sqinter> (z \\<sqinter> y)\\<^sup>\\<star> \\<squnion>\n  y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star>\n  \\<le> y\\<^sup>T \\<sqinter> y\\<^sup>\\<star> \\<squnion>\n        y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "have \"... = y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>T \\<sqinter> y\\<^sup>\\<star> \\<squnion>\n    y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star> =\n    y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star>", "using 1 acyclic_star_below_complement_1 inf_commute"], ["proof (prove)\nusing this:\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y\n  pd_kleene_allegory_class.acyclic ?w =\n  (?w\\<^sup>\\<star> \\<sqinter> ?w\\<^sup>T = bot)\n  ?x \\<sqinter> ?y = ?y \\<sqinter> ?x\n\ngoal (1 subgoal):\n 1. y\\<^sup>T \\<sqinter> y\\<^sup>\\<star> \\<squnion>\n    y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star> =\n    y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star>", "by auto"], ["proof (state)\nthis:\n  y\\<^sup>T \\<sqinter> y\\<^sup>\\<star> \\<squnion>\n  y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star> =\n  y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "also"], ["proof (state)\nthis:\n  y\\<^sup>T \\<sqinter> y\\<^sup>\\<star> \\<squnion>\n  y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star> =\n  y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "have \"... \\<le> (z \\<sqinter> y\\<^sup>T) * (z\\<^sup>\\<star> \\<sqinter> (z \\<sqinter> y\\<^sup>T)\\<^sup>T * y\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star>\n    \\<le> (z \\<sqinter> y\\<^sup>T) *\n          (z\\<^sup>\\<star> \\<sqinter>\n           (z \\<sqinter> y\\<^sup>T)\\<^sup>T * y\\<^sup>T)", "using dedekind_1 inf_commute"], ["proof (prove)\nusing this:\n  ?x * ?y \\<sqinter> ?z \\<le> ?x * (?y \\<sqinter> ?x\\<^sup>T * ?z)\n  ?x \\<sqinter> ?y = ?y \\<sqinter> ?x\n\ngoal (1 subgoal):\n 1. y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star>\n    \\<le> (z \\<sqinter> y\\<^sup>T) *\n          (z\\<^sup>\\<star> \\<sqinter>\n           (z \\<sqinter> y\\<^sup>T)\\<^sup>T * y\\<^sup>T)", "by auto"], ["proof (state)\nthis:\n  y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star>\n  \\<le> (z \\<sqinter> y\\<^sup>T) *\n        (z\\<^sup>\\<star> \\<sqinter>\n         (z \\<sqinter> y\\<^sup>T)\\<^sup>T * y\\<^sup>T)\n\ngoal (1 subgoal):\n 1. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "also"], ["proof (state)\nthis:\n  y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T) * z\\<^sup>\\<star>\n  \\<le> (z \\<sqinter> y\\<^sup>T) *\n        (z\\<^sup>\\<star> \\<sqinter>\n         (z \\<sqinter> y\\<^sup>T)\\<^sup>T * y\\<^sup>T)\n\ngoal (1 subgoal):\n 1. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "have \"... \\<le> z * y * y\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<sqinter> y\\<^sup>T) *\n    (z\\<^sup>\\<star> \\<sqinter>\n     (z \\<sqinter> y\\<^sup>T)\\<^sup>T * y\\<^sup>T)\n    \\<le> z * y * y\\<^sup>T", "by (simp add: comp_associative comp_isotone conv_dist_inf inf.coboundedI2)"], ["proof (state)\nthis:\n  (z \\<sqinter> y\\<^sup>T) *\n  (z\\<^sup>\\<star> \\<sqinter> (z \\<sqinter> y\\<^sup>T)\\<^sup>T * y\\<^sup>T)\n  \\<le> z * y * y\\<^sup>T\n\ngoal (1 subgoal):\n 1. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "also"], ["proof (state)\nthis:\n  (z \\<sqinter> y\\<^sup>T) *\n  (z\\<^sup>\\<star> \\<sqinter> (z \\<sqinter> y\\<^sup>T)\\<^sup>T * y\\<^sup>T)\n  \\<le> z * y * y\\<^sup>T\n\ngoal (1 subgoal):\n 1. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "have \"... \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z * y * y\\<^sup>T \\<le> z", "using 1 mult_right_isotone mult_assoc"], ["proof (prove)\nusing this:\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n  ?a * ?b * ?c = ?a * (?b * ?c)\n\ngoal (1 subgoal):\n 1. z * y * y\\<^sup>T \\<le> z", "by fastforce"], ["proof (state)\nthis:\n  z * y * y\\<^sup>T \\<le> z\n\ngoal (1 subgoal):\n 1. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "finally"], ["proof (chain)\npicking this:\n  y\\<^sup>T \\<sqinter>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n  \\<le> z", "show \"y\\<^sup>T \\<sqinter> (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star> \\<le> z\""], ["proof (prove)\nusing this:\n  y\\<^sup>T \\<sqinter>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n  \\<le> z\n\ngoal (1 subgoal):\n 1. y\\<^sup>T \\<sqinter>\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n    \\<le> z", "."], ["proof (state)\nthis:\n  y\\<^sup>T \\<sqinter>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n  \\<le> z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<sqinter>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> *\n  (z \\<sqinter> y)\\<^sup>\\<star> \\<squnion>\n  y\\<^sup>T \\<sqinter>\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n  \\<le> z\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> \\<le> y", "finally"], ["proof (chain)\npicking this:\n  x \\<sqinter> z\\<^sup>\\<star> \\<le> z", "show \"x \\<sqinter> z\\<^sup>\\<star> \\<le> z\""], ["proof (prove)\nusing this:\n  x \\<sqinter> z\\<^sup>\\<star> \\<le> z\n\ngoal (1 subgoal):\n 1. x \\<sqinter> z\\<^sup>\\<star> \\<le> z", "."], ["proof (state)\nthis:\n  x \\<sqinter> z\\<^sup>\\<star> \\<le> z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  acyclic_4a x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 1.10\\<close>"], ["", "lemma top_injective_inf_complement:\n  assumes \"injective x\"\n  shows \"top * (x \\<sqinter> y) \\<sqinter> top * (x \\<sqinter> -y) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top * (x \\<sqinter> y) \\<sqinter> top * (x \\<sqinter> - y) = bot", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. top * (x \\<sqinter> y) \\<sqinter> top * (x \\<sqinter> - y) = bot", "have \"(x \\<sqinter> -y) * (x\\<^sup>T \\<sqinter> y\\<^sup>T) \\<le> -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreflexive ((x \\<sqinter> - y) * (x\\<^sup>T \\<sqinter> y\\<^sup>T))", "by (metis conv_dist_inf inf.cobounded2 inf_left_idem mult_left_one p_shunting_swap schroeder_4_p)"], ["proof (state)\nthis:\n  irreflexive ((x \\<sqinter> - y) * (x\\<^sup>T \\<sqinter> y\\<^sup>T))\n\ngoal (1 subgoal):\n 1. top * (x \\<sqinter> y) \\<sqinter> top * (x \\<sqinter> - y) = bot", "hence \"(x \\<sqinter> -y) * (x\\<^sup>T \\<sqinter> y\\<^sup>T) = bot\""], ["proof (prove)\nusing this:\n  irreflexive ((x \\<sqinter> - y) * (x\\<^sup>T \\<sqinter> y\\<^sup>T))\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> - y) * (x\\<^sup>T \\<sqinter> y\\<^sup>T) = bot", "by (smt assms comp_isotone coreflexive_comp_inf coreflexive_idempotent coreflexive_symmetric dual_order.trans inf.cobounded1 strict_order_var)"], ["proof (state)\nthis:\n  (x \\<sqinter> - y) * (x\\<^sup>T \\<sqinter> y\\<^sup>T) = bot\n\ngoal (1 subgoal):\n 1. top * (x \\<sqinter> y) \\<sqinter> top * (x \\<sqinter> - y) = bot", "thus ?thesis"], ["proof (prove)\nusing this:\n  (x \\<sqinter> - y) * (x\\<^sup>T \\<sqinter> y\\<^sup>T) = bot\n\ngoal (1 subgoal):\n 1. top * (x \\<sqinter> y) \\<sqinter> top * (x \\<sqinter> - y) = bot", "by (simp add: conv_dist_inf schroeder_2 mult_assoc)"], ["proof (state)\nthis:\n  top * (x \\<sqinter> y) \\<sqinter> top * (x \\<sqinter> - y) = bot\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma top_injective_inf_complement_2:\n  assumes \"injective x\"\n  shows \"(x\\<^sup>T \\<sqinter> y) * top \\<sqinter> (x\\<^sup>T \\<sqinter> -y) * top = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x\\<^sup>T \\<sqinter> y) * top \\<sqinter>\n    (x\\<^sup>T \\<sqinter> - y) * top =\n    bot", "by (smt assms top_injective_inf_complement conv_dist_comp conv_dist_inf conv_involutive conv_complement conv_top conv_bot)"], ["", "text \\<open>Theorem 10.3\\<close>"], ["", "lemma acyclic_6_implies_5a:\n  \"acyclic_6 x \\<Longrightarrow> acyclic_5a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_6 x \\<Longrightarrow> acyclic_5a x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. acyclic_6 x \\<Longrightarrow> acyclic_5a x", "assume \"acyclic_6 x\""], ["proof (state)\nthis:\n  acyclic_6 x\n\ngoal (1 subgoal):\n 1. acyclic_6 x \\<Longrightarrow> acyclic_5a x", "from this"], ["proof (chain)\npicking this:\n  acyclic_6 x", "obtain y where 1: \"y \\<squnion> y\\<^sup>T = x \\<and> acyclic y \\<and> injective y\""], ["proof (prove)\nusing this:\n  acyclic_6 x\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        y \\<squnion> y\\<^sup>T = x \\<and>\n        pd_kleene_allegory_class.acyclic y \\<and>\n        injective y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using acyclic_6_def"], ["proof (prove)\nusing this:\n  acyclic_6 x\n  acyclic_6 ?x \\<equiv>\n  \\<exists>y.\n     y \\<squnion> y\\<^sup>T = ?x \\<and>\n     pd_kleene_allegory_class.acyclic y \\<and> injective y\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        y \\<squnion> y\\<^sup>T = x \\<and>\n        pd_kleene_allegory_class.acyclic y \\<and>\n        injective y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y\n\ngoal (1 subgoal):\n 1. acyclic_6 x \\<Longrightarrow> acyclic_5a x", "show \"acyclic_5a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_5a x", "proof (unfold acyclic_5a_def, rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = (1::'a)", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = (1::'a)", "assume \"z \\<le> x\""], ["proof (state)\nthis:\n  z \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = (1::'a)", "hence 2: \"z = (z \\<sqinter> y) \\<squnion> (z \\<sqinter> y\\<^sup>T)\""], ["proof (prove)\nusing this:\n  z \\<le> x\n\ngoal (1 subgoal):\n 1. z = z \\<sqinter> y \\<squnion> z \\<sqinter> y\\<^sup>T", "by (metis 1 inf.orderE inf_sup_distrib1)"], ["proof (state)\nthis:\n  z = z \\<sqinter> y \\<squnion> z \\<sqinter> y\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = (1::'a)", "hence 3: \"z\\<^sup>\\<star> = (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  z = z \\<sqinter> y \\<squnion> z \\<sqinter> y\\<^sup>T\n\ngoal (1 subgoal):\n 1. z\\<^sup>\\<star> =\n    (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>", "by (metis 1 cancel_separate_2)"], ["proof (state)\nthis:\n  z\\<^sup>\\<star> =\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = (1::'a)", "have \"(x \\<sqinter> -z)\\<^sup>\\<star> = ((y \\<sqinter> -z) \\<squnion> (y\\<^sup>T \\<sqinter> -z))\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> - z)\\<^sup>\\<star> =\n    (y \\<sqinter> - z \\<squnion> y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star>", "using 1 inf_sup_distrib2"], ["proof (prove)\nusing this:\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y\n  (?y \\<squnion> ?z) \\<sqinter> ?x =\n  ?y \\<sqinter> ?x \\<squnion> ?z \\<sqinter> ?x\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> - z)\\<^sup>\\<star> =\n    (y \\<sqinter> - z \\<squnion> y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star>", "by auto"], ["proof (state)\nthis:\n  (x \\<sqinter> - z)\\<^sup>\\<star> =\n  (y \\<sqinter> - z \\<squnion> y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = (1::'a)", "also"], ["proof (state)\nthis:\n  (x \\<sqinter> - z)\\<^sup>\\<star> =\n  (y \\<sqinter> - z \\<squnion> y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = (1::'a)", "have \"... = (y\\<^sup>T \\<sqinter> -z)\\<^sup>\\<star> * (y \\<sqinter> -z)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<sqinter> - z \\<squnion> y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> =\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n    (y \\<sqinter> - z)\\<^sup>\\<star>", "using 1 cancel_separate_2 inf_commute"], ["proof (prove)\nusing this:\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y\n  coreflexive (?x * ?y) \\<Longrightarrow>\n  (?w \\<sqinter> ?x \\<squnion> ?z \\<sqinter> ?y)\\<^sup>\\<star> =\n  (?z \\<sqinter> ?y)\\<^sup>\\<star> * (?w \\<sqinter> ?x)\\<^sup>\\<star>\n  ?x \\<sqinter> ?y = ?y \\<sqinter> ?x\n\ngoal (1 subgoal):\n 1. (y \\<sqinter> - z \\<squnion> y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> =\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n    (y \\<sqinter> - z)\\<^sup>\\<star>", "by auto"], ["proof (state)\nthis:\n  (y \\<sqinter> - z \\<squnion> y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> =\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = (1::'a)", "finally"], ["proof (chain)\npicking this:\n  (x \\<sqinter> - z)\\<^sup>\\<star> =\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star>", "have \"z\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> -z)\\<^sup>\\<star> = (y\\<^sup>T \\<sqinter> z)\\<^sup>\\<star> * (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter> (y\\<^sup>T \\<sqinter> -z)\\<^sup>\\<star> * (y \\<sqinter> -z)\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  (x \\<sqinter> - z)\\<^sup>\\<star> =\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. z\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - z)\\<^sup>\\<star> =\n    (y\\<^sup>T \\<sqinter> z)\\<^sup>\\<star> *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n    (y \\<sqinter> - z)\\<^sup>\\<star>", "using 3 inf_commute"], ["proof (prove)\nusing this:\n  (x \\<sqinter> - z)\\<^sup>\\<star> =\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star>\n  z\\<^sup>\\<star> =\n  (z \\<sqinter> y\\<^sup>T)\\<^sup>\\<star> * (z \\<sqinter> y)\\<^sup>\\<star>\n  ?x \\<sqinter> ?y = ?y \\<sqinter> ?x\n\ngoal (1 subgoal):\n 1. z\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - z)\\<^sup>\\<star> =\n    (y\\<^sup>T \\<sqinter> z)\\<^sup>\\<star> *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n    (y \\<sqinter> - z)\\<^sup>\\<star>", "by simp"], ["proof (state)\nthis:\n  z\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - z)\\<^sup>\\<star> =\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>\\<star> *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = (1::'a)", "also"], ["proof (state)\nthis:\n  z\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - z)\\<^sup>\\<star> =\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>\\<star> *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = (1::'a)", "have \"... = ((y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter> (y\\<^sup>T \\<sqinter> -z)\\<^sup>\\<star> * (y \\<sqinter> -z)\\<^sup>\\<star>) \\<squnion> ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter> (y\\<^sup>T \\<sqinter> -z)\\<^sup>\\<star> * (y \\<sqinter> -z)\\<^sup>\\<star>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y\\<^sup>T \\<sqinter> z)\\<^sup>\\<star> *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n    (y \\<sqinter> - z)\\<^sup>\\<star> =\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n    (y \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n    (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n    (y \\<sqinter> - z)\\<^sup>\\<star>", "by (smt inf.sup_monoid.add_commute inf_sup_distrib1 star.circ_loop_fixpoint sup_commute mult_assoc)"], ["proof (state)\nthis:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>\\<star> *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star> =\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = (1::'a)", "also"], ["proof (state)\nthis:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>\\<star> *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star> =\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = (1::'a)", "have \"... = (1 \\<sqinter> (y\\<^sup>T \\<sqinter> -z)\\<^sup>\\<star> * (y \\<sqinter> -z)\\<^sup>\\<star>) \\<squnion> ((y \\<sqinter> z)\\<^sup>+ \\<sqinter> (y\\<^sup>T \\<sqinter> -z)\\<^sup>\\<star> * (y \\<sqinter> -z)\\<^sup>\\<star>) \\<squnion> ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter> (y\\<^sup>T \\<sqinter> -z)\\<^sup>\\<star> * (y \\<sqinter> -z)\\<^sup>\\<star>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n    (y \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n    (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n    (y \\<sqinter> - z)\\<^sup>\\<star> =\n    (1::'a) \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n    (y \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n    (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n    (y \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n    (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n    (y \\<sqinter> - z)\\<^sup>\\<star>", "by (metis inf_sup_distrib2 star_left_unfold_equal)"], ["proof (state)\nthis:\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star> =\n  (1::'a) \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n  (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = (1::'a)", "also"], ["proof (state)\nthis:\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star> =\n  (1::'a) \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n  (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = (1::'a)", "have \"... \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive\n     ((1::'a) \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n      (y \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n      (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n      (y \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n      (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n      (y \\<sqinter> - z)\\<^sup>\\<star>)", "proof (intro sup_least)"], ["proof (state)\ngoal (3 subgoals):\n 1. coreflexive\n     ((1::'a) \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n      (y \\<sqinter> - z)\\<^sup>\\<star>)\n 2. coreflexive\n     ((y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n      (y \\<sqinter> - z)\\<^sup>\\<star>)\n 3. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n      (y \\<sqinter> - z)\\<^sup>\\<star>)", "show \"1 \\<sqinter> (y\\<^sup>T \\<sqinter> -z)\\<^sup>\\<star> * (y \\<sqinter> -z)\\<^sup>\\<star> \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive\n     ((1::'a) \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n      (y \\<sqinter> - z)\\<^sup>\\<star>)", "by simp"], ["proof (state)\nthis:\n  coreflexive\n   ((1::'a) \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n    (y \\<sqinter> - z)\\<^sup>\\<star>)\n\ngoal (2 subgoals):\n 1. coreflexive\n     ((y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n      (y \\<sqinter> - z)\\<^sup>\\<star>)\n 2. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n      (y \\<sqinter> - z)\\<^sup>\\<star>)", "have \"(y \\<sqinter> z)\\<^sup>+ \\<sqinter> (y\\<^sup>T \\<sqinter> -z)\\<^sup>\\<star> * (y \\<sqinter> -z)\\<^sup>\\<star> = ((y \\<sqinter> z)\\<^sup>+ \\<sqinter> (y\\<^sup>T \\<sqinter> -z)\\<^sup>\\<star>) \\<squnion> ((y \\<sqinter> z)\\<^sup>+ \\<sqinter> (y\\<^sup>T \\<sqinter> -z)\\<^sup>\\<star> * (y \\<sqinter> -z)\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n    (y \\<sqinter> - z)\\<^sup>\\<star> =\n    (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n    (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> * (y \\<sqinter> - z)\\<^sup>+", "by (metis inf_sup_distrib1 star.circ_back_loop_fixpoint star.circ_plus_same sup_commute mult_assoc)"], ["proof (state)\nthis:\n  (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star> =\n  (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n  (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> * (y \\<sqinter> - z)\\<^sup>+\n\ngoal (2 subgoals):\n 1. coreflexive\n     ((y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n      (y \\<sqinter> - z)\\<^sup>\\<star>)\n 2. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n      (y \\<sqinter> - z)\\<^sup>\\<star>)", "also"], ["proof (state)\nthis:\n  (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star> =\n  (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n  (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> * (y \\<sqinter> - z)\\<^sup>+\n\ngoal (2 subgoals):\n 1. coreflexive\n     ((y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n      (y \\<sqinter> - z)\\<^sup>\\<star>)\n 2. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n      (y \\<sqinter> - z)\\<^sup>\\<star>)", "have \"... \\<le> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n    (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> * (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot", "proof (rule sup_least)"], ["proof (state)\ngoal (2 subgoals):\n 1. (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star>\n    \\<le> bot\n 2. (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> * (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot", "have \"(y \\<sqinter> z)\\<^sup>+ \\<sqinter> (y\\<^sup>T \\<sqinter> -z)\\<^sup>\\<star> \\<le> y\\<^sup>+ \\<sqinter> y\\<^sup>T\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star>\n    \\<le> y\\<^sup>+ \\<sqinter> y\\<^sup>T\\<^sup>\\<star>", "by (meson comp_inf.mult_isotone comp_isotone inf.cobounded1 star_isotone)"], ["proof (state)\nthis:\n  (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star>\n  \\<le> y\\<^sup>+ \\<sqinter> y\\<^sup>T\\<^sup>\\<star>\n\ngoal (2 subgoals):\n 1. (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star>\n    \\<le> bot\n 2. (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> * (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot", "also"], ["proof (state)\nthis:\n  (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star>\n  \\<le> y\\<^sup>+ \\<sqinter> y\\<^sup>T\\<^sup>\\<star>\n\ngoal (2 subgoals):\n 1. (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star>\n    \\<le> bot\n 2. (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> * (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot", "have \"... = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>+ \\<sqinter> y\\<^sup>T\\<^sup>\\<star> = bot", "using 1"], ["proof (prove)\nusing this:\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y\n\ngoal (1 subgoal):\n 1. y\\<^sup>+ \\<sqinter> y\\<^sup>T\\<^sup>\\<star> = bot", "by (smt acyclic_star_inf_conv inf.orderE inf.sup_monoid.add_assoc pseudo_complement star.left_plus_below_circ)"], ["proof (state)\nthis:\n  y\\<^sup>+ \\<sqinter> y\\<^sup>T\\<^sup>\\<star> = bot\n\ngoal (2 subgoals):\n 1. (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star>\n    \\<le> bot\n 2. (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> * (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot", "finally"], ["proof (chain)\npicking this:\n  (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star>\n  \\<le> bot", "show \"(y \\<sqinter> z)\\<^sup>+ \\<sqinter> (y\\<^sup>T \\<sqinter> -z)\\<^sup>\\<star> \\<le> bot\""], ["proof (prove)\nusing this:\n  (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star>\n  \\<le> bot\n\ngoal (1 subgoal):\n 1. (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star>\n    \\<le> bot", "."], ["proof (state)\nthis:\n  (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star>\n  \\<le> bot\n\ngoal (1 subgoal):\n 1. (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> * (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot", "have \"(y \\<sqinter> z)\\<^sup>+ \\<sqinter> (y\\<^sup>T \\<sqinter> -z)\\<^sup>\\<star> * (y \\<sqinter> -z)\\<^sup>+ \\<le> top * (y \\<sqinter> z) \\<sqinter> top * (y \\<sqinter> -z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> * (y \\<sqinter> - z)\\<^sup>+\n    \\<le> top * (y \\<sqinter> z) \\<sqinter> top * (y \\<sqinter> - z)", "by (metis comp_associative comp_inf.mult_isotone star.circ_left_top star.circ_plus_same top_left_mult_increasing)"], ["proof (state)\nthis:\n  (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> * (y \\<sqinter> - z)\\<^sup>+\n  \\<le> top * (y \\<sqinter> z) \\<sqinter> top * (y \\<sqinter> - z)\n\ngoal (1 subgoal):\n 1. (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> * (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot", "also"], ["proof (state)\nthis:\n  (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> * (y \\<sqinter> - z)\\<^sup>+\n  \\<le> top * (y \\<sqinter> z) \\<sqinter> top * (y \\<sqinter> - z)\n\ngoal (1 subgoal):\n 1. (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> * (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot", "have \"... = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top * (y \\<sqinter> z) \\<sqinter> top * (y \\<sqinter> - z) = bot", "using 1"], ["proof (prove)\nusing this:\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y\n\ngoal (1 subgoal):\n 1. top * (y \\<sqinter> z) \\<sqinter> top * (y \\<sqinter> - z) = bot", "by (simp add: top_injective_inf_complement)"], ["proof (state)\nthis:\n  top * (y \\<sqinter> z) \\<sqinter> top * (y \\<sqinter> - z) = bot\n\ngoal (1 subgoal):\n 1. (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> * (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot", "finally"], ["proof (chain)\npicking this:\n  (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> * (y \\<sqinter> - z)\\<^sup>+\n  \\<le> bot", "show \"(y \\<sqinter> z)\\<^sup>+ \\<sqinter> (y\\<^sup>T \\<sqinter> -z)\\<^sup>\\<star> * (y \\<sqinter> -z)\\<^sup>+ \\<le> bot\""], ["proof (prove)\nusing this:\n  (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> * (y \\<sqinter> - z)\\<^sup>+\n  \\<le> bot\n\ngoal (1 subgoal):\n 1. (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> * (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot", "."], ["proof (state)\nthis:\n  (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> * (y \\<sqinter> - z)\\<^sup>+\n  \\<le> bot\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n  (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> * (y \\<sqinter> - z)\\<^sup>+\n  \\<le> bot\n\ngoal (2 subgoals):\n 1. coreflexive\n     ((y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n      (y \\<sqinter> - z)\\<^sup>\\<star>)\n 2. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n      (y \\<sqinter> - z)\\<^sup>\\<star>)", "finally"], ["proof (chain)\npicking this:\n  (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star>\n  \\<le> bot", "show \"(y \\<sqinter> z)\\<^sup>+ \\<sqinter> (y\\<^sup>T \\<sqinter> -z)\\<^sup>\\<star> * (y \\<sqinter> -z)\\<^sup>\\<star> \\<le> 1\""], ["proof (prove)\nusing this:\n  (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star>\n  \\<le> bot\n\ngoal (1 subgoal):\n 1. coreflexive\n     ((y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n      (y \\<sqinter> - z)\\<^sup>\\<star>)", "using bot_least le_bot"], ["proof (prove)\nusing this:\n  (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star>\n  \\<le> bot\n  bot \\<le> ?a\n  ?a \\<le> bot \\<Longrightarrow> ?a = bot\n\ngoal (1 subgoal):\n 1. coreflexive\n     ((y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n      (y \\<sqinter> - z)\\<^sup>\\<star>)", "by blast"], ["proof (state)\nthis:\n  coreflexive\n   ((y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n    (y \\<sqinter> - z)\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n      (y \\<sqinter> - z)\\<^sup>\\<star>)", "have \"(y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter> (y\\<^sup>T \\<sqinter> -z)\\<^sup>\\<star> * (y \\<sqinter> -z)\\<^sup>\\<star> = ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter> (y \\<sqinter> -z)\\<^sup>\\<star>) \\<squnion> ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter> (y\\<^sup>T \\<sqinter> -z)\\<^sup>+ * (y \\<sqinter> -z)\\<^sup>\\<star>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n    (y \\<sqinter> - z)\\<^sup>\\<star> =\n    (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n    (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>", "by (metis inf_sup_distrib1 star.circ_loop_fixpoint sup_commute mult_assoc)"], ["proof (state)\nthis:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star> =\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n      (y \\<sqinter> - z)\\<^sup>\\<star>)", "also"], ["proof (state)\nthis:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n  (y \\<sqinter> - z)\\<^sup>\\<star> =\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n      (y \\<sqinter> - z)\\<^sup>\\<star>)", "have \"... = ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter> 1) \\<squnion> ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter> (y \\<sqinter> -z)\\<^sup>+) \\<squnion> ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter> (y\\<^sup>T \\<sqinter> -z)\\<^sup>+ * (y \\<sqinter> -z)\\<^sup>\\<star>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n    (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star> =\n    (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (1::'a) \\<squnion>\n    (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y \\<sqinter> - z)\\<^sup>+ \\<squnion>\n    (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>", "by (metis inf_sup_distrib1 star_left_unfold_equal)"], ["proof (state)\nthis:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star> =\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (1::'a) \\<squnion>\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y \\<sqinter> - z)\\<^sup>+ \\<squnion>\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n      (y \\<sqinter> - z)\\<^sup>\\<star>)", "also"], ["proof (state)\nthis:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star> =\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (1::'a) \\<squnion>\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y \\<sqinter> - z)\\<^sup>+ \\<squnion>\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n      (y \\<sqinter> - z)\\<^sup>\\<star>)", "have \"... \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (1::'a) \\<squnion>\n      (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y \\<sqinter> - z)\\<^sup>+ \\<squnion>\n      (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>)", "proof (intro sup_least)"], ["proof (state)\ngoal (3 subgoals):\n 1. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (1::'a))\n 2. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y \\<sqinter> - z)\\<^sup>+)\n 3. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>)", "show \"(y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter> 1 \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (1::'a))", "by simp"], ["proof (state)\nthis:\n  coreflexive\n   ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (1::'a))\n\ngoal (2 subgoals):\n 1. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y \\<sqinter> - z)\\<^sup>+)\n 2. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>)", "have \"(y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter> (y \\<sqinter> -z)\\<^sup>+ = ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ \\<sqinter> (y \\<sqinter> -z)\\<^sup>+) \\<squnion> ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>+ \\<sqinter> (y \\<sqinter> -z)\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y \\<sqinter> - z)\\<^sup>+ =\n    (y\\<^sup>T \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y \\<sqinter> - z)\\<^sup>+ \\<squnion>\n    (y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y \\<sqinter> - z)\\<^sup>+", "by (smt inf.sup_monoid.add_commute inf_sup_distrib1 star.circ_back_loop_fixpoint star.circ_plus_same sup_commute mult_assoc)"], ["proof (state)\nthis:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y \\<sqinter> - z)\\<^sup>+ =\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y \\<sqinter> - z)\\<^sup>+ \\<squnion>\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y \\<sqinter> - z)\\<^sup>+\n\ngoal (2 subgoals):\n 1. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y \\<sqinter> - z)\\<^sup>+)\n 2. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>)", "also"], ["proof (state)\nthis:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y \\<sqinter> - z)\\<^sup>+ =\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y \\<sqinter> - z)\\<^sup>+ \\<squnion>\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y \\<sqinter> - z)\\<^sup>+\n\ngoal (2 subgoals):\n 1. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y \\<sqinter> - z)\\<^sup>+)\n 2. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>)", "have \"... \\<le> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y\\<^sup>T \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y \\<sqinter> - z)\\<^sup>+ \\<squnion>\n    (y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot", "proof (rule sup_least)"], ["proof (state)\ngoal (2 subgoals):\n 1. (y\\<^sup>T \\<sqinter> z)\\<^sup>+ \\<sqinter> (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot\n 2. (y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot", "have \"(y\\<^sup>T \\<sqinter> z)\\<^sup>+ \\<sqinter> (y \\<sqinter> -z)\\<^sup>+ \\<le> y\\<^sup>T\\<^sup>+ \\<sqinter> y\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y\\<^sup>T \\<sqinter> z)\\<^sup>+ \\<sqinter> (y \\<sqinter> - z)\\<^sup>+\n    \\<le> y\\<^sup>T\\<^sup>+ \\<sqinter> y\\<^sup>+", "by (meson comp_inf.mult_isotone comp_isotone inf.cobounded1 star_isotone)"], ["proof (state)\nthis:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ \\<sqinter> (y \\<sqinter> - z)\\<^sup>+\n  \\<le> y\\<^sup>T\\<^sup>+ \\<sqinter> y\\<^sup>+\n\ngoal (2 subgoals):\n 1. (y\\<^sup>T \\<sqinter> z)\\<^sup>+ \\<sqinter> (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot\n 2. (y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot", "also"], ["proof (state)\nthis:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ \\<sqinter> (y \\<sqinter> - z)\\<^sup>+\n  \\<le> y\\<^sup>T\\<^sup>+ \\<sqinter> y\\<^sup>+\n\ngoal (2 subgoals):\n 1. (y\\<^sup>T \\<sqinter> z)\\<^sup>+ \\<sqinter> (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot\n 2. (y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot", "have \"... = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>T\\<^sup>+ \\<sqinter> y\\<^sup>+ = bot", "using 1"], ["proof (prove)\nusing this:\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y\n\ngoal (1 subgoal):\n 1. y\\<^sup>T\\<^sup>+ \\<sqinter> y\\<^sup>+ = bot", "by (metis acyclic_asymmetric conv_inf_bot_iff conv_plus_commute star_sup_1 sup.idem mult_assoc)"], ["proof (state)\nthis:\n  y\\<^sup>T\\<^sup>+ \\<sqinter> y\\<^sup>+ = bot\n\ngoal (2 subgoals):\n 1. (y\\<^sup>T \\<sqinter> z)\\<^sup>+ \\<sqinter> (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot\n 2. (y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot", "finally"], ["proof (chain)\npicking this:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ \\<sqinter> (y \\<sqinter> - z)\\<^sup>+\n  \\<le> bot", "show \"(y\\<^sup>T \\<sqinter> z)\\<^sup>+ \\<sqinter> (y \\<sqinter> -z)\\<^sup>+ \\<le> bot\""], ["proof (prove)\nusing this:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ \\<sqinter> (y \\<sqinter> - z)\\<^sup>+\n  \\<le> bot\n\ngoal (1 subgoal):\n 1. (y\\<^sup>T \\<sqinter> z)\\<^sup>+ \\<sqinter> (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot", "."], ["proof (state)\nthis:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ \\<sqinter> (y \\<sqinter> - z)\\<^sup>+\n  \\<le> bot\n\ngoal (1 subgoal):\n 1. (y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot", "have \"(y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>+ \\<sqinter> (y \\<sqinter> -z)\\<^sup>+ \\<le> top * (y \\<sqinter> z) \\<sqinter> top * (y \\<sqinter> -z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y \\<sqinter> - z)\\<^sup>+\n    \\<le> top * (y \\<sqinter> z) \\<sqinter> top * (y \\<sqinter> - z)", "by (smt comp_inf.mult_isotone comp_isotone inf.cobounded1 inf.orderE star.circ_plus_same top.extremum mult_assoc)"], ["proof (state)\nthis:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y \\<sqinter> - z)\\<^sup>+\n  \\<le> top * (y \\<sqinter> z) \\<sqinter> top * (y \\<sqinter> - z)\n\ngoal (1 subgoal):\n 1. (y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot", "also"], ["proof (state)\nthis:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y \\<sqinter> - z)\\<^sup>+\n  \\<le> top * (y \\<sqinter> z) \\<sqinter> top * (y \\<sqinter> - z)\n\ngoal (1 subgoal):\n 1. (y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot", "have \"... = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top * (y \\<sqinter> z) \\<sqinter> top * (y \\<sqinter> - z) = bot", "using 1"], ["proof (prove)\nusing this:\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y\n\ngoal (1 subgoal):\n 1. top * (y \\<sqinter> z) \\<sqinter> top * (y \\<sqinter> - z) = bot", "by (simp add: top_injective_inf_complement)"], ["proof (state)\nthis:\n  top * (y \\<sqinter> z) \\<sqinter> top * (y \\<sqinter> - z) = bot\n\ngoal (1 subgoal):\n 1. (y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot", "finally"], ["proof (chain)\npicking this:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y \\<sqinter> - z)\\<^sup>+\n  \\<le> bot", "show \"(y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>+ \\<sqinter> (y \\<sqinter> -z)\\<^sup>+ \\<le> bot\""], ["proof (prove)\nusing this:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y \\<sqinter> - z)\\<^sup>+\n  \\<le> bot\n\ngoal (1 subgoal):\n 1. (y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y \\<sqinter> - z)\\<^sup>+\n    \\<le> bot", "."], ["proof (state)\nthis:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y \\<sqinter> - z)\\<^sup>+\n  \\<le> bot\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y \\<sqinter> - z)\\<^sup>+ \\<squnion>\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n  (y \\<sqinter> - z)\\<^sup>+\n  \\<le> bot\n\ngoal (2 subgoals):\n 1. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y \\<sqinter> - z)\\<^sup>+)\n 2. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>)", "finally"], ["proof (chain)\npicking this:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y \\<sqinter> - z)\\<^sup>+\n  \\<le> bot", "show \"(y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter> (y \\<sqinter> -z)\\<^sup>+ \\<le> 1\""], ["proof (prove)\nusing this:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y \\<sqinter> - z)\\<^sup>+\n  \\<le> bot\n\ngoal (1 subgoal):\n 1. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y \\<sqinter> - z)\\<^sup>+)", "using bot_least le_bot"], ["proof (prove)\nusing this:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y \\<sqinter> - z)\\<^sup>+\n  \\<le> bot\n  bot \\<le> ?a\n  ?a \\<le> bot \\<Longrightarrow> ?a = bot\n\ngoal (1 subgoal):\n 1. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y \\<sqinter> - z)\\<^sup>+)", "by blast"], ["proof (state)\nthis:\n  coreflexive\n   ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y \\<sqinter> - z)\\<^sup>+)\n\ngoal (1 subgoal):\n 1. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>)", "have \"(y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter> (y\\<^sup>T \\<sqinter> -z)\\<^sup>+ * (y \\<sqinter> -z)\\<^sup>\\<star> \\<le> (y\\<^sup>T \\<sqinter> z) * top \\<sqinter> (y\\<^sup>T \\<sqinter> -z) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>\n    \\<le> (y\\<^sup>T \\<sqinter> z) * top \\<sqinter>\n          (y\\<^sup>T \\<sqinter> - z) * top", "by (smt comp_inf.mult_isotone comp_isotone eq_iff top.extremum mult_assoc)"], ["proof (state)\nthis:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>\n  \\<le> (y\\<^sup>T \\<sqinter> z) * top \\<sqinter>\n        (y\\<^sup>T \\<sqinter> - z) * top\n\ngoal (1 subgoal):\n 1. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>)", "also"], ["proof (state)\nthis:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>\n  \\<le> (y\\<^sup>T \\<sqinter> z) * top \\<sqinter>\n        (y\\<^sup>T \\<sqinter> - z) * top\n\ngoal (1 subgoal):\n 1. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>)", "have \"... = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y\\<^sup>T \\<sqinter> z) * top \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z) * top =\n    bot", "using 1"], ["proof (prove)\nusing this:\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y\n\ngoal (1 subgoal):\n 1. (y\\<^sup>T \\<sqinter> z) * top \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z) * top =\n    bot", "by (simp add: top_injective_inf_complement_2)"], ["proof (state)\nthis:\n  (y\\<^sup>T \\<sqinter> z) * top \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z) * top =\n  bot\n\ngoal (1 subgoal):\n 1. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>)", "finally"], ["proof (chain)\npicking this:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>\n  \\<le> bot", "show \"(y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter> (y\\<^sup>T \\<sqinter> -z)\\<^sup>+ * (y \\<sqinter> -z)\\<^sup>\\<star> \\<le> 1\""], ["proof (prove)\nusing this:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>\n  \\<le> bot\n\ngoal (1 subgoal):\n 1. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>)", "using bot_least le_bot"], ["proof (prove)\nusing this:\n  (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n  (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n  (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>\n  \\<le> bot\n  bot \\<le> ?a\n  ?a \\<le> bot \\<Longrightarrow> ?a = bot\n\ngoal (1 subgoal):\n 1. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>)", "by blast"], ["proof (state)\nthis:\n  coreflexive\n   ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coreflexive\n   ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (1::'a) \\<squnion>\n    (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y \\<sqinter> - z)\\<^sup>+ \\<squnion>\n    (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>+ * (y \\<sqinter> - z)\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n      (y \\<sqinter> - z)\\<^sup>\\<star>)", "finally"], ["proof (chain)\npicking this:\n  coreflexive\n   ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n    (y \\<sqinter> - z)\\<^sup>\\<star>)", "show \"(y\\<^sup>T \\<sqinter> z)\\<^sup>+ * (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter> (y\\<^sup>T \\<sqinter> -z)\\<^sup>\\<star> * (y \\<sqinter> -z)\\<^sup>\\<star> \\<le> 1\""], ["proof (prove)\nusing this:\n  coreflexive\n   ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n    (y \\<sqinter> - z)\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. coreflexive\n     ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n      (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n      (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n      (y \\<sqinter> - z)\\<^sup>\\<star>)", "."], ["proof (state)\nthis:\n  coreflexive\n   ((y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n    (y \\<sqinter> - z)\\<^sup>\\<star>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coreflexive\n   ((1::'a) \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n    (y \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n    (y \\<sqinter> z)\\<^sup>+ \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n    (y \\<sqinter> - z)\\<^sup>\\<star> \\<squnion>\n    (y\\<^sup>T \\<sqinter> z)\\<^sup>+ *\n    (y \\<sqinter> z)\\<^sup>\\<star> \\<sqinter>\n    (y\\<^sup>T \\<sqinter> - z)\\<^sup>\\<star> *\n    (y \\<sqinter> - z)\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = (1::'a)", "finally"], ["proof (chain)\npicking this:\n  coreflexive (z\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - z)\\<^sup>\\<star>)", "show \"z\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> -z)\\<^sup>\\<star> = 1\""], ["proof (prove)\nusing this:\n  coreflexive (z\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - z)\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. z\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - z)\\<^sup>\\<star> = (1::'a)", "by (simp add: antisym star.circ_reflexive)"], ["proof (state)\nthis:\n  z\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - z)\\<^sup>\\<star> = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  acyclic_5a x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 9.7\\<close>"], ["", "lemma acyclic_5b_implies_4:\n  assumes \"irreflexive x\"\n      and \"acyclic_5b x\"\n    shows \"acyclic_4 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_4 x", "proof (unfold acyclic_4_def, rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y", "assume \"y \\<le> x\""], ["proof (state)\nthis:\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y", "hence \"y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> -y)\\<^sup>+ \\<le> 1\""], ["proof (prove)\nusing this:\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. coreflexive (y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>+)", "using acyclic_5b_def assms(2)"], ["proof (prove)\nusing this:\n  y \\<le> x\n  acyclic_5b ?x \\<equiv>\n  \\<forall>y\\<le>?x.\n     coreflexive (y\\<^sup>\\<star> \\<sqinter> (?x \\<sqinter> - y)\\<^sup>+)\n  acyclic_5b x\n\ngoal (1 subgoal):\n 1. coreflexive (y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>+)", "by blast"], ["proof (state)\nthis:\n  coreflexive (y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y", "hence \"y\\<^sup>\\<star> \\<sqinter> x \\<sqinter> -y \\<le> 1\""], ["proof (prove)\nusing this:\n  coreflexive (y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>+)\n\ngoal (1 subgoal):\n 1. coreflexive (y\\<^sup>\\<star> \\<sqinter> x \\<sqinter> - y)", "by (smt inf.sup_left_divisibility inf.sup_monoid.add_assoc star.circ_mult_increasing)"], ["proof (state)\nthis:\n  coreflexive (y\\<^sup>\\<star> \\<sqinter> x \\<sqinter> - y)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y", "hence \"y\\<^sup>\\<star> \\<sqinter> x \\<sqinter> -y = bot\""], ["proof (prove)\nusing this:\n  coreflexive (y\\<^sup>\\<star> \\<sqinter> x \\<sqinter> - y)\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> \\<sqinter> x \\<sqinter> - y = bot", "by (smt assms(1) comp_inf.semiring.mult_zero_left inf.orderE inf.sup_monoid.add_assoc inf.sup_monoid.add_commute pseudo_complement)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> \\<sqinter> x \\<sqinter> - y = bot\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y", "thus \"x \\<sqinter> y\\<^sup>\\<star> \\<le> --y\""], ["proof (prove)\nusing this:\n  y\\<^sup>\\<star> \\<sqinter> x \\<sqinter> - y = bot\n\ngoal (1 subgoal):\n 1. x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y", "using inf.sup_monoid.add_commute pseudo_complement"], ["proof (prove)\nusing this:\n  y\\<^sup>\\<star> \\<sqinter> x \\<sqinter> - y = bot\n  ?a \\<sqinter> ?b = ?b \\<sqinter> ?a\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y", "by fastforce"], ["proof (state)\nthis:\n  x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 9\\<close>"], ["", "lemma acyclic_5a_5b:\n  \"acyclic_5a x \\<longleftrightarrow> acyclic_5b x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_5a x = acyclic_5b x", "by (simp add: acyclic_5a_def acyclic_5b_def star.circ_reflexive reflexive_inf_plus_star)"], ["", "text \\<open>Theorem 9\\<close>"], ["", "lemma acyclic_5a_5c:\n  \"acyclic_5a x \\<longleftrightarrow> acyclic_5c x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_5a x = acyclic_5c x", "by (metis acyclic_5a_def acyclic_5c_def inf_commute star.circ_reflexive reflexive_inf_plus_star)"], ["", "text \\<open>Theorem 9\\<close>"], ["", "lemma acyclic_5b_5d:\n  \"acyclic_5b x \\<longleftrightarrow> acyclic_5d x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_5b x = acyclic_5d x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. acyclic_5b x = acyclic_5d x", "have \"acyclic_5b x \\<longleftrightarrow> (\\<forall>y . y \\<le> x \\<longrightarrow> (y\\<^sup>+ \\<squnion> 1) \\<sqinter> (x \\<sqinter> -y)\\<^sup>+ \\<le> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_5b x =\n    (\\<forall>y\\<le>x.\n        coreflexive\n         ((y\\<^sup>+ \\<squnion> (1::'a)) \\<sqinter>\n          (x \\<sqinter> - y)\\<^sup>+))", "by (simp add: acyclic_5b_def star_left_unfold_equal sup_commute)"], ["proof (state)\nthis:\n  acyclic_5b x =\n  (\\<forall>y\\<le>x.\n      coreflexive\n       ((y\\<^sup>+ \\<squnion> (1::'a)) \\<sqinter>\n        (x \\<sqinter> - y)\\<^sup>+))\n\ngoal (1 subgoal):\n 1. acyclic_5b x = acyclic_5d x", "also"], ["proof (state)\nthis:\n  acyclic_5b x =\n  (\\<forall>y\\<le>x.\n      coreflexive\n       ((y\\<^sup>+ \\<squnion> (1::'a)) \\<sqinter>\n        (x \\<sqinter> - y)\\<^sup>+))\n\ngoal (1 subgoal):\n 1. acyclic_5b x = acyclic_5d x", "have \"... \\<longleftrightarrow> acyclic_5d x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>y\\<le>x.\n        coreflexive\n         ((y\\<^sup>+ \\<squnion> (1::'a)) \\<sqinter>\n          (x \\<sqinter> - y)\\<^sup>+)) =\n    acyclic_5d x", "by (simp add: inf_sup_distrib2 acyclic_5d_def)"], ["proof (state)\nthis:\n  (\\<forall>y\\<le>x.\n      coreflexive\n       ((y\\<^sup>+ \\<squnion> (1::'a)) \\<sqinter>\n        (x \\<sqinter> - y)\\<^sup>+)) =\n  acyclic_5d x\n\ngoal (1 subgoal):\n 1. acyclic_5b x = acyclic_5d x", "finally"], ["proof (chain)\npicking this:\n  acyclic_5b x = acyclic_5d x", "show ?thesis"], ["proof (prove)\nusing this:\n  acyclic_5b x = acyclic_5d x\n\ngoal (1 subgoal):\n 1. acyclic_5b x = acyclic_5d x", "."], ["proof (state)\nthis:\n  acyclic_5b x = acyclic_5d x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma acyclic_5a_5e:\n  \"acyclic_5a x \\<longleftrightarrow> acyclic_5e x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_5a x = acyclic_5e x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. acyclic_5a x \\<Longrightarrow> acyclic_5e x\n 2. acyclic_5e x \\<Longrightarrow> acyclic_5a x", "assume 1: \"acyclic_5a x\""], ["proof (state)\nthis:\n  acyclic_5a x\n\ngoal (2 subgoals):\n 1. acyclic_5a x \\<Longrightarrow> acyclic_5e x\n 2. acyclic_5e x \\<Longrightarrow> acyclic_5a x", "show \"acyclic_5e x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_5e x", "proof (unfold acyclic_5e_def, intro allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       y \\<le> x \\<and>\n       z \\<le> x \\<and> y \\<sqinter> z = bot \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = (1::'a)", "fix y z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       y \\<le> x \\<and>\n       z \\<le> x \\<and> y \\<sqinter> z = bot \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = (1::'a)", "assume 2: \"y \\<le> x \\<and> z \\<le> x \\<and> y \\<sqinter> z = bot\""], ["proof (state)\nthis:\n  y \\<le> x \\<and> z \\<le> x \\<and> y \\<sqinter> z = bot\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       y \\<le> x \\<and>\n       z \\<le> x \\<and> y \\<sqinter> z = bot \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = (1::'a)", "hence \"z \\<le> x \\<sqinter> -y\""], ["proof (prove)\nusing this:\n  y \\<le> x \\<and> z \\<le> x \\<and> y \\<sqinter> z = bot\n\ngoal (1 subgoal):\n 1. z \\<le> x \\<sqinter> - y", "using p_antitone_iff pseudo_complement"], ["proof (prove)\nusing this:\n  y \\<le> x \\<and> z \\<le> x \\<and> y \\<sqinter> z = bot\n  (?x \\<le> - ?y) = (?y \\<le> - ?x)\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. z \\<le> x \\<sqinter> - y", "by auto"], ["proof (state)\nthis:\n  z \\<le> x \\<sqinter> - y\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       y \\<le> x \\<and>\n       z \\<le> x \\<and> y \\<sqinter> z = bot \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = (1::'a)", "hence \"y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> \\<le> 1\""], ["proof (prove)\nusing this:\n  z \\<le> x \\<sqinter> - y\n\ngoal (1 subgoal):\n 1. coreflexive (y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star>)", "using 1 2"], ["proof (prove)\nusing this:\n  z \\<le> x \\<sqinter> - y\n  acyclic_5a x\n  y \\<le> x \\<and> z \\<le> x \\<and> y \\<sqinter> z = bot\n\ngoal (1 subgoal):\n 1. coreflexive (y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star>)", "by (metis acyclic_5a_def comp_inf.mult_isotone inf.cobounded1 inf.right_idem star_isotone)"], ["proof (state)\nthis:\n  coreflexive (y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       y \\<le> x \\<and>\n       z \\<le> x \\<and> y \\<sqinter> z = bot \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = (1::'a)", "thus \"y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = 1\""], ["proof (prove)\nusing this:\n  coreflexive (y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = (1::'a)", "by (simp add: antisym star.circ_reflexive)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  acyclic_5e x\n\ngoal (1 subgoal):\n 1. acyclic_5e x \\<Longrightarrow> acyclic_5a x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. acyclic_5e x \\<Longrightarrow> acyclic_5a x", "assume 1: \"acyclic_5e x\""], ["proof (state)\nthis:\n  acyclic_5e x\n\ngoal (1 subgoal):\n 1. acyclic_5e x \\<Longrightarrow> acyclic_5a x", "show \"acyclic_5a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_5a x", "proof (unfold acyclic_5a_def, rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = (1::'a)", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = (1::'a)", "let ?z = \"x \\<sqinter> -y\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = (1::'a)", "assume 2: \"y \\<le> x\""], ["proof (state)\nthis:\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = (1::'a)", "have \"y \\<sqinter> ?z = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sqinter> (x \\<sqinter> - y) = bot", "by (simp add: inf.left_commute)"], ["proof (state)\nthis:\n  y \\<sqinter> (x \\<sqinter> - y) = bot\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = (1::'a)", "thus \"y\\<^sup>\\<star> \\<sqinter> ?z\\<^sup>\\<star> = 1\""], ["proof (prove)\nusing this:\n  y \\<sqinter> (x \\<sqinter> - y) = bot\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = (1::'a)", "using 1 2"], ["proof (prove)\nusing this:\n  y \\<sqinter> (x \\<sqinter> - y) = bot\n  acyclic_5e x\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = (1::'a)", "by (simp add: acyclic_5e_def)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  acyclic_5a x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 9\\<close>"], ["", "lemma acyclic_5e_5f:\n  \"acyclic_5e x \\<longleftrightarrow> acyclic_5f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_5e x = acyclic_5f x", "by (simp add: acyclic_5e_def acyclic_5f_def)"], ["", "lemma acyclic_5e_down_closed:\n  assumes \"x \\<le> y\"\n      and \"acyclic_5e y\"\n    shows \"acyclic_5e x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_5e x", "using assms acyclic_5e_def order.trans"], ["proof (prove)\nusing this:\n  x \\<le> y\n  acyclic_5e y\n  acyclic_5e ?x \\<equiv>\n  \\<forall>y z.\n     y \\<le> ?x \\<and>\n     z \\<le> ?x \\<and> y \\<sqinter> z = bot \\<longrightarrow>\n     y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = (1::'a)\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?c\\<rbrakk> \\<Longrightarrow> ?a \\<le> ?c\n\ngoal (1 subgoal):\n 1. acyclic_5e x", "by blast"], ["", "lemma acyclic_5a_down_closed:\n  assumes \"x \\<le> y\"\n      and \"acyclic_5a y\"\n    shows \"acyclic_5a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_5a x", "using acyclic_5e_down_closed assms acyclic_5a_5e"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; acyclic_5e ?y\\<rbrakk>\n  \\<Longrightarrow> acyclic_5e ?x\n  x \\<le> y\n  acyclic_5a y\n  acyclic_5a ?x = acyclic_5e ?x\n\ngoal (1 subgoal):\n 1. acyclic_5a x", "by blast"], ["", "text \\<open>further variants of the existence of a linear order\\<close>"], ["", "abbreviation \"linear_orderable_4 x \\<equiv> transitive x \\<and> acyclic x \\<and> strict_linear x\""], ["", "abbreviation \"linear_orderable_5 x \\<equiv> transitive x \\<and> acyclic x \\<and> linear (x\\<^sup>\\<star>)\""], ["", "abbreviation \"linear_orderable_6 x \\<equiv> acyclic x \\<and> linear (x\\<^sup>\\<star>)\""], ["", "abbreviation \"linear_orderable_7 x \\<equiv> split 1 (x\\<^sup>\\<star>) top\""], ["", "abbreviation \"linear_orderable_8 x \\<equiv> split bot (x\\<^sup>+) (-1)\""], ["", "lemma linear_orderable_3_4:\n  \"linear_orderable_3 x \\<longleftrightarrow> linear_orderable_4 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_orderable_3 x = linear_orderable_4 x", "using transitive_acyclic_asymmetric"], ["proof (prove)\nusing this:\n  transitive ?x \\<Longrightarrow>\n  pd_kleene_allegory_class.acyclic ?x = asymmetric ?x\n\ngoal (1 subgoal):\n 1. linear_orderable_3 x = linear_orderable_4 x", "by blast"], ["", "lemma linear_orderable_5_implies_6:\n  \"linear_orderable_5 x \\<Longrightarrow> linear_orderable_6 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitive x \\<and> linear_orderable_6 x \\<Longrightarrow>\n    linear_orderable_6 x", "by simp"], ["", "lemma linear_orderable_6_implies_3:\n  assumes \"linear_orderable_6 x\"\n  shows \"linear_orderable_3 (x\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_orderable_3 (x\\<^sup>+)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. linear_orderable_3 (x\\<^sup>+)", "have 1: \"transitive (x\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitive (x\\<^sup>+)", "by (simp add: comp_associative mult_isotone star.circ_mult_upper_bound star.left_plus_below_circ)"], ["proof (state)\nthis:\n  transitive (x\\<^sup>+)\n\ngoal (1 subgoal):\n 1. linear_orderable_3 (x\\<^sup>+)", "have 2: \"asymmetric (x\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. asymmetric (x\\<^sup>+)", "by (simp add: assms acyclic_asymmetric star.circ_transitive_equal star.left_plus_circ mult_assoc)"], ["proof (state)\nthis:\n  asymmetric (x\\<^sup>+)\n\ngoal (1 subgoal):\n 1. linear_orderable_3 (x\\<^sup>+)", "have 3: \"strict_linear (x\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_linear (x\\<^sup>+)", "by (smt assms acyclic_star_inf_conv conv_star_commute inf.sup_monoid.add_commute inf_absorb2 maddux_3_13 orientable_11_implies_12 star_left_unfold_equal)"], ["proof (state)\nthis:\n  strict_linear (x\\<^sup>+)\n\ngoal (1 subgoal):\n 1. linear_orderable_3 (x\\<^sup>+)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_orderable_3 (x\\<^sup>+)", "using 1 2 3"], ["proof (prove)\nusing this:\n  transitive (x\\<^sup>+)\n  asymmetric (x\\<^sup>+)\n  strict_linear (x\\<^sup>+)\n\ngoal (1 subgoal):\n 1. linear_orderable_3 (x\\<^sup>+)", "by simp"], ["proof (state)\nthis:\n  linear_orderable_3 (x\\<^sup>+)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma linear_orderable_7_implies_1:\n  \"linear_orderable_7 x \\<Longrightarrow> linear_orderable_1 (x\\<^sup>\\<star>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> \\<sqinter> x\\<^sup>\\<star>\\<^sup>T = (1::'a) \\<and>\n    linear (x\\<^sup>\\<star>) \\<Longrightarrow>\n    linear_orderable_1 (x\\<^sup>\\<star>)", "using star.circ_transitive_equal"], ["proof (prove)\nusing this:\n  idempotent (?x\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. x\\<^sup>\\<star> \\<sqinter> x\\<^sup>\\<star>\\<^sup>T = (1::'a) \\<and>\n    linear (x\\<^sup>\\<star>) \\<Longrightarrow>\n    linear_orderable_1 (x\\<^sup>\\<star>)", "by auto"], ["", "lemma linear_orderable_6_implies_8:\n  \"linear_orderable_6 x \\<Longrightarrow> linear_orderable_8 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_orderable_6 x \\<Longrightarrow>\n    asymmetric (x\\<^sup>+) \\<and> strict_linear (x\\<^sup>+)", "by (simp add: linear_orderable_6_implies_3)"], ["", "abbreviation \"path_orderable x \\<equiv> univalent x \\<and> injective x \\<and> acyclic x \\<and> linear (x\\<^sup>\\<star>)\""], ["", "lemma path_orderable_implies_linear_orderable_6:\n  \"path_orderable x \\<Longrightarrow> linear_orderable_6 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path_orderable x \\<Longrightarrow> linear_orderable_6 x", "by simp"], ["", "definition \"simple_paths x \\<equiv> \\<exists>y . y \\<squnion> y\\<^sup>T = x \\<and> acyclic y \\<and> injective y \\<and> univalent y\""], ["", "text \\<open>Theorem 14.1\\<close>"], ["", "lemma simple_paths_acyclic_6:\n  \"simple_paths x \\<Longrightarrow> acyclic_6 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_paths x \\<Longrightarrow> acyclic_6 x", "using simple_paths_def acyclic_6_def"], ["proof (prove)\nusing this:\n  simple_paths ?x \\<equiv>\n  \\<exists>y.\n     y \\<squnion> y\\<^sup>T = ?x \\<and>\n     pd_kleene_allegory_class.acyclic y \\<and>\n     injective y \\<and> univalent y\n  acyclic_6 ?x \\<equiv>\n  \\<exists>y.\n     y \\<squnion> y\\<^sup>T = ?x \\<and>\n     pd_kleene_allegory_class.acyclic y \\<and> injective y\n\ngoal (1 subgoal):\n 1. simple_paths x \\<Longrightarrow> acyclic_6 x", "by blast"], ["", "text \\<open>Theorem 14.2\\<close>"], ["", "lemma simple_paths_transitively_orientable:\n  assumes \"simple_paths x\"\n  shows \"transitively_orientable (x\\<^sup>+ \\<sqinter> -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitively_orientable (x\\<^sup>+ \\<sqinter> - (1::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. transitively_orientable (x\\<^sup>+ \\<sqinter> - (1::'a))", "from assms"], ["proof (chain)\npicking this:\n  simple_paths x", "obtain y where 1: \"y \\<squnion> y\\<^sup>T = x \\<and> acyclic y \\<and> injective y \\<and> univalent y\""], ["proof (prove)\nusing this:\n  simple_paths x\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        y \\<squnion> y\\<^sup>T = x \\<and>\n        pd_kleene_allegory_class.acyclic y \\<and>\n        injective y \\<and> univalent y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using simple_paths_def"], ["proof (prove)\nusing this:\n  simple_paths x\n  simple_paths ?x \\<equiv>\n  \\<exists>y.\n     y \\<squnion> y\\<^sup>T = ?x \\<and>\n     pd_kleene_allegory_class.acyclic y \\<and>\n     injective y \\<and> univalent y\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        y \\<squnion> y\\<^sup>T = x \\<and>\n        pd_kleene_allegory_class.acyclic y \\<and>\n        injective y \\<and> univalent y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y \\<and> univalent y\n\ngoal (1 subgoal):\n 1. transitively_orientable (x\\<^sup>+ \\<sqinter> - (1::'a))", "let ?y = \"y\\<^sup>+\""], ["proof (state)\ngoal (1 subgoal):\n 1. transitively_orientable (x\\<^sup>+ \\<sqinter> - (1::'a))", "have 2: \"transitive ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitive (y\\<^sup>+)", "by (simp add: comp_associative mult_right_isotone star.circ_mult_upper_bound star.left_plus_below_circ)"], ["proof (state)\nthis:\n  transitive (y\\<^sup>+)\n\ngoal (1 subgoal):\n 1. transitively_orientable (x\\<^sup>+ \\<sqinter> - (1::'a))", "have 3: \"asymmetric ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. asymmetric (y\\<^sup>+)", "using 1 acyclic_plus_asymmetric"], ["proof (prove)\nusing this:\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y \\<and> univalent y\n  pd_kleene_allegory_class.acyclic ?x = asymmetric (?x\\<^sup>+)\n\ngoal (1 subgoal):\n 1. asymmetric (y\\<^sup>+)", "by auto"], ["proof (state)\nthis:\n  asymmetric (y\\<^sup>+)\n\ngoal (1 subgoal):\n 1. transitively_orientable (x\\<^sup>+ \\<sqinter> - (1::'a))", "have \"?y \\<squnion> ?y\\<^sup>T = x\\<^sup>+ \\<sqinter> -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>+ \\<squnion> y\\<^sup>+\\<^sup>T = x\\<^sup>+ \\<sqinter> - (1::'a)", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. y\\<^sup>+ \\<squnion> y\\<^sup>+\\<^sup>T\n    \\<le> x\\<^sup>+ \\<sqinter> - (1::'a)\n 2. x\\<^sup>+ \\<sqinter> - (1::'a)\n    \\<le> y\\<^sup>+ \\<squnion> y\\<^sup>+\\<^sup>T", "have 4: \"?y \\<le> x\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>+ \\<le> x\\<^sup>+", "using 1 comp_isotone star_isotone"], ["proof (prove)\nusing this:\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y \\<and> univalent y\n  \\<lbrakk>?x \\<le> ?y; ?w \\<le> ?z\\<rbrakk>\n  \\<Longrightarrow> ?x * ?w \\<le> ?y * ?z\n  ?x \\<le> ?y \\<Longrightarrow> ?x\\<^sup>\\<star> \\<le> ?y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. y\\<^sup>+ \\<le> x\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  y\\<^sup>+ \\<le> x\\<^sup>+\n\ngoal (2 subgoals):\n 1. y\\<^sup>+ \\<squnion> y\\<^sup>+\\<^sup>T\n    \\<le> x\\<^sup>+ \\<sqinter> - (1::'a)\n 2. x\\<^sup>+ \\<sqinter> - (1::'a)\n    \\<le> y\\<^sup>+ \\<squnion> y\\<^sup>+\\<^sup>T", "hence \"?y\\<^sup>T \\<le> x\\<^sup>+\""], ["proof (prove)\nusing this:\n  y\\<^sup>+ \\<le> x\\<^sup>+\n\ngoal (1 subgoal):\n 1. y\\<^sup>+\\<^sup>T \\<le> x\\<^sup>+", "using 1"], ["proof (prove)\nusing this:\n  y\\<^sup>+ \\<le> x\\<^sup>+\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y \\<and> univalent y\n\ngoal (1 subgoal):\n 1. y\\<^sup>+\\<^sup>T \\<le> x\\<^sup>+", "by (metis conv_dist_sup conv_involutive conv_order conv_plus_commute sup_commute)"], ["proof (state)\nthis:\n  y\\<^sup>+\\<^sup>T \\<le> x\\<^sup>+\n\ngoal (2 subgoals):\n 1. y\\<^sup>+ \\<squnion> y\\<^sup>+\\<^sup>T\n    \\<le> x\\<^sup>+ \\<sqinter> - (1::'a)\n 2. x\\<^sup>+ \\<sqinter> - (1::'a)\n    \\<le> y\\<^sup>+ \\<squnion> y\\<^sup>+\\<^sup>T", "thus \"?y \\<squnion> ?y\\<^sup>T \\<le> x\\<^sup>+ \\<sqinter> -1\""], ["proof (prove)\nusing this:\n  y\\<^sup>+\\<^sup>T \\<le> x\\<^sup>+\n\ngoal (1 subgoal):\n 1. y\\<^sup>+ \\<squnion> y\\<^sup>+\\<^sup>T\n    \\<le> x\\<^sup>+ \\<sqinter> - (1::'a)", "using 1 4"], ["proof (prove)\nusing this:\n  y\\<^sup>+\\<^sup>T \\<le> x\\<^sup>+\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y \\<and> univalent y\n  y\\<^sup>+ \\<le> x\\<^sup>+\n\ngoal (1 subgoal):\n 1. y\\<^sup>+ \\<squnion> y\\<^sup>+\\<^sup>T\n    \\<le> x\\<^sup>+ \\<sqinter> - (1::'a)", "by (simp add: irreflexive_conv_closed)"], ["proof (state)\nthis:\n  y\\<^sup>+ \\<squnion> y\\<^sup>+\\<^sup>T\n  \\<le> x\\<^sup>+ \\<sqinter> - (1::'a)\n\ngoal (1 subgoal):\n 1. x\\<^sup>+ \\<sqinter> - (1::'a)\n    \\<le> y\\<^sup>+ \\<squnion> y\\<^sup>+\\<^sup>T", "have \"x\\<^sup>+ \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>+ \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\\<^sup>T", "using 1"], ["proof (prove)\nusing this:\n  y \\<squnion> y\\<^sup>T = x \\<and>\n  pd_kleene_allegory_class.acyclic y \\<and> injective y \\<and> univalent y\n\ngoal (1 subgoal):\n 1. x\\<^sup>+ \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\\<^sup>T", "by (metis cancel_separate_1_sup conv_star_commute star.left_plus_below_circ)"], ["proof (state)\nthis:\n  x\\<^sup>+ \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\\<^sup>T\n\ngoal (1 subgoal):\n 1. x\\<^sup>+ \\<sqinter> - (1::'a)\n    \\<le> y\\<^sup>+ \\<squnion> y\\<^sup>+\\<^sup>T", "also"], ["proof (state)\nthis:\n  x\\<^sup>+ \\<le> y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\\<^sup>T\n\ngoal (1 subgoal):\n 1. x\\<^sup>+ \\<sqinter> - (1::'a)\n    \\<le> y\\<^sup>+ \\<squnion> y\\<^sup>+\\<^sup>T", "have \"... = ?y \\<squnion> ?y\\<^sup>T \\<squnion> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\\<^sup>T =\n    y\\<^sup>+ \\<squnion> y\\<^sup>+\\<^sup>T \\<squnion> (1::'a)", "by (smt conv_plus_commute conv_star_commute star.circ_reflexive star_left_unfold_equal sup.absorb1 sup_assoc sup_monoid.add_commute)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> \\<squnion> y\\<^sup>\\<star>\\<^sup>T =\n  y\\<^sup>+ \\<squnion> y\\<^sup>+\\<^sup>T \\<squnion> (1::'a)\n\ngoal (1 subgoal):\n 1. x\\<^sup>+ \\<sqinter> - (1::'a)\n    \\<le> y\\<^sup>+ \\<squnion> y\\<^sup>+\\<^sup>T", "finally"], ["proof (chain)\npicking this:\n  x\\<^sup>+ \\<le> y\\<^sup>+ \\<squnion> y\\<^sup>+\\<^sup>T \\<squnion> (1::'a)", "show \"x\\<^sup>+ \\<sqinter> -1 \\<le> ?y \\<squnion> ?y\\<^sup>T\""], ["proof (prove)\nusing this:\n  x\\<^sup>+ \\<le> y\\<^sup>+ \\<squnion> y\\<^sup>+\\<^sup>T \\<squnion> (1::'a)\n\ngoal (1 subgoal):\n 1. x\\<^sup>+ \\<sqinter> - (1::'a)\n    \\<le> y\\<^sup>+ \\<squnion> y\\<^sup>+\\<^sup>T", "by (metis inf.order_lesseq_imp inf.sup_monoid.add_commute inf.sup_right_isotone p_inf_sup_below sup_commute)"], ["proof (state)\nthis:\n  x\\<^sup>+ \\<sqinter> - (1::'a)\n  \\<le> y\\<^sup>+ \\<squnion> y\\<^sup>+\\<^sup>T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y\\<^sup>+ \\<squnion> y\\<^sup>+\\<^sup>T = x\\<^sup>+ \\<sqinter> - (1::'a)\n\ngoal (1 subgoal):\n 1. transitively_orientable (x\\<^sup>+ \\<sqinter> - (1::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  y\\<^sup>+ \\<squnion> y\\<^sup>+\\<^sup>T = x\\<^sup>+ \\<sqinter> - (1::'a)\n\ngoal (1 subgoal):\n 1. transitively_orientable (x\\<^sup>+ \\<sqinter> - (1::'a))", "using 2 3 transitively_orientable_def"], ["proof (prove)\nusing this:\n  y\\<^sup>+ \\<squnion> y\\<^sup>+\\<^sup>T = x\\<^sup>+ \\<sqinter> - (1::'a)\n  transitive (y\\<^sup>+)\n  asymmetric (y\\<^sup>+)\n  transitively_orientable ?x \\<equiv>\n  \\<exists>y. orientation ?x y \\<and> transitive y\n\ngoal (1 subgoal):\n 1. transitively_orientable (x\\<^sup>+ \\<sqinter> - (1::'a))", "by auto"], ["proof (state)\nthis:\n  transitively_orientable (x\\<^sup>+ \\<sqinter> - (1::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation \"spanning x y \\<equiv> y \\<le> x \\<and> x \\<le> (y \\<squnion> y\\<^sup>T)\\<^sup>\\<star> \\<and> acyclic y \\<and> injective y\""], ["", "definition \"spannable x \\<equiv> \\<exists>y . spanning x y\""], ["", "lemma acyclic_6_implies_spannable:\n  \"acyclic_6 x \\<Longrightarrow> spannable x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_6 x \\<Longrightarrow> spannable x", "by (metis acyclic_6_def star.circ_increasing sup.cobounded1 spannable_def)"], ["", "lemma acyclic_3a_spannable_implies_6:\n  assumes \"acyclic_3a x\"\n      and \"spannable x\"\n      and \"symmetric x\"\n    shows \"acyclic_6 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_6 x", "by (smt acyclic_6_def acyclic_3a_def assms conv_isotone le_supI spannable_def)"], ["", "text \\<open>Theorem 10.3\\<close>"], ["", "lemma acyclic_6_implies_3a:\n  \"acyclic_6 x \\<Longrightarrow> acyclic_3a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_6 x \\<Longrightarrow> acyclic_3a x", "by (simp add: acyclic_6_implies_4a acyclic_4a_implies_3a)"], ["", "text \\<open>Theorem 10.3\\<close>"], ["", "lemma acyclic_6_implies_2:\n  \"acyclic_6 x \\<Longrightarrow> acyclic_2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_6 x \\<Longrightarrow> acyclic_2 x", "by (simp add: acyclic_6_implies_4a acyclic_6_symmetric acyclic_4_implies_2 acyclic_4a_implies_4)"], ["", "text \\<open>Theorem 11\\<close>"], ["", "lemma acyclic_6_3a_spannable:\n  \"acyclic_6 x \\<longleftrightarrow> symmetric x \\<and> spannable x \\<and> acyclic_3a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_6 x = (symmetric x \\<and> spannable x \\<and> acyclic_3a x)", "using acyclic_6_implies_3a acyclic_3a_spannable_implies_6 acyclic_6_implies_spannable acyclic_6_symmetric"], ["proof (prove)\nusing this:\n  acyclic_6 ?x \\<Longrightarrow> acyclic_3a ?x\n  \\<lbrakk>acyclic_3a ?x; spannable ?x; symmetric ?x\\<rbrakk>\n  \\<Longrightarrow> acyclic_6 ?x\n  acyclic_6 ?x \\<Longrightarrow> spannable ?x\n  acyclic_6 ?x \\<Longrightarrow> symmetric ?x\n\ngoal (1 subgoal):\n 1. acyclic_6 x = (symmetric x \\<and> spannable x \\<and> acyclic_3a x)", "by blast"], ["", "end"], ["", "context stone_kleene_relation_algebra\nbegin"], ["", "text \\<open>Theorem 11.3\\<close>"], ["", "lemma point_spanning:\n  assumes \"point p\"\n  shows \"spanning (-1) (p \\<sqinter> -1)\"\n        \"spannable (-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreflexive (p \\<sqinter> - (1::'a)) \\<and>\n    - (1::'a)\n    \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n           (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star> \\<and>\n    pd_kleene_allegory_class.acyclic (p \\<sqinter> - (1::'a)) \\<and>\n    injective (p \\<sqinter> - (1::'a)) &&&\n    spannable (- (1::'a))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. irreflexive (p \\<sqinter> - (1::'a)) \\<and>\n    - (1::'a)\n    \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n           (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star> \\<and>\n    pd_kleene_allegory_class.acyclic (p \\<sqinter> - (1::'a)) \\<and>\n    injective (p \\<sqinter> - (1::'a))\n 2. spannable (- (1::'a))", "let ?y = \"p \\<sqinter> -1\""], ["proof (state)\ngoal (2 subgoals):\n 1. irreflexive (p \\<sqinter> - (1::'a)) \\<and>\n    - (1::'a)\n    \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n           (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star> \\<and>\n    pd_kleene_allegory_class.acyclic (p \\<sqinter> - (1::'a)) \\<and>\n    injective (p \\<sqinter> - (1::'a))\n 2. spannable (- (1::'a))", "have 1: \"injective ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. injective (p \\<sqinter> - (1::'a))", "by (simp add: assms injective_inf_closed)"], ["proof (state)\nthis:\n  injective (p \\<sqinter> - (1::'a))\n\ngoal (2 subgoals):\n 1. irreflexive (p \\<sqinter> - (1::'a)) \\<and>\n    - (1::'a)\n    \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n           (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star> \\<and>\n    pd_kleene_allegory_class.acyclic (p \\<sqinter> - (1::'a)) \\<and>\n    injective (p \\<sqinter> - (1::'a))\n 2. spannable (- (1::'a))", "have \"?y * ?y \\<le> -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. asymmetric_var (p \\<sqinter> - (1::'a))", "using assms cancel_separate_5 inf.sup_monoid.add_commute vector_inf_comp"], ["proof (prove)\nusing this:\n  point p\n  coreflexive (?w * ?z\\<^sup>T) \\<Longrightarrow>\n  ?w \\<sqinter> ?x * (?y \\<sqinter> ?z) \\<le> ?y\n  ?a \\<sqinter> ?b = ?b \\<sqinter> ?a\n  vector ?x \\<Longrightarrow>\n  (?x \\<sqinter> ?y) * ?z = ?x \\<sqinter> ?y * ?z\n\ngoal (1 subgoal):\n 1. asymmetric_var (p \\<sqinter> - (1::'a))", "by auto"], ["proof (state)\nthis:\n  asymmetric_var (p \\<sqinter> - (1::'a))\n\ngoal (2 subgoals):\n 1. irreflexive (p \\<sqinter> - (1::'a)) \\<and>\n    - (1::'a)\n    \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n           (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star> \\<and>\n    pd_kleene_allegory_class.acyclic (p \\<sqinter> - (1::'a)) \\<and>\n    injective (p \\<sqinter> - (1::'a))\n 2. spannable (- (1::'a))", "hence 2: \"transitive ?y\""], ["proof (prove)\nusing this:\n  asymmetric_var (p \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. transitive (p \\<sqinter> - (1::'a))", "by (simp add: assms vector_inf_comp)"], ["proof (state)\nthis:\n  transitive (p \\<sqinter> - (1::'a))\n\ngoal (2 subgoals):\n 1. irreflexive (p \\<sqinter> - (1::'a)) \\<and>\n    - (1::'a)\n    \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n           (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star> \\<and>\n    pd_kleene_allegory_class.acyclic (p \\<sqinter> - (1::'a)) \\<and>\n    injective (p \\<sqinter> - (1::'a))\n 2. spannable (- (1::'a))", "hence 3: \"acyclic ?y\""], ["proof (prove)\nusing this:\n  transitive (p \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. pd_kleene_allegory_class.acyclic (p \\<sqinter> - (1::'a))", "by (simp add: transitive_acyclic_irreflexive)"], ["proof (state)\nthis:\n  pd_kleene_allegory_class.acyclic (p \\<sqinter> - (1::'a))\n\ngoal (2 subgoals):\n 1. irreflexive (p \\<sqinter> - (1::'a)) \\<and>\n    - (1::'a)\n    \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n           (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star> \\<and>\n    pd_kleene_allegory_class.acyclic (p \\<sqinter> - (1::'a)) \\<and>\n    injective (p \\<sqinter> - (1::'a))\n 2. spannable (- (1::'a))", "have 4: \"p \\<le> ?y \\<squnion> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> p \\<sqinter> - (1::'a) \\<squnion> (1::'a)", "by (simp add: regular_complement_top sup_commute sup_inf_distrib1)"], ["proof (state)\nthis:\n  p \\<le> p \\<sqinter> - (1::'a) \\<squnion> (1::'a)\n\ngoal (2 subgoals):\n 1. irreflexive (p \\<sqinter> - (1::'a)) \\<and>\n    - (1::'a)\n    \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n           (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star> \\<and>\n    pd_kleene_allegory_class.acyclic (p \\<sqinter> - (1::'a)) \\<and>\n    injective (p \\<sqinter> - (1::'a))\n 2. spannable (- (1::'a))", "have \"top = p\\<^sup>T * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top = p\\<^sup>T * p", "using assms inf.eq_iff shunt_bijective top_greatest vector_conv_covector"], ["proof (prove)\nusing this:\n  point p\n  (?x = ?y) = (?y \\<le> ?x \\<and> ?x \\<le> ?y)\n  bijective ?z \\<Longrightarrow>\n  (?x \\<le> ?y * ?z) = (?x * ?z\\<^sup>T \\<le> ?y)\n  ?x \\<le> top\n  vector ?v = covector (?v\\<^sup>T)\n\ngoal (1 subgoal):\n 1. top = p\\<^sup>T * p", "by blast"], ["proof (state)\nthis:\n  top = p\\<^sup>T * p\n\ngoal (2 subgoals):\n 1. irreflexive (p \\<sqinter> - (1::'a)) \\<and>\n    - (1::'a)\n    \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n           (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star> \\<and>\n    pd_kleene_allegory_class.acyclic (p \\<sqinter> - (1::'a)) \\<and>\n    injective (p \\<sqinter> - (1::'a))\n 2. spannable (- (1::'a))", "also"], ["proof (state)\nthis:\n  top = p\\<^sup>T * p\n\ngoal (2 subgoals):\n 1. irreflexive (p \\<sqinter> - (1::'a)) \\<and>\n    - (1::'a)\n    \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n           (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star> \\<and>\n    pd_kleene_allegory_class.acyclic (p \\<sqinter> - (1::'a)) \\<and>\n    injective (p \\<sqinter> - (1::'a))\n 2. spannable (- (1::'a))", "have \"... \\<le> (?y \\<squnion> 1)\\<^sup>T * (?y \\<squnion> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p\\<^sup>T * p\n    \\<le> (p \\<sqinter> - (1::'a) \\<squnion> (1::'a))\\<^sup>T *\n          (p \\<sqinter> - (1::'a) \\<squnion> (1::'a))", "using 4"], ["proof (prove)\nusing this:\n  p \\<le> p \\<sqinter> - (1::'a) \\<squnion> (1::'a)\n\ngoal (1 subgoal):\n 1. p\\<^sup>T * p\n    \\<le> (p \\<sqinter> - (1::'a) \\<squnion> (1::'a))\\<^sup>T *\n          (p \\<sqinter> - (1::'a) \\<squnion> (1::'a))", "by (simp add: conv_isotone mult_isotone)"], ["proof (state)\nthis:\n  p\\<^sup>T * p\n  \\<le> (p \\<sqinter> - (1::'a) \\<squnion> (1::'a))\\<^sup>T *\n        (p \\<sqinter> - (1::'a) \\<squnion> (1::'a))\n\ngoal (2 subgoals):\n 1. irreflexive (p \\<sqinter> - (1::'a)) \\<and>\n    - (1::'a)\n    \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n           (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star> \\<and>\n    pd_kleene_allegory_class.acyclic (p \\<sqinter> - (1::'a)) \\<and>\n    injective (p \\<sqinter> - (1::'a))\n 2. spannable (- (1::'a))", "also"], ["proof (state)\nthis:\n  p\\<^sup>T * p\n  \\<le> (p \\<sqinter> - (1::'a) \\<squnion> (1::'a))\\<^sup>T *\n        (p \\<sqinter> - (1::'a) \\<squnion> (1::'a))\n\ngoal (2 subgoals):\n 1. irreflexive (p \\<sqinter> - (1::'a)) \\<and>\n    - (1::'a)\n    \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n           (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star> \\<and>\n    pd_kleene_allegory_class.acyclic (p \\<sqinter> - (1::'a)) \\<and>\n    injective (p \\<sqinter> - (1::'a))\n 2. spannable (- (1::'a))", "have \"... = (?y \\<squnion> ?y\\<^sup>T)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<sqinter> - (1::'a) \\<squnion> (1::'a))\\<^sup>T *\n    (p \\<sqinter> - (1::'a) \\<squnion> (1::'a)) =\n    (p \\<sqinter> - (1::'a) \\<squnion>\n     (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star>", "using 1 2"], ["proof (prove)\nusing this:\n  injective (p \\<sqinter> - (1::'a))\n  transitive (p \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. (p \\<sqinter> - (1::'a) \\<squnion> (1::'a))\\<^sup>T *\n    (p \\<sqinter> - (1::'a) \\<squnion> (1::'a)) =\n    (p \\<sqinter> - (1::'a) \\<squnion>\n     (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star>", "by (smt antisym cancel_separate_1 conv_star_commute star.circ_mult_1 star.circ_mult_increasing star.right_plus_circ star_right_induct_mult sup_commute)"], ["proof (state)\nthis:\n  (p \\<sqinter> - (1::'a) \\<squnion> (1::'a))\\<^sup>T *\n  (p \\<sqinter> - (1::'a) \\<squnion> (1::'a)) =\n  (p \\<sqinter> - (1::'a) \\<squnion>\n   (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star>\n\ngoal (2 subgoals):\n 1. irreflexive (p \\<sqinter> - (1::'a)) \\<and>\n    - (1::'a)\n    \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n           (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star> \\<and>\n    pd_kleene_allegory_class.acyclic (p \\<sqinter> - (1::'a)) \\<and>\n    injective (p \\<sqinter> - (1::'a))\n 2. spannable (- (1::'a))", "finally"], ["proof (chain)\npicking this:\n  top\n  \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n         (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star>", "have \"-1 \\<le> (?y \\<squnion> ?y\\<^sup>T)\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  top\n  \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n         (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. - (1::'a)\n    \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n           (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star>", "using top.extremum top_le"], ["proof (prove)\nusing this:\n  top\n  \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n         (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star>\n  ?a \\<le> top\n  top \\<le> ?a \\<Longrightarrow> ?a = top\n\ngoal (1 subgoal):\n 1. - (1::'a)\n    \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n           (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star>", "by blast"], ["proof (state)\nthis:\n  - (1::'a)\n  \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n         (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star>\n\ngoal (2 subgoals):\n 1. irreflexive (p \\<sqinter> - (1::'a)) \\<and>\n    - (1::'a)\n    \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n           (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star> \\<and>\n    pd_kleene_allegory_class.acyclic (p \\<sqinter> - (1::'a)) \\<and>\n    injective (p \\<sqinter> - (1::'a))\n 2. spannable (- (1::'a))", "thus \"spanning (-1) (p \\<sqinter> -1)\""], ["proof (prove)\nusing this:\n  - (1::'a)\n  \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n         (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. irreflexive (p \\<sqinter> - (1::'a)) \\<and>\n    - (1::'a)\n    \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n           (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star> \\<and>\n    pd_kleene_allegory_class.acyclic (p \\<sqinter> - (1::'a)) \\<and>\n    injective (p \\<sqinter> - (1::'a))", "using 1 3 inf.cobounded2"], ["proof (prove)\nusing this:\n  - (1::'a)\n  \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n         (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star>\n  injective (p \\<sqinter> - (1::'a))\n  pd_kleene_allegory_class.acyclic (p \\<sqinter> - (1::'a))\n  ?a \\<sqinter> ?b \\<le> ?b\n\ngoal (1 subgoal):\n 1. irreflexive (p \\<sqinter> - (1::'a)) \\<and>\n    - (1::'a)\n    \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n           (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star> \\<and>\n    pd_kleene_allegory_class.acyclic (p \\<sqinter> - (1::'a)) \\<and>\n    injective (p \\<sqinter> - (1::'a))", "by blast"], ["proof (state)\nthis:\n  irreflexive (p \\<sqinter> - (1::'a)) \\<and>\n  - (1::'a)\n  \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n         (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star> \\<and>\n  pd_kleene_allegory_class.acyclic (p \\<sqinter> - (1::'a)) \\<and>\n  injective (p \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. spannable (- (1::'a))", "thus \"spannable (-1)\""], ["proof (prove)\nusing this:\n  irreflexive (p \\<sqinter> - (1::'a)) \\<and>\n  - (1::'a)\n  \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n         (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star> \\<and>\n  pd_kleene_allegory_class.acyclic (p \\<sqinter> - (1::'a)) \\<and>\n  injective (p \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. spannable (- (1::'a))", "using spannable_def"], ["proof (prove)\nusing this:\n  irreflexive (p \\<sqinter> - (1::'a)) \\<and>\n  - (1::'a)\n  \\<le> (p \\<sqinter> - (1::'a) \\<squnion>\n         (p \\<sqinter> - (1::'a))\\<^sup>T)\\<^sup>\\<star> \\<and>\n  pd_kleene_allegory_class.acyclic (p \\<sqinter> - (1::'a)) \\<and>\n  injective (p \\<sqinter> - (1::'a))\n  spannable ?x \\<equiv> \\<exists>y. spanning ?x y\n\ngoal (1 subgoal):\n 1. spannable (- (1::'a))", "by blast"], ["proof (state)\nthis:\n  spannable (- (1::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "(* move to Kleene_Relation_Algebras *)"], ["", "lemma irreflexive_star:\n  \"(x \\<sqinter> -1)\\<^sup>\\<star> = x\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> - (1::'a))\\<^sup>\\<star> = x\\<^sup>\\<star>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<sqinter> - (1::'a))\\<^sup>\\<star> = x\\<^sup>\\<star>", "have 1: \"x \\<sqinter> 1 \\<le> (x \\<sqinter> -1)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> (1::'a) \\<le> (x \\<sqinter> - (1::'a))\\<^sup>\\<star>", "by (simp add: le_infI2 star.circ_reflexive)"], ["proof (state)\nthis:\n  x \\<sqinter> (1::'a) \\<le> (x \\<sqinter> - (1::'a))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> - (1::'a))\\<^sup>\\<star> = x\\<^sup>\\<star>", "have \"x \\<sqinter> -1 \\<le> (x \\<sqinter> -1)\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> - (1::'a) \\<le> (x \\<sqinter> - (1::'a))\\<^sup>\\<star>", "by (simp add: star.circ_increasing)"], ["proof (state)\nthis:\n  x \\<sqinter> - (1::'a) \\<le> (x \\<sqinter> - (1::'a))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> - (1::'a))\\<^sup>\\<star> = x\\<^sup>\\<star>", "hence \"x \\<le> (x \\<sqinter> -1)\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  x \\<sqinter> - (1::'a) \\<le> (x \\<sqinter> - (1::'a))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x \\<le> (x \\<sqinter> - (1::'a))\\<^sup>\\<star>", "using 1"], ["proof (prove)\nusing this:\n  x \\<sqinter> - (1::'a) \\<le> (x \\<sqinter> - (1::'a))\\<^sup>\\<star>\n  x \\<sqinter> (1::'a) \\<le> (x \\<sqinter> - (1::'a))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x \\<le> (x \\<sqinter> - (1::'a))\\<^sup>\\<star>", "by (smt maddux_3_11_pp regular_one_closed sup.absorb_iff1 sup_assoc)"], ["proof (state)\nthis:\n  x \\<le> (x \\<sqinter> - (1::'a))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> - (1::'a))\\<^sup>\\<star> = x\\<^sup>\\<star>", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> (x \\<sqinter> - (1::'a))\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> - (1::'a))\\<^sup>\\<star> = x\\<^sup>\\<star>", "by (metis antisym inf.cobounded1 star_involutive star_isotone)"], ["proof (state)\nthis:\n  (x \\<sqinter> - (1::'a))\\<^sup>\\<star> = x\\<^sup>\\<star>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 6.5\\<close>"], ["", "lemma acyclic_2_1:\n  assumes \"orientable x\"\n  shows \"acyclic_2 x \\<longleftrightarrow> acyclic_1 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_2 x = acyclic_1 x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. acyclic_2 x \\<Longrightarrow> acyclic_1 x\n 2. acyclic_1 x \\<Longrightarrow> acyclic_2 x", "assume \"acyclic_2 x\""], ["proof (state)\nthis:\n  acyclic_2 x\n\ngoal (2 subgoals):\n 1. acyclic_2 x \\<Longrightarrow> acyclic_1 x\n 2. acyclic_1 x \\<Longrightarrow> acyclic_2 x", "thus \"acyclic_1 x\""], ["proof (prove)\nusing this:\n  acyclic_2 x\n\ngoal (1 subgoal):\n 1. acyclic_1 x", "using acyclic_2_implies_1"], ["proof (prove)\nusing this:\n  acyclic_2 x\n  acyclic_2 ?x \\<Longrightarrow> acyclic_1 ?x\n\ngoal (1 subgoal):\n 1. acyclic_1 x", "by blast"], ["proof (state)\nthis:\n  acyclic_1 x\n\ngoal (1 subgoal):\n 1. acyclic_1 x \\<Longrightarrow> acyclic_2 x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. acyclic_1 x \\<Longrightarrow> acyclic_2 x", "assume 1: \"acyclic_1 x\""], ["proof (state)\nthis:\n  acyclic_1 x\n\ngoal (1 subgoal):\n 1. acyclic_1 x \\<Longrightarrow> acyclic_2 x", "obtain y where 2: \"orientation x y \\<and> symmetric x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        orientation x y \\<and> symmetric x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms orientable_def orientable_symmetric"], ["proof (prove)\nusing this:\n  orientable x\n  orientable ?x \\<equiv> \\<exists>y. orientation ?x y\n  orientable ?x \\<Longrightarrow> symmetric ?x\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        orientation x y \\<and> symmetric x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  orientation x y \\<and> symmetric x\n\ngoal (1 subgoal):\n 1. acyclic_1 x \\<Longrightarrow> acyclic_2 x", "show \"acyclic_2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_2 x", "proof (unfold acyclic_2_def, rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<and> asymmetric y \\<Longrightarrow>\n       pd_kleene_allegory_class.acyclic y", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<and> asymmetric y \\<Longrightarrow>\n       pd_kleene_allegory_class.acyclic y", "assume 3: \"z \\<le> x \\<and> asymmetric z\""], ["proof (state)\nthis:\n  z \\<le> x \\<and> asymmetric z\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<and> asymmetric y \\<Longrightarrow>\n       pd_kleene_allegory_class.acyclic y", "let ?z = \"(--z \\<sqinter> x) \\<squnion> (-(z \\<squnion> z\\<^sup>T) \\<sqinter> y)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<and> asymmetric y \\<Longrightarrow>\n       pd_kleene_allegory_class.acyclic y", "have \"orientation x ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. orientation x\n     (- - z \\<sqinter> x \\<squnion> - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. - - z \\<sqinter> x \\<squnion>\n    - (z \\<squnion> z\\<^sup>T) \\<sqinter> y \\<squnion>\n    (- - z \\<sqinter> x \\<squnion>\n     - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)\\<^sup>T =\n    x\n 2. asymmetric\n     (- - z \\<sqinter> x \\<squnion> - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)", "have \"?z \\<squnion> ?z\\<^sup>T = ((--z \\<squnion> --z\\<^sup>T) \\<sqinter> x) \\<squnion> (-(z \\<squnion> z\\<^sup>T) \\<sqinter> (y \\<squnion> y\\<^sup>T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - z \\<sqinter> x \\<squnion>\n    - (z \\<squnion> z\\<^sup>T) \\<sqinter> y \\<squnion>\n    (- - z \\<sqinter> x \\<squnion>\n     - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)\\<^sup>T =\n    (- - z \\<squnion> - - z\\<^sup>T) \\<sqinter> x \\<squnion>\n    - (z \\<squnion> z\\<^sup>T) \\<sqinter> (y \\<squnion> y\\<^sup>T)", "by (smt 2 3 comp_inf.semiring.combine_common_factor conv_complement conv_dist_inf conv_dist_sup inf_sup_distrib1 orientation_symmetric sup.left_commute sup_assoc)"], ["proof (state)\nthis:\n  - - z \\<sqinter> x \\<squnion>\n  - (z \\<squnion> z\\<^sup>T) \\<sqinter> y \\<squnion>\n  (- - z \\<sqinter> x \\<squnion>\n   - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)\\<^sup>T =\n  (- - z \\<squnion> - - z\\<^sup>T) \\<sqinter> x \\<squnion>\n  - (z \\<squnion> z\\<^sup>T) \\<sqinter> (y \\<squnion> y\\<^sup>T)\n\ngoal (2 subgoals):\n 1. - - z \\<sqinter> x \\<squnion>\n    - (z \\<squnion> z\\<^sup>T) \\<sqinter> y \\<squnion>\n    (- - z \\<sqinter> x \\<squnion>\n     - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)\\<^sup>T =\n    x\n 2. asymmetric\n     (- - z \\<sqinter> x \\<squnion> - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)", "also"], ["proof (state)\nthis:\n  - - z \\<sqinter> x \\<squnion>\n  - (z \\<squnion> z\\<^sup>T) \\<sqinter> y \\<squnion>\n  (- - z \\<sqinter> x \\<squnion>\n   - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)\\<^sup>T =\n  (- - z \\<squnion> - - z\\<^sup>T) \\<sqinter> x \\<squnion>\n  - (z \\<squnion> z\\<^sup>T) \\<sqinter> (y \\<squnion> y\\<^sup>T)\n\ngoal (2 subgoals):\n 1. - - z \\<sqinter> x \\<squnion>\n    - (z \\<squnion> z\\<^sup>T) \\<sqinter> y \\<squnion>\n    (- - z \\<sqinter> x \\<squnion>\n     - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)\\<^sup>T =\n    x\n 2. asymmetric\n     (- - z \\<sqinter> x \\<squnion> - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)", "have \"... = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- - z \\<squnion> - - z\\<^sup>T) \\<sqinter> x \\<squnion>\n    - (z \\<squnion> z\\<^sup>T) \\<sqinter> (y \\<squnion> y\\<^sup>T) =\n    x", "by (metis 2 inf_commute maddux_3_11_pp pp_dist_sup sup_monoid.add_commute)"], ["proof (state)\nthis:\n  (- - z \\<squnion> - - z\\<^sup>T) \\<sqinter> x \\<squnion>\n  - (z \\<squnion> z\\<^sup>T) \\<sqinter> (y \\<squnion> y\\<^sup>T) =\n  x\n\ngoal (2 subgoals):\n 1. - - z \\<sqinter> x \\<squnion>\n    - (z \\<squnion> z\\<^sup>T) \\<sqinter> y \\<squnion>\n    (- - z \\<sqinter> x \\<squnion>\n     - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)\\<^sup>T =\n    x\n 2. asymmetric\n     (- - z \\<sqinter> x \\<squnion> - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)", "finally"], ["proof (chain)\npicking this:\n  - - z \\<sqinter> x \\<squnion>\n  - (z \\<squnion> z\\<^sup>T) \\<sqinter> y \\<squnion>\n  (- - z \\<sqinter> x \\<squnion>\n   - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)\\<^sup>T =\n  x", "show \"?z \\<squnion> ?z\\<^sup>T = x\""], ["proof (prove)\nusing this:\n  - - z \\<sqinter> x \\<squnion>\n  - (z \\<squnion> z\\<^sup>T) \\<sqinter> y \\<squnion>\n  (- - z \\<sqinter> x \\<squnion>\n   - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)\\<^sup>T =\n  x\n\ngoal (1 subgoal):\n 1. - - z \\<sqinter> x \\<squnion>\n    - (z \\<squnion> z\\<^sup>T) \\<sqinter> y \\<squnion>\n    (- - z \\<sqinter> x \\<squnion>\n     - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)\\<^sup>T =\n    x", "."], ["proof (state)\nthis:\n  - - z \\<sqinter> x \\<squnion>\n  - (z \\<squnion> z\\<^sup>T) \\<sqinter> y \\<squnion>\n  (- - z \\<sqinter> x \\<squnion>\n   - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)\\<^sup>T =\n  x\n\ngoal (1 subgoal):\n 1. asymmetric\n     (- - z \\<sqinter> x \\<squnion> - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)", "have \"?z \\<sqinter> ?z\\<^sup>T = ((--z \\<sqinter> x) \\<squnion> (-(z \\<squnion> z\\<^sup>T) \\<sqinter> y)) \\<sqinter> ((--z\\<^sup>T \\<sqinter> x) \\<squnion> (-(z \\<squnion> z\\<^sup>T) \\<sqinter> y\\<^sup>T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- - z \\<sqinter> x \\<squnion>\n     - (z \\<squnion> z\\<^sup>T) \\<sqinter> y) \\<sqinter>\n    (- - z \\<sqinter> x \\<squnion>\n     - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)\\<^sup>T =\n    (- - z \\<sqinter> x \\<squnion>\n     - (z \\<squnion> z\\<^sup>T) \\<sqinter> y) \\<sqinter>\n    (- - z\\<^sup>T \\<sqinter> x \\<squnion>\n     - (z \\<squnion> z\\<^sup>T) \\<sqinter> y\\<^sup>T)", "by (simp add: 2 conv_complement conv_dist_inf conv_dist_sup inf.sup_monoid.add_commute)"], ["proof (state)\nthis:\n  (- - z \\<sqinter> x \\<squnion>\n   - (z \\<squnion> z\\<^sup>T) \\<sqinter> y) \\<sqinter>\n  (- - z \\<sqinter> x \\<squnion>\n   - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)\\<^sup>T =\n  (- - z \\<sqinter> x \\<squnion>\n   - (z \\<squnion> z\\<^sup>T) \\<sqinter> y) \\<sqinter>\n  (- - z\\<^sup>T \\<sqinter> x \\<squnion>\n   - (z \\<squnion> z\\<^sup>T) \\<sqinter> y\\<^sup>T)\n\ngoal (1 subgoal):\n 1. asymmetric\n     (- - z \\<sqinter> x \\<squnion> - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)", "also"], ["proof (state)\nthis:\n  (- - z \\<sqinter> x \\<squnion>\n   - (z \\<squnion> z\\<^sup>T) \\<sqinter> y) \\<sqinter>\n  (- - z \\<sqinter> x \\<squnion>\n   - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)\\<^sup>T =\n  (- - z \\<sqinter> x \\<squnion>\n   - (z \\<squnion> z\\<^sup>T) \\<sqinter> y) \\<sqinter>\n  (- - z\\<^sup>T \\<sqinter> x \\<squnion>\n   - (z \\<squnion> z\\<^sup>T) \\<sqinter> y\\<^sup>T)\n\ngoal (1 subgoal):\n 1. asymmetric\n     (- - z \\<sqinter> x \\<squnion> - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)", "have \"... = ((--z \\<sqinter> x) \\<sqinter> (--z\\<^sup>T \\<sqinter> x)) \\<squnion> ((--z \\<sqinter> x) \\<sqinter> (-(z \\<squnion> z\\<^sup>T) \\<sqinter> y\\<^sup>T)) \\<squnion> ((-(z \\<squnion> z\\<^sup>T) \\<sqinter> y) \\<sqinter> (--z\\<^sup>T \\<sqinter> x)) \\<squnion> ((-(z \\<squnion> z\\<^sup>T) \\<sqinter> y) \\<sqinter> (-(z \\<squnion> z\\<^sup>T) \\<sqinter> y\\<^sup>T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- - z \\<sqinter> x \\<squnion>\n     - (z \\<squnion> z\\<^sup>T) \\<sqinter> y) \\<sqinter>\n    (- - z\\<^sup>T \\<sqinter> x \\<squnion>\n     - (z \\<squnion> z\\<^sup>T) \\<sqinter> y\\<^sup>T) =\n    - - z \\<sqinter> x \\<sqinter> (- - z\\<^sup>T \\<sqinter> x) \\<squnion>\n    - - z \\<sqinter> x \\<sqinter>\n    (- (z \\<squnion> z\\<^sup>T) \\<sqinter> y\\<^sup>T) \\<squnion>\n    - (z \\<squnion> z\\<^sup>T) \\<sqinter> y \\<sqinter>\n    (- - z\\<^sup>T \\<sqinter> x) \\<squnion>\n    - (z \\<squnion> z\\<^sup>T) \\<sqinter> y \\<sqinter>\n    (- (z \\<squnion> z\\<^sup>T) \\<sqinter> y\\<^sup>T)", "by (smt comp_inf.semiring.distrib_left inf_sup_distrib2 sup_assoc)"], ["proof (state)\nthis:\n  (- - z \\<sqinter> x \\<squnion>\n   - (z \\<squnion> z\\<^sup>T) \\<sqinter> y) \\<sqinter>\n  (- - z\\<^sup>T \\<sqinter> x \\<squnion>\n   - (z \\<squnion> z\\<^sup>T) \\<sqinter> y\\<^sup>T) =\n  - - z \\<sqinter> x \\<sqinter> (- - z\\<^sup>T \\<sqinter> x) \\<squnion>\n  - - z \\<sqinter> x \\<sqinter>\n  (- (z \\<squnion> z\\<^sup>T) \\<sqinter> y\\<^sup>T) \\<squnion>\n  - (z \\<squnion> z\\<^sup>T) \\<sqinter> y \\<sqinter>\n  (- - z\\<^sup>T \\<sqinter> x) \\<squnion>\n  - (z \\<squnion> z\\<^sup>T) \\<sqinter> y \\<sqinter>\n  (- (z \\<squnion> z\\<^sup>T) \\<sqinter> y\\<^sup>T)\n\ngoal (1 subgoal):\n 1. asymmetric\n     (- - z \\<sqinter> x \\<squnion> - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)", "also"], ["proof (state)\nthis:\n  (- - z \\<sqinter> x \\<squnion>\n   - (z \\<squnion> z\\<^sup>T) \\<sqinter> y) \\<sqinter>\n  (- - z\\<^sup>T \\<sqinter> x \\<squnion>\n   - (z \\<squnion> z\\<^sup>T) \\<sqinter> y\\<^sup>T) =\n  - - z \\<sqinter> x \\<sqinter> (- - z\\<^sup>T \\<sqinter> x) \\<squnion>\n  - - z \\<sqinter> x \\<sqinter>\n  (- (z \\<squnion> z\\<^sup>T) \\<sqinter> y\\<^sup>T) \\<squnion>\n  - (z \\<squnion> z\\<^sup>T) \\<sqinter> y \\<sqinter>\n  (- - z\\<^sup>T \\<sqinter> x) \\<squnion>\n  - (z \\<squnion> z\\<^sup>T) \\<sqinter> y \\<sqinter>\n  (- (z \\<squnion> z\\<^sup>T) \\<sqinter> y\\<^sup>T)\n\ngoal (1 subgoal):\n 1. asymmetric\n     (- - z \\<sqinter> x \\<squnion> - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)", "have \"... = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - z \\<sqinter> x \\<sqinter> (- - z\\<^sup>T \\<sqinter> x) \\<squnion>\n    - - z \\<sqinter> x \\<sqinter>\n    (- (z \\<squnion> z\\<^sup>T) \\<sqinter> y\\<^sup>T) \\<squnion>\n    - (z \\<squnion> z\\<^sup>T) \\<sqinter> y \\<sqinter>\n    (- - z\\<^sup>T \\<sqinter> x) \\<squnion>\n    - (z \\<squnion> z\\<^sup>T) \\<sqinter> y \\<sqinter>\n    (- (z \\<squnion> z\\<^sup>T) \\<sqinter> y\\<^sup>T) =\n    bot", "by (smt 2 3 inf.cobounded1 inf.left_commute inf.orderE p_dist_sup pseudo_complement sup.absorb_iff1)"], ["proof (state)\nthis:\n  - - z \\<sqinter> x \\<sqinter> (- - z\\<^sup>T \\<sqinter> x) \\<squnion>\n  - - z \\<sqinter> x \\<sqinter>\n  (- (z \\<squnion> z\\<^sup>T) \\<sqinter> y\\<^sup>T) \\<squnion>\n  - (z \\<squnion> z\\<^sup>T) \\<sqinter> y \\<sqinter>\n  (- - z\\<^sup>T \\<sqinter> x) \\<squnion>\n  - (z \\<squnion> z\\<^sup>T) \\<sqinter> y \\<sqinter>\n  (- (z \\<squnion> z\\<^sup>T) \\<sqinter> y\\<^sup>T) =\n  bot\n\ngoal (1 subgoal):\n 1. asymmetric\n     (- - z \\<sqinter> x \\<squnion> - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)", "finally"], ["proof (chain)\npicking this:\n  asymmetric\n   (- - z \\<sqinter> x \\<squnion> - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)", "show \"?z \\<sqinter> ?z\\<^sup>T = bot\""], ["proof (prove)\nusing this:\n  asymmetric\n   (- - z \\<sqinter> x \\<squnion> - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)\n\ngoal (1 subgoal):\n 1. asymmetric\n     (- - z \\<sqinter> x \\<squnion> - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)", "."], ["proof (state)\nthis:\n  asymmetric\n   (- - z \\<sqinter> x \\<squnion> - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  orientation x\n   (- - z \\<sqinter> x \\<squnion> - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<and> asymmetric y \\<Longrightarrow>\n       pd_kleene_allegory_class.acyclic y", "hence 4: \"acyclic ?z\""], ["proof (prove)\nusing this:\n  orientation x\n   (- - z \\<sqinter> x \\<squnion> - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)\n\ngoal (1 subgoal):\n 1. pd_kleene_allegory_class.acyclic\n     (- - z \\<sqinter> x \\<squnion> - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)", "using 1 acyclic_1_def"], ["proof (prove)\nusing this:\n  orientation x\n   (- - z \\<sqinter> x \\<squnion> - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)\n  acyclic_1 x\n  acyclic_1 ?x \\<equiv>\n  \\<forall>y.\n     orientation ?x y \\<longrightarrow> pd_kleene_allegory_class.acyclic y\n\ngoal (1 subgoal):\n 1. pd_kleene_allegory_class.acyclic\n     (- - z \\<sqinter> x \\<squnion> - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)", "by auto"], ["proof (state)\nthis:\n  pd_kleene_allegory_class.acyclic\n   (- - z \\<sqinter> x \\<squnion> - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<and> asymmetric y \\<Longrightarrow>\n       pd_kleene_allegory_class.acyclic y", "have \"z \\<le> ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<le> - - z \\<sqinter> x \\<squnion>\n            - (z \\<squnion> z\\<^sup>T) \\<sqinter> y", "by (simp add: 3 le_supI1 pp_increasing)"], ["proof (state)\nthis:\n  z \\<le> - - z \\<sqinter> x \\<squnion>\n          - (z \\<squnion> z\\<^sup>T) \\<sqinter> y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<and> asymmetric y \\<Longrightarrow>\n       pd_kleene_allegory_class.acyclic y", "thus \"acyclic z\""], ["proof (prove)\nusing this:\n  z \\<le> - - z \\<sqinter> x \\<squnion>\n          - (z \\<squnion> z\\<^sup>T) \\<sqinter> y\n\ngoal (1 subgoal):\n 1. pd_kleene_allegory_class.acyclic z", "using 4 comp_isotone star_isotone"], ["proof (prove)\nusing this:\n  z \\<le> - - z \\<sqinter> x \\<squnion>\n          - (z \\<squnion> z\\<^sup>T) \\<sqinter> y\n  pd_kleene_allegory_class.acyclic\n   (- - z \\<sqinter> x \\<squnion> - (z \\<squnion> z\\<^sup>T) \\<sqinter> y)\n  \\<lbrakk>?x \\<le> ?y; ?w \\<le> ?z\\<rbrakk>\n  \\<Longrightarrow> ?x * ?w \\<le> ?y * ?z\n  ?x \\<le> ?y \\<Longrightarrow> ?x\\<^sup>\\<star> \\<le> ?y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. pd_kleene_allegory_class.acyclic z", "by fastforce"], ["proof (state)\nthis:\n  pd_kleene_allegory_class.acyclic z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  acyclic_2 x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 8\\<close>"], ["", "lemma acyclic_4_4c:\n  \"acyclic_4 x \\<longleftrightarrow> acyclic_4c x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_4 x = acyclic_4c x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. acyclic_4 x \\<Longrightarrow> acyclic_4c x\n 2. acyclic_4c x \\<Longrightarrow> acyclic_4 x", "assume 1: \"acyclic_4 x\""], ["proof (state)\nthis:\n  acyclic_4 x\n\ngoal (2 subgoals):\n 1. acyclic_4 x \\<Longrightarrow> acyclic_4c x\n 2. acyclic_4c x \\<Longrightarrow> acyclic_4 x", "show \"acyclic_4c x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_4c x", "proof (unfold acyclic_4c_def, rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = bot", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = bot", "assume 2: \"y \\<le> x\""], ["proof (state)\nthis:\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = bot", "have \"x \\<sqinter> (x \\<sqinter> -y)\\<^sup>\\<star> \\<le> --(x \\<sqinter> -y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star>\n    \\<le> - - (x \\<sqinter> - y)", "using 1 acyclic_4_def inf.cobounded1"], ["proof (prove)\nusing this:\n  acyclic_4 x\n  acyclic_4 ?x \\<equiv>\n  \\<forall>y\\<le>?x. ?x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y\n  ?a \\<sqinter> ?b \\<le> ?a\n\ngoal (1 subgoal):\n 1. x \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star>\n    \\<le> - - (x \\<sqinter> - y)", "by blast"], ["proof (state)\nthis:\n  x \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> \\<le> - - (x \\<sqinter> - y)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = bot", "also"], ["proof (state)\nthis:\n  x \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> \\<le> - - (x \\<sqinter> - y)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = bot", "have \"... \\<le> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - (x \\<sqinter> - y) \\<le> - y", "by simp"], ["proof (state)\nthis:\n  - - (x \\<sqinter> - y) \\<le> - y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = bot", "finally"], ["proof (chain)\npicking this:\n  x \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> \\<le> - y", "have \"x \\<sqinter> y \\<sqinter> (x \\<sqinter> -y)\\<^sup>\\<star> = bot\""], ["proof (prove)\nusing this:\n  x \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> \\<le> - y\n\ngoal (1 subgoal):\n 1. x \\<sqinter> y \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = bot", "by (simp add: p_shunting_swap pseudo_complement)"], ["proof (state)\nthis:\n  x \\<sqinter> y \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = bot\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow>\n       y \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = bot", "thus \"y \\<sqinter> (x \\<sqinter> -y)\\<^sup>\\<star> = bot\""], ["proof (prove)\nusing this:\n  x \\<sqinter> y \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = bot\n\ngoal (1 subgoal):\n 1. y \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = bot", "using 2 inf_absorb2"], ["proof (prove)\nusing this:\n  x \\<sqinter> y \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = bot\n  y \\<le> x\n  ?y \\<le> ?x \\<Longrightarrow> ?x \\<sqinter> ?y = ?y\n\ngoal (1 subgoal):\n 1. y \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = bot", "by auto"], ["proof (state)\nthis:\n  y \\<sqinter> (x \\<sqinter> - y)\\<^sup>\\<star> = bot\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  acyclic_4c x\n\ngoal (1 subgoal):\n 1. acyclic_4c x \\<Longrightarrow> acyclic_4 x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. acyclic_4c x \\<Longrightarrow> acyclic_4 x", "assume 3: \"acyclic_4c x\""], ["proof (state)\nthis:\n  acyclic_4c x\n\ngoal (1 subgoal):\n 1. acyclic_4c x \\<Longrightarrow> acyclic_4 x", "show \"acyclic_4 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_4 x", "proof (unfold acyclic_4_def, rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y", "assume 4: \"y \\<le> x\""], ["proof (state)\nthis:\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y", "have \"x \\<sqinter> -y \\<sqinter> (x \\<sqinter> -(x \\<sqinter> -y))\\<^sup>\\<star> = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> - y \\<sqinter>\n    (x \\<sqinter> - (x \\<sqinter> - y))\\<^sup>\\<star> =\n    bot", "using 3 acyclic_4c_def inf_le1"], ["proof (prove)\nusing this:\n  acyclic_4c x\n  acyclic_4c ?x \\<equiv>\n  \\<forall>y\\<le>?x. y \\<sqinter> (?x \\<sqinter> - y)\\<^sup>\\<star> = bot\n  ?x \\<sqinter> ?y \\<le> ?x\n\ngoal (1 subgoal):\n 1. x \\<sqinter> - y \\<sqinter>\n    (x \\<sqinter> - (x \\<sqinter> - y))\\<^sup>\\<star> =\n    bot", "by blast"], ["proof (state)\nthis:\n  x \\<sqinter> - y \\<sqinter>\n  (x \\<sqinter> - (x \\<sqinter> - y))\\<^sup>\\<star> =\n  bot\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y", "hence \"x \\<sqinter> -y \\<sqinter> (x \\<sqinter> --y)\\<^sup>\\<star> = bot\""], ["proof (prove)\nusing this:\n  x \\<sqinter> - y \\<sqinter>\n  (x \\<sqinter> - (x \\<sqinter> - y))\\<^sup>\\<star> =\n  bot\n\ngoal (1 subgoal):\n 1. x \\<sqinter> - y \\<sqinter> (x \\<sqinter> - - y)\\<^sup>\\<star> = bot", "using inf_import_p"], ["proof (prove)\nusing this:\n  x \\<sqinter> - y \\<sqinter>\n  (x \\<sqinter> - (x \\<sqinter> - y))\\<^sup>\\<star> =\n  bot\n  ?x \\<sqinter> - (?x \\<sqinter> ?y) = ?x \\<sqinter> - ?y\n\ngoal (1 subgoal):\n 1. x \\<sqinter> - y \\<sqinter> (x \\<sqinter> - - y)\\<^sup>\\<star> = bot", "by auto"], ["proof (state)\nthis:\n  x \\<sqinter> - y \\<sqinter> (x \\<sqinter> - - y)\\<^sup>\\<star> = bot\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y", "hence \"x \\<sqinter> -y \\<sqinter> (x \\<sqinter> y)\\<^sup>\\<star> = bot\""], ["proof (prove)\nusing this:\n  x \\<sqinter> - y \\<sqinter> (x \\<sqinter> - - y)\\<^sup>\\<star> = bot\n\ngoal (1 subgoal):\n 1. x \\<sqinter> - y \\<sqinter> (x \\<sqinter> y)\\<^sup>\\<star> = bot", "by (smt p_inf_pp pp_dist_star pp_pp_inf_bot_iff)"], ["proof (state)\nthis:\n  x \\<sqinter> - y \\<sqinter> (x \\<sqinter> y)\\<^sup>\\<star> = bot\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y", "hence \"x \\<sqinter> -y \\<sqinter> y\\<^sup>\\<star> = bot\""], ["proof (prove)\nusing this:\n  x \\<sqinter> - y \\<sqinter> (x \\<sqinter> y)\\<^sup>\\<star> = bot\n\ngoal (1 subgoal):\n 1. x \\<sqinter> - y \\<sqinter> y\\<^sup>\\<star> = bot", "using 4 inf_absorb2"], ["proof (prove)\nusing this:\n  x \\<sqinter> - y \\<sqinter> (x \\<sqinter> y)\\<^sup>\\<star> = bot\n  y \\<le> x\n  ?y \\<le> ?x \\<Longrightarrow> ?x \\<sqinter> ?y = ?y\n\ngoal (1 subgoal):\n 1. x \\<sqinter> - y \\<sqinter> y\\<^sup>\\<star> = bot", "by auto"], ["proof (state)\nthis:\n  x \\<sqinter> - y \\<sqinter> y\\<^sup>\\<star> = bot\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y", "thus \"x \\<sqinter> y\\<^sup>\\<star> \\<le> --y\""], ["proof (prove)\nusing this:\n  x \\<sqinter> - y \\<sqinter> y\\<^sup>\\<star> = bot\n\ngoal (1 subgoal):\n 1. x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y", "using p_shunting_swap pseudo_complement"], ["proof (prove)\nusing this:\n  x \\<sqinter> - y \\<sqinter> y\\<^sup>\\<star> = bot\n  (?x \\<sqinter> ?y \\<le> - ?z) = (?x \\<sqinter> ?z \\<le> - ?y)\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y", "by auto"], ["proof (state)\nthis:\n  x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  acyclic_4 x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Theorem 9\\<close>"], ["", "lemma acyclic_5f_5g:\n  \"acyclic_5f x \\<longleftrightarrow> acyclic_5g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_5f x = acyclic_5g x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. acyclic_5f x \\<Longrightarrow> acyclic_5g x\n 2. acyclic_5g x \\<Longrightarrow> acyclic_5f x", "assume \"acyclic_5f x\""], ["proof (state)\nthis:\n  acyclic_5f x\n\ngoal (2 subgoals):\n 1. acyclic_5f x \\<Longrightarrow> acyclic_5g x\n 2. acyclic_5g x \\<Longrightarrow> acyclic_5f x", "thus \"acyclic_5g x\""], ["proof (prove)\nusing this:\n  acyclic_5f x\n\ngoal (1 subgoal):\n 1. acyclic_5g x", "using acyclic_5f_def acyclic_5g_def"], ["proof (prove)\nusing this:\n  acyclic_5f x\n  acyclic_5f ?x \\<equiv>\n  \\<forall>y z.\n     y \\<squnion> z \\<le> ?x \\<and> y \\<sqinter> z = bot \\<longrightarrow>\n     y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = (1::'a)\n  acyclic_5g ?x \\<equiv>\n  \\<forall>y z.\n     y \\<squnion> z = ?x \\<and> y \\<sqinter> z = bot \\<longrightarrow>\n     y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = (1::'a)\n\ngoal (1 subgoal):\n 1. acyclic_5g x", "by auto"], ["proof (state)\nthis:\n  acyclic_5g x\n\ngoal (1 subgoal):\n 1. acyclic_5g x \\<Longrightarrow> acyclic_5f x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. acyclic_5g x \\<Longrightarrow> acyclic_5f x", "assume 1: \"acyclic_5g x\""], ["proof (state)\nthis:\n  acyclic_5g x\n\ngoal (1 subgoal):\n 1. acyclic_5g x \\<Longrightarrow> acyclic_5f x", "show \"acyclic_5f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_5f x", "proof (unfold acyclic_5f_def, intro allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       y \\<squnion> z \\<le> x \\<and> y \\<sqinter> z = bot \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = (1::'a)", "fix y z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       y \\<squnion> z \\<le> x \\<and> y \\<sqinter> z = bot \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = (1::'a)", "let ?y = \"x \\<sqinter> --y\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       y \\<squnion> z \\<le> x \\<and> y \\<sqinter> z = bot \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = (1::'a)", "let ?z = \"x \\<sqinter> -y\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       y \\<squnion> z \\<le> x \\<and> y \\<sqinter> z = bot \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = (1::'a)", "assume \"y \\<squnion> z \\<le> x \\<and> y \\<sqinter> z = bot\""], ["proof (state)\nthis:\n  y \\<squnion> z \\<le> x \\<and> y \\<sqinter> z = bot\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       y \\<squnion> z \\<le> x \\<and> y \\<sqinter> z = bot \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = (1::'a)", "hence \"y \\<le> ?y \\<and> z \\<le> ?z\""], ["proof (prove)\nusing this:\n  y \\<squnion> z \\<le> x \\<and> y \\<sqinter> z = bot\n\ngoal (1 subgoal):\n 1. y \\<le> x \\<sqinter> - - y \\<and> z \\<le> x \\<sqinter> - y", "using inf.sup_monoid.add_commute pseudo_complement"], ["proof (prove)\nusing this:\n  y \\<squnion> z \\<le> x \\<and> y \\<sqinter> z = bot\n  ?a \\<sqinter> ?b = ?b \\<sqinter> ?a\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. y \\<le> x \\<sqinter> - - y \\<and> z \\<le> x \\<sqinter> - y", "by fastforce"], ["proof (state)\nthis:\n  y \\<le> x \\<sqinter> - - y \\<and> z \\<le> x \\<sqinter> - y\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       y \\<squnion> z \\<le> x \\<and> y \\<sqinter> z = bot \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = (1::'a)", "hence \"y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> \\<le> ?y\\<^sup>\\<star> \\<sqinter> ?z\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  y \\<le> x \\<sqinter> - - y \\<and> z \\<le> x \\<sqinter> - y\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star>\n    \\<le> (x \\<sqinter> - - y)\\<^sup>\\<star> \\<sqinter>\n          (x \\<sqinter> - y)\\<^sup>\\<star>", "using comp_inf.mult_isotone star_isotone"], ["proof (prove)\nusing this:\n  y \\<le> x \\<sqinter> - - y \\<and> z \\<le> x \\<sqinter> - y\n  \\<lbrakk>?w \\<le> ?y; ?x \\<le> ?z\\<rbrakk>\n  \\<Longrightarrow> ?w \\<sqinter> ?x \\<le> ?y \\<sqinter> ?z\n  ?x \\<le> ?y \\<Longrightarrow> ?x\\<^sup>\\<star> \\<le> ?y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star>\n    \\<le> (x \\<sqinter> - - y)\\<^sup>\\<star> \\<sqinter>\n          (x \\<sqinter> - y)\\<^sup>\\<star>", "by blast"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star>\n  \\<le> (x \\<sqinter> - - y)\\<^sup>\\<star> \\<sqinter>\n        (x \\<sqinter> - y)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       y \\<squnion> z \\<le> x \\<and> y \\<sqinter> z = bot \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = (1::'a)", "also"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star>\n  \\<le> (x \\<sqinter> - - y)\\<^sup>\\<star> \\<sqinter>\n        (x \\<sqinter> - y)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       y \\<squnion> z \\<le> x \\<and> y \\<sqinter> z = bot \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = (1::'a)", "have \"... = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> - - y)\\<^sup>\\<star> \\<sqinter>\n    (x \\<sqinter> - y)\\<^sup>\\<star> =\n    (1::'a)", "using 1"], ["proof (prove)\nusing this:\n  acyclic_5g x\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> - - y)\\<^sup>\\<star> \\<sqinter>\n    (x \\<sqinter> - y)\\<^sup>\\<star> =\n    (1::'a)", "by (simp add: acyclic_5g_def inf.left_commute inf.sup_monoid.add_commute maddux_3_11_pp)"], ["proof (state)\nthis:\n  (x \\<sqinter> - - y)\\<^sup>\\<star> \\<sqinter>\n  (x \\<sqinter> - y)\\<^sup>\\<star> =\n  (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       y \\<squnion> z \\<le> x \\<and> y \\<sqinter> z = bot \\<Longrightarrow>\n       y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = (1::'a)", "finally"], ["proof (chain)\npicking this:\n  coreflexive (y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star>)", "show \"y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = 1\""], ["proof (prove)\nusing this:\n  coreflexive (y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = (1::'a)", "by (simp add: antisym star.circ_reflexive)"], ["proof (state)\nthis:\n  y\\<^sup>\\<star> \\<sqinter> z\\<^sup>\\<star> = (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  acyclic_5f x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma linear_orderable_3_implies_5:\n  assumes \"linear_orderable_3 x\"\n  shows \"linear_orderable_5 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitive x \\<and> linear_orderable_6 x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. transitive x \\<and> linear_orderable_6 x", "have \"top = x \\<squnion> x\\<^sup>T \\<squnion> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top = x \\<squnion> x\\<^sup>T \\<squnion> (1::'a)", "using assms conv_dist_sup orientable_12_implies_11 sup_assoc sup_commute"], ["proof (prove)\nusing this:\n  linear_orderable_3 x\n  (?x \\<squnion> ?y)\\<^sup>T = ?x\\<^sup>T \\<squnion> ?y\\<^sup>T\n  asymmetric ?x \\<and> strict_linear ?x \\<Longrightarrow>\n  (?x \\<squnion> (1::'a)) \\<sqinter> (?x \\<squnion> (1::'a))\\<^sup>T =\n  (1::'a) \\<and>\n  linear (?x \\<squnion> (1::'a))\n  ?x \\<squnion> ?y \\<squnion> ?z = ?x \\<squnion> (?y \\<squnion> ?z)\n  ?x \\<squnion> ?y = ?y \\<squnion> ?x\n\ngoal (1 subgoal):\n 1. top = x \\<squnion> x\\<^sup>T \\<squnion> (1::'a)", "by fastforce"], ["proof (state)\nthis:\n  top = x \\<squnion> x\\<^sup>T \\<squnion> (1::'a)\n\ngoal (1 subgoal):\n 1. transitive x \\<and> linear_orderable_6 x", "also"], ["proof (state)\nthis:\n  top = x \\<squnion> x\\<^sup>T \\<squnion> (1::'a)\n\ngoal (1 subgoal):\n 1. transitive x \\<and> linear_orderable_6 x", "have \"... \\<le> x\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star>\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<squnion> x\\<^sup>T \\<squnion> (1::'a)\n    \\<le> x\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star>\\<^sup>T", "by (smt conv_star_commute star.circ_increasing star_sup_one sup_assoc sup_commute sup_mono)"], ["proof (state)\nthis:\n  x \\<squnion> x\\<^sup>T \\<squnion> (1::'a)\n  \\<le> x\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star>\\<^sup>T\n\ngoal (1 subgoal):\n 1. transitive x \\<and> linear_orderable_6 x", "finally"], ["proof (chain)\npicking this:\n  top \\<le> x\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star>\\<^sup>T", "show ?thesis"], ["proof (prove)\nusing this:\n  top \\<le> x\\<^sup>\\<star> \\<squnion> x\\<^sup>\\<star>\\<^sup>T\n\ngoal (1 subgoal):\n 1. transitive x \\<and> linear_orderable_6 x", "by (simp add: assms top_le transitive_acyclic_asymmetric)"], ["proof (state)\nthis:\n  transitive x \\<and> linear_orderable_6 x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma linear_orderable_8_implies_7:\n  \"linear_orderable_8 x \\<Longrightarrow> linear_orderable_7 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. asymmetric (x\\<^sup>+) \\<and>\n    strict_linear (x\\<^sup>+) \\<Longrightarrow>\n    x\\<^sup>\\<star> \\<sqinter> x\\<^sup>\\<star>\\<^sup>T = (1::'a) \\<and>\n    linear (x\\<^sup>\\<star>)", "using orientable_12_implies_11 star_left_unfold_equal sup_commute"], ["proof (prove)\nusing this:\n  asymmetric ?x \\<and> strict_linear ?x \\<Longrightarrow>\n  (?x \\<squnion> (1::'a)) \\<sqinter> (?x \\<squnion> (1::'a))\\<^sup>T =\n  (1::'a) \\<and>\n  linear (?x \\<squnion> (1::'a))\n  (1::'a) \\<squnion> ?x\\<^sup>+ = ?x\\<^sup>\\<star>\n  ?x \\<squnion> ?y = ?y \\<squnion> ?x\n\ngoal (1 subgoal):\n 1. asymmetric (x\\<^sup>+) \\<and>\n    strict_linear (x\\<^sup>+) \\<Longrightarrow>\n    x\\<^sup>\\<star> \\<sqinter> x\\<^sup>\\<star>\\<^sup>T = (1::'a) \\<and>\n    linear (x\\<^sup>\\<star>)", "by fastforce"], ["", "text \\<open>Theorem 13\\<close>"], ["", "lemma exists_split_characterisations_2:\n  shows \"(\\<exists>x . linear_orderable_1 x) \\<longleftrightarrow> (\\<exists>x . linear_orderable_4 x)\"\n  and \"(\\<exists>x . linear_orderable_1 x) \\<longleftrightarrow> (\\<exists>x . linear_orderable_5 x)\"\n  and \"(\\<exists>x . linear_orderable_1 x) \\<longleftrightarrow> (\\<exists>x . linear_orderable_6 x)\"\n  and \"(\\<exists>x . linear_orderable_1 x) \\<longleftrightarrow> (\\<exists>x . linear_orderable_7 x)\"\n  and \"(\\<exists>x . linear_orderable_1 x) \\<longleftrightarrow> (\\<exists>x . linear_orderable_8 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<exists>x. linear_orderable_1 x) =\n     (\\<exists>x. linear_orderable_4 x) &&&\n     (\\<exists>x. linear_orderable_1 x) =\n     (\\<exists>x. transitive x \\<and> linear_orderable_6 x)) &&&\n    (\\<exists>x. linear_orderable_1 x) =\n    (\\<exists>x. linear_orderable_6 x) &&&\n    (\\<exists>x. linear_orderable_1 x) =\n    (\\<exists>x.\n        x\\<^sup>\\<star> \\<sqinter> x\\<^sup>\\<star>\\<^sup>T = (1::'a) \\<and>\n        linear (x\\<^sup>\\<star>)) &&&\n    (\\<exists>x. linear_orderable_1 x) =\n    (\\<exists>x. asymmetric (x\\<^sup>+) \\<and> strict_linear (x\\<^sup>+))", "subgoal 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. linear_orderable_1 x) = (\\<exists>x. linear_orderable_4 x)", "using exists_split_characterisations(1) strict_order_transitive_acyclic"], ["proof (prove)\nusing this:\n  (\\<exists>x. linear_orderable_1 x) = (\\<exists>x. linear_orderable_2 x)\n  strict_order ?x =\n  (transitive ?x \\<and> pd_kleene_allegory_class.acyclic ?x)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. linear_orderable_1 x) = (\\<exists>x. linear_orderable_4 x)", "by auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. (\\<exists>x. linear_orderable_1 x) =\n    (\\<exists>x. transitive x \\<and> linear_orderable_6 x)\n 2. (\\<exists>x. linear_orderable_1 x) = (\\<exists>x. linear_orderable_6 x)\n 3. (\\<exists>x. linear_orderable_1 x) =\n    (\\<exists>x.\n        x\\<^sup>\\<star> \\<sqinter> x\\<^sup>\\<star>\\<^sup>T = (1::'a) \\<and>\n        linear (x\\<^sup>\\<star>))\n 4. (\\<exists>x. linear_orderable_1 x) =\n    (\\<exists>x. asymmetric (x\\<^sup>+) \\<and> strict_linear (x\\<^sup>+))", "subgoal 2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. linear_orderable_1 x) =\n    (\\<exists>x. transitive x \\<and> linear_orderable_6 x)", "using 1 linear_orderable_3_implies_5 linear_orderable_6_implies_3 transitive_acyclic_asymmetric"], ["proof (prove)\nusing this:\n  (\\<exists>x. linear_orderable_1 x) = (\\<exists>x. linear_orderable_4 x)\n  linear_orderable_3 ?x \\<Longrightarrow>\n  transitive ?x \\<and> linear_orderable_6 ?x\n  linear_orderable_6 ?x \\<Longrightarrow> linear_orderable_3 (?x\\<^sup>+)\n  transitive ?x \\<Longrightarrow>\n  pd_kleene_allegory_class.acyclic ?x = asymmetric ?x\n\ngoal (1 subgoal):\n 1. (\\<exists>x. linear_orderable_1 x) =\n    (\\<exists>x. transitive x \\<and> linear_orderable_6 x)", "by auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. (\\<exists>x. linear_orderable_1 x) = (\\<exists>x. linear_orderable_6 x)\n 2. (\\<exists>x. linear_orderable_1 x) =\n    (\\<exists>x.\n        x\\<^sup>\\<star> \\<sqinter> x\\<^sup>\\<star>\\<^sup>T = (1::'a) \\<and>\n        linear (x\\<^sup>\\<star>))\n 3. (\\<exists>x. linear_orderable_1 x) =\n    (\\<exists>x. asymmetric (x\\<^sup>+) \\<and> strict_linear (x\\<^sup>+))", "subgoal 3"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. linear_orderable_1 x) = (\\<exists>x. linear_orderable_6 x)", "using 2 exists_split_characterisations(1) linear_orderable_6_implies_3"], ["proof (prove)\nusing this:\n  (\\<exists>x. linear_orderable_1 x) =\n  (\\<exists>x. transitive x \\<and> linear_orderable_6 x)\n  (\\<exists>x. linear_orderable_1 x) = (\\<exists>x. linear_orderable_2 x)\n  linear_orderable_6 ?x \\<Longrightarrow> linear_orderable_3 (?x\\<^sup>+)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. linear_orderable_1 x) = (\\<exists>x. linear_orderable_6 x)", "by auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<exists>x. linear_orderable_1 x) =\n    (\\<exists>x.\n        x\\<^sup>\\<star> \\<sqinter> x\\<^sup>\\<star>\\<^sup>T = (1::'a) \\<and>\n        linear (x\\<^sup>\\<star>))\n 2. (\\<exists>x. linear_orderable_1 x) =\n    (\\<exists>x. asymmetric (x\\<^sup>+) \\<and> strict_linear (x\\<^sup>+))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. linear_orderable_1 x) =\n    (\\<exists>x.\n        x\\<^sup>\\<star> \\<sqinter> x\\<^sup>\\<star>\\<^sup>T = (1::'a) \\<and>\n        linear (x\\<^sup>\\<star>))", "using 2 linear_orderable_8_implies_7 linear_orderable_6_implies_3 linear_orderable_7_implies_1"], ["proof (prove)\nusing this:\n  (\\<exists>x. linear_orderable_1 x) =\n  (\\<exists>x. transitive x \\<and> linear_orderable_6 x)\n  asymmetric (?x\\<^sup>+) \\<and>\n  strict_linear (?x\\<^sup>+) \\<Longrightarrow>\n  ?x\\<^sup>\\<star> \\<sqinter> ?x\\<^sup>\\<star>\\<^sup>T = (1::'a) \\<and>\n  linear (?x\\<^sup>\\<star>)\n  linear_orderable_6 ?x \\<Longrightarrow> linear_orderable_3 (?x\\<^sup>+)\n  ?x\\<^sup>\\<star> \\<sqinter> ?x\\<^sup>\\<star>\\<^sup>T = (1::'a) \\<and>\n  linear (?x\\<^sup>\\<star>) \\<Longrightarrow>\n  linear_orderable_1 (?x\\<^sup>\\<star>)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. linear_orderable_1 x) =\n    (\\<exists>x.\n        x\\<^sup>\\<star> \\<sqinter> x\\<^sup>\\<star>\\<^sup>T = (1::'a) \\<and>\n        linear (x\\<^sup>\\<star>))", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. linear_orderable_1 x) =\n    (\\<exists>x. asymmetric (x\\<^sup>+) \\<and> strict_linear (x\\<^sup>+))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. linear_orderable_1 x) =\n    (\\<exists>x. asymmetric (x\\<^sup>+) \\<and> strict_linear (x\\<^sup>+))", "using 3 linear_orderable_8_implies_7 asymmetric_irreflexive linear_orderable_6_implies_3"], ["proof (prove)\nusing this:\n  (\\<exists>x. linear_orderable_1 x) = (\\<exists>x. linear_orderable_6 x)\n  asymmetric (?x\\<^sup>+) \\<and>\n  strict_linear (?x\\<^sup>+) \\<Longrightarrow>\n  ?x\\<^sup>\\<star> \\<sqinter> ?x\\<^sup>\\<star>\\<^sup>T = (1::'a) \\<and>\n  linear (?x\\<^sup>\\<star>)\n  asymmetric ?x \\<Longrightarrow> irreflexive ?x\n  linear_orderable_6 ?x \\<Longrightarrow> linear_orderable_3 (?x\\<^sup>+)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. linear_orderable_1 x) =\n    (\\<exists>x. asymmetric (x\\<^sup>+) \\<and> strict_linear (x\\<^sup>+))", "by blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "subsection \\<open>Arc axiom\\<close>"], ["", "class stone_kleene_relation_algebra_arc = stone_kleene_relation_algebra +\n  assumes arc_axiom: \"x \\<noteq> bot \\<Longrightarrow> \\<exists>y . arc y \\<and> y \\<le> --x\"\nbegin"], ["", "subclass stone_relation_algebra_tarski"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.stone_relation_algebra_tarski (\\<sqinter>) (\\<le>) (<)\n     (\\<squnion>) bot top uminus (1::'a) (*) conv", "proof unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>regular x; x \\<noteq> bot\\<rbrakk>\n       \\<Longrightarrow> times_top_class.total (top * x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>regular x; x \\<noteq> bot\\<rbrakk>\n       \\<Longrightarrow> times_top_class.total (top * x)", "assume 1: \"regular x\" and 2: \"x \\<noteq> bot\""], ["proof (state)\nthis:\n  regular x\n  x \\<noteq> bot\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>regular x; x \\<noteq> bot\\<rbrakk>\n       \\<Longrightarrow> times_top_class.total (top * x)", "from 2"], ["proof (chain)\npicking this:\n  x \\<noteq> bot", "obtain y where \"arc y \\<and> y \\<le> --x\""], ["proof (prove)\nusing this:\n  x \\<noteq> bot\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        arc y \\<and> y \\<le> - - x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using arc_axiom"], ["proof (prove)\nusing this:\n  x \\<noteq> bot\n  ?x \\<noteq> bot \\<Longrightarrow> \\<exists>y. arc y \\<and> y \\<le> - - ?x\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        arc y \\<and> y \\<le> - - x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  arc y \\<and> y \\<le> - - x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>regular x; x \\<noteq> bot\\<rbrakk>\n       \\<Longrightarrow> times_top_class.total (top * x)", "thus \"top * x * top = top\""], ["proof (prove)\nusing this:\n  arc y \\<and> y \\<le> - - x\n\ngoal (1 subgoal):\n 1. times_top_class.total (top * x)", "using 1"], ["proof (prove)\nusing this:\n  arc y \\<and> y \\<le> - - x\n  regular x\n\ngoal (1 subgoal):\n 1. times_top_class.total (top * x)", "by (metis mult_assoc le_iff_sup mult_left_isotone semiring.distrib_left sup.orderE top.extremum)"], ["proof (state)\nthis:\n  times_top_class.total (top * x)\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  assumes orientable_path: \"arc x \\<Longrightarrow> x \\<le> --y\\<^sup>\\<star> \\<Longrightarrow> \\<exists>z . z \\<le> y \\<and> asymmetric z \\<and> x \\<le> --z\\<^sup>\\<star>\"\nbegin"], ["", "text \\<open>Theorem 8.6\\<close>"], ["", "lemma acyclic_2_4:\n  assumes \"irreflexive x\"\n      and \"symmetric x\"\n    shows \"acyclic_2 x \\<longleftrightarrow> acyclic_4 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_2 x = acyclic_4 x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. acyclic_2 x \\<Longrightarrow> acyclic_4 x\n 2. acyclic_4 x \\<Longrightarrow> acyclic_2 x", "show \"acyclic_2 x \\<Longrightarrow> acyclic_4 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_2 x \\<Longrightarrow> acyclic_4 x", "proof (unfold acyclic_4_def, intro allI, intro impI, rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>acyclic_2 x; y \\<le> x;\n        \\<not> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y\\<rbrakk>\n       \\<Longrightarrow> False", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>acyclic_2 x; y \\<le> x;\n        \\<not> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y\\<rbrakk>\n       \\<Longrightarrow> False", "assume 1: \"acyclic_2 x\" and 2: \"y \\<le> x\" and 3: \"\\<not> x \\<sqinter> y\\<^sup>\\<star> \\<le> --y\""], ["proof (state)\nthis:\n  acyclic_2 x\n  y \\<le> x\n  \\<not> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>acyclic_2 x; y \\<le> x;\n        \\<not> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"x \\<sqinter> y\\<^sup>\\<star> \\<sqinter> -y \\<noteq> bot\""], ["proof (prove)\nusing this:\n  acyclic_2 x\n  y \\<le> x\n  \\<not> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y\n\ngoal (1 subgoal):\n 1. x \\<sqinter> y\\<^sup>\\<star> \\<sqinter> - y \\<noteq> bot", "by (simp add: pseudo_complement)"], ["proof (state)\nthis:\n  x \\<sqinter> y\\<^sup>\\<star> \\<sqinter> - y \\<noteq> bot\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>acyclic_2 x; y \\<le> x;\n        \\<not> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y\\<rbrakk>\n       \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  x \\<sqinter> y\\<^sup>\\<star> \\<sqinter> - y \\<noteq> bot", "obtain z where 4: \"arc z \\<and> z \\<le> --(x \\<sqinter> y\\<^sup>\\<star> \\<sqinter> -y)\""], ["proof (prove)\nusing this:\n  x \\<sqinter> y\\<^sup>\\<star> \\<sqinter> - y \\<noteq> bot\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        arc z \\<and>\n        z \\<le> - - (x \\<sqinter> y\\<^sup>\\<star> \\<sqinter>\n                     - y) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using arc_axiom"], ["proof (prove)\nusing this:\n  x \\<sqinter> y\\<^sup>\\<star> \\<sqinter> - y \\<noteq> bot\n  ?x \\<noteq> bot \\<Longrightarrow> \\<exists>y. arc y \\<and> y \\<le> - - ?x\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        arc z \\<and>\n        z \\<le> - - (x \\<sqinter> y\\<^sup>\\<star> \\<sqinter>\n                     - y) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  arc z \\<and> z \\<le> - - (x \\<sqinter> y\\<^sup>\\<star> \\<sqinter> - y)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>acyclic_2 x; y \\<le> x;\n        \\<not> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y\\<rbrakk>\n       \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  arc z \\<and> z \\<le> - - (x \\<sqinter> y\\<^sup>\\<star> \\<sqinter> - y)", "obtain w where 5: \"w \\<le> y \\<and> asymmetric w \\<and> z \\<le> --w\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  arc z \\<and> z \\<le> - - (x \\<sqinter> y\\<^sup>\\<star> \\<sqinter> - y)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        w \\<le> y \\<and>\n        asymmetric w \\<and> z \\<le> - - w\\<^sup>\\<star> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using orientable_path"], ["proof (prove)\nusing this:\n  arc z \\<and> z \\<le> - - (x \\<sqinter> y\\<^sup>\\<star> \\<sqinter> - y)\n  \\<lbrakk>arc ?x1; ?x1 \\<le> - - ?y1\\<^sup>\\<star>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>z\\<le>?y1.\n                       asymmetric z \\<and> ?x1 \\<le> - - z\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        w \\<le> y \\<and>\n        asymmetric w \\<and> z \\<le> - - w\\<^sup>\\<star> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  w \\<le> y \\<and> asymmetric w \\<and> z \\<le> - - w\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>acyclic_2 x; y \\<le> x;\n        \\<not> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y\\<rbrakk>\n       \\<Longrightarrow> False", "let ?y = \"w \\<squnion> (z\\<^sup>T \\<sqinter> x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>acyclic_2 x; y \\<le> x;\n        \\<not> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y\\<rbrakk>\n       \\<Longrightarrow> False", "have 6: \"?y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<squnion> z\\<^sup>T \\<sqinter> x \\<le> x", "using 2 5"], ["proof (prove)\nusing this:\n  y \\<le> x\n  w \\<le> y \\<and> asymmetric w \\<and> z \\<le> - - w\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. w \\<squnion> z\\<^sup>T \\<sqinter> x \\<le> x", "by auto"], ["proof (state)\nthis:\n  w \\<squnion> z\\<^sup>T \\<sqinter> x \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>acyclic_2 x; y \\<le> x;\n        \\<not> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y\\<rbrakk>\n       \\<Longrightarrow> False", "have \"?y \\<sqinter> ?y\\<^sup>T = (w \\<sqinter> w\\<^sup>T) \\<squnion> (w \\<sqinter> z \\<sqinter> x\\<^sup>T) \\<squnion> (z\\<^sup>T \\<sqinter> x \\<sqinter> w\\<^sup>T) \\<squnion> (z\\<^sup>T \\<sqinter> x \\<sqinter> z \\<sqinter> x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w \\<squnion> z\\<^sup>T \\<sqinter> x) \\<sqinter>\n    (w \\<squnion> z\\<^sup>T \\<sqinter> x)\\<^sup>T =\n    w \\<sqinter> w\\<^sup>T \\<squnion>\n    w \\<sqinter> z \\<sqinter> x\\<^sup>T \\<squnion>\n    z\\<^sup>T \\<sqinter> x \\<sqinter> w\\<^sup>T \\<squnion>\n    z\\<^sup>T \\<sqinter> x \\<sqinter> z \\<sqinter> x\\<^sup>T", "by (simp add: inf.commute sup.commute inf.left_commute sup.left_commute conv_dist_inf conv_dist_sup inf_sup_distrib1)"], ["proof (state)\nthis:\n  (w \\<squnion> z\\<^sup>T \\<sqinter> x) \\<sqinter>\n  (w \\<squnion> z\\<^sup>T \\<sqinter> x)\\<^sup>T =\n  w \\<sqinter> w\\<^sup>T \\<squnion>\n  w \\<sqinter> z \\<sqinter> x\\<^sup>T \\<squnion>\n  z\\<^sup>T \\<sqinter> x \\<sqinter> w\\<^sup>T \\<squnion>\n  z\\<^sup>T \\<sqinter> x \\<sqinter> z \\<sqinter> x\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>acyclic_2 x; y \\<le> x;\n        \\<not> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y\\<rbrakk>\n       \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (w \\<squnion> z\\<^sup>T \\<sqinter> x) \\<sqinter>\n  (w \\<squnion> z\\<^sup>T \\<sqinter> x)\\<^sup>T =\n  w \\<sqinter> w\\<^sup>T \\<squnion>\n  w \\<sqinter> z \\<sqinter> x\\<^sup>T \\<squnion>\n  z\\<^sup>T \\<sqinter> x \\<sqinter> w\\<^sup>T \\<squnion>\n  z\\<^sup>T \\<sqinter> x \\<sqinter> z \\<sqinter> x\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>acyclic_2 x; y \\<le> x;\n        \\<not> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y\\<rbrakk>\n       \\<Longrightarrow> False", "have \"... \\<le> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<sqinter> w\\<^sup>T \\<squnion>\n    w \\<sqinter> z \\<sqinter> x\\<^sup>T \\<squnion>\n    z\\<^sup>T \\<sqinter> x \\<sqinter> w\\<^sup>T \\<squnion>\n    z\\<^sup>T \\<sqinter> x \\<sqinter> z \\<sqinter> x\\<^sup>T\n    \\<le> bot", "proof (intro sup_least)"], ["proof (state)\ngoal (4 subgoals):\n 1. w \\<sqinter> w\\<^sup>T \\<le> bot\n 2. w \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> bot\n 3. z\\<^sup>T \\<sqinter> x \\<sqinter> w\\<^sup>T \\<le> bot\n 4. z\\<^sup>T \\<sqinter> x \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> bot", "show \"w \\<sqinter> w\\<^sup>T \\<le> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<sqinter> w\\<^sup>T \\<le> bot", "by (simp add: 5)"], ["proof (state)\nthis:\n  w \\<sqinter> w\\<^sup>T \\<le> bot\n\ngoal (3 subgoals):\n 1. w \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> bot\n 2. z\\<^sup>T \\<sqinter> x \\<sqinter> w\\<^sup>T \\<le> bot\n 3. z\\<^sup>T \\<sqinter> x \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> bot", "have \"w \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> y \\<sqinter> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> y \\<sqinter> z", "by (simp add: 5 inf.coboundedI1)"], ["proof (state)\nthis:\n  w \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> y \\<sqinter> z\n\ngoal (3 subgoals):\n 1. w \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> bot\n 2. z\\<^sup>T \\<sqinter> x \\<sqinter> w\\<^sup>T \\<le> bot\n 3. z\\<^sup>T \\<sqinter> x \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> bot", "also"], ["proof (state)\nthis:\n  w \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> y \\<sqinter> z\n\ngoal (3 subgoals):\n 1. w \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> bot\n 2. z\\<^sup>T \\<sqinter> x \\<sqinter> w\\<^sup>T \\<le> bot\n 3. z\\<^sup>T \\<sqinter> x \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> bot", "have \"... \\<le> y \\<sqinter> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sqinter> z \\<le> y \\<sqinter> - y", "using 4"], ["proof (prove)\nusing this:\n  arc z \\<and> z \\<le> - - (x \\<sqinter> y\\<^sup>\\<star> \\<sqinter> - y)\n\ngoal (1 subgoal):\n 1. y \\<sqinter> z \\<le> y \\<sqinter> - y", "by (metis eq_refl inf.cobounded1 inf.left_commute inf.sup_monoid.add_commute inf_p order_trans pseudo_complement)"], ["proof (state)\nthis:\n  y \\<sqinter> z \\<le> y \\<sqinter> - y\n\ngoal (3 subgoals):\n 1. w \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> bot\n 2. z\\<^sup>T \\<sqinter> x \\<sqinter> w\\<^sup>T \\<le> bot\n 3. z\\<^sup>T \\<sqinter> x \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> bot", "finally"], ["proof (chain)\npicking this:\n  w \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> y \\<sqinter> - y", "show \"w \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> bot\""], ["proof (prove)\nusing this:\n  w \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> y \\<sqinter> - y\n\ngoal (1 subgoal):\n 1. w \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> bot", "by simp"], ["proof (state)\nthis:\n  w \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> bot\n\ngoal (2 subgoals):\n 1. z\\<^sup>T \\<sqinter> x \\<sqinter> w\\<^sup>T \\<le> bot\n 2. z\\<^sup>T \\<sqinter> x \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> bot", "thus \"z\\<^sup>T \\<sqinter> x \\<sqinter> w\\<^sup>T \\<le> bot\""], ["proof (prove)\nusing this:\n  w \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> bot\n\ngoal (1 subgoal):\n 1. z\\<^sup>T \\<sqinter> x \\<sqinter> w\\<^sup>T \\<le> bot", "by (smt conv_dist_inf conv_inf_bot_iff inf.left_commute inf.sup_monoid.add_commute le_bot)"], ["proof (state)\nthis:\n  z\\<^sup>T \\<sqinter> x \\<sqinter> w\\<^sup>T \\<le> bot\n\ngoal (1 subgoal):\n 1. z\\<^sup>T \\<sqinter> x \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> bot", "have \"irreflexive z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreflexive z", "by (meson 4 assms(1) dual_order.trans irreflexive_complement_reflexive irreflexive_inf_closed reflexive_complement_irreflexive)"], ["proof (state)\nthis:\n  irreflexive z\n\ngoal (1 subgoal):\n 1. z\\<^sup>T \\<sqinter> x \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> bot", "hence \"asymmetric z\""], ["proof (prove)\nusing this:\n  irreflexive z\n\ngoal (1 subgoal):\n 1. asymmetric z", "using 4"], ["proof (prove)\nusing this:\n  irreflexive z\n  arc z \\<and> z \\<le> - - (x \\<sqinter> y\\<^sup>\\<star> \\<sqinter> - y)\n\ngoal (1 subgoal):\n 1. asymmetric z", "by (simp add: pseudo_complement irreflexive_inf_arc_asymmetric)"], ["proof (state)\nthis:\n  asymmetric z\n\ngoal (1 subgoal):\n 1. z\\<^sup>T \\<sqinter> x \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> bot", "thus \"z\\<^sup>T \\<sqinter> x \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> bot\""], ["proof (prove)\nusing this:\n  asymmetric z\n\ngoal (1 subgoal):\n 1. z\\<^sup>T \\<sqinter> x \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> bot", "by (simp add: inf.left_commute inf.sup_monoid.add_commute)"], ["proof (state)\nthis:\n  z\\<^sup>T \\<sqinter> x \\<sqinter> z \\<sqinter> x\\<^sup>T \\<le> bot\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w \\<sqinter> w\\<^sup>T \\<squnion>\n  w \\<sqinter> z \\<sqinter> x\\<^sup>T \\<squnion>\n  z\\<^sup>T \\<sqinter> x \\<sqinter> w\\<^sup>T \\<squnion>\n  z\\<^sup>T \\<sqinter> x \\<sqinter> z \\<sqinter> x\\<^sup>T\n  \\<le> bot\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>acyclic_2 x; y \\<le> x;\n        \\<not> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y\\<rbrakk>\n       \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  (w \\<squnion> z\\<^sup>T \\<sqinter> x) \\<sqinter>\n  (w \\<squnion> z\\<^sup>T \\<sqinter> x)\\<^sup>T\n  \\<le> bot", "have \"acyclic ?y\""], ["proof (prove)\nusing this:\n  (w \\<squnion> z\\<^sup>T \\<sqinter> x) \\<sqinter>\n  (w \\<squnion> z\\<^sup>T \\<sqinter> x)\\<^sup>T\n  \\<le> bot\n\ngoal (1 subgoal):\n 1. pd_kleene_allegory_class.acyclic (w \\<squnion> z\\<^sup>T \\<sqinter> x)", "using 1 6"], ["proof (prove)\nusing this:\n  (w \\<squnion> z\\<^sup>T \\<sqinter> x) \\<sqinter>\n  (w \\<squnion> z\\<^sup>T \\<sqinter> x)\\<^sup>T\n  \\<le> bot\n  acyclic_2 x\n  w \\<squnion> z\\<^sup>T \\<sqinter> x \\<le> x\n\ngoal (1 subgoal):\n 1. pd_kleene_allegory_class.acyclic (w \\<squnion> z\\<^sup>T \\<sqinter> x)", "by (simp add: le_bot acyclic_2_def)"], ["proof (state)\nthis:\n  pd_kleene_allegory_class.acyclic (w \\<squnion> z\\<^sup>T \\<sqinter> x)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>acyclic_2 x; y \\<le> x;\n        \\<not> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"?y\\<^sup>\\<star> \\<sqinter> ?y\\<^sup>T = bot\""], ["proof (prove)\nusing this:\n  pd_kleene_allegory_class.acyclic (w \\<squnion> z\\<^sup>T \\<sqinter> x)\n\ngoal (1 subgoal):\n 1. (w \\<squnion> z\\<^sup>T \\<sqinter> x)\\<^sup>\\<star> \\<sqinter>\n    (w \\<squnion> z\\<^sup>T \\<sqinter> x)\\<^sup>T =\n    bot", "using acyclic_star_below_complement_1"], ["proof (prove)\nusing this:\n  pd_kleene_allegory_class.acyclic (w \\<squnion> z\\<^sup>T \\<sqinter> x)\n  pd_kleene_allegory_class.acyclic ?w =\n  (?w\\<^sup>\\<star> \\<sqinter> ?w\\<^sup>T = bot)\n\ngoal (1 subgoal):\n 1. (w \\<squnion> z\\<^sup>T \\<sqinter> x)\\<^sup>\\<star> \\<sqinter>\n    (w \\<squnion> z\\<^sup>T \\<sqinter> x)\\<^sup>T =\n    bot", "by blast"], ["proof (state)\nthis:\n  (w \\<squnion> z\\<^sup>T \\<sqinter> x)\\<^sup>\\<star> \\<sqinter>\n  (w \\<squnion> z\\<^sup>T \\<sqinter> x)\\<^sup>T =\n  bot\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>acyclic_2 x; y \\<le> x;\n        \\<not> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"w\\<^sup>\\<star> \\<sqinter> ?y\\<^sup>T = bot\""], ["proof (prove)\nusing this:\n  (w \\<squnion> z\\<^sup>T \\<sqinter> x)\\<^sup>\\<star> \\<sqinter>\n  (w \\<squnion> z\\<^sup>T \\<sqinter> x)\\<^sup>T =\n  bot\n\ngoal (1 subgoal):\n 1. w\\<^sup>\\<star> \\<sqinter>\n    (w \\<squnion> z\\<^sup>T \\<sqinter> x)\\<^sup>T =\n    bot", "using dual_order.trans pseudo_complement star.circ_sub_dist"], ["proof (prove)\nusing this:\n  (w \\<squnion> z\\<^sup>T \\<sqinter> x)\\<^sup>\\<star> \\<sqinter>\n  (w \\<squnion> z\\<^sup>T \\<sqinter> x)\\<^sup>T =\n  bot\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n  ?x\\<^sup>\\<star> \\<le> (?x \\<squnion> ?y)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. w\\<^sup>\\<star> \\<sqinter>\n    (w \\<squnion> z\\<^sup>T \\<sqinter> x)\\<^sup>T =\n    bot", "by blast"], ["proof (state)\nthis:\n  w\\<^sup>\\<star> \\<sqinter> (w \\<squnion> z\\<^sup>T \\<sqinter> x)\\<^sup>T =\n  bot\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>acyclic_2 x; y \\<le> x;\n        \\<not> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"w\\<^sup>\\<star> \\<sqinter> z \\<sqinter> x\\<^sup>T = bot\""], ["proof (prove)\nusing this:\n  w\\<^sup>\\<star> \\<sqinter> (w \\<squnion> z\\<^sup>T \\<sqinter> x)\\<^sup>T =\n  bot\n\ngoal (1 subgoal):\n 1. w\\<^sup>\\<star> \\<sqinter> z \\<sqinter> x\\<^sup>T = bot", "by (simp add: comp_inf.semiring.distrib_left conv_dist_inf conv_dist_sup inf.sup_monoid.add_assoc)"], ["proof (state)\nthis:\n  w\\<^sup>\\<star> \\<sqinter> z \\<sqinter> x\\<^sup>T = bot\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>acyclic_2 x; y \\<le> x;\n        \\<not> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"z \\<sqinter> x\\<^sup>T = bot\""], ["proof (prove)\nusing this:\n  w\\<^sup>\\<star> \\<sqinter> z \\<sqinter> x\\<^sup>T = bot\n\ngoal (1 subgoal):\n 1. z \\<sqinter> x\\<^sup>T = bot", "using 5"], ["proof (prove)\nusing this:\n  w\\<^sup>\\<star> \\<sqinter> z \\<sqinter> x\\<^sup>T = bot\n  w \\<le> y \\<and> asymmetric w \\<and> z \\<le> - - w\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. z \\<sqinter> x\\<^sup>T = bot", "by (metis comp_inf.p_pp_comp inf.absorb2 pp_pp_inf_bot_iff)"], ["proof (state)\nthis:\n  z \\<sqinter> x\\<^sup>T = bot\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>acyclic_2 x; y \\<le> x;\n        \\<not> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"z \\<sqinter> --x = bot\""], ["proof (prove)\nusing this:\n  z \\<sqinter> x\\<^sup>T = bot\n\ngoal (1 subgoal):\n 1. z \\<sqinter> - - x = bot", "using assms(2) pseudo_complement"], ["proof (prove)\nusing this:\n  z \\<sqinter> x\\<^sup>T = bot\n  symmetric x\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. z \\<sqinter> - - x = bot", "by auto"], ["proof (state)\nthis:\n  z \\<sqinter> - - x = bot\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>acyclic_2 x; y \\<le> x;\n        \\<not> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"z = bot\""], ["proof (prove)\nusing this:\n  z \\<sqinter> - - x = bot\n\ngoal (1 subgoal):\n 1. z = bot", "using 4 inf.orderE"], ["proof (prove)\nusing this:\n  z \\<sqinter> - - x = bot\n  arc z \\<and> z \\<le> - - (x \\<sqinter> y\\<^sup>\\<star> \\<sqinter> - y)\n  \\<lbrakk>?a \\<le> ?b;\n   ?a = ?a \\<sqinter> ?b \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. z = bot", "by auto"], ["proof (state)\nthis:\n  z = bot\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>acyclic_2 x; y \\<le> x;\n        \\<not> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y\\<rbrakk>\n       \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  z = bot\n\ngoal (1 subgoal):\n 1. False", "using 3 4 comp_inf.coreflexive_pseudo_complement inf_bot_right"], ["proof (prove)\nusing this:\n  z = bot\n  \\<not> x \\<sqinter> y\\<^sup>\\<star> \\<le> - - y\n  arc z \\<and> z \\<le> - - (x \\<sqinter> y\\<^sup>\\<star> \\<sqinter> - y)\n  ?x \\<le> top \\<Longrightarrow>\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y \\<sqinter> top)\n  ?x \\<sqinter> bot = bot\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  acyclic_2 x \\<Longrightarrow> acyclic_4 x\n\ngoal (1 subgoal):\n 1. acyclic_4 x \\<Longrightarrow> acyclic_2 x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. acyclic_4 x \\<Longrightarrow> acyclic_2 x", "show \"acyclic_4 x \\<Longrightarrow> acyclic_2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_4 x \\<Longrightarrow> acyclic_2 x", "by (simp add: assms(2) acyclic_4_implies_2)"], ["proof (state)\nthis:\n  acyclic_4 x \\<Longrightarrow> acyclic_2 x\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "context kleene_relation_algebra\nbegin"], ["", "text \\<open>Theorem 8\\<close>"], ["", "lemma acyclic_3a_implies_4b:\n  assumes \"acyclic_3a x\"\n    shows \"acyclic_4b x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_4b x", "proof (unfold acyclic_4b_def, rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> = y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> = y", "let ?y = \"(x \\<sqinter> -y\\<^sup>\\<star>) \\<squnion> y\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> = y", "assume 1: \"y \\<le> x\""], ["proof (state)\nthis:\n  y \\<le> x\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> = y", "have \"x = (x \\<sqinter> -y\\<^sup>\\<star>) \\<squnion> (x \\<sqinter> y\\<^sup>\\<star>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x =\n    x \\<sqinter> - y\\<^sup>\\<star> \\<squnion> x \\<sqinter> y\\<^sup>\\<star>", "by simp"], ["proof (state)\nthis:\n  x = x \\<sqinter> - y\\<^sup>\\<star> \\<squnion> x \\<sqinter> y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> = y", "also"], ["proof (state)\nthis:\n  x = x \\<sqinter> - y\\<^sup>\\<star> \\<squnion> x \\<sqinter> y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> = y", "have \"... \\<le> ?y \\<squnion> y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> - y\\<^sup>\\<star> \\<squnion> x \\<sqinter> y\\<^sup>\\<star>\n    \\<le> x \\<sqinter> - y\\<^sup>\\<star> \\<squnion> y \\<squnion>\n          y\\<^sup>\\<star>", "using shunting_var"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> - ?y \\<le> ?z) = (?x \\<le> ?z \\<squnion> ?y)\n\ngoal (1 subgoal):\n 1. x \\<sqinter> - y\\<^sup>\\<star> \\<squnion> x \\<sqinter> y\\<^sup>\\<star>\n    \\<le> x \\<sqinter> - y\\<^sup>\\<star> \\<squnion> y \\<squnion>\n          y\\<^sup>\\<star>", "by fastforce"], ["proof (state)\nthis:\n  x \\<sqinter> - y\\<^sup>\\<star> \\<squnion> x \\<sqinter> y\\<^sup>\\<star>\n  \\<le> x \\<sqinter> - y\\<^sup>\\<star> \\<squnion> y \\<squnion>\n        y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> = y", "also"], ["proof (state)\nthis:\n  x \\<sqinter> - y\\<^sup>\\<star> \\<squnion> x \\<sqinter> y\\<^sup>\\<star>\n  \\<le> x \\<sqinter> - y\\<^sup>\\<star> \\<squnion> y \\<squnion>\n        y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> = y", "have \"... \\<le> ?y\\<^sup>\\<star>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> - y\\<^sup>\\<star> \\<squnion> y \\<squnion> y\\<^sup>\\<star>\n    \\<le> (x \\<sqinter> - y\\<^sup>\\<star> \\<squnion> y)\\<^sup>\\<star>", "by (simp add: star.circ_increasing star.circ_sub_dist sup_commute)"], ["proof (state)\nthis:\n  x \\<sqinter> - y\\<^sup>\\<star> \\<squnion> y \\<squnion> y\\<^sup>\\<star>\n  \\<le> (x \\<sqinter> - y\\<^sup>\\<star> \\<squnion> y)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> = y", "finally"], ["proof (chain)\npicking this:\n  x \\<le> (x \\<sqinter> - y\\<^sup>\\<star> \\<squnion> y)\\<^sup>\\<star>", "have \"?y = x\""], ["proof (prove)\nusing this:\n  x \\<le> (x \\<sqinter> - y\\<^sup>\\<star> \\<squnion> y)\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x \\<sqinter> - y\\<^sup>\\<star> \\<squnion> y = x", "using 1 assms acyclic_3a_def"], ["proof (prove)\nusing this:\n  x \\<le> (x \\<sqinter> - y\\<^sup>\\<star> \\<squnion> y)\\<^sup>\\<star>\n  y \\<le> x\n  acyclic_3a x\n  acyclic_3a ?x \\<equiv>\n  \\<forall>y.\n     y \\<le> ?x \\<and> ?x \\<le> y\\<^sup>\\<star> \\<longrightarrow> y = ?x\n\ngoal (1 subgoal):\n 1. x \\<sqinter> - y\\<^sup>\\<star> \\<squnion> y = x", "by simp"], ["proof (state)\nthis:\n  x \\<sqinter> - y\\<^sup>\\<star> \\<squnion> y = x\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> = y", "hence \"x \\<sqinter> y\\<^sup>\\<star> = y \\<sqinter> y\\<^sup>\\<star>\""], ["proof (prove)\nusing this:\n  x \\<sqinter> - y\\<^sup>\\<star> \\<squnion> y = x\n\ngoal (1 subgoal):\n 1. x \\<sqinter> y\\<^sup>\\<star> = y \\<sqinter> y\\<^sup>\\<star>", "by (smt (z3) inf.sup_monoid.add_commute inf_sup_absorb inf_sup_distrib2 maddux_3_13 sup_commute sup_inf_absorb)"], ["proof (state)\nthis:\n  x \\<sqinter> y\\<^sup>\\<star> = y \\<sqinter> y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<le> x \\<Longrightarrow> x \\<sqinter> y\\<^sup>\\<star> = y", "thus \"x \\<sqinter> y\\<^sup>\\<star> = y\""], ["proof (prove)\nusing this:\n  x \\<sqinter> y\\<^sup>\\<star> = y \\<sqinter> y\\<^sup>\\<star>\n\ngoal (1 subgoal):\n 1. x \\<sqinter> y\\<^sup>\\<star> = y", "by (simp add: inf_absorb1 star.circ_increasing)"], ["proof (state)\nthis:\n  x \\<sqinter> y\\<^sup>\\<star> = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma acyclic_3a_4b:\n  \"acyclic_3a x \\<longleftrightarrow> acyclic_4b x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_3a x = acyclic_4b x", "using acyclic_3a_implies_4b acyclic_4a_4b acyclic_4a_implies_3a"], ["proof (prove)\nusing this:\n  acyclic_3a ?x \\<Longrightarrow> acyclic_4b ?x\n  acyclic_4a ?x = acyclic_4b ?x\n  acyclic_4a ?x \\<Longrightarrow> acyclic_3a ?x\n\ngoal (1 subgoal):\n 1. acyclic_3a x = acyclic_4b x", "by blast"], ["", "lemma acyclic_4_4a:\n  \"acyclic_4 x \\<longleftrightarrow> acyclic_4a x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic_4 x = acyclic_4a x", "by (simp add: acyclic_4_def acyclic_4a_def)"], ["", "subsection \\<open>Counterexamples\\<close>"], ["", "text \\<open>\nCalls to nitpick have been put into comments to save processing time.\n\\<close>"], ["", "text \\<open>independence of (0)\\<close>"], ["", "lemma \"symmetric x \\<Longrightarrow> irreflexive_inf x \\<Longrightarrow> orientable x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>symmetric x; irreflexive_inf x\\<rbrakk>\n    \\<Longrightarrow> orientable x", "text \\<open>nitpick[expect=genuine,card=4,timeout=600]\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>symmetric x; irreflexive_inf x\\<rbrakk>\n    \\<Longrightarrow> orientable x", "oops"], ["", "lemma \"linear_orderable_6 x \\<Longrightarrow> path_orderable x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_orderable_6 x \\<Longrightarrow> path_orderable x", "text \\<open>nitpick[expect=genuine,card=8,timeout=600]\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_orderable_6 x \\<Longrightarrow> path_orderable x", "oops"], ["", "text \\<open>(5) does not imply (6)\\<close>"], ["", "lemma \"symmetric x \\<Longrightarrow> irreflexive x \\<Longrightarrow> acyclic_5a x \\<Longrightarrow> acyclic_6 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>symmetric x; irreflexive x; acyclic_5a x\\<rbrakk>\n    \\<Longrightarrow> acyclic_6 x", "text \\<open>nitpick[expect=genuine,card=4,timeout=600]\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>symmetric x; irreflexive x; acyclic_5a x\\<rbrakk>\n    \\<Longrightarrow> acyclic_6 x", "oops"], ["", "text \\<open>(2) does not imply (4)\\<close>"], ["", "lemma \"symmetric x \\<Longrightarrow> irreflexive x \\<Longrightarrow> acyclic_2 x \\<Longrightarrow> acyclic_4 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>symmetric x; irreflexive x; acyclic_2 x\\<rbrakk>\n    \\<Longrightarrow> acyclic_4 x", "text \\<open>nitpick[expect=genuine,card=8,timeout=600]\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>symmetric x; irreflexive x; acyclic_2 x\\<rbrakk>\n    \\<Longrightarrow> acyclic_4 x", "oops"], ["", "end"], ["", "end"]]}