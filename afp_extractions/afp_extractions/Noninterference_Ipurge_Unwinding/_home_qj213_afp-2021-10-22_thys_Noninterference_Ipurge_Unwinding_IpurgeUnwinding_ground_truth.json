{"file_name": "/home/qj213/afp-2021-10-22/thys/Noninterference_Ipurge_Unwinding/IpurgeUnwinding.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Noninterference_Ipurge_Unwinding", "problem_names": ["lemma process_rule_2_traces:\n \"xs @ xs' \\<in> traces P \\<Longrightarrow> xs \\<in> traces P\"", "lemma process_rule_4 [rule_format]:\n \"(xs, X) \\<in> failures P \\<longrightarrow> (xs @ [x], {}) \\<in> failures P \\<or> (xs, insert x X) \\<in> failures P\"", "lemma failures_traces:\n \"(xs, X) \\<in> failures P \\<Longrightarrow> xs \\<in> traces P\"", "lemma traces_failures:\n \"xs \\<in> traces P \\<Longrightarrow> (xs, {}) \\<in> failures P\"", "lemma sinks_interference [rule_format]:\n \"D x \\<in> sinks I D u xs \\<longrightarrow>\n  (u, D x) \\<in> I \\<or> (\\<exists>v \\<in> sinks I D u xs. (v, D x) \\<in> I)\"", "lemma sinks_interference_eq:\n \"((u, D x) \\<in> I \\<or> (\\<exists>v \\<in> sinks I D u xs. (v, D x) \\<in> I)) =\n  (D x \\<in> sinks I D u (xs @ [x]))\"", "lemma\n  assumes A: \"\\<forall>xs A. (\\<forall>X \\<in> A. (xs, X) \\<in> failures P) \\<longrightarrow>\n    (xs, \\<Union>X \\<in> A. X) \\<in> failures P\"\n  shows \"\\<forall>xs. xs \\<in> traces P\"", "lemma traces_dom_events:\n  assumes A: \"u \\<in> range D\"\n  shows \"xs \\<in> traces P =\n    (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {})\"\n    (is \"_ = (?S \\<noteq> {})\")", "lemma fc_traces:\n  assumes\n    A: \"future_consistent P D R\" and\n    B: \"u \\<in> range D\" and\n    C: \"(xs, ys) \\<in> R u\"\n  shows \"(xs \\<in> traces P) = (ys \\<in> traces P)\"", "lemma wfc_traces:\n  assumes\n    A: \"weakly_future_consistent P I D R\" and\n    B: \"u \\<in> range D \\<inter> (-I) `` range D\" and\n    C: \"(xs, ys) \\<in> R u\"\n  shows \"(xs \\<in> traces P) = (ys \\<in> traces P)\"", "lemma fc_implies_wfc:\n \"future_consistent P D R \\<Longrightarrow> weakly_future_consistent P I D R\"", "lemma singleton_set_some:\n \"(\\<exists>Y. Y \\<in> singleton_set X) = (\\<exists>x. x \\<in> X)\"", "lemma singleton_set_union:\n \"(\\<Union>Y \\<in> singleton_set X. Y) = X\"", "lemma sinks_aux_subset:\n \"U \\<subseteq> sinks_aux I D U xs\"", "lemma sinks_aux_single_dom:\n \"sinks_aux I D {u} xs = insert u (sinks I D u xs)\"", "lemma sinks_aux_single_event:\n \"sinks_aux I D U [x] = (if \\<exists>v \\<in> U. (v, D x) \\<in> I\n   then insert (D x) U\n   else U)\"", "lemma sinks_aux_cons:\n \"sinks_aux I D U (x # xs) = (if \\<exists>v \\<in> U. (v, D x) \\<in> I\n   then sinks_aux I D (insert (D x) U) xs\n   else sinks_aux I D U xs)\"", "lemma ipurge_tr_aux_single_dom:\n \"ipurge_tr_aux I D {u} xs = ipurge_tr I D u xs\"", "lemma ipurge_ref_aux_single_dom:\n \"ipurge_ref_aux I D {u} xs X = ipurge_ref I D u xs X\"", "lemma ipurge_ref_aux_all [rule_format]:\n \"(\\<forall>u \\<in> U. \\<not> (\\<exists>v \\<in> D ` (X \\<union> set xs). (u, v) \\<in> I)) \\<longrightarrow>\n  ipurge_ref_aux I D U xs X = X\"", "lemma ipurge_ref_all:\n \"\\<not> (\\<exists>v \\<in> D ` (X \\<union> set xs). (u, v) \\<in> I) \\<Longrightarrow> ipurge_ref I D u xs X = X\"", "lemma unaffected_domains_single_dom:\n \"{x \\<in> X. D x \\<in> unaffected_domains I D {u} xs} = ipurge_ref I D u xs X\"", "lemma sources_sinks:\n \"sources I D u xs = sinks (I\\<inverse>) D u (rev xs)\"", "lemma sources_sinks_aux:\n \"sources_aux I D U xs = sinks_aux (I\\<inverse>) D U (rev xs)\"", "lemma sources_aux_subset:\n \"U \\<subseteq> sources_aux I D U xs\"", "lemma sources_aux_append:\n \"sources_aux I D U (xs @ ys) = sources_aux I D (sources_aux I D U ys) xs\"", "lemma sources_aux_append_nil [rule_format]:\n \"sources_aux I D U ys = U \\<longrightarrow>\n  sources_aux I D U (xs @ ys) = sources_aux I D U xs\"", "lemma ipurge_tr_rev_aux_append:\n \"ipurge_tr_rev_aux I D U (xs @ ys) =\n  ipurge_tr_rev_aux I D (sources_aux I D U ys) xs @ ipurge_tr_rev_aux I D U ys\"", "lemma ipurge_tr_rev_aux_nil_1 [rule_format]:\n \"ipurge_tr_rev_aux I D U xs = [] \\<longrightarrow> (\\<forall>u \\<in> U. \\<not> (\\<exists>v \\<in> D ` set xs. (v, u) \\<in> I))\"", "lemma ipurge_tr_rev_aux_nil_2 [rule_format]:\n \"(\\<forall>u \\<in> U. \\<not> (\\<exists>v \\<in> D ` set xs. (v, u) \\<in> I)) \\<longrightarrow> ipurge_tr_rev_aux I D U xs = []\"", "lemma ipurge_tr_rev_aux_nil:\n \"(ipurge_tr_rev_aux I D U xs = []) = (\\<forall>u \\<in> U. \\<not> (\\<exists>v \\<in> D ` set xs. (v, u) \\<in> I))\"", "lemma ipurge_tr_rev_aux_nil_sources [rule_format]:\n \"ipurge_tr_rev_aux I D U xs = [] \\<longrightarrow> sources_aux I D U xs = U\"", "lemma ipurge_tr_rev_aux_append_nil_1 [rule_format]:\n \"ipurge_tr_rev_aux I D U ys = [] \\<longrightarrow>\n  ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs\"", "lemma ipurge_tr_rev_aux_first [rule_format]:\n \"ipurge_tr_rev_aux I D U xs = x # ws \\<longrightarrow>\n  (\\<exists>ys zs. xs = ys @ x # zs \\<and>\n    ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n    (\\<exists>v \\<in> sources_aux I D U zs. (D x, v) \\<in> I))\"", "lemma ipurge_tr_rev_aux_last_1 [rule_format]:\n \"ipurge_tr_rev_aux I D U xs = ws @ [x] \\<longrightarrow> (\\<exists>v \\<in> U. (D x, v) \\<in> I)\"", "lemma ipurge_tr_rev_aux_last_2 [rule_format]:\n \"ipurge_tr_rev_aux I D U xs = ws @ [x] \\<longrightarrow>\n  (\\<exists>ys zs. xs = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = [])\"", "lemma ipurge_tr_rev_aux_all [rule_format]:\n \"(\\<forall>v \\<in> D ` set xs. \\<exists>u \\<in> U. (v, u) \\<in> I) \\<longrightarrow> ipurge_tr_rev_aux I D U xs = xs\"", "lemma offset_not_none_1 [rule_format]:\n \"offset k x xs \\<noteq> None \\<longrightarrow> (\\<exists>ys zs. xs = ys @ x # zs)\"", "lemma offset_not_none_2 [rule_format]:\n \"xs = ys @ x # zs \\<longrightarrow> offset k x xs \\<noteq> None\"", "lemma offset_not_none:\n \"(offset k x xs \\<noteq> None) = (\\<exists>ys zs. xs = ys @ x # zs)\"", "lemma offset_addition [rule_format]:\n \"offset k x xs \\<noteq> None \\<longrightarrow> offset (n + m) x xs = Some (the (offset n x xs) + m)\"", "lemma offset_suc:\n  assumes A: \"offset k x xs \\<noteq> None\"\n  shows \"offset (Suc n) x xs = Some (Suc (the (offset n x xs)))\"", "lemma ipurge_tr_rev_aux_first_offset [rule_format]:\n \"xs = ys @ x # zs \\<and> ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n    (\\<exists>v \\<in> sources_aux I D U zs. (D x, v) \\<in> I) \\<longrightarrow>\n  ys = take (the (offset 0 x xs)) xs\"", "lemma ipurge_tr_rev_aux_append_nil_2 [rule_format]:\n \"ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D V xs \\<longrightarrow>\n  ipurge_tr_rev_aux I D U ys = []\"", "lemma ipurge_tr_rev_aux_append_nil:\n \"(ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs) =\n  (ipurge_tr_rev_aux I D U ys = [])\"", "lemma Interleaves_ipurge_tr:\n \"xs \\<cong> {ipurge_tr_rev I D u xs, rev (ipurge_tr (I\\<inverse>) D u (rev xs)),\n    \\<lambda>y ys. D y \\<in> sinks (I\\<inverse>) D u (rev (y # ys))}\"", "lemma Interleaves_ipurge_tr_aux:\n \"xs \\<cong> {ipurge_tr_rev_aux I D U xs, rev (ipurge_tr_aux (I\\<inverse>) D U (rev xs)),\n    \\<lambda>y ys. \\<exists>v \\<in> sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}\"", "lemma ipurge_tr_aux_all:\n \"(ipurge_tr_aux I D U xs = xs) = (\\<forall>u \\<in> U. \\<not> (\\<exists>v \\<in> D ` set xs. (u, v) \\<in> I))\"", "lemma ipurge_tr_rev_aux_single_dom:\n \"ipurge_tr_rev_aux I D {u} xs = ipurge_tr_rev I D u xs\" (is \"?ys = ?ys'\")", "lemma ipurge_tr_all:\n \"(ipurge_tr I D u xs = xs) = (\\<not> (\\<exists>v \\<in> D ` set xs. (u, v) \\<in> I))\"", "lemma ipurge_tr_rev_all:\n \"\\<forall>v \\<in> D ` set xs. (v, u) \\<in> I \\<Longrightarrow> ipurge_tr_rev I D u xs = xs\"", "lemma rel_ipurge_aux_single_dom:\n \"rel_ipurge_aux P I D {u} = rel_ipurge P I D u\"", "lemma view_partition_rel_ipurge:\n \"view_partition P D (rel_ipurge P I D)\"", "lemma fc_equals_wfc_rel_ipurge:\n \"future_consistent P D (rel_ipurge P I D) =\n  weakly_future_consistent P I D (rel_ipurge P I D)\"", "lemma ipurge_tr_rev_ipurge_tr_aux_1 [rule_format]:\n \"U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\"", "lemma ipurge_tr_rev_ipurge_tr_aux_2 [rule_format]:\n \"U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n  ipurge_tr_rev_aux I D U (xs @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\"", "lemma ipurge_tr_rev_ipurge_tr_1:\n  assumes A: \"u \\<in> unaffected_domains I D {D y} zs\"\n  shows \"ipurge_tr_rev I D u (xs @ y # zs) =\n    ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)\"", "lemma ipurge_tr_rev_ipurge_tr_2:\n  assumes A: \"u \\<in> unaffected_domains I D {D y} zs\"\n  shows \"ipurge_tr_rev I D u (xs @ zs) =\n    ipurge_tr_rev I D u (xs @ y # ipurge_tr I D (D y) zs)\"", "lemma iu_condition_imply_secure_aux_1:\n  assumes\n    RUC: \"ref_union_closed P\" and\n    IU: \"weakly_future_consistent P I D (rel_ipurge P I D)\" and\n    A: \"(xs @ y # ys, Y) \\<in> failures P\" and\n    B: \"xs @ ipurge_tr I D (D y) ys \\<in> traces P\" and\n    C: \"\\<exists>y'. y' \\<in> ipurge_ref I D (D y) ys Y\"\n  shows \"(xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y) \\<in> failures P\"", "lemma iu_condition_imply_secure_aux_2:\n  assumes\n    RUC: \"ref_union_closed P\" and\n    IU: \"weakly_future_consistent P I D (rel_ipurge P I D)\" and\n    A: \"(xs @ zs, Z) \\<in> failures P\" and\n    B: \"xs @ y # ipurge_tr I D (D y) zs \\<in> traces P\" and\n    C: \"\\<exists>z'. z' \\<in> ipurge_ref I D (D y) zs Z\"\n  shows \"(xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z) \\<in> failures P\"", "lemma iu_condition_imply_secure_1 [rule_format]:\n  assumes\n    RUC: \"ref_union_closed P\" and\n    IU: \"weakly_future_consistent P I D (rel_ipurge P I D)\"\n  shows \"(xs @ y # ys, Y) \\<in> failures P \\<longrightarrow>\n    (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y) \\<in> failures P\"", "lemma iu_condition_imply_secure_2 [rule_format]:\n  assumes\n    RUC: \"ref_union_closed P\" and\n    IU: \"weakly_future_consistent P I D (rel_ipurge P I D)\" and\n    Y: \"xs @ [y] \\<in> traces P\"\n  shows \"(xs @ zs, Z) \\<in> failures P \\<longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z) \\<in> failures P\"", "theorem iu_condition_imply_secure:\n  assumes\n    RUC: \"ref_union_closed P\" and\n    IU: \"weakly_future_consistent P I D (rel_ipurge P I D)\"\n  shows \"secure P I D\"", "lemma secure_implies_failure_consistency_aux [rule_format]:\n  assumes S: \"secure P I D\"\n  shows \"(xs @ ys @ zs, X) \\<in> failures P \\<longrightarrow>\n    ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys = [] \\<longrightarrow> (xs @ zs, X) \\<in> failures P\"", "lemma secure_implies_failure_consistency [rule_format]:\n  assumes S: \"secure P I D\"\n  shows \"(xs, ys) \\<in> rel_ipurge_aux P I D (D ` (X \\<union> set zs)) \\<longrightarrow>\n    (xs @ zs, X) \\<in> failures P \\<longrightarrow> (ys @ zs, X) \\<in> failures P\"", "lemma secure_implies_trace_consistency:\n \"secure P I D \\<Longrightarrow> (xs, ys) \\<in> rel_ipurge_aux P I D (D ` set zs) \\<Longrightarrow>\n  xs @ zs \\<in> traces P \\<Longrightarrow> ys @ zs \\<in> traces P\"", "lemma secure_implies_next_event_consistency:\n \"secure P I D \\<Longrightarrow> (xs, ys) \\<in> rel_ipurge P I D (D x) \\<Longrightarrow>\n  x \\<in> next_events P xs \\<Longrightarrow> x \\<in> next_events P ys\"", "lemma secure_implies_refusal_consistency:\n \"secure P I D \\<Longrightarrow> (xs, ys) \\<in> rel_ipurge_aux P I D (D ` X) \\<Longrightarrow>\n  X \\<in> refusals P xs \\<Longrightarrow> X \\<in> refusals P ys\"", "lemma secure_implies_ref_event_consistency:\n \"secure P I D \\<Longrightarrow> (xs, ys) \\<in> rel_ipurge P I D (D x) \\<Longrightarrow>\n  {x} \\<in> refusals P xs \\<Longrightarrow> {x} \\<in> refusals P ys\"", "theorem secure_implies_iu_condition:\n  assumes S: \"secure P I D\"\n  shows \"future_consistent P D (rel_ipurge P I D)\"", "theorem ipurge_unwinding:\n \"ref_union_closed P \\<Longrightarrow>\n  secure P I D = weakly_future_consistent P I D (rel_ipurge P I D)\""], "translations": [["", "lemma process_rule_2_traces:\n \"xs @ xs' \\<in> traces P \\<Longrightarrow> xs \\<in> traces P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ xs' \\<in> traces P \\<Longrightarrow> xs \\<in> traces P", "proof (simp add: traces_def Domain_iff, erule exE, rule_tac x = \"{}\" in exI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       (xs @ xs', y) \\<in> failures P \\<Longrightarrow>\n       (xs, {}) \\<in> failures P", "qed (rule process_rule_2_failures)"], ["", "lemma process_rule_4 [rule_format]:\n \"(xs, X) \\<in> failures P \\<longrightarrow> (xs @ [x], {}) \\<in> failures P \\<or> (xs, insert x X) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs, X) \\<in> failures P \\<longrightarrow>\n    (xs @ [x], {}) \\<in> failures P \\<or> (xs, insert x X) \\<in> failures P", "proof (simp add: failures_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. (xs, X) \\<in> fst (Rep_process P) \\<longrightarrow>\n    (xs @ [x], {}) \\<in> fst (Rep_process P) \\<or>\n    (xs, insert x X) \\<in> fst (Rep_process P)", "have \"Rep_process P \\<in> process_set\" (is \"?P' \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_process P \\<in> process_set", "by (rule Rep_process)"], ["proof (state)\nthis:\n  Rep_process P \\<in> process_set\n\ngoal (1 subgoal):\n 1. (xs, X) \\<in> fst (Rep_process P) \\<longrightarrow>\n    (xs @ [x], {}) \\<in> fst (Rep_process P) \\<or>\n    (xs, insert x X) \\<in> fst (Rep_process P)", "hence \"\\<forall>xs x X. (xs, X) \\<in> fst ?P' \\<longrightarrow>\n    (xs @ [x], {}) \\<in> fst ?P' \\<or> (xs, insert x X) \\<in> fst ?P'\""], ["proof (prove)\nusing this:\n  Rep_process P \\<in> process_set\n\ngoal (1 subgoal):\n 1. \\<forall>xs x X.\n       (xs, X) \\<in> fst (Rep_process P) \\<longrightarrow>\n       (xs @ [x], {}) \\<in> fst (Rep_process P) \\<or>\n       (xs, insert x X) \\<in> fst (Rep_process P)", "by (simp add: process_set_def process_prop_4_def)"], ["proof (state)\nthis:\n  \\<forall>xs x X.\n     (xs, X) \\<in> fst (Rep_process P) \\<longrightarrow>\n     (xs @ [x], {}) \\<in> fst (Rep_process P) \\<or>\n     (xs, insert x X) \\<in> fst (Rep_process P)\n\ngoal (1 subgoal):\n 1. (xs, X) \\<in> fst (Rep_process P) \\<longrightarrow>\n    (xs @ [x], {}) \\<in> fst (Rep_process P) \\<or>\n    (xs, insert x X) \\<in> fst (Rep_process P)", "thus \"(xs, X) \\<in> fst ?P' \\<longrightarrow>\n    (xs @ [x], {}) \\<in> fst ?P' \\<or> (xs, insert x X) \\<in> fst ?P'\""], ["proof (prove)\nusing this:\n  \\<forall>xs x X.\n     (xs, X) \\<in> fst (Rep_process P) \\<longrightarrow>\n     (xs @ [x], {}) \\<in> fst (Rep_process P) \\<or>\n     (xs, insert x X) \\<in> fst (Rep_process P)\n\ngoal (1 subgoal):\n 1. (xs, X) \\<in> fst (Rep_process P) \\<longrightarrow>\n    (xs @ [x], {}) \\<in> fst (Rep_process P) \\<or>\n    (xs, insert x X) \\<in> fst (Rep_process P)", "by blast"], ["proof (state)\nthis:\n  (xs, X) \\<in> fst (Rep_process P) \\<longrightarrow>\n  (xs @ [x], {}) \\<in> fst (Rep_process P) \\<or>\n  (xs, insert x X) \\<in> fst (Rep_process P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma failures_traces:\n \"(xs, X) \\<in> failures P \\<Longrightarrow> xs \\<in> traces P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs, X) \\<in> failures P \\<Longrightarrow> xs \\<in> traces P", "by (simp add: traces_def Domain_iff, rule exI)"], ["", "lemma traces_failures:\n \"xs \\<in> traces P \\<Longrightarrow> (xs, {}) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> traces P \\<Longrightarrow> (xs, {}) \\<in> failures P", "proof (simp add: traces_def Domain_iff, erule exE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       (xs, y) \\<in> failures P \\<Longrightarrow> (xs, {}) \\<in> failures P", "qed (erule process_rule_3, simp)"], ["", "lemma sinks_interference [rule_format]:\n \"D x \\<in> sinks I D u xs \\<longrightarrow>\n  (u, D x) \\<in> I \\<or> (\\<exists>v \\<in> sinks I D u xs. (v, D x) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D x \\<in> sinks I D u xs \\<longrightarrow>\n    (u, D x) \\<in> I \\<or> (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I)", "proof (induction xs rule: rev_induct, simp, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>D x \\<in> sinks I D u xs \\<longrightarrow>\n                (u, D x) \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I);\n        D x \\<in> sinks I D u (xs @ [xa])\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [xa]).\n                             (v, D x) \\<in> I)", "fix x' xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>D x \\<in> sinks I D u xs \\<longrightarrow>\n                (u, D x) \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I);\n        D x \\<in> sinks I D u (xs @ [xa])\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [xa]).\n                             (v, D x) \\<in> I)", "assume\n    A: \"D x \\<in> sinks I D u xs \\<longrightarrow>\n      (u, D x) \\<in> I \\<or> (\\<exists>v \\<in> sinks I D u xs. (v, D x) \\<in> I)\" and\n    B: \"D x \\<in> sinks I D u (xs @ [x'])\""], ["proof (state)\nthis:\n  D x \\<in> sinks I D u xs \\<longrightarrow>\n  (u, D x) \\<in> I \\<or> (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I)\n  D x \\<in> sinks I D u (xs @ [x'])\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>D x \\<in> sinks I D u xs \\<longrightarrow>\n                (u, D x) \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I);\n        D x \\<in> sinks I D u (xs @ [xa])\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [xa]).\n                             (v, D x) \\<in> I)", "show \"(u, D x) \\<in> I \\<or> (\\<exists>v \\<in> sinks I D u (xs @ [x']). (v, D x) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "proof (cases \"(u, D x') \\<in> I \\<or> (\\<exists>v \\<in> sinks I D u xs. (v, D x') \\<in> I)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (u, D x') \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n 2. \\<not> ((u, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D u xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "case True"], ["proof (state)\nthis:\n  (u, D x') \\<in> I \\<or> (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I)\n\ngoal (2 subgoals):\n 1. (u, D x') \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n 2. \\<not> ((u, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D u xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "hence \"D x = D x' \\<or> D x \\<in> sinks I D u xs\""], ["proof (prove)\nusing this:\n  (u, D x') \\<in> I \\<or> (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I)\n\ngoal (1 subgoal):\n 1. D x = D x' \\<or> D x \\<in> sinks I D u xs", "using B"], ["proof (prove)\nusing this:\n  (u, D x') \\<in> I \\<or> (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I)\n  D x \\<in> sinks I D u (xs @ [x'])\n\ngoal (1 subgoal):\n 1. D x = D x' \\<or> D x \\<in> sinks I D u xs", "by simp"], ["proof (state)\nthis:\n  D x = D x' \\<or> D x \\<in> sinks I D u xs\n\ngoal (2 subgoals):\n 1. (u, D x') \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n 2. \\<not> ((u, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D u xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "moreover"], ["proof (state)\nthis:\n  D x = D x' \\<or> D x \\<in> sinks I D u xs\n\ngoal (2 subgoals):\n 1. (u, D x') \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n 2. \\<not> ((u, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D u xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "{"], ["proof (state)\nthis:\n  D x = D x' \\<or> D x \\<in> sinks I D u xs\n\ngoal (2 subgoals):\n 1. (u, D x') \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n 2. \\<not> ((u, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D u xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "assume C: \"D x = D x'\""], ["proof (state)\nthis:\n  D x = D x'\n\ngoal (2 subgoals):\n 1. (u, D x') \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n 2. \\<not> ((u, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D u xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "have ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "using True"], ["proof (prove)\nusing this:\n  (u, D x') \\<in> I \\<or> (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I)\n\ngoal (1 subgoal):\n 1. (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "proof (rule disjE, erule_tac [2] bexE)"], ["proof (state)\ngoal (2 subgoals):\n 1. (u, D x') \\<in> I \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n 2. \\<And>v.\n       \\<lbrakk>(u, D x') \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I);\n        v \\<in> sinks I D u xs; (v, D x') \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [x']).\n                             (v, D x) \\<in> I)", "assume \"(u, D x') \\<in> I\""], ["proof (state)\nthis:\n  (u, D x') \\<in> I\n\ngoal (2 subgoals):\n 1. (u, D x') \\<in> I \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n 2. \\<And>v.\n       \\<lbrakk>(u, D x') \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I);\n        v \\<in> sinks I D u xs; (v, D x') \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [x']).\n                             (v, D x) \\<in> I)", "hence \"(u, D x) \\<in> I\""], ["proof (prove)\nusing this:\n  (u, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. (u, D x) \\<in> I", "using C"], ["proof (prove)\nusing this:\n  (u, D x') \\<in> I\n  D x = D x'\n\ngoal (1 subgoal):\n 1. (u, D x) \\<in> I", "by simp"], ["proof (state)\nthis:\n  (u, D x) \\<in> I\n\ngoal (2 subgoals):\n 1. (u, D x') \\<in> I \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n 2. \\<And>v.\n       \\<lbrakk>(u, D x') \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I);\n        v \\<in> sinks I D u xs; (v, D x') \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [x']).\n                             (v, D x) \\<in> I)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", ".."], ["proof (state)\nthis:\n  (u, D x) \\<in> I \\<or>\n  (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, D x') \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I);\n        v \\<in> sinks I D u xs; (v, D x') \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [x']).\n                             (v, D x) \\<in> I)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, D x') \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I);\n        v \\<in> sinks I D u xs; (v, D x') \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [x']).\n                             (v, D x) \\<in> I)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, D x') \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I);\n        v \\<in> sinks I D u xs; (v, D x') \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [x']).\n                             (v, D x) \\<in> I)", "assume \"(v, D x') \\<in> I\""], ["proof (state)\nthis:\n  (v, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, D x') \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I);\n        v \\<in> sinks I D u xs; (v, D x') \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [x']).\n                             (v, D x) \\<in> I)", "hence \"(v, D x) \\<in> I\""], ["proof (prove)\nusing this:\n  (v, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. (v, D x) \\<in> I", "using C"], ["proof (prove)\nusing this:\n  (v, D x') \\<in> I\n  D x = D x'\n\ngoal (1 subgoal):\n 1. (v, D x) \\<in> I", "by simp"], ["proof (state)\nthis:\n  (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, D x') \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I);\n        v \\<in> sinks I D u xs; (v, D x') \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [x']).\n                             (v, D x) \\<in> I)", "moreover"], ["proof (state)\nthis:\n  (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, D x') \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I);\n        v \\<in> sinks I D u xs; (v, D x') \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [x']).\n                             (v, D x) \\<in> I)", "assume \"v \\<in> sinks I D u xs\""], ["proof (state)\nthis:\n  v \\<in> sinks I D u xs\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, D x') \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I);\n        v \\<in> sinks I D u xs; (v, D x') \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [x']).\n                             (v, D x) \\<in> I)", "hence \"v \\<in> sinks I D u (xs @ [x'])\""], ["proof (prove)\nusing this:\n  v \\<in> sinks I D u xs\n\ngoal (1 subgoal):\n 1. v \\<in> sinks I D u (xs @ [x'])", "by simp"], ["proof (state)\nthis:\n  v \\<in> sinks I D u (xs @ [x'])\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, D x') \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I);\n        v \\<in> sinks I D u xs; (v, D x') \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [x']).\n                             (v, D x) \\<in> I)", "ultimately"], ["proof (chain)\npicking this:\n  (v, D x) \\<in> I\n  v \\<in> sinks I D u (xs @ [x'])", "have \"\\<exists>v \\<in> sinks I D u (xs @ [x']). (v, D x) \\<in> I\""], ["proof (prove)\nusing this:\n  (v, D x) \\<in> I\n  v \\<in> sinks I D u (xs @ [x'])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, D x') \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I);\n        v \\<in> sinks I D u xs; (v, D x') \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [x']).\n                             (v, D x) \\<in> I)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", ".."], ["proof (state)\nthis:\n  (u, D x) \\<in> I \\<or>\n  (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (u, D x) \\<in> I \\<or>\n  (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n\ngoal (2 subgoals):\n 1. (u, D x') \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n 2. \\<not> ((u, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D u xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "}"], ["proof (state)\nthis:\n  D x = D x' \\<Longrightarrow>\n  (u, D x) \\<in> I \\<or>\n  (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n\ngoal (2 subgoals):\n 1. (u, D x') \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n 2. \\<not> ((u, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D u xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "moreover"], ["proof (state)\nthis:\n  D x = D x' \\<Longrightarrow>\n  (u, D x) \\<in> I \\<or>\n  (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n\ngoal (2 subgoals):\n 1. (u, D x') \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n 2. \\<not> ((u, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D u xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "{"], ["proof (state)\nthis:\n  D x = D x' \\<Longrightarrow>\n  (u, D x) \\<in> I \\<or>\n  (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n\ngoal (2 subgoals):\n 1. (u, D x') \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n 2. \\<not> ((u, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D u xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "assume \"D x \\<in> sinks I D u xs\""], ["proof (state)\nthis:\n  D x \\<in> sinks I D u xs\n\ngoal (2 subgoals):\n 1. (u, D x') \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n 2. \\<not> ((u, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D u xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "with A"], ["proof (chain)\npicking this:\n  D x \\<in> sinks I D u xs \\<longrightarrow>\n  (u, D x) \\<in> I \\<or> (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I)\n  D x \\<in> sinks I D u xs", "have \"(u, D x) \\<in> I \\<or> (\\<exists>v \\<in> sinks I D u xs. (v, D x) \\<in> I)\""], ["proof (prove)\nusing this:\n  D x \\<in> sinks I D u xs \\<longrightarrow>\n  (u, D x) \\<in> I \\<or> (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I)\n  D x \\<in> sinks I D u xs\n\ngoal (1 subgoal):\n 1. (u, D x) \\<in> I \\<or> (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I)", ".."], ["proof (state)\nthis:\n  (u, D x) \\<in> I \\<or> (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I)\n\ngoal (2 subgoals):\n 1. (u, D x') \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n 2. \\<not> ((u, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D u xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "hence ?thesis"], ["proof (prove)\nusing this:\n  (u, D x) \\<in> I \\<or> (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "proof (rule disjE, erule_tac [2] bexE)"], ["proof (state)\ngoal (2 subgoals):\n 1. (u, D x) \\<in> I \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n 2. \\<And>v.\n       \\<lbrakk>(u, D x) \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I);\n        v \\<in> sinks I D u xs; (v, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [x']).\n                             (v, D x) \\<in> I)", "assume \"(u, D x) \\<in> I\""], ["proof (state)\nthis:\n  (u, D x) \\<in> I\n\ngoal (2 subgoals):\n 1. (u, D x) \\<in> I \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n 2. \\<And>v.\n       \\<lbrakk>(u, D x) \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I);\n        v \\<in> sinks I D u xs; (v, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [x']).\n                             (v, D x) \\<in> I)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (u, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", ".."], ["proof (state)\nthis:\n  (u, D x) \\<in> I \\<or>\n  (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, D x) \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I);\n        v \\<in> sinks I D u xs; (v, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [x']).\n                             (v, D x) \\<in> I)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, D x) \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I);\n        v \\<in> sinks I D u xs; (v, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [x']).\n                             (v, D x) \\<in> I)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, D x) \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I);\n        v \\<in> sinks I D u xs; (v, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [x']).\n                             (v, D x) \\<in> I)", "assume \"(v, D x) \\<in> I\""], ["proof (state)\nthis:\n  (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, D x) \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I);\n        v \\<in> sinks I D u xs; (v, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [x']).\n                             (v, D x) \\<in> I)", "moreover"], ["proof (state)\nthis:\n  (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, D x) \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I);\n        v \\<in> sinks I D u xs; (v, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [x']).\n                             (v, D x) \\<in> I)", "assume \"v \\<in> sinks I D u xs\""], ["proof (state)\nthis:\n  v \\<in> sinks I D u xs\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, D x) \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I);\n        v \\<in> sinks I D u xs; (v, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [x']).\n                             (v, D x) \\<in> I)", "hence \"v \\<in> sinks I D u (xs @ [x'])\""], ["proof (prove)\nusing this:\n  v \\<in> sinks I D u xs\n\ngoal (1 subgoal):\n 1. v \\<in> sinks I D u (xs @ [x'])", "by simp"], ["proof (state)\nthis:\n  v \\<in> sinks I D u (xs @ [x'])\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, D x) \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I);\n        v \\<in> sinks I D u xs; (v, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [x']).\n                             (v, D x) \\<in> I)", "ultimately"], ["proof (chain)\npicking this:\n  (v, D x) \\<in> I\n  v \\<in> sinks I D u (xs @ [x'])", "have \"\\<exists>v \\<in> sinks I D u (xs @ [x']). (v, D x) \\<in> I\""], ["proof (prove)\nusing this:\n  (v, D x) \\<in> I\n  v \\<in> sinks I D u (xs @ [x'])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>(u, D x) \\<in> I \\<or>\n                (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I);\n        v \\<in> sinks I D u xs; (v, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> (u, D x) \\<in> I \\<or>\n                         (\\<exists>v\\<in>sinks I D u (xs @ [x']).\n                             (v, D x) \\<in> I)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", ".."], ["proof (state)\nthis:\n  (u, D x) \\<in> I \\<or>\n  (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (u, D x) \\<in> I \\<or>\n  (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n\ngoal (2 subgoals):\n 1. (u, D x') \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n 2. \\<not> ((u, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D u xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "}"], ["proof (state)\nthis:\n  D x \\<in> sinks I D u xs \\<Longrightarrow>\n  (u, D x) \\<in> I \\<or>\n  (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n\ngoal (2 subgoals):\n 1. (u, D x') \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n 2. \\<not> ((u, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D u xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "ultimately"], ["proof (chain)\npicking this:\n  D x = D x' \\<or> D x \\<in> sinks I D u xs\n  D x = D x' \\<Longrightarrow>\n  (u, D x) \\<in> I \\<or>\n  (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n  D x \\<in> sinks I D u xs \\<Longrightarrow>\n  (u, D x) \\<in> I \\<or>\n  (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "show ?thesis"], ["proof (prove)\nusing this:\n  D x = D x' \\<or> D x \\<in> sinks I D u xs\n  D x = D x' \\<Longrightarrow>\n  (u, D x) \\<in> I \\<or>\n  (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n  D x \\<in> sinks I D u xs \\<Longrightarrow>\n  (u, D x) \\<in> I \\<or>\n  (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", ".."], ["proof (state)\nthis:\n  (u, D x) \\<in> I \\<or>\n  (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> ((u, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D u xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((u, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D u xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "case False"], ["proof (state)\nthis:\n  \\<not> ((u, D x') \\<in> I \\<or>\n          (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I))\n\ngoal (1 subgoal):\n 1. \\<not> ((u, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D u xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "hence C: \"sinks I D u (xs @ [x']) = sinks I D u xs\""], ["proof (prove)\nusing this:\n  \\<not> ((u, D x') \\<in> I \\<or>\n          (\\<exists>v\\<in>sinks I D u xs. (v, D x') \\<in> I))\n\ngoal (1 subgoal):\n 1. sinks I D u (xs @ [x']) = sinks I D u xs", "by simp"], ["proof (state)\nthis:\n  sinks I D u (xs @ [x']) = sinks I D u xs\n\ngoal (1 subgoal):\n 1. \\<not> ((u, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D u xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "hence \"D x \\<in> sinks I D u xs\""], ["proof (prove)\nusing this:\n  sinks I D u (xs @ [x']) = sinks I D u xs\n\ngoal (1 subgoal):\n 1. D x \\<in> sinks I D u xs", "using B"], ["proof (prove)\nusing this:\n  sinks I D u (xs @ [x']) = sinks I D u xs\n  D x \\<in> sinks I D u (xs @ [x'])\n\ngoal (1 subgoal):\n 1. D x \\<in> sinks I D u xs", "by simp"], ["proof (state)\nthis:\n  D x \\<in> sinks I D u xs\n\ngoal (1 subgoal):\n 1. \\<not> ((u, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D u xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "with A"], ["proof (chain)\npicking this:\n  D x \\<in> sinks I D u xs \\<longrightarrow>\n  (u, D x) \\<in> I \\<or> (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I)\n  D x \\<in> sinks I D u xs", "have \"(u, D x) \\<in> I \\<or> (\\<exists>v \\<in> sinks I D u xs. (v, D x) \\<in> I)\""], ["proof (prove)\nusing this:\n  D x \\<in> sinks I D u xs \\<longrightarrow>\n  (u, D x) \\<in> I \\<or> (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I)\n  D x \\<in> sinks I D u xs\n\ngoal (1 subgoal):\n 1. (u, D x) \\<in> I \\<or> (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I)", ".."], ["proof (state)\nthis:\n  (u, D x) \\<in> I \\<or> (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> ((u, D x') \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D u xs.\n                (v, D x') \\<in> I)) \\<Longrightarrow>\n    (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (u, D x) \\<in> I \\<or> (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "using C"], ["proof (prove)\nusing this:\n  (u, D x) \\<in> I \\<or> (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I)\n  sinks I D u (xs @ [x']) = sinks I D u xs\n\ngoal (1 subgoal):\n 1. (u, D x) \\<in> I \\<or>\n    (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)", "by simp"], ["proof (state)\nthis:\n  (u, D x) \\<in> I \\<or>\n  (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (u, D x) \\<in> I \\<or>\n  (\\<exists>v\\<in>sinks I D u (xs @ [x']). (v, D x) \\<in> I)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sinks_interference_eq:\n \"((u, D x) \\<in> I \\<or> (\\<exists>v \\<in> sinks I D u xs. (v, D x) \\<in> I)) =\n  (D x \\<in> sinks I D u (xs @ [x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((u, D x) \\<in> I \\<or>\n     (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I)) =\n    (D x \\<in> sinks I D u (xs @ [x]))", "proof (rule iffI, erule_tac [2] contrapos_pp, simp_all (no_asm_simp))"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> ((u, D x) \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D u xs.\n                (v, D x) \\<in> I)) \\<Longrightarrow>\n    D x \\<notin> sinks I D u xs", "qed (erule contrapos_nn, rule sinks_interference)"], ["", "text \\<open>\n\\null\n\nIn what follows, some lemmas concerning the constants defined above are proven.\n\nIn the definition of predicate @{term ref_union_closed}, the conclusion that the union of a set of\nrefusals is itself a refusal for the same trace is subordinated to the condition that the set of\nrefusals be nonempty. The first lemma shows that in the absence of this condition, the predicate\ncould only be satisfied by a process admitting any event list as a trace, which proves that the\ncondition must be present for the definition to be correct.\n\nThe subsequent lemmas prove that, for each domain \\emph{u} in the ranges respectively taken into\nconsideration, the image of \\emph{u} under a future consistent or weakly future consistent\ndomain-relation map may only correlate a pair of event lists such that either both are traces, or\nboth are not traces. Finally, it is demonstrated that future consistency implies weak future\nconsistency.\n\n\\null\n\\<close>"], ["", "lemma\n  assumes A: \"\\<forall>xs A. (\\<forall>X \\<in> A. (xs, X) \\<in> failures P) \\<longrightarrow>\n    (xs, \\<Union>X \\<in> A. X) \\<in> failures P\"\n  shows \"\\<forall>xs. xs \\<in> traces P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xs. xs \\<in> traces P", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs. xs \\<in> traces P", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs. xs \\<in> traces P", "have \"(\\<forall>X \\<in> {}. (xs, X) \\<in> failures P) \\<longrightarrow> (xs, \\<Union>X \\<in> {}. X) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>X\\<in>{}. (xs, X) \\<in> failures P) \\<longrightarrow>\n    (xs, \\<Union>X\\<in>{}. X) \\<in> failures P", "using A"], ["proof (prove)\nusing this:\n  \\<forall>xs A.\n     (\\<forall>X\\<in>A. (xs, X) \\<in> failures P) \\<longrightarrow>\n     (xs, \\<Union>X\\<in>A. X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (\\<forall>X\\<in>{}. (xs, X) \\<in> failures P) \\<longrightarrow>\n    (xs, \\<Union>X\\<in>{}. X) \\<in> failures P", "by blast"], ["proof (state)\nthis:\n  (\\<forall>X\\<in>{}. (xs, X) \\<in> failures P) \\<longrightarrow>\n  (xs, \\<Union>X\\<in>{}. X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>xs. xs \\<in> traces P", "moreover"], ["proof (state)\nthis:\n  (\\<forall>X\\<in>{}. (xs, X) \\<in> failures P) \\<longrightarrow>\n  (xs, \\<Union>X\\<in>{}. X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>xs. xs \\<in> traces P", "have \"\\<forall>X \\<in> {}. (xs, X) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>{}. (xs, X) \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  \\<forall>X\\<in>{}. (xs, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>xs. xs \\<in> traces P", "ultimately"], ["proof (chain)\npicking this:\n  (\\<forall>X\\<in>{}. (xs, X) \\<in> failures P) \\<longrightarrow>\n  (xs, \\<Union>X\\<in>{}. X) \\<in> failures P\n  \\<forall>X\\<in>{}. (xs, X) \\<in> failures P", "have \"(xs, \\<Union>X \\<in> {}. X) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (\\<forall>X\\<in>{}. (xs, X) \\<in> failures P) \\<longrightarrow>\n  (xs, \\<Union>X\\<in>{}. X) \\<in> failures P\n  \\<forall>X\\<in>{}. (xs, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs, \\<Union>X\\<in>{}. X) \\<in> failures P", ".."], ["proof (state)\nthis:\n  (xs, \\<Union>X\\<in>{}. X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>xs. xs \\<in> traces P", "thus \"xs \\<in> traces P\""], ["proof (prove)\nusing this:\n  (xs, \\<Union>X\\<in>{}. X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. xs \\<in> traces P", "by (rule failures_traces)"], ["proof (state)\nthis:\n  xs \\<in> traces P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma traces_dom_events:\n  assumes A: \"u \\<in> range D\"\n  shows \"xs \\<in> traces P =\n    (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {})\"\n    (is \"_ = (?S \\<noteq> {})\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) =\n    (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. xs \\<in> traces P \\<Longrightarrow>\n    next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}\n 2. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "have \"\\<exists>x. u = D x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. u = D x", "using A"], ["proof (prove)\nusing this:\n  u \\<in> range D\n\ngoal (1 subgoal):\n 1. \\<exists>x. u = D x", "by (simp add: image_def)"], ["proof (state)\nthis:\n  \\<exists>x. u = D x\n\ngoal (2 subgoals):\n 1. xs \\<in> traces P \\<Longrightarrow>\n    next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}\n 2. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "then"], ["proof (chain)\npicking this:\n  \\<exists>x. u = D x", "obtain x where B: \"u = D x\""], ["proof (prove)\nusing this:\n  \\<exists>x. u = D x\n\ngoal (1 subgoal):\n 1. (\\<And>x. u = D x \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", ".."], ["proof (state)\nthis:\n  u = D x\n\ngoal (2 subgoals):\n 1. xs \\<in> traces P \\<Longrightarrow>\n    next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}\n 2. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "assume \"xs \\<in> traces P\""], ["proof (state)\nthis:\n  xs \\<in> traces P\n\ngoal (2 subgoals):\n 1. xs \\<in> traces P \\<Longrightarrow>\n    next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}\n 2. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "hence \"(xs, {}) \\<in> failures P\""], ["proof (prove)\nusing this:\n  xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. (xs, {}) \\<in> failures P", "by (rule traces_failures)"], ["proof (state)\nthis:\n  (xs, {}) \\<in> failures P\n\ngoal (2 subgoals):\n 1. xs \\<in> traces P \\<Longrightarrow>\n    next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}\n 2. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "hence \"(xs @ [x], {}) \\<in> failures P \\<or> (xs, {x}) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (xs, {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ [x], {}) \\<in> failures P \\<or> (xs, {x}) \\<in> failures P", "by (rule process_rule_4)"], ["proof (state)\nthis:\n  (xs @ [x], {}) \\<in> failures P \\<or> (xs, {x}) \\<in> failures P\n\ngoal (2 subgoals):\n 1. xs \\<in> traces P \\<Longrightarrow>\n    next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}\n 2. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "moreover"], ["proof (state)\nthis:\n  (xs @ [x], {}) \\<in> failures P \\<or> (xs, {x}) \\<in> failures P\n\ngoal (2 subgoals):\n 1. xs \\<in> traces P \\<Longrightarrow>\n    next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}\n 2. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "{"], ["proof (state)\nthis:\n  (xs @ [x], {}) \\<in> failures P \\<or> (xs, {x}) \\<in> failures P\n\ngoal (2 subgoals):\n 1. xs \\<in> traces P \\<Longrightarrow>\n    next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}\n 2. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "assume \"(xs @ [x], {}) \\<in> failures P\""], ["proof (state)\nthis:\n  (xs @ [x], {}) \\<in> failures P\n\ngoal (2 subgoals):\n 1. xs \\<in> traces P \\<Longrightarrow>\n    next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}\n 2. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "hence \"xs @ [x] \\<in> traces P\""], ["proof (prove)\nusing this:\n  (xs @ [x], {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. xs @ [x] \\<in> traces P", "by (rule failures_traces)"], ["proof (state)\nthis:\n  xs @ [x] \\<in> traces P\n\ngoal (2 subgoals):\n 1. xs \\<in> traces P \\<Longrightarrow>\n    next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}\n 2. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "hence \"x \\<in> next_dom_events P D u xs\""], ["proof (prove)\nusing this:\n  xs @ [x] \\<in> traces P\n\ngoal (1 subgoal):\n 1. x \\<in> next_dom_events P D u xs", "using B"], ["proof (prove)\nusing this:\n  xs @ [x] \\<in> traces P\n  u = D x\n\ngoal (1 subgoal):\n 1. x \\<in> next_dom_events P D u xs", "by (simp add: next_dom_events_def next_events_def)"], ["proof (state)\nthis:\n  x \\<in> next_dom_events P D u xs\n\ngoal (2 subgoals):\n 1. xs \\<in> traces P \\<Longrightarrow>\n    next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}\n 2. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "hence \"x \\<in> ?S\""], ["proof (prove)\nusing this:\n  x \\<in> next_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs", ".."], ["proof (state)\nthis:\n  x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs\n\ngoal (2 subgoals):\n 1. xs \\<in> traces P \\<Longrightarrow>\n    next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}\n 2. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "}"], ["proof (state)\nthis:\n  (xs @ [x], {}) \\<in> failures P \\<Longrightarrow>\n  x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs\n\ngoal (2 subgoals):\n 1. xs \\<in> traces P \\<Longrightarrow>\n    next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}\n 2. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "moreover"], ["proof (state)\nthis:\n  (xs @ [x], {}) \\<in> failures P \\<Longrightarrow>\n  x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs\n\ngoal (2 subgoals):\n 1. xs \\<in> traces P \\<Longrightarrow>\n    next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}\n 2. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "{"], ["proof (state)\nthis:\n  (xs @ [x], {}) \\<in> failures P \\<Longrightarrow>\n  x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs\n\ngoal (2 subgoals):\n 1. xs \\<in> traces P \\<Longrightarrow>\n    next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}\n 2. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "assume \"(xs, {x}) \\<in> failures P\""], ["proof (state)\nthis:\n  (xs, {x}) \\<in> failures P\n\ngoal (2 subgoals):\n 1. xs \\<in> traces P \\<Longrightarrow>\n    next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}\n 2. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "hence \"x \\<in> ref_dom_events P D u xs\""], ["proof (prove)\nusing this:\n  (xs, {x}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. x \\<in> ref_dom_events P D u xs", "using B"], ["proof (prove)\nusing this:\n  (xs, {x}) \\<in> failures P\n  u = D x\n\ngoal (1 subgoal):\n 1. x \\<in> ref_dom_events P D u xs", "by (simp add: ref_dom_events_def refusals_def)"], ["proof (state)\nthis:\n  x \\<in> ref_dom_events P D u xs\n\ngoal (2 subgoals):\n 1. xs \\<in> traces P \\<Longrightarrow>\n    next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}\n 2. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "hence \"x \\<in> ?S\""], ["proof (prove)\nusing this:\n  x \\<in> ref_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs", ".."], ["proof (state)\nthis:\n  x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs\n\ngoal (2 subgoals):\n 1. xs \\<in> traces P \\<Longrightarrow>\n    next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}\n 2. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "}"], ["proof (state)\nthis:\n  (xs, {x}) \\<in> failures P \\<Longrightarrow>\n  x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs\n\ngoal (2 subgoals):\n 1. xs \\<in> traces P \\<Longrightarrow>\n    next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}\n 2. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "ultimately"], ["proof (chain)\npicking this:\n  (xs @ [x], {}) \\<in> failures P \\<or> (xs, {x}) \\<in> failures P\n  (xs @ [x], {}) \\<in> failures P \\<Longrightarrow>\n  x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs\n  (xs, {x}) \\<in> failures P \\<Longrightarrow>\n  x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs", "have \"x \\<in> ?S\""], ["proof (prove)\nusing this:\n  (xs @ [x], {}) \\<in> failures P \\<or> (xs, {x}) \\<in> failures P\n  (xs @ [x], {}) \\<in> failures P \\<Longrightarrow>\n  x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs\n  (xs, {x}) \\<in> failures P \\<Longrightarrow>\n  x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs", ".."], ["proof (state)\nthis:\n  x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs\n\ngoal (2 subgoals):\n 1. xs \\<in> traces P \\<Longrightarrow>\n    next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}\n 2. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "hence \"\\<exists>x. x \\<in> ?S\""], ["proof (prove)\nusing this:\n  x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs", ".."], ["proof (state)\nthis:\n  \\<exists>x.\n     x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs\n\ngoal (2 subgoals):\n 1. xs \\<in> traces P \\<Longrightarrow>\n    next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}\n 2. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "thus \"?S \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}", "by (subst ex_in_conv [symmetric])"], ["proof (state)\nthis:\n  next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "assume \"?S \\<noteq> {}\""], ["proof (state)\nthis:\n  next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "hence \"\\<exists>x. x \\<in> ?S\""], ["proof (prove)\nusing this:\n  next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs", "by (subst ex_in_conv)"], ["proof (state)\nthis:\n  \\<exists>x.\n     x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "then"], ["proof (chain)\npicking this:\n  \\<exists>x.\n     x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs", "obtain x where \"x \\<in> ?S\""], ["proof (prove)\nusing this:\n  \\<exists>x.\n     x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> next_dom_events P D u xs \\<union>\n                ref_dom_events P D u xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "moreover"], ["proof (state)\nthis:\n  x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "{"], ["proof (state)\nthis:\n  x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "assume \"x \\<in> next_dom_events P D u xs\""], ["proof (state)\nthis:\n  x \\<in> next_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "hence \"xs @ [x] \\<in> traces P\""], ["proof (prove)\nusing this:\n  x \\<in> next_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. xs @ [x] \\<in> traces P", "by (simp add: next_dom_events_def next_events_def)"], ["proof (state)\nthis:\n  xs @ [x] \\<in> traces P\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "hence \"xs \\<in> traces P\""], ["proof (prove)\nusing this:\n  xs @ [x] \\<in> traces P\n\ngoal (1 subgoal):\n 1. xs \\<in> traces P", "by (rule process_rule_2_traces)"], ["proof (state)\nthis:\n  xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "}"], ["proof (state)\nthis:\n  x \\<in> next_dom_events P D u xs \\<Longrightarrow> xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "moreover"], ["proof (state)\nthis:\n  x \\<in> next_dom_events P D u xs \\<Longrightarrow> xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "{"], ["proof (state)\nthis:\n  x \\<in> next_dom_events P D u xs \\<Longrightarrow> xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "assume \"x \\<in> ref_dom_events P D u xs\""], ["proof (state)\nthis:\n  x \\<in> ref_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "hence \"(xs, {x}) \\<in> failures P\""], ["proof (prove)\nusing this:\n  x \\<in> ref_dom_events P D u xs\n\ngoal (1 subgoal):\n 1. (xs, {x}) \\<in> failures P", "by (simp add: ref_dom_events_def refusals_def)"], ["proof (state)\nthis:\n  (xs, {x}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "hence \"xs \\<in> traces P\""], ["proof (prove)\nusing this:\n  (xs, {x}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. xs \\<in> traces P", "by (rule failures_traces)"], ["proof (state)\nthis:\n  xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "}"], ["proof (state)\nthis:\n  x \\<in> ref_dom_events P D u xs \\<Longrightarrow> xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n    {} \\<Longrightarrow>\n    xs \\<in> traces P", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs\n  x \\<in> next_dom_events P D u xs \\<Longrightarrow> xs \\<in> traces P\n  x \\<in> ref_dom_events P D u xs \\<Longrightarrow> xs \\<in> traces P", "show \"xs \\<in> traces P\""], ["proof (prove)\nusing this:\n  x \\<in> next_dom_events P D u xs \\<union> ref_dom_events P D u xs\n  x \\<in> next_dom_events P D u xs \\<Longrightarrow> xs \\<in> traces P\n  x \\<in> ref_dom_events P D u xs \\<Longrightarrow> xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. xs \\<in> traces P", ".."], ["proof (state)\nthis:\n  xs \\<in> traces P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fc_traces:\n  assumes\n    A: \"future_consistent P D R\" and\n    B: \"u \\<in> range D\" and\n    C: \"(xs, ys) \\<in> R u\"\n  shows \"(xs \\<in> traces P) = (ys \\<in> traces P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "have \"\\<forall>u \\<in> range D. \\<forall>xs ys. (xs, ys) \\<in> R u \\<longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>range D.\n       \\<forall>xs ys.\n          (xs, ys) \\<in> R u \\<longrightarrow>\n          next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n          ref_dom_events P D u xs = ref_dom_events P D u ys", "using A"], ["proof (prove)\nusing this:\n  future_consistent P D R\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>range D.\n       \\<forall>xs ys.\n          (xs, ys) \\<in> R u \\<longrightarrow>\n          next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n          ref_dom_events P D u xs = ref_dom_events P D u ys", "by (simp add: future_consistent_def)"], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> R u \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n        ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "hence \"\\<forall>xs ys. (xs, ys) \\<in> R u \\<longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> R u \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n        ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. \\<forall>xs ys.\n       (xs, ys) \\<in> R u \\<longrightarrow>\n       next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n       ref_dom_events P D u xs = ref_dom_events P D u ys", "using B"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> R u \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n        ref_dom_events P D u xs = ref_dom_events P D u ys\n  u \\<in> range D\n\ngoal (1 subgoal):\n 1. \\<forall>xs ys.\n       (xs, ys) \\<in> R u \\<longrightarrow>\n       next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n       ref_dom_events P D u xs = ref_dom_events P D u ys", ".."], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     (xs, ys) \\<in> R u \\<longrightarrow>\n     next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n     ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "hence \"(xs, ys) \\<in> R u \\<longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys\""], ["proof (prove)\nusing this:\n  \\<forall>xs ys.\n     (xs, ys) \\<in> R u \\<longrightarrow>\n     next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n     ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. (xs, ys) \\<in> R u \\<longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys", "by blast"], ["proof (state)\nthis:\n  (xs, ys) \\<in> R u \\<longrightarrow>\n  next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n  ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "hence \"next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys\""], ["proof (prove)\nusing this:\n  (xs, ys) \\<in> R u \\<longrightarrow>\n  next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n  ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys", "using C"], ["proof (prove)\nusing this:\n  (xs, ys) \\<in> R u \\<longrightarrow>\n  next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n  ref_dom_events P D u xs = ref_dom_events P D u ys\n  (xs, ys) \\<in> R u\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys", ".."], ["proof (state)\nthis:\n  next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n  ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "hence \"next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {} =\n    (next_dom_events P D u ys \\<union> ref_dom_events P D u ys \\<noteq> {})\""], ["proof (prove)\nusing this:\n  next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n  ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n     {}) =\n    (next_dom_events P D u ys \\<union> ref_dom_events P D u ys \\<noteq> {})", "by simp"], ["proof (state)\nthis:\n  (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}) =\n  (next_dom_events P D u ys \\<union> ref_dom_events P D u ys \\<noteq> {})\n\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "moreover"], ["proof (state)\nthis:\n  (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}) =\n  (next_dom_events P D u ys \\<union> ref_dom_events P D u ys \\<noteq> {})\n\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "have \"xs \\<in> traces P =\n    (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) =\n    (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {})", "using B"], ["proof (prove)\nusing this:\n  u \\<in> range D\n\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) =\n    (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {})", "by (rule traces_dom_events)"], ["proof (state)\nthis:\n  (xs \\<in> traces P) =\n  (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {})\n\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "moreover"], ["proof (state)\nthis:\n  (xs \\<in> traces P) =\n  (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {})\n\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "have \"ys \\<in> traces P =\n    (next_dom_events P D u ys \\<union> ref_dom_events P D u ys \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ys \\<in> traces P) =\n    (next_dom_events P D u ys \\<union> ref_dom_events P D u ys \\<noteq> {})", "using B"], ["proof (prove)\nusing this:\n  u \\<in> range D\n\ngoal (1 subgoal):\n 1. (ys \\<in> traces P) =\n    (next_dom_events P D u ys \\<union> ref_dom_events P D u ys \\<noteq> {})", "by (rule traces_dom_events)"], ["proof (state)\nthis:\n  (ys \\<in> traces P) =\n  (next_dom_events P D u ys \\<union> ref_dom_events P D u ys \\<noteq> {})\n\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "ultimately"], ["proof (chain)\npicking this:\n  (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}) =\n  (next_dom_events P D u ys \\<union> ref_dom_events P D u ys \\<noteq> {})\n  (xs \\<in> traces P) =\n  (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {})\n  (ys \\<in> traces P) =\n  (next_dom_events P D u ys \\<union> ref_dom_events P D u ys \\<noteq> {})", "show ?thesis"], ["proof (prove)\nusing this:\n  (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}) =\n  (next_dom_events P D u ys \\<union> ref_dom_events P D u ys \\<noteq> {})\n  (xs \\<in> traces P) =\n  (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {})\n  (ys \\<in> traces P) =\n  (next_dom_events P D u ys \\<union> ref_dom_events P D u ys \\<noteq> {})\n\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "by simp"], ["proof (state)\nthis:\n  (xs \\<in> traces P) = (ys \\<in> traces P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wfc_traces:\n  assumes\n    A: \"weakly_future_consistent P I D R\" and\n    B: \"u \\<in> range D \\<inter> (-I) `` range D\" and\n    C: \"(xs, ys) \\<in> R u\"\n  shows \"(xs \\<in> traces P) = (ys \\<in> traces P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "have \"\\<forall>u \\<in> range D \\<inter> (-I) `` range D. \\<forall>xs ys. (xs, ys) \\<in> R u \\<longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n       \\<forall>xs ys.\n          (xs, ys) \\<in> R u \\<longrightarrow>\n          next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n          ref_dom_events P D u xs = ref_dom_events P D u ys", "using A"], ["proof (prove)\nusing this:\n  weakly_future_consistent P I D R\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n       \\<forall>xs ys.\n          (xs, ys) \\<in> R u \\<longrightarrow>\n          next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n          ref_dom_events P D u xs = ref_dom_events P D u ys", "by (simp add: weakly_future_consistent_def)"], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> R u \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n        ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "hence \"\\<forall>xs ys. (xs, ys) \\<in> R u \\<longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> R u \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n        ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. \\<forall>xs ys.\n       (xs, ys) \\<in> R u \\<longrightarrow>\n       next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n       ref_dom_events P D u xs = ref_dom_events P D u ys", "using B"], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> R u \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n        ref_dom_events P D u xs = ref_dom_events P D u ys\n  u \\<in> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. \\<forall>xs ys.\n       (xs, ys) \\<in> R u \\<longrightarrow>\n       next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n       ref_dom_events P D u xs = ref_dom_events P D u ys", ".."], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     (xs, ys) \\<in> R u \\<longrightarrow>\n     next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n     ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "hence \"(xs, ys) \\<in> R u \\<longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys\""], ["proof (prove)\nusing this:\n  \\<forall>xs ys.\n     (xs, ys) \\<in> R u \\<longrightarrow>\n     next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n     ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. (xs, ys) \\<in> R u \\<longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys", "by blast"], ["proof (state)\nthis:\n  (xs, ys) \\<in> R u \\<longrightarrow>\n  next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n  ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "hence \"next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys\""], ["proof (prove)\nusing this:\n  (xs, ys) \\<in> R u \\<longrightarrow>\n  next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n  ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys", "using C"], ["proof (prove)\nusing this:\n  (xs, ys) \\<in> R u \\<longrightarrow>\n  next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n  ref_dom_events P D u xs = ref_dom_events P D u ys\n  (xs, ys) \\<in> R u\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys", ".."], ["proof (state)\nthis:\n  next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n  ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "hence \"next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {} =\n    (next_dom_events P D u ys \\<union> ref_dom_events P D u ys \\<noteq> {})\""], ["proof (prove)\nusing this:\n  next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n  ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq>\n     {}) =\n    (next_dom_events P D u ys \\<union> ref_dom_events P D u ys \\<noteq> {})", "by simp"], ["proof (state)\nthis:\n  (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}) =\n  (next_dom_events P D u ys \\<union> ref_dom_events P D u ys \\<noteq> {})\n\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "moreover"], ["proof (state)\nthis:\n  (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}) =\n  (next_dom_events P D u ys \\<union> ref_dom_events P D u ys \\<noteq> {})\n\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "have B': \"u \\<in> range D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> range D", "using B"], ["proof (prove)\nusing this:\n  u \\<in> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. u \\<in> range D", ".."], ["proof (state)\nthis:\n  u \\<in> range D\n\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "hence \"xs \\<in> traces P =\n    (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {})\""], ["proof (prove)\nusing this:\n  u \\<in> range D\n\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) =\n    (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {})", "by (rule traces_dom_events)"], ["proof (state)\nthis:\n  (xs \\<in> traces P) =\n  (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {})\n\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "moreover"], ["proof (state)\nthis:\n  (xs \\<in> traces P) =\n  (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {})\n\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "have \"ys \\<in> traces P =\n    (next_dom_events P D u ys \\<union> ref_dom_events P D u ys \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ys \\<in> traces P) =\n    (next_dom_events P D u ys \\<union> ref_dom_events P D u ys \\<noteq> {})", "using B'"], ["proof (prove)\nusing this:\n  u \\<in> range D\n\ngoal (1 subgoal):\n 1. (ys \\<in> traces P) =\n    (next_dom_events P D u ys \\<union> ref_dom_events P D u ys \\<noteq> {})", "by (rule traces_dom_events)"], ["proof (state)\nthis:\n  (ys \\<in> traces P) =\n  (next_dom_events P D u ys \\<union> ref_dom_events P D u ys \\<noteq> {})\n\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "ultimately"], ["proof (chain)\npicking this:\n  (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}) =\n  (next_dom_events P D u ys \\<union> ref_dom_events P D u ys \\<noteq> {})\n  (xs \\<in> traces P) =\n  (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {})\n  (ys \\<in> traces P) =\n  (next_dom_events P D u ys \\<union> ref_dom_events P D u ys \\<noteq> {})", "show ?thesis"], ["proof (prove)\nusing this:\n  (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {}) =\n  (next_dom_events P D u ys \\<union> ref_dom_events P D u ys \\<noteq> {})\n  (xs \\<in> traces P) =\n  (next_dom_events P D u xs \\<union> ref_dom_events P D u xs \\<noteq> {})\n  (ys \\<in> traces P) =\n  (next_dom_events P D u ys \\<union> ref_dom_events P D u ys \\<noteq> {})\n\ngoal (1 subgoal):\n 1. (xs \\<in> traces P) = (ys \\<in> traces P)", "by simp"], ["proof (state)\nthis:\n  (xs \\<in> traces P) = (ys \\<in> traces P)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fc_implies_wfc:\n \"future_consistent P D R \\<Longrightarrow> weakly_future_consistent P I D R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. future_consistent P D R \\<Longrightarrow>\n    weakly_future_consistent P I D R", "by (simp only: future_consistent_def weakly_future_consistent_def, blast)"], ["", "text \\<open>\n\\null\n\nFinally, the definition is given of an auxiliary function \\<open>singleton_set\\<close>, whose output is the\nset of the singleton subsets of a set taken as input, and then some basic properties of this\nfunction are proven.\n\n\\null\n\\<close>"], ["", "definition singleton_set :: \"'a set \\<Rightarrow> 'a set set\" where\n\"singleton_set X \\<equiv> {Y. \\<exists>x \\<in> X. Y = {x}}\""], ["", "lemma singleton_set_some:\n \"(\\<exists>Y. Y \\<in> singleton_set X) = (\\<exists>x. x \\<in> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>Y. Y \\<in> singleton_set X) = (\\<exists>x. x \\<in> X)", "proof (rule iffI, simp_all add: singleton_set_def, erule_tac [!] exE, erule bexE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Y x.\n       \\<lbrakk>x \\<in> X; Y = {x}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x. x \\<in> X\n 2. \\<And>x.\n       x \\<in> X \\<Longrightarrow> \\<exists>Y. \\<exists>x\\<in>X. Y = {x}", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Y x.\n       \\<lbrakk>x \\<in> X; Y = {x}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x. x \\<in> X\n 2. \\<And>x.\n       x \\<in> X \\<Longrightarrow> \\<exists>Y. \\<exists>x\\<in>X. Y = {x}", "assume \"x \\<in> X\""], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (2 subgoals):\n 1. \\<And>Y x.\n       \\<lbrakk>x \\<in> X; Y = {x}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x. x \\<in> X\n 2. \\<And>x.\n       x \\<in> X \\<Longrightarrow> \\<exists>Y. \\<exists>x\\<in>X. Y = {x}", "thus \"\\<exists>x. x \\<in> X\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> X", ".."], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow> \\<exists>Y. \\<exists>x\\<in>X. Y = {x}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow> \\<exists>Y. \\<exists>x\\<in>X. Y = {x}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow> \\<exists>Y. \\<exists>x\\<in>X. Y = {x}", "assume A: \"x \\<in> X\""], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow> \\<exists>Y. \\<exists>x\\<in>X. Y = {x}", "have \"{x} = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x} = {x}", ".."], ["proof (state)\nthis:\n  {x} = {x}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow> \\<exists>Y. \\<exists>x\\<in>X. Y = {x}", "hence \"\\<exists>x' \\<in> X. {x} = {x'}\""], ["proof (prove)\nusing this:\n  {x} = {x}\n\ngoal (1 subgoal):\n 1. \\<exists>x'\\<in>X. {x} = {x'}", "using A"], ["proof (prove)\nusing this:\n  {x} = {x}\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<exists>x'\\<in>X. {x} = {x'}", ".."], ["proof (state)\nthis:\n  \\<exists>x'\\<in>X. {x} = {x'}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow> \\<exists>Y. \\<exists>x\\<in>X. Y = {x}", "thus \"\\<exists>Y. \\<exists>x' \\<in> X. Y = {x'}\""], ["proof (prove)\nusing this:\n  \\<exists>x'\\<in>X. {x} = {x'}\n\ngoal (1 subgoal):\n 1. \\<exists>Y. \\<exists>x'\\<in>X. Y = {x'}", "by (rule exI)"], ["proof (state)\nthis:\n  \\<exists>Y. \\<exists>x'\\<in>X. Y = {x'}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma singleton_set_union:\n \"(\\<Union>Y \\<in> singleton_set X. Y) = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>Y\\<in>singleton_set X. Y) = X", "proof (subst singleton_set_def, rule equalityI, rule_tac [!] subsetI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<Union>Y\\<in>{Y. \\<exists>x\\<in>X. Y = {x}}.\n                   Y) \\<Longrightarrow>\n       x \\<in> X\n 2. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       x \\<in> (\\<Union>Y\\<in>{Y. \\<exists>x\\<in>X. Y = {x}}. Y)", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<Union>Y\\<in>{Y. \\<exists>x\\<in>X. Y = {x}}.\n                   Y) \\<Longrightarrow>\n       x \\<in> X\n 2. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       x \\<in> (\\<Union>Y\\<in>{Y. \\<exists>x\\<in>X. Y = {x}}. Y)", "assume A: \"x \\<in> (\\<Union>Y \\<in> {Y'. \\<exists>x' \\<in> X. Y' = {x'}}. Y)\""], ["proof (state)\nthis:\n  x \\<in> (\\<Union>Y\\<in>{Y'. \\<exists>x'\\<in>X. Y' = {x'}}. Y)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> (\\<Union>Y\\<in>{Y. \\<exists>x\\<in>X. Y = {x}}.\n                   Y) \\<Longrightarrow>\n       x \\<in> X\n 2. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       x \\<in> (\\<Union>Y\\<in>{Y. \\<exists>x\\<in>X. Y = {x}}. Y)", "show \"x \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> X", "proof (rule UN_E [OF A], simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<exists>x'\\<in>X. xa = {x'}; x \\<in> xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> X", "qed (erule bexE, simp)"], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       x \\<in> (\\<Union>Y\\<in>{Y. \\<exists>x\\<in>X. Y = {x}}. Y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       x \\<in> (\\<Union>Y\\<in>{Y. \\<exists>x\\<in>X. Y = {x}}. Y)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       x \\<in> (\\<Union>Y\\<in>{Y. \\<exists>x\\<in>X. Y = {x}}. Y)", "assume A: \"x \\<in> X\""], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       x \\<in> (\\<Union>Y\\<in>{Y. \\<exists>x\\<in>X. Y = {x}}. Y)", "show \"x \\<in> (\\<Union>Y \\<in> {Y'. \\<exists>x' \\<in> X. Y' = {x'}}. Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>Y\\<in>{Y'. \\<exists>x'\\<in>X. Y' = {x'}}. Y)", "proof (rule UN_I [of \"{x}\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. {x} \\<in> {Y'. \\<exists>x'\\<in>X. Y' = {x'}}\n 2. x \\<in> {x}", "qed (simp_all add: A)"], ["proof (state)\nthis:\n  x \\<in> (\\<Union>Y\\<in>{Y'. \\<exists>x'\\<in>X. Y' = {x'}}. Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Additional intransitive purge functions and their properties\""], ["", "text \\<open>\nFunctions \\<open>sinks_aux\\<close>, \\<open>ipurge_tr_aux\\<close>, and \\<open>ipurge_ref_aux\\<close>, defined here below,\nare auxiliary versions of functions @{term sinks}, @{term ipurge_tr}, and @{term ipurge_ref} taking\nas input a set of domains rather than a single domain. As shown below, these functions are useful\nfor the study of single domain ones, involved in the definition of CSP noninterference security\n\\cite{R1}, since they distribute over list concatenation, while being susceptible to be expressed in\nterms of the corresponding single domain functions in case the input set of domains is a singleton.\n\nA further function, \\<open>unaffected_domains\\<close>, takes as inputs a set of domains \\<open>U\\<close> and an\nevent list \\<open>xs\\<close>, and outputs the set of the event domains not allowed to be affected by\n\\<open>U\\<close> after the occurrence of \\<open>xs\\<close>.\n\n\\null\n\\<close>"], ["", "function sinks_aux ::\n \"('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> 'd set \\<Rightarrow> 'a list \\<Rightarrow> 'd set\" where\n\"sinks_aux _ _ U [] = U\" |\n\"sinks_aux I D U (xs @ [x]) = (if \\<exists>v \\<in> sinks_aux I D U xs. (v, D x) \\<in> I\n  then insert (D x) (sinks_aux I D U xs)\n  else sinks_aux I D U xs)\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>uu_ uv_ U. x = (uu_, uv_, U, []) \\<Longrightarrow> P;\n        \\<And>I D U xs xa.\n           x = (I, D, U, xs @ [xa]) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>uu_ uv_ U uua_ uva_ Ua.\n       (uu_, uv_, U, []) = (uua_, uva_, Ua, []) \\<Longrightarrow> U = Ua\n 3. \\<And>uu_ uv_ U I D Ua xs x.\n       (uu_, uv_, U, []) = (I, D, Ua, xs @ [x]) \\<Longrightarrow>\n       U =\n       (if \\<exists>v\\<in>sinks_aux_sumC (I, D, Ua, xs). (v, D x) \\<in> I\n        then insert (D x) (sinks_aux_sumC (I, D, Ua, xs))\n        else sinks_aux_sumC (I, D, Ua, xs))\n 4. \\<And>I D U xs x Ia Da Ua xsa xa.\n       (I, D, U, xs @ [x]) = (Ia, Da, Ua, xsa @ [xa]) \\<Longrightarrow>\n       (if \\<exists>v\\<in>sinks_aux_sumC (I, D, U, xs). (v, D x) \\<in> I\n        then insert (D x) (sinks_aux_sumC (I, D, U, xs))\n        else sinks_aux_sumC (I, D, U, xs)) =\n       (if \\<exists>v\\<in>sinks_aux_sumC (Ia, Da, Ua, xsa).\n              (v, Da xa) \\<in> Ia\n        then insert (Da xa) (sinks_aux_sumC (Ia, Da, Ua, xsa))\n        else sinks_aux_sumC (Ia, Da, Ua, xsa))", "proof (atomize_elim, simp_all add: split_paired_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b. b = [] \\<or> (\\<exists>xs x. b = xs @ [x])", "qed (rule rev_cases, rule disjI1, assumption, simp)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All sinks_aux_dom", "by lexicographic_order"], ["", "function ipurge_tr_aux ::\n \"('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> 'd set \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n\"ipurge_tr_aux _ _ _ [] = []\" |\n\"ipurge_tr_aux I D U (xs @ [x]) = (if \\<exists>v \\<in> sinks_aux I D U xs. (v, D x) \\<in> I\n  then ipurge_tr_aux I D U xs\n  else ipurge_tr_aux I D U xs @ [x])\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>uu_ uv_ uw_.\n                   x = (uu_, uv_, uw_, []) \\<Longrightarrow> P;\n        \\<And>I D U xs xa.\n           x = (I, D, U, xs @ [xa]) \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>uu_ uv_ uw_ uua_ uva_ uwa_.\n       (uu_, uv_, uw_, []) = (uua_, uva_, uwa_, []) \\<Longrightarrow>\n       [] = []\n 3. \\<And>uu_ uv_ uw_ I D U xs x.\n       (uu_, uv_, uw_, []) = (I, D, U, xs @ [x]) \\<Longrightarrow>\n       [] =\n       (if \\<exists>v\\<in>sinks_aux I D U xs. (v, D x) \\<in> I\n        then ipurge_tr_aux_sumC (I, D, U, xs)\n        else ipurge_tr_aux_sumC (I, D, U, xs) @ [x])\n 4. \\<And>I D U xs x Ia Da Ua xsa xa.\n       (I, D, U, xs @ [x]) = (Ia, Da, Ua, xsa @ [xa]) \\<Longrightarrow>\n       (if \\<exists>v\\<in>sinks_aux I D U xs. (v, D x) \\<in> I\n        then ipurge_tr_aux_sumC (I, D, U, xs)\n        else ipurge_tr_aux_sumC (I, D, U, xs) @ [x]) =\n       (if \\<exists>v\\<in>sinks_aux Ia Da Ua xsa. (v, Da xa) \\<in> Ia\n        then ipurge_tr_aux_sumC (Ia, Da, Ua, xsa)\n        else ipurge_tr_aux_sumC (Ia, Da, Ua, xsa) @ [xa])", "proof (atomize_elim, simp_all add: split_paired_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b. b = [] \\<or> (\\<exists>xs x. b = xs @ [x])", "qed (rule rev_cases, rule disjI1, assumption, simp)"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All ipurge_tr_aux_dom", "by lexicographic_order"], ["", "definition ipurge_ref_aux ::\n \"('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> 'd set \\<Rightarrow> 'a list \\<Rightarrow> 'a set \\<Rightarrow> 'a set\" where\n\"ipurge_ref_aux I D U xs X \\<equiv>\n  {x \\<in> X. \\<forall>v \\<in> sinks_aux I D U xs. (v, D x) \\<notin> I}\""], ["", "definition unaffected_domains ::\n \"('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> 'd set \\<Rightarrow> 'a list \\<Rightarrow> 'd set\" where\n\"unaffected_domains I D U xs \\<equiv>\n  {u \\<in> range D. \\<forall>v \\<in> sinks_aux I D U xs. (v, u) \\<notin> I}\""], ["", "text \\<open>\n\\null\n\nFunction \\<open>ipurge_tr_rev\\<close>, defined here below in terms of function \\<open>sources\\<close>, is the\nreverse of function @{term ipurge_tr} with regard to both the order in which events are considered,\nand the criterion by which they are purged.\n\nIn some detail, both functions \\<open>sources\\<close> and \\<open>ipurge_tr_rev\\<close> take as inputs a domain\n\\<open>u\\<close> and an event list \\<open>xs\\<close>, whose recursive decomposition is performed by item\nprepending rather than appending. Then:\n\n\\begin{itemize}\n\n\\item\n\\<open>sources\\<close> outputs the set of the domains of the events in \\<open>xs\\<close> allowed to affect\n\\<open>u\\<close>;\n\n\\item\n\\<open>ipurge_tr_rev\\<close> outputs the sublist of \\<open>xs\\<close> obtained by recursively deleting the events\nnot allowed to affect \\<open>u\\<close>, as detected via function \\<open>sources\\<close>.\n\n\\end{itemize}\n\nIn other words, these functions follow Rushby's ones \\emph{sources} and \\emph{ipurge} \\cite{R4},\nformalized in \\cite{R1} as \\<open>c_sources\\<close> and \\<open>c_ipurge\\<close>. The only difference consists of\ndropping the implicit supposition that the noninterference policy be reflexive, as done in the\ndefinition of CPS noninterference security \\cite{R1}. This goal is achieved by defining the output\nof function \\<open>sources\\<close>, when it is applied to the empty list, as being the empty set rather\nthan the singleton comprised of the input domain.\n\nAs for functions \\<open>sources_aux\\<close> and \\<open>ipurge_tr_rev_aux\\<close>, they are auxiliary versions of\nfunctions \\<open>sources\\<close> and \\<open>ipurge_tr_rev\\<close> taking as input a set of domains rather than a\nsingle domain. As shown below, these functions distribute over list concatenation, while being\nsusceptible to be expressed in terms of the corresponding single domain functions in case the input\nset of domains is a singleton.\n\n\\null\n\\<close>"], ["", "primrec sources :: \"('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> 'd \\<Rightarrow> 'a list \\<Rightarrow> 'd set\" where\n\"sources _ _ _ [] = {}\" |\n\"sources I D u (x # xs) =\n  (if (D x, u) \\<in> I \\<or> (\\<exists>v \\<in> sources I D u xs. (D x, v) \\<in> I)\n  then insert (D x) (sources I D u xs)\n  else sources I D u xs)\""], ["", "primrec ipurge_tr_rev :: \"('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> 'd \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n\"ipurge_tr_rev _ _ _ [] = []\" |\n\"ipurge_tr_rev I D u (x # xs) = (if D x \\<in> sources I D u (x # xs)\n  then x # ipurge_tr_rev I D u xs\n  else ipurge_tr_rev I D u xs)\""], ["", "primrec sources_aux ::\n \"('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> 'd set \\<Rightarrow> 'a list \\<Rightarrow> 'd set\" where\n\"sources_aux _ _ U [] = U\" |\n\"sources_aux I D U (x # xs) = (if \\<exists>v \\<in> sources_aux I D U xs. (D x, v) \\<in> I\n  then insert (D x) (sources_aux I D U xs)\n  else sources_aux I D U xs)\""], ["", "primrec ipurge_tr_rev_aux ::\n \"('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> 'd set \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n\"ipurge_tr_rev_aux _ _ _ [] = []\" |\n\"ipurge_tr_rev_aux I D U (x # xs) = (if \\<exists>v \\<in> sources_aux I D U xs. (D x, v) \\<in> I\n  then x # ipurge_tr_rev_aux I D U xs\n  else ipurge_tr_rev_aux I D U xs)\""], ["", "text \\<open>\n\\null\n\nHere below are some lemmas on functions @{term sinks_aux}, @{term ipurge_tr_aux},\n@{term ipurge_ref_aux}, and @{term unaffected_domains}. As anticipated above, these lemmas\nessentially concern distributivity over list concatenation and expressions in terms of single domain\nfunctions in the degenerate case of a singleton set of domains.\n\n\\null\n\\<close>"], ["", "lemma sinks_aux_subset:\n \"U \\<subseteq> sinks_aux I D U xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> sinks_aux I D U xs", "proof (induction xs rule: rev_induct, simp_all, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>U \\<subseteq> sinks_aux I D U xs;\n        \\<exists>v\\<in>sinks_aux I D U xs. (v, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> U \\<subseteq> insert (D x) (sinks_aux I D U xs)", "qed (rule subset_insertI2)"], ["", "lemma sinks_aux_single_dom:\n \"sinks_aux I D {u} xs = insert u (sinks I D u xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D {u} xs = insert u (sinks I D u xs)", "by (induction xs rule: rev_induct, simp_all add: insert_commute)"], ["", "lemma sinks_aux_single_event:\n \"sinks_aux I D U [x] = (if \\<exists>v \\<in> U. (v, D x) \\<in> I\n   then insert (D x) U\n   else U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D U [x] =\n    (if \\<exists>v\\<in>U. (v, D x) \\<in> I then insert (D x) U else U)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sinks_aux I D U [x] =\n    (if \\<exists>v\\<in>U. (v, D x) \\<in> I then insert (D x) U else U)", "have \"sinks_aux I D U [x] = sinks_aux I D U ([] @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D U [x] = sinks_aux I D U ([] @ [x])", "by simp"], ["proof (state)\nthis:\n  sinks_aux I D U [x] = sinks_aux I D U ([] @ [x])\n\ngoal (1 subgoal):\n 1. sinks_aux I D U [x] =\n    (if \\<exists>v\\<in>U. (v, D x) \\<in> I then insert (D x) U else U)", "thus ?thesis"], ["proof (prove)\nusing this:\n  sinks_aux I D U [x] = sinks_aux I D U ([] @ [x])\n\ngoal (1 subgoal):\n 1. sinks_aux I D U [x] =\n    (if \\<exists>v\\<in>U. (v, D x) \\<in> I then insert (D x) U else U)", "by (simp only: sinks_aux.simps)"], ["proof (state)\nthis:\n  sinks_aux I D U [x] =\n  (if \\<exists>v\\<in>U. (v, D x) \\<in> I then insert (D x) U else U)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sinks_aux_cons:\n \"sinks_aux I D U (x # xs) = (if \\<exists>v \\<in> U. (v, D x) \\<in> I\n   then sinks_aux I D (insert (D x) U) xs\n   else sinks_aux I D U xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D U (x # xs) =\n    (if \\<exists>v\\<in>U. (v, D x) \\<in> I\n     then sinks_aux I D (insert (D x) U) xs else sinks_aux I D U xs)", "proof (induction xs rule: rev_induct, case_tac [!] \"\\<exists>v \\<in> U. (v, D x) \\<in> I\",\n simp_all add: sinks_aux_single_event del: sinks_aux.simps(2))"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa xs.\n       \\<lbrakk>sinks_aux I D U (x # xs) =\n                sinks_aux I D (insert (D x) U) xs;\n        \\<exists>v\\<in>U. (v, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> sinks_aux I D U (x # xs @ [xa]) =\n                         sinks_aux I D (insert (D x) U) (xs @ [xa])\n 2. \\<And>xa xs.\n       \\<lbrakk>sinks_aux I D U (x # xs) = sinks_aux I D U xs;\n        \\<forall>v\\<in>U. (v, D x) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> sinks_aux I D U (x # xs @ [xa]) =\n                         sinks_aux I D U (xs @ [xa])", "fix x' xs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa xs.\n       \\<lbrakk>sinks_aux I D U (x # xs) =\n                sinks_aux I D (insert (D x) U) xs;\n        \\<exists>v\\<in>U. (v, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> sinks_aux I D U (x # xs @ [xa]) =\n                         sinks_aux I D (insert (D x) U) (xs @ [xa])\n 2. \\<And>xa xs.\n       \\<lbrakk>sinks_aux I D U (x # xs) = sinks_aux I D U xs;\n        \\<forall>v\\<in>U. (v, D x) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> sinks_aux I D U (x # xs @ [xa]) =\n                         sinks_aux I D U (xs @ [xa])", "assume A: \"sinks_aux I D U (x # xs) = sinks_aux I D (insert (D x) U) xs\"\n    (is \"?S = ?S'\")"], ["proof (state)\nthis:\n  sinks_aux I D U (x # xs) = sinks_aux I D (insert (D x) U) xs\n\ngoal (2 subgoals):\n 1. \\<And>xa xs.\n       \\<lbrakk>sinks_aux I D U (x # xs) =\n                sinks_aux I D (insert (D x) U) xs;\n        \\<exists>v\\<in>U. (v, D x) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> sinks_aux I D U (x # xs @ [xa]) =\n                         sinks_aux I D (insert (D x) U) (xs @ [xa])\n 2. \\<And>xa xs.\n       \\<lbrakk>sinks_aux I D U (x # xs) = sinks_aux I D U xs;\n        \\<forall>v\\<in>U. (v, D x) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> sinks_aux I D U (x # xs @ [xa]) =\n                         sinks_aux I D U (xs @ [xa])", "show \"sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])", "proof (cases \"\\<exists>v \\<in> ?S. (v, D x') \\<in> I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D U (x # xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])", "case True"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks_aux I D U (x # xs). (v, D x') \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D U (x # xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])", "hence \"sinks_aux I D U ((x # xs) @ [x']) = insert (D x') ?S\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks_aux I D U (x # xs). (v, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. sinks_aux I D U ((x # xs) @ [x']) =\n    insert (D x') (sinks_aux I D U (x # xs))", "by (simp only: sinks_aux.simps, simp)"], ["proof (state)\nthis:\n  sinks_aux I D U ((x # xs) @ [x']) =\n  insert (D x') (sinks_aux I D U (x # xs))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D U (x # xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])", "moreover"], ["proof (state)\nthis:\n  sinks_aux I D U ((x # xs) @ [x']) =\n  insert (D x') (sinks_aux I D U (x # xs))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D U (x # xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])", "have \"\\<exists>v \\<in> ?S'. (v, D x') \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks_aux I D (insert (D x) U) xs. (v, D x') \\<in> I", "using A and True"], ["proof (prove)\nusing this:\n  sinks_aux I D U (x # xs) = sinks_aux I D (insert (D x) U) xs\n  \\<exists>v\\<in>sinks_aux I D U (x # xs). (v, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks_aux I D (insert (D x) U) xs. (v, D x') \\<in> I", "by simp"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks_aux I D (insert (D x) U) xs. (v, D x') \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D U (x # xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])", "hence \"sinks_aux I D (insert (D x) U) (xs @ [x']) = insert (D x') ?S'\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks_aux I D (insert (D x) U) xs. (v, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. sinks_aux I D (insert (D x) U) (xs @ [x']) =\n    insert (D x') (sinks_aux I D (insert (D x) U) xs)", "by simp"], ["proof (state)\nthis:\n  sinks_aux I D (insert (D x) U) (xs @ [x']) =\n  insert (D x') (sinks_aux I D (insert (D x) U) xs)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D U (x # xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])", "ultimately"], ["proof (chain)\npicking this:\n  sinks_aux I D U ((x # xs) @ [x']) =\n  insert (D x') (sinks_aux I D U (x # xs))\n  sinks_aux I D (insert (D x) U) (xs @ [x']) =\n  insert (D x') (sinks_aux I D (insert (D x) U) xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  sinks_aux I D U ((x # xs) @ [x']) =\n  insert (D x') (sinks_aux I D U (x # xs))\n  sinks_aux I D (insert (D x) U) (xs @ [x']) =\n  insert (D x') (sinks_aux I D (insert (D x) U) xs)\n\ngoal (1 subgoal):\n 1. sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])", "using A"], ["proof (prove)\nusing this:\n  sinks_aux I D U ((x # xs) @ [x']) =\n  insert (D x') (sinks_aux I D U (x # xs))\n  sinks_aux I D (insert (D x) U) (xs @ [x']) =\n  insert (D x') (sinks_aux I D (insert (D x) U) xs)\n  sinks_aux I D U (x # xs) = sinks_aux I D (insert (D x) U) xs\n\ngoal (1 subgoal):\n 1. sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])", "by simp"], ["proof (state)\nthis:\n  sinks_aux I D U (x # xs @ [x']) =\n  sinks_aux I D (insert (D x) U) (xs @ [x'])\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs). (v, D x') \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])", "hence \"sinks_aux I D U ((x # xs) @ [x']) = ?S\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs). (v, D x') \\<in> I)\n\ngoal (1 subgoal):\n 1. sinks_aux I D U ((x # xs) @ [x']) = sinks_aux I D U (x # xs)", "by (simp only: sinks_aux.simps, simp)"], ["proof (state)\nthis:\n  sinks_aux I D U ((x # xs) @ [x']) = sinks_aux I D U (x # xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])", "moreover"], ["proof (state)\nthis:\n  sinks_aux I D U ((x # xs) @ [x']) = sinks_aux I D U (x # xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])", "have \"\\<not> (\\<exists>v \\<in> ?S'. (v, D x') \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (insert (D x) U) xs.\n               (v, D x') \\<in> I)", "using A and False"], ["proof (prove)\nusing this:\n  sinks_aux I D U (x # xs) = sinks_aux I D (insert (D x) U) xs\n  \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs). (v, D x') \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (insert (D x) U) xs.\n               (v, D x') \\<in> I)", "by simp"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (insert (D x) U) xs.\n             (v, D x') \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])", "hence \"sinks_aux I D (insert (D x) U) (xs @ [x']) = ?S'\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (insert (D x) U) xs.\n             (v, D x') \\<in> I)\n\ngoal (1 subgoal):\n 1. sinks_aux I D (insert (D x) U) (xs @ [x']) =\n    sinks_aux I D (insert (D x) U) xs", "by simp"], ["proof (state)\nthis:\n  sinks_aux I D (insert (D x) U) (xs @ [x']) =\n  sinks_aux I D (insert (D x) U) xs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])", "ultimately"], ["proof (chain)\npicking this:\n  sinks_aux I D U ((x # xs) @ [x']) = sinks_aux I D U (x # xs)\n  sinks_aux I D (insert (D x) U) (xs @ [x']) =\n  sinks_aux I D (insert (D x) U) xs", "show ?thesis"], ["proof (prove)\nusing this:\n  sinks_aux I D U ((x # xs) @ [x']) = sinks_aux I D U (x # xs)\n  sinks_aux I D (insert (D x) U) (xs @ [x']) =\n  sinks_aux I D (insert (D x) U) xs\n\ngoal (1 subgoal):\n 1. sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])", "using A"], ["proof (prove)\nusing this:\n  sinks_aux I D U ((x # xs) @ [x']) = sinks_aux I D U (x # xs)\n  sinks_aux I D (insert (D x) U) (xs @ [x']) =\n  sinks_aux I D (insert (D x) U) xs\n  sinks_aux I D U (x # xs) = sinks_aux I D (insert (D x) U) xs\n\ngoal (1 subgoal):\n 1. sinks_aux I D U (x # xs @ [x']) =\n    sinks_aux I D (insert (D x) U) (xs @ [x'])", "by simp"], ["proof (state)\nthis:\n  sinks_aux I D U (x # xs @ [x']) =\n  sinks_aux I D (insert (D x) U) (xs @ [x'])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sinks_aux I D U (x # xs @ [x']) =\n  sinks_aux I D (insert (D x) U) (xs @ [x'])\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>sinks_aux I D U (x # xs) = sinks_aux I D U xs;\n        \\<forall>v\\<in>U. (v, D x) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> sinks_aux I D U (x # xs @ [xa]) =\n                         sinks_aux I D U (xs @ [xa])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>sinks_aux I D U (x # xs) = sinks_aux I D U xs;\n        \\<forall>v\\<in>U. (v, D x) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> sinks_aux I D U (x # xs @ [xa]) =\n                         sinks_aux I D U (xs @ [xa])", "fix x' xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>sinks_aux I D U (x # xs) = sinks_aux I D U xs;\n        \\<forall>v\\<in>U. (v, D x) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> sinks_aux I D U (x # xs @ [xa]) =\n                         sinks_aux I D U (xs @ [xa])", "assume A: \"sinks_aux I D U (x # xs) = sinks_aux I D U xs\"\n    (is \"?S = ?S'\")"], ["proof (state)\nthis:\n  sinks_aux I D U (x # xs) = sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>sinks_aux I D U (x # xs) = sinks_aux I D U xs;\n        \\<forall>v\\<in>U. (v, D x) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> sinks_aux I D U (x # xs @ [xa]) =\n                         sinks_aux I D U (xs @ [xa])", "show \"sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])", "proof (cases \"\\<exists>v \\<in> ?S. (v, D x') \\<in> I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D U (x # xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])", "case True"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks_aux I D U (x # xs). (v, D x') \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D U (x # xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])", "hence \"sinks_aux I D U ((x # xs) @ [x']) = insert (D x') ?S\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks_aux I D U (x # xs). (v, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. sinks_aux I D U ((x # xs) @ [x']) =\n    insert (D x') (sinks_aux I D U (x # xs))", "by (simp only: sinks_aux.simps, simp)"], ["proof (state)\nthis:\n  sinks_aux I D U ((x # xs) @ [x']) =\n  insert (D x') (sinks_aux I D U (x # xs))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D U (x # xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])", "moreover"], ["proof (state)\nthis:\n  sinks_aux I D U ((x # xs) @ [x']) =\n  insert (D x') (sinks_aux I D U (x # xs))\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D U (x # xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])", "have \"\\<exists>v \\<in> ?S'. (v, D x') \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks_aux I D U xs. (v, D x') \\<in> I", "using A and True"], ["proof (prove)\nusing this:\n  sinks_aux I D U (x # xs) = sinks_aux I D U xs\n  \\<exists>v\\<in>sinks_aux I D U (x # xs). (v, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks_aux I D U xs. (v, D x') \\<in> I", "by simp"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks_aux I D U xs. (v, D x') \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D U (x # xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])", "hence \"sinks_aux I D U (xs @ [x']) = insert (D x') ?S'\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks_aux I D U xs. (v, D x') \\<in> I\n\ngoal (1 subgoal):\n 1. sinks_aux I D U (xs @ [x']) = insert (D x') (sinks_aux I D U xs)", "by simp"], ["proof (state)\nthis:\n  sinks_aux I D U (xs @ [x']) = insert (D x') (sinks_aux I D U xs)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D U (x # xs).\n       (v, D x') \\<in> I \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])", "ultimately"], ["proof (chain)\npicking this:\n  sinks_aux I D U ((x # xs) @ [x']) =\n  insert (D x') (sinks_aux I D U (x # xs))\n  sinks_aux I D U (xs @ [x']) = insert (D x') (sinks_aux I D U xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  sinks_aux I D U ((x # xs) @ [x']) =\n  insert (D x') (sinks_aux I D U (x # xs))\n  sinks_aux I D U (xs @ [x']) = insert (D x') (sinks_aux I D U xs)\n\ngoal (1 subgoal):\n 1. sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])", "using A"], ["proof (prove)\nusing this:\n  sinks_aux I D U ((x # xs) @ [x']) =\n  insert (D x') (sinks_aux I D U (x # xs))\n  sinks_aux I D U (xs @ [x']) = insert (D x') (sinks_aux I D U xs)\n  sinks_aux I D U (x # xs) = sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])", "by simp"], ["proof (state)\nthis:\n  sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs). (v, D x') \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])", "hence \"sinks_aux I D U ((x # xs) @ [x']) = ?S\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs). (v, D x') \\<in> I)\n\ngoal (1 subgoal):\n 1. sinks_aux I D U ((x # xs) @ [x']) = sinks_aux I D U (x # xs)", "by (simp only: sinks_aux.simps, simp)"], ["proof (state)\nthis:\n  sinks_aux I D U ((x # xs) @ [x']) = sinks_aux I D U (x # xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])", "moreover"], ["proof (state)\nthis:\n  sinks_aux I D U ((x # xs) @ [x']) = sinks_aux I D U (x # xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])", "have \"\\<not> (\\<exists>v \\<in> ?S'. (v, D x') \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D U xs. (v, D x') \\<in> I)", "using A and False"], ["proof (prove)\nusing this:\n  sinks_aux I D U (x # xs) = sinks_aux I D U xs\n  \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs). (v, D x') \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D U xs. (v, D x') \\<in> I)", "by simp"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D U xs. (v, D x') \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])", "hence \"sinks_aux I D U (xs @ [x']) = ?S'\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D U xs. (v, D x') \\<in> I)\n\ngoal (1 subgoal):\n 1. sinks_aux I D U (xs @ [x']) = sinks_aux I D U xs", "by simp"], ["proof (state)\nthis:\n  sinks_aux I D U (xs @ [x']) = sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D U (x # xs).\n               (v, D x') \\<in> I) \\<Longrightarrow>\n    sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])", "ultimately"], ["proof (chain)\npicking this:\n  sinks_aux I D U ((x # xs) @ [x']) = sinks_aux I D U (x # xs)\n  sinks_aux I D U (xs @ [x']) = sinks_aux I D U xs", "show ?thesis"], ["proof (prove)\nusing this:\n  sinks_aux I D U ((x # xs) @ [x']) = sinks_aux I D U (x # xs)\n  sinks_aux I D U (xs @ [x']) = sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])", "using A"], ["proof (prove)\nusing this:\n  sinks_aux I D U ((x # xs) @ [x']) = sinks_aux I D U (x # xs)\n  sinks_aux I D U (xs @ [x']) = sinks_aux I D U xs\n  sinks_aux I D U (x # xs) = sinks_aux I D U xs\n\ngoal (1 subgoal):\n 1. sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])", "by simp"], ["proof (state)\nthis:\n  sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sinks_aux I D U (x # xs @ [x']) = sinks_aux I D U (xs @ [x'])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_tr_aux_single_dom:\n \"ipurge_tr_aux I D {u} xs = ipurge_tr I D u xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D {u} xs = ipurge_tr I D u xs", "proof (induction xs rule: rev_induct, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       ipurge_tr_aux I D {u} xs = ipurge_tr I D u xs \\<Longrightarrow>\n       ipurge_tr_aux I D {u} (xs @ [x]) = ipurge_tr I D u (xs @ [x])", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       ipurge_tr_aux I D {u} xs = ipurge_tr I D u xs \\<Longrightarrow>\n       ipurge_tr_aux I D {u} (xs @ [x]) = ipurge_tr I D u (xs @ [x])", "assume A: \"ipurge_tr_aux I D {u} xs = ipurge_tr I D u xs\""], ["proof (state)\nthis:\n  ipurge_tr_aux I D {u} xs = ipurge_tr I D u xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       ipurge_tr_aux I D {u} xs = ipurge_tr I D u xs \\<Longrightarrow>\n       ipurge_tr_aux I D {u} (xs @ [x]) = ipurge_tr I D u (xs @ [x])", "show \"ipurge_tr_aux I D {u} (xs @ [x]) = ipurge_tr I D u (xs @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D {u} (xs @ [x]) = ipurge_tr I D u (xs @ [x])", "proof (cases \"\\<exists>v \\<in> sinks_aux I D {u} xs. (v, D x) \\<in> I\",\n   simp_all only: ipurge_tr_aux.simps if_True if_False)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D {u} xs. (v, D x) \\<in> I \\<Longrightarrow>\n    ipurge_tr_aux I D {u} xs = ipurge_tr I D u (xs @ [x])\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D {u} xs.\n               (v, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D {u} xs @ [x] = ipurge_tr I D u (xs @ [x])", "case True"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks_aux I D {u} xs. (v, D x) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D {u} xs. (v, D x) \\<in> I \\<Longrightarrow>\n    ipurge_tr_aux I D {u} xs = ipurge_tr I D u (xs @ [x])\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D {u} xs.\n               (v, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D {u} xs @ [x] = ipurge_tr I D u (xs @ [x])", "hence \"(u, D x) \\<in> I \\<or> (\\<exists>v \\<in> sinks I D u xs. (v, D x) \\<in> I)\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks_aux I D {u} xs. (v, D x) \\<in> I\n\ngoal (1 subgoal):\n 1. (u, D x) \\<in> I \\<or> (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I)", "by (simp add: sinks_aux_single_dom)"], ["proof (state)\nthis:\n  (u, D x) \\<in> I \\<or> (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D {u} xs. (v, D x) \\<in> I \\<Longrightarrow>\n    ipurge_tr_aux I D {u} xs = ipurge_tr I D u (xs @ [x])\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D {u} xs.\n               (v, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D {u} xs @ [x] = ipurge_tr I D u (xs @ [x])", "hence \"ipurge_tr I D u (xs @ [x]) = ipurge_tr I D u xs\""], ["proof (prove)\nusing this:\n  (u, D x) \\<in> I \\<or> (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr I D u (xs @ [x]) = ipurge_tr I D u xs", "by simp"], ["proof (state)\nthis:\n  ipurge_tr I D u (xs @ [x]) = ipurge_tr I D u xs\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D {u} xs. (v, D x) \\<in> I \\<Longrightarrow>\n    ipurge_tr_aux I D {u} xs = ipurge_tr I D u (xs @ [x])\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D {u} xs.\n               (v, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D {u} xs @ [x] = ipurge_tr I D u (xs @ [x])", "thus \"ipurge_tr_aux I D {u} xs = ipurge_tr I D u (xs @ [x])\""], ["proof (prove)\nusing this:\n  ipurge_tr I D u (xs @ [x]) = ipurge_tr I D u xs\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D {u} xs = ipurge_tr I D u (xs @ [x])", "using A"], ["proof (prove)\nusing this:\n  ipurge_tr I D u (xs @ [x]) = ipurge_tr I D u xs\n  ipurge_tr_aux I D {u} xs = ipurge_tr I D u xs\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D {u} xs = ipurge_tr I D u (xs @ [x])", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_aux I D {u} xs = ipurge_tr I D u (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D {u} xs.\n               (v, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D {u} xs @ [x] = ipurge_tr I D u (xs @ [x])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D {u} xs.\n               (v, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D {u} xs @ [x] = ipurge_tr I D u (xs @ [x])", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D {u} xs. (v, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D {u} xs.\n               (v, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D {u} xs @ [x] = ipurge_tr I D u (xs @ [x])", "hence \"\\<not> ((u, D x) \\<in> I \\<or> (\\<exists>v \\<in> sinks I D u xs. (v, D x) \\<in> I))\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D {u} xs. (v, D x) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> ((u, D x) \\<in> I \\<or>\n            (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I))", "by (simp add: sinks_aux_single_dom)"], ["proof (state)\nthis:\n  \\<not> ((u, D x) \\<in> I \\<or>\n          (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D {u} xs.\n               (v, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D {u} xs @ [x] = ipurge_tr I D u (xs @ [x])", "hence \"D x \\<notin> sinks I D u (xs @ [x])\""], ["proof (prove)\nusing this:\n  \\<not> ((u, D x) \\<in> I \\<or>\n          (\\<exists>v\\<in>sinks I D u xs. (v, D x) \\<in> I))\n\ngoal (1 subgoal):\n 1. D x \\<notin> sinks I D u (xs @ [x])", "by (simp only: sinks_interference_eq, simp)"], ["proof (state)\nthis:\n  D x \\<notin> sinks I D u (xs @ [x])\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D {u} xs.\n               (v, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D {u} xs @ [x] = ipurge_tr I D u (xs @ [x])", "hence \"ipurge_tr I D u (xs @ [x]) = ipurge_tr I D u xs @ [x]\""], ["proof (prove)\nusing this:\n  D x \\<notin> sinks I D u (xs @ [x])\n\ngoal (1 subgoal):\n 1. ipurge_tr I D u (xs @ [x]) = ipurge_tr I D u xs @ [x]", "by simp"], ["proof (state)\nthis:\n  ipurge_tr I D u (xs @ [x]) = ipurge_tr I D u xs @ [x]\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D {u} xs.\n               (v, D x) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D {u} xs @ [x] = ipurge_tr I D u (xs @ [x])", "thus \"ipurge_tr_aux I D {u} xs @ [x] = ipurge_tr I D u (xs @ [x])\""], ["proof (prove)\nusing this:\n  ipurge_tr I D u (xs @ [x]) = ipurge_tr I D u xs @ [x]\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D {u} xs @ [x] = ipurge_tr I D u (xs @ [x])", "using A"], ["proof (prove)\nusing this:\n  ipurge_tr I D u (xs @ [x]) = ipurge_tr I D u xs @ [x]\n  ipurge_tr_aux I D {u} xs = ipurge_tr I D u xs\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D {u} xs @ [x] = ipurge_tr I D u (xs @ [x])", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_aux I D {u} xs @ [x] = ipurge_tr I D u (xs @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_tr_aux I D {u} (xs @ [x]) = ipurge_tr I D u (xs @ [x])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_ref_aux_single_dom:\n \"ipurge_ref_aux I D {u} xs X = ipurge_ref I D u xs X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref_aux I D {u} xs X = ipurge_ref I D u xs X", "by (simp add: ipurge_ref_aux_def ipurge_ref_def sinks_aux_single_dom)"], ["", "lemma ipurge_ref_aux_all [rule_format]:\n \"(\\<forall>u \\<in> U. \\<not> (\\<exists>v \\<in> D ` (X \\<union> set xs). (u, v) \\<in> I)) \\<longrightarrow>\n  ipurge_ref_aux I D U xs X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>u\\<in>U.\n        \\<not> (\\<exists>v\\<in>D ` (X \\<union> set xs).\n                   (u, v) \\<in> I)) \\<longrightarrow>\n    ipurge_ref_aux I D U xs X = X", "proof (induction xs, simp_all add: ipurge_ref_aux_def sinks_aux_cons)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>u\\<in>U.\n        \\<forall>v\\<in>X. (u, D v) \\<notin> I) \\<longrightarrow>\n    {x \\<in> X. \\<forall>v\\<in>U. (v, D x) \\<notin> I} = X", "qed (rule impI, rule equalityI, rule_tac [!] subsetI, simp_all)"], ["", "lemma ipurge_ref_all:\n \"\\<not> (\\<exists>v \\<in> D ` (X \\<union> set xs). (u, v) \\<in> I) \\<Longrightarrow> ipurge_ref I D u xs X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set xs).\n               (u, v) \\<in> I) \\<Longrightarrow>\n    ipurge_ref I D u xs X = X", "by (subst ipurge_ref_aux_single_dom [symmetric], rule ipurge_ref_aux_all, simp)"], ["", "lemma unaffected_domains_single_dom:\n \"{x \\<in> X. D x \\<in> unaffected_domains I D {u} xs} = ipurge_ref I D u xs X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> X. D x \\<in> unaffected_domains I D {u} xs} =\n    ipurge_ref I D u xs X", "by (simp add: ipurge_ref_def unaffected_domains_def sinks_aux_single_dom)"], ["", "text \\<open>\n\\null\n\nHere below are some lemmas on functions @{term sources}, @{term ipurge_tr_rev}, @{term sources_aux},\nand @{term ipurge_tr_rev_aux}. As anticipated above, the lemmas on the last two functions basically\nconcern distributivity over list concatenation and expressions in terms of single domain functions\nin the degenerate case of a singleton set of domains.\n\n\\null\n\\<close>"], ["", "lemma sources_sinks:\n \"sources I D u xs = sinks (I\\<inverse>) D u (rev xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sources I D u xs = sinks (I\\<inverse>) D u (rev xs)", "by (induction xs, simp_all)"], ["", "lemma sources_sinks_aux:\n \"sources_aux I D U xs = sinks_aux (I\\<inverse>) D U (rev xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sources_aux I D U xs = sinks_aux (I\\<inverse>) D U (rev xs)", "by (induction xs, simp_all)"], ["", "lemma sources_aux_subset:\n \"U \\<subseteq> sources_aux I D U xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> sources_aux I D U xs", "by (subst sources_sinks_aux, rule sinks_aux_subset)"], ["", "lemma sources_aux_append:\n \"sources_aux I D U (xs @ ys) = sources_aux I D (sources_aux I D U ys) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sources_aux I D U (xs @ ys) = sources_aux I D (sources_aux I D U ys) xs", "by (induction xs, simp_all)"], ["", "lemma sources_aux_append_nil [rule_format]:\n \"sources_aux I D U ys = U \\<longrightarrow>\n  sources_aux I D U (xs @ ys) = sources_aux I D U xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sources_aux I D U ys = U \\<longrightarrow>\n    sources_aux I D U (xs @ ys) = sources_aux I D U xs", "by (induction xs, simp_all)"], ["", "lemma ipurge_tr_rev_aux_append:\n \"ipurge_tr_rev_aux I D U (xs @ ys) =\n  ipurge_tr_rev_aux I D (sources_aux I D U ys) xs @ ipurge_tr_rev_aux I D U ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys) =\n    ipurge_tr_rev_aux I D (sources_aux I D U ys) xs @\n    ipurge_tr_rev_aux I D U ys", "by (induction xs, simp_all add: sources_aux_append)"], ["", "lemma ipurge_tr_rev_aux_nil_1 [rule_format]:\n \"ipurge_tr_rev_aux I D U xs = [] \\<longrightarrow> (\\<forall>u \\<in> U. \\<not> (\\<exists>v \\<in> D ` set xs. (v, u) \\<in> I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U xs = [] \\<longrightarrow>\n    (\\<forall>u\\<in>U. \\<not> (\\<exists>v\\<in>D ` set xs. (v, u) \\<in> I))", "by (induction xs rule: rev_induct, simp_all add: ipurge_tr_rev_aux_append)"], ["", "lemma ipurge_tr_rev_aux_nil_2 [rule_format]:\n \"(\\<forall>u \\<in> U. \\<not> (\\<exists>v \\<in> D ` set xs. (v, u) \\<in> I)) \\<longrightarrow> ipurge_tr_rev_aux I D U xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>u\\<in>U.\n        \\<not> (\\<exists>v\\<in>D ` set xs.\n                   (v, u) \\<in> I)) \\<longrightarrow>\n    ipurge_tr_rev_aux I D U xs = []", "by (induction xs rule: rev_induct, simp_all add: ipurge_tr_rev_aux_append)"], ["", "lemma ipurge_tr_rev_aux_nil:\n \"(ipurge_tr_rev_aux I D U xs = []) = (\\<forall>u \\<in> U. \\<not> (\\<exists>v \\<in> D ` set xs. (v, u) \\<in> I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipurge_tr_rev_aux I D U xs = []) =\n    (\\<forall>u\\<in>U. \\<not> (\\<exists>v\\<in>D ` set xs. (v, u) \\<in> I))", "proof (rule iffI, rule ballI, erule ipurge_tr_rev_aux_nil_1, assumption)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U.\n       \\<not> (\\<exists>v\\<in>D ` set xs. (v, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U xs = []", "qed (rule ipurge_tr_rev_aux_nil_2, erule bspec)"], ["", "lemma ipurge_tr_rev_aux_nil_sources [rule_format]:\n \"ipurge_tr_rev_aux I D U xs = [] \\<longrightarrow> sources_aux I D U xs = U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U xs = [] \\<longrightarrow>\n    sources_aux I D U xs = U", "by (induction xs, simp_all)"], ["", "lemma ipurge_tr_rev_aux_append_nil_1 [rule_format]:\n \"ipurge_tr_rev_aux I D U ys = [] \\<longrightarrow>\n  ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U ys = [] \\<longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs", "by (induction xs, simp_all add: ipurge_tr_rev_aux_nil_sources sources_aux_append_nil)"], ["", "lemma ipurge_tr_rev_aux_first [rule_format]:\n \"ipurge_tr_rev_aux I D U xs = x # ws \\<longrightarrow>\n  (\\<exists>ys zs. xs = ys @ x # zs \\<and>\n    ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n    (\\<exists>v \\<in> sources_aux I D U zs. (D x, v) \\<in> I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U xs = x # ws \\<longrightarrow>\n    (\\<exists>ys zs.\n        xs = ys @ x # zs \\<and>\n        ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n        (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I))", "proof (induction xs, simp, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>ipurge_tr_rev_aux I D U xs = x # ws \\<longrightarrow>\n                (\\<exists>ys zs.\n                    xs = ys @ x # zs \\<and>\n                    ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys =\n                    [] \\<and>\n                    (\\<exists>v\\<in>sources_aux I D U zs.\n                        (D x, v) \\<in> I));\n        ipurge_tr_rev_aux I D U (a # xs) = x # ws\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            a # xs = ys @ x # zs \\<and>\n                            ipurge_tr_rev_aux I D\n                             (sources_aux I D U (x # zs)) ys =\n                            [] \\<and>\n                            (\\<exists>v\\<in>sources_aux I D U zs.\n                                (D x, v) \\<in> I)", "fix x' xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>ipurge_tr_rev_aux I D U xs = x # ws \\<longrightarrow>\n                (\\<exists>ys zs.\n                    xs = ys @ x # zs \\<and>\n                    ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys =\n                    [] \\<and>\n                    (\\<exists>v\\<in>sources_aux I D U zs.\n                        (D x, v) \\<in> I));\n        ipurge_tr_rev_aux I D U (a # xs) = x # ws\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            a # xs = ys @ x # zs \\<and>\n                            ipurge_tr_rev_aux I D\n                             (sources_aux I D U (x # zs)) ys =\n                            [] \\<and>\n                            (\\<exists>v\\<in>sources_aux I D U zs.\n                                (D x, v) \\<in> I)", "assume\n    A: \"ipurge_tr_rev_aux I D U xs = x # ws \\<longrightarrow>\n      (\\<exists>ys zs. xs = ys @ x # zs \\<and>\n        ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n        (\\<exists>v \\<in> sources_aux I D U zs. (D x, v) \\<in> I))\" and\n    B: \"ipurge_tr_rev_aux I D U (x' # xs) = x # ws\""], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U xs = x # ws \\<longrightarrow>\n  (\\<exists>ys zs.\n      xs = ys @ x # zs \\<and>\n      ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n      (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I))\n  ipurge_tr_rev_aux I D U (x' # xs) = x # ws\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>ipurge_tr_rev_aux I D U xs = x # ws \\<longrightarrow>\n                (\\<exists>ys zs.\n                    xs = ys @ x # zs \\<and>\n                    ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys =\n                    [] \\<and>\n                    (\\<exists>v\\<in>sources_aux I D U zs.\n                        (D x, v) \\<in> I));\n        ipurge_tr_rev_aux I D U (a # xs) = x # ws\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            a # xs = ys @ x # zs \\<and>\n                            ipurge_tr_rev_aux I D\n                             (sources_aux I D U (x # zs)) ys =\n                            [] \\<and>\n                            (\\<exists>v\\<in>sources_aux I D U zs.\n                                (D x, v) \\<in> I)", "show \"\\<exists>ys zs. x' # xs = ys @ x # zs \\<and>\n    ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n    (\\<exists>v \\<in> sources_aux I D U zs. (D x, v) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys zs.\n       x' # xs = ys @ x # zs \\<and>\n       ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n       (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)", "proof (cases \"\\<exists>v \\<in> sources_aux I D U xs. (D x', v) \\<in> I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sources_aux I D U xs. (D x', v) \\<in> I \\<Longrightarrow>\n    \\<exists>ys zs.\n       x' # xs = ys @ x # zs \\<and>\n       ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n       (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)\n 2. \\<not> (\\<exists>v\\<in>sources_aux I D U xs.\n               (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       x' # xs = ys @ x # zs \\<and>\n       ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n       (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)", "case True"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sources_aux I D U xs. (D x', v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sources_aux I D U xs. (D x', v) \\<in> I \\<Longrightarrow>\n    \\<exists>ys zs.\n       x' # xs = ys @ x # zs \\<and>\n       ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n       (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)\n 2. \\<not> (\\<exists>v\\<in>sources_aux I D U xs.\n               (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       x' # xs = ys @ x # zs \\<and>\n       ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n       (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)", "then"], ["proof (chain)\npicking this:\n  \\<exists>v\\<in>sources_aux I D U xs. (D x', v) \\<in> I", "have \"x' = x\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sources_aux I D U xs. (D x', v) \\<in> I\n\ngoal (1 subgoal):\n 1. x' = x", "using B"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sources_aux I D U xs. (D x', v) \\<in> I\n  ipurge_tr_rev_aux I D U (x' # xs) = x # ws\n\ngoal (1 subgoal):\n 1. x' = x", "by simp"], ["proof (state)\nthis:\n  x' = x\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sources_aux I D U xs. (D x', v) \\<in> I \\<Longrightarrow>\n    \\<exists>ys zs.\n       x' # xs = ys @ x # zs \\<and>\n       ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n       (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)\n 2. \\<not> (\\<exists>v\\<in>sources_aux I D U xs.\n               (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       x' # xs = ys @ x # zs \\<and>\n       ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n       (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)", "with True"], ["proof (chain)\npicking this:\n  \\<exists>v\\<in>sources_aux I D U xs. (D x', v) \\<in> I\n  x' = x", "have \"x' # xs = x # xs \\<and>\n      ipurge_tr_rev_aux I D (sources_aux I D U (x # xs)) [] = [] \\<and>\n      (\\<exists>v \\<in> sources_aux I D U xs. (D x, v) \\<in> I)\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sources_aux I D U xs. (D x', v) \\<in> I\n  x' = x\n\ngoal (1 subgoal):\n 1. x' # xs = x # xs \\<and>\n    ipurge_tr_rev_aux I D (sources_aux I D U (x # xs)) [] = [] \\<and>\n    (\\<exists>v\\<in>sources_aux I D U xs. (D x, v) \\<in> I)", "by simp"], ["proof (state)\nthis:\n  x' # xs = x # xs \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # xs)) [] = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D U xs. (D x, v) \\<in> I)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sources_aux I D U xs. (D x', v) \\<in> I \\<Longrightarrow>\n    \\<exists>ys zs.\n       x' # xs = ys @ x # zs \\<and>\n       ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n       (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)\n 2. \\<not> (\\<exists>v\\<in>sources_aux I D U xs.\n               (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       x' # xs = ys @ x # zs \\<and>\n       ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n       (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x' # xs = x # xs \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # xs)) [] = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D U xs. (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs.\n       x' # xs = ys @ x # zs \\<and>\n       ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n       (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ys zs.\n     x' # xs = ys @ x # zs \\<and>\n     ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n     (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sources_aux I D U xs.\n               (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       x' # xs = ys @ x # zs \\<and>\n       ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n       (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sources_aux I D U xs.\n               (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       x' # xs = ys @ x # zs \\<and>\n       ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n       (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sources_aux I D U xs. (D x', v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sources_aux I D U xs.\n               (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       x' # xs = ys @ x # zs \\<and>\n       ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n       (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)", "hence \"ipurge_tr_rev_aux I D U xs = x # ws\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sources_aux I D U xs. (D x', v) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U xs = x # ws", "using B"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sources_aux I D U xs. (D x', v) \\<in> I)\n  ipurge_tr_rev_aux I D U (x' # xs) = x # ws\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U xs = x # ws", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U xs = x # ws\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sources_aux I D U xs.\n               (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       x' # xs = ys @ x # zs \\<and>\n       ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n       (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)", "with A"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_aux I D U xs = x # ws \\<longrightarrow>\n  (\\<exists>ys zs.\n      xs = ys @ x # zs \\<and>\n      ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n      (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I))\n  ipurge_tr_rev_aux I D U xs = x # ws", "have \"\\<exists>ys zs. xs = ys @ x # zs \\<and>\n      ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n      (\\<exists>v \\<in> sources_aux I D U zs. (D x, v) \\<in> I)\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U xs = x # ws \\<longrightarrow>\n  (\\<exists>ys zs.\n      xs = ys @ x # zs \\<and>\n      ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n      (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I))\n  ipurge_tr_rev_aux I D U xs = x # ws\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs.\n       xs = ys @ x # zs \\<and>\n       ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n       (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)", ".."], ["proof (state)\nthis:\n  \\<exists>ys zs.\n     xs = ys @ x # zs \\<and>\n     ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n     (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sources_aux I D U xs.\n               (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       x' # xs = ys @ x # zs \\<and>\n       ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n       (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)", "then"], ["proof (chain)\npicking this:\n  \\<exists>ys zs.\n     xs = ys @ x # zs \\<and>\n     ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n     (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)", "obtain ys and zs where xs: \"xs = ys @ x # zs \\<and>\n      ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n      (\\<exists>v \\<in> sources_aux I D U zs. (D x, v) \\<in> I)\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs.\n     xs = ys @ x # zs \\<and>\n     ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n     (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        xs = ys @ x # zs \\<and>\n        ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n        (\\<exists>v\\<in>sources_aux I D U zs.\n            (D x, v) \\<in> I) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xs = ys @ x # zs \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sources_aux I D U xs.\n               (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       x' # xs = ys @ x # zs \\<and>\n       ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n       (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)", "then"], ["proof (chain)\npicking this:\n  xs = ys @ x # zs \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)", "have\n      \"\\<not> (\\<exists>v \\<in> sources_aux I D (sources_aux I D U (x # zs)) ys. (D x', v) \\<in> I)\""], ["proof (prove)\nusing this:\n  xs = ys @ x # zs \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sources_aux I D (sources_aux I D U (x # zs)) ys.\n               (D x', v) \\<in> I)", "using False"], ["proof (prove)\nusing this:\n  xs = ys @ x # zs \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)\n  \\<not> (\\<exists>v\\<in>sources_aux I D U xs. (D x', v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sources_aux I D (sources_aux I D U (x # zs)) ys.\n               (D x', v) \\<in> I)", "by (simp add: sources_aux_append)"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sources_aux I D (sources_aux I D U (x # zs)) ys.\n             (D x', v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sources_aux I D U xs.\n               (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       x' # xs = ys @ x # zs \\<and>\n       ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n       (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)", "hence \"ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) (x' # ys) =\n      ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sources_aux I D (sources_aux I D U (x # zs)) ys.\n             (D x', v) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) (x' # ys) =\n    ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) (x' # ys) =\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sources_aux I D U xs.\n               (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       x' # xs = ys @ x # zs \\<and>\n       ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n       (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)", "with xs"], ["proof (chain)\npicking this:\n  xs = ys @ x # zs \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) (x' # ys) =\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys", "have \"x' # xs = (x' # ys) @ x # zs \\<and>\n      ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) (x' # ys) = [] \\<and>\n      (\\<exists>v \\<in> sources_aux I D U zs. (D x, v) \\<in> I)\""], ["proof (prove)\nusing this:\n  xs = ys @ x # zs \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) (x' # ys) =\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys\n\ngoal (1 subgoal):\n 1. x' # xs = (x' # ys) @ x # zs \\<and>\n    ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) (x' # ys) = [] \\<and>\n    (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)", "by (simp del: sources_aux.simps)"], ["proof (state)\nthis:\n  x' # xs = (x' # ys) @ x # zs \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) (x' # ys) = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sources_aux I D U xs.\n               (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       x' # xs = ys @ x # zs \\<and>\n       ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n       (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x' # xs = (x' # ys) @ x # zs \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) (x' # ys) = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs.\n       x' # xs = ys @ x # zs \\<and>\n       ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n       (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)", "by blast"], ["proof (state)\nthis:\n  \\<exists>ys zs.\n     x' # xs = ys @ x # zs \\<and>\n     ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n     (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ys zs.\n     x' # xs = ys @ x # zs \\<and>\n     ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n     (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_tr_rev_aux_last_1 [rule_format]:\n \"ipurge_tr_rev_aux I D U xs = ws @ [x] \\<longrightarrow> (\\<exists>v \\<in> U. (D x, v) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U xs = ws @ [x] \\<longrightarrow>\n    (\\<exists>v\\<in>U. (D x, v) \\<in> I)", "proof (induction xs rule: rev_induct, simp, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>ipurge_tr_rev_aux I D U xs = ws @ [x] \\<longrightarrow>\n                (\\<exists>v\\<in>U. (D x, v) \\<in> I);\n        ipurge_tr_rev_aux I D U (xs @ [xa]) = ws @ [x]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<in>U. (D x, v) \\<in> I", "fix xs x'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>ipurge_tr_rev_aux I D U xs = ws @ [x] \\<longrightarrow>\n                (\\<exists>v\\<in>U. (D x, v) \\<in> I);\n        ipurge_tr_rev_aux I D U (xs @ [xa]) = ws @ [x]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<in>U. (D x, v) \\<in> I", "assume\n    A: \"ipurge_tr_rev_aux I D U xs = ws @ [x] \\<longrightarrow> (\\<exists>v \\<in> U. (D x, v) \\<in> I)\" and\n    B: \"ipurge_tr_rev_aux I D U (xs @ [x']) = ws @ [x]\""], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U xs = ws @ [x] \\<longrightarrow>\n  (\\<exists>v\\<in>U. (D x, v) \\<in> I)\n  ipurge_tr_rev_aux I D U (xs @ [x']) = ws @ [x]\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>ipurge_tr_rev_aux I D U xs = ws @ [x] \\<longrightarrow>\n                (\\<exists>v\\<in>U. (D x, v) \\<in> I);\n        ipurge_tr_rev_aux I D U (xs @ [xa]) = ws @ [x]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<in>U. (D x, v) \\<in> I", "show \"\\<exists>v \\<in> U. (D x, v) \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U. (D x, v) \\<in> I", "proof (cases \"\\<exists>v \\<in> U. (D x', v) \\<in> I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>U. (D x', v) \\<in> I \\<Longrightarrow>\n    \\<exists>v\\<in>U. (D x, v) \\<in> I\n 2. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>v\\<in>U. (D x, v) \\<in> I", "case True"], ["proof (state)\nthis:\n  \\<exists>v\\<in>U. (D x', v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>U. (D x', v) \\<in> I \\<Longrightarrow>\n    \\<exists>v\\<in>U. (D x, v) \\<in> I\n 2. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>v\\<in>U. (D x, v) \\<in> I", "hence \"ipurge_tr_rev_aux I D U (xs @ [x']) =\n      ipurge_tr_rev_aux I D (insert (D x') U) xs @ [x']\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>U. (D x', v) \\<in> I\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ [x']) =\n    ipurge_tr_rev_aux I D (insert (D x') U) xs @ [x']", "by (simp add: ipurge_tr_rev_aux_append)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ [x']) =\n  ipurge_tr_rev_aux I D (insert (D x') U) xs @ [x']\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>U. (D x', v) \\<in> I \\<Longrightarrow>\n    \\<exists>v\\<in>U. (D x, v) \\<in> I\n 2. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>v\\<in>U. (D x, v) \\<in> I", "hence \"x' = x\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (xs @ [x']) =\n  ipurge_tr_rev_aux I D (insert (D x') U) xs @ [x']\n\ngoal (1 subgoal):\n 1. x' = x", "using B"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (xs @ [x']) =\n  ipurge_tr_rev_aux I D (insert (D x') U) xs @ [x']\n  ipurge_tr_rev_aux I D U (xs @ [x']) = ws @ [x]\n\ngoal (1 subgoal):\n 1. x' = x", "by simp"], ["proof (state)\nthis:\n  x' = x\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>U. (D x', v) \\<in> I \\<Longrightarrow>\n    \\<exists>v\\<in>U. (D x, v) \\<in> I\n 2. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>v\\<in>U. (D x, v) \\<in> I", "thus ?thesis"], ["proof (prove)\nusing this:\n  x' = x\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U. (D x, v) \\<in> I", "using True"], ["proof (prove)\nusing this:\n  x' = x\n  \\<exists>v\\<in>U. (D x', v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U. (D x, v) \\<in> I", "by simp"], ["proof (state)\nthis:\n  \\<exists>v\\<in>U. (D x, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>v\\<in>U. (D x, v) \\<in> I", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>v\\<in>U. (D x, v) \\<in> I", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>v\\<in>U. (D x, v) \\<in> I", "hence \"ipurge_tr_rev_aux I D U (xs @ [x']) = ipurge_tr_rev_aux I D U xs\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ [x']) = ipurge_tr_rev_aux I D U xs", "by (simp add: ipurge_tr_rev_aux_append)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ [x']) = ipurge_tr_rev_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>v\\<in>U. (D x, v) \\<in> I", "hence \"ipurge_tr_rev_aux I D U xs = ws @ [x]\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (xs @ [x']) = ipurge_tr_rev_aux I D U xs\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U xs = ws @ [x]", "using B"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (xs @ [x']) = ipurge_tr_rev_aux I D U xs\n  ipurge_tr_rev_aux I D U (xs @ [x']) = ws @ [x]\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U xs = ws @ [x]", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U xs = ws @ [x]\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>v\\<in>U. (D x, v) \\<in> I", "with A"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_aux I D U xs = ws @ [x] \\<longrightarrow>\n  (\\<exists>v\\<in>U. (D x, v) \\<in> I)\n  ipurge_tr_rev_aux I D U xs = ws @ [x]", "show ?thesis"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U xs = ws @ [x] \\<longrightarrow>\n  (\\<exists>v\\<in>U. (D x, v) \\<in> I)\n  ipurge_tr_rev_aux I D U xs = ws @ [x]\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>U. (D x, v) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<in>U. (D x, v) \\<in> I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>v\\<in>U. (D x, v) \\<in> I\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_tr_rev_aux_last_2 [rule_format]:\n \"ipurge_tr_rev_aux I D U xs = ws @ [x] \\<longrightarrow>\n  (\\<exists>ys zs. xs = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U xs = ws @ [x] \\<longrightarrow>\n    (\\<exists>ys zs.\n        xs = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = [])", "proof (induction xs rule: rev_induct, simp, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>ipurge_tr_rev_aux I D U xs = ws @ [x] \\<longrightarrow>\n                (\\<exists>ys zs.\n                    xs = ys @ x # zs \\<and>\n                    ipurge_tr_rev_aux I D U zs = []);\n        ipurge_tr_rev_aux I D U (xs @ [xa]) = ws @ [x]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            xs @ [xa] = ys @ x # zs \\<and>\n                            ipurge_tr_rev_aux I D U zs = []", "fix xs x'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>ipurge_tr_rev_aux I D U xs = ws @ [x] \\<longrightarrow>\n                (\\<exists>ys zs.\n                    xs = ys @ x # zs \\<and>\n                    ipurge_tr_rev_aux I D U zs = []);\n        ipurge_tr_rev_aux I D U (xs @ [xa]) = ws @ [x]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            xs @ [xa] = ys @ x # zs \\<and>\n                            ipurge_tr_rev_aux I D U zs = []", "assume\n    A: \"ipurge_tr_rev_aux I D U xs = ws @ [x] \\<longrightarrow>\n      (\\<exists>ys zs. xs = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = [])\" and\n    B: \"ipurge_tr_rev_aux I D U (xs @ [x']) = ws @ [x]\""], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U xs = ws @ [x] \\<longrightarrow>\n  (\\<exists>ys zs. xs = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = [])\n  ipurge_tr_rev_aux I D U (xs @ [x']) = ws @ [x]\n\ngoal (1 subgoal):\n 1. \\<And>xa xs.\n       \\<lbrakk>ipurge_tr_rev_aux I D U xs = ws @ [x] \\<longrightarrow>\n                (\\<exists>ys zs.\n                    xs = ys @ x # zs \\<and>\n                    ipurge_tr_rev_aux I D U zs = []);\n        ipurge_tr_rev_aux I D U (xs @ [xa]) = ws @ [x]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs.\n                            xs @ [xa] = ys @ x # zs \\<and>\n                            ipurge_tr_rev_aux I D U zs = []", "show \"\\<exists>ys zs. xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys zs.\n       xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []", "proof (cases \"\\<exists>v \\<in> U. (D x', v) \\<in> I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>U. (D x', v) \\<in> I \\<Longrightarrow>\n    \\<exists>ys zs.\n       xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []\n 2. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []", "case True"], ["proof (state)\nthis:\n  \\<exists>v\\<in>U. (D x', v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>U. (D x', v) \\<in> I \\<Longrightarrow>\n    \\<exists>ys zs.\n       xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []\n 2. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []", "hence \"ipurge_tr_rev_aux I D U (xs @ [x']) =\n      ipurge_tr_rev_aux I D (insert (D x') U) xs @ [x']\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>U. (D x', v) \\<in> I\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ [x']) =\n    ipurge_tr_rev_aux I D (insert (D x') U) xs @ [x']", "by (simp add: ipurge_tr_rev_aux_append)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ [x']) =\n  ipurge_tr_rev_aux I D (insert (D x') U) xs @ [x']\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>U. (D x', v) \\<in> I \\<Longrightarrow>\n    \\<exists>ys zs.\n       xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []\n 2. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []", "hence \"xs @ [x'] = xs @ x # [] \\<and> ipurge_tr_rev_aux I D U [] = []\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (xs @ [x']) =\n  ipurge_tr_rev_aux I D (insert (D x') U) xs @ [x']\n\ngoal (1 subgoal):\n 1. xs @ [x'] = xs @ [x] \\<and> ipurge_tr_rev_aux I D U [] = []", "using B"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (xs @ [x']) =\n  ipurge_tr_rev_aux I D (insert (D x') U) xs @ [x']\n  ipurge_tr_rev_aux I D U (xs @ [x']) = ws @ [x]\n\ngoal (1 subgoal):\n 1. xs @ [x'] = xs @ [x] \\<and> ipurge_tr_rev_aux I D U [] = []", "by simp"], ["proof (state)\nthis:\n  xs @ [x'] = xs @ [x] \\<and> ipurge_tr_rev_aux I D U [] = []\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>U. (D x', v) \\<in> I \\<Longrightarrow>\n    \\<exists>ys zs.\n       xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []\n 2. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs @ [x'] = xs @ [x] \\<and> ipurge_tr_rev_aux I D U [] = []\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs.\n       xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []", "by blast"], ["proof (state)\nthis:\n  \\<exists>ys zs.\n     xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []", "hence \"ipurge_tr_rev_aux I D U (xs @ [x']) = ipurge_tr_rev_aux I D U xs\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ [x']) = ipurge_tr_rev_aux I D U xs", "by (simp add: ipurge_tr_rev_aux_append)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ [x']) = ipurge_tr_rev_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []", "hence \"ipurge_tr_rev_aux I D U xs = ws @ [x]\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (xs @ [x']) = ipurge_tr_rev_aux I D U xs\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U xs = ws @ [x]", "using B"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (xs @ [x']) = ipurge_tr_rev_aux I D U xs\n  ipurge_tr_rev_aux I D U (xs @ [x']) = ws @ [x]\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U xs = ws @ [x]", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U xs = ws @ [x]\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []", "with A"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_aux I D U xs = ws @ [x] \\<longrightarrow>\n  (\\<exists>ys zs. xs = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = [])\n  ipurge_tr_rev_aux I D U xs = ws @ [x]", "have \"\\<exists>ys zs. xs = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U xs = ws @ [x] \\<longrightarrow>\n  (\\<exists>ys zs. xs = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = [])\n  ipurge_tr_rev_aux I D U xs = ws @ [x]\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs. xs = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []", ".."], ["proof (state)\nthis:\n  \\<exists>ys zs. xs = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []", "then"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. xs = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []", "obtain ys and zs where\n      C: \"xs = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. xs = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        xs = ys @ x # zs \\<and>\n        ipurge_tr_rev_aux I D U zs = [] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xs = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []", "hence \"xs @ [x'] = ys @ x # zs @ [x']\""], ["proof (prove)\nusing this:\n  xs = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []\n\ngoal (1 subgoal):\n 1. xs @ [x'] = ys @ x # zs @ [x']", "by simp"], ["proof (state)\nthis:\n  xs @ [x'] = ys @ x # zs @ [x']\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []", "moreover"], ["proof (state)\nthis:\n  xs @ [x'] = ys @ x # zs @ [x']\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []", "have\n     \"ipurge_tr_rev_aux I D U (zs @ [x']) = ipurge_tr_rev_aux I D U zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (zs @ [x']) = ipurge_tr_rev_aux I D U zs", "using False"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (zs @ [x']) = ipurge_tr_rev_aux I D U zs", "by (simp add: ipurge_tr_rev_aux_append)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (zs @ [x']) = ipurge_tr_rev_aux I D U zs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []", "hence \"ipurge_tr_rev_aux I D U (zs @ [x']) = []\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (zs @ [x']) = ipurge_tr_rev_aux I D U zs\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (zs @ [x']) = []", "using C"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (zs @ [x']) = ipurge_tr_rev_aux I D U zs\n  xs = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (zs @ [x']) = []", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (zs @ [x']) = []\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []", "ultimately"], ["proof (chain)\npicking this:\n  xs @ [x'] = ys @ x # zs @ [x']\n  ipurge_tr_rev_aux I D U (zs @ [x']) = []", "have \"xs @ [x'] = ys @ x # zs @ [x'] \\<and>\n      ipurge_tr_rev_aux I D U (zs @ [x']) = []\""], ["proof (prove)\nusing this:\n  xs @ [x'] = ys @ x # zs @ [x']\n  ipurge_tr_rev_aux I D U (zs @ [x']) = []\n\ngoal (1 subgoal):\n 1. xs @ [x'] = ys @ x # zs @ [x'] \\<and>\n    ipurge_tr_rev_aux I D U (zs @ [x']) = []", ".."], ["proof (state)\nthis:\n  xs @ [x'] = ys @ x # zs @ [x'] \\<and>\n  ipurge_tr_rev_aux I D U (zs @ [x']) = []\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>U. (D x', v) \\<in> I) \\<Longrightarrow>\n    \\<exists>ys zs.\n       xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs @ [x'] = ys @ x # zs @ [x'] \\<and>\n  ipurge_tr_rev_aux I D U (zs @ [x']) = []\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs.\n       xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []", "by blast"], ["proof (state)\nthis:\n  \\<exists>ys zs.\n     xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ys zs.\n     xs @ [x'] = ys @ x # zs \\<and> ipurge_tr_rev_aux I D U zs = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_tr_rev_aux_all [rule_format]:\n \"(\\<forall>v \\<in> D ` set xs. \\<exists>u \\<in> U. (v, u) \\<in> I) \\<longrightarrow> ipurge_tr_rev_aux I D U xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>v\\<in>D ` set xs.\n        \\<exists>u\\<in>U. (v, u) \\<in> I) \\<longrightarrow>\n    ipurge_tr_rev_aux I D U xs = xs", "proof (induction xs, simp, rule impI, simp, erule conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>ipurge_tr_rev_aux I D U xs = xs;\n        \\<exists>u\\<in>U. (D a, u) \\<in> I;\n        \\<forall>v\\<in>set xs. \\<exists>u\\<in>U. (D v, u) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<in>sources_aux I D U xs.\n                            (D a, v) \\<in> I", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>ipurge_tr_rev_aux I D U xs = xs;\n        \\<exists>u\\<in>U. (D a, u) \\<in> I;\n        \\<forall>v\\<in>set xs. \\<exists>u\\<in>U. (D v, u) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<in>sources_aux I D U xs.\n                            (D a, v) \\<in> I", "assume \"\\<exists>u \\<in> U. (D x, u) \\<in> I\""], ["proof (state)\nthis:\n  \\<exists>u\\<in>U. (D x, u) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>ipurge_tr_rev_aux I D U xs = xs;\n        \\<exists>u\\<in>U. (D a, u) \\<in> I;\n        \\<forall>v\\<in>set xs. \\<exists>u\\<in>U. (D v, u) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<in>sources_aux I D U xs.\n                            (D a, v) \\<in> I", "then"], ["proof (chain)\npicking this:\n  \\<exists>u\\<in>U. (D x, u) \\<in> I", "obtain u where A: \"u \\<in> U\" and B: \"(D x, u) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>U. (D x, u) \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> U; (D x, u) \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  u \\<in> U\n  (D x, u) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>ipurge_tr_rev_aux I D U xs = xs;\n        \\<exists>u\\<in>U. (D a, u) \\<in> I;\n        \\<forall>v\\<in>set xs. \\<exists>u\\<in>U. (D v, u) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<in>sources_aux I D U xs.\n                            (D a, v) \\<in> I", "have \"U \\<subseteq> sources_aux I D U xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> sources_aux I D U xs", "by (rule sources_aux_subset)"], ["proof (state)\nthis:\n  U \\<subseteq> sources_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>ipurge_tr_rev_aux I D U xs = xs;\n        \\<exists>u\\<in>U. (D a, u) \\<in> I;\n        \\<forall>v\\<in>set xs. \\<exists>u\\<in>U. (D v, u) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<in>sources_aux I D U xs.\n                            (D a, v) \\<in> I", "hence \"u \\<in> sources_aux I D U xs\""], ["proof (prove)\nusing this:\n  U \\<subseteq> sources_aux I D U xs\n\ngoal (1 subgoal):\n 1. u \\<in> sources_aux I D U xs", "using A"], ["proof (prove)\nusing this:\n  U \\<subseteq> sources_aux I D U xs\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. u \\<in> sources_aux I D U xs", ".."], ["proof (state)\nthis:\n  u \\<in> sources_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>ipurge_tr_rev_aux I D U xs = xs;\n        \\<exists>u\\<in>U. (D a, u) \\<in> I;\n        \\<forall>v\\<in>set xs. \\<exists>u\\<in>U. (D v, u) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v\\<in>sources_aux I D U xs.\n                            (D a, v) \\<in> I", "with B"], ["proof (chain)\npicking this:\n  (D x, u) \\<in> I\n  u \\<in> sources_aux I D U xs", "show \"\\<exists>u \\<in> sources_aux I D U xs. (D x, u) \\<in> I\""], ["proof (prove)\nusing this:\n  (D x, u) \\<in> I\n  u \\<in> sources_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>sources_aux I D U xs. (D x, u) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>u\\<in>sources_aux I D U xs. (D x, u) \\<in> I\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n\\null\n\nHere below, further properties of the functions defined above are investigated thanks to the\nintroduction of function \\<open>offset\\<close>, which searches a list for a given item and returns the\noffset of its first occurrence, if any, from the first item of the list.\n\n\\null\n\\<close>"], ["", "primrec offset :: \"nat \\<Rightarrow> 'a \\<Rightarrow> 'a list \\<Rightarrow> nat option\" where\n\"offset _ _ [] = None\" |\n\"offset n x (y # ys) = (if y = x then Some n else offset (Suc n) x ys)\""], ["", "lemma offset_not_none_1 [rule_format]:\n \"offset k x xs \\<noteq> None \\<longrightarrow> (\\<exists>ys zs. xs = ys @ x # zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offset k x xs \\<noteq> None \\<longrightarrow>\n    (\\<exists>ys zs. xs = ys @ x # zs)", "proof (induction xs arbitrary: k, simp, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs k.\n       \\<lbrakk>\\<And>k.\n                   offset k x xs \\<noteq> None \\<longrightarrow>\n                   (\\<exists>ys zs. xs = ys @ x # zs);\n        offset k x (a # xs) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs. a # xs = ys @ x # zs", "fix w xs k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs k.\n       \\<lbrakk>\\<And>k.\n                   offset k x xs \\<noteq> None \\<longrightarrow>\n                   (\\<exists>ys zs. xs = ys @ x # zs);\n        offset k x (a # xs) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs. a # xs = ys @ x # zs", "assume\n    A: \"\\<And>k. offset k x xs \\<noteq> None \\<longrightarrow> (\\<exists>ys zs. xs = ys @ x # zs)\" and\n    B: \"offset k x (w # xs) \\<noteq> None\""], ["proof (state)\nthis:\n  offset ?k x xs \\<noteq> None \\<longrightarrow>\n  (\\<exists>ys zs. xs = ys @ x # zs)\n  offset k x (w # xs) \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>a xs k.\n       \\<lbrakk>\\<And>k.\n                   offset k x xs \\<noteq> None \\<longrightarrow>\n                   (\\<exists>ys zs. xs = ys @ x # zs);\n        offset k x (a # xs) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ys zs. a # xs = ys @ x # zs", "show \"\\<exists>ys zs. w # xs = ys @ x # zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys zs. w # xs = ys @ x # zs", "proof (cases \"w = x\", simp)"], ["proof (state)\ngoal (2 subgoals):\n 1. w = x \\<Longrightarrow> \\<exists>ys zs. x # xs = ys @ x # zs\n 2. w \\<noteq> x \\<Longrightarrow> \\<exists>ys zs. w # xs = ys @ x # zs", "case True"], ["proof (state)\nthis:\n  w = x\n\ngoal (2 subgoals):\n 1. w = x \\<Longrightarrow> \\<exists>ys zs. x # xs = ys @ x # zs\n 2. w \\<noteq> x \\<Longrightarrow> \\<exists>ys zs. w # xs = ys @ x # zs", "hence \"x # xs = [] @ x # xs\""], ["proof (prove)\nusing this:\n  w = x\n\ngoal (1 subgoal):\n 1. x # xs = [] @ x # xs", "by simp"], ["proof (state)\nthis:\n  x # xs = [] @ x # xs\n\ngoal (2 subgoals):\n 1. w = x \\<Longrightarrow> \\<exists>ys zs. x # xs = ys @ x # zs\n 2. w \\<noteq> x \\<Longrightarrow> \\<exists>ys zs. w # xs = ys @ x # zs", "thus \"\\<exists>ys zs. x # xs = ys @ x # zs\""], ["proof (prove)\nusing this:\n  x # xs = [] @ x # xs\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs. x # xs = ys @ x # zs", "by blast"], ["proof (state)\nthis:\n  \\<exists>ys zs. x # xs = ys @ x # zs\n\ngoal (1 subgoal):\n 1. w \\<noteq> x \\<Longrightarrow> \\<exists>ys zs. w # xs = ys @ x # zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> x \\<Longrightarrow> \\<exists>ys zs. w # xs = ys @ x # zs", "case False"], ["proof (state)\nthis:\n  w \\<noteq> x\n\ngoal (1 subgoal):\n 1. w \\<noteq> x \\<Longrightarrow> \\<exists>ys zs. w # xs = ys @ x # zs", "hence \"offset k x (w # xs) = offset (Suc k) x xs\""], ["proof (prove)\nusing this:\n  w \\<noteq> x\n\ngoal (1 subgoal):\n 1. offset k x (w # xs) = offset (Suc k) x xs", "by simp"], ["proof (state)\nthis:\n  offset k x (w # xs) = offset (Suc k) x xs\n\ngoal (1 subgoal):\n 1. w \\<noteq> x \\<Longrightarrow> \\<exists>ys zs. w # xs = ys @ x # zs", "hence \"offset (Suc k) x xs \\<noteq> None\""], ["proof (prove)\nusing this:\n  offset k x (w # xs) = offset (Suc k) x xs\n\ngoal (1 subgoal):\n 1. offset (Suc k) x xs \\<noteq> None", "using B"], ["proof (prove)\nusing this:\n  offset k x (w # xs) = offset (Suc k) x xs\n  offset k x (w # xs) \\<noteq> None\n\ngoal (1 subgoal):\n 1. offset (Suc k) x xs \\<noteq> None", "by simp"], ["proof (state)\nthis:\n  offset (Suc k) x xs \\<noteq> None\n\ngoal (1 subgoal):\n 1. w \\<noteq> x \\<Longrightarrow> \\<exists>ys zs. w # xs = ys @ x # zs", "moreover"], ["proof (state)\nthis:\n  offset (Suc k) x xs \\<noteq> None\n\ngoal (1 subgoal):\n 1. w \\<noteq> x \\<Longrightarrow> \\<exists>ys zs. w # xs = ys @ x # zs", "have \"offset (Suc k) x xs \\<noteq> None \\<longrightarrow> (\\<exists>ys zs. xs = ys @ x # zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offset (Suc k) x xs \\<noteq> None \\<longrightarrow>\n    (\\<exists>ys zs. xs = ys @ x # zs)", "using A"], ["proof (prove)\nusing this:\n  offset ?k x xs \\<noteq> None \\<longrightarrow>\n  (\\<exists>ys zs. xs = ys @ x # zs)\n\ngoal (1 subgoal):\n 1. offset (Suc k) x xs \\<noteq> None \\<longrightarrow>\n    (\\<exists>ys zs. xs = ys @ x # zs)", "."], ["proof (state)\nthis:\n  offset (Suc k) x xs \\<noteq> None \\<longrightarrow>\n  (\\<exists>ys zs. xs = ys @ x # zs)\n\ngoal (1 subgoal):\n 1. w \\<noteq> x \\<Longrightarrow> \\<exists>ys zs. w # xs = ys @ x # zs", "ultimately"], ["proof (chain)\npicking this:\n  offset (Suc k) x xs \\<noteq> None\n  offset (Suc k) x xs \\<noteq> None \\<longrightarrow>\n  (\\<exists>ys zs. xs = ys @ x # zs)", "have \"\\<exists>ys zs. xs = ys @ x # zs\""], ["proof (prove)\nusing this:\n  offset (Suc k) x xs \\<noteq> None\n  offset (Suc k) x xs \\<noteq> None \\<longrightarrow>\n  (\\<exists>ys zs. xs = ys @ x # zs)\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs. xs = ys @ x # zs", "by simp"], ["proof (state)\nthis:\n  \\<exists>ys zs. xs = ys @ x # zs\n\ngoal (1 subgoal):\n 1. w \\<noteq> x \\<Longrightarrow> \\<exists>ys zs. w # xs = ys @ x # zs", "then"], ["proof (chain)\npicking this:\n  \\<exists>ys zs. xs = ys @ x # zs", "obtain ys and zs where \"xs = ys @ x # zs\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. xs = ys @ x # zs\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        xs = ys @ x # zs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xs = ys @ x # zs\n\ngoal (1 subgoal):\n 1. w \\<noteq> x \\<Longrightarrow> \\<exists>ys zs. w # xs = ys @ x # zs", "hence \"w # xs = (w # ys) @ x # zs\""], ["proof (prove)\nusing this:\n  xs = ys @ x # zs\n\ngoal (1 subgoal):\n 1. w # xs = (w # ys) @ x # zs", "by simp"], ["proof (state)\nthis:\n  w # xs = (w # ys) @ x # zs\n\ngoal (1 subgoal):\n 1. w \\<noteq> x \\<Longrightarrow> \\<exists>ys zs. w # xs = ys @ x # zs", "thus \"\\<exists>ys zs. w # xs = ys @ x # zs\""], ["proof (prove)\nusing this:\n  w # xs = (w # ys) @ x # zs\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs. w # xs = ys @ x # zs", "by blast"], ["proof (state)\nthis:\n  \\<exists>ys zs. w # xs = ys @ x # zs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ys zs. w # xs = ys @ x # zs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma offset_not_none_2 [rule_format]:\n \"xs = ys @ x # zs \\<longrightarrow> offset k x xs \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys @ x # zs \\<longrightarrow> offset k x xs \\<noteq> None", "proof (induction xs arbitrary: ys k, simp_all del: not_None_eq, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys k.\n       \\<lbrakk>\\<And>ys k.\n                   xs = ys @ x # zs \\<longrightarrow>\n                   offset k x (ys @ x # zs) \\<noteq> None;\n        a # xs = ys @ x # zs\\<rbrakk>\n       \\<Longrightarrow> offset k x (ys @ x # zs) \\<noteq> None", "fix w xs ys k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys k.\n       \\<lbrakk>\\<And>ys k.\n                   xs = ys @ x # zs \\<longrightarrow>\n                   offset k x (ys @ x # zs) \\<noteq> None;\n        a # xs = ys @ x # zs\\<rbrakk>\n       \\<Longrightarrow> offset k x (ys @ x # zs) \\<noteq> None", "assume\n    A: \"\\<And>ys' k'. xs = ys' @ x # zs \\<longrightarrow> offset k' x (ys' @ x # zs) \\<noteq> None\" and\n    B: \"w # xs = ys @ x # zs\""], ["proof (state)\nthis:\n  xs = ?ys' @ x # zs \\<longrightarrow>\n  offset ?k' x (?ys' @ x # zs) \\<noteq> None\n  w # xs = ys @ x # zs\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys k.\n       \\<lbrakk>\\<And>ys k.\n                   xs = ys @ x # zs \\<longrightarrow>\n                   offset k x (ys @ x # zs) \\<noteq> None;\n        a # xs = ys @ x # zs\\<rbrakk>\n       \\<Longrightarrow> offset k x (ys @ x # zs) \\<noteq> None", "show \"offset k x (ys @ x # zs) \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offset k x (ys @ x # zs) \\<noteq> None", "proof (cases ys, simp_all del: not_None_eq, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ys = a # list; a \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> offset (Suc k) x (list @ x # zs) \\<noteq> None", "fix y' ys'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ys = a # list; a \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> offset (Suc k) x (list @ x # zs) \\<noteq> None", "have \"xs = ys' @ x # zs \\<longrightarrow> offset (Suc k) x (ys' @ x # zs) \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys' @ x # zs \\<longrightarrow>\n    offset (Suc k) x (ys' @ x # zs) \\<noteq> None", "using A"], ["proof (prove)\nusing this:\n  xs = ?ys' @ x # zs \\<longrightarrow>\n  offset ?k' x (?ys' @ x # zs) \\<noteq> None\n\ngoal (1 subgoal):\n 1. xs = ys' @ x # zs \\<longrightarrow>\n    offset (Suc k) x (ys' @ x # zs) \\<noteq> None", "."], ["proof (state)\nthis:\n  xs = ys' @ x # zs \\<longrightarrow>\n  offset (Suc k) x (ys' @ x # zs) \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ys = a # list; a \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> offset (Suc k) x (list @ x # zs) \\<noteq> None", "moreover"], ["proof (state)\nthis:\n  xs = ys' @ x # zs \\<longrightarrow>\n  offset (Suc k) x (ys' @ x # zs) \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ys = a # list; a \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> offset (Suc k) x (list @ x # zs) \\<noteq> None", "assume \"ys = y' # ys'\""], ["proof (state)\nthis:\n  ys = y' # ys'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ys = a # list; a \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> offset (Suc k) x (list @ x # zs) \\<noteq> None", "hence \"xs = ys' @ x # zs\""], ["proof (prove)\nusing this:\n  ys = y' # ys'\n\ngoal (1 subgoal):\n 1. xs = ys' @ x # zs", "using B"], ["proof (prove)\nusing this:\n  ys = y' # ys'\n  w # xs = ys @ x # zs\n\ngoal (1 subgoal):\n 1. xs = ys' @ x # zs", "by simp"], ["proof (state)\nthis:\n  xs = ys' @ x # zs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>ys = a # list; a \\<noteq> x\\<rbrakk>\n       \\<Longrightarrow> offset (Suc k) x (list @ x # zs) \\<noteq> None", "ultimately"], ["proof (chain)\npicking this:\n  xs = ys' @ x # zs \\<longrightarrow>\n  offset (Suc k) x (ys' @ x # zs) \\<noteq> None\n  xs = ys' @ x # zs", "show \"offset (Suc k) x (ys' @ x # zs) \\<noteq> None\""], ["proof (prove)\nusing this:\n  xs = ys' @ x # zs \\<longrightarrow>\n  offset (Suc k) x (ys' @ x # zs) \\<noteq> None\n  xs = ys' @ x # zs\n\ngoal (1 subgoal):\n 1. offset (Suc k) x (ys' @ x # zs) \\<noteq> None", ".."], ["proof (state)\nthis:\n  offset (Suc k) x (ys' @ x # zs) \\<noteq> None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  offset k x (ys @ x # zs) \\<noteq> None\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma offset_not_none:\n \"(offset k x xs \\<noteq> None) = (\\<exists>ys zs. xs = ys @ x # zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (offset k x xs \\<noteq> None) = (\\<exists>ys zs. xs = ys @ x # zs)", "by (rule iffI, erule offset_not_none_1, (erule exE)+, rule offset_not_none_2)"], ["", "lemma offset_addition [rule_format]:\n \"offset k x xs \\<noteq> None \\<longrightarrow> offset (n + m) x xs = Some (the (offset n x xs) + m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offset k x xs \\<noteq> None \\<longrightarrow>\n    offset (n + m) x xs = Some (the (offset n x xs) + m)", "proof (induction xs arbitrary: k n, simp, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs k n.\n       \\<lbrakk>\\<And>k n.\n                   offset k x xs \\<noteq> None \\<longrightarrow>\n                   offset (n + m) x xs = Some (the (offset n x xs) + m);\n        offset k x (a # xs) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> offset (n + m) x (a # xs) =\n                         Some (the (offset n x (a # xs)) + m)", "fix w xs k n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs k n.\n       \\<lbrakk>\\<And>k n.\n                   offset k x xs \\<noteq> None \\<longrightarrow>\n                   offset (n + m) x xs = Some (the (offset n x xs) + m);\n        offset k x (a # xs) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> offset (n + m) x (a # xs) =\n                         Some (the (offset n x (a # xs)) + m)", "assume\n    A: \"\\<And>k n. offset k x xs \\<noteq> None \\<longrightarrow>\n      offset (n + m) x xs = Some (the (offset n x xs) + m)\" and\n    B: \"offset k x (w # xs) \\<noteq> None\""], ["proof (state)\nthis:\n  offset ?k x xs \\<noteq> None \\<longrightarrow>\n  offset (?n + m) x xs = Some (the (offset ?n x xs) + m)\n  offset k x (w # xs) \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<And>a xs k n.\n       \\<lbrakk>\\<And>k n.\n                   offset k x xs \\<noteq> None \\<longrightarrow>\n                   offset (n + m) x xs = Some (the (offset n x xs) + m);\n        offset k x (a # xs) \\<noteq> None\\<rbrakk>\n       \\<Longrightarrow> offset (n + m) x (a # xs) =\n                         Some (the (offset n x (a # xs)) + m)", "show \"offset (n + m) x (w # xs) = Some (the (offset n x (w # xs)) + m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offset (n + m) x (w # xs) = Some (the (offset n x (w # xs)) + m)", "proof (cases \"w = x\", simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> x \\<Longrightarrow>\n    offset (Suc (n + m)) x xs = Some (the (offset (Suc n) x xs) + m)", "case False"], ["proof (state)\nthis:\n  w \\<noteq> x\n\ngoal (1 subgoal):\n 1. w \\<noteq> x \\<Longrightarrow>\n    offset (Suc (n + m)) x xs = Some (the (offset (Suc n) x xs) + m)", "hence \"offset k x (w # xs) = offset (Suc k) x xs\""], ["proof (prove)\nusing this:\n  w \\<noteq> x\n\ngoal (1 subgoal):\n 1. offset k x (w # xs) = offset (Suc k) x xs", "by simp"], ["proof (state)\nthis:\n  offset k x (w # xs) = offset (Suc k) x xs\n\ngoal (1 subgoal):\n 1. w \\<noteq> x \\<Longrightarrow>\n    offset (Suc (n + m)) x xs = Some (the (offset (Suc n) x xs) + m)", "hence \"offset (Suc k) x xs \\<noteq> None\""], ["proof (prove)\nusing this:\n  offset k x (w # xs) = offset (Suc k) x xs\n\ngoal (1 subgoal):\n 1. offset (Suc k) x xs \\<noteq> None", "using B"], ["proof (prove)\nusing this:\n  offset k x (w # xs) = offset (Suc k) x xs\n  offset k x (w # xs) \\<noteq> None\n\ngoal (1 subgoal):\n 1. offset (Suc k) x xs \\<noteq> None", "by simp"], ["proof (state)\nthis:\n  offset (Suc k) x xs \\<noteq> None\n\ngoal (1 subgoal):\n 1. w \\<noteq> x \\<Longrightarrow>\n    offset (Suc (n + m)) x xs = Some (the (offset (Suc n) x xs) + m)", "moreover"], ["proof (state)\nthis:\n  offset (Suc k) x xs \\<noteq> None\n\ngoal (1 subgoal):\n 1. w \\<noteq> x \\<Longrightarrow>\n    offset (Suc (n + m)) x xs = Some (the (offset (Suc n) x xs) + m)", "have \"offset (Suc k) x xs \\<noteq> None \\<longrightarrow>\n      offset (Suc n + m) x xs = Some (the (offset (Suc n) x xs) + m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offset (Suc k) x xs \\<noteq> None \\<longrightarrow>\n    offset (Suc n + m) x xs = Some (the (offset (Suc n) x xs) + m)", "using A"], ["proof (prove)\nusing this:\n  offset ?k x xs \\<noteq> None \\<longrightarrow>\n  offset (?n + m) x xs = Some (the (offset ?n x xs) + m)\n\ngoal (1 subgoal):\n 1. offset (Suc k) x xs \\<noteq> None \\<longrightarrow>\n    offset (Suc n + m) x xs = Some (the (offset (Suc n) x xs) + m)", "."], ["proof (state)\nthis:\n  offset (Suc k) x xs \\<noteq> None \\<longrightarrow>\n  offset (Suc n + m) x xs = Some (the (offset (Suc n) x xs) + m)\n\ngoal (1 subgoal):\n 1. w \\<noteq> x \\<Longrightarrow>\n    offset (Suc (n + m)) x xs = Some (the (offset (Suc n) x xs) + m)", "ultimately"], ["proof (chain)\npicking this:\n  offset (Suc k) x xs \\<noteq> None\n  offset (Suc k) x xs \\<noteq> None \\<longrightarrow>\n  offset (Suc n + m) x xs = Some (the (offset (Suc n) x xs) + m)", "show \"offset (Suc (n + m)) x xs =\n      Some (the (offset (Suc n) x xs) + m)\""], ["proof (prove)\nusing this:\n  offset (Suc k) x xs \\<noteq> None\n  offset (Suc k) x xs \\<noteq> None \\<longrightarrow>\n  offset (Suc n + m) x xs = Some (the (offset (Suc n) x xs) + m)\n\ngoal (1 subgoal):\n 1. offset (Suc (n + m)) x xs = Some (the (offset (Suc n) x xs) + m)", "by simp"], ["proof (state)\nthis:\n  offset (Suc (n + m)) x xs = Some (the (offset (Suc n) x xs) + m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  offset (n + m) x (w # xs) = Some (the (offset n x (w # xs)) + m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma offset_suc:\n  assumes A: \"offset k x xs \\<noteq> None\"\n  shows \"offset (Suc n) x xs = Some (Suc (the (offset n x xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offset (Suc n) x xs = Some (Suc (the (offset n x xs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. offset (Suc n) x xs = Some (Suc (the (offset n x xs)))", "have \"offset (Suc n) x xs = offset (n + Suc 0) x xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offset (Suc n) x xs = offset (n + Suc 0) x xs", "by simp"], ["proof (state)\nthis:\n  offset (Suc n) x xs = offset (n + Suc 0) x xs\n\ngoal (1 subgoal):\n 1. offset (Suc n) x xs = Some (Suc (the (offset n x xs)))", "also"], ["proof (state)\nthis:\n  offset (Suc n) x xs = offset (n + Suc 0) x xs\n\ngoal (1 subgoal):\n 1. offset (Suc n) x xs = Some (Suc (the (offset n x xs)))", "have \"\\<dots> = Some (the (offset n x xs) + Suc 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offset (n + Suc 0) x xs = Some (the (offset n x xs) + Suc 0)", "using A"], ["proof (prove)\nusing this:\n  offset k x xs \\<noteq> None\n\ngoal (1 subgoal):\n 1. offset (n + Suc 0) x xs = Some (the (offset n x xs) + Suc 0)", "by (rule offset_addition)"], ["proof (state)\nthis:\n  offset (n + Suc 0) x xs = Some (the (offset n x xs) + Suc 0)\n\ngoal (1 subgoal):\n 1. offset (Suc n) x xs = Some (Suc (the (offset n x xs)))", "also"], ["proof (state)\nthis:\n  offset (n + Suc 0) x xs = Some (the (offset n x xs) + Suc 0)\n\ngoal (1 subgoal):\n 1. offset (Suc n) x xs = Some (Suc (the (offset n x xs)))", "have \"\\<dots> = Some (Suc (the (offset n x xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some (the (offset n x xs) + Suc 0) = Some (Suc (the (offset n x xs)))", "by simp"], ["proof (state)\nthis:\n  Some (the (offset n x xs) + Suc 0) = Some (Suc (the (offset n x xs)))\n\ngoal (1 subgoal):\n 1. offset (Suc n) x xs = Some (Suc (the (offset n x xs)))", "finally"], ["proof (chain)\npicking this:\n  offset (Suc n) x xs = Some (Suc (the (offset n x xs)))", "show ?thesis"], ["proof (prove)\nusing this:\n  offset (Suc n) x xs = Some (Suc (the (offset n x xs)))\n\ngoal (1 subgoal):\n 1. offset (Suc n) x xs = Some (Suc (the (offset n x xs)))", "."], ["proof (state)\nthis:\n  offset (Suc n) x xs = Some (Suc (the (offset n x xs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_tr_rev_aux_first_offset [rule_format]:\n \"xs = ys @ x # zs \\<and> ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n    (\\<exists>v \\<in> sources_aux I D U zs. (D x, v) \\<in> I) \\<longrightarrow>\n  ys = take (the (offset 0 x xs)) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = ys @ x # zs \\<and>\n    ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n    (\\<exists>v\\<in>sources_aux I D U zs.\n        (D x, v) \\<in> I) \\<longrightarrow>\n    ys = take (the (offset 0 x xs)) xs", "proof (induction xs arbitrary: ys, simp, rule impI, (erule conjE)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   xs = ys @ x # zs \\<and>\n                   ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys =\n                   [] \\<and>\n                   (\\<exists>v\\<in>sources_aux I D U zs.\n                       (D x, v) \\<in> I) \\<longrightarrow>\n                   ys = take (the (offset 0 x xs)) xs;\n        a # xs = ys @ x # zs;\n        ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [];\n        \\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> ys = take (the (offset 0 x (a # xs))) (a # xs)", "fix x' xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   xs = ys @ x # zs \\<and>\n                   ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys =\n                   [] \\<and>\n                   (\\<exists>v\\<in>sources_aux I D U zs.\n                       (D x, v) \\<in> I) \\<longrightarrow>\n                   ys = take (the (offset 0 x xs)) xs;\n        a # xs = ys @ x # zs;\n        ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [];\n        \\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> ys = take (the (offset 0 x (a # xs))) (a # xs)", "assume\n    A: \"\\<And>ys. xs = ys @ x # zs \\<and>\n        ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [] \\<and>\n        (\\<exists>v \\<in> sources_aux I D U zs. (D x, v) \\<in> I) \\<longrightarrow>\n      ys = take (the (offset 0 x xs)) xs\" and\n    B: \"x' # xs = ys @ x # zs\" and\n    C: \"ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = []\" and\n    D: \"\\<exists>v \\<in> sources_aux I D U zs. (D x, v) \\<in> I\""], ["proof (state)\nthis:\n  xs = ?ys @ x # zs \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ?ys = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I) \\<longrightarrow>\n  ?ys = take (the (offset 0 x xs)) xs\n  x' # xs = ys @ x # zs\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = []\n  \\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   xs = ys @ x # zs \\<and>\n                   ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys =\n                   [] \\<and>\n                   (\\<exists>v\\<in>sources_aux I D U zs.\n                       (D x, v) \\<in> I) \\<longrightarrow>\n                   ys = take (the (offset 0 x xs)) xs;\n        a # xs = ys @ x # zs;\n        ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = [];\n        \\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I\\<rbrakk>\n       \\<Longrightarrow> ys = take (the (offset 0 x (a # xs))) (a # xs)", "show \"ys = take (the (offset 0 x (x' # xs))) (x' # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys = take (the (offset 0 x (x' # xs))) (x' # xs)", "proof (cases ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    ys = take (the (offset 0 x (x' # xs))) (x' # xs)\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       ys = take (the (offset 0 x (x' # xs))) (x' # xs)", "case Nil"], ["proof (state)\nthis:\n  ys = []\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    ys = take (the (offset 0 x (x' # xs))) (x' # xs)\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       ys = take (the (offset 0 x (x' # xs))) (x' # xs)", "then"], ["proof (chain)\npicking this:\n  ys = []", "have \"x' = x\""], ["proof (prove)\nusing this:\n  ys = []\n\ngoal (1 subgoal):\n 1. x' = x", "using B"], ["proof (prove)\nusing this:\n  ys = []\n  x' # xs = ys @ x # zs\n\ngoal (1 subgoal):\n 1. x' = x", "by simp"], ["proof (state)\nthis:\n  x' = x\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    ys = take (the (offset 0 x (x' # xs))) (x' # xs)\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       ys = take (the (offset 0 x (x' # xs))) (x' # xs)", "with Nil"], ["proof (chain)\npicking this:\n  ys = []\n  x' = x", "show ?thesis"], ["proof (prove)\nusing this:\n  ys = []\n  x' = x\n\ngoal (1 subgoal):\n 1. ys = take (the (offset 0 x (x' # xs))) (x' # xs)", "by simp"], ["proof (state)\nthis:\n  ys = take (the (offset 0 x (x' # xs))) (x' # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       ys = take (the (offset 0 x (x' # xs))) (x' # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       ys = take (the (offset 0 x (x' # xs))) (x' # xs)", "case (Cons y ys')"], ["proof (state)\nthis:\n  ys = y # ys'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       ys = take (the (offset 0 x (x' # xs))) (x' # xs)", "hence E: \"xs = ys' @ x # zs\""], ["proof (prove)\nusing this:\n  ys = y # ys'\n\ngoal (1 subgoal):\n 1. xs = ys' @ x # zs", "using B"], ["proof (prove)\nusing this:\n  ys = y # ys'\n  x' # xs = ys @ x # zs\n\ngoal (1 subgoal):\n 1. xs = ys' @ x # zs", "by simp"], ["proof (state)\nthis:\n  xs = ys' @ x # zs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       ys = take (the (offset 0 x (x' # xs))) (x' # xs)", "moreover"], ["proof (state)\nthis:\n  xs = ys' @ x # zs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       ys = take (the (offset 0 x (x' # xs))) (x' # xs)", "have\n      F: \"ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) (y # ys') = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) (y # ys') = []", "using Cons and C"], ["proof (prove)\nusing this:\n  ys = y # ys'\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys = []\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) (y # ys') = []", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) (y # ys') = []\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       ys = take (the (offset 0 x (x' # xs))) (x' # xs)", "hence\n      G: \"\\<not> (\\<exists>v \\<in> sources_aux I D (sources_aux I D U (x # zs)) ys'. (D y, v) \\<in> I)\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) (y # ys') = []\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sources_aux I D (sources_aux I D U (x # zs)) ys'.\n               (D y, v) \\<in> I)", "by (rule_tac notI, simp)"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sources_aux I D (sources_aux I D U (x # zs)) ys'.\n             (D y, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       ys = take (the (offset 0 x (x' # xs))) (x' # xs)", "hence \"ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys' = []\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sources_aux I D (sources_aux I D U (x # zs)) ys'.\n             (D y, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys' = []", "using F"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sources_aux I D (sources_aux I D U (x # zs)) ys'.\n             (D y, v) \\<in> I)\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) (y # ys') = []\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys' = []", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys' = []\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       ys = take (the (offset 0 x (x' # xs))) (x' # xs)", "ultimately"], ["proof (chain)\npicking this:\n  xs = ys' @ x # zs\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys' = []", "have \"xs = ys' @ x # zs \\<and>\n      ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys' = [] \\<and>\n      (\\<exists>v \\<in> sources_aux I D U zs. (D x, v) \\<in> I)\""], ["proof (prove)\nusing this:\n  xs = ys' @ x # zs\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys' = []\n\ngoal (1 subgoal):\n 1. xs = ys' @ x # zs \\<and>\n    ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys' = [] \\<and>\n    (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)", "using D"], ["proof (prove)\nusing this:\n  xs = ys' @ x # zs\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys' = []\n  \\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I\n\ngoal (1 subgoal):\n 1. xs = ys' @ x # zs \\<and>\n    ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys' = [] \\<and>\n    (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)", "by blast"], ["proof (state)\nthis:\n  xs = ys' @ x # zs \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys' = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       ys = take (the (offset 0 x (x' # xs))) (x' # xs)", "with A"], ["proof (chain)\npicking this:\n  xs = ?ys @ x # zs \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ?ys = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I) \\<longrightarrow>\n  ?ys = take (the (offset 0 x xs)) xs\n  xs = ys' @ x # zs \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys' = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)", "have H: \"ys' = take (the (offset 0 x xs)) xs\""], ["proof (prove)\nusing this:\n  xs = ?ys @ x # zs \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ?ys = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I) \\<longrightarrow>\n  ?ys = take (the (offset 0 x xs)) xs\n  xs = ys' @ x # zs \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # zs)) ys' = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. ys' = take (the (offset 0 x xs)) xs", ".."], ["proof (state)\nthis:\n  ys' = take (the (offset 0 x xs)) xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       ys = take (the (offset 0 x (x' # xs))) (x' # xs)", "have I: \"x' = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x' = y", "using Cons and B"], ["proof (prove)\nusing this:\n  ys = y # ys'\n  x' # xs = ys @ x # zs\n\ngoal (1 subgoal):\n 1. x' = y", "by simp"], ["proof (state)\nthis:\n  x' = y\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       ys = take (the (offset 0 x (x' # xs))) (x' # xs)", "hence\n      J: \"\\<not> (\\<exists>v \\<in> sources_aux I D (sources_aux I D U zs) (ys' @ [x]). (D x', v) \\<in> I)\""], ["proof (prove)\nusing this:\n  x' = y\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sources_aux I D (sources_aux I D U zs)\n                            (ys' @ [x]).\n               (D x', v) \\<in> I)", "using G"], ["proof (prove)\nusing this:\n  x' = y\n  \\<not> (\\<exists>v\\<in>sources_aux I D (sources_aux I D U (x # zs)) ys'.\n             (D y, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sources_aux I D (sources_aux I D U zs)\n                            (ys' @ [x]).\n               (D x', v) \\<in> I)", "by (simp add: sources_aux_append)"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sources_aux I D (sources_aux I D U zs) (ys' @ [x]).\n             (D x', v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       ys = take (the (offset 0 x (x' # xs))) (x' # xs)", "have \"x' \\<noteq> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<noteq> x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. x' = x \\<Longrightarrow> False", "assume \"x' = x\""], ["proof (state)\nthis:\n  x' = x\n\ngoal (1 subgoal):\n 1. x' = x \\<Longrightarrow> False", "hence \"\\<exists>v \\<in> sources_aux I D U zs. (D x', v) \\<in> I\""], ["proof (prove)\nusing this:\n  x' = x\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sources_aux I D U zs. (D x', v) \\<in> I", "using D"], ["proof (prove)\nusing this:\n  x' = x\n  \\<exists>v\\<in>sources_aux I D U zs. (D x, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sources_aux I D U zs. (D x', v) \\<in> I", "by simp"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sources_aux I D U zs. (D x', v) \\<in> I\n\ngoal (1 subgoal):\n 1. x' = x \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>v\\<in>sources_aux I D U zs. (D x', v) \\<in> I", "obtain v where K: \"v \\<in> sources_aux I D U zs\" and L: \"(D x', v) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sources_aux I D U zs. (D x', v) \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> sources_aux I D U zs; (D x', v) \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  v \\<in> sources_aux I D U zs\n  (D x', v) \\<in> I\n\ngoal (1 subgoal):\n 1. x' = x \\<Longrightarrow> False", "have \"sources_aux I D U zs \\<subseteq>\n        sources_aux I D (sources_aux I D U zs) (ys' @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sources_aux I D U zs\n    \\<subseteq> sources_aux I D (sources_aux I D U zs) (ys' @ [x])", "by (rule sources_aux_subset)"], ["proof (state)\nthis:\n  sources_aux I D U zs\n  \\<subseteq> sources_aux I D (sources_aux I D U zs) (ys' @ [x])\n\ngoal (1 subgoal):\n 1. x' = x \\<Longrightarrow> False", "hence \"v \\<in> sources_aux I D (sources_aux I D U zs) (ys' @ [x])\""], ["proof (prove)\nusing this:\n  sources_aux I D U zs\n  \\<subseteq> sources_aux I D (sources_aux I D U zs) (ys' @ [x])\n\ngoal (1 subgoal):\n 1. v \\<in> sources_aux I D (sources_aux I D U zs) (ys' @ [x])", "using K"], ["proof (prove)\nusing this:\n  sources_aux I D U zs\n  \\<subseteq> sources_aux I D (sources_aux I D U zs) (ys' @ [x])\n  v \\<in> sources_aux I D U zs\n\ngoal (1 subgoal):\n 1. v \\<in> sources_aux I D (sources_aux I D U zs) (ys' @ [x])", ".."], ["proof (state)\nthis:\n  v \\<in> sources_aux I D (sources_aux I D U zs) (ys' @ [x])\n\ngoal (1 subgoal):\n 1. x' = x \\<Longrightarrow> False", "with L"], ["proof (chain)\npicking this:\n  (D x', v) \\<in> I\n  v \\<in> sources_aux I D (sources_aux I D U zs) (ys' @ [x])", "have\n       \"\\<exists>v \\<in> sources_aux I D (sources_aux I D U zs) (ys' @ [x]). (D x', v) \\<in> I\""], ["proof (prove)\nusing this:\n  (D x', v) \\<in> I\n  v \\<in> sources_aux I D (sources_aux I D U zs) (ys' @ [x])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sources_aux I D (sources_aux I D U zs) (ys' @ [x]).\n       (D x', v) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<in>sources_aux I D (sources_aux I D U zs) (ys' @ [x]).\n     (D x', v) \\<in> I\n\ngoal (1 subgoal):\n 1. x' = x \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sources_aux I D (sources_aux I D U zs) (ys' @ [x]).\n     (D x', v) \\<in> I\n\ngoal (1 subgoal):\n 1. False", "using J"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sources_aux I D (sources_aux I D U zs) (ys' @ [x]).\n     (D x', v) \\<in> I\n  \\<not> (\\<exists>v\\<in>sources_aux I D (sources_aux I D U zs) (ys' @ [x]).\n             (D x', v) \\<in> I)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x' \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       ys = take (the (offset 0 x (x' # xs))) (x' # xs)", "hence \"offset 0 x (x' # xs) = offset (Suc 0) x xs\""], ["proof (prove)\nusing this:\n  x' \\<noteq> x\n\ngoal (1 subgoal):\n 1. offset 0 x (x' # xs) = offset (Suc 0) x xs", "by simp"], ["proof (state)\nthis:\n  offset 0 x (x' # xs) = offset (Suc 0) x xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       ys = take (the (offset 0 x (x' # xs))) (x' # xs)", "also"], ["proof (state)\nthis:\n  offset 0 x (x' # xs) = offset (Suc 0) x xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       ys = take (the (offset 0 x (x' # xs))) (x' # xs)", "have \"\\<dots> = Some (Suc (the (offset 0 x xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. offset (Suc 0) x xs = Some (Suc (the (offset 0 x xs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. offset (Suc 0) x xs = Some (Suc (the (offset 0 x xs)))", "have \"\\<exists>ys zs. xs = ys @ x # zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ys zs. xs = ys @ x # zs", "using E"], ["proof (prove)\nusing this:\n  xs = ys' @ x # zs\n\ngoal (1 subgoal):\n 1. \\<exists>ys zs. xs = ys @ x # zs", "by blast"], ["proof (state)\nthis:\n  \\<exists>ys zs. xs = ys @ x # zs\n\ngoal (1 subgoal):\n 1. offset (Suc 0) x xs = Some (Suc (the (offset 0 x xs)))", "hence \"offset 0 x xs \\<noteq> None\""], ["proof (prove)\nusing this:\n  \\<exists>ys zs. xs = ys @ x # zs\n\ngoal (1 subgoal):\n 1. offset 0 x xs \\<noteq> None", "by (simp only: offset_not_none)"], ["proof (state)\nthis:\n  offset 0 x xs \\<noteq> None\n\ngoal (1 subgoal):\n 1. offset (Suc 0) x xs = Some (Suc (the (offset 0 x xs)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  offset 0 x xs \\<noteq> None\n\ngoal (1 subgoal):\n 1. offset (Suc 0) x xs = Some (Suc (the (offset 0 x xs)))", "by (rule offset_suc)"], ["proof (state)\nthis:\n  offset (Suc 0) x xs = Some (Suc (the (offset 0 x xs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  offset (Suc 0) x xs = Some (Suc (the (offset 0 x xs)))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       ys = take (the (offset 0 x (x' # xs))) (x' # xs)", "finally"], ["proof (chain)\npicking this:\n  offset 0 x (x' # xs) = Some (Suc (the (offset 0 x xs)))", "have \"take (the (offset 0 x (x' # xs))) (x' # xs) =\n      x' # take (the (offset 0 x xs)) xs\""], ["proof (prove)\nusing this:\n  offset 0 x (x' # xs) = Some (Suc (the (offset 0 x xs)))\n\ngoal (1 subgoal):\n 1. take (the (offset 0 x (x' # xs))) (x' # xs) =\n    x' # take (the (offset 0 x xs)) xs", "by simp"], ["proof (state)\nthis:\n  take (the (offset 0 x (x' # xs))) (x' # xs) =\n  x' # take (the (offset 0 x xs)) xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       ys = take (the (offset 0 x (x' # xs))) (x' # xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  take (the (offset 0 x (x' # xs))) (x' # xs) =\n  x' # take (the (offset 0 x xs)) xs\n\ngoal (1 subgoal):\n 1. ys = take (the (offset 0 x (x' # xs))) (x' # xs)", "using Cons and H and I"], ["proof (prove)\nusing this:\n  take (the (offset 0 x (x' # xs))) (x' # xs) =\n  x' # take (the (offset 0 x xs)) xs\n  ys = y # ys'\n  ys' = take (the (offset 0 x xs)) xs\n  x' = y\n\ngoal (1 subgoal):\n 1. ys = take (the (offset 0 x (x' # xs))) (x' # xs)", "by simp"], ["proof (state)\nthis:\n  ys = take (the (offset 0 x (x' # xs))) (x' # xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ys = take (the (offset 0 x (x' # xs))) (x' # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_tr_rev_aux_append_nil_2 [rule_format]:\n \"ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D V xs \\<longrightarrow>\n  ipurge_tr_rev_aux I D U ys = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys) =\n    ipurge_tr_rev_aux I D V xs \\<longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []", "proof (induction xs, simp, simp only: append_Cons, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>ipurge_tr_rev_aux I D U (xs @ ys) =\n                ipurge_tr_rev_aux I D V xs \\<longrightarrow>\n                ipurge_tr_rev_aux I D U ys = [];\n        ipurge_tr_rev_aux I D U (a # xs @ ys) =\n        ipurge_tr_rev_aux I D V (a # xs)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U ys = []", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>ipurge_tr_rev_aux I D U (xs @ ys) =\n                ipurge_tr_rev_aux I D V xs \\<longrightarrow>\n                ipurge_tr_rev_aux I D U ys = [];\n        ipurge_tr_rev_aux I D U (a # xs @ ys) =\n        ipurge_tr_rev_aux I D V (a # xs)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U ys = []", "assume\n    A: \"ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D V xs \\<longrightarrow>\n      ipurge_tr_rev_aux I D U ys = []\" and\n    B: \"ipurge_tr_rev_aux I D U (x # xs @ ys) = ipurge_tr_rev_aux I D V (x # xs)\""], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ys) =\n  ipurge_tr_rev_aux I D V xs \\<longrightarrow>\n  ipurge_tr_rev_aux I D U ys = []\n  ipurge_tr_rev_aux I D U (x # xs @ ys) = ipurge_tr_rev_aux I D V (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>ipurge_tr_rev_aux I D U (xs @ ys) =\n                ipurge_tr_rev_aux I D V xs \\<longrightarrow>\n                ipurge_tr_rev_aux I D U ys = [];\n        ipurge_tr_rev_aux I D U (a # xs @ ys) =\n        ipurge_tr_rev_aux I D V (a # xs)\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U ys = []", "show \"ipurge_tr_rev_aux I D U ys = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U ys = []", "proof (cases \"\\<exists>v \\<in> sources_aux I D V xs. (D x, v) \\<in> I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sources_aux I D V xs. (D x, v) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []\n 2. \\<not> (\\<exists>v\\<in>sources_aux I D V xs.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []", "case True"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sources_aux I D V xs. (D x, v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sources_aux I D V xs. (D x, v) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []\n 2. \\<not> (\\<exists>v\\<in>sources_aux I D V xs.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []", "hence C: \"ipurge_tr_rev_aux I D U (x # xs @ ys) =\n      x # ipurge_tr_rev_aux I D V xs\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sources_aux I D V xs. (D x, v) \\<in> I\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (x # xs @ ys) = x # ipurge_tr_rev_aux I D V xs", "using B"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sources_aux I D V xs. (D x, v) \\<in> I\n  ipurge_tr_rev_aux I D U (x # xs @ ys) = ipurge_tr_rev_aux I D V (x # xs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (x # xs @ ys) = x # ipurge_tr_rev_aux I D V xs", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (x # xs @ ys) = x # ipurge_tr_rev_aux I D V xs\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sources_aux I D V xs. (D x, v) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []\n 2. \\<not> (\\<exists>v\\<in>sources_aux I D V xs.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []", "hence \"\\<exists>vs ws. x # xs @ ys = vs @ x # ws \\<and>\n      ipurge_tr_rev_aux I D (sources_aux I D U (x # ws)) vs = [] \\<and>\n      (\\<exists>v \\<in> sources_aux I D U ws. (D x, v) \\<in> I)\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (x # xs @ ys) = x # ipurge_tr_rev_aux I D V xs\n\ngoal (1 subgoal):\n 1. \\<exists>vs ws.\n       x # xs @ ys = vs @ x # ws \\<and>\n       ipurge_tr_rev_aux I D (sources_aux I D U (x # ws)) vs = [] \\<and>\n       (\\<exists>v\\<in>sources_aux I D U ws. (D x, v) \\<in> I)", "by (rule ipurge_tr_rev_aux_first)"], ["proof (state)\nthis:\n  \\<exists>vs ws.\n     x # xs @ ys = vs @ x # ws \\<and>\n     ipurge_tr_rev_aux I D (sources_aux I D U (x # ws)) vs = [] \\<and>\n     (\\<exists>v\\<in>sources_aux I D U ws. (D x, v) \\<in> I)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sources_aux I D V xs. (D x, v) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []\n 2. \\<not> (\\<exists>v\\<in>sources_aux I D V xs.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []", "then"], ["proof (chain)\npicking this:\n  \\<exists>vs ws.\n     x # xs @ ys = vs @ x # ws \\<and>\n     ipurge_tr_rev_aux I D (sources_aux I D U (x # ws)) vs = [] \\<and>\n     (\\<exists>v\\<in>sources_aux I D U ws. (D x, v) \\<in> I)", "obtain vs and ws where *: \"x # xs @ ys = vs @ x # ws \\<and>\n      ipurge_tr_rev_aux I D (sources_aux I D U (x # ws)) vs = [] \\<and>\n      (\\<exists>v \\<in> sources_aux I D U ws. (D x, v) \\<in> I)\""], ["proof (prove)\nusing this:\n  \\<exists>vs ws.\n     x # xs @ ys = vs @ x # ws \\<and>\n     ipurge_tr_rev_aux I D (sources_aux I D U (x # ws)) vs = [] \\<and>\n     (\\<exists>v\\<in>sources_aux I D U ws. (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. (\\<And>vs ws.\n        x # xs @ ys = vs @ x # ws \\<and>\n        ipurge_tr_rev_aux I D (sources_aux I D U (x # ws)) vs = [] \\<and>\n        (\\<exists>v\\<in>sources_aux I D U ws.\n            (D x, v) \\<in> I) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x # xs @ ys = vs @ x # ws \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # ws)) vs = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D U ws. (D x, v) \\<in> I)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sources_aux I D V xs. (D x, v) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []\n 2. \\<not> (\\<exists>v\\<in>sources_aux I D V xs.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []", "then"], ["proof (chain)\npicking this:\n  x # xs @ ys = vs @ x # ws \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # ws)) vs = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D U ws. (D x, v) \\<in> I)", "have \"vs = take (the (offset 0 x (x # xs @ ys))) (x # xs @ ys)\""], ["proof (prove)\nusing this:\n  x # xs @ ys = vs @ x # ws \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # ws)) vs = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D U ws. (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. vs = take (the (offset 0 x (x # xs @ ys))) (x # xs @ ys)", "by (rule ipurge_tr_rev_aux_first_offset)"], ["proof (state)\nthis:\n  vs = take (the (offset 0 x (x # xs @ ys))) (x # xs @ ys)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sources_aux I D V xs. (D x, v) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []\n 2. \\<not> (\\<exists>v\\<in>sources_aux I D V xs.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []", "hence \"vs = []\""], ["proof (prove)\nusing this:\n  vs = take (the (offset 0 x (x # xs @ ys))) (x # xs @ ys)\n\ngoal (1 subgoal):\n 1. vs = []", "by simp"], ["proof (state)\nthis:\n  vs = []\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sources_aux I D V xs. (D x, v) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []\n 2. \\<not> (\\<exists>v\\<in>sources_aux I D V xs.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []", "with *"], ["proof (chain)\npicking this:\n  x # xs @ ys = vs @ x # ws \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # ws)) vs = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D U ws. (D x, v) \\<in> I)\n  vs = []", "have \"\\<exists>v \\<in> sources_aux I D U (xs @ ys). (D x, v) \\<in> I\""], ["proof (prove)\nusing this:\n  x # xs @ ys = vs @ x # ws \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D U (x # ws)) vs = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D U ws. (D x, v) \\<in> I)\n  vs = []\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sources_aux I D U (xs @ ys). (D x, v) \\<in> I", "by simp"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sources_aux I D U (xs @ ys). (D x, v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sources_aux I D V xs. (D x, v) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []\n 2. \\<not> (\\<exists>v\\<in>sources_aux I D V xs.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []", "hence \"ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D V xs\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sources_aux I D U (xs @ ys). (D x, v) \\<in> I\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D V xs", "using C"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sources_aux I D U (xs @ ys). (D x, v) \\<in> I\n  ipurge_tr_rev_aux I D U (x # xs @ ys) = x # ipurge_tr_rev_aux I D V xs\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D V xs", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D V xs\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sources_aux I D V xs. (D x, v) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []\n 2. \\<not> (\\<exists>v\\<in>sources_aux I D V xs.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []", "with A"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_aux I D U (xs @ ys) =\n  ipurge_tr_rev_aux I D V xs \\<longrightarrow>\n  ipurge_tr_rev_aux I D U ys = []\n  ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D V xs", "show ?thesis"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (xs @ ys) =\n  ipurge_tr_rev_aux I D V xs \\<longrightarrow>\n  ipurge_tr_rev_aux I D U ys = []\n  ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D V xs\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U ys = []", ".."], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U ys = []\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sources_aux I D V xs.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sources_aux I D V xs.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sources_aux I D V xs. (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sources_aux I D V xs.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []", "moreover"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sources_aux I D V xs. (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sources_aux I D V xs.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []", "have \"\\<not> (\\<exists>v \\<in> sources_aux I D U (xs @ ys). (D x, v) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sources_aux I D U (xs @ ys). (D x, v) \\<in> I)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sources_aux I D U (xs @ ys).\n       (D x, v) \\<in> I \\<Longrightarrow>\n    False", "assume \"\\<exists>v \\<in> sources_aux I D U (xs @ ys). (D x, v) \\<in> I\""], ["proof (state)\nthis:\n  \\<exists>v\\<in>sources_aux I D U (xs @ ys). (D x, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sources_aux I D U (xs @ ys).\n       (D x, v) \\<in> I \\<Longrightarrow>\n    False", "hence \"ipurge_tr_rev_aux I D V (x # xs) =\n        x # ipurge_tr_rev_aux I D U (xs @ ys)\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sources_aux I D U (xs @ ys). (D x, v) \\<in> I\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D V (x # xs) = x # ipurge_tr_rev_aux I D U (xs @ ys)", "using B"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sources_aux I D U (xs @ ys). (D x, v) \\<in> I\n  ipurge_tr_rev_aux I D U (x # xs @ ys) = ipurge_tr_rev_aux I D V (x # xs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D V (x # xs) = x # ipurge_tr_rev_aux I D U (xs @ ys)", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D V (x # xs) = x # ipurge_tr_rev_aux I D U (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sources_aux I D U (xs @ ys).\n       (D x, v) \\<in> I \\<Longrightarrow>\n    False", "hence \"\\<exists>vs ws. x # xs = vs @ x # ws \\<and>\n        ipurge_tr_rev_aux I D (sources_aux I D V (x # ws)) vs = [] \\<and>\n        (\\<exists>v \\<in> sources_aux I D V ws. (D x, v) \\<in> I)\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D V (x # xs) = x # ipurge_tr_rev_aux I D U (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<exists>vs ws.\n       x # xs = vs @ x # ws \\<and>\n       ipurge_tr_rev_aux I D (sources_aux I D V (x # ws)) vs = [] \\<and>\n       (\\<exists>v\\<in>sources_aux I D V ws. (D x, v) \\<in> I)", "by (rule ipurge_tr_rev_aux_first)"], ["proof (state)\nthis:\n  \\<exists>vs ws.\n     x # xs = vs @ x # ws \\<and>\n     ipurge_tr_rev_aux I D (sources_aux I D V (x # ws)) vs = [] \\<and>\n     (\\<exists>v\\<in>sources_aux I D V ws. (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sources_aux I D U (xs @ ys).\n       (D x, v) \\<in> I \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>vs ws.\n     x # xs = vs @ x # ws \\<and>\n     ipurge_tr_rev_aux I D (sources_aux I D V (x # ws)) vs = [] \\<and>\n     (\\<exists>v\\<in>sources_aux I D V ws. (D x, v) \\<in> I)", "obtain vs and ws where *: \"x # xs = vs @ x # ws \\<and>\n        ipurge_tr_rev_aux I D (sources_aux I D V (x # ws)) vs = [] \\<and>\n        (\\<exists>v \\<in> sources_aux I D V ws. (D x, v) \\<in> I)\""], ["proof (prove)\nusing this:\n  \\<exists>vs ws.\n     x # xs = vs @ x # ws \\<and>\n     ipurge_tr_rev_aux I D (sources_aux I D V (x # ws)) vs = [] \\<and>\n     (\\<exists>v\\<in>sources_aux I D V ws. (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. (\\<And>vs ws.\n        x # xs = vs @ x # ws \\<and>\n        ipurge_tr_rev_aux I D (sources_aux I D V (x # ws)) vs = [] \\<and>\n        (\\<exists>v\\<in>sources_aux I D V ws.\n            (D x, v) \\<in> I) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x # xs = vs @ x # ws \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D V (x # ws)) vs = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D V ws. (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sources_aux I D U (xs @ ys).\n       (D x, v) \\<in> I \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  x # xs = vs @ x # ws \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D V (x # ws)) vs = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D V ws. (D x, v) \\<in> I)", "have \"vs = take (the (offset 0 x (x # xs))) (x # xs)\""], ["proof (prove)\nusing this:\n  x # xs = vs @ x # ws \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D V (x # ws)) vs = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D V ws. (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. vs = take (the (offset 0 x (x # xs))) (x # xs)", "by (rule ipurge_tr_rev_aux_first_offset)"], ["proof (state)\nthis:\n  vs = take (the (offset 0 x (x # xs))) (x # xs)\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sources_aux I D U (xs @ ys).\n       (D x, v) \\<in> I \\<Longrightarrow>\n    False", "hence \"vs = []\""], ["proof (prove)\nusing this:\n  vs = take (the (offset 0 x (x # xs))) (x # xs)\n\ngoal (1 subgoal):\n 1. vs = []", "by simp"], ["proof (state)\nthis:\n  vs = []\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sources_aux I D U (xs @ ys).\n       (D x, v) \\<in> I \\<Longrightarrow>\n    False", "with *"], ["proof (chain)\npicking this:\n  x # xs = vs @ x # ws \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D V (x # ws)) vs = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D V ws. (D x, v) \\<in> I)\n  vs = []", "have \"\\<exists>v \\<in> sources_aux I D V xs. (D x, v) \\<in> I\""], ["proof (prove)\nusing this:\n  x # xs = vs @ x # ws \\<and>\n  ipurge_tr_rev_aux I D (sources_aux I D V (x # ws)) vs = [] \\<and>\n  (\\<exists>v\\<in>sources_aux I D V ws. (D x, v) \\<in> I)\n  vs = []\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sources_aux I D V xs. (D x, v) \\<in> I", "by simp"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sources_aux I D V xs. (D x, v) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sources_aux I D U (xs @ ys).\n       (D x, v) \\<in> I \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sources_aux I D V xs. (D x, v) \\<in> I\n\ngoal (1 subgoal):\n 1. False", "using False"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sources_aux I D V xs. (D x, v) \\<in> I\n  \\<not> (\\<exists>v\\<in>sources_aux I D V xs. (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sources_aux I D U (xs @ ys). (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sources_aux I D V xs.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>v\\<in>sources_aux I D V xs. (D x, v) \\<in> I)\n  \\<not> (\\<exists>v\\<in>sources_aux I D U (xs @ ys). (D x, v) \\<in> I)", "have \"ipurge_tr_rev_aux I D U (xs @ ys) =\n      ipurge_tr_rev_aux I D V xs\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sources_aux I D V xs. (D x, v) \\<in> I)\n  \\<not> (\\<exists>v\\<in>sources_aux I D U (xs @ ys). (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D V xs", "using B"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sources_aux I D V xs. (D x, v) \\<in> I)\n  \\<not> (\\<exists>v\\<in>sources_aux I D U (xs @ ys). (D x, v) \\<in> I)\n  ipurge_tr_rev_aux I D U (x # xs @ ys) = ipurge_tr_rev_aux I D V (x # xs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D V xs", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D V xs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sources_aux I D V xs.\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U ys = []", "with A"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_aux I D U (xs @ ys) =\n  ipurge_tr_rev_aux I D V xs \\<longrightarrow>\n  ipurge_tr_rev_aux I D U ys = []\n  ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D V xs", "show ?thesis"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (xs @ ys) =\n  ipurge_tr_rev_aux I D V xs \\<longrightarrow>\n  ipurge_tr_rev_aux I D U ys = []\n  ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D V xs\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U ys = []", ".."], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U ys = []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U ys = []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_tr_rev_aux_append_nil:\n \"(ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs) =\n  (ipurge_tr_rev_aux I D U ys = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs) =\n    (ipurge_tr_rev_aux I D U ys = [])", "by (rule iffI, erule ipurge_tr_rev_aux_append_nil_2, rule ipurge_tr_rev_aux_append_nil_1)"], ["", "text \\<open>\n\\null\n\nIn what follows, it is proven by induction that the lists output by functions @{term ipurge_tr} and\n@{term ipurge_tr_rev}, as well as those output by @{term ipurge_tr_aux} and\n@{term ipurge_tr_rev_aux}, satisfy predicate @{term Interleaves} (cf. \\cite{R2}), in correspondence\nwith suitable input predicates expressed in terms of functions @{term sinks} and @{term sinks_aux},\nrespectively. Then, some lemmas on the aforesaid functions are demonstrated without induction, using\nprevious lemmas along with the properties of predicate @{term Interleaves}.\n\n\\null\n\\<close>"], ["", "lemma Interleaves_ipurge_tr:\n \"xs \\<cong> {ipurge_tr_rev I D u xs, rev (ipurge_tr (I\\<inverse>) D u (rev xs)),\n    \\<lambda>y ys. D y \\<in> sinks (I\\<inverse>) D u (rev (y # ys))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<cong> {ipurge_tr_rev I D u\n                 xs, rev (ipurge_tr (I\\<inverse>) D u\n                           (rev xs)), \\<lambda>y ys.\n   D y \\<in> sinks (I\\<inverse>) D u (rev (y # ys))}", "proof (induction xs, simp, simp only: rev.simps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       xs \\<cong> {ipurge_tr_rev I D u\n                    xs, rev (ipurge_tr (I\\<inverse>) D u\n                              (rev xs)), \\<lambda>y ys.\n      D y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])} \\<Longrightarrow>\n       a #\n       xs \\<cong> {ipurge_tr_rev I D u\n                    (a #\n                     xs), rev (ipurge_tr (I\\<inverse>) D u\n                                (rev xs @\n                                 [a])), \\<lambda>y ys.\n     D y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])}", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       xs \\<cong> {ipurge_tr_rev I D u\n                    xs, rev (ipurge_tr (I\\<inverse>) D u\n                              (rev xs)), \\<lambda>y ys.\n      D y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])} \\<Longrightarrow>\n       a #\n       xs \\<cong> {ipurge_tr_rev I D u\n                    (a #\n                     xs), rev (ipurge_tr (I\\<inverse>) D u\n                                (rev xs @\n                                 [a])), \\<lambda>y ys.\n     D y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])}", "assume A: \"xs \\<cong> {ipurge_tr_rev I D u xs, rev (ipurge_tr (I\\<inverse>) D u (rev xs)),\n    \\<lambda>y ys. D y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])}\"\n    (is \"_ \\<cong> {?ys, ?zs, ?P}\")"], ["proof (state)\nthis:\n  xs \\<cong> {ipurge_tr_rev I D u\n               xs, rev (ipurge_tr (I\\<inverse>) D u\n                         (rev xs)), \\<lambda>y ys.\n D y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])}\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       xs \\<cong> {ipurge_tr_rev I D u\n                    xs, rev (ipurge_tr (I\\<inverse>) D u\n                              (rev xs)), \\<lambda>y ys.\n      D y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])} \\<Longrightarrow>\n       a #\n       xs \\<cong> {ipurge_tr_rev I D u\n                    (a #\n                     xs), rev (ipurge_tr (I\\<inverse>) D u\n                                (rev xs @\n                                 [a])), \\<lambda>y ys.\n     D y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])}", "show \"x # xs \\<cong>\n    {ipurge_tr_rev I D u (x # xs), rev (ipurge_tr (I\\<inverse>) D u (rev xs @ [x])), ?P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x #\n    xs \\<cong> {ipurge_tr_rev I D u\n                 (x #\n                  xs), rev (ipurge_tr (I\\<inverse>) D u\n                             (rev xs @\n                              [x])), \\<lambda>y ys.\n  D y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])}", "proof (cases \"?P x xs\", simp_all add: sources_sinks del: sinks.simps)"], ["proof (state)\ngoal (2 subgoals):\n 1. D x \\<in> sinks (I\\<inverse>) D u (rev xs @ [x]) \\<Longrightarrow>\n    x #\n    xs \\<cong> {x #\n                ipurge_tr_rev I D u\n                 xs, rev (ipurge_tr (I\\<inverse>) D u\n                           (rev xs)), \\<lambda>y ys.\n   D y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])}\n 2. D x \\<notin> sinks (I\\<inverse>) D u (rev xs @ [x]) \\<Longrightarrow>\n    x #\n    xs \\<cong> {ipurge_tr_rev I D u\n                 xs, x #\n                     rev (ipurge_tr (I\\<inverse>) D u\n                           (rev xs)), \\<lambda>y ys.\n   D y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])}", "case True"], ["proof (state)\nthis:\n  D x \\<in> sinks (I\\<inverse>) D u (rev xs @ [x])\n\ngoal (2 subgoals):\n 1. D x \\<in> sinks (I\\<inverse>) D u (rev xs @ [x]) \\<Longrightarrow>\n    x #\n    xs \\<cong> {x #\n                ipurge_tr_rev I D u\n                 xs, rev (ipurge_tr (I\\<inverse>) D u\n                           (rev xs)), \\<lambda>y ys.\n   D y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])}\n 2. D x \\<notin> sinks (I\\<inverse>) D u (rev xs @ [x]) \\<Longrightarrow>\n    x #\n    xs \\<cong> {ipurge_tr_rev I D u\n                 xs, x #\n                     rev (ipurge_tr (I\\<inverse>) D u\n                           (rev xs)), \\<lambda>y ys.\n   D y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])}", "thus \"x # xs \\<cong> {x # ?ys, ?zs, ?P}\""], ["proof (prove)\nusing this:\n  D x \\<in> sinks (I\\<inverse>) D u (rev xs @ [x])\n\ngoal (1 subgoal):\n 1. x #\n    xs \\<cong> {x #\n                ipurge_tr_rev I D u\n                 xs, rev (ipurge_tr (I\\<inverse>) D u\n                           (rev xs)), \\<lambda>y ys.\n   D y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])}", "using A"], ["proof (prove)\nusing this:\n  D x \\<in> sinks (I\\<inverse>) D u (rev xs @ [x])\n  xs \\<cong> {ipurge_tr_rev I D u\n               xs, rev (ipurge_tr (I\\<inverse>) D u\n                         (rev xs)), \\<lambda>y ys.\n D y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])}\n\ngoal (1 subgoal):\n 1. x #\n    xs \\<cong> {x #\n                ipurge_tr_rev I D u\n                 xs, rev (ipurge_tr (I\\<inverse>) D u\n                           (rev xs)), \\<lambda>y ys.\n   D y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])}", "by (cases ?zs, simp_all)"], ["proof (state)\nthis:\n  x #\n  xs \\<cong> {x #\n              ipurge_tr_rev I D u\n               xs, rev (ipurge_tr (I\\<inverse>) D u\n                         (rev xs)), \\<lambda>y ys.\n D y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])}\n\ngoal (1 subgoal):\n 1. D x \\<notin> sinks (I\\<inverse>) D u (rev xs @ [x]) \\<Longrightarrow>\n    x #\n    xs \\<cong> {ipurge_tr_rev I D u\n                 xs, x #\n                     rev (ipurge_tr (I\\<inverse>) D u\n                           (rev xs)), \\<lambda>y ys.\n   D y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. D x \\<notin> sinks (I\\<inverse>) D u (rev xs @ [x]) \\<Longrightarrow>\n    x #\n    xs \\<cong> {ipurge_tr_rev I D u\n                 xs, x #\n                     rev (ipurge_tr (I\\<inverse>) D u\n                           (rev xs)), \\<lambda>y ys.\n   D y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])}", "case False"], ["proof (state)\nthis:\n  D x \\<notin> sinks (I\\<inverse>) D u (rev xs @ [x])\n\ngoal (1 subgoal):\n 1. D x \\<notin> sinks (I\\<inverse>) D u (rev xs @ [x]) \\<Longrightarrow>\n    x #\n    xs \\<cong> {ipurge_tr_rev I D u\n                 xs, x #\n                     rev (ipurge_tr (I\\<inverse>) D u\n                           (rev xs)), \\<lambda>y ys.\n   D y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])}", "thus \"x # xs \\<cong> {?ys, x # ?zs, ?P}\""], ["proof (prove)\nusing this:\n  D x \\<notin> sinks (I\\<inverse>) D u (rev xs @ [x])\n\ngoal (1 subgoal):\n 1. x #\n    xs \\<cong> {ipurge_tr_rev I D u\n                 xs, x #\n                     rev (ipurge_tr (I\\<inverse>) D u\n                           (rev xs)), \\<lambda>y ys.\n   D y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])}", "using A"], ["proof (prove)\nusing this:\n  D x \\<notin> sinks (I\\<inverse>) D u (rev xs @ [x])\n  xs \\<cong> {ipurge_tr_rev I D u\n               xs, rev (ipurge_tr (I\\<inverse>) D u\n                         (rev xs)), \\<lambda>y ys.\n D y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])}\n\ngoal (1 subgoal):\n 1. x #\n    xs \\<cong> {ipurge_tr_rev I D u\n                 xs, x #\n                     rev (ipurge_tr (I\\<inverse>) D u\n                           (rev xs)), \\<lambda>y ys.\n   D y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])}", "by (cases ?ys, simp_all)"], ["proof (state)\nthis:\n  x #\n  xs \\<cong> {ipurge_tr_rev I D u\n               xs, x #\n                   rev (ipurge_tr (I\\<inverse>) D u\n                         (rev xs)), \\<lambda>y ys.\n D y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x #\n  xs \\<cong> {ipurge_tr_rev I D u\n               (x #\n                xs), rev (ipurge_tr (I\\<inverse>) D u\n                           (rev xs @\n                            [x])), \\<lambda>y ys.\nD y \\<in> sinks (I\\<inverse>) D u (rev ys @ [y])}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Interleaves_ipurge_tr_aux:\n \"xs \\<cong> {ipurge_tr_rev_aux I D U xs, rev (ipurge_tr_aux (I\\<inverse>) D U (rev xs)),\n    \\<lambda>y ys. \\<exists>v \\<in> sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<cong> {ipurge_tr_rev_aux I D U\n                 xs, rev (ipurge_tr_aux (I\\<inverse>) D U\n                           (rev xs)), \\<lambda>y ys.\n   \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}", "proof (induction xs, simp, simp only: rev.simps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       xs \\<cong> {ipurge_tr_rev_aux I D U\n                    xs, rev (ipurge_tr_aux (I\\<inverse>) D U\n                              (rev xs)), \\<lambda>y ys.\n      \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys).\n         (D y, v) \\<in> I} \\<Longrightarrow>\n       a #\n       xs \\<cong> {ipurge_tr_rev_aux I D U\n                    (a #\n                     xs), rev (ipurge_tr_aux (I\\<inverse>) D U\n                                (rev xs @\n                                 [a])), \\<lambda>y ys.\n     \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}", "fix x xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       xs \\<cong> {ipurge_tr_rev_aux I D U\n                    xs, rev (ipurge_tr_aux (I\\<inverse>) D U\n                              (rev xs)), \\<lambda>y ys.\n      \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys).\n         (D y, v) \\<in> I} \\<Longrightarrow>\n       a #\n       xs \\<cong> {ipurge_tr_rev_aux I D U\n                    (a #\n                     xs), rev (ipurge_tr_aux (I\\<inverse>) D U\n                                (rev xs @\n                                 [a])), \\<lambda>y ys.\n     \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}", "assume A: \"xs \\<cong> {ipurge_tr_rev_aux I D U xs,\n    rev (ipurge_tr_aux (I\\<inverse>) D U (rev xs)),\n    \\<lambda>y ys. \\<exists>v \\<in> sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}\"\n    (is \"_ \\<cong> {?ys, ?zs, ?P}\")"], ["proof (state)\nthis:\n  xs \\<cong> {ipurge_tr_rev_aux I D U\n               xs, rev (ipurge_tr_aux (I\\<inverse>) D U\n                         (rev xs)), \\<lambda>y ys.\n \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       xs \\<cong> {ipurge_tr_rev_aux I D U\n                    xs, rev (ipurge_tr_aux (I\\<inverse>) D U\n                              (rev xs)), \\<lambda>y ys.\n      \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys).\n         (D y, v) \\<in> I} \\<Longrightarrow>\n       a #\n       xs \\<cong> {ipurge_tr_rev_aux I D U\n                    (a #\n                     xs), rev (ipurge_tr_aux (I\\<inverse>) D U\n                                (rev xs @\n                                 [a])), \\<lambda>y ys.\n     \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}", "show \"x # xs \\<cong>\n    {ipurge_tr_rev_aux I D U (x # xs),\n    rev (ipurge_tr_aux (I\\<inverse>) D U (rev xs @ [x])), ?P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x #\n    xs \\<cong> {ipurge_tr_rev_aux I D U\n                 (x #\n                  xs), rev (ipurge_tr_aux (I\\<inverse>) D U\n                             (rev xs @\n                              [x])), \\<lambda>y ys.\n  \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}", "proof (cases \"?P x xs\", simp_all (no_asm_simp) add: sources_sinks_aux)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev xs).\n       (D x, v) \\<in> I \\<Longrightarrow>\n    x #\n    xs \\<cong> {x #\n                ipurge_tr_rev_aux I D U\n                 xs, rev (ipurge_tr_aux (I\\<inverse>) D U\n                           (rev xs)), \\<lambda>y ys.\n   \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}\n 2. \\<not> (\\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev xs).\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    x #\n    xs \\<cong> {ipurge_tr_rev_aux I D U\n                 xs, x #\n                     rev (ipurge_tr_aux (I\\<inverse>) D U\n                           (rev xs)), \\<lambda>y ys.\n   \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}", "case True"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev xs). (D x, v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev xs).\n       (D x, v) \\<in> I \\<Longrightarrow>\n    x #\n    xs \\<cong> {x #\n                ipurge_tr_rev_aux I D U\n                 xs, rev (ipurge_tr_aux (I\\<inverse>) D U\n                           (rev xs)), \\<lambda>y ys.\n   \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}\n 2. \\<not> (\\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev xs).\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    x #\n    xs \\<cong> {ipurge_tr_rev_aux I D U\n                 xs, x #\n                     rev (ipurge_tr_aux (I\\<inverse>) D U\n                           (rev xs)), \\<lambda>y ys.\n   \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}", "thus \"x # xs \\<cong> {x # ?ys, ?zs, ?P}\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev xs). (D x, v) \\<in> I\n\ngoal (1 subgoal):\n 1. x #\n    xs \\<cong> {x #\n                ipurge_tr_rev_aux I D U\n                 xs, rev (ipurge_tr_aux (I\\<inverse>) D U\n                           (rev xs)), \\<lambda>y ys.\n   \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}", "using A"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev xs). (D x, v) \\<in> I\n  xs \\<cong> {ipurge_tr_rev_aux I D U\n               xs, rev (ipurge_tr_aux (I\\<inverse>) D U\n                         (rev xs)), \\<lambda>y ys.\n \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}\n\ngoal (1 subgoal):\n 1. x #\n    xs \\<cong> {x #\n                ipurge_tr_rev_aux I D U\n                 xs, rev (ipurge_tr_aux (I\\<inverse>) D U\n                           (rev xs)), \\<lambda>y ys.\n   \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}", "by (cases ?zs, simp_all)"], ["proof (state)\nthis:\n  x #\n  xs \\<cong> {x #\n              ipurge_tr_rev_aux I D U\n               xs, rev (ipurge_tr_aux (I\\<inverse>) D U\n                         (rev xs)), \\<lambda>y ys.\n \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev xs).\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    x #\n    xs \\<cong> {ipurge_tr_rev_aux I D U\n                 xs, x #\n                     rev (ipurge_tr_aux (I\\<inverse>) D U\n                           (rev xs)), \\<lambda>y ys.\n   \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev xs).\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    x #\n    xs \\<cong> {ipurge_tr_rev_aux I D U\n                 xs, x #\n                     rev (ipurge_tr_aux (I\\<inverse>) D U\n                           (rev xs)), \\<lambda>y ys.\n   \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev xs).\n             (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev xs).\n               (D x, v) \\<in> I) \\<Longrightarrow>\n    x #\n    xs \\<cong> {ipurge_tr_rev_aux I D U\n                 xs, x #\n                     rev (ipurge_tr_aux (I\\<inverse>) D U\n                           (rev xs)), \\<lambda>y ys.\n   \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}", "thus \"x # xs \\<cong> {?ys, x # ?zs, ?P}\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev xs).\n             (D x, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. x #\n    xs \\<cong> {ipurge_tr_rev_aux I D U\n                 xs, x #\n                     rev (ipurge_tr_aux (I\\<inverse>) D U\n                           (rev xs)), \\<lambda>y ys.\n   \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}", "using A"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev xs).\n             (D x, v) \\<in> I)\n  xs \\<cong> {ipurge_tr_rev_aux I D U\n               xs, rev (ipurge_tr_aux (I\\<inverse>) D U\n                         (rev xs)), \\<lambda>y ys.\n \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}\n\ngoal (1 subgoal):\n 1. x #\n    xs \\<cong> {ipurge_tr_rev_aux I D U\n                 xs, x #\n                     rev (ipurge_tr_aux (I\\<inverse>) D U\n                           (rev xs)), \\<lambda>y ys.\n   \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}", "by (cases ?ys, simp_all)"], ["proof (state)\nthis:\n  x #\n  xs \\<cong> {ipurge_tr_rev_aux I D U\n               xs, x #\n                   rev (ipurge_tr_aux (I\\<inverse>) D U\n                         (rev xs)), \\<lambda>y ys.\n \\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x #\n  xs \\<cong> {ipurge_tr_rev_aux I D U\n               (x #\n                xs), rev (ipurge_tr_aux (I\\<inverse>) D U\n                           (rev xs @\n                            [x])), \\<lambda>y ys.\n\\<exists>v\\<in>sinks_aux (I\\<inverse>) D U (rev ys). (D y, v) \\<in> I}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_tr_aux_all:\n \"(ipurge_tr_aux I D U xs = xs) = (\\<forall>u \\<in> U. \\<not> (\\<exists>v \\<in> D ` set xs. (u, v) \\<in> I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipurge_tr_aux I D U xs = xs) =\n    (\\<forall>u\\<in>U. \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (ipurge_tr_aux I D U xs = xs) =\n    (\\<forall>u\\<in>U. \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I))", "have A: \"rev xs \\<cong> {ipurge_tr_rev_aux (I\\<inverse>) D U (rev xs),\n    rev (ipurge_tr_aux ((I\\<inverse>)\\<inverse>) D U (rev (rev xs))),\n    \\<lambda>y ys. \\<exists>v \\<in> sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ys). (D y, v) \\<in> (I\\<inverse>)}\"\n    (is \"_ \\<cong> {_, _, ?P}\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. rev xs \\<cong> {ipurge_tr_rev_aux (I\\<inverse>) D U\n                     (rev xs), rev (ipurge_tr_aux ((I\\<inverse>)\\<inverse>)\n                                     D U\n                                     (rev\n (rev xs))), \\<lambda>y ys.\n                \\<exists>v\\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U\n                                (rev ys).\n                   (D y, v) \\<in> I\\<inverse>}", "by (rule Interleaves_ipurge_tr_aux)"], ["proof (state)\nthis:\n  rev xs \\<cong> {ipurge_tr_rev_aux (I\\<inverse>) D U\n                   (rev xs), rev (ipurge_tr_aux ((I\\<inverse>)\\<inverse>) D\n                                   U (rev\n (rev xs))), \\<lambda>y ys.\n                \\<exists>v\\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U\n                                (rev ys).\n                   (D y, v) \\<in> I\\<inverse>}\n\ngoal (1 subgoal):\n 1. (ipurge_tr_aux I D U xs = xs) =\n    (\\<forall>u\\<in>U. \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipurge_tr_aux I D U xs = xs) =\n    (\\<forall>u\\<in>U. \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ipurge_tr_aux I D U xs = xs \\<Longrightarrow>\n    \\<forall>u\\<in>U. \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I)\n 2. \\<forall>u\\<in>U.\n       \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D U xs = xs", "assume \"ipurge_tr_aux I D U xs = xs\""], ["proof (state)\nthis:\n  ipurge_tr_aux I D U xs = xs\n\ngoal (2 subgoals):\n 1. ipurge_tr_aux I D U xs = xs \\<Longrightarrow>\n    \\<forall>u\\<in>U. \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I)\n 2. \\<forall>u\\<in>U.\n       \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D U xs = xs", "hence \"rev xs \\<cong> {ipurge_tr_rev_aux (I\\<inverse>) D U (rev xs), rev xs, ?P}\""], ["proof (prove)\nusing this:\n  ipurge_tr_aux I D U xs = xs\n\ngoal (1 subgoal):\n 1. rev xs \\<cong> {ipurge_tr_rev_aux (I\\<inverse>) D U\n                     (rev xs), rev xs, \\<lambda>y ys.\n    \\<exists>v\\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ys).\n       (D y, v) \\<in> I\\<inverse>}", "using A"], ["proof (prove)\nusing this:\n  ipurge_tr_aux I D U xs = xs\n  rev xs \\<cong> {ipurge_tr_rev_aux (I\\<inverse>) D U\n                   (rev xs), rev (ipurge_tr_aux ((I\\<inverse>)\\<inverse>) D\n                                   U (rev\n (rev xs))), \\<lambda>y ys.\n                \\<exists>v\\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U\n                                (rev ys).\n                   (D y, v) \\<in> I\\<inverse>}\n\ngoal (1 subgoal):\n 1. rev xs \\<cong> {ipurge_tr_rev_aux (I\\<inverse>) D U\n                     (rev xs), rev xs, \\<lambda>y ys.\n    \\<exists>v\\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ys).\n       (D y, v) \\<in> I\\<inverse>}", "by simp"], ["proof (state)\nthis:\n  rev xs \\<cong> {ipurge_tr_rev_aux (I\\<inverse>) D U\n                   (rev xs), rev xs, \\<lambda>y ys.\n  \\<exists>v\\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ys).\n     (D y, v) \\<in> I\\<inverse>}\n\ngoal (2 subgoals):\n 1. ipurge_tr_aux I D U xs = xs \\<Longrightarrow>\n    \\<forall>u\\<in>U. \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I)\n 2. \\<forall>u\\<in>U.\n       \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D U xs = xs", "hence \"rev xs \\<simeq> {ipurge_tr_rev_aux (I\\<inverse>) D U (rev xs), rev xs, ?P}\""], ["proof (prove)\nusing this:\n  rev xs \\<cong> {ipurge_tr_rev_aux (I\\<inverse>) D U\n                   (rev xs), rev xs, \\<lambda>y ys.\n  \\<exists>v\\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ys).\n     (D y, v) \\<in> I\\<inverse>}\n\ngoal (1 subgoal):\n 1. rev xs \\<simeq> {ipurge_tr_rev_aux (I\\<inverse>) D U\n                      (rev xs), rev xs, \\<lambda>y ys.\n     \\<exists>v\\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ys).\n        (D y, v) \\<in> I\\<inverse>}", "by (rule Interleaves_interleaves)"], ["proof (state)\nthis:\n  rev xs \\<simeq> {ipurge_tr_rev_aux (I\\<inverse>) D U\n                    (rev xs), rev xs, \\<lambda>y ys.\n   \\<exists>v\\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ys).\n      (D y, v) \\<in> I\\<inverse>}\n\ngoal (2 subgoals):\n 1. ipurge_tr_aux I D U xs = xs \\<Longrightarrow>\n    \\<forall>u\\<in>U. \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I)\n 2. \\<forall>u\\<in>U.\n       \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D U xs = xs", "moreover"], ["proof (state)\nthis:\n  rev xs \\<simeq> {ipurge_tr_rev_aux (I\\<inverse>) D U\n                    (rev xs), rev xs, \\<lambda>y ys.\n   \\<exists>v\\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ys).\n      (D y, v) \\<in> I\\<inverse>}\n\ngoal (2 subgoals):\n 1. ipurge_tr_aux I D U xs = xs \\<Longrightarrow>\n    \\<forall>u\\<in>U. \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I)\n 2. \\<forall>u\\<in>U.\n       \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D U xs = xs", "have \"rev xs \\<simeq> {[], rev xs, ?P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev xs \\<simeq> {[], rev xs, \\<lambda>y ys.\n                                    \\<exists>v\n       \\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ys).\n (D y, v) \\<in> I\\<inverse>}", "by (rule interleaves_nil_all)"], ["proof (state)\nthis:\n  rev xs \\<simeq> {[], rev xs, \\<lambda>y ys.\n                                  \\<exists>v\n     \\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ys).\n                                     (D y, v) \\<in> I\\<inverse>}\n\ngoal (2 subgoals):\n 1. ipurge_tr_aux I D U xs = xs \\<Longrightarrow>\n    \\<forall>u\\<in>U. \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I)\n 2. \\<forall>u\\<in>U.\n       \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D U xs = xs", "ultimately"], ["proof (chain)\npicking this:\n  rev xs \\<simeq> {ipurge_tr_rev_aux (I\\<inverse>) D U\n                    (rev xs), rev xs, \\<lambda>y ys.\n   \\<exists>v\\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ys).\n      (D y, v) \\<in> I\\<inverse>}\n  rev xs \\<simeq> {[], rev xs, \\<lambda>y ys.\n                                  \\<exists>v\n     \\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ys).\n                                     (D y, v) \\<in> I\\<inverse>}", "have \"ipurge_tr_rev_aux (I\\<inverse>) D U (rev xs) = []\""], ["proof (prove)\nusing this:\n  rev xs \\<simeq> {ipurge_tr_rev_aux (I\\<inverse>) D U\n                    (rev xs), rev xs, \\<lambda>y ys.\n   \\<exists>v\\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ys).\n      (D y, v) \\<in> I\\<inverse>}\n  rev xs \\<simeq> {[], rev xs, \\<lambda>y ys.\n                                  \\<exists>v\n     \\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ys).\n                                     (D y, v) \\<in> I\\<inverse>}\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux (I\\<inverse>) D U (rev xs) = []", "by (rule interleaves_equal_fst)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux (I\\<inverse>) D U (rev xs) = []\n\ngoal (2 subgoals):\n 1. ipurge_tr_aux I D U xs = xs \\<Longrightarrow>\n    \\<forall>u\\<in>U. \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I)\n 2. \\<forall>u\\<in>U.\n       \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D U xs = xs", "thus \"\\<forall>u \\<in> U. \\<not> (\\<exists>v \\<in> D ` set xs. (u, v) \\<in> I)\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux (I\\<inverse>) D U (rev xs) = []\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U. \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I)", "by (simp add: ipurge_tr_rev_aux_nil)"], ["proof (state)\nthis:\n  \\<forall>u\\<in>U. \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U.\n       \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D U xs = xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U.\n       \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D U xs = xs", "assume \"\\<forall>u \\<in> U. \\<not> (\\<exists>v \\<in> D ` set xs. (u, v) \\<in> I)\""], ["proof (state)\nthis:\n  \\<forall>u\\<in>U. \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U.\n       \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D U xs = xs", "hence \"ipurge_tr_rev_aux (I\\<inverse>) D U (rev xs) = []\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>U. \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux (I\\<inverse>) D U (rev xs) = []", "by (simp add: ipurge_tr_rev_aux_nil)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux (I\\<inverse>) D U (rev xs) = []\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U.\n       \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D U xs = xs", "hence \"rev xs \\<cong> {[], rev (ipurge_tr_aux I D U xs), ?P}\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux (I\\<inverse>) D U (rev xs) = []\n\ngoal (1 subgoal):\n 1. rev xs \\<cong> {[], rev (ipurge_tr_aux I D U\n                              xs), \\<lambda>y ys.\n\\<exists>v\\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ys).\n   (D y, v) \\<in> I\\<inverse>}", "using A"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux (I\\<inverse>) D U (rev xs) = []\n  rev xs \\<cong> {ipurge_tr_rev_aux (I\\<inverse>) D U\n                   (rev xs), rev (ipurge_tr_aux ((I\\<inverse>)\\<inverse>) D\n                                   U (rev\n (rev xs))), \\<lambda>y ys.\n                \\<exists>v\\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U\n                                (rev ys).\n                   (D y, v) \\<in> I\\<inverse>}\n\ngoal (1 subgoal):\n 1. rev xs \\<cong> {[], rev (ipurge_tr_aux I D U\n                              xs), \\<lambda>y ys.\n\\<exists>v\\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ys).\n   (D y, v) \\<in> I\\<inverse>}", "by simp"], ["proof (state)\nthis:\n  rev xs \\<cong> {[], rev (ipurge_tr_aux I D U\n                            xs), \\<lambda>y ys.\n                                    \\<exists>v\n       \\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ys).\n (D y, v) \\<in> I\\<inverse>}\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U.\n       \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D U xs = xs", "hence \"rev xs \\<simeq> {[], rev (ipurge_tr_aux I D U xs), ?P}\""], ["proof (prove)\nusing this:\n  rev xs \\<cong> {[], rev (ipurge_tr_aux I D U\n                            xs), \\<lambda>y ys.\n                                    \\<exists>v\n       \\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ys).\n (D y, v) \\<in> I\\<inverse>}\n\ngoal (1 subgoal):\n 1. rev xs \\<simeq> {[], rev (ipurge_tr_aux I D U\n                               xs), \\<lambda>y ys.\n \\<exists>v\\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ys).\n    (D y, v) \\<in> I\\<inverse>}", "by (rule Interleaves_interleaves)"], ["proof (state)\nthis:\n  rev xs \\<simeq> {[], rev (ipurge_tr_aux I D U\n                             xs), \\<lambda>y ys.\n                                     \\<exists>v\n        \\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ys).\n  (D y, v) \\<in> I\\<inverse>}\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U.\n       \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D U xs = xs", "hence \"rev xs \\<simeq> {rev (ipurge_tr_aux I D U xs), [], \\<lambda>w ws. \\<not> ?P w ws}\""], ["proof (prove)\nusing this:\n  rev xs \\<simeq> {[], rev (ipurge_tr_aux I D U\n                             xs), \\<lambda>y ys.\n                                     \\<exists>v\n        \\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ys).\n  (D y, v) \\<in> I\\<inverse>}\n\ngoal (1 subgoal):\n 1. rev xs \\<simeq> {rev (ipurge_tr_aux I D U\n                           xs), [], \\<lambda>w ws.\n \\<not> (\\<exists>v\\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ws).\n            (D w, v) \\<in> I\\<inverse>)}", "by (subst (asm) interleaves_swap)"], ["proof (state)\nthis:\n  rev xs \\<simeq> {rev (ipurge_tr_aux I D U\n                         xs), [], \\<lambda>w ws.\n                                     \\<not> (\\<exists>v\n                \\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ws).\n          (D w, v) \\<in> I\\<inverse>)}\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U.\n       \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D U xs = xs", "moreover"], ["proof (state)\nthis:\n  rev xs \\<simeq> {rev (ipurge_tr_aux I D U\n                         xs), [], \\<lambda>w ws.\n                                     \\<not> (\\<exists>v\n                \\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ws).\n          (D w, v) \\<in> I\\<inverse>)}\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U.\n       \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D U xs = xs", "have \"rev xs \\<simeq> {rev xs, [], \\<lambda>w ws. \\<not> ?P w ws}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rev xs \\<simeq> {rev xs, [], \\<lambda>w ws.\n                                    \\<not> (\\<exists>v\n               \\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ws).\n         (D w, v) \\<in> I\\<inverse>)}", "by (rule interleaves_all_nil)"], ["proof (state)\nthis:\n  rev xs \\<simeq> {rev xs, [], \\<lambda>w ws.\n                                  \\<not> (\\<exists>v\n             \\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ws).\n       (D w, v) \\<in> I\\<inverse>)}\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U.\n       \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D U xs = xs", "ultimately"], ["proof (chain)\npicking this:\n  rev xs \\<simeq> {rev (ipurge_tr_aux I D U\n                         xs), [], \\<lambda>w ws.\n                                     \\<not> (\\<exists>v\n                \\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ws).\n          (D w, v) \\<in> I\\<inverse>)}\n  rev xs \\<simeq> {rev xs, [], \\<lambda>w ws.\n                                  \\<not> (\\<exists>v\n             \\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ws).\n       (D w, v) \\<in> I\\<inverse>)}", "have \"rev (ipurge_tr_aux I D U xs) = rev xs\""], ["proof (prove)\nusing this:\n  rev xs \\<simeq> {rev (ipurge_tr_aux I D U\n                         xs), [], \\<lambda>w ws.\n                                     \\<not> (\\<exists>v\n                \\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ws).\n          (D w, v) \\<in> I\\<inverse>)}\n  rev xs \\<simeq> {rev xs, [], \\<lambda>w ws.\n                                  \\<not> (\\<exists>v\n             \\<in>sinks_aux ((I\\<inverse>)\\<inverse>) D U (rev ws).\n       (D w, v) \\<in> I\\<inverse>)}\n\ngoal (1 subgoal):\n 1. rev (ipurge_tr_aux I D U xs) = rev xs", "by (rule interleaves_equal_fst)"], ["proof (state)\nthis:\n  rev (ipurge_tr_aux I D U xs) = rev xs\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U.\n       \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_aux I D U xs = xs", "thus \"ipurge_tr_aux I D U xs = xs\""], ["proof (prove)\nusing this:\n  rev (ipurge_tr_aux I D U xs) = rev xs\n\ngoal (1 subgoal):\n 1. ipurge_tr_aux I D U xs = xs", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_aux I D U xs = xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (ipurge_tr_aux I D U xs = xs) =\n  (\\<forall>u\\<in>U. \\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_tr_rev_aux_single_dom:\n \"ipurge_tr_rev_aux I D {u} xs = ipurge_tr_rev I D u xs\" (is \"?ys = ?ys'\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D {u} xs = ipurge_tr_rev I D u xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D {u} xs = ipurge_tr_rev I D u xs", "have \"xs \\<cong> {?ys, rev (ipurge_tr_aux (I\\<inverse>) D {u} (rev xs)),\n    \\<lambda>y ys. \\<exists>v \\<in> sinks_aux (I\\<inverse>) D {u} (rev ys). (D y, v) \\<in> I}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<cong> {ipurge_tr_rev_aux I D {u}\n                 xs, rev (ipurge_tr_aux (I\\<inverse>) D {u}\n                           (rev xs)), \\<lambda>y ys.\n   \\<exists>v\\<in>sinks_aux (I\\<inverse>) D {u} (rev ys). (D y, v) \\<in> I}", "by (rule Interleaves_ipurge_tr_aux)"], ["proof (state)\nthis:\n  xs \\<cong> {ipurge_tr_rev_aux I D {u}\n               xs, rev (ipurge_tr_aux (I\\<inverse>) D {u}\n                         (rev xs)), \\<lambda>y ys.\n \\<exists>v\\<in>sinks_aux (I\\<inverse>) D {u} (rev ys). (D y, v) \\<in> I}\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D {u} xs = ipurge_tr_rev I D u xs", "hence \"xs \\<cong> {?ys, rev (ipurge_tr (I\\<inverse>) D u (rev xs)),\n    \\<lambda>y ys. (u, D y) \\<in> I\\<inverse> \\<or> (\\<exists>v \\<in> sinks (I\\<inverse>) D u (rev ys). (v, D y) \\<in> I\\<inverse>)}\""], ["proof (prove)\nusing this:\n  xs \\<cong> {ipurge_tr_rev_aux I D {u}\n               xs, rev (ipurge_tr_aux (I\\<inverse>) D {u}\n                         (rev xs)), \\<lambda>y ys.\n \\<exists>v\\<in>sinks_aux (I\\<inverse>) D {u} (rev ys). (D y, v) \\<in> I}\n\ngoal (1 subgoal):\n 1. xs \\<cong> {ipurge_tr_rev_aux I D {u}\n                 xs, rev (ipurge_tr (I\\<inverse>) D u\n                           (rev xs)), \\<lambda>y ys.\n   (u, D y) \\<in> I\\<inverse> \\<or>\n   (\\<exists>v\\<in>sinks (I\\<inverse>) D u (rev ys).\n       (v, D y) \\<in> I\\<inverse>)}", "by (simp add: ipurge_tr_aux_single_dom sinks_aux_single_dom)"], ["proof (state)\nthis:\n  xs \\<cong> {ipurge_tr_rev_aux I D {u}\n               xs, rev (ipurge_tr (I\\<inverse>) D u\n                         (rev xs)), \\<lambda>y ys.\n (u, D y) \\<in> I\\<inverse> \\<or>\n (\\<exists>v\\<in>sinks (I\\<inverse>) D u (rev ys).\n     (v, D y) \\<in> I\\<inverse>)}\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D {u} xs = ipurge_tr_rev I D u xs", "hence \"xs \\<cong> {?ys, rev (ipurge_tr (I\\<inverse>) D u (rev xs)),\n    \\<lambda>y ys. D y \\<in> sinks (I\\<inverse>) D u (rev (y # ys))}\"\n    (is \"_ \\<cong> {_, ?zs, ?P}\")"], ["proof (prove)\nusing this:\n  xs \\<cong> {ipurge_tr_rev_aux I D {u}\n               xs, rev (ipurge_tr (I\\<inverse>) D u\n                         (rev xs)), \\<lambda>y ys.\n (u, D y) \\<in> I\\<inverse> \\<or>\n (\\<exists>v\\<in>sinks (I\\<inverse>) D u (rev ys).\n     (v, D y) \\<in> I\\<inverse>)}\n\ngoal (1 subgoal):\n 1. xs \\<cong> {ipurge_tr_rev_aux I D {u}\n                 xs, rev (ipurge_tr (I\\<inverse>) D u\n                           (rev xs)), \\<lambda>y ys.\n   D y \\<in> sinks (I\\<inverse>) D u (rev (y # ys))}", "by (simp only: sinks_interference_eq, simp)"], ["proof (state)\nthis:\n  xs \\<cong> {ipurge_tr_rev_aux I D {u}\n               xs, rev (ipurge_tr (I\\<inverse>) D u\n                         (rev xs)), \\<lambda>y ys.\n D y \\<in> sinks (I\\<inverse>) D u (rev (y # ys))}\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D {u} xs = ipurge_tr_rev I D u xs", "moreover"], ["proof (state)\nthis:\n  xs \\<cong> {ipurge_tr_rev_aux I D {u}\n               xs, rev (ipurge_tr (I\\<inverse>) D u\n                         (rev xs)), \\<lambda>y ys.\n D y \\<in> sinks (I\\<inverse>) D u (rev (y # ys))}\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D {u} xs = ipurge_tr_rev I D u xs", "have \"xs \\<cong> {?ys', ?zs, ?P}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<cong> {ipurge_tr_rev I D u\n                 xs, rev (ipurge_tr (I\\<inverse>) D u\n                           (rev xs)), \\<lambda>y ys.\n   D y \\<in> sinks (I\\<inverse>) D u (rev (y # ys))}", "by (rule Interleaves_ipurge_tr)"], ["proof (state)\nthis:\n  xs \\<cong> {ipurge_tr_rev I D u\n               xs, rev (ipurge_tr (I\\<inverse>) D u\n                         (rev xs)), \\<lambda>y ys.\n D y \\<in> sinks (I\\<inverse>) D u (rev (y # ys))}\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D {u} xs = ipurge_tr_rev I D u xs", "ultimately"], ["proof (chain)\npicking this:\n  xs \\<cong> {ipurge_tr_rev_aux I D {u}\n               xs, rev (ipurge_tr (I\\<inverse>) D u\n                         (rev xs)), \\<lambda>y ys.\n D y \\<in> sinks (I\\<inverse>) D u (rev (y # ys))}\n  xs \\<cong> {ipurge_tr_rev I D u\n               xs, rev (ipurge_tr (I\\<inverse>) D u\n                         (rev xs)), \\<lambda>y ys.\n D y \\<in> sinks (I\\<inverse>) D u (rev (y # ys))}", "show ?thesis"], ["proof (prove)\nusing this:\n  xs \\<cong> {ipurge_tr_rev_aux I D {u}\n               xs, rev (ipurge_tr (I\\<inverse>) D u\n                         (rev xs)), \\<lambda>y ys.\n D y \\<in> sinks (I\\<inverse>) D u (rev (y # ys))}\n  xs \\<cong> {ipurge_tr_rev I D u\n               xs, rev (ipurge_tr (I\\<inverse>) D u\n                         (rev xs)), \\<lambda>y ys.\n D y \\<in> sinks (I\\<inverse>) D u (rev (y # ys))}\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D {u} xs = ipurge_tr_rev I D u xs", "by (rule Interleaves_equal_fst)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D {u} xs = ipurge_tr_rev I D u xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_tr_all:\n \"(ipurge_tr I D u xs = xs) = (\\<not> (\\<exists>v \\<in> D ` set xs. (u, v) \\<in> I))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ipurge_tr I D u xs = xs) =\n    (\\<not> (\\<exists>v\\<in>D ` set xs. (u, v) \\<in> I))", "by (subst ipurge_tr_aux_single_dom [symmetric], simp add: ipurge_tr_aux_all)"], ["", "lemma ipurge_tr_rev_all:\n \"\\<forall>v \\<in> D ` set xs. (v, u) \\<in> I \\<Longrightarrow> ipurge_tr_rev I D u xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>D ` set xs. (v, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev I D u xs = xs", "proof (subst ipurge_tr_rev_aux_single_dom [symmetric], rule ipurge_tr_rev_aux_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>\\<forall>v\\<in>D ` set xs. (v, u) \\<in> I;\n        v \\<in> D ` set xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<in>{u}. (v, u) \\<in> I", "qed (simp (no_asm_simp))"], ["", "subsection \"A domain-relation map based on intransitive purge\""], ["", "text \\<open>\nIn what follows, constant \\<open>rel_ipurge\\<close> is defined as the domain-relation map that associates\neach domain \\<open>u\\<close> to the relation comprised of the pairs of traces whose images under function\n@{term \"ipurge_tr_rev I D u\"} are equal, viz. whose events affecting \\<open>u\\<close> are the same.\n\nAn auxiliary domain set-relation map, \\<open>rel_ipurge_aux\\<close>, is also defined by replacing\n@{term ipurge_tr_rev} with @{term ipurge_tr_rev_aux}, so as to exploit the distributivity of the\nlatter function over list concatenation. Unsurprisingly, since @{term ipurge_tr_rev_aux} degenerates\ninto @{term ipurge_tr_rev} for a singleton set of domains, the same happens for\n\\<open>rel_ipurge_aux\\<close> and \\<open>rel_ipurge\\<close>.\n\nSubsequently, some basic properties of domain-relation map \\<open>rel_ipurge\\<close> are proven, namely\nthat it is a view partition, and is future consistent if and only if it is weakly future consistent.\nThe nontrivial implication, viz. the direct one, derives from the fact that for each domain\n\\<open>u\\<close> allowed to be affected by any event domain, function @{term \"ipurge_tr_rev I D u\"} matches\nthe identity function, so that two traces are correlated by the image of \\<open>rel_ipurge\\<close> under\n\\<open>u\\<close> just in case they are equal.\n\n\\null\n\\<close>"], ["", "definition rel_ipurge ::\n \"'a process \\<Rightarrow> ('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> ('a, 'd) dom_rel_map\" where\n\"rel_ipurge P I D u \\<equiv> {(xs, ys). xs \\<in> traces P \\<and> ys \\<in> traces P \\<and>\n  ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys}\""], ["", "definition rel_ipurge_aux ::\n \"'a process \\<Rightarrow> ('d \\<times> 'd) set \\<Rightarrow> ('a \\<Rightarrow> 'd) \\<Rightarrow> ('a, 'd) domset_rel_map\" where\n\"rel_ipurge_aux P I D U \\<equiv> {(xs, ys). xs \\<in> traces P \\<and> ys \\<in> traces P \\<and>\n  ipurge_tr_rev_aux I D U xs = ipurge_tr_rev_aux I D U ys}\""], ["", "lemma rel_ipurge_aux_single_dom:\n \"rel_ipurge_aux P I D {u} = rel_ipurge P I D u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_ipurge_aux P I D {u} = rel_ipurge P I D u", "by (simp add: rel_ipurge_def rel_ipurge_aux_def ipurge_tr_rev_aux_single_dom)"], ["", "lemma view_partition_rel_ipurge:\n \"view_partition P D (rel_ipurge P I D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. view_partition P D (rel_ipurge P I D)", "proof (subst view_partition_def, rule ballI, rule equivI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u.\n       u \\<in> range D \\<Longrightarrow>\n       refl_on (traces P) (rel_ipurge P I D u)\n 2. \\<And>u. u \\<in> range D \\<Longrightarrow> sym (rel_ipurge P I D u)\n 3. \\<And>u. u \\<in> range D \\<Longrightarrow> trans (rel_ipurge P I D u)", "fix u"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u.\n       u \\<in> range D \\<Longrightarrow>\n       refl_on (traces P) (rel_ipurge P I D u)\n 2. \\<And>u. u \\<in> range D \\<Longrightarrow> sym (rel_ipurge P I D u)\n 3. \\<And>u. u \\<in> range D \\<Longrightarrow> trans (rel_ipurge P I D u)", "show \"refl_on (traces P) (rel_ipurge P I D u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refl_on (traces P) (rel_ipurge P I D u)", "proof (rule refl_onI, simp_all add: rel_ipurge_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. {(xs, ys).\n     xs \\<in> traces P \\<and>\n     ys \\<in> traces P \\<and>\n     ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys}\n    \\<subseteq> traces P \\<times> traces P", "qed (rule subsetI, simp add: split_paired_all)"], ["proof (state)\nthis:\n  refl_on (traces P) (rel_ipurge P I D u)\n\ngoal (2 subgoals):\n 1. \\<And>u. u \\<in> range D \\<Longrightarrow> sym (rel_ipurge P I D u)\n 2. \\<And>u. u \\<in> range D \\<Longrightarrow> trans (rel_ipurge P I D u)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u. u \\<in> range D \\<Longrightarrow> sym (rel_ipurge P I D u)\n 2. \\<And>u. u \\<in> range D \\<Longrightarrow> trans (rel_ipurge P I D u)", "fix u"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u. u \\<in> range D \\<Longrightarrow> sym (rel_ipurge P I D u)\n 2. \\<And>u. u \\<in> range D \\<Longrightarrow> trans (rel_ipurge P I D u)", "show \"sym (rel_ipurge P I D u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym (rel_ipurge P I D u)", "by (rule symI, simp add: rel_ipurge_def)"], ["proof (state)\nthis:\n  sym (rel_ipurge P I D u)\n\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> range D \\<Longrightarrow> trans (rel_ipurge P I D u)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> range D \\<Longrightarrow> trans (rel_ipurge P I D u)", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> range D \\<Longrightarrow> trans (rel_ipurge P I D u)", "show \"trans (rel_ipurge P I D u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans (rel_ipurge P I D u)", "by (rule transI, simp add: rel_ipurge_def)"], ["proof (state)\nthis:\n  trans (rel_ipurge P I D u)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fc_equals_wfc_rel_ipurge:\n \"future_consistent P D (rel_ipurge P I D) =\n  weakly_future_consistent P I D (rel_ipurge P I D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. future_consistent P D (rel_ipurge P I D) =\n    weakly_future_consistent P I D (rel_ipurge P I D)", "proof (rule iffI, erule fc_implies_wfc,\n simp only: future_consistent_def weakly_future_consistent_def,\n rule ballI, (rule allI)+, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>\\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                   \\<forall>xs ys.\n                      (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n                      next_dom_events P D u xs =\n                      next_dom_events P D u ys \\<and>\n                      ref_dom_events P D u xs = ref_dom_events P D u ys;\n        u \\<in> range D; (xs, ys) \\<in> rel_ipurge P I D u\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs =\n                         next_dom_events P D u ys \\<and>\n                         ref_dom_events P D u xs = ref_dom_events P D u ys", "fix u xs ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>\\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                   \\<forall>xs ys.\n                      (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n                      next_dom_events P D u xs =\n                      next_dom_events P D u ys \\<and>\n                      ref_dom_events P D u xs = ref_dom_events P D u ys;\n        u \\<in> range D; (xs, ys) \\<in> rel_ipurge P I D u\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs =\n                         next_dom_events P D u ys \\<and>\n                         ref_dom_events P D u xs = ref_dom_events P D u ys", "assume\n    A: \"\\<forall>u \\<in> range D \\<inter> (-I) `` range D. \\<forall>xs ys. (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n      next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n      ref_dom_events P D u xs = ref_dom_events P D u ys\" and\n    B: \"u \\<in> range D\" and\n    C: \"(xs, ys) \\<in> rel_ipurge P I D u\""], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n        ref_dom_events P D u xs = ref_dom_events P D u ys\n  u \\<in> range D\n  (xs, ys) \\<in> rel_ipurge P I D u\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys.\n       \\<lbrakk>\\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n                   \\<forall>xs ys.\n                      (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n                      next_dom_events P D u xs =\n                      next_dom_events P D u ys \\<and>\n                      ref_dom_events P D u xs = ref_dom_events P D u ys;\n        u \\<in> range D; (xs, ys) \\<in> rel_ipurge P I D u\\<rbrakk>\n       \\<Longrightarrow> next_dom_events P D u xs =\n                         next_dom_events P D u ys \\<and>\n                         ref_dom_events P D u xs = ref_dom_events P D u ys", "show \"next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys", "proof (cases \"u \\<in> range D \\<inter> (-I) `` range D\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> range D \\<inter> (- I) `` range D \\<Longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys\n 2. u \\<notin> range D \\<inter> (- I) `` range D \\<Longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys", "case True"], ["proof (state)\nthis:\n  u \\<in> range D \\<inter> (- I) `` range D\n\ngoal (2 subgoals):\n 1. u \\<in> range D \\<inter> (- I) `` range D \\<Longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys\n 2. u \\<notin> range D \\<inter> (- I) `` range D \\<Longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys", "with A"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n        ref_dom_events P D u xs = ref_dom_events P D u ys\n  u \\<in> range D \\<inter> (- I) `` range D", "have \"\\<forall>xs ys. (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n      next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n      ref_dom_events P D u xs = ref_dom_events P D u ys\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n        ref_dom_events P D u xs = ref_dom_events P D u ys\n  u \\<in> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. \\<forall>xs ys.\n       (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n       next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n       ref_dom_events P D u xs = ref_dom_events P D u ys", ".."], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n     next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n     ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (2 subgoals):\n 1. u \\<in> range D \\<inter> (- I) `` range D \\<Longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys\n 2. u \\<notin> range D \\<inter> (- I) `` range D \\<Longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys", "hence \"(xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n      next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n      ref_dom_events P D u xs = ref_dom_events P D u ys\""], ["proof (prove)\nusing this:\n  \\<forall>xs ys.\n     (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n     next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n     ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys", "by blast"], ["proof (state)\nthis:\n  (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n  next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n  ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (2 subgoals):\n 1. u \\<in> range D \\<inter> (- I) `` range D \\<Longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys\n 2. u \\<notin> range D \\<inter> (- I) `` range D \\<Longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys", "thus ?thesis"], ["proof (prove)\nusing this:\n  (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n  next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n  ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys", "using C"], ["proof (prove)\nusing this:\n  (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n  next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n  ref_dom_events P D u xs = ref_dom_events P D u ys\n  (xs, ys) \\<in> rel_ipurge P I D u\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys", ".."], ["proof (state)\nthis:\n  next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n  ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. u \\<notin> range D \\<inter> (- I) `` range D \\<Longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<notin> range D \\<inter> (- I) `` range D \\<Longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys", "case False"], ["proof (state)\nthis:\n  u \\<notin> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. u \\<notin> range D \\<inter> (- I) `` range D \\<Longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys", "hence D: \"u \\<notin> (-I) `` range D\""], ["proof (prove)\nusing this:\n  u \\<notin> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. u \\<notin> (- I) `` range D", "using B"], ["proof (prove)\nusing this:\n  u \\<notin> range D \\<inter> (- I) `` range D\n  u \\<in> range D\n\ngoal (1 subgoal):\n 1. u \\<notin> (- I) `` range D", "by simp"], ["proof (state)\nthis:\n  u \\<notin> (- I) `` range D\n\ngoal (1 subgoal):\n 1. u \\<notin> range D \\<inter> (- I) `` range D \\<Longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys", "have \"ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys", "using C"], ["proof (prove)\nusing this:\n  (xs, ys) \\<in> rel_ipurge P I D u\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys", "by (simp add: rel_ipurge_def)"], ["proof (state)\nthis:\n  ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\n\ngoal (1 subgoal):\n 1. u \\<notin> range D \\<inter> (- I) `` range D \\<Longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\n\ngoal (1 subgoal):\n 1. u \\<notin> range D \\<inter> (- I) `` range D \\<Longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys", "have \"\\<forall>zs. ipurge_tr_rev I D u zs = zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>zs. ipurge_tr_rev I D u zs = zs", "proof (rule allI, rule ipurge_tr_rev_all, rule ballI, erule imageE, rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>zs v x.\n       \\<lbrakk>v = D x; x \\<in> set zs; (v, u) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> False", "fix v x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>zs v x.\n       \\<lbrakk>v = D x; x \\<in> set zs; (v, u) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"(v, u) \\<notin> I\""], ["proof (state)\nthis:\n  (v, u) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<And>zs v x.\n       \\<lbrakk>v = D x; x \\<in> set zs; (v, u) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"(v, u) \\<in> -I\""], ["proof (prove)\nusing this:\n  (v, u) \\<notin> I\n\ngoal (1 subgoal):\n 1. (v, u) \\<in> - I", "by simp"], ["proof (state)\nthis:\n  (v, u) \\<in> - I\n\ngoal (1 subgoal):\n 1. \\<And>zs v x.\n       \\<lbrakk>v = D x; x \\<in> set zs; (v, u) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (v, u) \\<in> - I\n\ngoal (1 subgoal):\n 1. \\<And>zs v x.\n       \\<lbrakk>v = D x; x \\<in> set zs; (v, u) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"v = D x\""], ["proof (state)\nthis:\n  v = D x\n\ngoal (1 subgoal):\n 1. \\<And>zs v x.\n       \\<lbrakk>v = D x; x \\<in> set zs; (v, u) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"v \\<in> range D\""], ["proof (prove)\nusing this:\n  v = D x\n\ngoal (1 subgoal):\n 1. v \\<in> range D", "by simp"], ["proof (state)\nthis:\n  v \\<in> range D\n\ngoal (1 subgoal):\n 1. \\<And>zs v x.\n       \\<lbrakk>v = D x; x \\<in> set zs; (v, u) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  (v, u) \\<in> - I\n  v \\<in> range D", "have \"u \\<in> (-I) `` range D\""], ["proof (prove)\nusing this:\n  (v, u) \\<in> - I\n  v \\<in> range D\n\ngoal (1 subgoal):\n 1. u \\<in> (- I) `` range D", ".."], ["proof (state)\nthis:\n  u \\<in> (- I) `` range D\n\ngoal (1 subgoal):\n 1. \\<And>zs v x.\n       \\<lbrakk>v = D x; x \\<in> set zs; (v, u) \\<notin> I\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  u \\<in> (- I) `` range D\n\ngoal (1 subgoal):\n 1. False", "using D"], ["proof (prove)\nusing this:\n  u \\<in> (- I) `` range D\n  u \\<notin> (- I) `` range D\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>zs. ipurge_tr_rev I D u zs = zs\n\ngoal (1 subgoal):\n 1. u \\<notin> range D \\<inter> (- I) `` range D \\<Longrightarrow>\n    next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\n  \\<forall>zs. ipurge_tr_rev I D u zs = zs", "show ?thesis"], ["proof (prove)\nusing this:\n  ipurge_tr_rev I D u xs = ipurge_tr_rev I D u ys\n  \\<forall>zs. ipurge_tr_rev I D u zs = zs\n\ngoal (1 subgoal):\n 1. next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n    ref_dom_events P D u xs = ref_dom_events P D u ys", "by simp"], ["proof (state)\nthis:\n  next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n  ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  next_dom_events P D u xs = next_dom_events P D u ys \\<and>\n  ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"The Ipurge Unwinding Theorem: proof of condition sufficiency\""], ["", "text \\<open>\nThe Ipurge Unwinding Theorem, formalized in what follows as theorem \\<open>ipurge_unwinding\\<close>, states\nthat a necessary and sufficient condition for the CSP noninterference security \\cite{R1} of a\nprocess being refusals union closed is that domain-relation map @{term rel_ipurge} be weakly future\nconsistent. Notwithstanding the equivalence of future consistency and weak future consistency for\n@{term rel_ipurge} (cf. above), expressing the theorem in terms of the latter reduces the range of\nthe domains to be considered in order to prove or disprove the security of a process, and then is\nmore convenient.\n\nAccording to the definition of CSP noninterference security formulated in \\cite{R1}, a process is\nregarded as being secure just in case the occurrence of an event \\emph{e} may only affect future\nevents allowed to be affected by \\emph{e}. Identifying security with the weak future consistency of\n@{term rel_ipurge} means reversing the view of the problem with respect to the direction of time. In\nfact, from this view, a process is secure just in case the occurrence of an event \\emph{e} may only\nbe affected by past events allowed to affect \\emph{e}. Therefore, what the Ipurge Unwinding Theorem\nproves is that ultimately, opposite perspectives with regard to the direction of time give rise to\nequivalent definitions of the noninterference security of a process.\n\nHere below, it is proven that the condition expressed by the Ipurge Unwinding Theorem is sufficient\nfor security.\n\n\\null\n\\<close>"], ["", "lemma ipurge_tr_rev_ipurge_tr_aux_1 [rule_format]:\n \"U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "proof (induction zs arbitrary: U rule: rev_induct, rule_tac [!] impI, simp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>U.\n       U \\<subseteq> unaffected_domains I D (D ` set ys)\n                      [] \\<Longrightarrow>\n       ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs\n 2. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "fix U"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>U.\n       U \\<subseteq> unaffected_domains I D (D ` set ys)\n                      [] \\<Longrightarrow>\n       ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs\n 2. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "assume A: \"U \\<subseteq> unaffected_domains I D (D ` set ys) []\""], ["proof (state)\nthis:\n  U \\<subseteq> unaffected_domains I D (D ` set ys) []\n\ngoal (2 subgoals):\n 1. \\<And>U.\n       U \\<subseteq> unaffected_domains I D (D ` set ys)\n                      [] \\<Longrightarrow>\n       ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs\n 2. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "have \"\\<forall>u \\<in> U. \\<forall>v \\<in> D ` set ys. (v, u) \\<notin> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U. \\<forall>v\\<in>D ` set ys. (v, u) \\<notin> I", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> U \\<Longrightarrow>\n       \\<forall>v\\<in>D ` set ys. (v, u) \\<notin> I", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> U \\<Longrightarrow>\n       \\<forall>v\\<in>D ` set ys. (v, u) \\<notin> I", "assume \"u \\<in> U\""], ["proof (state)\nthis:\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> U \\<Longrightarrow>\n       \\<forall>v\\<in>D ` set ys. (v, u) \\<notin> I", "with A"], ["proof (chain)\npicking this:\n  U \\<subseteq> unaffected_domains I D (D ` set ys) []\n  u \\<in> U", "have \"u \\<in> unaffected_domains I D (D ` set ys) []\""], ["proof (prove)\nusing this:\n  U \\<subseteq> unaffected_domains I D (D ` set ys) []\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. u \\<in> unaffected_domains I D (D ` set ys) []", ".."], ["proof (state)\nthis:\n  u \\<in> unaffected_domains I D (D ` set ys) []\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> U \\<Longrightarrow>\n       \\<forall>v\\<in>D ` set ys. (v, u) \\<notin> I", "thus \"\\<forall>v \\<in> D ` set ys. (v, u) \\<notin> I\""], ["proof (prove)\nusing this:\n  u \\<in> unaffected_domains I D (D ` set ys) []\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>D ` set ys. (v, u) \\<notin> I", "by (simp add: unaffected_domains_def)"], ["proof (state)\nthis:\n  \\<forall>v\\<in>D ` set ys. (v, u) \\<notin> I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>u\\<in>U. \\<forall>v\\<in>D ` set ys. (v, u) \\<notin> I\n\ngoal (2 subgoals):\n 1. \\<And>U.\n       U \\<subseteq> unaffected_domains I D (D ` set ys)\n                      [] \\<Longrightarrow>\n       ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs\n 2. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "hence \"ipurge_tr_rev_aux I D U ys = []\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>U. \\<forall>v\\<in>D ` set ys. (v, u) \\<notin> I\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U ys = []", "by (simp add: ipurge_tr_rev_aux_nil)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U ys = []\n\ngoal (2 subgoals):\n 1. \\<And>U.\n       U \\<subseteq> unaffected_domains I D (D ` set ys)\n                      [] \\<Longrightarrow>\n       ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs\n 2. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "thus \"ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U ys = []\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs", "by (simp add: ipurge_tr_rev_aux_append_nil)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs\n\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "fix z zs U"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "let ?U' = \"insert (D z) U\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "assume\n    A: \"\\<And>U. U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n      ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n      ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\" and\n    B: \"U \\<subseteq> unaffected_domains I D (D ` set ys) (zs @ [z])\""], ["proof (state)\nthis:\n  ?U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n  ipurge_tr_rev_aux I D ?U (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D ?U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n  U \\<subseteq> unaffected_domains I D (D ` set ys) (zs @ [z])\n\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "have C: \"U \\<subseteq> unaffected_domains I D (D ` set ys) zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> unaffected_domains I D (D ` set ys) zs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> U \\<Longrightarrow>\n       x \\<in> unaffected_domains I D (D ` set ys) zs", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> U \\<Longrightarrow>\n       x \\<in> unaffected_domains I D (D ` set ys) zs", "assume \"u \\<in> U\""], ["proof (state)\nthis:\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> U \\<Longrightarrow>\n       x \\<in> unaffected_domains I D (D ` set ys) zs", "with B"], ["proof (chain)\npicking this:\n  U \\<subseteq> unaffected_domains I D (D ` set ys) (zs @ [z])\n  u \\<in> U", "have \"u \\<in> unaffected_domains I D (D ` set ys) (zs @ [z])\""], ["proof (prove)\nusing this:\n  U \\<subseteq> unaffected_domains I D (D ` set ys) (zs @ [z])\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. u \\<in> unaffected_domains I D (D ` set ys) (zs @ [z])", ".."], ["proof (state)\nthis:\n  u \\<in> unaffected_domains I D (D ` set ys) (zs @ [z])\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> U \\<Longrightarrow>\n       x \\<in> unaffected_domains I D (D ` set ys) zs", "thus \"u \\<in> unaffected_domains I D (D ` set ys) zs\""], ["proof (prove)\nusing this:\n  u \\<in> unaffected_domains I D (D ` set ys) (zs @ [z])\n\ngoal (1 subgoal):\n 1. u \\<in> unaffected_domains I D (D ` set ys) zs", "by (simp add: unaffected_domains_def)"], ["proof (state)\nthis:\n  u \\<in> unaffected_domains I D (D ` set ys) zs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U \\<subseteq> unaffected_domains I D (D ` set ys) zs\n\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "have D: \"ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "have \"U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n      ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n      ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "using A"], ["proof (prove)\nusing this:\n  ?U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n  ipurge_tr_rev_aux I D ?U (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D ?U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "."], ["proof (state)\nthis:\n  U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "using C"], ["proof (prove)\nusing this:\n  U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n  U \\<subseteq> unaffected_domains I D (D ` set ys) zs\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", ".."], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "have E: \"\\<not> (\\<exists>v \\<in> sinks_aux I D (D ` set ys) zs. (v, D z) \\<in> I) \\<longrightarrow>\n    ipurge_tr_rev_aux I D ?U' (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D ?U' (xs @ ipurge_tr_aux I D (D ` set ys) zs)\"\n    (is \"?P \\<longrightarrow> ?Q\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "assume ?P"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs. (v, D z) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "have \"?U' \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n      ipurge_tr_rev_aux I D ?U' (xs @ ys @ zs) =\n      ipurge_tr_rev_aux I D ?U' (xs @ ipurge_tr_aux I D (D ` set ys) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (D z) U\n    \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "using A"], ["proof (prove)\nusing this:\n  ?U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n  ipurge_tr_rev_aux I D ?U (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D ?U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. insert (D z) U\n    \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "."], ["proof (state)\nthis:\n  insert (D z) U\n  \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n  ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "moreover"], ["proof (state)\nthis:\n  insert (D z) U\n  \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n  ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "have \"?U' \\<subseteq> unaffected_domains I D (D ` set ys) zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (D z) U \\<subseteq> unaffected_domains I D (D ` set ys) zs", "by (simp add: C, simp add: unaffected_domains_def \\<open>?P\\<close> [simplified])"], ["proof (state)\nthis:\n  insert (D z) U \\<subseteq> unaffected_domains I D (D ` set ys) zs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "ultimately"], ["proof (chain)\npicking this:\n  insert (D z) U\n  \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n  ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n  insert (D z) U \\<subseteq> unaffected_domains I D (D ` set ys) zs", "show ?Q"], ["proof (prove)\nusing this:\n  insert (D z) U\n  \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n  ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n  insert (D z) U \\<subseteq> unaffected_domains I D (D ` set ys) zs\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ipurge_tr_aux I D (D ` set ys) zs)", ".."], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n             (v, D z) \\<in> I) \\<longrightarrow>\n  ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ ys @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ ys @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "show \"ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))", "proof (cases \"\\<exists>v \\<in> sinks_aux I D (D ` set ys) zs. (v, D z) \\<in> I\",\n   simp_all (no_asm_simp))"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n       (v, D z) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "case True"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks_aux I D (D ` set ys) zs. (v, D z) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n       (v, D z) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "have \"\\<not> (\\<exists>u \\<in> U. (D z, u) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow> False", "assume \"\\<exists>u \\<in> U. (D z, u) \\<in> I\""], ["proof (state)\nthis:\n  \\<exists>u\\<in>U. (D z, u) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>u\\<in>U. (D z, u) \\<in> I", "obtain u where F: \"u \\<in> U\" and G: \"(D z, u) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>U. (D z, u) \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> U; (D z, u) \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  u \\<in> U\n  (D z, u) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow> False", "have \"D z \\<in> sinks_aux I D (D ` set ys) (zs @ [z])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D z \\<in> sinks_aux I D (D ` set ys) (zs @ [z])", "using True"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks_aux I D (D ` set ys) zs. (v, D z) \\<in> I\n\ngoal (1 subgoal):\n 1. D z \\<in> sinks_aux I D (D ` set ys) (zs @ [z])", "by simp"], ["proof (state)\nthis:\n  D z \\<in> sinks_aux I D (D ` set ys) (zs @ [z])\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow> False", "with G"], ["proof (chain)\npicking this:\n  (D z, u) \\<in> I\n  D z \\<in> sinks_aux I D (D ` set ys) (zs @ [z])", "have \"\\<exists>v \\<in> sinks_aux I D (D ` set ys) (zs @ [z]). (v, u) \\<in> I\""], ["proof (prove)\nusing this:\n  (D z, u) \\<in> I\n  D z \\<in> sinks_aux I D (D ` set ys) (zs @ [z])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks_aux I D (D ` set ys) (zs @ [z]). (v, u) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks_aux I D (D ` set ys) (zs @ [z]). (v, u) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks_aux I D (D ` set ys) (zs @ [z]). (v, u) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow> False", "have \"u \\<in> unaffected_domains I D (D ` set ys) (zs @ [z])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> unaffected_domains I D (D ` set ys) (zs @ [z])", "using B and F"], ["proof (prove)\nusing this:\n  U \\<subseteq> unaffected_domains I D (D ` set ys) (zs @ [z])\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. u \\<in> unaffected_domains I D (D ` set ys) (zs @ [z])", ".."], ["proof (state)\nthis:\n  u \\<in> unaffected_domains I D (D ` set ys) (zs @ [z])\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow> False", "hence \"\\<not> (\\<exists>v \\<in> sinks_aux I D (D ` set ys) (zs @ [z]). (v, u) \\<in> I)\""], ["proof (prove)\nusing this:\n  u \\<in> unaffected_domains I D (D ` set ys) (zs @ [z])\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) (zs @ [z]).\n               (v, u) \\<in> I)", "by (simp add: unaffected_domains_def)"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) (zs @ [z]).\n             (v, u) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>v\\<in>sinks_aux I D (D ` set ys) (zs @ [z]). (v, u) \\<in> I\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) (zs @ [z]).\n             (v, u) \\<in> I)", "show False"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks_aux I D (D ` set ys) (zs @ [z]). (v, u) \\<in> I\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) (zs @ [z]).\n             (v, u) \\<in> I)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n       (v, D z) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "hence \"ipurge_tr_rev_aux I D U ((xs @ ys @ zs) @ [z]) =\n      ipurge_tr_rev_aux I D U (xs @ ys @ zs)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U ((xs @ ys @ zs) @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs)", "by (subst ipurge_tr_rev_aux_append, simp)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U ((xs @ ys @ zs) @ [z]) =\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n       (v, D z) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "also"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U ((xs @ ys @ zs) @ [z]) =\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n       (v, D z) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "have \"\\<dots> = ipurge_tr_rev_aux I D U\n      (xs @ ipurge_tr_aux I D (D ` set ys) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "using D"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "."], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n       (v, D z) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "finally"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_aux I D U ((xs @ ys @ zs) @ [z]) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "show \"ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n      ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U ((xs @ ys @ zs) @ [z]) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs. (v, D z) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "note F = this"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs. (v, D z) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "show \"ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n      ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "proof (cases \"\\<exists>u \\<in> U. (D z, u) \\<in> I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])\n 2. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "case True"], ["proof (state)\nthis:\n  \\<exists>u\\<in>U. (D z, u) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])\n 2. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "hence \"ipurge_tr_rev_aux I D U ((xs @ ys @ zs) @ [z]) =\n        ipurge_tr_rev_aux I D ?U' (xs @ ys @ zs) @ [z]\""], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>U. (D z, u) \\<in> I\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U ((xs @ ys @ zs) @ [z]) =\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) @ [z]", "by (subst ipurge_tr_rev_aux_append, simp)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U ((xs @ ys @ zs) @ [z]) =\n  ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) @ [z]\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])\n 2. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "also"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U ((xs @ ys @ zs) @ [z]) =\n  ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) @ [z]\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])\n 2. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "have \"\\<dots> =\n        ipurge_tr_rev_aux I D ?U' (xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) @ [z] =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n    [z]", "using E and F"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n             (v, D z) \\<in> I) \\<longrightarrow>\n  ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs. (v, D z) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) @ [z] =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n    [z]", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) @ [z] =\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n  [z]\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])\n 2. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "also"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (insert (D z) U) (xs @ ys @ zs) @ [z] =\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n  [z]\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])\n 2. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "have \"\\<dots> =\n        ipurge_tr_rev_aux I D U ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n    [z] =\n    ipurge_tr_rev_aux I D U ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])", "using True"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>U. (D z, u) \\<in> I\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n    [z] =\n    ipurge_tr_rev_aux I D U ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])", "by (subst ipurge_tr_rev_aux_append, simp)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ipurge_tr_aux I D (D ` set ys) zs) @\n  [z] =\n  ipurge_tr_rev_aux I D U ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])\n 2. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "finally"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_aux I D U ((xs @ ys @ zs) @ [z]) =\n  ipurge_tr_rev_aux I D U ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])", "show ?thesis"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U ((xs @ ys @ zs) @ [z]) =\n  ipurge_tr_rev_aux I D U ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "hence \"ipurge_tr_rev_aux I D U ((xs @ ys @ zs) @ [z]) =\n        ipurge_tr_rev_aux I D U (xs @ ys @ zs)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U ((xs @ ys @ zs) @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs)", "by (subst ipurge_tr_rev_aux_append, simp)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U ((xs @ ys @ zs) @ [z]) =\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "also"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U ((xs @ ys @ zs) @ [z]) =\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "have \"\\<dots> =\n        ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "using D"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)", "."], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "also"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "have \"\\<dots> =\n        ipurge_tr_rev_aux I D U ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs) =\n    ipurge_tr_rev_aux I D U ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])", "using False"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs) =\n    ipurge_tr_rev_aux I D U ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])", "by (subst ipurge_tr_rev_aux_append, simp)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs) =\n  ipurge_tr_rev_aux I D U ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "finally"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_aux I D U ((xs @ ys @ zs) @ [z]) =\n  ipurge_tr_rev_aux I D U ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])", "show ?thesis"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U ((xs @ ys @ zs) @ [z]) =\n  ipurge_tr_rev_aux I D U ((xs @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) zs @ [z])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ys @ zs @ [z]) =\n  ipurge_tr_rev_aux I D U (xs @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_tr_rev_ipurge_tr_aux_2 [rule_format]:\n \"U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n  ipurge_tr_rev_aux I D U (xs @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)", "proof (induction zs arbitrary: U rule: rev_induct, rule_tac [!] impI, simp)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>U.\n       U \\<subseteq> unaffected_domains I D (D ` set ys)\n                      [] \\<Longrightarrow>\n       ipurge_tr_rev_aux I D U xs = ipurge_tr_rev_aux I D U (xs @ ys)\n 2. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ys @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @\n                           ys @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "fix U"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>U.\n       U \\<subseteq> unaffected_domains I D (D ` set ys)\n                      [] \\<Longrightarrow>\n       ipurge_tr_rev_aux I D U xs = ipurge_tr_rev_aux I D U (xs @ ys)\n 2. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ys @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @\n                           ys @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "assume A: \"U \\<subseteq> unaffected_domains I D (D ` set ys) []\""], ["proof (state)\nthis:\n  U \\<subseteq> unaffected_domains I D (D ` set ys) []\n\ngoal (2 subgoals):\n 1. \\<And>U.\n       U \\<subseteq> unaffected_domains I D (D ` set ys)\n                      [] \\<Longrightarrow>\n       ipurge_tr_rev_aux I D U xs = ipurge_tr_rev_aux I D U (xs @ ys)\n 2. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ys @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @\n                           ys @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "have \"\\<forall>u \\<in> U. \\<forall>v \\<in> D ` set ys. (v, u) \\<notin> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>U. \\<forall>v\\<in>D ` set ys. (v, u) \\<notin> I", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> U \\<Longrightarrow>\n       \\<forall>v\\<in>D ` set ys. (v, u) \\<notin> I", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> U \\<Longrightarrow>\n       \\<forall>v\\<in>D ` set ys. (v, u) \\<notin> I", "assume \"u \\<in> U\""], ["proof (state)\nthis:\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> U \\<Longrightarrow>\n       \\<forall>v\\<in>D ` set ys. (v, u) \\<notin> I", "with A"], ["proof (chain)\npicking this:\n  U \\<subseteq> unaffected_domains I D (D ` set ys) []\n  u \\<in> U", "have \"u \\<in> unaffected_domains I D (D ` set ys) []\""], ["proof (prove)\nusing this:\n  U \\<subseteq> unaffected_domains I D (D ` set ys) []\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. u \\<in> unaffected_domains I D (D ` set ys) []", ".."], ["proof (state)\nthis:\n  u \\<in> unaffected_domains I D (D ` set ys) []\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> U \\<Longrightarrow>\n       \\<forall>v\\<in>D ` set ys. (v, u) \\<notin> I", "thus \"\\<forall>v \\<in> D ` set ys. (v, u) \\<notin> I\""], ["proof (prove)\nusing this:\n  u \\<in> unaffected_domains I D (D ` set ys) []\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>D ` set ys. (v, u) \\<notin> I", "by (simp add: unaffected_domains_def)"], ["proof (state)\nthis:\n  \\<forall>v\\<in>D ` set ys. (v, u) \\<notin> I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>u\\<in>U. \\<forall>v\\<in>D ` set ys. (v, u) \\<notin> I\n\ngoal (2 subgoals):\n 1. \\<And>U.\n       U \\<subseteq> unaffected_domains I D (D ` set ys)\n                      [] \\<Longrightarrow>\n       ipurge_tr_rev_aux I D U xs = ipurge_tr_rev_aux I D U (xs @ ys)\n 2. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ys @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @\n                           ys @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "hence \"ipurge_tr_rev_aux I D U ys = []\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>U. \\<forall>v\\<in>D ` set ys. (v, u) \\<notin> I\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U ys = []", "by (simp add: ipurge_tr_rev_aux_nil)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U ys = []\n\ngoal (2 subgoals):\n 1. \\<And>U.\n       U \\<subseteq> unaffected_domains I D (D ` set ys)\n                      [] \\<Longrightarrow>\n       ipurge_tr_rev_aux I D U xs = ipurge_tr_rev_aux I D U (xs @ ys)\n 2. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ys @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @\n                           ys @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "hence \"ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U ys = []\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs", "by (simp add: ipurge_tr_rev_aux_append_nil)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs\n\ngoal (2 subgoals):\n 1. \\<And>U.\n       U \\<subseteq> unaffected_domains I D (D ` set ys)\n                      [] \\<Longrightarrow>\n       ipurge_tr_rev_aux I D U xs = ipurge_tr_rev_aux I D U (xs @ ys)\n 2. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ys @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @\n                           ys @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "thus \"ipurge_tr_rev_aux I D U xs = ipurge_tr_rev_aux I D U (xs @ ys)\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (xs @ ys) = ipurge_tr_rev_aux I D U xs\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U xs = ipurge_tr_rev_aux I D U (xs @ ys)", ".."], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U xs = ipurge_tr_rev_aux I D U (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ys @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @\n                           ys @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ys @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @\n                           ys @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "fix z zs U"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ys @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @\n                           ys @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "let ?U' = \"insert (D z) U\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ys @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @\n                           ys @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "assume\n    A: \"\\<And>U. U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n      ipurge_tr_rev_aux I D U (xs @ zs) =\n      ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\" and\n    B: \"U \\<subseteq> unaffected_domains I D (D ` set ys) (zs @ [z])\""], ["proof (state)\nthis:\n  ?U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n  ipurge_tr_rev_aux I D ?U (xs @ zs) =\n  ipurge_tr_rev_aux I D ?U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n  U \\<subseteq> unaffected_domains I D (D ` set ys) (zs @ [z])\n\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ys @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @\n                           ys @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "have C: \"U \\<subseteq> unaffected_domains I D (D ` set ys) zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> unaffected_domains I D (D ` set ys) zs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> U \\<Longrightarrow>\n       x \\<in> unaffected_domains I D (D ` set ys) zs", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> U \\<Longrightarrow>\n       x \\<in> unaffected_domains I D (D ` set ys) zs", "assume \"u \\<in> U\""], ["proof (state)\nthis:\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> U \\<Longrightarrow>\n       x \\<in> unaffected_domains I D (D ` set ys) zs", "with B"], ["proof (chain)\npicking this:\n  U \\<subseteq> unaffected_domains I D (D ` set ys) (zs @ [z])\n  u \\<in> U", "have \"u \\<in> unaffected_domains I D (D ` set ys) (zs @ [z])\""], ["proof (prove)\nusing this:\n  U \\<subseteq> unaffected_domains I D (D ` set ys) (zs @ [z])\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. u \\<in> unaffected_domains I D (D ` set ys) (zs @ [z])", ".."], ["proof (state)\nthis:\n  u \\<in> unaffected_domains I D (D ` set ys) (zs @ [z])\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> U \\<Longrightarrow>\n       x \\<in> unaffected_domains I D (D ` set ys) zs", "thus \"u \\<in> unaffected_domains I D (D ` set ys) zs\""], ["proof (prove)\nusing this:\n  u \\<in> unaffected_domains I D (D ` set ys) (zs @ [z])\n\ngoal (1 subgoal):\n 1. u \\<in> unaffected_domains I D (D ` set ys) zs", "by (simp add: unaffected_domains_def)"], ["proof (state)\nthis:\n  u \\<in> unaffected_domains I D (D ` set ys) zs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  U \\<subseteq> unaffected_domains I D (D ` set ys) zs\n\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ys @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @\n                           ys @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "have D: \"ipurge_tr_rev_aux I D U (xs @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)", "have \"U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n      ipurge_tr_rev_aux I D U (xs @ zs) =\n      ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)", "using A"], ["proof (prove)\nusing this:\n  ?U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n  ipurge_tr_rev_aux I D ?U (xs @ zs) =\n  ipurge_tr_rev_aux I D ?U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)", "."], ["proof (state)\nthis:\n  U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n  ipurge_tr_rev_aux I D U (xs @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n  ipurge_tr_rev_aux I D U (xs @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)", "using C"], ["proof (prove)\nusing this:\n  U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n  ipurge_tr_rev_aux I D U (xs @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n  U \\<subseteq> unaffected_domains I D (D ` set ys) zs\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)", ".."], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ys @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @\n                           ys @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "have E: \"\\<not> (\\<exists>v \\<in> sinks_aux I D (D ` set ys) zs. (v, D z) \\<in> I) \\<longrightarrow>\n    ipurge_tr_rev_aux I D ?U' (xs @ zs) =\n    ipurge_tr_rev_aux I D ?U' (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\"\n    (is \"?P \\<longrightarrow> ?Q\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ zs) =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ zs) =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)", "assume ?P"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs. (v, D z) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ zs) =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)", "have \"?U' \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n      ipurge_tr_rev_aux I D ?U' (xs @ zs) =\n      ipurge_tr_rev_aux I D ?U' (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (D z) U\n    \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ zs) =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)", "using A"], ["proof (prove)\nusing this:\n  ?U \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n  ipurge_tr_rev_aux I D ?U (xs @ zs) =\n  ipurge_tr_rev_aux I D ?U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. insert (D z) U\n    \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ zs) =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)", "."], ["proof (state)\nthis:\n  insert (D z) U\n  \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n  ipurge_tr_rev_aux I D (insert (D z) U) (xs @ zs) =\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ zs) =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)", "moreover"], ["proof (state)\nthis:\n  insert (D z) U\n  \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n  ipurge_tr_rev_aux I D (insert (D z) U) (xs @ zs) =\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ zs) =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)", "have \"?U' \\<subseteq> unaffected_domains I D (D ` set ys) zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (D z) U \\<subseteq> unaffected_domains I D (D ` set ys) zs", "by (simp add: C, simp add: unaffected_domains_def \\<open>?P\\<close> [simplified])"], ["proof (state)\nthis:\n  insert (D z) U \\<subseteq> unaffected_domains I D (D ` set ys) zs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ zs) =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)", "ultimately"], ["proof (chain)\npicking this:\n  insert (D z) U\n  \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n  ipurge_tr_rev_aux I D (insert (D z) U) (xs @ zs) =\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n  insert (D z) U \\<subseteq> unaffected_domains I D (D ` set ys) zs", "show ?Q"], ["proof (prove)\nusing this:\n  insert (D z) U\n  \\<subseteq> unaffected_domains I D (D ` set ys) zs \\<longrightarrow>\n  ipurge_tr_rev_aux I D (insert (D z) U) (xs @ zs) =\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n  insert (D z) U \\<subseteq> unaffected_domains I D (D ` set ys) zs\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (insert (D z) U) (xs @ zs) =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)", ".."], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (insert (D z) U) (xs @ zs) =\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n             (v, D z) \\<in> I) \\<longrightarrow>\n  ipurge_tr_rev_aux I D (insert (D z) U) (xs @ zs) =\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa U.\n       \\<lbrakk>\\<And>U.\n                   U \\<subseteq> unaffected_domains I D (D ` set ys)\n                                  xsa \\<longrightarrow>\n                   ipurge_tr_rev_aux I D U (xs @ xsa) =\n                   ipurge_tr_rev_aux I D U\n                    (xs @ ys @ ipurge_tr_aux I D (D ` set ys) xsa);\n        U \\<subseteq> unaffected_domains I D (D ` set ys)\n                       (xsa @ [x])\\<rbrakk>\n       \\<Longrightarrow> ipurge_tr_rev_aux I D U (xs @ xsa @ [x]) =\n                         ipurge_tr_rev_aux I D U\n                          (xs @\n                           ys @ ipurge_tr_aux I D (D ` set ys) (xsa @ [x]))", "show \"ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))", "proof (cases \"\\<exists>v \\<in> sinks_aux I D (D ` set ys) zs. (v, D z) \\<in> I\",\n   simp_all (no_asm_simp))"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n       (v, D z) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "case True"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks_aux I D (D ` set ys) zs. (v, D z) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n       (v, D z) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "have \"\\<not> (\\<exists>u \\<in> U. (D z, u) \\<in> I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow> False", "assume \"\\<exists>u \\<in> U. (D z, u) \\<in> I\""], ["proof (state)\nthis:\n  \\<exists>u\\<in>U. (D z, u) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>u\\<in>U. (D z, u) \\<in> I", "obtain u where F: \"u \\<in> U\" and G: \"(D z, u) \\<in> I\""], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>U. (D z, u) \\<in> I\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>u \\<in> U; (D z, u) \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  u \\<in> U\n  (D z, u) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow> False", "have \"D z \\<in> sinks_aux I D (D ` set ys) (zs @ [z])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D z \\<in> sinks_aux I D (D ` set ys) (zs @ [z])", "using True"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks_aux I D (D ` set ys) zs. (v, D z) \\<in> I\n\ngoal (1 subgoal):\n 1. D z \\<in> sinks_aux I D (D ` set ys) (zs @ [z])", "by simp"], ["proof (state)\nthis:\n  D z \\<in> sinks_aux I D (D ` set ys) (zs @ [z])\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow> False", "with G"], ["proof (chain)\npicking this:\n  (D z, u) \\<in> I\n  D z \\<in> sinks_aux I D (D ` set ys) (zs @ [z])", "have \"\\<exists>v \\<in> sinks_aux I D (D ` set ys) (zs @ [z]). (v, u) \\<in> I\""], ["proof (prove)\nusing this:\n  (D z, u) \\<in> I\n  D z \\<in> sinks_aux I D (D ` set ys) (zs @ [z])\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>sinks_aux I D (D ` set ys) (zs @ [z]). (v, u) \\<in> I", ".."], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks_aux I D (D ` set ys) (zs @ [z]). (v, u) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<exists>v\\<in>sinks_aux I D (D ` set ys) (zs @ [z]). (v, u) \\<in> I\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow> False", "have \"u \\<in> unaffected_domains I D (D ` set ys) (zs @ [z])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> unaffected_domains I D (D ` set ys) (zs @ [z])", "using B and F"], ["proof (prove)\nusing this:\n  U \\<subseteq> unaffected_domains I D (D ` set ys) (zs @ [z])\n  u \\<in> U\n\ngoal (1 subgoal):\n 1. u \\<in> unaffected_domains I D (D ` set ys) (zs @ [z])", ".."], ["proof (state)\nthis:\n  u \\<in> unaffected_domains I D (D ` set ys) (zs @ [z])\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow> False", "hence \"\\<not> (\\<exists>v \\<in> sinks_aux I D (D ` set ys) (zs @ [z]). (v, u) \\<in> I)\""], ["proof (prove)\nusing this:\n  u \\<in> unaffected_domains I D (D ` set ys) (zs @ [z])\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) (zs @ [z]).\n               (v, u) \\<in> I)", "by (simp add: unaffected_domains_def)"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) (zs @ [z]).\n             (v, u) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>v\\<in>sinks_aux I D (D ` set ys) (zs @ [z]). (v, u) \\<in> I\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) (zs @ [z]).\n             (v, u) \\<in> I)", "show False"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>sinks_aux I D (D ` set ys) (zs @ [z]). (v, u) \\<in> I\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) (zs @ [z]).\n             (v, u) \\<in> I)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n       (v, D z) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "hence \"ipurge_tr_rev_aux I D U ((xs @ zs) @ [z]) =\n      ipurge_tr_rev_aux I D U (xs @ zs)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U ((xs @ zs) @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ zs)", "by (subst ipurge_tr_rev_aux_append, simp)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U ((xs @ zs) @ [z]) =\n  ipurge_tr_rev_aux I D U (xs @ zs)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n       (v, D z) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "also"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U ((xs @ zs) @ [z]) =\n  ipurge_tr_rev_aux I D U (xs @ zs)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n       (v, D z) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "have\n     \"\\<dots> = ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)", "using D"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (xs @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)", "."], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n       (v, D z) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n 2. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "finally"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_aux I D U ((xs @ zs) @ [z]) =\n  ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)", "show \"ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n      ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U ((xs @ zs) @ [z]) =\n  ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n  ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs. (v, D z) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "note F = this"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs. (v, D z) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n               (v, D z) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "show \"ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n      ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "proof (cases \"\\<exists>u \\<in> U. (D z, u) \\<in> I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])\n 2. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "case True"], ["proof (state)\nthis:\n  \\<exists>u\\<in>U. (D z, u) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])\n 2. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "hence \"ipurge_tr_rev_aux I D U ((xs @ zs) @ [z]) =\n        ipurge_tr_rev_aux I D ?U' (xs @ zs) @ [z]\""], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>U. (D z, u) \\<in> I\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U ((xs @ zs) @ [z]) =\n    ipurge_tr_rev_aux I D (insert (D z) U) (xs @ zs) @ [z]", "by (subst ipurge_tr_rev_aux_append, simp)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U ((xs @ zs) @ [z]) =\n  ipurge_tr_rev_aux I D (insert (D z) U) (xs @ zs) @ [z]\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])\n 2. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "also"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U ((xs @ zs) @ [z]) =\n  ipurge_tr_rev_aux I D (insert (D z) U) (xs @ zs) @ [z]\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])\n 2. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "have \"\\<dots> =\n        ipurge_tr_rev_aux I D ?U'\n        (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs) @ [z]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (insert (D z) U) (xs @ zs) @ [z] =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs) @\n    [z]", "using E and F"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs.\n             (v, D z) \\<in> I) \\<longrightarrow>\n  ipurge_tr_rev_aux I D (insert (D z) U) (xs @ zs) =\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n  \\<not> (\\<exists>v\\<in>sinks_aux I D (D ` set ys) zs. (v, D z) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (insert (D z) U) (xs @ zs) @ [z] =\n    ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs) @\n    [z]", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (insert (D z) U) (xs @ zs) @ [z] =\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs) @\n  [z]\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])\n 2. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "also"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (insert (D z) U) (xs @ zs) @ [z] =\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs) @\n  [z]\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])\n 2. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "have \"\\<dots> =\n        ipurge_tr_rev_aux I D U\n        ((xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs) @\n    [z] =\n    ipurge_tr_rev_aux I D U\n     ((xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])", "using True"], ["proof (prove)\nusing this:\n  \\<exists>u\\<in>U. (D z, u) \\<in> I\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (insert (D z) U)\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs) @\n    [z] =\n    ipurge_tr_rev_aux I D U\n     ((xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])", "by (subst ipurge_tr_rev_aux_append, simp)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (insert (D z) U)\n   (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs) @\n  [z] =\n  ipurge_tr_rev_aux I D U\n   ((xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])\n\ngoal (2 subgoals):\n 1. \\<exists>u\\<in>U. (D z, u) \\<in> I \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])\n 2. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "finally"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_aux I D U ((xs @ zs) @ [z]) =\n  ipurge_tr_rev_aux I D U\n   ((xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])", "show ?thesis"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U ((xs @ zs) @ [z]) =\n  ipurge_tr_rev_aux I D U\n   ((xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n  ipurge_tr_rev_aux I D U\n   (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "hence \"ipurge_tr_rev_aux I D U ((xs @ zs) @ [z]) =\n        ipurge_tr_rev_aux I D U (xs @ zs)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U ((xs @ zs) @ [z]) =\n    ipurge_tr_rev_aux I D U (xs @ zs)", "by (subst ipurge_tr_rev_aux_append, simp)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U ((xs @ zs) @ [z]) =\n  ipurge_tr_rev_aux I D U (xs @ zs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "also"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U ((xs @ zs) @ [z]) =\n  ipurge_tr_rev_aux I D U (xs @ zs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "have \"\\<dots> =\n        ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)", "using D"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U (xs @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ zs) =\n    ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)", "."], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "also"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ zs) =\n  ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "have \"\\<dots> =\n        ipurge_tr_rev_aux I D U\n        ((xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs) =\n    ipurge_tr_rev_aux I D U\n     ((xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])", "using False"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs) =\n    ipurge_tr_rev_aux I D U\n     ((xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])", "by (subst ipurge_tr_rev_aux_append, simp)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs) =\n  ipurge_tr_rev_aux I D U\n   ((xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>u\\<in>U. (D z, u) \\<in> I) \\<Longrightarrow>\n    ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "finally"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_aux I D U ((xs @ zs) @ [z]) =\n  ipurge_tr_rev_aux I D U\n   ((xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])", "show ?thesis"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D U ((xs @ zs) @ [z]) =\n  ipurge_tr_rev_aux I D U\n   ((xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs) @ [z])\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n    ipurge_tr_rev_aux I D U\n     (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n  ipurge_tr_rev_aux I D U\n   (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n  ipurge_tr_rev_aux I D U\n   (xs @ ys @ ipurge_tr_aux I D (D ` set ys) zs @ [z])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D U (xs @ zs @ [z]) =\n  ipurge_tr_rev_aux I D U\n   (xs @ ys @ ipurge_tr_aux I D (D ` set ys) (zs @ [z]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_tr_rev_ipurge_tr_1:\n  assumes A: \"u \\<in> unaffected_domains I D {D y} zs\"\n  shows \"ipurge_tr_rev I D u (xs @ y # zs) =\n    ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (xs @ y # zs) =\n    ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (xs @ y # zs) =\n    ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)", "have \"ipurge_tr_rev I D u (xs @ y # zs) =\n    ipurge_tr_rev_aux I D {u} (xs @ [y] @ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (xs @ y # zs) =\n    ipurge_tr_rev_aux I D {u} (xs @ [y] @ zs)", "by (simp add: ipurge_tr_rev_aux_single_dom)"], ["proof (state)\nthis:\n  ipurge_tr_rev I D u (xs @ y # zs) =\n  ipurge_tr_rev_aux I D {u} (xs @ [y] @ zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (xs @ y # zs) =\n    ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)", "also"], ["proof (state)\nthis:\n  ipurge_tr_rev I D u (xs @ y # zs) =\n  ipurge_tr_rev_aux I D {u} (xs @ [y] @ zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (xs @ y # zs) =\n    ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)", "have \"\\<dots> = ipurge_tr_rev_aux I D {u}\n    (xs @ ipurge_tr_aux I D (D ` set [y]) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D {u} (xs @ [y] @ zs) =\n    ipurge_tr_rev_aux I D {u} (xs @ ipurge_tr_aux I D (D ` set [y]) zs)", "by (rule ipurge_tr_rev_ipurge_tr_aux_1, simp add: A)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D {u} (xs @ [y] @ zs) =\n  ipurge_tr_rev_aux I D {u} (xs @ ipurge_tr_aux I D (D ` set [y]) zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (xs @ y # zs) =\n    ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)", "also"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D {u} (xs @ [y] @ zs) =\n  ipurge_tr_rev_aux I D {u} (xs @ ipurge_tr_aux I D (D ` set [y]) zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (xs @ y # zs) =\n    ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)", "have \"\\<dots> = ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D {u} (xs @ ipurge_tr_aux I D (D ` set [y]) zs) =\n    ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)", "by (simp add: ipurge_tr_aux_single_dom ipurge_tr_rev_aux_single_dom)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D {u} (xs @ ipurge_tr_aux I D (D ` set [y]) zs) =\n  ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (xs @ y # zs) =\n    ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)", "finally"], ["proof (chain)\npicking this:\n  ipurge_tr_rev I D u (xs @ y # zs) =\n  ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)", "show ?thesis"], ["proof (prove)\nusing this:\n  ipurge_tr_rev I D u (xs @ y # zs) =\n  ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (xs @ y # zs) =\n    ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)", "."], ["proof (state)\nthis:\n  ipurge_tr_rev I D u (xs @ y # zs) =\n  ipurge_tr_rev I D u (xs @ ipurge_tr I D (D y) zs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ipurge_tr_rev_ipurge_tr_2:\n  assumes A: \"u \\<in> unaffected_domains I D {D y} zs\"\n  shows \"ipurge_tr_rev I D u (xs @ zs) =\n    ipurge_tr_rev I D u (xs @ y # ipurge_tr I D (D y) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (xs @ zs) =\n    ipurge_tr_rev I D u (xs @ y # ipurge_tr I D (D y) zs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (xs @ zs) =\n    ipurge_tr_rev I D u (xs @ y # ipurge_tr I D (D y) zs)", "have \"ipurge_tr_rev I D u (xs @ zs) = ipurge_tr_rev_aux I D {u} (xs @ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (xs @ zs) = ipurge_tr_rev_aux I D {u} (xs @ zs)", "by (simp add: ipurge_tr_rev_aux_single_dom)"], ["proof (state)\nthis:\n  ipurge_tr_rev I D u (xs @ zs) = ipurge_tr_rev_aux I D {u} (xs @ zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (xs @ zs) =\n    ipurge_tr_rev I D u (xs @ y # ipurge_tr I D (D y) zs)", "also"], ["proof (state)\nthis:\n  ipurge_tr_rev I D u (xs @ zs) = ipurge_tr_rev_aux I D {u} (xs @ zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (xs @ zs) =\n    ipurge_tr_rev I D u (xs @ y # ipurge_tr I D (D y) zs)", "have\n   \"\\<dots> = ipurge_tr_rev_aux I D {u} (xs @ [y] @ ipurge_tr_aux I D (D ` set [y]) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D {u} (xs @ zs) =\n    ipurge_tr_rev_aux I D {u}\n     (xs @ [y] @ ipurge_tr_aux I D (D ` set [y]) zs)", "by (rule ipurge_tr_rev_ipurge_tr_aux_2, simp add: A)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D {u} (xs @ zs) =\n  ipurge_tr_rev_aux I D {u} (xs @ [y] @ ipurge_tr_aux I D (D ` set [y]) zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (xs @ zs) =\n    ipurge_tr_rev I D u (xs @ y # ipurge_tr I D (D y) zs)", "also"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D {u} (xs @ zs) =\n  ipurge_tr_rev_aux I D {u} (xs @ [y] @ ipurge_tr_aux I D (D ` set [y]) zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (xs @ zs) =\n    ipurge_tr_rev I D u (xs @ y # ipurge_tr I D (D y) zs)", "have \"\\<dots> = ipurge_tr_rev I D u (xs @ y # ipurge_tr I D (D y) zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D {u}\n     (xs @ [y] @ ipurge_tr_aux I D (D ` set [y]) zs) =\n    ipurge_tr_rev I D u (xs @ y # ipurge_tr I D (D y) zs)", "by (simp add: ipurge_tr_aux_single_dom ipurge_tr_rev_aux_single_dom)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D {u}\n   (xs @ [y] @ ipurge_tr_aux I D (D ` set [y]) zs) =\n  ipurge_tr_rev I D u (xs @ y # ipurge_tr I D (D y) zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (xs @ zs) =\n    ipurge_tr_rev I D u (xs @ y # ipurge_tr I D (D y) zs)", "finally"], ["proof (chain)\npicking this:\n  ipurge_tr_rev I D u (xs @ zs) =\n  ipurge_tr_rev I D u (xs @ y # ipurge_tr I D (D y) zs)", "show ?thesis"], ["proof (prove)\nusing this:\n  ipurge_tr_rev I D u (xs @ zs) =\n  ipurge_tr_rev I D u (xs @ y # ipurge_tr I D (D y) zs)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D u (xs @ zs) =\n    ipurge_tr_rev I D u (xs @ y # ipurge_tr I D (D y) zs)", "."], ["proof (state)\nthis:\n  ipurge_tr_rev I D u (xs @ zs) =\n  ipurge_tr_rev I D u (xs @ y # ipurge_tr I D (D y) zs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iu_condition_imply_secure_aux_1:\n  assumes\n    RUC: \"ref_union_closed P\" and\n    IU: \"weakly_future_consistent P I D (rel_ipurge P I D)\" and\n    A: \"(xs @ y # ys, Y) \\<in> failures P\" and\n    B: \"xs @ ipurge_tr I D (D y) ys \\<in> traces P\" and\n    C: \"\\<exists>y'. y' \\<in> ipurge_ref I D (D y) ys Y\"\n  shows \"(xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y)\n    \\<in> failures P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y)\n    \\<in> failures P", "let ?A = \"singleton_set (ipurge_ref I D (D y) ys Y)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y)\n    \\<in> failures P", "have \"(\\<exists>X. X \\<in> ?A) \\<longrightarrow>\n    (\\<forall>X \\<in> ?A. (xs @ ipurge_tr I D (D y) ys, X) \\<in> failures P) \\<longrightarrow>\n    (xs @ ipurge_tr I D (D y) ys, \\<Union>X \\<in> ?A. X) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>X.\n        X \\<in> singleton_set (ipurge_ref I D (D y) ys Y)) \\<longrightarrow>\n    (\\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y).\n        (xs @ ipurge_tr I D (D y) ys, X) \\<in> failures P) \\<longrightarrow>\n    (xs @ ipurge_tr I D (D y) ys,\n     \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y). X)\n    \\<in> failures P", "using RUC"], ["proof (prove)\nusing this:\n  ref_union_closed P\n\ngoal (1 subgoal):\n 1. (\\<exists>X.\n        X \\<in> singleton_set (ipurge_ref I D (D y) ys Y)) \\<longrightarrow>\n    (\\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y).\n        (xs @ ipurge_tr I D (D y) ys, X) \\<in> failures P) \\<longrightarrow>\n    (xs @ ipurge_tr I D (D y) ys,\n     \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y). X)\n    \\<in> failures P", "by (simp add: ref_union_closed_def)"], ["proof (state)\nthis:\n  (\\<exists>X.\n      X \\<in> singleton_set (ipurge_ref I D (D y) ys Y)) \\<longrightarrow>\n  (\\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y).\n      (xs @ ipurge_tr I D (D y) ys, X) \\<in> failures P) \\<longrightarrow>\n  (xs @ ipurge_tr I D (D y) ys,\n   \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y). X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y)\n    \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (\\<exists>X.\n      X \\<in> singleton_set (ipurge_ref I D (D y) ys Y)) \\<longrightarrow>\n  (\\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y).\n      (xs @ ipurge_tr I D (D y) ys, X) \\<in> failures P) \\<longrightarrow>\n  (xs @ ipurge_tr I D (D y) ys,\n   \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y). X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y)\n    \\<in> failures P", "obtain y' where D: \"y' \\<in> ipurge_ref I D (D y) ys Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y'.\n        y' \\<in> ipurge_ref I D (D y) ys Y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using C"], ["proof (prove)\nusing this:\n  \\<exists>y'. y' \\<in> ipurge_ref I D (D y) ys Y\n\ngoal (1 subgoal):\n 1. (\\<And>y'.\n        y' \\<in> ipurge_ref I D (D y) ys Y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  y' \\<in> ipurge_ref I D (D y) ys Y\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y)\n    \\<in> failures P", "hence \"\\<exists>X. X \\<in> ?A\""], ["proof (prove)\nusing this:\n  y' \\<in> ipurge_ref I D (D y) ys Y\n\ngoal (1 subgoal):\n 1. \\<exists>X. X \\<in> singleton_set (ipurge_ref I D (D y) ys Y)", "by (simp add: singleton_set_some, rule exI)"], ["proof (state)\nthis:\n  \\<exists>X. X \\<in> singleton_set (ipurge_ref I D (D y) ys Y)\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y)\n    \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (\\<exists>X.\n      X \\<in> singleton_set (ipurge_ref I D (D y) ys Y)) \\<longrightarrow>\n  (\\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y).\n      (xs @ ipurge_tr I D (D y) ys, X) \\<in> failures P) \\<longrightarrow>\n  (xs @ ipurge_tr I D (D y) ys,\n   \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y). X)\n  \\<in> failures P\n  \\<exists>X. X \\<in> singleton_set (ipurge_ref I D (D y) ys Y)", "have \"(\\<forall>X \\<in> ?A. (xs @ ipurge_tr I D (D y) ys, X) \\<in> failures P) \\<longrightarrow>\n    (xs @ ipurge_tr I D (D y) ys, \\<Union>X \\<in> ?A. X) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (\\<exists>X.\n      X \\<in> singleton_set (ipurge_ref I D (D y) ys Y)) \\<longrightarrow>\n  (\\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y).\n      (xs @ ipurge_tr I D (D y) ys, X) \\<in> failures P) \\<longrightarrow>\n  (xs @ ipurge_tr I D (D y) ys,\n   \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y). X)\n  \\<in> failures P\n  \\<exists>X. X \\<in> singleton_set (ipurge_ref I D (D y) ys Y)\n\ngoal (1 subgoal):\n 1. (\\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y).\n        (xs @ ipurge_tr I D (D y) ys, X) \\<in> failures P) \\<longrightarrow>\n    (xs @ ipurge_tr I D (D y) ys,\n     \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y). X)\n    \\<in> failures P", ".."], ["proof (state)\nthis:\n  (\\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y).\n      (xs @ ipurge_tr I D (D y) ys, X) \\<in> failures P) \\<longrightarrow>\n  (xs @ ipurge_tr I D (D y) ys,\n   \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y). X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y)\n    \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (\\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y).\n      (xs @ ipurge_tr I D (D y) ys, X) \\<in> failures P) \\<longrightarrow>\n  (xs @ ipurge_tr I D (D y) ys,\n   \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y). X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y)\n    \\<in> failures P", "have \"\\<forall>X \\<in> ?A. (xs @ ipurge_tr I D (D y) ys, X) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y).\n       (xs @ ipurge_tr I D (D y) ys, X) \\<in> failures P", "proof (rule ballI, simp add: singleton_set_def, erule bexE, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) ys Y; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) ys, {x}) \\<in> failures P", "fix y'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) ys Y; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) ys, {x}) \\<in> failures P", "have \"\\<forall>u \\<in> range D \\<inter> (-I) `` range D.\n      \\<forall>xs ys. (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n      ref_dom_events P D u xs = ref_dom_events P D u ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n       \\<forall>xs ys.\n          (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n          ref_dom_events P D u xs = ref_dom_events P D u ys", "using IU"], ["proof (prove)\nusing this:\n  weakly_future_consistent P I D (rel_ipurge P I D)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n       \\<forall>xs ys.\n          (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n          ref_dom_events P D u xs = ref_dom_events P D u ys", "by (simp add: weakly_future_consistent_def)"], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n        ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) ys Y; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) ys, {x}) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n        ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) ys Y; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) ys, {x}) \\<in> failures P", "assume E: \"y' \\<in> ipurge_ref I D (D y) ys Y\""], ["proof (state)\nthis:\n  y' \\<in> ipurge_ref I D (D y) ys Y\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) ys Y; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) ys, {x}) \\<in> failures P", "hence \"(D y, D y') \\<notin> I\""], ["proof (prove)\nusing this:\n  y' \\<in> ipurge_ref I D (D y) ys Y\n\ngoal (1 subgoal):\n 1. (D y, D y') \\<notin> I", "by (simp add: ipurge_ref_def)"], ["proof (state)\nthis:\n  (D y, D y') \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) ys Y; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) ys, {x}) \\<in> failures P", "hence \"D y' \\<in> range D \\<inter> (-I) `` range D\""], ["proof (prove)\nusing this:\n  (D y, D y') \\<notin> I\n\ngoal (1 subgoal):\n 1. D y' \\<in> range D \\<inter> (- I) `` range D", "by (simp add: Image_iff, rule exI)"], ["proof (state)\nthis:\n  D y' \\<in> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) ys Y; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) ys, {x}) \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n        ref_dom_events P D u xs = ref_dom_events P D u ys\n  D y' \\<in> range D \\<inter> (- I) `` range D", "have \"\\<forall>xs ys. (xs, ys) \\<in> rel_ipurge P I D (D y') \\<longrightarrow>\n      ref_dom_events P D (D y') xs = ref_dom_events P D (D y') ys\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n        ref_dom_events P D u xs = ref_dom_events P D u ys\n  D y' \\<in> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. \\<forall>xs ys.\n       (xs, ys) \\<in> rel_ipurge P I D (D y') \\<longrightarrow>\n       ref_dom_events P D (D y') xs = ref_dom_events P D (D y') ys", ".."], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     (xs, ys) \\<in> rel_ipurge P I D (D y') \\<longrightarrow>\n     ref_dom_events P D (D y') xs = ref_dom_events P D (D y') ys\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) ys Y; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) ys, {x}) \\<in> failures P", "hence\n      F: \"(xs @ y # ys, xs @ ipurge_tr I D (D y) ys) \\<in> rel_ipurge P I D (D y') \\<longrightarrow>\n        ref_dom_events P D (D y') (xs @ y # ys) =\n        ref_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)\""], ["proof (prove)\nusing this:\n  \\<forall>xs ys.\n     (xs, ys) \\<in> rel_ipurge P I D (D y') \\<longrightarrow>\n     ref_dom_events P D (D y') xs = ref_dom_events P D (D y') ys\n\ngoal (1 subgoal):\n 1. (xs @ y # ys, xs @ ipurge_tr I D (D y) ys)\n    \\<in> rel_ipurge P I D (D y') \\<longrightarrow>\n    ref_dom_events P D (D y') (xs @ y # ys) =\n    ref_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)", "by blast"], ["proof (state)\nthis:\n  (xs @ y # ys, xs @ ipurge_tr I D (D y) ys)\n  \\<in> rel_ipurge P I D (D y') \\<longrightarrow>\n  ref_dom_events P D (D y') (xs @ y # ys) =\n  ref_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) ys Y; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) ys, {x}) \\<in> failures P", "have \"y' \\<in> {x \\<in> Y. D x \\<in> unaffected_domains I D {D y} ys}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y' \\<in> {x \\<in> Y. D x \\<in> unaffected_domains I D {D y} ys}", "using E"], ["proof (prove)\nusing this:\n  y' \\<in> ipurge_ref I D (D y) ys Y\n\ngoal (1 subgoal):\n 1. y' \\<in> {x \\<in> Y. D x \\<in> unaffected_domains I D {D y} ys}", "by (simp add: unaffected_domains_single_dom)"], ["proof (state)\nthis:\n  y' \\<in> {x \\<in> Y. D x \\<in> unaffected_domains I D {D y} ys}\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) ys Y; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) ys, {x}) \\<in> failures P", "hence \"D y' \\<in> unaffected_domains I D {D y} ys\""], ["proof (prove)\nusing this:\n  y' \\<in> {x \\<in> Y. D x \\<in> unaffected_domains I D {D y} ys}\n\ngoal (1 subgoal):\n 1. D y' \\<in> unaffected_domains I D {D y} ys", "by simp"], ["proof (state)\nthis:\n  D y' \\<in> unaffected_domains I D {D y} ys\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) ys Y; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) ys, {x}) \\<in> failures P", "hence \"ipurge_tr_rev I D (D y') (xs @ y # ys) =\n      ipurge_tr_rev I D (D y') (xs @ ipurge_tr I D (D y) ys)\""], ["proof (prove)\nusing this:\n  D y' \\<in> unaffected_domains I D {D y} ys\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D (D y') (xs @ y # ys) =\n    ipurge_tr_rev I D (D y') (xs @ ipurge_tr I D (D y) ys)", "by (rule ipurge_tr_rev_ipurge_tr_1)"], ["proof (state)\nthis:\n  ipurge_tr_rev I D (D y') (xs @ y # ys) =\n  ipurge_tr_rev I D (D y') (xs @ ipurge_tr I D (D y) ys)\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) ys Y; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) ys, {x}) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_rev I D (D y') (xs @ y # ys) =\n  ipurge_tr_rev I D (D y') (xs @ ipurge_tr I D (D y) ys)\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) ys Y; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) ys, {x}) \\<in> failures P", "have \"xs @ y # ys \\<in> traces P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ y # ys \\<in> traces P", "using A"], ["proof (prove)\nusing this:\n  (xs @ y # ys, Y) \\<in> failures P\n\ngoal (1 subgoal):\n 1. xs @ y # ys \\<in> traces P", "by (rule failures_traces)"], ["proof (state)\nthis:\n  xs @ y # ys \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) ys Y; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) ys, {x}) \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr_rev I D (D y') (xs @ y # ys) =\n  ipurge_tr_rev I D (D y') (xs @ ipurge_tr I D (D y) ys)\n  xs @ y # ys \\<in> traces P", "have\n     \"(xs @ y # ys, xs @ ipurge_tr I D (D y) ys) \\<in> rel_ipurge P I D (D y')\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev I D (D y') (xs @ y # ys) =\n  ipurge_tr_rev I D (D y') (xs @ ipurge_tr I D (D y) ys)\n  xs @ y # ys \\<in> traces P\n\ngoal (1 subgoal):\n 1. (xs @ y # ys, xs @ ipurge_tr I D (D y) ys) \\<in> rel_ipurge P I D (D y')", "using B"], ["proof (prove)\nusing this:\n  ipurge_tr_rev I D (D y') (xs @ y # ys) =\n  ipurge_tr_rev I D (D y') (xs @ ipurge_tr I D (D y) ys)\n  xs @ y # ys \\<in> traces P\n  xs @ ipurge_tr I D (D y) ys \\<in> traces P\n\ngoal (1 subgoal):\n 1. (xs @ y # ys, xs @ ipurge_tr I D (D y) ys) \\<in> rel_ipurge P I D (D y')", "by (simp add: rel_ipurge_def)"], ["proof (state)\nthis:\n  (xs @ y # ys, xs @ ipurge_tr I D (D y) ys) \\<in> rel_ipurge P I D (D y')\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) ys Y; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) ys, {x}) \\<in> failures P", "with F"], ["proof (chain)\npicking this:\n  (xs @ y # ys, xs @ ipurge_tr I D (D y) ys)\n  \\<in> rel_ipurge P I D (D y') \\<longrightarrow>\n  ref_dom_events P D (D y') (xs @ y # ys) =\n  ref_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)\n  (xs @ y # ys, xs @ ipurge_tr I D (D y) ys) \\<in> rel_ipurge P I D (D y')", "have \"ref_dom_events P D (D y') (xs @ y # ys) =\n      ref_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)\""], ["proof (prove)\nusing this:\n  (xs @ y # ys, xs @ ipurge_tr I D (D y) ys)\n  \\<in> rel_ipurge P I D (D y') \\<longrightarrow>\n  ref_dom_events P D (D y') (xs @ y # ys) =\n  ref_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)\n  (xs @ y # ys, xs @ ipurge_tr I D (D y) ys) \\<in> rel_ipurge P I D (D y')\n\ngoal (1 subgoal):\n 1. ref_dom_events P D (D y') (xs @ y # ys) =\n    ref_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)", ".."], ["proof (state)\nthis:\n  ref_dom_events P D (D y') (xs @ y # ys) =\n  ref_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) ys Y; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) ys, {x}) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  ref_dom_events P D (D y') (xs @ y # ys) =\n  ref_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) ys Y; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) ys, {x}) \\<in> failures P", "have \"y' \\<in> ref_dom_events P D (D y') (xs @ y # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y' \\<in> ref_dom_events P D (D y') (xs @ y # ys)", "proof (simp add: ref_dom_events_def refusals_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. (xs @ y # ys, {y'}) \\<in> failures P", "have \"{y'} \\<subseteq> Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {y'} \\<subseteq> Y", "using E"], ["proof (prove)\nusing this:\n  y' \\<in> ipurge_ref I D (D y) ys Y\n\ngoal (1 subgoal):\n 1. {y'} \\<subseteq> Y", "by (simp add: ipurge_ref_def)"], ["proof (state)\nthis:\n  {y'} \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. (xs @ y # ys, {y'}) \\<in> failures P", "with A"], ["proof (chain)\npicking this:\n  (xs @ y # ys, Y) \\<in> failures P\n  {y'} \\<subseteq> Y", "show \"(xs @ y # ys, {y'}) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (xs @ y # ys, Y) \\<in> failures P\n  {y'} \\<subseteq> Y\n\ngoal (1 subgoal):\n 1. (xs @ y # ys, {y'}) \\<in> failures P", "by (rule process_rule_3)"], ["proof (state)\nthis:\n  (xs @ y # ys, {y'}) \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y' \\<in> ref_dom_events P D (D y') (xs @ y # ys)\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) ys Y; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) ys, {x}) \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  ref_dom_events P D (D y') (xs @ y # ys) =\n  ref_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)\n  y' \\<in> ref_dom_events P D (D y') (xs @ y # ys)", "have \"y' \\<in> ref_dom_events P D (D y')\n      (xs @ ipurge_tr I D (D y) ys)\""], ["proof (prove)\nusing this:\n  ref_dom_events P D (D y') (xs @ y # ys) =\n  ref_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)\n  y' \\<in> ref_dom_events P D (D y') (xs @ y # ys)\n\ngoal (1 subgoal):\n 1. y' \\<in> ref_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)", "by simp"], ["proof (state)\nthis:\n  y' \\<in> ref_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) ys Y; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) ys, {x}) \\<in> failures P", "thus \"(xs @ ipurge_tr I D (D y) ys, {y'}) \\<in> failures P\""], ["proof (prove)\nusing this:\n  y' \\<in> ref_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) ys, {y'}) \\<in> failures P", "by (simp add: ref_dom_events_def refusals_def)"], ["proof (state)\nthis:\n  (xs @ ipurge_tr I D (D y) ys, {y'}) \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y).\n     (xs @ ipurge_tr I D (D y) ys, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y)\n    \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (\\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y).\n      (xs @ ipurge_tr I D (D y) ys, X) \\<in> failures P) \\<longrightarrow>\n  (xs @ ipurge_tr I D (D y) ys,\n   \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y). X)\n  \\<in> failures P\n  \\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y).\n     (xs @ ipurge_tr I D (D y) ys, X) \\<in> failures P", "have \"(xs @ ipurge_tr I D (D y) ys, \\<Union>X \\<in> ?A. X) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (\\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y).\n      (xs @ ipurge_tr I D (D y) ys, X) \\<in> failures P) \\<longrightarrow>\n  (xs @ ipurge_tr I D (D y) ys,\n   \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y). X)\n  \\<in> failures P\n  \\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y).\n     (xs @ ipurge_tr I D (D y) ys, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) ys,\n     \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y). X)\n    \\<in> failures P", ".."], ["proof (state)\nthis:\n  (xs @ ipurge_tr I D (D y) ys,\n   \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y). X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y)\n    \\<in> failures P", "thus ?thesis"], ["proof (prove)\nusing this:\n  (xs @ ipurge_tr I D (D y) ys,\n   \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) ys Y). X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y)\n    \\<in> failures P", "by (simp only: singleton_set_union)"], ["proof (state)\nthis:\n  (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y) \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iu_condition_imply_secure_aux_2:\n  assumes\n    RUC: \"ref_union_closed P\" and\n    IU: \"weakly_future_consistent P I D (rel_ipurge P I D)\" and\n    A: \"(xs @ zs, Z) \\<in> failures P\" and\n    B: \"xs @ y # ipurge_tr I D (D y) zs \\<in> traces P\" and\n    C: \"\\<exists>z'. z' \\<in> ipurge_ref I D (D y) zs Z\"\n  shows \"(xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n    \\<in> failures P", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n    \\<in> failures P", "let ?A = \"singleton_set (ipurge_ref I D (D y) zs Z)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n    \\<in> failures P", "have \"(\\<exists>X. X \\<in> ?A) \\<longrightarrow>\n    (\\<forall>X \\<in> ?A. (xs @ y # ipurge_tr I D (D y) zs, X) \\<in> failures P) \\<longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) zs, \\<Union>X \\<in> ?A. X) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>X.\n        X \\<in> singleton_set (ipurge_ref I D (D y) zs Z)) \\<longrightarrow>\n    (\\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z).\n        (xs @ y # ipurge_tr I D (D y) zs, X)\n        \\<in> failures P) \\<longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) zs,\n     \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z). X)\n    \\<in> failures P", "using RUC"], ["proof (prove)\nusing this:\n  ref_union_closed P\n\ngoal (1 subgoal):\n 1. (\\<exists>X.\n        X \\<in> singleton_set (ipurge_ref I D (D y) zs Z)) \\<longrightarrow>\n    (\\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z).\n        (xs @ y # ipurge_tr I D (D y) zs, X)\n        \\<in> failures P) \\<longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) zs,\n     \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z). X)\n    \\<in> failures P", "by (simp add: ref_union_closed_def)"], ["proof (state)\nthis:\n  (\\<exists>X.\n      X \\<in> singleton_set (ipurge_ref I D (D y) zs Z)) \\<longrightarrow>\n  (\\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z).\n      (xs @ y # ipurge_tr I D (D y) zs, X)\n      \\<in> failures P) \\<longrightarrow>\n  (xs @ y # ipurge_tr I D (D y) zs,\n   \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z). X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n    \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (\\<exists>X.\n      X \\<in> singleton_set (ipurge_ref I D (D y) zs Z)) \\<longrightarrow>\n  (\\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z).\n      (xs @ y # ipurge_tr I D (D y) zs, X)\n      \\<in> failures P) \\<longrightarrow>\n  (xs @ y # ipurge_tr I D (D y) zs,\n   \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z). X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n    \\<in> failures P", "obtain z' where D: \"z' \\<in> ipurge_ref I D (D y) zs Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z'.\n        z' \\<in> ipurge_ref I D (D y) zs Z \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using C"], ["proof (prove)\nusing this:\n  \\<exists>z'. z' \\<in> ipurge_ref I D (D y) zs Z\n\ngoal (1 subgoal):\n 1. (\\<And>z'.\n        z' \\<in> ipurge_ref I D (D y) zs Z \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  z' \\<in> ipurge_ref I D (D y) zs Z\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n    \\<in> failures P", "hence \"\\<exists>X. X \\<in> ?A\""], ["proof (prove)\nusing this:\n  z' \\<in> ipurge_ref I D (D y) zs Z\n\ngoal (1 subgoal):\n 1. \\<exists>X. X \\<in> singleton_set (ipurge_ref I D (D y) zs Z)", "by (simp add: singleton_set_some, rule exI)"], ["proof (state)\nthis:\n  \\<exists>X. X \\<in> singleton_set (ipurge_ref I D (D y) zs Z)\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n    \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (\\<exists>X.\n      X \\<in> singleton_set (ipurge_ref I D (D y) zs Z)) \\<longrightarrow>\n  (\\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z).\n      (xs @ y # ipurge_tr I D (D y) zs, X)\n      \\<in> failures P) \\<longrightarrow>\n  (xs @ y # ipurge_tr I D (D y) zs,\n   \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z). X)\n  \\<in> failures P\n  \\<exists>X. X \\<in> singleton_set (ipurge_ref I D (D y) zs Z)", "have\n   \"(\\<forall>X \\<in> ?A. (xs @ y # ipurge_tr I D (D y) zs, X) \\<in> failures P) \\<longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) zs, \\<Union>X \\<in> ?A. X) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (\\<exists>X.\n      X \\<in> singleton_set (ipurge_ref I D (D y) zs Z)) \\<longrightarrow>\n  (\\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z).\n      (xs @ y # ipurge_tr I D (D y) zs, X)\n      \\<in> failures P) \\<longrightarrow>\n  (xs @ y # ipurge_tr I D (D y) zs,\n   \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z). X)\n  \\<in> failures P\n  \\<exists>X. X \\<in> singleton_set (ipurge_ref I D (D y) zs Z)\n\ngoal (1 subgoal):\n 1. (\\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z).\n        (xs @ y # ipurge_tr I D (D y) zs, X)\n        \\<in> failures P) \\<longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) zs,\n     \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z). X)\n    \\<in> failures P", ".."], ["proof (state)\nthis:\n  (\\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z).\n      (xs @ y # ipurge_tr I D (D y) zs, X)\n      \\<in> failures P) \\<longrightarrow>\n  (xs @ y # ipurge_tr I D (D y) zs,\n   \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z). X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n    \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (\\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z).\n      (xs @ y # ipurge_tr I D (D y) zs, X)\n      \\<in> failures P) \\<longrightarrow>\n  (xs @ y # ipurge_tr I D (D y) zs,\n   \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z). X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n    \\<in> failures P", "have \"\\<forall>X \\<in> ?A. (xs @ y # ipurge_tr I D (D y) zs, X) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z).\n       (xs @ y # ipurge_tr I D (D y) zs, X) \\<in> failures P", "proof (rule ballI, simp add: singleton_set_def, erule bexE, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) zs Z; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) zs, {x})\n                         \\<in> failures P", "fix z'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) zs Z; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) zs, {x})\n                         \\<in> failures P", "have \"\\<forall>u \\<in> range D \\<inter> (-I) `` range D.\n      \\<forall>xs ys. (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n      ref_dom_events P D u xs = ref_dom_events P D u ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n       \\<forall>xs ys.\n          (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n          ref_dom_events P D u xs = ref_dom_events P D u ys", "using IU"], ["proof (prove)\nusing this:\n  weakly_future_consistent P I D (rel_ipurge P I D)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n       \\<forall>xs ys.\n          (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n          ref_dom_events P D u xs = ref_dom_events P D u ys", "by (simp add: weakly_future_consistent_def)"], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n        ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) zs Z; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) zs, {x})\n                         \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n        ref_dom_events P D u xs = ref_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) zs Z; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) zs, {x})\n                         \\<in> failures P", "assume E: \"z' \\<in> ipurge_ref I D (D y) zs Z\""], ["proof (state)\nthis:\n  z' \\<in> ipurge_ref I D (D y) zs Z\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) zs Z; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) zs, {x})\n                         \\<in> failures P", "hence \"(D y, D z') \\<notin> I\""], ["proof (prove)\nusing this:\n  z' \\<in> ipurge_ref I D (D y) zs Z\n\ngoal (1 subgoal):\n 1. (D y, D z') \\<notin> I", "by (simp add: ipurge_ref_def)"], ["proof (state)\nthis:\n  (D y, D z') \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) zs Z; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) zs, {x})\n                         \\<in> failures P", "hence \"D z' \\<in> range D \\<inter> (-I) `` range D\""], ["proof (prove)\nusing this:\n  (D y, D z') \\<notin> I\n\ngoal (1 subgoal):\n 1. D z' \\<in> range D \\<inter> (- I) `` range D", "by (simp add: Image_iff, rule exI)"], ["proof (state)\nthis:\n  D z' \\<in> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) zs Z; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) zs, {x})\n                         \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n        ref_dom_events P D u xs = ref_dom_events P D u ys\n  D z' \\<in> range D \\<inter> (- I) `` range D", "have \"\\<forall>xs ys. (xs, ys) \\<in> rel_ipurge P I D (D z') \\<longrightarrow>\n      ref_dom_events P D (D z') xs = ref_dom_events P D (D z') ys\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n        ref_dom_events P D u xs = ref_dom_events P D u ys\n  D z' \\<in> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. \\<forall>xs ys.\n       (xs, ys) \\<in> rel_ipurge P I D (D z') \\<longrightarrow>\n       ref_dom_events P D (D z') xs = ref_dom_events P D (D z') ys", ".."], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     (xs, ys) \\<in> rel_ipurge P I D (D z') \\<longrightarrow>\n     ref_dom_events P D (D z') xs = ref_dom_events P D (D z') ys\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) zs Z; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) zs, {x})\n                         \\<in> failures P", "hence\n      F: \"(xs @ zs, xs @ y # ipurge_tr I D (D y) zs) \\<in> rel_ipurge P I D (D z') \\<longrightarrow>\n        ref_dom_events P D (D z') (xs @ zs) =\n        ref_dom_events P D (D z') (xs @ y # ipurge_tr I D (D y) zs)\""], ["proof (prove)\nusing this:\n  \\<forall>xs ys.\n     (xs, ys) \\<in> rel_ipurge P I D (D z') \\<longrightarrow>\n     ref_dom_events P D (D z') xs = ref_dom_events P D (D z') ys\n\ngoal (1 subgoal):\n 1. (xs @ zs, xs @ y # ipurge_tr I D (D y) zs)\n    \\<in> rel_ipurge P I D (D z') \\<longrightarrow>\n    ref_dom_events P D (D z') (xs @ zs) =\n    ref_dom_events P D (D z') (xs @ y # ipurge_tr I D (D y) zs)", "by blast"], ["proof (state)\nthis:\n  (xs @ zs, xs @ y # ipurge_tr I D (D y) zs)\n  \\<in> rel_ipurge P I D (D z') \\<longrightarrow>\n  ref_dom_events P D (D z') (xs @ zs) =\n  ref_dom_events P D (D z') (xs @ y # ipurge_tr I D (D y) zs)\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) zs Z; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) zs, {x})\n                         \\<in> failures P", "have \"z' \\<in> {x \\<in> Z. D x \\<in> unaffected_domains I D {D y} zs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z' \\<in> {x \\<in> Z. D x \\<in> unaffected_domains I D {D y} zs}", "using E"], ["proof (prove)\nusing this:\n  z' \\<in> ipurge_ref I D (D y) zs Z\n\ngoal (1 subgoal):\n 1. z' \\<in> {x \\<in> Z. D x \\<in> unaffected_domains I D {D y} zs}", "by (simp add: unaffected_domains_single_dom)"], ["proof (state)\nthis:\n  z' \\<in> {x \\<in> Z. D x \\<in> unaffected_domains I D {D y} zs}\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) zs Z; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) zs, {x})\n                         \\<in> failures P", "hence \"D z' \\<in> unaffected_domains I D {D y} zs\""], ["proof (prove)\nusing this:\n  z' \\<in> {x \\<in> Z. D x \\<in> unaffected_domains I D {D y} zs}\n\ngoal (1 subgoal):\n 1. D z' \\<in> unaffected_domains I D {D y} zs", "by simp"], ["proof (state)\nthis:\n  D z' \\<in> unaffected_domains I D {D y} zs\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) zs Z; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) zs, {x})\n                         \\<in> failures P", "hence \"ipurge_tr_rev I D (D z') (xs @ zs) =\n      ipurge_tr_rev I D (D z') (xs @ y # ipurge_tr I D (D y) zs)\""], ["proof (prove)\nusing this:\n  D z' \\<in> unaffected_domains I D {D y} zs\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D (D z') (xs @ zs) =\n    ipurge_tr_rev I D (D z') (xs @ y # ipurge_tr I D (D y) zs)", "by (rule ipurge_tr_rev_ipurge_tr_2)"], ["proof (state)\nthis:\n  ipurge_tr_rev I D (D z') (xs @ zs) =\n  ipurge_tr_rev I D (D z') (xs @ y # ipurge_tr I D (D y) zs)\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) zs Z; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) zs, {x})\n                         \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_rev I D (D z') (xs @ zs) =\n  ipurge_tr_rev I D (D z') (xs @ y # ipurge_tr I D (D y) zs)\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) zs Z; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) zs, {x})\n                         \\<in> failures P", "have \"xs @ zs \\<in> traces P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ zs \\<in> traces P", "using A"], ["proof (prove)\nusing this:\n  (xs @ zs, Z) \\<in> failures P\n\ngoal (1 subgoal):\n 1. xs @ zs \\<in> traces P", "by (rule failures_traces)"], ["proof (state)\nthis:\n  xs @ zs \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) zs Z; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) zs, {x})\n                         \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr_rev I D (D z') (xs @ zs) =\n  ipurge_tr_rev I D (D z') (xs @ y # ipurge_tr I D (D y) zs)\n  xs @ zs \\<in> traces P", "have\n     \"(xs @ zs, xs @ y # ipurge_tr I D (D y) zs) \\<in> rel_ipurge P I D (D z')\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev I D (D z') (xs @ zs) =\n  ipurge_tr_rev I D (D z') (xs @ y # ipurge_tr I D (D y) zs)\n  xs @ zs \\<in> traces P\n\ngoal (1 subgoal):\n 1. (xs @ zs, xs @ y # ipurge_tr I D (D y) zs) \\<in> rel_ipurge P I D (D z')", "using B"], ["proof (prove)\nusing this:\n  ipurge_tr_rev I D (D z') (xs @ zs) =\n  ipurge_tr_rev I D (D z') (xs @ y # ipurge_tr I D (D y) zs)\n  xs @ zs \\<in> traces P\n  xs @ y # ipurge_tr I D (D y) zs \\<in> traces P\n\ngoal (1 subgoal):\n 1. (xs @ zs, xs @ y # ipurge_tr I D (D y) zs) \\<in> rel_ipurge P I D (D z')", "by (simp add: rel_ipurge_def)"], ["proof (state)\nthis:\n  (xs @ zs, xs @ y # ipurge_tr I D (D y) zs) \\<in> rel_ipurge P I D (D z')\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) zs Z; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) zs, {x})\n                         \\<in> failures P", "with F"], ["proof (chain)\npicking this:\n  (xs @ zs, xs @ y # ipurge_tr I D (D y) zs)\n  \\<in> rel_ipurge P I D (D z') \\<longrightarrow>\n  ref_dom_events P D (D z') (xs @ zs) =\n  ref_dom_events P D (D z') (xs @ y # ipurge_tr I D (D y) zs)\n  (xs @ zs, xs @ y # ipurge_tr I D (D y) zs) \\<in> rel_ipurge P I D (D z')", "have \"ref_dom_events P D (D z') (xs @ zs) =\n      ref_dom_events P D (D z') (xs @ y # ipurge_tr I D (D y) zs)\""], ["proof (prove)\nusing this:\n  (xs @ zs, xs @ y # ipurge_tr I D (D y) zs)\n  \\<in> rel_ipurge P I D (D z') \\<longrightarrow>\n  ref_dom_events P D (D z') (xs @ zs) =\n  ref_dom_events P D (D z') (xs @ y # ipurge_tr I D (D y) zs)\n  (xs @ zs, xs @ y # ipurge_tr I D (D y) zs) \\<in> rel_ipurge P I D (D z')\n\ngoal (1 subgoal):\n 1. ref_dom_events P D (D z') (xs @ zs) =\n    ref_dom_events P D (D z') (xs @ y # ipurge_tr I D (D y) zs)", ".."], ["proof (state)\nthis:\n  ref_dom_events P D (D z') (xs @ zs) =\n  ref_dom_events P D (D z') (xs @ y # ipurge_tr I D (D y) zs)\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) zs Z; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) zs, {x})\n                         \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  ref_dom_events P D (D z') (xs @ zs) =\n  ref_dom_events P D (D z') (xs @ y # ipurge_tr I D (D y) zs)\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) zs Z; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) zs, {x})\n                         \\<in> failures P", "have \"z' \\<in> ref_dom_events P D (D z') (xs @ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z' \\<in> ref_dom_events P D (D z') (xs @ zs)", "proof (simp add: ref_dom_events_def refusals_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. (xs @ zs, {z'}) \\<in> failures P", "have \"{z'} \\<subseteq> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {z'} \\<subseteq> Z", "using E"], ["proof (prove)\nusing this:\n  z' \\<in> ipurge_ref I D (D y) zs Z\n\ngoal (1 subgoal):\n 1. {z'} \\<subseteq> Z", "by (simp add: ipurge_ref_def)"], ["proof (state)\nthis:\n  {z'} \\<subseteq> Z\n\ngoal (1 subgoal):\n 1. (xs @ zs, {z'}) \\<in> failures P", "with A"], ["proof (chain)\npicking this:\n  (xs @ zs, Z) \\<in> failures P\n  {z'} \\<subseteq> Z", "show \"(xs @ zs, {z'}) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (xs @ zs, Z) \\<in> failures P\n  {z'} \\<subseteq> Z\n\ngoal (1 subgoal):\n 1. (xs @ zs, {z'}) \\<in> failures P", "by (rule process_rule_3)"], ["proof (state)\nthis:\n  (xs @ zs, {z'}) \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z' \\<in> ref_dom_events P D (D z') (xs @ zs)\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) zs Z; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) zs, {x})\n                         \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  ref_dom_events P D (D z') (xs @ zs) =\n  ref_dom_events P D (D z') (xs @ y # ipurge_tr I D (D y) zs)\n  z' \\<in> ref_dom_events P D (D z') (xs @ zs)", "have \"z' \\<in> ref_dom_events P D (D z')\n      (xs @ y # ipurge_tr I D (D y) zs)\""], ["proof (prove)\nusing this:\n  ref_dom_events P D (D z') (xs @ zs) =\n  ref_dom_events P D (D z') (xs @ y # ipurge_tr I D (D y) zs)\n  z' \\<in> ref_dom_events P D (D z') (xs @ zs)\n\ngoal (1 subgoal):\n 1. z' \\<in> ref_dom_events P D (D z') (xs @ y # ipurge_tr I D (D y) zs)", "by simp"], ["proof (state)\nthis:\n  z' \\<in> ref_dom_events P D (D z') (xs @ y # ipurge_tr I D (D y) zs)\n\ngoal (1 subgoal):\n 1. \\<And>X x.\n       \\<lbrakk>x \\<in> ipurge_ref I D (D y) zs Z; X = {x}\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) zs, {x})\n                         \\<in> failures P", "thus \"(xs @ y # ipurge_tr I D (D y) zs, {z'}) \\<in> failures P\""], ["proof (prove)\nusing this:\n  z' \\<in> ref_dom_events P D (D z') (xs @ y # ipurge_tr I D (D y) zs)\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) zs, {z'}) \\<in> failures P", "by (simp add: ref_dom_events_def refusals_def)"], ["proof (state)\nthis:\n  (xs @ y # ipurge_tr I D (D y) zs, {z'}) \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z).\n     (xs @ y # ipurge_tr I D (D y) zs, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n    \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (\\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z).\n      (xs @ y # ipurge_tr I D (D y) zs, X)\n      \\<in> failures P) \\<longrightarrow>\n  (xs @ y # ipurge_tr I D (D y) zs,\n   \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z). X)\n  \\<in> failures P\n  \\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z).\n     (xs @ y # ipurge_tr I D (D y) zs, X) \\<in> failures P", "have\n   \"(xs @ y # ipurge_tr I D (D y) zs, \\<Union>X \\<in> ?A. X) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (\\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z).\n      (xs @ y # ipurge_tr I D (D y) zs, X)\n      \\<in> failures P) \\<longrightarrow>\n  (xs @ y # ipurge_tr I D (D y) zs,\n   \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z). X)\n  \\<in> failures P\n  \\<forall>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z).\n     (xs @ y # ipurge_tr I D (D y) zs, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) zs,\n     \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z). X)\n    \\<in> failures P", ".."], ["proof (state)\nthis:\n  (xs @ y # ipurge_tr I D (D y) zs,\n   \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z). X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n    \\<in> failures P", "thus ?thesis"], ["proof (prove)\nusing this:\n  (xs @ y # ipurge_tr I D (D y) zs,\n   \\<Union>X\\<in>singleton_set (ipurge_ref I D (D y) zs Z). X)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n    \\<in> failures P", "by (simp only: singleton_set_union)"], ["proof (state)\nthis:\n  (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n  \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iu_condition_imply_secure_1 [rule_format]:\n  assumes\n    RUC: \"ref_union_closed P\" and\n    IU: \"weakly_future_consistent P I D (rel_ipurge P I D)\"\n  shows \"(xs @ y # ys, Y) \\<in> failures P \\<longrightarrow>\n    (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ y # ys, Y) \\<in> failures P \\<longrightarrow>\n    (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y)\n    \\<in> failures P", "proof (induction ys arbitrary: Y rule: rev_induct, rule_tac [!] impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Y.\n       (xs @ [y], Y) \\<in> failures P \\<Longrightarrow>\n       (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y)\n       \\<in> failures P\n 2. \\<And>x xsa Y.\n       \\<lbrakk>\\<And>Y.\n                   (xs @ y # xsa, Y) \\<in> failures P \\<longrightarrow>\n                   (xs @ ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Y)\n                   \\<in> failures P;\n        (xs @ y # xsa @ [x], Y) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Y)\n                         \\<in> failures P", "fix Y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Y.\n       (xs @ [y], Y) \\<in> failures P \\<Longrightarrow>\n       (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y)\n       \\<in> failures P\n 2. \\<And>x xsa Y.\n       \\<lbrakk>\\<And>Y.\n                   (xs @ y # xsa, Y) \\<in> failures P \\<longrightarrow>\n                   (xs @ ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Y)\n                   \\<in> failures P;\n        (xs @ y # xsa @ [x], Y) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Y)\n                         \\<in> failures P", "assume A: \"(xs @ [y], Y) \\<in> failures P\""], ["proof (state)\nthis:\n  (xs @ [y], Y) \\<in> failures P\n\ngoal (2 subgoals):\n 1. \\<And>Y.\n       (xs @ [y], Y) \\<in> failures P \\<Longrightarrow>\n       (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y)\n       \\<in> failures P\n 2. \\<And>x xsa Y.\n       \\<lbrakk>\\<And>Y.\n                   (xs @ y # xsa, Y) \\<in> failures P \\<longrightarrow>\n                   (xs @ ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Y)\n                   \\<in> failures P;\n        (xs @ y # xsa @ [x], Y) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Y)\n                         \\<in> failures P", "show \"(xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y)\n    \\<in> failures P", "proof (cases \"\\<exists>y'. y' \\<in> ipurge_ref I D (D y) [] Y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>y'. y' \\<in> ipurge_ref I D (D y) [] Y \\<Longrightarrow>\n    (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y)\n    \\<in> failures P\n 2. \\<nexists>y'. y' \\<in> ipurge_ref I D (D y) [] Y \\<Longrightarrow>\n    (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y)\n    \\<in> failures P", "case True"], ["proof (state)\nthis:\n  \\<exists>y'. y' \\<in> ipurge_ref I D (D y) [] Y\n\ngoal (2 subgoals):\n 1. \\<exists>y'. y' \\<in> ipurge_ref I D (D y) [] Y \\<Longrightarrow>\n    (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y)\n    \\<in> failures P\n 2. \\<nexists>y'. y' \\<in> ipurge_ref I D (D y) [] Y \\<Longrightarrow>\n    (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y)\n    \\<in> failures P", "have \"xs @ [y] \\<in> traces P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ [y] \\<in> traces P", "using A"], ["proof (prove)\nusing this:\n  (xs @ [y], Y) \\<in> failures P\n\ngoal (1 subgoal):\n 1. xs @ [y] \\<in> traces P", "by (rule failures_traces)"], ["proof (state)\nthis:\n  xs @ [y] \\<in> traces P\n\ngoal (2 subgoals):\n 1. \\<exists>y'. y' \\<in> ipurge_ref I D (D y) [] Y \\<Longrightarrow>\n    (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y)\n    \\<in> failures P\n 2. \\<nexists>y'. y' \\<in> ipurge_ref I D (D y) [] Y \\<Longrightarrow>\n    (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y)\n    \\<in> failures P", "hence \"xs \\<in> traces P\""], ["proof (prove)\nusing this:\n  xs @ [y] \\<in> traces P\n\ngoal (1 subgoal):\n 1. xs \\<in> traces P", "by (rule process_rule_2_traces)"], ["proof (state)\nthis:\n  xs \\<in> traces P\n\ngoal (2 subgoals):\n 1. \\<exists>y'. y' \\<in> ipurge_ref I D (D y) [] Y \\<Longrightarrow>\n    (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y)\n    \\<in> failures P\n 2. \\<nexists>y'. y' \\<in> ipurge_ref I D (D y) [] Y \\<Longrightarrow>\n    (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y)\n    \\<in> failures P", "hence \"xs @ ipurge_tr I D (D y) [] \\<in> traces P\""], ["proof (prove)\nusing this:\n  xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. xs @ ipurge_tr I D (D y) [] \\<in> traces P", "by simp"], ["proof (state)\nthis:\n  xs @ ipurge_tr I D (D y) [] \\<in> traces P\n\ngoal (2 subgoals):\n 1. \\<exists>y'. y' \\<in> ipurge_ref I D (D y) [] Y \\<Longrightarrow>\n    (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y)\n    \\<in> failures P\n 2. \\<nexists>y'. y' \\<in> ipurge_ref I D (D y) [] Y \\<Longrightarrow>\n    (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y)\n    \\<in> failures P", "with RUC and IU and A"], ["proof (chain)\npicking this:\n  ref_union_closed P\n  weakly_future_consistent P I D (rel_ipurge P I D)\n  (xs @ [y], Y) \\<in> failures P\n  xs @ ipurge_tr I D (D y) [] \\<in> traces P", "show ?thesis"], ["proof (prove)\nusing this:\n  ref_union_closed P\n  weakly_future_consistent P I D (rel_ipurge P I D)\n  (xs @ [y], Y) \\<in> failures P\n  xs @ ipurge_tr I D (D y) [] \\<in> traces P\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y)\n    \\<in> failures P", "using True"], ["proof (prove)\nusing this:\n  ref_union_closed P\n  weakly_future_consistent P I D (rel_ipurge P I D)\n  (xs @ [y], Y) \\<in> failures P\n  xs @ ipurge_tr I D (D y) [] \\<in> traces P\n  \\<exists>y'. y' \\<in> ipurge_ref I D (D y) [] Y\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y)\n    \\<in> failures P", "by (rule iu_condition_imply_secure_aux_1)"], ["proof (state)\nthis:\n  (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<nexists>y'. y' \\<in> ipurge_ref I D (D y) [] Y \\<Longrightarrow>\n    (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y)\n    \\<in> failures P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>y'. y' \\<in> ipurge_ref I D (D y) [] Y \\<Longrightarrow>\n    (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y)\n    \\<in> failures P", "case False"], ["proof (state)\nthis:\n  \\<nexists>y'. y' \\<in> ipurge_ref I D (D y) [] Y\n\ngoal (1 subgoal):\n 1. \\<nexists>y'. y' \\<in> ipurge_ref I D (D y) [] Y \\<Longrightarrow>\n    (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y)\n    \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  \\<nexists>y'. y' \\<in> ipurge_ref I D (D y) [] Y\n\ngoal (1 subgoal):\n 1. \\<nexists>y'. y' \\<in> ipurge_ref I D (D y) [] Y \\<Longrightarrow>\n    (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y)\n    \\<in> failures P", "have \"(xs, {}) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs, {}) \\<in> failures P", "using A"], ["proof (prove)\nusing this:\n  (xs @ [y], Y) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs, {}) \\<in> failures P", "by (rule process_rule_2)"], ["proof (state)\nthis:\n  (xs, {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<nexists>y'. y' \\<in> ipurge_ref I D (D y) [] Y \\<Longrightarrow>\n    (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y)\n    \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  \\<nexists>y'. y' \\<in> ipurge_ref I D (D y) [] Y\n  (xs, {}) \\<in> failures P", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>y'. y' \\<in> ipurge_ref I D (D y) [] Y\n  (xs, {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y)\n    \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y) \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (xs @ ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Y) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa Y.\n       \\<lbrakk>\\<And>Y.\n                   (xs @ y # xsa, Y) \\<in> failures P \\<longrightarrow>\n                   (xs @ ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Y)\n                   \\<in> failures P;\n        (xs @ y # xsa @ [x], Y) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Y)\n                         \\<in> failures P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa Y.\n       \\<lbrakk>\\<And>Y.\n                   (xs @ y # xsa, Y) \\<in> failures P \\<longrightarrow>\n                   (xs @ ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Y)\n                   \\<in> failures P;\n        (xs @ y # xsa @ [x], Y) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Y)\n                         \\<in> failures P", "fix y' ys Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa Y.\n       \\<lbrakk>\\<And>Y.\n                   (xs @ y # xsa, Y) \\<in> failures P \\<longrightarrow>\n                   (xs @ ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Y)\n                   \\<in> failures P;\n        (xs @ y # xsa @ [x], Y) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Y)\n                         \\<in> failures P", "assume\n    A: \"\\<And>Y'. (xs @ y # ys, Y') \\<in> failures P \\<longrightarrow>\n      (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y') \\<in> failures P\" and\n    B: \"(xs @ y # ys @ [y'], Y) \\<in> failures P\""], ["proof (state)\nthis:\n  (xs @ y # ys, ?Y') \\<in> failures P \\<longrightarrow>\n  (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys ?Y')\n  \\<in> failures P\n  (xs @ y # ys @ [y'], Y) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa Y.\n       \\<lbrakk>\\<And>Y.\n                   (xs @ y # xsa, Y) \\<in> failures P \\<longrightarrow>\n                   (xs @ ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Y)\n                   \\<in> failures P;\n        (xs @ y # xsa @ [x], Y) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Y)\n                         \\<in> failures P", "have \"(xs @ y # ys, {}) \\<in> failures P \\<longrightarrow>\n    (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys {}) \\<in> failures P\"\n    (is \"_ \\<longrightarrow> (_, ?Y') \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ y # ys, {}) \\<in> failures P \\<longrightarrow>\n    (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys {})\n    \\<in> failures P", "using A"], ["proof (prove)\nusing this:\n  (xs @ y # ys, ?Y') \\<in> failures P \\<longrightarrow>\n  (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys ?Y')\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ y # ys, {}) \\<in> failures P \\<longrightarrow>\n    (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys {})\n    \\<in> failures P", "."], ["proof (state)\nthis:\n  (xs @ y # ys, {}) \\<in> failures P \\<longrightarrow>\n  (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa Y.\n       \\<lbrakk>\\<And>Y.\n                   (xs @ y # xsa, Y) \\<in> failures P \\<longrightarrow>\n                   (xs @ ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Y)\n                   \\<in> failures P;\n        (xs @ y # xsa @ [x], Y) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Y)\n                         \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (xs @ y # ys, {}) \\<in> failures P \\<longrightarrow>\n  (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa Y.\n       \\<lbrakk>\\<And>Y.\n                   (xs @ y # xsa, Y) \\<in> failures P \\<longrightarrow>\n                   (xs @ ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Y)\n                   \\<in> failures P;\n        (xs @ y # xsa @ [x], Y) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Y)\n                         \\<in> failures P", "have \"((xs @ y # ys) @ [y'], Y) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((xs @ y # ys) @ [y'], Y) \\<in> failures P", "using B"], ["proof (prove)\nusing this:\n  (xs @ y # ys @ [y'], Y) \\<in> failures P\n\ngoal (1 subgoal):\n 1. ((xs @ y # ys) @ [y'], Y) \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  ((xs @ y # ys) @ [y'], Y) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa Y.\n       \\<lbrakk>\\<And>Y.\n                   (xs @ y # xsa, Y) \\<in> failures P \\<longrightarrow>\n                   (xs @ ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Y)\n                   \\<in> failures P;\n        (xs @ y # xsa @ [x], Y) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Y)\n                         \\<in> failures P", "hence C: \"(xs @ y # ys, {}) \\<in> failures P\""], ["proof (prove)\nusing this:\n  ((xs @ y # ys) @ [y'], Y) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ y # ys, {}) \\<in> failures P", "by (rule process_rule_2)"], ["proof (state)\nthis:\n  (xs @ y # ys, {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa Y.\n       \\<lbrakk>\\<And>Y.\n                   (xs @ y # xsa, Y) \\<in> failures P \\<longrightarrow>\n                   (xs @ ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Y)\n                   \\<in> failures P;\n        (xs @ y # xsa @ [x], Y) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Y)\n                         \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (xs @ y # ys, {}) \\<in> failures P \\<longrightarrow>\n  (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys {}) \\<in> failures P\n  (xs @ y # ys, {}) \\<in> failures P", "have \"(xs @ ipurge_tr I D (D y) ys, ?Y') \\<in> failures P\""], ["proof (prove)\nusing this:\n  (xs @ y # ys, {}) \\<in> failures P \\<longrightarrow>\n  (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys {}) \\<in> failures P\n  (xs @ y # ys, {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys {})\n    \\<in> failures P", ".."], ["proof (state)\nthis:\n  (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa Y.\n       \\<lbrakk>\\<And>Y.\n                   (xs @ y # xsa, Y) \\<in> failures P \\<longrightarrow>\n                   (xs @ ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Y)\n                   \\<in> failures P;\n        (xs @ y # xsa @ [x], Y) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Y)\n                         \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa Y.\n       \\<lbrakk>\\<And>Y.\n                   (xs @ y # xsa, Y) \\<in> failures P \\<longrightarrow>\n                   (xs @ ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Y)\n                   \\<in> failures P;\n        (xs @ y # xsa @ [x], Y) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Y)\n                         \\<in> failures P", "have \"{} \\<subseteq> ?Y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<subseteq> ipurge_ref I D (D y) ys {}", ".."], ["proof (state)\nthis:\n  {} \\<subseteq> ipurge_ref I D (D y) ys {}\n\ngoal (1 subgoal):\n 1. \\<And>x xsa Y.\n       \\<lbrakk>\\<And>Y.\n                   (xs @ y # xsa, Y) \\<in> failures P \\<longrightarrow>\n                   (xs @ ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Y)\n                   \\<in> failures P;\n        (xs @ y # xsa @ [x], Y) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Y)\n                         \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys {}) \\<in> failures P\n  {} \\<subseteq> ipurge_ref I D (D y) ys {}", "have D: \"(xs @ ipurge_tr I D (D y) ys, {}) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys {}) \\<in> failures P\n  {} \\<subseteq> ipurge_ref I D (D y) ys {}\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) ys, {}) \\<in> failures P", "by (rule process_rule_3)"], ["proof (state)\nthis:\n  (xs @ ipurge_tr I D (D y) ys, {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa Y.\n       \\<lbrakk>\\<And>Y.\n                   (xs @ y # xsa, Y) \\<in> failures P \\<longrightarrow>\n                   (xs @ ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Y)\n                   \\<in> failures P;\n        (xs @ y # xsa @ [x], Y) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Y)\n                         \\<in> failures P", "have E: \"xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "proof (cases \"D y' \\<in> sinks I D (D y) (ys @ [y'])\")"], ["proof (state)\ngoal (2 subgoals):\n 1. D y' \\<in> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P\n 2. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "case True"], ["proof (state)\nthis:\n  D y' \\<in> sinks I D (D y) (ys @ [y'])\n\ngoal (2 subgoals):\n 1. D y' \\<in> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P\n 2. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "hence \"(xs @ ipurge_tr I D (D y) (ys @ [y']), {}) \\<in> failures P\""], ["proof (prove)\nusing this:\n  D y' \\<in> sinks I D (D y) (ys @ [y'])\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) (ys @ [y']), {}) \\<in> failures P", "using D"], ["proof (prove)\nusing this:\n  D y' \\<in> sinks I D (D y) (ys @ [y'])\n  (xs @ ipurge_tr I D (D y) ys, {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) (ys @ [y']), {}) \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (xs @ ipurge_tr I D (D y) (ys @ [y']), {}) \\<in> failures P\n\ngoal (2 subgoals):\n 1. D y' \\<in> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P\n 2. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "thus ?thesis"], ["proof (prove)\nusing this:\n  (xs @ ipurge_tr I D (D y) (ys @ [y']), {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "by (rule failures_traces)"], ["proof (state)\nthis:\n  xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P\n\ngoal (1 subgoal):\n 1. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "case False"], ["proof (state)\nthis:\n  D y' \\<notin> sinks I D (D y) (ys @ [y'])\n\ngoal (1 subgoal):\n 1. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "have \"\\<forall>u \\<in> range D \\<inter> (-I) `` range D.\n      \\<forall>xs ys. (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n      next_dom_events P D u xs = next_dom_events P D u ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n       \\<forall>xs ys.\n          (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n          next_dom_events P D u xs = next_dom_events P D u ys", "using IU"], ["proof (prove)\nusing this:\n  weakly_future_consistent P I D (rel_ipurge P I D)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n       \\<forall>xs ys.\n          (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n          next_dom_events P D u xs = next_dom_events P D u ys", "by (simp add: weakly_future_consistent_def)"], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "moreover"], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "have \"(D y, D y') \\<notin> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (D y, D y') \\<notin> I", "using False"], ["proof (prove)\nusing this:\n  D y' \\<notin> sinks I D (D y) (ys @ [y'])\n\ngoal (1 subgoal):\n 1. (D y, D y') \\<notin> I", "by (simp add: sinks_interference_eq [symmetric] del: sinks.simps)"], ["proof (state)\nthis:\n  (D y, D y') \\<notin> I\n\ngoal (1 subgoal):\n 1. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "hence \"D y' \\<in> range D \\<inter> (-I) `` range D\""], ["proof (prove)\nusing this:\n  (D y, D y') \\<notin> I\n\ngoal (1 subgoal):\n 1. D y' \\<in> range D \\<inter> (- I) `` range D", "by (simp add: Image_iff, rule exI)"], ["proof (state)\nthis:\n  D y' \\<in> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys\n  D y' \\<in> range D \\<inter> (- I) `` range D", "have \"\\<forall>xs ys. (xs, ys) \\<in> rel_ipurge P I D (D y') \\<longrightarrow>\n      next_dom_events P D (D y') xs = next_dom_events P D (D y') ys\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys\n  D y' \\<in> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. \\<forall>xs ys.\n       (xs, ys) \\<in> rel_ipurge P I D (D y') \\<longrightarrow>\n       next_dom_events P D (D y') xs = next_dom_events P D (D y') ys", ".."], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     (xs, ys) \\<in> rel_ipurge P I D (D y') \\<longrightarrow>\n     next_dom_events P D (D y') xs = next_dom_events P D (D y') ys\n\ngoal (1 subgoal):\n 1. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "hence\n      F: \"(xs @ y # ys, xs @ ipurge_tr I D (D y) ys) \\<in> rel_ipurge P I D (D y') \\<longrightarrow>\n        next_dom_events P D (D y') (xs @ y # ys) =\n        next_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)\""], ["proof (prove)\nusing this:\n  \\<forall>xs ys.\n     (xs, ys) \\<in> rel_ipurge P I D (D y') \\<longrightarrow>\n     next_dom_events P D (D y') xs = next_dom_events P D (D y') ys\n\ngoal (1 subgoal):\n 1. (xs @ y # ys, xs @ ipurge_tr I D (D y) ys)\n    \\<in> rel_ipurge P I D (D y') \\<longrightarrow>\n    next_dom_events P D (D y') (xs @ y # ys) =\n    next_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)", "by blast"], ["proof (state)\nthis:\n  (xs @ y # ys, xs @ ipurge_tr I D (D y) ys)\n  \\<in> rel_ipurge P I D (D y') \\<longrightarrow>\n  next_dom_events P D (D y') (xs @ y # ys) =\n  next_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)\n\ngoal (1 subgoal):\n 1. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "have \"\\<forall>v \\<in> insert (D y) (sinks I D (D y) ys). (v, D y') \\<notin> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>insert (D y) (sinks I D (D y) ys). (v, D y') \\<notin> I", "using False"], ["proof (prove)\nusing this:\n  D y' \\<notin> sinks I D (D y) (ys @ [y'])\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>insert (D y) (sinks I D (D y) ys). (v, D y') \\<notin> I", "by (simp add: sinks_interference_eq [symmetric] del: sinks.simps)"], ["proof (state)\nthis:\n  \\<forall>v\\<in>insert (D y) (sinks I D (D y) ys). (v, D y') \\<notin> I\n\ngoal (1 subgoal):\n 1. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "hence \"\\<forall>v \\<in> sinks_aux I D {D y} ys. (v, D y') \\<notin> I\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>insert (D y) (sinks I D (D y) ys). (v, D y') \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>sinks_aux I D {D y} ys. (v, D y') \\<notin> I", "by (simp add: sinks_aux_single_dom)"], ["proof (state)\nthis:\n  \\<forall>v\\<in>sinks_aux I D {D y} ys. (v, D y') \\<notin> I\n\ngoal (1 subgoal):\n 1. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "hence \"D y' \\<in> unaffected_domains I D {D y} ys\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>sinks_aux I D {D y} ys. (v, D y') \\<notin> I\n\ngoal (1 subgoal):\n 1. D y' \\<in> unaffected_domains I D {D y} ys", "by (simp add: unaffected_domains_def)"], ["proof (state)\nthis:\n  D y' \\<in> unaffected_domains I D {D y} ys\n\ngoal (1 subgoal):\n 1. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "hence \"ipurge_tr_rev I D (D y') (xs @ y # ys) =\n      ipurge_tr_rev I D (D y') (xs @ ipurge_tr I D (D y) ys)\""], ["proof (prove)\nusing this:\n  D y' \\<in> unaffected_domains I D {D y} ys\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D (D y') (xs @ y # ys) =\n    ipurge_tr_rev I D (D y') (xs @ ipurge_tr I D (D y) ys)", "by (rule ipurge_tr_rev_ipurge_tr_1)"], ["proof (state)\nthis:\n  ipurge_tr_rev I D (D y') (xs @ y # ys) =\n  ipurge_tr_rev I D (D y') (xs @ ipurge_tr I D (D y) ys)\n\ngoal (1 subgoal):\n 1. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_rev I D (D y') (xs @ y # ys) =\n  ipurge_tr_rev I D (D y') (xs @ ipurge_tr I D (D y) ys)\n\ngoal (1 subgoal):\n 1. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "have \"xs @ y # ys \\<in> traces P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ y # ys \\<in> traces P", "using C"], ["proof (prove)\nusing this:\n  (xs @ y # ys, {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. xs @ y # ys \\<in> traces P", "by (rule failures_traces)"], ["proof (state)\nthis:\n  xs @ y # ys \\<in> traces P\n\ngoal (1 subgoal):\n 1. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "moreover"], ["proof (state)\nthis:\n  xs @ y # ys \\<in> traces P\n\ngoal (1 subgoal):\n 1. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "have \"xs @ ipurge_tr I D (D y) ys \\<in> traces P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ ipurge_tr I D (D y) ys \\<in> traces P", "using D"], ["proof (prove)\nusing this:\n  (xs @ ipurge_tr I D (D y) ys, {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. xs @ ipurge_tr I D (D y) ys \\<in> traces P", "by (rule failures_traces)"], ["proof (state)\nthis:\n  xs @ ipurge_tr I D (D y) ys \\<in> traces P\n\ngoal (1 subgoal):\n 1. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr_rev I D (D y') (xs @ y # ys) =\n  ipurge_tr_rev I D (D y') (xs @ ipurge_tr I D (D y) ys)\n  xs @ y # ys \\<in> traces P\n  xs @ ipurge_tr I D (D y) ys \\<in> traces P", "have\n     \"(xs @ y # ys, xs @ ipurge_tr I D (D y) ys) \\<in> rel_ipurge P I D (D y')\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev I D (D y') (xs @ y # ys) =\n  ipurge_tr_rev I D (D y') (xs @ ipurge_tr I D (D y) ys)\n  xs @ y # ys \\<in> traces P\n  xs @ ipurge_tr I D (D y) ys \\<in> traces P\n\ngoal (1 subgoal):\n 1. (xs @ y # ys, xs @ ipurge_tr I D (D y) ys) \\<in> rel_ipurge P I D (D y')", "by (simp add: rel_ipurge_def)"], ["proof (state)\nthis:\n  (xs @ y # ys, xs @ ipurge_tr I D (D y) ys) \\<in> rel_ipurge P I D (D y')\n\ngoal (1 subgoal):\n 1. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "with F"], ["proof (chain)\npicking this:\n  (xs @ y # ys, xs @ ipurge_tr I D (D y) ys)\n  \\<in> rel_ipurge P I D (D y') \\<longrightarrow>\n  next_dom_events P D (D y') (xs @ y # ys) =\n  next_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)\n  (xs @ y # ys, xs @ ipurge_tr I D (D y) ys) \\<in> rel_ipurge P I D (D y')", "have \"next_dom_events P D (D y') (xs @ y # ys) =\n      next_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)\""], ["proof (prove)\nusing this:\n  (xs @ y # ys, xs @ ipurge_tr I D (D y) ys)\n  \\<in> rel_ipurge P I D (D y') \\<longrightarrow>\n  next_dom_events P D (D y') (xs @ y # ys) =\n  next_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)\n  (xs @ y # ys, xs @ ipurge_tr I D (D y) ys) \\<in> rel_ipurge P I D (D y')\n\ngoal (1 subgoal):\n 1. next_dom_events P D (D y') (xs @ y # ys) =\n    next_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)", ".."], ["proof (state)\nthis:\n  next_dom_events P D (D y') (xs @ y # ys) =\n  next_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)\n\ngoal (1 subgoal):\n 1. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "moreover"], ["proof (state)\nthis:\n  next_dom_events P D (D y') (xs @ y # ys) =\n  next_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)\n\ngoal (1 subgoal):\n 1. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "have \"y' \\<in> next_dom_events P D (D y') (xs @ y # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y' \\<in> next_dom_events P D (D y') (xs @ y # ys)", "proof (simp add: next_dom_events_def next_events_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. xs @ y # ys @ [y'] \\<in> traces P", "qed (rule failures_traces [OF B])"], ["proof (state)\nthis:\n  y' \\<in> next_dom_events P D (D y') (xs @ y # ys)\n\ngoal (1 subgoal):\n 1. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "ultimately"], ["proof (chain)\npicking this:\n  next_dom_events P D (D y') (xs @ y # ys) =\n  next_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)\n  y' \\<in> next_dom_events P D (D y') (xs @ y # ys)", "have \"y' \\<in> next_dom_events P D (D y')\n      (xs @ ipurge_tr I D (D y) ys)\""], ["proof (prove)\nusing this:\n  next_dom_events P D (D y') (xs @ y # ys) =\n  next_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)\n  y' \\<in> next_dom_events P D (D y') (xs @ y # ys)\n\ngoal (1 subgoal):\n 1. y' \\<in> next_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)", "by simp"], ["proof (state)\nthis:\n  y' \\<in> next_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)\n\ngoal (1 subgoal):\n 1. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "hence \"xs @ ipurge_tr I D (D y) ys @ [y'] \\<in> traces P\""], ["proof (prove)\nusing this:\n  y' \\<in> next_dom_events P D (D y') (xs @ ipurge_tr I D (D y) ys)\n\ngoal (1 subgoal):\n 1. xs @ ipurge_tr I D (D y) ys @ [y'] \\<in> traces P", "by (simp add: next_dom_events_def next_events_def)"], ["proof (state)\nthis:\n  xs @ ipurge_tr I D (D y) ys @ [y'] \\<in> traces P\n\ngoal (1 subgoal):\n 1. D y' \\<notin> sinks I D (D y) (ys @ [y']) \\<Longrightarrow>\n    xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs @ ipurge_tr I D (D y) ys @ [y'] \\<in> traces P\n\ngoal (1 subgoal):\n 1. xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "using False"], ["proof (prove)\nusing this:\n  xs @ ipurge_tr I D (D y) ys @ [y'] \\<in> traces P\n  D y' \\<notin> sinks I D (D y) (ys @ [y'])\n\ngoal (1 subgoal):\n 1. xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P", "by simp"], ["proof (state)\nthis:\n  xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa Y.\n       \\<lbrakk>\\<And>Y.\n                   (xs @ y # xsa, Y) \\<in> failures P \\<longrightarrow>\n                   (xs @ ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Y)\n                   \\<in> failures P;\n        (xs @ y # xsa @ [x], Y) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Y)\n                         \\<in> failures P", "show \"(xs @ ipurge_tr I D (D y) (ys @ [y']), ipurge_ref I D (D y) (ys @ [y']) Y)\n    \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) (ys @ [y']),\n     ipurge_ref I D (D y) (ys @ [y']) Y)\n    \\<in> failures P", "proof (cases \"\\<exists>x. x \\<in> ipurge_ref I D (D y) (ys @ [y']) Y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x. x \\<in> ipurge_ref I D (D y) (ys @ [y']) Y \\<Longrightarrow>\n    (xs @ ipurge_tr I D (D y) (ys @ [y']),\n     ipurge_ref I D (D y) (ys @ [y']) Y)\n    \\<in> failures P\n 2. \\<nexists>x.\n       x \\<in> ipurge_ref I D (D y) (ys @ [y']) Y \\<Longrightarrow>\n    (xs @ ipurge_tr I D (D y) (ys @ [y']),\n     ipurge_ref I D (D y) (ys @ [y']) Y)\n    \\<in> failures P", "case True"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> ipurge_ref I D (D y) (ys @ [y']) Y\n\ngoal (2 subgoals):\n 1. \\<exists>x. x \\<in> ipurge_ref I D (D y) (ys @ [y']) Y \\<Longrightarrow>\n    (xs @ ipurge_tr I D (D y) (ys @ [y']),\n     ipurge_ref I D (D y) (ys @ [y']) Y)\n    \\<in> failures P\n 2. \\<nexists>x.\n       x \\<in> ipurge_ref I D (D y) (ys @ [y']) Y \\<Longrightarrow>\n    (xs @ ipurge_tr I D (D y) (ys @ [y']),\n     ipurge_ref I D (D y) (ys @ [y']) Y)\n    \\<in> failures P", "with RUC and IU and B and E"], ["proof (chain)\npicking this:\n  ref_union_closed P\n  weakly_future_consistent P I D (rel_ipurge P I D)\n  (xs @ y # ys @ [y'], Y) \\<in> failures P\n  xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P\n  \\<exists>x. x \\<in> ipurge_ref I D (D y) (ys @ [y']) Y", "show ?thesis"], ["proof (prove)\nusing this:\n  ref_union_closed P\n  weakly_future_consistent P I D (rel_ipurge P I D)\n  (xs @ y # ys @ [y'], Y) \\<in> failures P\n  xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P\n  \\<exists>x. x \\<in> ipurge_ref I D (D y) (ys @ [y']) Y\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) (ys @ [y']),\n     ipurge_ref I D (D y) (ys @ [y']) Y)\n    \\<in> failures P", "by (rule iu_condition_imply_secure_aux_1)"], ["proof (state)\nthis:\n  (xs @ ipurge_tr I D (D y) (ys @ [y']), ipurge_ref I D (D y) (ys @ [y']) Y)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       x \\<in> ipurge_ref I D (D y) (ys @ [y']) Y \\<Longrightarrow>\n    (xs @ ipurge_tr I D (D y) (ys @ [y']),\n     ipurge_ref I D (D y) (ys @ [y']) Y)\n    \\<in> failures P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       x \\<in> ipurge_ref I D (D y) (ys @ [y']) Y \\<Longrightarrow>\n    (xs @ ipurge_tr I D (D y) (ys @ [y']),\n     ipurge_ref I D (D y) (ys @ [y']) Y)\n    \\<in> failures P", "case False"], ["proof (state)\nthis:\n  \\<nexists>x. x \\<in> ipurge_ref I D (D y) (ys @ [y']) Y\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       x \\<in> ipurge_ref I D (D y) (ys @ [y']) Y \\<Longrightarrow>\n    (xs @ ipurge_tr I D (D y) (ys @ [y']),\n     ipurge_ref I D (D y) (ys @ [y']) Y)\n    \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  \\<nexists>x. x \\<in> ipurge_ref I D (D y) (ys @ [y']) Y\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       x \\<in> ipurge_ref I D (D y) (ys @ [y']) Y \\<Longrightarrow>\n    (xs @ ipurge_tr I D (D y) (ys @ [y']),\n     ipurge_ref I D (D y) (ys @ [y']) Y)\n    \\<in> failures P", "have \"(xs @ ipurge_tr I D (D y) (ys @ [y']), {}) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) (ys @ [y']), {}) \\<in> failures P", "using E"], ["proof (prove)\nusing this:\n  xs @ ipurge_tr I D (D y) (ys @ [y']) \\<in> traces P\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) (ys @ [y']), {}) \\<in> failures P", "by (rule traces_failures)"], ["proof (state)\nthis:\n  (xs @ ipurge_tr I D (D y) (ys @ [y']), {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<nexists>x.\n       x \\<in> ipurge_ref I D (D y) (ys @ [y']) Y \\<Longrightarrow>\n    (xs @ ipurge_tr I D (D y) (ys @ [y']),\n     ipurge_ref I D (D y) (ys @ [y']) Y)\n    \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  \\<nexists>x. x \\<in> ipurge_ref I D (D y) (ys @ [y']) Y\n  (xs @ ipurge_tr I D (D y) (ys @ [y']), {}) \\<in> failures P", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>x. x \\<in> ipurge_ref I D (D y) (ys @ [y']) Y\n  (xs @ ipurge_tr I D (D y) (ys @ [y']), {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) (ys @ [y']),\n     ipurge_ref I D (D y) (ys @ [y']) Y)\n    \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (xs @ ipurge_tr I D (D y) (ys @ [y']), ipurge_ref I D (D y) (ys @ [y']) Y)\n  \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (xs @ ipurge_tr I D (D y) (ys @ [y']), ipurge_ref I D (D y) (ys @ [y']) Y)\n  \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iu_condition_imply_secure_2 [rule_format]:\n  assumes\n    RUC: \"ref_union_closed P\" and\n    IU: \"weakly_future_consistent P I D (rel_ipurge P I D)\" and\n    Y: \"xs @ [y] \\<in> traces P\"\n  shows \"(xs @ zs, Z) \\<in> failures P \\<longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ zs, Z) \\<in> failures P \\<longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n    \\<in> failures P", "proof (induction zs arbitrary: Z rule: rev_induct, rule_tac [!] impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Z.\n       (xs @ [], Z) \\<in> failures P \\<Longrightarrow>\n       (xs @ y # ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Z)\n       \\<in> failures P\n 2. \\<And>x xsa Z.\n       \\<lbrakk>\\<And>Z.\n                   (xs @ xsa, Z) \\<in> failures P \\<longrightarrow>\n                   (xs @ y # ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Z)\n                   \\<in> failures P;\n        (xs @ xsa @ [x], Z) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Z)\n                         \\<in> failures P", "fix Z"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Z.\n       (xs @ [], Z) \\<in> failures P \\<Longrightarrow>\n       (xs @ y # ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Z)\n       \\<in> failures P\n 2. \\<And>x xsa Z.\n       \\<lbrakk>\\<And>Z.\n                   (xs @ xsa, Z) \\<in> failures P \\<longrightarrow>\n                   (xs @ y # ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Z)\n                   \\<in> failures P;\n        (xs @ xsa @ [x], Z) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Z)\n                         \\<in> failures P", "assume A: \"(xs @ [], Z) \\<in> failures P\""], ["proof (state)\nthis:\n  (xs @ [], Z) \\<in> failures P\n\ngoal (2 subgoals):\n 1. \\<And>Z.\n       (xs @ [], Z) \\<in> failures P \\<Longrightarrow>\n       (xs @ y # ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Z)\n       \\<in> failures P\n 2. \\<And>x xsa Z.\n       \\<lbrakk>\\<And>Z.\n                   (xs @ xsa, Z) \\<in> failures P \\<longrightarrow>\n                   (xs @ y # ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Z)\n                   \\<in> failures P;\n        (xs @ xsa @ [x], Z) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Z)\n                         \\<in> failures P", "show \"(xs @ y # ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Z) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Z)\n    \\<in> failures P", "proof (cases \"\\<exists>z'. z' \\<in> ipurge_ref I D (D y) [] Z\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>z'. z' \\<in> ipurge_ref I D (D y) [] Z \\<Longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Z)\n    \\<in> failures P\n 2. \\<nexists>z'. z' \\<in> ipurge_ref I D (D y) [] Z \\<Longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Z)\n    \\<in> failures P", "case True"], ["proof (state)\nthis:\n  \\<exists>z'. z' \\<in> ipurge_ref I D (D y) [] Z\n\ngoal (2 subgoals):\n 1. \\<exists>z'. z' \\<in> ipurge_ref I D (D y) [] Z \\<Longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Z)\n    \\<in> failures P\n 2. \\<nexists>z'. z' \\<in> ipurge_ref I D (D y) [] Z \\<Longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Z)\n    \\<in> failures P", "have \"xs @ y # ipurge_tr I D (D y) [] \\<in> traces P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ y # ipurge_tr I D (D y) [] \\<in> traces P", "using Y"], ["proof (prove)\nusing this:\n  xs @ [y] \\<in> traces P\n\ngoal (1 subgoal):\n 1. xs @ y # ipurge_tr I D (D y) [] \\<in> traces P", "by simp"], ["proof (state)\nthis:\n  xs @ y # ipurge_tr I D (D y) [] \\<in> traces P\n\ngoal (2 subgoals):\n 1. \\<exists>z'. z' \\<in> ipurge_ref I D (D y) [] Z \\<Longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Z)\n    \\<in> failures P\n 2. \\<nexists>z'. z' \\<in> ipurge_ref I D (D y) [] Z \\<Longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Z)\n    \\<in> failures P", "with RUC and IU and A"], ["proof (chain)\npicking this:\n  ref_union_closed P\n  weakly_future_consistent P I D (rel_ipurge P I D)\n  (xs @ [], Z) \\<in> failures P\n  xs @ y # ipurge_tr I D (D y) [] \\<in> traces P", "show ?thesis"], ["proof (prove)\nusing this:\n  ref_union_closed P\n  weakly_future_consistent P I D (rel_ipurge P I D)\n  (xs @ [], Z) \\<in> failures P\n  xs @ y # ipurge_tr I D (D y) [] \\<in> traces P\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Z)\n    \\<in> failures P", "using True"], ["proof (prove)\nusing this:\n  ref_union_closed P\n  weakly_future_consistent P I D (rel_ipurge P I D)\n  (xs @ [], Z) \\<in> failures P\n  xs @ y # ipurge_tr I D (D y) [] \\<in> traces P\n  \\<exists>z'. z' \\<in> ipurge_ref I D (D y) [] Z\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Z)\n    \\<in> failures P", "by (rule iu_condition_imply_secure_aux_2)"], ["proof (state)\nthis:\n  (xs @ y # ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Z)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<nexists>z'. z' \\<in> ipurge_ref I D (D y) [] Z \\<Longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Z)\n    \\<in> failures P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>z'. z' \\<in> ipurge_ref I D (D y) [] Z \\<Longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Z)\n    \\<in> failures P", "case False"], ["proof (state)\nthis:\n  \\<nexists>z'. z' \\<in> ipurge_ref I D (D y) [] Z\n\ngoal (1 subgoal):\n 1. \\<nexists>z'. z' \\<in> ipurge_ref I D (D y) [] Z \\<Longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Z)\n    \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  \\<nexists>z'. z' \\<in> ipurge_ref I D (D y) [] Z\n\ngoal (1 subgoal):\n 1. \\<nexists>z'. z' \\<in> ipurge_ref I D (D y) [] Z \\<Longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Z)\n    \\<in> failures P", "have \"(xs @ [y], {}) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ [y], {}) \\<in> failures P", "using Y"], ["proof (prove)\nusing this:\n  xs @ [y] \\<in> traces P\n\ngoal (1 subgoal):\n 1. (xs @ [y], {}) \\<in> failures P", "by (rule traces_failures)"], ["proof (state)\nthis:\n  (xs @ [y], {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<nexists>z'. z' \\<in> ipurge_ref I D (D y) [] Z \\<Longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Z)\n    \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  \\<nexists>z'. z' \\<in> ipurge_ref I D (D y) [] Z\n  (xs @ [y], {}) \\<in> failures P", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>z'. z' \\<in> ipurge_ref I D (D y) [] Z\n  (xs @ [y], {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Z)\n    \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (xs @ y # ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Z)\n  \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (xs @ y # ipurge_tr I D (D y) [], ipurge_ref I D (D y) [] Z)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa Z.\n       \\<lbrakk>\\<And>Z.\n                   (xs @ xsa, Z) \\<in> failures P \\<longrightarrow>\n                   (xs @ y # ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Z)\n                   \\<in> failures P;\n        (xs @ xsa @ [x], Z) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Z)\n                         \\<in> failures P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa Z.\n       \\<lbrakk>\\<And>Z.\n                   (xs @ xsa, Z) \\<in> failures P \\<longrightarrow>\n                   (xs @ y # ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Z)\n                   \\<in> failures P;\n        (xs @ xsa @ [x], Z) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Z)\n                         \\<in> failures P", "fix z zs Z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa Z.\n       \\<lbrakk>\\<And>Z.\n                   (xs @ xsa, Z) \\<in> failures P \\<longrightarrow>\n                   (xs @ y # ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Z)\n                   \\<in> failures P;\n        (xs @ xsa @ [x], Z) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Z)\n                         \\<in> failures P", "assume\n    A: \"\\<And>Z. (xs @ zs, Z) \\<in> failures P \\<longrightarrow>\n      (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z) \\<in> failures P\" and\n    B: \"(xs @ zs @ [z], Z) \\<in> failures P\""], ["proof (state)\nthis:\n  (xs @ zs, ?Z) \\<in> failures P \\<longrightarrow>\n  (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs ?Z)\n  \\<in> failures P\n  (xs @ zs @ [z], Z) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa Z.\n       \\<lbrakk>\\<And>Z.\n                   (xs @ xsa, Z) \\<in> failures P \\<longrightarrow>\n                   (xs @ y # ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Z)\n                   \\<in> failures P;\n        (xs @ xsa @ [x], Z) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Z)\n                         \\<in> failures P", "have \"(xs @ zs, {}) \\<in> failures P \\<longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs {}) \\<in> failures P\"\n    (is \"_ \\<longrightarrow> (_, ?Z') \\<in> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ zs, {}) \\<in> failures P \\<longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs {})\n    \\<in> failures P", "using A"], ["proof (prove)\nusing this:\n  (xs @ zs, ?Z) \\<in> failures P \\<longrightarrow>\n  (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs ?Z)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ zs, {}) \\<in> failures P \\<longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs {})\n    \\<in> failures P", "."], ["proof (state)\nthis:\n  (xs @ zs, {}) \\<in> failures P \\<longrightarrow>\n  (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs {})\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa Z.\n       \\<lbrakk>\\<And>Z.\n                   (xs @ xsa, Z) \\<in> failures P \\<longrightarrow>\n                   (xs @ y # ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Z)\n                   \\<in> failures P;\n        (xs @ xsa @ [x], Z) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Z)\n                         \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (xs @ zs, {}) \\<in> failures P \\<longrightarrow>\n  (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs {})\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa Z.\n       \\<lbrakk>\\<And>Z.\n                   (xs @ xsa, Z) \\<in> failures P \\<longrightarrow>\n                   (xs @ y # ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Z)\n                   \\<in> failures P;\n        (xs @ xsa @ [x], Z) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Z)\n                         \\<in> failures P", "have \"((xs @ zs) @ [z], Z) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((xs @ zs) @ [z], Z) \\<in> failures P", "using B"], ["proof (prove)\nusing this:\n  (xs @ zs @ [z], Z) \\<in> failures P\n\ngoal (1 subgoal):\n 1. ((xs @ zs) @ [z], Z) \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  ((xs @ zs) @ [z], Z) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa Z.\n       \\<lbrakk>\\<And>Z.\n                   (xs @ xsa, Z) \\<in> failures P \\<longrightarrow>\n                   (xs @ y # ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Z)\n                   \\<in> failures P;\n        (xs @ xsa @ [x], Z) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Z)\n                         \\<in> failures P", "hence C: \"(xs @ zs, {}) \\<in> failures P\""], ["proof (prove)\nusing this:\n  ((xs @ zs) @ [z], Z) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ zs, {}) \\<in> failures P", "by (rule process_rule_2)"], ["proof (state)\nthis:\n  (xs @ zs, {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa Z.\n       \\<lbrakk>\\<And>Z.\n                   (xs @ xsa, Z) \\<in> failures P \\<longrightarrow>\n                   (xs @ y # ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Z)\n                   \\<in> failures P;\n        (xs @ xsa @ [x], Z) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Z)\n                         \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (xs @ zs, {}) \\<in> failures P \\<longrightarrow>\n  (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs {})\n  \\<in> failures P\n  (xs @ zs, {}) \\<in> failures P", "have \"(xs @ y # ipurge_tr I D (D y) zs, ?Z') \\<in> failures P\""], ["proof (prove)\nusing this:\n  (xs @ zs, {}) \\<in> failures P \\<longrightarrow>\n  (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs {})\n  \\<in> failures P\n  (xs @ zs, {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs {})\n    \\<in> failures P", ".."], ["proof (state)\nthis:\n  (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs {})\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa Z.\n       \\<lbrakk>\\<And>Z.\n                   (xs @ xsa, Z) \\<in> failures P \\<longrightarrow>\n                   (xs @ y # ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Z)\n                   \\<in> failures P;\n        (xs @ xsa @ [x], Z) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Z)\n                         \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs {})\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa Z.\n       \\<lbrakk>\\<And>Z.\n                   (xs @ xsa, Z) \\<in> failures P \\<longrightarrow>\n                   (xs @ y # ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Z)\n                   \\<in> failures P;\n        (xs @ xsa @ [x], Z) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Z)\n                         \\<in> failures P", "have \"{} \\<subseteq> ?Z'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<subseteq> ipurge_ref I D (D y) zs {}", ".."], ["proof (state)\nthis:\n  {} \\<subseteq> ipurge_ref I D (D y) zs {}\n\ngoal (1 subgoal):\n 1. \\<And>x xsa Z.\n       \\<lbrakk>\\<And>Z.\n                   (xs @ xsa, Z) \\<in> failures P \\<longrightarrow>\n                   (xs @ y # ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Z)\n                   \\<in> failures P;\n        (xs @ xsa @ [x], Z) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Z)\n                         \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs {})\n  \\<in> failures P\n  {} \\<subseteq> ipurge_ref I D (D y) zs {}", "have D: \"(xs @ y # ipurge_tr I D (D y) zs, {}) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs {})\n  \\<in> failures P\n  {} \\<subseteq> ipurge_ref I D (D y) zs {}\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) zs, {}) \\<in> failures P", "by (rule process_rule_3)"], ["proof (state)\nthis:\n  (xs @ y # ipurge_tr I D (D y) zs, {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa Z.\n       \\<lbrakk>\\<And>Z.\n                   (xs @ xsa, Z) \\<in> failures P \\<longrightarrow>\n                   (xs @ y # ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Z)\n                   \\<in> failures P;\n        (xs @ xsa @ [x], Z) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Z)\n                         \\<in> failures P", "have E: \"xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "proof (cases \"D z \\<in> sinks I D (D y) (zs @ [z])\")"], ["proof (state)\ngoal (2 subgoals):\n 1. D z \\<in> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P\n 2. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "case True"], ["proof (state)\nthis:\n  D z \\<in> sinks I D (D y) (zs @ [z])\n\ngoal (2 subgoals):\n 1. D z \\<in> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P\n 2. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "hence \"(xs @ y # ipurge_tr I D (D y) (zs @ [z]), {}) \\<in> failures P\""], ["proof (prove)\nusing this:\n  D z \\<in> sinks I D (D y) (zs @ [z])\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) (zs @ [z]), {}) \\<in> failures P", "using D"], ["proof (prove)\nusing this:\n  D z \\<in> sinks I D (D y) (zs @ [z])\n  (xs @ y # ipurge_tr I D (D y) zs, {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) (zs @ [z]), {}) \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (xs @ y # ipurge_tr I D (D y) (zs @ [z]), {}) \\<in> failures P\n\ngoal (2 subgoals):\n 1. D z \\<in> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P\n 2. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "thus ?thesis"], ["proof (prove)\nusing this:\n  (xs @ y # ipurge_tr I D (D y) (zs @ [z]), {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "by (rule failures_traces)"], ["proof (state)\nthis:\n  xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P\n\ngoal (1 subgoal):\n 1. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "case False"], ["proof (state)\nthis:\n  D z \\<notin> sinks I D (D y) (zs @ [z])\n\ngoal (1 subgoal):\n 1. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "have \"\\<forall>u \\<in> range D \\<inter> (-I) `` range D.\n      \\<forall>xs ys. (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n      next_dom_events P D u xs = next_dom_events P D u ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n       \\<forall>xs ys.\n          (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n          next_dom_events P D u xs = next_dom_events P D u ys", "using IU"], ["proof (prove)\nusing this:\n  weakly_future_consistent P I D (rel_ipurge P I D)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n       \\<forall>xs ys.\n          (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n          next_dom_events P D u xs = next_dom_events P D u ys", "by (simp add: weakly_future_consistent_def)"], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "moreover"], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys\n\ngoal (1 subgoal):\n 1. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "have \"(D y, D z) \\<notin> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (D y, D z) \\<notin> I", "using False"], ["proof (prove)\nusing this:\n  D z \\<notin> sinks I D (D y) (zs @ [z])\n\ngoal (1 subgoal):\n 1. (D y, D z) \\<notin> I", "by (simp add: sinks_interference_eq [symmetric] del: sinks.simps)"], ["proof (state)\nthis:\n  (D y, D z) \\<notin> I\n\ngoal (1 subgoal):\n 1. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "hence \"D z \\<in> range D \\<inter> (-I) `` range D\""], ["proof (prove)\nusing this:\n  (D y, D z) \\<notin> I\n\ngoal (1 subgoal):\n 1. D z \\<in> range D \\<inter> (- I) `` range D", "by (simp add: Image_iff, rule exI)"], ["proof (state)\nthis:\n  D z \\<in> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys\n  D z \\<in> range D \\<inter> (- I) `` range D", "have \"\\<forall>xs ys. (xs, ys) \\<in> rel_ipurge P I D (D z) \\<longrightarrow>\n      next_dom_events P D (D z) xs = next_dom_events P D (D z) ys\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>range D \\<inter> (- I) `` range D.\n     \\<forall>xs ys.\n        (xs, ys) \\<in> rel_ipurge P I D u \\<longrightarrow>\n        next_dom_events P D u xs = next_dom_events P D u ys\n  D z \\<in> range D \\<inter> (- I) `` range D\n\ngoal (1 subgoal):\n 1. \\<forall>xs ys.\n       (xs, ys) \\<in> rel_ipurge P I D (D z) \\<longrightarrow>\n       next_dom_events P D (D z) xs = next_dom_events P D (D z) ys", ".."], ["proof (state)\nthis:\n  \\<forall>xs ys.\n     (xs, ys) \\<in> rel_ipurge P I D (D z) \\<longrightarrow>\n     next_dom_events P D (D z) xs = next_dom_events P D (D z) ys\n\ngoal (1 subgoal):\n 1. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "hence\n      F: \"(xs @ zs, xs @ y # ipurge_tr I D (D y) zs) \\<in> rel_ipurge P I D (D z) \\<longrightarrow>\n        next_dom_events P D (D z) (xs @ zs) =\n        next_dom_events P D (D z) (xs @ y # ipurge_tr I D (D y) zs)\""], ["proof (prove)\nusing this:\n  \\<forall>xs ys.\n     (xs, ys) \\<in> rel_ipurge P I D (D z) \\<longrightarrow>\n     next_dom_events P D (D z) xs = next_dom_events P D (D z) ys\n\ngoal (1 subgoal):\n 1. (xs @ zs, xs @ y # ipurge_tr I D (D y) zs)\n    \\<in> rel_ipurge P I D (D z) \\<longrightarrow>\n    next_dom_events P D (D z) (xs @ zs) =\n    next_dom_events P D (D z) (xs @ y # ipurge_tr I D (D y) zs)", "by blast"], ["proof (state)\nthis:\n  (xs @ zs, xs @ y # ipurge_tr I D (D y) zs)\n  \\<in> rel_ipurge P I D (D z) \\<longrightarrow>\n  next_dom_events P D (D z) (xs @ zs) =\n  next_dom_events P D (D z) (xs @ y # ipurge_tr I D (D y) zs)\n\ngoal (1 subgoal):\n 1. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "have \"\\<forall>v \\<in> insert (D y) (sinks I D (D y) zs). (v, D z) \\<notin> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>insert (D y) (sinks I D (D y) zs). (v, D z) \\<notin> I", "using False"], ["proof (prove)\nusing this:\n  D z \\<notin> sinks I D (D y) (zs @ [z])\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>insert (D y) (sinks I D (D y) zs). (v, D z) \\<notin> I", "by (simp add: sinks_interference_eq [symmetric] del: sinks.simps)"], ["proof (state)\nthis:\n  \\<forall>v\\<in>insert (D y) (sinks I D (D y) zs). (v, D z) \\<notin> I\n\ngoal (1 subgoal):\n 1. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "hence \"\\<forall>v \\<in> sinks_aux I D {D y} zs. (v, D z) \\<notin> I\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>insert (D y) (sinks I D (D y) zs). (v, D z) \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>sinks_aux I D {D y} zs. (v, D z) \\<notin> I", "by (simp add: sinks_aux_single_dom)"], ["proof (state)\nthis:\n  \\<forall>v\\<in>sinks_aux I D {D y} zs. (v, D z) \\<notin> I\n\ngoal (1 subgoal):\n 1. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "hence \"D z \\<in> unaffected_domains I D {D y} zs\""], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>sinks_aux I D {D y} zs. (v, D z) \\<notin> I\n\ngoal (1 subgoal):\n 1. D z \\<in> unaffected_domains I D {D y} zs", "by (simp add: unaffected_domains_def)"], ["proof (state)\nthis:\n  D z \\<in> unaffected_domains I D {D y} zs\n\ngoal (1 subgoal):\n 1. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "hence \"ipurge_tr_rev I D (D z) (xs @ zs) =\n      ipurge_tr_rev I D (D z) (xs @ y # ipurge_tr I D (D y) zs)\""], ["proof (prove)\nusing this:\n  D z \\<in> unaffected_domains I D {D y} zs\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev I D (D z) (xs @ zs) =\n    ipurge_tr_rev I D (D z) (xs @ y # ipurge_tr I D (D y) zs)", "by (rule ipurge_tr_rev_ipurge_tr_2)"], ["proof (state)\nthis:\n  ipurge_tr_rev I D (D z) (xs @ zs) =\n  ipurge_tr_rev I D (D z) (xs @ y # ipurge_tr I D (D y) zs)\n\ngoal (1 subgoal):\n 1. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_rev I D (D z) (xs @ zs) =\n  ipurge_tr_rev I D (D z) (xs @ y # ipurge_tr I D (D y) zs)\n\ngoal (1 subgoal):\n 1. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "have \"xs @ zs \\<in> traces P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ zs \\<in> traces P", "using C"], ["proof (prove)\nusing this:\n  (xs @ zs, {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. xs @ zs \\<in> traces P", "by (rule failures_traces)"], ["proof (state)\nthis:\n  xs @ zs \\<in> traces P\n\ngoal (1 subgoal):\n 1. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "moreover"], ["proof (state)\nthis:\n  xs @ zs \\<in> traces P\n\ngoal (1 subgoal):\n 1. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "have \"xs @ y # ipurge_tr I D (D y) zs \\<in> traces P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs @ y # ipurge_tr I D (D y) zs \\<in> traces P", "using D"], ["proof (prove)\nusing this:\n  (xs @ y # ipurge_tr I D (D y) zs, {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. xs @ y # ipurge_tr I D (D y) zs \\<in> traces P", "by (rule failures_traces)"], ["proof (state)\nthis:\n  xs @ y # ipurge_tr I D (D y) zs \\<in> traces P\n\ngoal (1 subgoal):\n 1. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr_rev I D (D z) (xs @ zs) =\n  ipurge_tr_rev I D (D z) (xs @ y # ipurge_tr I D (D y) zs)\n  xs @ zs \\<in> traces P\n  xs @ y # ipurge_tr I D (D y) zs \\<in> traces P", "have\n     \"(xs @ zs, xs @ y # ipurge_tr I D (D y) zs) \\<in> rel_ipurge P I D (D z)\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev I D (D z) (xs @ zs) =\n  ipurge_tr_rev I D (D z) (xs @ y # ipurge_tr I D (D y) zs)\n  xs @ zs \\<in> traces P\n  xs @ y # ipurge_tr I D (D y) zs \\<in> traces P\n\ngoal (1 subgoal):\n 1. (xs @ zs, xs @ y # ipurge_tr I D (D y) zs) \\<in> rel_ipurge P I D (D z)", "by (simp add: rel_ipurge_def)"], ["proof (state)\nthis:\n  (xs @ zs, xs @ y # ipurge_tr I D (D y) zs) \\<in> rel_ipurge P I D (D z)\n\ngoal (1 subgoal):\n 1. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "with F"], ["proof (chain)\npicking this:\n  (xs @ zs, xs @ y # ipurge_tr I D (D y) zs)\n  \\<in> rel_ipurge P I D (D z) \\<longrightarrow>\n  next_dom_events P D (D z) (xs @ zs) =\n  next_dom_events P D (D z) (xs @ y # ipurge_tr I D (D y) zs)\n  (xs @ zs, xs @ y # ipurge_tr I D (D y) zs) \\<in> rel_ipurge P I D (D z)", "have \"next_dom_events P D (D z) (xs @ zs) =\n      next_dom_events P D (D z) (xs @ y # ipurge_tr I D (D y) zs)\""], ["proof (prove)\nusing this:\n  (xs @ zs, xs @ y # ipurge_tr I D (D y) zs)\n  \\<in> rel_ipurge P I D (D z) \\<longrightarrow>\n  next_dom_events P D (D z) (xs @ zs) =\n  next_dom_events P D (D z) (xs @ y # ipurge_tr I D (D y) zs)\n  (xs @ zs, xs @ y # ipurge_tr I D (D y) zs) \\<in> rel_ipurge P I D (D z)\n\ngoal (1 subgoal):\n 1. next_dom_events P D (D z) (xs @ zs) =\n    next_dom_events P D (D z) (xs @ y # ipurge_tr I D (D y) zs)", ".."], ["proof (state)\nthis:\n  next_dom_events P D (D z) (xs @ zs) =\n  next_dom_events P D (D z) (xs @ y # ipurge_tr I D (D y) zs)\n\ngoal (1 subgoal):\n 1. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "moreover"], ["proof (state)\nthis:\n  next_dom_events P D (D z) (xs @ zs) =\n  next_dom_events P D (D z) (xs @ y # ipurge_tr I D (D y) zs)\n\ngoal (1 subgoal):\n 1. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "have \"z \\<in> next_dom_events P D (D z) (xs @ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> next_dom_events P D (D z) (xs @ zs)", "proof (simp add: next_dom_events_def next_events_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. xs @ zs @ [z] \\<in> traces P", "qed (rule failures_traces [OF B])"], ["proof (state)\nthis:\n  z \\<in> next_dom_events P D (D z) (xs @ zs)\n\ngoal (1 subgoal):\n 1. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "ultimately"], ["proof (chain)\npicking this:\n  next_dom_events P D (D z) (xs @ zs) =\n  next_dom_events P D (D z) (xs @ y # ipurge_tr I D (D y) zs)\n  z \\<in> next_dom_events P D (D z) (xs @ zs)", "have \"z \\<in> next_dom_events P D (D z)\n      (xs @ y # ipurge_tr I D (D y) zs)\""], ["proof (prove)\nusing this:\n  next_dom_events P D (D z) (xs @ zs) =\n  next_dom_events P D (D z) (xs @ y # ipurge_tr I D (D y) zs)\n  z \\<in> next_dom_events P D (D z) (xs @ zs)\n\ngoal (1 subgoal):\n 1. z \\<in> next_dom_events P D (D z) (xs @ y # ipurge_tr I D (D y) zs)", "by simp"], ["proof (state)\nthis:\n  z \\<in> next_dom_events P D (D z) (xs @ y # ipurge_tr I D (D y) zs)\n\ngoal (1 subgoal):\n 1. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "hence \"xs @ y # ipurge_tr I D (D y) zs @ [z] \\<in> traces P\""], ["proof (prove)\nusing this:\n  z \\<in> next_dom_events P D (D z) (xs @ y # ipurge_tr I D (D y) zs)\n\ngoal (1 subgoal):\n 1. xs @ y # ipurge_tr I D (D y) zs @ [z] \\<in> traces P", "by (simp add: next_dom_events_def next_events_def)"], ["proof (state)\nthis:\n  xs @ y # ipurge_tr I D (D y) zs @ [z] \\<in> traces P\n\ngoal (1 subgoal):\n 1. D z \\<notin> sinks I D (D y) (zs @ [z]) \\<Longrightarrow>\n    xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs @ y # ipurge_tr I D (D y) zs @ [z] \\<in> traces P\n\ngoal (1 subgoal):\n 1. xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "using False"], ["proof (prove)\nusing this:\n  xs @ y # ipurge_tr I D (D y) zs @ [z] \\<in> traces P\n  D z \\<notin> sinks I D (D y) (zs @ [z])\n\ngoal (1 subgoal):\n 1. xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P", "by simp"], ["proof (state)\nthis:\n  xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa Z.\n       \\<lbrakk>\\<And>Z.\n                   (xs @ xsa, Z) \\<in> failures P \\<longrightarrow>\n                   (xs @ y # ipurge_tr I D (D y) xsa,\n                    ipurge_ref I D (D y) xsa Z)\n                   \\<in> failures P;\n        (xs @ xsa @ [x], Z) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ y # ipurge_tr I D (D y) (xsa @ [x]),\n                          ipurge_ref I D (D y) (xsa @ [x]) Z)\n                         \\<in> failures P", "show \"(xs @ y # ipurge_tr I D (D y) (zs @ [z]),\n    ipurge_ref I D (D y) (zs @ [z]) Z)\n    \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) (zs @ [z]),\n     ipurge_ref I D (D y) (zs @ [z]) Z)\n    \\<in> failures P", "proof (cases \"\\<exists>x. x \\<in> ipurge_ref I D (D y) (zs @ [z]) Z\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x. x \\<in> ipurge_ref I D (D y) (zs @ [z]) Z \\<Longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) (zs @ [z]),\n     ipurge_ref I D (D y) (zs @ [z]) Z)\n    \\<in> failures P\n 2. \\<nexists>x. x \\<in> ipurge_ref I D (D y) (zs @ [z]) Z \\<Longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) (zs @ [z]),\n     ipurge_ref I D (D y) (zs @ [z]) Z)\n    \\<in> failures P", "case True"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> ipurge_ref I D (D y) (zs @ [z]) Z\n\ngoal (2 subgoals):\n 1. \\<exists>x. x \\<in> ipurge_ref I D (D y) (zs @ [z]) Z \\<Longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) (zs @ [z]),\n     ipurge_ref I D (D y) (zs @ [z]) Z)\n    \\<in> failures P\n 2. \\<nexists>x. x \\<in> ipurge_ref I D (D y) (zs @ [z]) Z \\<Longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) (zs @ [z]),\n     ipurge_ref I D (D y) (zs @ [z]) Z)\n    \\<in> failures P", "with RUC and IU and B and E"], ["proof (chain)\npicking this:\n  ref_union_closed P\n  weakly_future_consistent P I D (rel_ipurge P I D)\n  (xs @ zs @ [z], Z) \\<in> failures P\n  xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P\n  \\<exists>x. x \\<in> ipurge_ref I D (D y) (zs @ [z]) Z", "show ?thesis"], ["proof (prove)\nusing this:\n  ref_union_closed P\n  weakly_future_consistent P I D (rel_ipurge P I D)\n  (xs @ zs @ [z], Z) \\<in> failures P\n  xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P\n  \\<exists>x. x \\<in> ipurge_ref I D (D y) (zs @ [z]) Z\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) (zs @ [z]),\n     ipurge_ref I D (D y) (zs @ [z]) Z)\n    \\<in> failures P", "by (rule iu_condition_imply_secure_aux_2)"], ["proof (state)\nthis:\n  (xs @ y # ipurge_tr I D (D y) (zs @ [z]),\n   ipurge_ref I D (D y) (zs @ [z]) Z)\n  \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<nexists>x. x \\<in> ipurge_ref I D (D y) (zs @ [z]) Z \\<Longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) (zs @ [z]),\n     ipurge_ref I D (D y) (zs @ [z]) Z)\n    \\<in> failures P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>x. x \\<in> ipurge_ref I D (D y) (zs @ [z]) Z \\<Longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) (zs @ [z]),\n     ipurge_ref I D (D y) (zs @ [z]) Z)\n    \\<in> failures P", "case False"], ["proof (state)\nthis:\n  \\<nexists>x. x \\<in> ipurge_ref I D (D y) (zs @ [z]) Z\n\ngoal (1 subgoal):\n 1. \\<nexists>x. x \\<in> ipurge_ref I D (D y) (zs @ [z]) Z \\<Longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) (zs @ [z]),\n     ipurge_ref I D (D y) (zs @ [z]) Z)\n    \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  \\<nexists>x. x \\<in> ipurge_ref I D (D y) (zs @ [z]) Z\n\ngoal (1 subgoal):\n 1. \\<nexists>x. x \\<in> ipurge_ref I D (D y) (zs @ [z]) Z \\<Longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) (zs @ [z]),\n     ipurge_ref I D (D y) (zs @ [z]) Z)\n    \\<in> failures P", "have \"(xs @ y # ipurge_tr I D (D y) (zs @ [z]), {}) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) (zs @ [z]), {}) \\<in> failures P", "using E"], ["proof (prove)\nusing this:\n  xs @ y # ipurge_tr I D (D y) (zs @ [z]) \\<in> traces P\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) (zs @ [z]), {}) \\<in> failures P", "by (rule traces_failures)"], ["proof (state)\nthis:\n  (xs @ y # ipurge_tr I D (D y) (zs @ [z]), {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<nexists>x. x \\<in> ipurge_ref I D (D y) (zs @ [z]) Z \\<Longrightarrow>\n    (xs @ y # ipurge_tr I D (D y) (zs @ [z]),\n     ipurge_ref I D (D y) (zs @ [z]) Z)\n    \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  \\<nexists>x. x \\<in> ipurge_ref I D (D y) (zs @ [z]) Z\n  (xs @ y # ipurge_tr I D (D y) (zs @ [z]), {}) \\<in> failures P", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>x. x \\<in> ipurge_ref I D (D y) (zs @ [z]) Z\n  (xs @ y # ipurge_tr I D (D y) (zs @ [z]), {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) (zs @ [z]),\n     ipurge_ref I D (D y) (zs @ [z]) Z)\n    \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (xs @ y # ipurge_tr I D (D y) (zs @ [z]),\n   ipurge_ref I D (D y) (zs @ [z]) Z)\n  \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (xs @ y # ipurge_tr I D (D y) (zs @ [z]),\n   ipurge_ref I D (D y) (zs @ [z]) Z)\n  \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem iu_condition_imply_secure:\n  assumes\n    RUC: \"ref_union_closed P\" and\n    IU: \"weakly_future_consistent P I D (rel_ipurge P I D)\"\n  shows \"secure P I D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. secure P I D", "proof (simp add: secure_def futures_def, (rule allI)+, rule impI, erule conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs y ys Y zs Z.\n       \\<lbrakk>(xs @ y # ys, Y) \\<in> failures P;\n        (xs @ zs, Z) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) ys,\n                          ipurge_ref I D (D y) ys Y)\n                         \\<in> failures P \\<and>\n                         (xs @ y # ipurge_tr I D (D y) zs,\n                          ipurge_ref I D (D y) zs Z)\n                         \\<in> failures P", "fix xs y ys Y zs Z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs y ys Y zs Z.\n       \\<lbrakk>(xs @ y # ys, Y) \\<in> failures P;\n        (xs @ zs, Z) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) ys,\n                          ipurge_ref I D (D y) ys Y)\n                         \\<in> failures P \\<and>\n                         (xs @ y # ipurge_tr I D (D y) zs,\n                          ipurge_ref I D (D y) zs Z)\n                         \\<in> failures P", "assume\n    A: \"(xs @ y # ys, Y) \\<in> failures P\" and\n    B: \"(xs @ zs, Z) \\<in> failures P\""], ["proof (state)\nthis:\n  (xs @ y # ys, Y) \\<in> failures P\n  (xs @ zs, Z) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>xs y ys Y zs Z.\n       \\<lbrakk>(xs @ y # ys, Y) \\<in> failures P;\n        (xs @ zs, Z) \\<in> failures P\\<rbrakk>\n       \\<Longrightarrow> (xs @ ipurge_tr I D (D y) ys,\n                          ipurge_ref I D (D y) ys Y)\n                         \\<in> failures P \\<and>\n                         (xs @ y # ipurge_tr I D (D y) zs,\n                          ipurge_ref I D (D y) zs Z)\n                         \\<in> failures P", "show \"(xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y) \\<in> failures P \\<and>\n    (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z) \\<in> failures P\"\n    (is \"?P \\<and> ?Q\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y)\n    \\<in> failures P \\<and>\n    (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n    \\<in> failures P", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y)\n    \\<in> failures P\n 2. (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n    \\<in> failures P", "show ?P"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y)\n    \\<in> failures P", "using RUC and IU and A"], ["proof (prove)\nusing this:\n  ref_union_closed P\n  weakly_future_consistent P I D (rel_ipurge P I D)\n  (xs @ y # ys, Y) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y)\n    \\<in> failures P", "by (rule iu_condition_imply_secure_1)"], ["proof (state)\nthis:\n  (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n    \\<in> failures P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n    \\<in> failures P", "have \"((xs @ [y]) @ ys, Y) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((xs @ [y]) @ ys, Y) \\<in> failures P", "using A"], ["proof (prove)\nusing this:\n  (xs @ y # ys, Y) \\<in> failures P\n\ngoal (1 subgoal):\n 1. ((xs @ [y]) @ ys, Y) \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  ((xs @ [y]) @ ys, Y) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n    \\<in> failures P", "hence \"(xs @ [y], {}) \\<in> failures P\""], ["proof (prove)\nusing this:\n  ((xs @ [y]) @ ys, Y) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ [y], {}) \\<in> failures P", "by (rule process_rule_2_failures)"], ["proof (state)\nthis:\n  (xs @ [y], {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n    \\<in> failures P", "hence \"xs @ [y] \\<in> traces P\""], ["proof (prove)\nusing this:\n  (xs @ [y], {}) \\<in> failures P\n\ngoal (1 subgoal):\n 1. xs @ [y] \\<in> traces P", "by (rule failures_traces)"], ["proof (state)\nthis:\n  xs @ [y] \\<in> traces P\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n    \\<in> failures P", "with RUC and IU"], ["proof (chain)\npicking this:\n  ref_union_closed P\n  weakly_future_consistent P I D (rel_ipurge P I D)\n  xs @ [y] \\<in> traces P", "show ?Q"], ["proof (prove)\nusing this:\n  ref_union_closed P\n  weakly_future_consistent P I D (rel_ipurge P I D)\n  xs @ [y] \\<in> traces P\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n    \\<in> failures P", "using B"], ["proof (prove)\nusing this:\n  ref_union_closed P\n  weakly_future_consistent P I D (rel_ipurge P I D)\n  xs @ [y] \\<in> traces P\n  (xs @ zs, Z) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n    \\<in> failures P", "by (rule iu_condition_imply_secure_2)"], ["proof (state)\nthis:\n  (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n  \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (xs @ ipurge_tr I D (D y) ys, ipurge_ref I D (D y) ys Y)\n  \\<in> failures P \\<and>\n  (xs @ y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs Z)\n  \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"The Ipurge Unwinding Theorem: proof of condition necessity\""], ["", "text \\<open>\nHere below, it is proven that the condition expressed by the Ipurge Unwinding Theorem is necessary\nfor security. Finally, the lemmas concerning condition sufficiency and necessity are gathered in the\nmain theorem.\n\n\\null\n\\<close>"], ["", "lemma secure_implies_failure_consistency_aux [rule_format]:\n  assumes S: \"secure P I D\"\n  shows \"(xs @ ys @ zs, X) \\<in> failures P \\<longrightarrow>\n    ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys = [] \\<longrightarrow> (xs @ zs, X) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs @ ys @ zs, X) \\<in> failures P \\<longrightarrow>\n    ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys =\n    [] \\<longrightarrow>\n    (xs @ zs, X) \\<in> failures P", "proof (induction ys rule: rev_induct, simp_all, (rule impI)+)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>(xs @ xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                [] \\<longrightarrow>\n                (xs @ zs, X) \\<in> failures P;\n        (xs @ xsa @ x # zs, X) \\<in> failures P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xsa @ [x]) =\n        []\\<rbrakk>\n       \\<Longrightarrow> (xs @ zs, X) \\<in> failures P", "fix y ys"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>(xs @ xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                [] \\<longrightarrow>\n                (xs @ zs, X) \\<in> failures P;\n        (xs @ xsa @ x # zs, X) \\<in> failures P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xsa @ [x]) =\n        []\\<rbrakk>\n       \\<Longrightarrow> (xs @ zs, X) \\<in> failures P", "assume *: \"ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (ys @ [y]) = []\""], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (ys @ [y]) = []\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>(xs @ xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                [] \\<longrightarrow>\n                (xs @ zs, X) \\<in> failures P;\n        (xs @ xsa @ x # zs, X) \\<in> failures P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xsa @ [x]) =\n        []\\<rbrakk>\n       \\<Longrightarrow> (xs @ zs, X) \\<in> failures P", "then"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (ys @ [y]) = []", "have A: \"\\<not> (\\<exists>v \\<in> D ` (X \\<union> set zs). (D y, v) \\<in> I)\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (ys @ [y]) = []\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs). (D y, v) \\<in> I)", "by (cases \"\\<exists>v \\<in> D ` (X \\<union> set zs). (D y, v) \\<in> I\",\n        simp_all add: ipurge_tr_rev_aux_append)"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs). (D y, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>(xs @ xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                [] \\<longrightarrow>\n                (xs @ zs, X) \\<in> failures P;\n        (xs @ xsa @ x # zs, X) \\<in> failures P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xsa @ [x]) =\n        []\\<rbrakk>\n       \\<Longrightarrow> (xs @ zs, X) \\<in> failures P", "with *"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (ys @ [y]) = []\n  \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs). (D y, v) \\<in> I)", "have B: \"ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys = []\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (ys @ [y]) = []\n  \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs). (D y, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys = []", "by (simp add: ipurge_tr_rev_aux_append)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys = []\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>(xs @ xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                [] \\<longrightarrow>\n                (xs @ zs, X) \\<in> failures P;\n        (xs @ xsa @ x # zs, X) \\<in> failures P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xsa @ [x]) =\n        []\\<rbrakk>\n       \\<Longrightarrow> (xs @ zs, X) \\<in> failures P", "assume \"(xs @ ys @ y # zs, X) \\<in> failures P\""], ["proof (state)\nthis:\n  (xs @ ys @ y # zs, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>(xs @ xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                [] \\<longrightarrow>\n                (xs @ zs, X) \\<in> failures P;\n        (xs @ xsa @ x # zs, X) \\<in> failures P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xsa @ [x]) =\n        []\\<rbrakk>\n       \\<Longrightarrow> (xs @ zs, X) \\<in> failures P", "hence \"(y # zs, X) \\<in> futures P (xs @ ys)\""], ["proof (prove)\nusing this:\n  (xs @ ys @ y # zs, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (y # zs, X) \\<in> futures P (xs @ ys)", "by (simp add: futures_def)"], ["proof (state)\nthis:\n  (y # zs, X) \\<in> futures P (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>(xs @ xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                [] \\<longrightarrow>\n                (xs @ zs, X) \\<in> failures P;\n        (xs @ xsa @ x # zs, X) \\<in> failures P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xsa @ [x]) =\n        []\\<rbrakk>\n       \\<Longrightarrow> (xs @ zs, X) \\<in> failures P", "hence \"(ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs X)\n    \\<in> futures P (xs @ ys)\""], ["proof (prove)\nusing this:\n  (y # zs, X) \\<in> futures P (xs @ ys)\n\ngoal (1 subgoal):\n 1. (ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs X)\n    \\<in> futures P (xs @ ys)", "using S"], ["proof (prove)\nusing this:\n  (y # zs, X) \\<in> futures P (xs @ ys)\n  secure P I D\n\ngoal (1 subgoal):\n 1. (ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs X)\n    \\<in> futures P (xs @ ys)", "by (simp add: secure_def)"], ["proof (state)\nthis:\n  (ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs X)\n  \\<in> futures P (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>(xs @ xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                [] \\<longrightarrow>\n                (xs @ zs, X) \\<in> failures P;\n        (xs @ xsa @ x # zs, X) \\<in> failures P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xsa @ [x]) =\n        []\\<rbrakk>\n       \\<Longrightarrow> (xs @ zs, X) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs X)\n  \\<in> futures P (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>(xs @ xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                [] \\<longrightarrow>\n                (xs @ zs, X) \\<in> failures P;\n        (xs @ xsa @ x # zs, X) \\<in> failures P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xsa @ [x]) =\n        []\\<rbrakk>\n       \\<Longrightarrow> (xs @ zs, X) \\<in> failures P", "have \"ipurge_tr I D (D y) zs = zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr I D (D y) zs = zs", "using A"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs). (D y, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr I D (D y) zs = zs", "by (simp add: ipurge_tr_all)"], ["proof (state)\nthis:\n  ipurge_tr I D (D y) zs = zs\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>(xs @ xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                [] \\<longrightarrow>\n                (xs @ zs, X) \\<in> failures P;\n        (xs @ xsa @ x # zs, X) \\<in> failures P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xsa @ [x]) =\n        []\\<rbrakk>\n       \\<Longrightarrow> (xs @ zs, X) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  ipurge_tr I D (D y) zs = zs\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>(xs @ xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                [] \\<longrightarrow>\n                (xs @ zs, X) \\<in> failures P;\n        (xs @ xsa @ x # zs, X) \\<in> failures P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xsa @ [x]) =\n        []\\<rbrakk>\n       \\<Longrightarrow> (xs @ zs, X) \\<in> failures P", "have \"ipurge_ref I D (D y) zs X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref I D (D y) zs X = X", "using A"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs). (D y, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_ref I D (D y) zs X = X", "by (rule ipurge_ref_all)"], ["proof (state)\nthis:\n  ipurge_ref I D (D y) zs X = X\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>(xs @ xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                [] \\<longrightarrow>\n                (xs @ zs, X) \\<in> failures P;\n        (xs @ xsa @ x # zs, X) \\<in> failures P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xsa @ [x]) =\n        []\\<rbrakk>\n       \\<Longrightarrow> (xs @ zs, X) \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs X)\n  \\<in> futures P (xs @ ys)\n  ipurge_tr I D (D y) zs = zs\n  ipurge_ref I D (D y) zs X = X", "have \"(zs, X) \\<in> futures P (xs @ ys)\""], ["proof (prove)\nusing this:\n  (ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs X)\n  \\<in> futures P (xs @ ys)\n  ipurge_tr I D (D y) zs = zs\n  ipurge_ref I D (D y) zs X = X\n\ngoal (1 subgoal):\n 1. (zs, X) \\<in> futures P (xs @ ys)", "by simp"], ["proof (state)\nthis:\n  (zs, X) \\<in> futures P (xs @ ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>(xs @ xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                [] \\<longrightarrow>\n                (xs @ zs, X) \\<in> failures P;\n        (xs @ xsa @ x # zs, X) \\<in> failures P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xsa @ [x]) =\n        []\\<rbrakk>\n       \\<Longrightarrow> (xs @ zs, X) \\<in> failures P", "hence C: \"(xs @ ys @ zs, X) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (zs, X) \\<in> futures P (xs @ ys)\n\ngoal (1 subgoal):\n 1. (xs @ ys @ zs, X) \\<in> failures P", "by (simp add: futures_def)"], ["proof (state)\nthis:\n  (xs @ ys @ zs, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>(xs @ xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                [] \\<longrightarrow>\n                (xs @ zs, X) \\<in> failures P;\n        (xs @ xsa @ x # zs, X) \\<in> failures P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xsa @ [x]) =\n        []\\<rbrakk>\n       \\<Longrightarrow> (xs @ zs, X) \\<in> failures P", "assume \"(xs @ ys @ zs, X) \\<in> failures P \\<longrightarrow>\n    ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys = [] \\<longrightarrow>\n    (xs @ zs, X) \\<in> failures P\""], ["proof (state)\nthis:\n  (xs @ ys @ zs, X) \\<in> failures P \\<longrightarrow>\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys = [] \\<longrightarrow>\n  (xs @ zs, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>(xs @ xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                [] \\<longrightarrow>\n                (xs @ zs, X) \\<in> failures P;\n        (xs @ xsa @ x # zs, X) \\<in> failures P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xsa @ [x]) =\n        []\\<rbrakk>\n       \\<Longrightarrow> (xs @ zs, X) \\<in> failures P", "hence \"ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys = [] \\<longrightarrow>\n    (xs @ zs, X) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (xs @ ys @ zs, X) \\<in> failures P \\<longrightarrow>\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys = [] \\<longrightarrow>\n  (xs @ zs, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys =\n    [] \\<longrightarrow>\n    (xs @ zs, X) \\<in> failures P", "using C"], ["proof (prove)\nusing this:\n  (xs @ ys @ zs, X) \\<in> failures P \\<longrightarrow>\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys = [] \\<longrightarrow>\n  (xs @ zs, X) \\<in> failures P\n  (xs @ ys @ zs, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys =\n    [] \\<longrightarrow>\n    (xs @ zs, X) \\<in> failures P", ".."], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys = [] \\<longrightarrow>\n  (xs @ zs, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>x xsa.\n       \\<lbrakk>(xs @ xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                [] \\<longrightarrow>\n                (xs @ zs, X) \\<in> failures P;\n        (xs @ xsa @ x # zs, X) \\<in> failures P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xsa @ [x]) =\n        []\\<rbrakk>\n       \\<Longrightarrow> (xs @ zs, X) \\<in> failures P", "thus \"(xs @ zs, X) \\<in> failures P\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys = [] \\<longrightarrow>\n  (xs @ zs, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (xs @ zs, X) \\<in> failures P", "using B"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys = [] \\<longrightarrow>\n  (xs @ zs, X) \\<in> failures P\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys = []\n\ngoal (1 subgoal):\n 1. (xs @ zs, X) \\<in> failures P", ".."], ["proof (state)\nthis:\n  (xs @ zs, X) \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma secure_implies_failure_consistency [rule_format]:\n  assumes S: \"secure P I D\"\n  shows \"(xs, ys) \\<in> rel_ipurge_aux P I D (D ` (X \\<union> set zs)) \\<longrightarrow>\n    (xs @ zs, X) \\<in> failures P \\<longrightarrow> (ys @ zs, X) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs, ys)\n    \\<in> rel_ipurge_aux P I D (D ` (X \\<union> set zs)) \\<longrightarrow>\n    (xs @ zs, X) \\<in> failures P \\<longrightarrow>\n    (ys @ zs, X) \\<in> failures P", "proof (induction ys arbitrary: xs zs rule: rev_induct,\n simp_all add: rel_ipurge_aux_def, (rule_tac [!] impI)+, (erule_tac [!] conjE)+)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs zs.\n       \\<lbrakk>(xs @ zs, X) \\<in> failures P; xs \\<in> traces P;\n        [] \\<in> traces P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs = []\\<rbrakk>\n       \\<Longrightarrow> (zs, X) \\<in> failures P\n 2. \\<And>x xs xsa zs.\n       \\<lbrakk>\\<And>xsa zs.\n                   xsa \\<in> traces P \\<and>\n                   xs \\<in> traces P \\<and>\n                   ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                   ipurge_tr_rev_aux I D (D ` (X \\<union> set zs))\n                    xs \\<longrightarrow>\n                   (xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                   (xs @ zs, X) \\<in> failures P;\n        (xsa @ zs, X) \\<in> failures P; xsa \\<in> traces P;\n        xs @ [x] \\<in> traces P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> (xs @ x # zs, X) \\<in> failures P", "fix xs zs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs zs.\n       \\<lbrakk>(xs @ zs, X) \\<in> failures P; xs \\<in> traces P;\n        [] \\<in> traces P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs = []\\<rbrakk>\n       \\<Longrightarrow> (zs, X) \\<in> failures P\n 2. \\<And>x xs xsa zs.\n       \\<lbrakk>\\<And>xsa zs.\n                   xsa \\<in> traces P \\<and>\n                   xs \\<in> traces P \\<and>\n                   ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                   ipurge_tr_rev_aux I D (D ` (X \\<union> set zs))\n                    xs \\<longrightarrow>\n                   (xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                   (xs @ zs, X) \\<in> failures P;\n        (xsa @ zs, X) \\<in> failures P; xsa \\<in> traces P;\n        xs @ [x] \\<in> traces P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> (xs @ x # zs, X) \\<in> failures P", "assume \"(xs @ zs, X) \\<in> failures P\""], ["proof (state)\nthis:\n  (xs @ zs, X) \\<in> failures P\n\ngoal (2 subgoals):\n 1. \\<And>xs zs.\n       \\<lbrakk>(xs @ zs, X) \\<in> failures P; xs \\<in> traces P;\n        [] \\<in> traces P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs = []\\<rbrakk>\n       \\<Longrightarrow> (zs, X) \\<in> failures P\n 2. \\<And>x xs xsa zs.\n       \\<lbrakk>\\<And>xsa zs.\n                   xsa \\<in> traces P \\<and>\n                   xs \\<in> traces P \\<and>\n                   ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                   ipurge_tr_rev_aux I D (D ` (X \\<union> set zs))\n                    xs \\<longrightarrow>\n                   (xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                   (xs @ zs, X) \\<in> failures P;\n        (xsa @ zs, X) \\<in> failures P; xsa \\<in> traces P;\n        xs @ [x] \\<in> traces P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> (xs @ x # zs, X) \\<in> failures P", "hence \"([] @ xs @ zs, X) \\<in> failures P\""], ["proof (prove)\nusing this:\n  (xs @ zs, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. ([] @ xs @ zs, X) \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  ([] @ xs @ zs, X) \\<in> failures P\n\ngoal (2 subgoals):\n 1. \\<And>xs zs.\n       \\<lbrakk>(xs @ zs, X) \\<in> failures P; xs \\<in> traces P;\n        [] \\<in> traces P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs = []\\<rbrakk>\n       \\<Longrightarrow> (zs, X) \\<in> failures P\n 2. \\<And>x xs xsa zs.\n       \\<lbrakk>\\<And>xsa zs.\n                   xsa \\<in> traces P \\<and>\n                   xs \\<in> traces P \\<and>\n                   ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                   ipurge_tr_rev_aux I D (D ` (X \\<union> set zs))\n                    xs \\<longrightarrow>\n                   (xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                   (xs @ zs, X) \\<in> failures P;\n        (xsa @ zs, X) \\<in> failures P; xsa \\<in> traces P;\n        xs @ [x] \\<in> traces P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> (xs @ x # zs, X) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  ([] @ xs @ zs, X) \\<in> failures P\n\ngoal (2 subgoals):\n 1. \\<And>xs zs.\n       \\<lbrakk>(xs @ zs, X) \\<in> failures P; xs \\<in> traces P;\n        [] \\<in> traces P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs = []\\<rbrakk>\n       \\<Longrightarrow> (zs, X) \\<in> failures P\n 2. \\<And>x xs xsa zs.\n       \\<lbrakk>\\<And>xsa zs.\n                   xsa \\<in> traces P \\<and>\n                   xs \\<in> traces P \\<and>\n                   ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                   ipurge_tr_rev_aux I D (D ` (X \\<union> set zs))\n                    xs \\<longrightarrow>\n                   (xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                   (xs @ zs, X) \\<in> failures P;\n        (xsa @ zs, X) \\<in> failures P; xsa \\<in> traces P;\n        xs @ [x] \\<in> traces P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> (xs @ x # zs, X) \\<in> failures P", "assume \"ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs = []\""], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs = []\n\ngoal (2 subgoals):\n 1. \\<And>xs zs.\n       \\<lbrakk>(xs @ zs, X) \\<in> failures P; xs \\<in> traces P;\n        [] \\<in> traces P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs = []\\<rbrakk>\n       \\<Longrightarrow> (zs, X) \\<in> failures P\n 2. \\<And>x xs xsa zs.\n       \\<lbrakk>\\<And>xsa zs.\n                   xsa \\<in> traces P \\<and>\n                   xs \\<in> traces P \\<and>\n                   ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                   ipurge_tr_rev_aux I D (D ` (X \\<union> set zs))\n                    xs \\<longrightarrow>\n                   (xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                   (xs @ zs, X) \\<in> failures P;\n        (xsa @ zs, X) \\<in> failures P; xsa \\<in> traces P;\n        xs @ [x] \\<in> traces P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> (xs @ x # zs, X) \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  ([] @ xs @ zs, X) \\<in> failures P\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs = []", "have \"([] @ zs, X) \\<in> failures P\""], ["proof (prove)\nusing this:\n  ([] @ xs @ zs, X) \\<in> failures P\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs = []\n\ngoal (1 subgoal):\n 1. ([] @ zs, X) \\<in> failures P", "using S"], ["proof (prove)\nusing this:\n  ([] @ xs @ zs, X) \\<in> failures P\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs = []\n  secure P I D\n\ngoal (1 subgoal):\n 1. ([] @ zs, X) \\<in> failures P", "by (rule_tac secure_implies_failure_consistency_aux)"], ["proof (state)\nthis:\n  ([] @ zs, X) \\<in> failures P\n\ngoal (2 subgoals):\n 1. \\<And>xs zs.\n       \\<lbrakk>(xs @ zs, X) \\<in> failures P; xs \\<in> traces P;\n        [] \\<in> traces P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs = []\\<rbrakk>\n       \\<Longrightarrow> (zs, X) \\<in> failures P\n 2. \\<And>x xs xsa zs.\n       \\<lbrakk>\\<And>xsa zs.\n                   xsa \\<in> traces P \\<and>\n                   xs \\<in> traces P \\<and>\n                   ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                   ipurge_tr_rev_aux I D (D ` (X \\<union> set zs))\n                    xs \\<longrightarrow>\n                   (xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                   (xs @ zs, X) \\<in> failures P;\n        (xsa @ zs, X) \\<in> failures P; xsa \\<in> traces P;\n        xs @ [x] \\<in> traces P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> (xs @ x # zs, X) \\<in> failures P", "thus \"(zs, X) \\<in> failures P\""], ["proof (prove)\nusing this:\n  ([] @ zs, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (zs, X) \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (zs, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa zs.\n       \\<lbrakk>\\<And>xsa zs.\n                   xsa \\<in> traces P \\<and>\n                   xs \\<in> traces P \\<and>\n                   ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                   ipurge_tr_rev_aux I D (D ` (X \\<union> set zs))\n                    xs \\<longrightarrow>\n                   (xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                   (xs @ zs, X) \\<in> failures P;\n        (xsa @ zs, X) \\<in> failures P; xsa \\<in> traces P;\n        xs @ [x] \\<in> traces P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> (xs @ x # zs, X) \\<in> failures P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs xsa zs.\n       \\<lbrakk>\\<And>xsa zs.\n                   xsa \\<in> traces P \\<and>\n                   xs \\<in> traces P \\<and>\n                   ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                   ipurge_tr_rev_aux I D (D ` (X \\<union> set zs))\n                    xs \\<longrightarrow>\n                   (xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                   (xs @ zs, X) \\<in> failures P;\n        (xsa @ zs, X) \\<in> failures P; xsa \\<in> traces P;\n        xs @ [x] \\<in> traces P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> (xs @ x # zs, X) \\<in> failures P", "fix y ys xs zs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs xsa zs.\n       \\<lbrakk>\\<And>xsa zs.\n                   xsa \\<in> traces P \\<and>\n                   xs \\<in> traces P \\<and>\n                   ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                   ipurge_tr_rev_aux I D (D ` (X \\<union> set zs))\n                    xs \\<longrightarrow>\n                   (xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                   (xs @ zs, X) \\<in> failures P;\n        (xsa @ zs, X) \\<in> failures P; xsa \\<in> traces P;\n        xs @ [x] \\<in> traces P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> (xs @ x # zs, X) \\<in> failures P", "assume\n    A: \"\\<And>xs' zs'. xs' \\<in> traces P \\<and> ys \\<in> traces P \\<and>\n      ipurge_tr_rev_aux I D (D ` (X \\<union> set zs')) xs' =\n      ipurge_tr_rev_aux I D (D ` (X \\<union> set zs')) ys \\<longrightarrow>\n      (xs' @ zs', X) \\<in> failures P \\<longrightarrow> (ys @ zs', X) \\<in> failures P\" and\n    B: \"(xs @ zs, X) \\<in> failures P\" and\n    C: \"xs \\<in> traces P\" and\n    D: \"ys @ [y] \\<in> traces P\" and\n    E: \"ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n      ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (ys @ [y])\""], ["proof (state)\nthis:\n  ?xs' \\<in> traces P \\<and>\n  ys \\<in> traces P \\<and>\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set ?zs')) ?xs' =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set ?zs')) ys \\<longrightarrow>\n  (?xs' @ ?zs', X) \\<in> failures P \\<longrightarrow>\n  (ys @ ?zs', X) \\<in> failures P\n  (xs @ zs, X) \\<in> failures P\n  xs \\<in> traces P\n  ys @ [y] \\<in> traces P\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (ys @ [y])\n\ngoal (1 subgoal):\n 1. \\<And>x xs xsa zs.\n       \\<lbrakk>\\<And>xsa zs.\n                   xsa \\<in> traces P \\<and>\n                   xs \\<in> traces P \\<and>\n                   ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n                   ipurge_tr_rev_aux I D (D ` (X \\<union> set zs))\n                    xs \\<longrightarrow>\n                   (xsa @ zs, X) \\<in> failures P \\<longrightarrow>\n                   (xs @ zs, X) \\<in> failures P;\n        (xsa @ zs, X) \\<in> failures P; xsa \\<in> traces P;\n        xs @ [x] \\<in> traces P;\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xsa =\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (xs @ [x])\\<rbrakk>\n       \\<Longrightarrow> (xs @ x # zs, X) \\<in> failures P", "show \"(ys @ y # zs, X) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ys @ y # zs, X) \\<in> failures P", "proof (cases \"\\<exists>v \\<in> D ` (X \\<union> set zs). (D y, v) \\<in> I\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs).\n       (D y, v) \\<in> I \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P\n 2. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "case True"], ["proof (state)\nthis:\n  \\<exists>v\\<in>D ` (X \\<union> set zs). (D y, v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs).\n       (D y, v) \\<in> I \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P\n 2. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "hence F: \"ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n      ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) ys @ [y]\""], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>D ` (X \\<union> set zs). (D y, v) \\<in> I\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n    ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) ys @ [y]", "using E"], ["proof (prove)\nusing this:\n  \\<exists>v\\<in>D ` (X \\<union> set zs). (D y, v) \\<in> I\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (ys @ [y])\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n    ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) ys @ [y]", "by (simp add: ipurge_tr_rev_aux_append)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) ys @ [y]\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs).\n       (D y, v) \\<in> I \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P\n 2. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "hence\n     \"\\<exists>vs ws. xs = vs @ y # ws \\<and> ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ws = []\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) ys @ [y]\n\ngoal (1 subgoal):\n 1. \\<exists>vs ws.\n       xs = vs @ y # ws \\<and>\n       ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ws = []", "by (rule ipurge_tr_rev_aux_last_2)"], ["proof (state)\nthis:\n  \\<exists>vs ws.\n     xs = vs @ y # ws \\<and>\n     ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ws = []\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs).\n       (D y, v) \\<in> I \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P\n 2. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "then"], ["proof (chain)\npicking this:\n  \\<exists>vs ws.\n     xs = vs @ y # ws \\<and>\n     ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ws = []", "obtain vs and ws where\n      G: \"xs = vs @ y # ws \\<and> ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ws = []\""], ["proof (prove)\nusing this:\n  \\<exists>vs ws.\n     xs = vs @ y # ws \\<and>\n     ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ws = []\n\ngoal (1 subgoal):\n 1. (\\<And>vs ws.\n        xs = vs @ y # ws \\<and>\n        ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ws =\n        [] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  xs = vs @ y # ws \\<and>\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ws = []\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs).\n       (D y, v) \\<in> I \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P\n 2. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "hence \"ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n      ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ((vs @ [y]) @ ws)\""], ["proof (prove)\nusing this:\n  xs = vs @ y # ws \\<and>\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ws = []\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n    ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ((vs @ [y]) @ ws)", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ((vs @ [y]) @ ws)\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs).\n       (D y, v) \\<in> I \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P\n 2. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "hence \"ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n      ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (vs @ [y])\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ((vs @ [y]) @ ws)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n    ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (vs @ [y])", "using G"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ((vs @ [y]) @ ws)\n  xs = vs @ y # ws \\<and>\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ws = []\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n    ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (vs @ [y])", "by (simp only: ipurge_tr_rev_aux_append_nil)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (vs @ [y])\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs).\n       (D y, v) \\<in> I \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P\n 2. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (vs @ [y])\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs).\n       (D y, v) \\<in> I \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P\n 2. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "have \"\\<exists>v \\<in> D ` (X \\<union> set zs). (D y, v) \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs). (D y, v) \\<in> I", "using F"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) ys @ [y]\n\ngoal (1 subgoal):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs). (D y, v) \\<in> I", "by (rule ipurge_tr_rev_aux_last_1)"], ["proof (state)\nthis:\n  \\<exists>v\\<in>D ` (X \\<union> set zs). (D y, v) \\<in> I\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs).\n       (D y, v) \\<in> I \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P\n 2. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (vs @ [y])\n  \\<exists>v\\<in>D ` (X \\<union> set zs). (D y, v) \\<in> I", "have \"ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n      ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) vs @ [y]\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (vs @ [y])\n  \\<exists>v\\<in>D ` (X \\<union> set zs). (D y, v) \\<in> I\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n    ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) vs @ [y]", "by (simp add: ipurge_tr_rev_aux_append)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) vs @ [y]\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs).\n       (D y, v) \\<in> I \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P\n 2. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "hence \"ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) vs =\n      ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) ys\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) vs @ [y]\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) vs =\n    ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) ys", "using F"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) vs @ [y]\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) ys @ [y]\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) vs =\n    ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) ys", "by simp"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) vs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) ys\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs).\n       (D y, v) \\<in> I \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P\n 2. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) vs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) ys\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs).\n       (D y, v) \\<in> I \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P\n 2. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "have \"vs @ y # ws \\<in> traces P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs @ y # ws \\<in> traces P", "using C and G"], ["proof (prove)\nusing this:\n  xs \\<in> traces P\n  xs = vs @ y # ws \\<and>\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ws = []\n\ngoal (1 subgoal):\n 1. vs @ y # ws \\<in> traces P", "by simp"], ["proof (state)\nthis:\n  vs @ y # ws \\<in> traces P\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs).\n       (D y, v) \\<in> I \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P\n 2. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "hence \"vs \\<in> traces P\""], ["proof (prove)\nusing this:\n  vs @ y # ws \\<in> traces P\n\ngoal (1 subgoal):\n 1. vs \\<in> traces P", "by (rule process_rule_2_traces)"], ["proof (state)\nthis:\n  vs \\<in> traces P\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs).\n       (D y, v) \\<in> I \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P\n 2. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  vs \\<in> traces P\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs).\n       (D y, v) \\<in> I \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P\n 2. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "have \"ys \\<in> traces P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<in> traces P", "using D"], ["proof (prove)\nusing this:\n  ys @ [y] \\<in> traces P\n\ngoal (1 subgoal):\n 1. ys \\<in> traces P", "by (rule process_rule_2_traces)"], ["proof (state)\nthis:\n  ys \\<in> traces P\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs).\n       (D y, v) \\<in> I \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P\n 2. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  ys \\<in> traces P\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs).\n       (D y, v) \\<in> I \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P\n 2. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "have \"vs \\<in> traces P \\<and> ys \\<in> traces P \\<and>\n      ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) vs =\n      ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) ys \\<longrightarrow>\n      (vs @ y # zs, X) \\<in> failures P \\<longrightarrow> (ys @ y # zs, X) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs \\<in> traces P \\<and>\n    ys \\<in> traces P \\<and>\n    ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) vs =\n    ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs)))\n     ys \\<longrightarrow>\n    (vs @ y # zs, X) \\<in> failures P \\<longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "using A"], ["proof (prove)\nusing this:\n  ?xs' \\<in> traces P \\<and>\n  ys \\<in> traces P \\<and>\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set ?zs')) ?xs' =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set ?zs')) ys \\<longrightarrow>\n  (?xs' @ ?zs', X) \\<in> failures P \\<longrightarrow>\n  (ys @ ?zs', X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. vs \\<in> traces P \\<and>\n    ys \\<in> traces P \\<and>\n    ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) vs =\n    ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs)))\n     ys \\<longrightarrow>\n    (vs @ y # zs, X) \\<in> failures P \\<longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "."], ["proof (state)\nthis:\n  vs \\<in> traces P \\<and>\n  ys \\<in> traces P \\<and>\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) vs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) ys \\<longrightarrow>\n  (vs @ y # zs, X) \\<in> failures P \\<longrightarrow>\n  (ys @ y # zs, X) \\<in> failures P\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs).\n       (D y, v) \\<in> I \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P\n 2. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) vs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) ys\n  vs \\<in> traces P\n  ys \\<in> traces P\n  vs \\<in> traces P \\<and>\n  ys \\<in> traces P \\<and>\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) vs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) ys \\<longrightarrow>\n  (vs @ y # zs, X) \\<in> failures P \\<longrightarrow>\n  (ys @ y # zs, X) \\<in> failures P", "have H: \"(vs @ y # zs, X) \\<in> failures P \\<longrightarrow>\n      (ys @ y # zs, X) \\<in> failures P\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) vs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) ys\n  vs \\<in> traces P\n  ys \\<in> traces P\n  vs \\<in> traces P \\<and>\n  ys \\<in> traces P \\<and>\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) vs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set (y # zs))) ys \\<longrightarrow>\n  (vs @ y # zs, X) \\<in> failures P \\<longrightarrow>\n  (ys @ y # zs, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (vs @ y # zs, X) \\<in> failures P \\<longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (vs @ y # zs, X) \\<in> failures P \\<longrightarrow>\n  (ys @ y # zs, X) \\<in> failures P\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs).\n       (D y, v) \\<in> I \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P\n 2. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "have \"((vs @ [y]) @ ws @ zs, X) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((vs @ [y]) @ ws @ zs, X) \\<in> failures P", "using B and G"], ["proof (prove)\nusing this:\n  (xs @ zs, X) \\<in> failures P\n  xs = vs @ y # ws \\<and>\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ws = []\n\ngoal (1 subgoal):\n 1. ((vs @ [y]) @ ws @ zs, X) \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  ((vs @ [y]) @ ws @ zs, X) \\<in> failures P\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs).\n       (D y, v) \\<in> I \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P\n 2. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  ((vs @ [y]) @ ws @ zs, X) \\<in> failures P\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs).\n       (D y, v) \\<in> I \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P\n 2. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "have \"ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ws = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ws = []", "using G"], ["proof (prove)\nusing this:\n  xs = vs @ y # ws \\<and>\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ws = []\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ws = []", ".."], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ws = []\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs).\n       (D y, v) \\<in> I \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P\n 2. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  ((vs @ [y]) @ ws @ zs, X) \\<in> failures P\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ws = []", "have \"((vs @ [y]) @ zs, X) \\<in> failures P\""], ["proof (prove)\nusing this:\n  ((vs @ [y]) @ ws @ zs, X) \\<in> failures P\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ws = []\n\ngoal (1 subgoal):\n 1. ((vs @ [y]) @ zs, X) \\<in> failures P", "using S"], ["proof (prove)\nusing this:\n  ((vs @ [y]) @ ws @ zs, X) \\<in> failures P\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ws = []\n  secure P I D\n\ngoal (1 subgoal):\n 1. ((vs @ [y]) @ zs, X) \\<in> failures P", "by (rule_tac secure_implies_failure_consistency_aux)"], ["proof (state)\nthis:\n  ((vs @ [y]) @ zs, X) \\<in> failures P\n\ngoal (2 subgoals):\n 1. \\<exists>v\\<in>D ` (X \\<union> set zs).\n       (D y, v) \\<in> I \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P\n 2. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((vs @ [y]) @ zs, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (ys @ y # zs, X) \\<in> failures P", "using H"], ["proof (prove)\nusing this:\n  ((vs @ [y]) @ zs, X) \\<in> failures P\n  (vs @ y # zs, X) \\<in> failures P \\<longrightarrow>\n  (ys @ y # zs, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (ys @ y # zs, X) \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (ys @ y # zs, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs). (D y, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "hence \"ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n      ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs). (D y, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n    ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys", "using E"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs). (D y, v) \\<in> I)\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) (ys @ [y])\n\ngoal (1 subgoal):\n 1. ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n    ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys", "by (simp add: ipurge_tr_rev_aux_append)"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "have \"ys \\<in> traces P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys \\<in> traces P", "using D"], ["proof (prove)\nusing this:\n  ys @ [y] \\<in> traces P\n\ngoal (1 subgoal):\n 1. ys \\<in> traces P", "by (rule process_rule_2_traces)"], ["proof (state)\nthis:\n  ys \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  ys \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "have \"xs \\<in> traces P \\<and> ys \\<in> traces P \\<and>\n      ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n      ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys \\<longrightarrow>\n      (xs @ zs, X) \\<in> failures P \\<longrightarrow> (ys @ zs, X) \\<in> failures P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<in> traces P \\<and>\n    ys \\<in> traces P \\<and>\n    ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n    ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys \\<longrightarrow>\n    (xs @ zs, X) \\<in> failures P \\<longrightarrow>\n    (ys @ zs, X) \\<in> failures P", "using A"], ["proof (prove)\nusing this:\n  ?xs' \\<in> traces P \\<and>\n  ys \\<in> traces P \\<and>\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set ?zs')) ?xs' =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set ?zs')) ys \\<longrightarrow>\n  (?xs' @ ?zs', X) \\<in> failures P \\<longrightarrow>\n  (ys @ ?zs', X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. xs \\<in> traces P \\<and>\n    ys \\<in> traces P \\<and>\n    ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n    ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys \\<longrightarrow>\n    (xs @ zs, X) \\<in> failures P \\<longrightarrow>\n    (ys @ zs, X) \\<in> failures P", "."], ["proof (state)\nthis:\n  xs \\<in> traces P \\<and>\n  ys \\<in> traces P \\<and>\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys \\<longrightarrow>\n  (xs @ zs, X) \\<in> failures P \\<longrightarrow>\n  (ys @ zs, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys\n  ys \\<in> traces P\n  xs \\<in> traces P \\<and>\n  ys \\<in> traces P \\<and>\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys \\<longrightarrow>\n  (xs @ zs, X) \\<in> failures P \\<longrightarrow>\n  (ys @ zs, X) \\<in> failures P", "have \"(ys @ zs, X) \\<in> failures P\""], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys\n  ys \\<in> traces P\n  xs \\<in> traces P \\<and>\n  ys \\<in> traces P \\<and>\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys \\<longrightarrow>\n  (xs @ zs, X) \\<in> failures P \\<longrightarrow>\n  (ys @ zs, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (ys @ zs, X) \\<in> failures P", "using B and C"], ["proof (prove)\nusing this:\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys\n  ys \\<in> traces P\n  xs \\<in> traces P \\<and>\n  ys \\<in> traces P \\<and>\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) xs =\n  ipurge_tr_rev_aux I D (D ` (X \\<union> set zs)) ys \\<longrightarrow>\n  (xs @ zs, X) \\<in> failures P \\<longrightarrow>\n  (ys @ zs, X) \\<in> failures P\n  (xs @ zs, X) \\<in> failures P\n  xs \\<in> traces P\n\ngoal (1 subgoal):\n 1. (ys @ zs, X) \\<in> failures P", "by simp"], ["proof (state)\nthis:\n  (ys @ zs, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "hence \"(zs, X) \\<in> futures P ys\""], ["proof (prove)\nusing this:\n  (ys @ zs, X) \\<in> failures P\n\ngoal (1 subgoal):\n 1. (zs, X) \\<in> futures P ys", "by (simp add: futures_def)"], ["proof (state)\nthis:\n  (zs, X) \\<in> futures P ys\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (zs, X) \\<in> futures P ys\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "have \"\\<exists>Y. ([y], Y) \\<in> futures P ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Y. ([y], Y) \\<in> futures P ys", "using D"], ["proof (prove)\nusing this:\n  ys @ [y] \\<in> traces P\n\ngoal (1 subgoal):\n 1. \\<exists>Y. ([y], Y) \\<in> futures P ys", "by (simp add: traces_def Domain_iff futures_def)"], ["proof (state)\nthis:\n  \\<exists>Y. ([y], Y) \\<in> futures P ys\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "then"], ["proof (chain)\npicking this:\n  \\<exists>Y. ([y], Y) \\<in> futures P ys", "obtain Y where \"([y], Y) \\<in> futures P ys\""], ["proof (prove)\nusing this:\n  \\<exists>Y. ([y], Y) \\<in> futures P ys\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        ([y], Y) \\<in> futures P ys \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", ".."], ["proof (state)\nthis:\n  ([y], Y) \\<in> futures P ys\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (zs, X) \\<in> futures P ys\n  ([y], Y) \\<in> futures P ys", "have\n      \"(y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs X) \\<in> futures P ys\""], ["proof (prove)\nusing this:\n  (zs, X) \\<in> futures P ys\n  ([y], Y) \\<in> futures P ys\n\ngoal (1 subgoal):\n 1. (y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs X)\n    \\<in> futures P ys", "using S"], ["proof (prove)\nusing this:\n  (zs, X) \\<in> futures P ys\n  ([y], Y) \\<in> futures P ys\n  secure P I D\n\ngoal (1 subgoal):\n 1. (y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs X)\n    \\<in> futures P ys", "by (simp add: secure_def)"], ["proof (state)\nthis:\n  (y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs X) \\<in> futures P ys\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  (y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs X) \\<in> futures P ys\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "have \"ipurge_tr I D (D y) zs = zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_tr I D (D y) zs = zs", "using False"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs). (D y, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_tr I D (D y) zs = zs", "by (simp add: ipurge_tr_all)"], ["proof (state)\nthis:\n  ipurge_tr I D (D y) zs = zs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "moreover"], ["proof (state)\nthis:\n  ipurge_tr I D (D y) zs = zs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "have \"ipurge_ref I D (D y) zs X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipurge_ref I D (D y) zs X = X", "using False"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs). (D y, v) \\<in> I)\n\ngoal (1 subgoal):\n 1. ipurge_ref I D (D y) zs X = X", "by (rule ipurge_ref_all)"], ["proof (state)\nthis:\n  ipurge_ref I D (D y) zs X = X\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>v\\<in>D ` (X \\<union> set zs).\n               (D y, v) \\<in> I) \\<Longrightarrow>\n    (ys @ y # zs, X) \\<in> failures P", "ultimately"], ["proof (chain)\npicking this:\n  (y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs X) \\<in> futures P ys\n  ipurge_tr I D (D y) zs = zs\n  ipurge_ref I D (D y) zs X = X", "show ?thesis"], ["proof (prove)\nusing this:\n  (y # ipurge_tr I D (D y) zs, ipurge_ref I D (D y) zs X) \\<in> futures P ys\n  ipurge_tr I D (D y) zs = zs\n  ipurge_ref I D (D y) zs X = X\n\ngoal (1 subgoal):\n 1. (ys @ y # zs, X) \\<in> failures P", "by (simp add: futures_def)"], ["proof (state)\nthis:\n  (ys @ y # zs, X) \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (ys @ y # zs, X) \\<in> failures P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma secure_implies_trace_consistency:\n \"secure P I D \\<Longrightarrow> (xs, ys) \\<in> rel_ipurge_aux P I D (D ` set zs) \\<Longrightarrow>\n  xs @ zs \\<in> traces P \\<Longrightarrow> ys @ zs \\<in> traces P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>secure P I D; (xs, ys) \\<in> rel_ipurge_aux P I D (D ` set zs);\n     xs @ zs \\<in> traces P\\<rbrakk>\n    \\<Longrightarrow> ys @ zs \\<in> traces P", "proof (simp add: traces_def Domain_iff, rule_tac x = \"{}\" in exI,\n rule secure_implies_failure_consistency, simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>secure P I D; (xs, ys) \\<in> rel_ipurge_aux P I D (D ` set zs);\n     \\<exists>y. (xs @ zs, y) \\<in> failures P\\<rbrakk>\n    \\<Longrightarrow> (xs @ zs, {}) \\<in> failures P", "qed (erule exE, erule process_rule_3, simp)"], ["", "lemma secure_implies_next_event_consistency:\n \"secure P I D \\<Longrightarrow> (xs, ys) \\<in> rel_ipurge P I D (D x) \\<Longrightarrow>\n  x \\<in> next_events P xs \\<Longrightarrow> x \\<in> next_events P ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>secure P I D; (xs, ys) \\<in> rel_ipurge P I D (D x);\n     x \\<in> next_events P xs\\<rbrakk>\n    \\<Longrightarrow> x \\<in> next_events P ys", "by (auto simp add: next_events_def rel_ipurge_aux_single_dom intro: secure_implies_trace_consistency)"], ["", "lemma secure_implies_refusal_consistency:\n \"secure P I D \\<Longrightarrow> (xs, ys) \\<in> rel_ipurge_aux P I D (D ` X) \\<Longrightarrow>\n  X \\<in> refusals P xs \\<Longrightarrow> X \\<in> refusals P ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>secure P I D; (xs, ys) \\<in> rel_ipurge_aux P I D (D ` X);\n     X \\<in> refusals P xs\\<rbrakk>\n    \\<Longrightarrow> X \\<in> refusals P ys", "by (simp add: refusals_def, subst append_Nil2 [symmetric],\n rule secure_implies_failure_consistency, simp_all)"], ["", "lemma secure_implies_ref_event_consistency:\n \"secure P I D \\<Longrightarrow> (xs, ys) \\<in> rel_ipurge P I D (D x) \\<Longrightarrow>\n  {x} \\<in> refusals P xs \\<Longrightarrow> {x} \\<in> refusals P ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>secure P I D; (xs, ys) \\<in> rel_ipurge P I D (D x);\n     {x} \\<in> refusals P xs\\<rbrakk>\n    \\<Longrightarrow> {x} \\<in> refusals P ys", "by (rule secure_implies_refusal_consistency, simp_all add: rel_ipurge_aux_single_dom)"], ["", "theorem secure_implies_iu_condition:\n  assumes S: \"secure P I D\"\n  shows \"future_consistent P D (rel_ipurge P I D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. future_consistent P D (rel_ipurge P I D)", "proof (simp add: future_consistent_def next_dom_events_def ref_dom_events_def,\n (rule allI)+, rule impI, rule conjI, rule_tac [!] equalityI, rule_tac [!] subsetI,\n simp_all, erule_tac [!] conjE)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        x \\<in> next_events P xs\\<rbrakk>\n       \\<Longrightarrow> x \\<in> next_events P ys\n 2. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        x \\<in> next_events P ys\\<rbrakk>\n       \\<Longrightarrow> x \\<in> next_events P xs\n 3. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P xs\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P ys\n 4. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "fix xs ys x"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        x \\<in> next_events P xs\\<rbrakk>\n       \\<Longrightarrow> x \\<in> next_events P ys\n 2. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        x \\<in> next_events P ys\\<rbrakk>\n       \\<Longrightarrow> x \\<in> next_events P xs\n 3. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P xs\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P ys\n 4. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "assume \"(xs, ys) \\<in> rel_ipurge P I D (D x)\" and \"x \\<in> next_events P xs\""], ["proof (state)\nthis:\n  (xs, ys) \\<in> rel_ipurge P I D (D x)\n  x \\<in> next_events P xs\n\ngoal (4 subgoals):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        x \\<in> next_events P xs\\<rbrakk>\n       \\<Longrightarrow> x \\<in> next_events P ys\n 2. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        x \\<in> next_events P ys\\<rbrakk>\n       \\<Longrightarrow> x \\<in> next_events P xs\n 3. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P xs\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P ys\n 4. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "with S"], ["proof (chain)\npicking this:\n  secure P I D\n  (xs, ys) \\<in> rel_ipurge P I D (D x)\n  x \\<in> next_events P xs", "show \"x \\<in> next_events P ys\""], ["proof (prove)\nusing this:\n  secure P I D\n  (xs, ys) \\<in> rel_ipurge P I D (D x)\n  x \\<in> next_events P xs\n\ngoal (1 subgoal):\n 1. x \\<in> next_events P ys", "by (rule secure_implies_next_event_consistency)"], ["proof (state)\nthis:\n  x \\<in> next_events P ys\n\ngoal (3 subgoals):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        x \\<in> next_events P ys\\<rbrakk>\n       \\<Longrightarrow> x \\<in> next_events P xs\n 2. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P xs\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P ys\n 3. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        x \\<in> next_events P ys\\<rbrakk>\n       \\<Longrightarrow> x \\<in> next_events P xs\n 2. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P xs\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P ys\n 3. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "fix xs ys x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        x \\<in> next_events P ys\\<rbrakk>\n       \\<Longrightarrow> x \\<in> next_events P xs\n 2. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P xs\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P ys\n 3. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "have \"\\<forall>u \\<in> range D. equiv (traces P) (rel_ipurge P I D u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>range D. equiv (traces P) (rel_ipurge P I D u)", "using view_partition_rel_ipurge"], ["proof (prove)\nusing this:\n  view_partition ?P ?D (rel_ipurge ?P ?I ?D)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>range D. equiv (traces P) (rel_ipurge P I D u)", "by (simp add: view_partition_def)"], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D. equiv (traces P) (rel_ipurge P I D u)\n\ngoal (3 subgoals):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        x \\<in> next_events P ys\\<rbrakk>\n       \\<Longrightarrow> x \\<in> next_events P xs\n 2. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P xs\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P ys\n 3. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "hence \"sym (rel_ipurge P I D (D x))\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>range D. equiv (traces P) (rel_ipurge P I D u)\n\ngoal (1 subgoal):\n 1. sym (rel_ipurge P I D (D x))", "by (simp add: equiv_def)"], ["proof (state)\nthis:\n  sym (rel_ipurge P I D (D x))\n\ngoal (3 subgoals):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        x \\<in> next_events P ys\\<rbrakk>\n       \\<Longrightarrow> x \\<in> next_events P xs\n 2. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P xs\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P ys\n 3. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "moreover"], ["proof (state)\nthis:\n  sym (rel_ipurge P I D (D x))\n\ngoal (3 subgoals):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        x \\<in> next_events P ys\\<rbrakk>\n       \\<Longrightarrow> x \\<in> next_events P xs\n 2. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P xs\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P ys\n 3. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "assume \"(xs, ys) \\<in> rel_ipurge P I D (D x)\""], ["proof (state)\nthis:\n  (xs, ys) \\<in> rel_ipurge P I D (D x)\n\ngoal (3 subgoals):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        x \\<in> next_events P ys\\<rbrakk>\n       \\<Longrightarrow> x \\<in> next_events P xs\n 2. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P xs\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P ys\n 3. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "ultimately"], ["proof (chain)\npicking this:\n  sym (rel_ipurge P I D (D x))\n  (xs, ys) \\<in> rel_ipurge P I D (D x)", "have \"(ys, xs) \\<in> rel_ipurge P I D (D x)\""], ["proof (prove)\nusing this:\n  sym (rel_ipurge P I D (D x))\n  (xs, ys) \\<in> rel_ipurge P I D (D x)\n\ngoal (1 subgoal):\n 1. (ys, xs) \\<in> rel_ipurge P I D (D x)", "by (rule symE)"], ["proof (state)\nthis:\n  (ys, xs) \\<in> rel_ipurge P I D (D x)\n\ngoal (3 subgoals):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        x \\<in> next_events P ys\\<rbrakk>\n       \\<Longrightarrow> x \\<in> next_events P xs\n 2. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P xs\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P ys\n 3. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "moreover"], ["proof (state)\nthis:\n  (ys, xs) \\<in> rel_ipurge P I D (D x)\n\ngoal (3 subgoals):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        x \\<in> next_events P ys\\<rbrakk>\n       \\<Longrightarrow> x \\<in> next_events P xs\n 2. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P xs\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P ys\n 3. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "assume \"x \\<in> next_events P ys\""], ["proof (state)\nthis:\n  x \\<in> next_events P ys\n\ngoal (3 subgoals):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        x \\<in> next_events P ys\\<rbrakk>\n       \\<Longrightarrow> x \\<in> next_events P xs\n 2. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P xs\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P ys\n 3. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "ultimately"], ["proof (chain)\npicking this:\n  (ys, xs) \\<in> rel_ipurge P I D (D x)\n  x \\<in> next_events P ys", "show \"x \\<in> next_events P xs\""], ["proof (prove)\nusing this:\n  (ys, xs) \\<in> rel_ipurge P I D (D x)\n  x \\<in> next_events P ys\n\ngoal (1 subgoal):\n 1. x \\<in> next_events P xs", "using S"], ["proof (prove)\nusing this:\n  (ys, xs) \\<in> rel_ipurge P I D (D x)\n  x \\<in> next_events P ys\n  secure P I D\n\ngoal (1 subgoal):\n 1. x \\<in> next_events P xs", "by (rule_tac secure_implies_next_event_consistency)"], ["proof (state)\nthis:\n  x \\<in> next_events P xs\n\ngoal (2 subgoals):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P xs\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P ys\n 2. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P xs\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P ys\n 2. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "fix xs ys x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P xs\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P ys\n 2. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "assume \"(xs, ys) \\<in> rel_ipurge P I D (D x)\" and \"{x} \\<in> refusals P xs\""], ["proof (state)\nthis:\n  (xs, ys) \\<in> rel_ipurge P I D (D x)\n  {x} \\<in> refusals P xs\n\ngoal (2 subgoals):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P xs\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P ys\n 2. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "with S"], ["proof (chain)\npicking this:\n  secure P I D\n  (xs, ys) \\<in> rel_ipurge P I D (D x)\n  {x} \\<in> refusals P xs", "show \"{x} \\<in> refusals P ys\""], ["proof (prove)\nusing this:\n  secure P I D\n  (xs, ys) \\<in> rel_ipurge P I D (D x)\n  {x} \\<in> refusals P xs\n\ngoal (1 subgoal):\n 1. {x} \\<in> refusals P ys", "by (rule secure_implies_ref_event_consistency)"], ["proof (state)\nthis:\n  {x} \\<in> refusals P ys\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "fix xs ys x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "have \"\\<forall>u \\<in> range D. equiv (traces P) (rel_ipurge P I D u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>range D. equiv (traces P) (rel_ipurge P I D u)", "using view_partition_rel_ipurge"], ["proof (prove)\nusing this:\n  view_partition ?P ?D (rel_ipurge ?P ?I ?D)\n\ngoal (1 subgoal):\n 1. \\<forall>u\\<in>range D. equiv (traces P) (rel_ipurge P I D u)", "by (simp add: view_partition_def)"], ["proof (state)\nthis:\n  \\<forall>u\\<in>range D. equiv (traces P) (rel_ipurge P I D u)\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "hence \"sym (rel_ipurge P I D (D x))\""], ["proof (prove)\nusing this:\n  \\<forall>u\\<in>range D. equiv (traces P) (rel_ipurge P I D u)\n\ngoal (1 subgoal):\n 1. sym (rel_ipurge P I D (D x))", "by (simp add: equiv_def)"], ["proof (state)\nthis:\n  sym (rel_ipurge P I D (D x))\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "moreover"], ["proof (state)\nthis:\n  sym (rel_ipurge P I D (D x))\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "assume \"(xs, ys) \\<in> rel_ipurge P I D (D x)\""], ["proof (state)\nthis:\n  (xs, ys) \\<in> rel_ipurge P I D (D x)\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "ultimately"], ["proof (chain)\npicking this:\n  sym (rel_ipurge P I D (D x))\n  (xs, ys) \\<in> rel_ipurge P I D (D x)", "have \"(ys, xs) \\<in> rel_ipurge P I D (D x)\""], ["proof (prove)\nusing this:\n  sym (rel_ipurge P I D (D x))\n  (xs, ys) \\<in> rel_ipurge P I D (D x)\n\ngoal (1 subgoal):\n 1. (ys, xs) \\<in> rel_ipurge P I D (D x)", "by (rule symE)"], ["proof (state)\nthis:\n  (ys, xs) \\<in> rel_ipurge P I D (D x)\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "moreover"], ["proof (state)\nthis:\n  (ys, xs) \\<in> rel_ipurge P I D (D x)\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "assume \"{x} \\<in> refusals P ys\""], ["proof (state)\nthis:\n  {x} \\<in> refusals P ys\n\ngoal (1 subgoal):\n 1. \\<And>u xs ys x.\n       \\<lbrakk>(xs, ys) \\<in> rel_ipurge P I D (D x); D u = D x;\n        {x} \\<in> refusals P ys\\<rbrakk>\n       \\<Longrightarrow> {x} \\<in> refusals P xs", "ultimately"], ["proof (chain)\npicking this:\n  (ys, xs) \\<in> rel_ipurge P I D (D x)\n  {x} \\<in> refusals P ys", "show \"{x} \\<in> refusals P xs\""], ["proof (prove)\nusing this:\n  (ys, xs) \\<in> rel_ipurge P I D (D x)\n  {x} \\<in> refusals P ys\n\ngoal (1 subgoal):\n 1. {x} \\<in> refusals P xs", "using S"], ["proof (prove)\nusing this:\n  (ys, xs) \\<in> rel_ipurge P I D (D x)\n  {x} \\<in> refusals P ys\n  secure P I D\n\ngoal (1 subgoal):\n 1. {x} \\<in> refusals P xs", "by (rule_tac secure_implies_ref_event_consistency)"], ["proof (state)\nthis:\n  {x} \\<in> refusals P xs\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem ipurge_unwinding:\n \"ref_union_closed P \\<Longrightarrow>\n  secure P I D = weakly_future_consistent P I D (rel_ipurge P I D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ref_union_closed P \\<Longrightarrow>\n    secure P I D = weakly_future_consistent P I D (rel_ipurge P I D)", "proof (rule iffI, subst fc_equals_wfc_rel_ipurge [symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ref_union_closed P; secure P I D\\<rbrakk>\n    \\<Longrightarrow> future_consistent P D (rel_ipurge P I D)\n 2. \\<lbrakk>ref_union_closed P;\n     weakly_future_consistent P I D (rel_ipurge P I D)\\<rbrakk>\n    \\<Longrightarrow> secure P I D", "qed (erule secure_implies_iu_condition, rule iu_condition_imply_secure)"], ["", "end"]]}