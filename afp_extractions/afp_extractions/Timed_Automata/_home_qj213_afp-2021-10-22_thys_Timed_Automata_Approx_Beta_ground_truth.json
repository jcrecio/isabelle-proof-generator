{"file_name": "/home/qj213/afp-2021-10-22/thys/Timed_Automata/Approx_Beta.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Timed_Automata", "problem_names": ["lemma region_dbm:\n  assumes \"R \\<in> \\<R>\"\n  defines \"v' \\<equiv> \\<lambda> i. THE c. c \\<in> X \\<and> v c = i\"\n  obtains M\n  where\"[M]\\<^bsub>v,n\\<^esub> = R\"\n  and \"\\<forall> i \\<le> n. \\<forall> j \\<le> n. M i 0 = \\<infinity> \\<and> j > 0 \\<and> i \\<noteq> j\\<longrightarrow> M i j = \\<infinity> \\<and> M j i = \\<infinity>\"\n  and \"\\<forall> i \\<le> n. M i i = Le 0\"\n  and \"\\<forall> i \\<le> n. \\<forall> j \\<le> n. i > 0 \\<and> j > 0 \\<and> M i 0 \\<noteq> \\<infinity> \\<and> M j 0 \\<noteq> \\<infinity> \\<longrightarrow> (\\<exists> d :: int.\n        (- k (v' j) \\<le> d \\<and> d \\<le> k (v' i) \\<and> M i j = Le d \\<and> M j i = Le (-d))\n      \\<or> (- k (v' j) \\<le> d - 1 \\<and> d \\<le> k (v' i) \\<and> M i j = Lt d \\<and> M j i = Lt (-d + 1)))\"\n  and \"\\<forall> i \\<le> n. i > 0 \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n        (\\<exists> d :: int. d \\<le> k (v' i) \\<and> d \\<ge> 0\n          \\<and> (M i 0 = Le d \\<and> M 0 i = Le (-d) \\<or> M i 0 = Lt d \\<and> M 0 i = Lt (-d + 1)))\"\n  and \"\\<forall> i \\<le> n. i > 0 \\<longrightarrow> (\\<exists> d :: int. - k (v' i) \\<le> d \\<and> d \\<le> 0 \\<and> (M 0 i = Le d \\<or> M 0 i = Lt d))\"\n  and \"\\<forall> i. \\<forall> j. M i j \\<noteq> \\<infinity> \\<longrightarrow> get_const (M i j) \\<in> \\<int>\"\n  and \"\\<forall> i \\<le> n. \\<forall> j \\<le> n. M i j \\<noteq> \\<infinity> \\<and> i > 0 \\<and> j > 0 \\<longrightarrow>\n      (\\<exists> d:: int. (M i j = Le d \\<or> M i j = Lt d) \\<and> (- k (v' j)) \\<le> d \\<and> d \\<le> k (v' i))\"", "lemma len_inf_elem:\n  \"(a, b) \\<in> set (arcs i j xs) \\<Longrightarrow> M a b = \\<infinity> \\<Longrightarrow> len M i j xs = \\<infinity>\"", "lemma dbm_add_strict_right_mono_neutral: \"a < Le d \\<Longrightarrow> a + Le (-d) < Le 0\"", "lemma dbm_lt_not_inf_less[intro]: \"A \\<noteq> \\<infinity> \\<Longrightarrow> A \\<prec> \\<infinity>\"", "lemma add_inf[simp]:\n  \"a + \\<infinity> = \\<infinity>\" \"\\<infinity> + a = \\<infinity>\"", "lemma inf_lt[simp,dest!]:\n  \"\\<infinity> < x \\<Longrightarrow> False\"", "lemma zone_diag_lt:\n  assumes \"a \\<le> n\" \"b \\<le> n\" and C: \"v c1 = a\" \"v c2 = b\" and not0: \"a > 0\" \"b > 0\"\n  shows \"[(\\<lambda> i j. if i = a \\<and> j = b then Lt d else \\<infinity>)]\\<^bsub>v,n\\<^esub> = {u. u c1 - u c2 < d}\"", "lemma zone_diag_le:\n  assumes \"a \\<le> n\" \"b \\<le> n\" and C: \"v c1 = a\" \"v c2 = b\" and not0: \"a > 0\" \"b > 0\"\n  shows \"[(\\<lambda> i j. if i = a \\<and> j = b then Le d else \\<infinity>)]\\<^bsub>v,n\\<^esub> = {u. u c1 - u c2 \\<le> d}\"", "lemma zone_diag_lt_2:\n  assumes \"a \\<le> n\" and C: \"v c = a\" and not0: \"a > 0\"\n  shows \"[(\\<lambda> i j. if i = a \\<and> j = 0 then Lt d else \\<infinity>)]\\<^bsub>v,n\\<^esub> = {u. u c < d}\"", "lemma zone_diag_le_2:\n  assumes \"a \\<le> n\" and C: \"v c = a\" and not0: \"a > 0\"\n  shows \"[(\\<lambda> i j. if i = a \\<and> j = 0 then Le d else \\<infinity>)]\\<^bsub>v,n\\<^esub> = {u. u c \\<le> d}\"", "lemma zone_diag_lt_3:\n  assumes \"a \\<le> n\" and C: \"v c = a\" and not0: \"a > 0\"\n  shows \"[(\\<lambda> i j. if i = 0 \\<and> j = a then Lt d else \\<infinity>)]\\<^bsub>v,n\\<^esub> = {u. - u c < d}\"", "lemma len_int_closed:\n  \"\\<forall> i j. (M i j :: real) \\<in> \\<int> \\<Longrightarrow> len M i j xs \\<in> \\<int>\"", "lemma get_const_distr:\n  \"a \\<noteq> \\<infinity> \\<Longrightarrow> b \\<noteq> \\<infinity> \\<Longrightarrow> get_const (a + b) = get_const a + get_const b\"", "lemma len_int_dbm_closed:\n  \"\\<forall> (i, j) \\<in> set (arcs i j xs). (get_const (M i j) :: real) \\<in> \\<int> \\<and> M i j \\<noteq> \\<infinity>\n  \\<Longrightarrow> get_const (len M i j xs) \\<in> \\<int> \\<and> len M i j xs \\<noteq> \\<infinity>\"", "lemma zone_diag_le_3:\n  assumes \"a \\<le> n\" and C: \"v c = a\" and not0: \"a > 0\"\n  shows \"[(\\<lambda> i j. if i = 0 \\<and> j = a then Le d else \\<infinity>)]\\<^bsub>v,n\\<^esub> = {u. - u c \\<le> d}\"", "lemma dbm_lt':\n  assumes \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\" \"M a b \\<le> Lt d\" \"a \\<le> n\" \"b \\<le> n\" \"v c1 = a\" \"v c2 = b\" \"a > 0\" \"b > 0\"\n  shows \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 < d}\"", "lemma dbm_lt'2:\n  assumes \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\" \"M a 0 \\<le> Lt d\" \"a \\<le> n\" \"v c1 = a\" \"a > 0\"\n  shows \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 < d}\"", "lemma dbm_lt'3:\n  assumes \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\" \"M 0 a \\<le> Lt d\" \"a \\<le> n\" \"v c1 = a\" \"a > 0\"\n  shows \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c1 < d}\"", "lemma dbm_le':\n  assumes \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\" \"M a b \\<le> Le d\" \"a \\<le> n\" \"b \\<le> n\" \"v c1 = a\" \"v c2 = b\" \"a > 0\" \"b > 0\"\n  shows \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> d}\"", "lemma dbm_le'2:\n  assumes \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\" \"M a 0 \\<le> Le d\" \"a \\<le> n\" \"v c1 = a\" \"a > 0\"\n  shows \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 \\<le> d}\"", "lemma dbm_le'3:\n  assumes \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\" \"M 0 a \\<le> Le d\" \"a \\<le> n\" \"v c1 = a\" \"a > 0\"\n  shows \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c1 \\<le> d}\"", "lemma int_zone_dbm:\n  assumes \"\\<forall> (_,d) \\<in> collect_clock_pairs cc. d \\<in> \\<int>\" \"\\<forall> c \\<in> collect_clks cc. v c \\<le> n\"\n  obtains M where \"{u. u \\<turnstile> cc} = [M]\\<^bsub>v,n\\<^esub>\" and \"dbm_int M n\"", "lemma non_empty_dbm_diag_set':\n  assumes \"clock_numbering' v n\" \"\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<noteq> \\<infinity> \\<longrightarrow> get_const (M i j) \\<in> \\<int>\"\n          \"[M]\\<^bsub>v,n\\<^esub> \\<noteq> {}\"\n  obtains M' where \"[M]\\<^bsub>v,n\\<^esub> = [M']\\<^bsub>v,n\\<^esub> \\<and> (\\<forall>i\\<le>n. \\<forall>j\\<le>n. M' i j \\<noteq> \\<infinity> \\<longrightarrow> get_const (M' i j) \\<in> \\<int>)\n    \\<and> (\\<forall> i \\<le> n. M' i i = \\<one>)\"", "lemma dbm_entry_int:\n  \"x \\<noteq> \\<infinity> \\<Longrightarrow> get_const x \\<in> \\<int> \\<Longrightarrow> \\<exists> d :: int. x = Le d \\<or> x = Lt d\"", "theorem region_zone_intersect_empty_approx_correct:\n  assumes \"R \\<in> \\<R>\" \"Z \\<subseteq> V\" \"R \\<inter> Z = {}\" \"vabstr Z M\"\n  shows \"R \\<inter> Approx\\<^sub>\\<beta> Z = {}\"", "lemma \\<R>_V: \"\\<Union> \\<R> = V\"", "lemma regions_beta_V: \"R \\<in> \\<R>\\<^sub>\\<beta> \\<Longrightarrow> R \\<subseteq> V\"", "lemma apx_V: \"Z \\<subseteq> V \\<Longrightarrow> Approx\\<^sub>\\<beta> Z \\<subseteq> V\"", "lemma apx_empty_iff:\n  assumes \"Z \\<subseteq> V\" \"vabstr Z M\"\n  shows \"Z = {} \\<longleftrightarrow> Approx\\<^sub>\\<beta> Z = {}\"", "lemma apx_empty_iff':\n  assumes \"Z \\<in> V'\" shows \"Z = {} \\<longleftrightarrow> Approx\\<^sub>\\<beta> Z = {}\"", "lemma apx_V':\n  assumes \"Z \\<subseteq> V\" shows \"Approx\\<^sub>\\<beta> Z \\<in> V'\"", "lemma step_z_V':\n  assumes \"A \\<turnstile> \\<langle>l,Z\\<rangle> \\<leadsto> \\<langle>l',Z'\\<rangle>\" \"valid_abstraction A X k\" \"\\<forall>c\\<in>clk_set A. v c \\<le> n\" \"Z \\<in> V'\"\n  shows \"Z' \\<in> V'\"", "lemma steps_z_V':\n  \"A \\<turnstile> \\<langle>l,Z\\<rangle> \\<leadsto>* \\<langle>l',Z'\\<rangle> \\<Longrightarrow> valid_abstraction A X k \\<Longrightarrow> \\<forall>c\\<in>clk_set A. v c \\<le> n \\<Longrightarrow> Z \\<in> V' \\<Longrightarrow> Z' \\<in> V'\"", "lemma step_z_alpha_sound:\n  \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l',Z'\\<rangle> \\<Longrightarrow> valid_abstraction A X k \\<Longrightarrow> \\<forall>c\\<in>clk_set A. v c \\<le> n \\<Longrightarrow> Z \\<in> V' \\<Longrightarrow> Z' \\<noteq> {}\n  \\<Longrightarrow> \\<exists> Z''. A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l',Z''\\<rangle> \\<and> Z'' \\<noteq> {}\"", "lemma step_z_alpha_complete:\n  \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l',Z'\\<rangle> \\<Longrightarrow> valid_abstraction A X k \\<Longrightarrow> \\<forall>c\\<in>clk_set A. v c \\<le> n \\<Longrightarrow> Z \\<in> V' \\<Longrightarrow> Z' \\<noteq> {}\n  \\<Longrightarrow> \\<exists> Z''. A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z''\\<rangle> \\<and> Z'' \\<noteq> {}\"", "lemma V'_V: \"Z \\<in> V' \\<Longrightarrow> Z \\<subseteq> V\"", "lemma steps_z_beta_V':\n  \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle> \\<Longrightarrow> valid_abstraction A X k \\<Longrightarrow>\\<forall>c\\<in>clk_set A. v c \\<le> n \\<Longrightarrow> Z \\<in> V' \\<Longrightarrow> Z' \\<in> V'\"", "lemma alpha_beta_step:\n  \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z'\\<rangle> \\<Longrightarrow> valid_abstraction A X k \\<Longrightarrow> \\<forall>c\\<in>clk_set A. v c \\<le> n \\<Longrightarrow> Z \\<in> V'\n  \\<Longrightarrow> \\<exists> Z''. A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha> \\<langle>l', Z''\\<rangle> \\<and> Z' \\<subseteq> Z''\"", "lemma alpha_beta_step':\n  \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z'\\<rangle> \\<Longrightarrow> valid_abstraction A X k \\<Longrightarrow> \\<forall>c\\<in>clk_set A. v c \\<le> n \\<Longrightarrow> Z \\<in> V' \\<Longrightarrow> W \\<subseteq> V\n  \\<Longrightarrow> Z \\<subseteq> W \\<Longrightarrow> \\<exists> W'. A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<alpha> \\<langle>l', W'\\<rangle> \\<and> Z' \\<subseteq> W'\"", "lemma alpha_beta_steps:\n  \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle> \\<Longrightarrow> valid_abstraction A X k \\<Longrightarrow> \\<forall>c\\<in>clk_set A. v c \\<le> n \\<Longrightarrow> Z \\<in> V'\n  \\<Longrightarrow> \\<exists> Z''. A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l', Z''\\<rangle> \\<and> Z' \\<subseteq> Z''\"", "lemma apx_mono:\n  \"Z' \\<subseteq> V \\<Longrightarrow> Z \\<subseteq> Z' \\<Longrightarrow> Approx\\<^sub>\\<beta> Z \\<subseteq> Approx\\<^sub>\\<beta> Z'\"", "lemma step_z_beta_mono:\n  \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z'\\<rangle> \\<Longrightarrow> Z \\<subseteq> W \\<Longrightarrow> W \\<subseteq> V \\<Longrightarrow> \\<exists> W'. A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', W'\\<rangle> \\<and> Z' \\<subseteq> W'\"", "lemma steps_z_beta_V: \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle> \\<Longrightarrow> Z \\<subseteq> V \\<Longrightarrow> Z' \\<subseteq> V\"", "lemma steps_z_beta_mono:\n  \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle> \\<Longrightarrow> Z \\<subseteq> W \\<Longrightarrow> W \\<subseteq> V \\<Longrightarrow> \\<exists> W'. A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', W'\\<rangle> \\<and> Z' \\<subseteq> W'\"", "lemma steps_z_beta_alt:\n  \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z'\\<rangle> \\<Longrightarrow> A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''\\<rangle> \\<Longrightarrow> A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''\\<rangle>\"", "lemma steps_z_beta_complete:\n  \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l', Z'\\<rangle> \\<Longrightarrow> valid_abstraction A X k \\<Longrightarrow> Z \\<subseteq> V\n  \\<Longrightarrow> \\<exists> Z''. A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l',Z''\\<rangle> \\<and> Z' \\<subseteq> Z''\"", "lemma steps_z_beta_complete':\n  \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l',Z'\\<rangle> \\<Longrightarrow> valid_abstraction A X k \\<Longrightarrow> Z \\<subseteq> V \\<Longrightarrow> Z' \\<noteq> {}\n  \\<Longrightarrow> \\<exists> Z''. A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l',Z''\\<rangle> \\<and> Z'' \\<noteq> {}\""], "translations": [["", "lemma region_dbm:\n  assumes \"R \\<in> \\<R>\"\n  defines \"v' \\<equiv> \\<lambda> i. THE c. c \\<in> X \\<and> v c = i\"\n  obtains M\n  where\"[M]\\<^bsub>v,n\\<^esub> = R\"\n  and \"\\<forall> i \\<le> n. \\<forall> j \\<le> n. M i 0 = \\<infinity> \\<and> j > 0 \\<and> i \\<noteq> j\\<longrightarrow> M i j = \\<infinity> \\<and> M j i = \\<infinity>\"\n  and \"\\<forall> i \\<le> n. M i i = Le 0\"\n  and \"\\<forall> i \\<le> n. \\<forall> j \\<le> n. i > 0 \\<and> j > 0 \\<and> M i 0 \\<noteq> \\<infinity> \\<and> M j 0 \\<noteq> \\<infinity> \\<longrightarrow> (\\<exists> d :: int.\n        (- k (v' j) \\<le> d \\<and> d \\<le> k (v' i) \\<and> M i j = Le d \\<and> M j i = Le (-d))\n      \\<or> (- k (v' j) \\<le> d - 1 \\<and> d \\<le> k (v' i) \\<and> M i j = Lt d \\<and> M j i = Lt (-d + 1)))\"\n  and \"\\<forall> i \\<le> n. i > 0 \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n        (\\<exists> d :: int. d \\<le> k (v' i) \\<and> d \\<ge> 0\n          \\<and> (M i 0 = Le d \\<and> M 0 i = Le (-d) \\<or> M i 0 = Lt d \\<and> M 0 i = Lt (-d + 1)))\"\n  and \"\\<forall> i \\<le> n. i > 0 \\<longrightarrow> (\\<exists> d :: int. - k (v' i) \\<le> d \\<and> d \\<le> 0 \\<and> (M 0 i = Le d \\<or> M 0 i = Lt d))\"\n  and \"\\<forall> i. \\<forall> j. M i j \\<noteq> \\<infinity> \\<longrightarrow> get_const (M i j) \\<in> \\<int>\"\n  and \"\\<forall> i \\<le> n. \\<forall> j \\<le> n. M i j \\<noteq> \\<infinity> \\<and> i > 0 \\<and> j > 0 \\<longrightarrow>\n      (\\<exists> d:: int. (M i j = Le d \\<or> M i j = Lt d) \\<and> (- k (v' j)) \\<le> d \\<and> d \\<le> k (v' i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  R \\<in> \\<R>\n  v' \\<equiv> \\<lambda>i. THE c. c \\<in> X \\<and> v c = i", "obtain I r where R: \"R = region X I r\" \"valid_region X k I r\""], ["proof (prove)\nusing this:\n  R \\<in> \\<R>\n  v' \\<equiv> \\<lambda>i. THE c. c \\<in> X \\<and> v c = i\n\ngoal (1 subgoal):\n 1. (\\<And>I r.\n        \\<lbrakk>R = Regions.region X I r;\n         Regions.valid_region X k I r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding \\<R>_def"], ["proof (prove)\nusing this:\n  R \\<in> {Regions.region X I r |I r. Regions.valid_region X k I r}\n  v' \\<equiv> \\<lambda>i. THE c. c \\<in> X \\<and> v c = i\n\ngoal (1 subgoal):\n 1. (\\<And>I r.\n        \\<lbrakk>R = Regions.region X I r;\n         Regions.valid_region X k I r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  R = Regions.region X I r\n  Regions.valid_region X k I r\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?X\\<^sub>0 = \"{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define f where \"f x = (if isIntv (I x) then Lt (intv_const (I x) + 1)\n                 else if isConst (I x) then Le (intv_const (I x))\n                 else \\<infinity>)\" for x"], ["proof (state)\nthis:\n  f ?x =\n  (if Regions.isIntv (I ?x) then Lt (real (intv_const (I ?x) + 1))\n   else if Regions.isConst (I ?x) then Le (real (intv_const (I ?x)))\n        else \\<infinity>)\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define g where \"g x = (if isIntv (I x) then Lt (- intv_const (I x))\n                 else if isConst (I x) then Le (- intv_const (I x))\n                 else Lt (- k x))\" for x"], ["proof (state)\nthis:\n  g ?x =\n  (if Regions.isIntv (I ?x)\n   then Lt (real_of_int (- int (intv_const (I ?x))))\n   else if Regions.isConst (I ?x)\n        then Le (real_of_int (- int (intv_const (I ?x))))\n        else Lt (real_of_int (- int (k ?x))))\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define h where \"h x y = (if isIntv (I x) \\<and> isIntv (I y) then\n                      if (y, x) \\<in> r \\<and> (x, y) \\<notin> r then Lt (int (intv_const (I x)) - intv_const (I y) + 1)\n                      else if (x, y) \\<in> r \\<and> (y, x) \\<notin> r then Lt (int (intv_const (I x)) - intv_const (I y))\n                      else Le (int (intv_const (I x)) - intv_const (I y))\n                   else if isConst (I x) \\<and> isConst (I y) then Le (int (intv_const (I x)) - intv_const (I y))\n                   else if isIntv (I x) \\<and> isConst (I y) then Lt (int (intv_const (I x)) + 1 - intv_const (I y))\n                   else if isConst (I x) \\<and> isIntv (I y) then Lt (int (intv_const (I x)) - intv_const (I y))\n                   else \\<infinity>)\" for x y"], ["proof (state)\nthis:\n  h ?x ?y =\n  (if Regions.isIntv (I ?x) \\<and> Regions.isIntv (I ?y)\n   then if (?y, ?x) \\<in> r \\<and> (?x, ?y) \\<notin> r\n        then Lt (real_of_int\n                  (int (intv_const (I ?x)) - int (intv_const (I ?y)) + 1))\n        else if (?x, ?y) \\<in> r \\<and> (?y, ?x) \\<notin> r\n             then Lt (real_of_int\n                       (int (intv_const (I ?x)) - int (intv_const (I ?y))))\n             else Le (real_of_int\n                       (int (intv_const (I ?x)) - int (intv_const (I ?y))))\n   else if Regions.isConst (I ?x) \\<and> Regions.isConst (I ?y)\n        then Le (real_of_int\n                  (int (intv_const (I ?x)) - int (intv_const (I ?y))))\n        else if Regions.isIntv (I ?x) \\<and> Regions.isConst (I ?y)\n             then Lt (real_of_int\n                       (int (intv_const (I ?x)) + 1 -\n                        int (intv_const (I ?y))))\n             else if Regions.isConst (I ?x) \\<and> Regions.isIntv (I ?y)\n                  then Lt (real_of_int\n                            (int (intv_const (I ?x)) -\n                             int (intv_const (I ?y))))\n                  else \\<infinity>)\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?M = \"\\<lambda> i j. if i = 0 then if j = 0 then Le 0 else g (v' j)\n                   else if j = 0 then f (v' i) else if i = j then Le 0 else h (v' i) (v' j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"[?M]\\<^bsub>v,n\\<^esub> \\<subseteq> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(\\<lambda>i j.\n         if i = 0 then if j = 0 then Le 0 else g (v' j)\n         else if j = 0 then f (v' i)\n              else if i = j then Le 0\n                   else h (v' i) (v' j))]\\<^bsub>v,n\\<^esub>\n    \\<subseteq> R", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> [(\\<lambda>i j.\n                    if i = 0 then if j = 0 then Le 0 else g (v' j)\n                    else if j = 0 then f (v' i)\n                         else if i = j then Le 0\n                              else h (v' i)\n                                    (v'\nj))]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n       x \\<in> R", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> [(\\<lambda>i j.\n                    if i = 0 then if j = 0 then Le 0 else g (v' j)\n                    else if j = 0 then f (v' i)\n                         else if i = j then Le 0\n                              else h (v' i)\n                                    (v'\nj))]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n       x \\<in> R", "assume u: \"u \\<in> [?M]\\<^bsub>v,n\\<^esub>\""], ["proof (state)\nthis:\n  u \\<in> [(\\<lambda>i j.\n               if i = 0 then if j = 0 then Le 0 else g (v' j)\n               else if j = 0 then f (v' i)\n                    else if i = j then Le 0\n                         else h (v' i) (v' j))]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> [(\\<lambda>i j.\n                    if i = 0 then if j = 0 then Le 0 else g (v' j)\n                    else if j = 0 then f (v' i)\n                         else if i = j then Le 0\n                              else h (v' i)\n                                    (v'\nj))]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n       x \\<in> R", "show \"u \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> R", "unfolding R"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> Regions.region X I r", "proof (standard, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>x\\<in>X. 0 \\<le> u x\n 2. \\<forall>x\\<in>X. Regions.intv_elem x u (I x)\n 3. ?X\\<^sub>0 = {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n 4. \\<forall>x\\<in>?X\\<^sub>0.\n       \\<forall>y\\<in>?X\\<^sub>0.\n          ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<forall>x\\<in>X. 0 \\<le> u x\n 2. \\<forall>x\\<in>X. Regions.intv_elem x u (I x)\n 3. ?X\\<^sub>0 = {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n 4. \\<forall>x\\<in>?X\\<^sub>0.\n       \\<forall>y\\<in>?X\\<^sub>0.\n          ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X. 0 \\<le> u x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> 0 \\<le> u x", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> 0 \\<le> u x", "assume c: \"c \\<in> X\""], ["proof (state)\nthis:\n  c \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> 0 \\<le> u x", "with clock_numbering"], ["proof (chain)\npicking this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  c \\<in> X", "have c2: \"v c \\<le> n\" \"v c > 0\" \"v' (v c) = c\""], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  c \\<in> X\n\ngoal (1 subgoal):\n 1. v c \\<le> n &&& 0 < v c &&& v' (v c) = c", "unfolding v'_def"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  c \\<in> X\n\ngoal (1 subgoal):\n 1. v c \\<le> n &&& 0 < v c &&& (THE ca. ca \\<in> X \\<and> v ca = v c) = c", "by auto"], ["proof (state)\nthis:\n  v c \\<le> n\n  0 < v c\n  v' (v c) = c\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> 0 \\<le> u x", "with u"], ["proof (chain)\npicking this:\n  u \\<in> [(\\<lambda>i j.\n               if i = 0 then if j = 0 then Le 0 else g (v' j)\n               else if j = 0 then f (v' i)\n                    else if i = j then Le 0\n                         else h (v' i) (v' j))]\\<^bsub>v,n\\<^esub>\n  v c \\<le> n\n  0 < v c\n  v' (v c) = c", "have \"dbm_entry_val u None (Some c) (g c)\""], ["proof (prove)\nusing this:\n  u \\<in> [(\\<lambda>i j.\n               if i = 0 then if j = 0 then Le 0 else g (v' j)\n               else if j = 0 then f (v' i)\n                    else if i = j then Le 0\n                         else h (v' i) (v' j))]\\<^bsub>v,n\\<^esub>\n  v c \\<le> n\n  0 < v c\n  v' (v c) = c\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c) (g c)", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  u \\<in> {u. Le 0 \\<preceq> (if 0 = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' 0)\n                                   else if 0 = 0 then Le 0\n  else h (v' 0) (v' 0)) \\<and>\n              (\\<forall>c.\n                  v c \\<le> n \\<longrightarrow>\n                  dbm_entry_val u None (Some c)\n                   (if 0 = 0 then if v c = 0 then Le 0 else g (v' (v c))\n                    else if v c = 0 then f (v' 0)\n                         else if 0 = v c then Le 0\n                              else h (v' 0) (v' (v c))) \\<and>\n                  dbm_entry_val u (Some c) None\n                   (if v c = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                    else if 0 = 0 then f (v' (v c))\n                         else if v c = 0 then Le 0\n                              else h (v' (v c)) (v' 0))) \\<and>\n              (\\<forall>c1 c2.\n                  v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                  dbm_entry_val u (Some c1) (Some c2)\n                   (if v c1 = 0\n                    then if v c2 = 0 then Le 0 else g (v' (v c2))\n                    else if v c2 = 0 then f (v' (v c1))\n                         else if v c1 = v c2 then Le 0\n                              else h (v' (v c1)) (v' (v c2))))}\n  v c \\<le> n\n  0 < v c\n  v' (v c) = c\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c) (g c)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u None (Some c) (g c)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> 0 \\<le> u x", "then"], ["proof (chain)\npicking this:\n  dbm_entry_val u None (Some c) (g c)", "show \"0 \\<le> u c\""], ["proof (prove)\nusing this:\n  dbm_entry_val u None (Some c) (g c)\n\ngoal (1 subgoal):\n 1. 0 \\<le> u c", "by (cases \"isIntv (I c)\"; cases \"isConst (I c)\") (auto simp: g_def)"], ["proof (state)\nthis:\n  0 \\<le> u c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>X. 0 \\<le> u x\n\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>X. Regions.intv_elem x u (I x)\n 2. ?X\\<^sub>0 = {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n 3. \\<forall>x\\<in>?X\\<^sub>0.\n       \\<forall>y\\<in>?X\\<^sub>0.\n          ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>X. Regions.intv_elem x u (I x)\n 2. ?X\\<^sub>0 = {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n 3. \\<forall>x\\<in>?X\\<^sub>0.\n       \\<forall>y\\<in>?X\\<^sub>0.\n          ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>X. Regions.intv_elem x u (I x)\n 2. ?X\\<^sub>0 = {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n 3. \\<forall>x\\<in>?X\\<^sub>0.\n       \\<forall>y\\<in>?X\\<^sub>0.\n          ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X. Regions.intv_elem x u (I x)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> Regions.intv_elem x u (I x)", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> Regions.intv_elem x u (I x)", "assume c: \"c \\<in> X\""], ["proof (state)\nthis:\n  c \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> Regions.intv_elem x u (I x)", "with clock_numbering"], ["proof (chain)\npicking this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  c \\<in> X", "have c2: \"v c \\<le> n\" \"v c > 0\" \"v' (v c) = c\""], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  c \\<in> X\n\ngoal (1 subgoal):\n 1. v c \\<le> n &&& 0 < v c &&& v' (v c) = c", "unfolding v'_def"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  c \\<in> X\n\ngoal (1 subgoal):\n 1. v c \\<le> n &&& 0 < v c &&& (THE ca. ca \\<in> X \\<and> v ca = v c) = c", "by auto"], ["proof (state)\nthis:\n  v c \\<le> n\n  0 < v c\n  v' (v c) = c\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> Regions.intv_elem x u (I x)", "with u"], ["proof (chain)\npicking this:\n  u \\<in> [(\\<lambda>i j.\n               if i = 0 then if j = 0 then Le 0 else g (v' j)\n               else if j = 0 then f (v' i)\n                    else if i = j then Le 0\n                         else h (v' i) (v' j))]\\<^bsub>v,n\\<^esub>\n  v c \\<le> n\n  0 < v c\n  v' (v c) = c", "have *: \"dbm_entry_val u None (Some c) (g c)\" \"dbm_entry_val u (Some c) None (f c)\""], ["proof (prove)\nusing this:\n  u \\<in> [(\\<lambda>i j.\n               if i = 0 then if j = 0 then Le 0 else g (v' j)\n               else if j = 0 then f (v' i)\n                    else if i = j then Le 0\n                         else h (v' i) (v' j))]\\<^bsub>v,n\\<^esub>\n  v c \\<le> n\n  0 < v c\n  v' (v c) = c\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c) (g c) &&&\n    dbm_entry_val u (Some c) None (f c)", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  u \\<in> {u. Le 0 \\<preceq> (if 0 = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' 0)\n                                   else if 0 = 0 then Le 0\n  else h (v' 0) (v' 0)) \\<and>\n              (\\<forall>c.\n                  v c \\<le> n \\<longrightarrow>\n                  dbm_entry_val u None (Some c)\n                   (if 0 = 0 then if v c = 0 then Le 0 else g (v' (v c))\n                    else if v c = 0 then f (v' 0)\n                         else if 0 = v c then Le 0\n                              else h (v' 0) (v' (v c))) \\<and>\n                  dbm_entry_val u (Some c) None\n                   (if v c = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                    else if 0 = 0 then f (v' (v c))\n                         else if v c = 0 then Le 0\n                              else h (v' (v c)) (v' 0))) \\<and>\n              (\\<forall>c1 c2.\n                  v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                  dbm_entry_val u (Some c1) (Some c2)\n                   (if v c1 = 0\n                    then if v c2 = 0 then Le 0 else g (v' (v c2))\n                    else if v c2 = 0 then f (v' (v c1))\n                         else if v c1 = v c2 then Le 0\n                              else h (v' (v c1)) (v' (v c2))))}\n  v c \\<le> n\n  0 < v c\n  v' (v c) = c\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c) (g c) &&&\n    dbm_entry_val u (Some c) None (f c)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u None (Some c) (g c)\n  dbm_entry_val u (Some c) None (f c)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> Regions.intv_elem x u (I x)", "show \"intv_elem c u (I c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Regions.intv_elem c u (I c)", "proof (cases \"I c\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       I c = Regions.intv.Const x1 \\<Longrightarrow>\n       Regions.intv_elem c u (I c)\n 2. \\<And>x2.\n       I c = Regions.intv.Intv x2 \\<Longrightarrow>\n       Regions.intv_elem c u (I c)\n 3. \\<And>x3.\n       I c = Regions.intv.Greater x3 \\<Longrightarrow>\n       Regions.intv_elem c u (I c)", "case (Const d)"], ["proof (state)\nthis:\n  I c = Regions.intv.Const d\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       I c = Regions.intv.Const x1 \\<Longrightarrow>\n       Regions.intv_elem c u (I c)\n 2. \\<And>x2.\n       I c = Regions.intv.Intv x2 \\<Longrightarrow>\n       Regions.intv_elem c u (I c)\n 3. \\<And>x3.\n       I c = Regions.intv.Greater x3 \\<Longrightarrow>\n       Regions.intv_elem c u (I c)", "then"], ["proof (chain)\npicking this:\n  I c = Regions.intv.Const d", "have \"\\<not> isIntv (I c)\" \"isConst (I c)\""], ["proof (prove)\nusing this:\n  I c = Regions.intv.Const d\n\ngoal (1 subgoal):\n 1. \\<not> Regions.isIntv (I c) &&& Regions.isConst (I c)", "by auto"], ["proof (state)\nthis:\n  \\<not> Regions.isIntv (I c)\n  Regions.isConst (I c)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       I c = Regions.intv.Const x1 \\<Longrightarrow>\n       Regions.intv_elem c u (I c)\n 2. \\<And>x2.\n       I c = Regions.intv.Intv x2 \\<Longrightarrow>\n       Regions.intv_elem c u (I c)\n 3. \\<And>x3.\n       I c = Regions.intv.Greater x3 \\<Longrightarrow>\n       Regions.intv_elem c u (I c)", "with * Const"], ["proof (chain)\npicking this:\n  dbm_entry_val u None (Some c) (g c)\n  dbm_entry_val u (Some c) None (f c)\n  I c = Regions.intv.Const d\n  \\<not> Regions.isIntv (I c)\n  Regions.isConst (I c)", "show ?thesis"], ["proof (prove)\nusing this:\n  dbm_entry_val u None (Some c) (g c)\n  dbm_entry_val u (Some c) None (f c)\n  I c = Regions.intv.Const d\n  \\<not> Regions.isIntv (I c)\n  Regions.isConst (I c)\n\ngoal (1 subgoal):\n 1. Regions.intv_elem c u (I c)", "unfolding g_def f_def"], ["proof (prove)\nusing this:\n  dbm_entry_val u None (Some c)\n   (if Regions.isIntv (I c) then Lt (real_of_int (- int (intv_const (I c))))\n    else if Regions.isConst (I c)\n         then Le (real_of_int (- int (intv_const (I c))))\n         else Lt (real_of_int (- int (k c))))\n  dbm_entry_val u (Some c) None\n   (if Regions.isIntv (I c) then Lt (real (intv_const (I c) + 1))\n    else if Regions.isConst (I c) then Le (real (intv_const (I c)))\n         else \\<infinity>)\n  I c = Regions.intv.Const d\n  \\<not> Regions.isIntv (I c)\n  Regions.isConst (I c)\n\ngoal (1 subgoal):\n 1. Regions.intv_elem c u (I c)", "using Const"], ["proof (prove)\nusing this:\n  dbm_entry_val u None (Some c)\n   (if Regions.isIntv (I c) then Lt (real_of_int (- int (intv_const (I c))))\n    else if Regions.isConst (I c)\n         then Le (real_of_int (- int (intv_const (I c))))\n         else Lt (real_of_int (- int (k c))))\n  dbm_entry_val u (Some c) None\n   (if Regions.isIntv (I c) then Lt (real (intv_const (I c) + 1))\n    else if Regions.isConst (I c) then Le (real (intv_const (I c)))\n         else \\<infinity>)\n  I c = Regions.intv.Const d\n  \\<not> Regions.isIntv (I c)\n  Regions.isConst (I c)\n  I c = Regions.intv.Const d\n\ngoal (1 subgoal):\n 1. Regions.intv_elem c u (I c)", "by auto"], ["proof (state)\nthis:\n  Regions.intv_elem c u (I c)\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       I c = Regions.intv.Intv x2 \\<Longrightarrow>\n       Regions.intv_elem c u (I c)\n 2. \\<And>x3.\n       I c = Regions.intv.Greater x3 \\<Longrightarrow>\n       Regions.intv_elem c u (I c)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       I c = Regions.intv.Intv x2 \\<Longrightarrow>\n       Regions.intv_elem c u (I c)\n 2. \\<And>x3.\n       I c = Regions.intv.Greater x3 \\<Longrightarrow>\n       Regions.intv_elem c u (I c)", "case (Intv d)"], ["proof (state)\nthis:\n  I c = Regions.intv.Intv d\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       I c = Regions.intv.Intv x2 \\<Longrightarrow>\n       Regions.intv_elem c u (I c)\n 2. \\<And>x3.\n       I c = Regions.intv.Greater x3 \\<Longrightarrow>\n       Regions.intv_elem c u (I c)", "then"], ["proof (chain)\npicking this:\n  I c = Regions.intv.Intv d", "have \"isIntv (I c)\" \"\\<not> isConst (I c)\""], ["proof (prove)\nusing this:\n  I c = Regions.intv.Intv d\n\ngoal (1 subgoal):\n 1. Regions.isIntv (I c) &&& \\<not> Regions.isConst (I c)", "by auto"], ["proof (state)\nthis:\n  Regions.isIntv (I c)\n  \\<not> Regions.isConst (I c)\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       I c = Regions.intv.Intv x2 \\<Longrightarrow>\n       Regions.intv_elem c u (I c)\n 2. \\<And>x3.\n       I c = Regions.intv.Greater x3 \\<Longrightarrow>\n       Regions.intv_elem c u (I c)", "with * Intv"], ["proof (chain)\npicking this:\n  dbm_entry_val u None (Some c) (g c)\n  dbm_entry_val u (Some c) None (f c)\n  I c = Regions.intv.Intv d\n  Regions.isIntv (I c)\n  \\<not> Regions.isConst (I c)", "show ?thesis"], ["proof (prove)\nusing this:\n  dbm_entry_val u None (Some c) (g c)\n  dbm_entry_val u (Some c) None (f c)\n  I c = Regions.intv.Intv d\n  Regions.isIntv (I c)\n  \\<not> Regions.isConst (I c)\n\ngoal (1 subgoal):\n 1. Regions.intv_elem c u (I c)", "unfolding g_def f_def"], ["proof (prove)\nusing this:\n  dbm_entry_val u None (Some c)\n   (if Regions.isIntv (I c) then Lt (real_of_int (- int (intv_const (I c))))\n    else if Regions.isConst (I c)\n         then Le (real_of_int (- int (intv_const (I c))))\n         else Lt (real_of_int (- int (k c))))\n  dbm_entry_val u (Some c) None\n   (if Regions.isIntv (I c) then Lt (real (intv_const (I c) + 1))\n    else if Regions.isConst (I c) then Le (real (intv_const (I c)))\n         else \\<infinity>)\n  I c = Regions.intv.Intv d\n  Regions.isIntv (I c)\n  \\<not> Regions.isConst (I c)\n\ngoal (1 subgoal):\n 1. Regions.intv_elem c u (I c)", "by auto"], ["proof (state)\nthis:\n  Regions.intv_elem c u (I c)\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       I c = Regions.intv.Greater x3 \\<Longrightarrow>\n       Regions.intv_elem c u (I c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       I c = Regions.intv.Greater x3 \\<Longrightarrow>\n       Regions.intv_elem c u (I c)", "case (Greater d)"], ["proof (state)\nthis:\n  I c = Regions.intv.Greater d\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       I c = Regions.intv.Greater x3 \\<Longrightarrow>\n       Regions.intv_elem c u (I c)", "then"], ["proof (chain)\npicking this:\n  I c = Regions.intv.Greater d", "have \"\\<not> isIntv (I c)\" \"\\<not> isConst (I c)\""], ["proof (prove)\nusing this:\n  I c = Regions.intv.Greater d\n\ngoal (1 subgoal):\n 1. \\<not> Regions.isIntv (I c) &&& \\<not> Regions.isConst (I c)", "by auto"], ["proof (state)\nthis:\n  \\<not> Regions.isIntv (I c)\n  \\<not> Regions.isConst (I c)\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       I c = Regions.intv.Greater x3 \\<Longrightarrow>\n       Regions.intv_elem c u (I c)", "with * Greater R(2) c"], ["proof (chain)\npicking this:\n  dbm_entry_val u None (Some c) (g c)\n  dbm_entry_val u (Some c) None (f c)\n  I c = Regions.intv.Greater d\n  Regions.valid_region X k I r\n  c \\<in> X\n  \\<not> Regions.isIntv (I c)\n  \\<not> Regions.isConst (I c)", "show ?thesis"], ["proof (prove)\nusing this:\n  dbm_entry_val u None (Some c) (g c)\n  dbm_entry_val u (Some c) None (f c)\n  I c = Regions.intv.Greater d\n  Regions.valid_region X k I r\n  c \\<in> X\n  \\<not> Regions.isIntv (I c)\n  \\<not> Regions.isConst (I c)\n\ngoal (1 subgoal):\n 1. Regions.intv_elem c u (I c)", "unfolding g_def f_def"], ["proof (prove)\nusing this:\n  dbm_entry_val u None (Some c)\n   (if Regions.isIntv (I c) then Lt (real_of_int (- int (intv_const (I c))))\n    else if Regions.isConst (I c)\n         then Le (real_of_int (- int (intv_const (I c))))\n         else Lt (real_of_int (- int (k c))))\n  dbm_entry_val u (Some c) None\n   (if Regions.isIntv (I c) then Lt (real (intv_const (I c) + 1))\n    else if Regions.isConst (I c) then Le (real (intv_const (I c)))\n         else \\<infinity>)\n  I c = Regions.intv.Greater d\n  Regions.valid_region X k I r\n  c \\<in> X\n  \\<not> Regions.isIntv (I c)\n  \\<not> Regions.isConst (I c)\n\ngoal (1 subgoal):\n 1. Regions.intv_elem c u (I c)", "by fastforce"], ["proof (state)\nthis:\n  Regions.intv_elem c u (I c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Regions.intv_elem c u (I c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>X. Regions.intv_elem x u (I x)\n\ngoal (2 subgoals):\n 1. ?X\\<^sub>0 = {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n 2. \\<forall>x\\<in>?X\\<^sub>0.\n       \\<forall>y\\<in>?X\\<^sub>0.\n          ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. ?X\\<^sub>0 = {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n 2. \\<forall>x\\<in>?X\\<^sub>0.\n       \\<forall>y\\<in>?X\\<^sub>0.\n          ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "show \"?X\\<^sub>0 = ?X\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d} =\n    {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}", ".."], ["proof (state)\nthis:\n  {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d} =\n  {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n       \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n          ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "show \"\\<forall>x \\<in> ?X\\<^sub>0. \\<forall> y \\<in> ?X\\<^sub>0. (x, y) \\<in> r \\<longleftrightarrow> frac (u x) \\<le> frac (u y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n       \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n          ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "proof (standard, standard)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d};\n        y \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\\<rbrakk>\n       \\<Longrightarrow> ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d};\n        y \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\\<rbrakk>\n       \\<Longrightarrow> ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "assume A: \"x \\<in> ?X\\<^sub>0\" \"y \\<in> ?X\\<^sub>0\""], ["proof (state)\nthis:\n  x \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n  y \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d};\n        y \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\\<rbrakk>\n       \\<Longrightarrow> ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "show \"(x, y) \\<in> r \\<longleftrightarrow> frac (u x) \\<le> frac (u y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "proof (cases \"x = y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))\n 2. x \\<noteq> y \\<Longrightarrow>\n    ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "case True"], ["proof (state)\nthis:\n  x = y\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))\n 2. x \\<noteq> y \\<Longrightarrow>\n    ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "have \"refl_on ?X\\<^sub>0 r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refl_on {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d} r", "using R(2)"], ["proof (prove)\nusing this:\n  Regions.valid_region X k I r\n\ngoal (1 subgoal):\n 1. refl_on {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d} r", "by auto"], ["proof (state)\nthis:\n  refl_on {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d} r\n\ngoal (2 subgoals):\n 1. x = y \\<Longrightarrow> ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))\n 2. x \\<noteq> y \\<Longrightarrow>\n    ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "with A True"], ["proof (chain)\npicking this:\n  x \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n  y \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n  x = y\n  refl_on {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d} r", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n  y \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n  x = y\n  refl_on {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d} r\n\ngoal (1 subgoal):\n 1. ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "unfolding refl_on_def"], ["proof (prove)\nusing this:\n  x \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n  y \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n  x = y\n  r \\<subseteq> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d} \\<times>\n                {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d} \\<and>\n  (\\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n      (x, x) \\<in> r)\n\ngoal (1 subgoal):\n 1. ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "by auto"], ["proof (state)\nthis:\n  ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "case False"], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "from A"], ["proof (chain)\npicking this:\n  x \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n  y \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}", "obtain d d' where AA:\n            \"I x = Intv d\" \"I y = Intv d'\" \"isIntv (I x)\" \"isIntv (I y)\" \"\\<not> isConst (I x)\" \"\\<not> isConst (I y)\""], ["proof (prove)\nusing this:\n  x \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n  y \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n\ngoal (1 subgoal):\n 1. (\\<And>d d'.\n        \\<lbrakk>I x = Regions.intv.Intv d; I y = Regions.intv.Intv d';\n         Regions.isIntv (I x); Regions.isIntv (I y);\n         \\<not> Regions.isConst (I x); \\<not> Regions.isConst (I y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  I x = Regions.intv.Intv d\n  I y = Regions.intv.Intv d'\n  Regions.isIntv (I x)\n  Regions.isIntv (I y)\n  \\<not> Regions.isConst (I x)\n  \\<not> Regions.isConst (I y)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "from A False clock_numbering"], ["proof (chain)\npicking this:\n  x \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n  y \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n  x \\<noteq> y\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n", "have B:\n            \"v x \\<le> n\" \"v x > 0\" \"v' (v x) = x\" \"v y \\<le> n\" \"v y > 0\" \"v' (v y) = y\" \"v x \\<noteq> v y\""], ["proof (prove)\nusing this:\n  x \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n  y \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n  x \\<noteq> y\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n\ngoal (1 subgoal):\n 1. (v x \\<le> n &&& 0 < v x &&& v' (v x) = x) &&&\n    (v y \\<le> n &&& 0 < v y) &&& v' (v y) = y &&& v x \\<noteq> v y", "unfolding v'_def"], ["proof (prove)\nusing this:\n  x \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n  y \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n  x \\<noteq> y\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n\ngoal (1 subgoal):\n 1. (v x \\<le> n &&&\n     0 < v x &&& (THE c. c \\<in> X \\<and> v c = v x) = x) &&&\n    (v y \\<le> n &&& 0 < v y) &&&\n    (THE c. c \\<in> X \\<and> v c = v y) = y &&& v x \\<noteq> v y", "by auto"], ["proof (state)\nthis:\n  v x \\<le> n\n  0 < v x\n  v' (v x) = x\n  v y \\<le> n\n  0 < v y\n  v' (v y) = y\n  v x \\<noteq> v y\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "with u"], ["proof (chain)\npicking this:\n  u \\<in> [(\\<lambda>i j.\n               if i = 0 then if j = 0 then Le 0 else g (v' j)\n               else if j = 0 then f (v' i)\n                    else if i = j then Le 0\n                         else h (v' i) (v' j))]\\<^bsub>v,n\\<^esub>\n  v x \\<le> n\n  0 < v x\n  v' (v x) = x\n  v y \\<le> n\n  0 < v y\n  v' (v y) = y\n  v x \\<noteq> v y", "have *: \n            \"dbm_entry_val u (Some x) (Some y) (h x y)\" \"dbm_entry_val u (Some y) (Some x) (h y x)\"\n            \"dbm_entry_val u None (Some x) (g x)\" \"dbm_entry_val u (Some x) None (f x)\"\n            \"dbm_entry_val u None (Some y) (g y)\" \"dbm_entry_val u (Some y) None (f y)\""], ["proof (prove)\nusing this:\n  u \\<in> [(\\<lambda>i j.\n               if i = 0 then if j = 0 then Le 0 else g (v' j)\n               else if j = 0 then f (v' i)\n                    else if i = j then Le 0\n                         else h (v' i) (v' j))]\\<^bsub>v,n\\<^esub>\n  v x \\<le> n\n  0 < v x\n  v' (v x) = x\n  v y \\<le> n\n  0 < v y\n  v' (v y) = y\n  v x \\<noteq> v y\n\ngoal (1 subgoal):\n 1. (dbm_entry_val u (Some x) (Some y) (h x y) &&&\n     dbm_entry_val u (Some y) (Some x) (h y x) &&&\n     dbm_entry_val u None (Some x) (g x)) &&&\n    dbm_entry_val u (Some x) None (f x) &&&\n    dbm_entry_val u None (Some y) (g y) &&&\n    dbm_entry_val u (Some y) None (f y)", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  u \\<in> {u. Le 0 \\<preceq> (if 0 = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' 0)\n                                   else if 0 = 0 then Le 0\n  else h (v' 0) (v' 0)) \\<and>\n              (\\<forall>c.\n                  v c \\<le> n \\<longrightarrow>\n                  dbm_entry_val u None (Some c)\n                   (if 0 = 0 then if v c = 0 then Le 0 else g (v' (v c))\n                    else if v c = 0 then f (v' 0)\n                         else if 0 = v c then Le 0\n                              else h (v' 0) (v' (v c))) \\<and>\n                  dbm_entry_val u (Some c) None\n                   (if v c = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                    else if 0 = 0 then f (v' (v c))\n                         else if v c = 0 then Le 0\n                              else h (v' (v c)) (v' 0))) \\<and>\n              (\\<forall>c1 c2.\n                  v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                  dbm_entry_val u (Some c1) (Some c2)\n                   (if v c1 = 0\n                    then if v c2 = 0 then Le 0 else g (v' (v c2))\n                    else if v c2 = 0 then f (v' (v c1))\n                         else if v c1 = v c2 then Le 0\n                              else h (v' (v c1)) (v' (v c2))))}\n  v x \\<le> n\n  0 < v x\n  v' (v x) = x\n  v y \\<le> n\n  0 < v y\n  v' (v y) = y\n  v x \\<noteq> v y\n\ngoal (1 subgoal):\n 1. (dbm_entry_val u (Some x) (Some y) (h x y) &&&\n     dbm_entry_val u (Some y) (Some x) (h y x) &&&\n     dbm_entry_val u None (Some x) (g x)) &&&\n    dbm_entry_val u (Some x) None (f x) &&&\n    dbm_entry_val u None (Some y) (g y) &&&\n    dbm_entry_val u (Some y) None (f y)", "by force+"], ["proof (state)\nthis:\n  dbm_entry_val u (Some x) (Some y) (h x y)\n  dbm_entry_val u (Some y) (Some x) (h y x)\n  dbm_entry_val u None (Some x) (g x)\n  dbm_entry_val u (Some x) None (f x)\n  dbm_entry_val u None (Some y) (g y)\n  dbm_entry_val u (Some y) None (f y)\n\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "show \"(x, y) \\<in> r \\<longleftrightarrow> frac (u x) \\<le> frac (u y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (x, y) \\<in> r \\<Longrightarrow> frac (u x) \\<le> frac (u y)\n 2. frac (u x) \\<le> frac (u y) \\<Longrightarrow> (x, y) \\<in> r", "assume C: \"(x, y) \\<in> r\""], ["proof (state)\nthis:\n  (x, y) \\<in> r\n\ngoal (2 subgoals):\n 1. (x, y) \\<in> r \\<Longrightarrow> frac (u x) \\<le> frac (u y)\n 2. frac (u x) \\<le> frac (u y) \\<Longrightarrow> (x, y) \\<in> r", "show \"frac (u x) \\<le> frac (u y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frac (u x) \\<le> frac (u y)", "proof (cases \"(y, x) \\<in> r\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (y, x) \\<in> r \\<Longrightarrow> frac (u x) \\<le> frac (u y)\n 2. (y, x) \\<notin> r \\<Longrightarrow> frac (u x) \\<le> frac (u y)", "case False"], ["proof (state)\nthis:\n  (y, x) \\<notin> r\n\ngoal (2 subgoals):\n 1. (y, x) \\<in> r \\<Longrightarrow> frac (u x) \\<le> frac (u y)\n 2. (y, x) \\<notin> r \\<Longrightarrow> frac (u x) \\<le> frac (u y)", "with * AA C"], ["proof (chain)\npicking this:\n  dbm_entry_val u (Some x) (Some y) (h x y)\n  dbm_entry_val u (Some y) (Some x) (h y x)\n  dbm_entry_val u None (Some x) (g x)\n  dbm_entry_val u (Some x) None (f x)\n  dbm_entry_val u None (Some y) (g y)\n  dbm_entry_val u (Some y) None (f y)\n  I x = Regions.intv.Intv d\n  I y = Regions.intv.Intv d'\n  Regions.isIntv (I x)\n  Regions.isIntv (I y)\n  \\<not> Regions.isConst (I x)\n  \\<not> Regions.isConst (I y)\n  (x, y) \\<in> r\n  (y, x) \\<notin> r", "have **:\n                \"u x - u y < int d - d'\"\n                \"d < u x\" \"u x < d + 1\" \"d' < u y\" \"u y < d' + 1\""], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some x) (Some y) (h x y)\n  dbm_entry_val u (Some y) (Some x) (h y x)\n  dbm_entry_val u None (Some x) (g x)\n  dbm_entry_val u (Some x) None (f x)\n  dbm_entry_val u None (Some y) (g y)\n  dbm_entry_val u (Some y) None (f y)\n  I x = Regions.intv.Intv d\n  I y = Regions.intv.Intv d'\n  Regions.isIntv (I x)\n  Regions.isIntv (I y)\n  \\<not> Regions.isConst (I x)\n  \\<not> Regions.isConst (I y)\n  (x, y) \\<in> r\n  (y, x) \\<notin> r\n\ngoal (1 subgoal):\n 1. (u x - u y < real_of_int (int d - int d') &&& real d < u x) &&&\n    u x < real (d + 1) &&& real d' < u y &&& u y < real (d' + 1)", "unfolding f_def g_def h_def"], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some x) (Some y)\n   (if Regions.isIntv (I x) \\<and> Regions.isIntv (I y)\n    then if (y, x) \\<in> r \\<and> (x, y) \\<notin> r\n         then Lt (real_of_int\n                   (int (intv_const (I x)) - int (intv_const (I y)) + 1))\n         else if (x, y) \\<in> r \\<and> (y, x) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I x)) - int (intv_const (I y))))\n              else Le (real_of_int\n                        (int (intv_const (I x)) - int (intv_const (I y))))\n    else if Regions.isConst (I x) \\<and> Regions.isConst (I y)\n         then Le (real_of_int\n                   (int (intv_const (I x)) - int (intv_const (I y))))\n         else if Regions.isIntv (I x) \\<and> Regions.isConst (I y)\n              then Lt (real_of_int\n                        (int (intv_const (I x)) + 1 -\n                         int (intv_const (I y))))\n              else if Regions.isConst (I x) \\<and> Regions.isIntv (I y)\n                   then Lt (real_of_int\n                             (int (intv_const (I x)) -\n                              int (intv_const (I y))))\n                   else \\<infinity>)\n  dbm_entry_val u (Some y) (Some x)\n   (if Regions.isIntv (I y) \\<and> Regions.isIntv (I x)\n    then if (x, y) \\<in> r \\<and> (y, x) \\<notin> r\n         then Lt (real_of_int\n                   (int (intv_const (I y)) - int (intv_const (I x)) + 1))\n         else if (y, x) \\<in> r \\<and> (x, y) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I y)) - int (intv_const (I x))))\n              else Le (real_of_int\n                        (int (intv_const (I y)) - int (intv_const (I x))))\n    else if Regions.isConst (I y) \\<and> Regions.isConst (I x)\n         then Le (real_of_int\n                   (int (intv_const (I y)) - int (intv_const (I x))))\n         else if Regions.isIntv (I y) \\<and> Regions.isConst (I x)\n              then Lt (real_of_int\n                        (int (intv_const (I y)) + 1 -\n                         int (intv_const (I x))))\n              else if Regions.isConst (I y) \\<and> Regions.isIntv (I x)\n                   then Lt (real_of_int\n                             (int (intv_const (I y)) -\n                              int (intv_const (I x))))\n                   else \\<infinity>)\n  dbm_entry_val u None (Some x)\n   (if Regions.isIntv (I x) then Lt (real_of_int (- int (intv_const (I x))))\n    else if Regions.isConst (I x)\n         then Le (real_of_int (- int (intv_const (I x))))\n         else Lt (real_of_int (- int (k x))))\n  dbm_entry_val u (Some x) None\n   (if Regions.isIntv (I x) then Lt (real (intv_const (I x) + 1))\n    else if Regions.isConst (I x) then Le (real (intv_const (I x)))\n         else \\<infinity>)\n  dbm_entry_val u None (Some y)\n   (if Regions.isIntv (I y) then Lt (real_of_int (- int (intv_const (I y))))\n    else if Regions.isConst (I y)\n         then Le (real_of_int (- int (intv_const (I y))))\n         else Lt (real_of_int (- int (k y))))\n  dbm_entry_val u (Some y) None\n   (if Regions.isIntv (I y) then Lt (real (intv_const (I y) + 1))\n    else if Regions.isConst (I y) then Le (real (intv_const (I y)))\n         else \\<infinity>)\n  I x = Regions.intv.Intv d\n  I y = Regions.intv.Intv d'\n  Regions.isIntv (I x)\n  Regions.isIntv (I y)\n  \\<not> Regions.isConst (I x)\n  \\<not> Regions.isConst (I y)\n  (x, y) \\<in> r\n  (y, x) \\<notin> r\n\ngoal (1 subgoal):\n 1. (u x - u y < real_of_int (int d - int d') &&& real d < u x) &&&\n    u x < real (d + 1) &&& real d' < u y &&& u y < real (d' + 1)", "by auto"], ["proof (state)\nthis:\n  u x - u y < real_of_int (int d - int d')\n  real d < u x\n  u x < real (d + 1)\n  real d' < u y\n  u y < real (d' + 1)\n\ngoal (2 subgoals):\n 1. (y, x) \\<in> r \\<Longrightarrow> frac (u x) \\<le> frac (u y)\n 2. (y, x) \\<notin> r \\<Longrightarrow> frac (u x) \\<le> frac (u y)", "from nat_intv_frac_decomp[OF **(2,3)] nat_intv_frac_decomp[OF **(4,5)] **(1)"], ["proof (chain)\npicking this:\n  u x = real d + frac (u x)\n  u y = real d' + frac (u y)\n  u x - u y < real_of_int (int d - int d')", "show\n                \"frac (u x) \\<le> frac (u y)\""], ["proof (prove)\nusing this:\n  u x = real d + frac (u x)\n  u y = real d' + frac (u y)\n  u x - u y < real_of_int (int d - int d')\n\ngoal (1 subgoal):\n 1. frac (u x) \\<le> frac (u y)", "by simp"], ["proof (state)\nthis:\n  frac (u x) \\<le> frac (u y)\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> r \\<Longrightarrow> frac (u x) \\<le> frac (u y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (y, x) \\<in> r \\<Longrightarrow> frac (u x) \\<le> frac (u y)", "case True"], ["proof (state)\nthis:\n  (y, x) \\<in> r\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> r \\<Longrightarrow> frac (u x) \\<le> frac (u y)", "with * AA C"], ["proof (chain)\npicking this:\n  dbm_entry_val u (Some x) (Some y) (h x y)\n  dbm_entry_val u (Some y) (Some x) (h y x)\n  dbm_entry_val u None (Some x) (g x)\n  dbm_entry_val u (Some x) None (f x)\n  dbm_entry_val u None (Some y) (g y)\n  dbm_entry_val u (Some y) None (f y)\n  I x = Regions.intv.Intv d\n  I y = Regions.intv.Intv d'\n  Regions.isIntv (I x)\n  Regions.isIntv (I y)\n  \\<not> Regions.isConst (I x)\n  \\<not> Regions.isConst (I y)\n  (x, y) \\<in> r\n  (y, x) \\<in> r", "have **:\n                \"u x - u y \\<le> int d - d'\"\n                \"d < u x\" \"u x < d + 1\" \"d' < u y\" \"u y < d' + 1\""], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some x) (Some y) (h x y)\n  dbm_entry_val u (Some y) (Some x) (h y x)\n  dbm_entry_val u None (Some x) (g x)\n  dbm_entry_val u (Some x) None (f x)\n  dbm_entry_val u None (Some y) (g y)\n  dbm_entry_val u (Some y) None (f y)\n  I x = Regions.intv.Intv d\n  I y = Regions.intv.Intv d'\n  Regions.isIntv (I x)\n  Regions.isIntv (I y)\n  \\<not> Regions.isConst (I x)\n  \\<not> Regions.isConst (I y)\n  (x, y) \\<in> r\n  (y, x) \\<in> r\n\ngoal (1 subgoal):\n 1. (u x - u y \\<le> real_of_int (int d - int d') &&& real d < u x) &&&\n    u x < real (d + 1) &&& real d' < u y &&& u y < real (d' + 1)", "unfolding f_def g_def h_def"], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some x) (Some y)\n   (if Regions.isIntv (I x) \\<and> Regions.isIntv (I y)\n    then if (y, x) \\<in> r \\<and> (x, y) \\<notin> r\n         then Lt (real_of_int\n                   (int (intv_const (I x)) - int (intv_const (I y)) + 1))\n         else if (x, y) \\<in> r \\<and> (y, x) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I x)) - int (intv_const (I y))))\n              else Le (real_of_int\n                        (int (intv_const (I x)) - int (intv_const (I y))))\n    else if Regions.isConst (I x) \\<and> Regions.isConst (I y)\n         then Le (real_of_int\n                   (int (intv_const (I x)) - int (intv_const (I y))))\n         else if Regions.isIntv (I x) \\<and> Regions.isConst (I y)\n              then Lt (real_of_int\n                        (int (intv_const (I x)) + 1 -\n                         int (intv_const (I y))))\n              else if Regions.isConst (I x) \\<and> Regions.isIntv (I y)\n                   then Lt (real_of_int\n                             (int (intv_const (I x)) -\n                              int (intv_const (I y))))\n                   else \\<infinity>)\n  dbm_entry_val u (Some y) (Some x)\n   (if Regions.isIntv (I y) \\<and> Regions.isIntv (I x)\n    then if (x, y) \\<in> r \\<and> (y, x) \\<notin> r\n         then Lt (real_of_int\n                   (int (intv_const (I y)) - int (intv_const (I x)) + 1))\n         else if (y, x) \\<in> r \\<and> (x, y) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I y)) - int (intv_const (I x))))\n              else Le (real_of_int\n                        (int (intv_const (I y)) - int (intv_const (I x))))\n    else if Regions.isConst (I y) \\<and> Regions.isConst (I x)\n         then Le (real_of_int\n                   (int (intv_const (I y)) - int (intv_const (I x))))\n         else if Regions.isIntv (I y) \\<and> Regions.isConst (I x)\n              then Lt (real_of_int\n                        (int (intv_const (I y)) + 1 -\n                         int (intv_const (I x))))\n              else if Regions.isConst (I y) \\<and> Regions.isIntv (I x)\n                   then Lt (real_of_int\n                             (int (intv_const (I y)) -\n                              int (intv_const (I x))))\n                   else \\<infinity>)\n  dbm_entry_val u None (Some x)\n   (if Regions.isIntv (I x) then Lt (real_of_int (- int (intv_const (I x))))\n    else if Regions.isConst (I x)\n         then Le (real_of_int (- int (intv_const (I x))))\n         else Lt (real_of_int (- int (k x))))\n  dbm_entry_val u (Some x) None\n   (if Regions.isIntv (I x) then Lt (real (intv_const (I x) + 1))\n    else if Regions.isConst (I x) then Le (real (intv_const (I x)))\n         else \\<infinity>)\n  dbm_entry_val u None (Some y)\n   (if Regions.isIntv (I y) then Lt (real_of_int (- int (intv_const (I y))))\n    else if Regions.isConst (I y)\n         then Le (real_of_int (- int (intv_const (I y))))\n         else Lt (real_of_int (- int (k y))))\n  dbm_entry_val u (Some y) None\n   (if Regions.isIntv (I y) then Lt (real (intv_const (I y) + 1))\n    else if Regions.isConst (I y) then Le (real (intv_const (I y)))\n         else \\<infinity>)\n  I x = Regions.intv.Intv d\n  I y = Regions.intv.Intv d'\n  Regions.isIntv (I x)\n  Regions.isIntv (I y)\n  \\<not> Regions.isConst (I x)\n  \\<not> Regions.isConst (I y)\n  (x, y) \\<in> r\n  (y, x) \\<in> r\n\ngoal (1 subgoal):\n 1. (u x - u y \\<le> real_of_int (int d - int d') &&& real d < u x) &&&\n    u x < real (d + 1) &&& real d' < u y &&& u y < real (d' + 1)", "by auto"], ["proof (state)\nthis:\n  u x - u y \\<le> real_of_int (int d - int d')\n  real d < u x\n  u x < real (d + 1)\n  real d' < u y\n  u y < real (d' + 1)\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> r \\<Longrightarrow> frac (u x) \\<le> frac (u y)", "from nat_intv_frac_decomp[OF **(2,3)] nat_intv_frac_decomp[OF **(4,5)] **(1)"], ["proof (chain)\npicking this:\n  u x = real d + frac (u x)\n  u y = real d' + frac (u y)\n  u x - u y \\<le> real_of_int (int d - int d')", "show\n                \"frac (u x) \\<le> frac (u y)\""], ["proof (prove)\nusing this:\n  u x = real d + frac (u x)\n  u y = real d' + frac (u y)\n  u x - u y \\<le> real_of_int (int d - int d')\n\ngoal (1 subgoal):\n 1. frac (u x) \\<le> frac (u y)", "by simp"], ["proof (state)\nthis:\n  frac (u x) \\<le> frac (u y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  frac (u x) \\<le> frac (u y)\n\ngoal (1 subgoal):\n 1. frac (u x) \\<le> frac (u y) \\<Longrightarrow> (x, y) \\<in> r", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. frac (u x) \\<le> frac (u y) \\<Longrightarrow> (x, y) \\<in> r", "assume \"frac (u x) \\<le> frac (u y)\""], ["proof (state)\nthis:\n  frac (u x) \\<le> frac (u y)\n\ngoal (1 subgoal):\n 1. frac (u x) \\<le> frac (u y) \\<Longrightarrow> (x, y) \\<in> r", "show \"(x, y) \\<in> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> r", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. (x, y) \\<notin> r \\<Longrightarrow> False", "assume C: \"(x,y) \\<notin> r\""], ["proof (state)\nthis:\n  (x, y) \\<notin> r\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> r \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (x, y) \\<notin> r\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> r \\<Longrightarrow> False", "from R(2)"], ["proof (chain)\npicking this:\n  Regions.valid_region X k I r", "have \"total_on ?X\\<^sub>0 r\""], ["proof (prove)\nusing this:\n  Regions.valid_region X k I r\n\ngoal (1 subgoal):\n 1. total_on {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d} r", "by auto"], ["proof (state)\nthis:\n  total_on {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d} r\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> r \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  (x, y) \\<notin> r\n  total_on {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d} r", "have \"(y, x) \\<in> r\""], ["proof (prove)\nusing this:\n  (x, y) \\<notin> r\n  total_on {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d} r\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> r", "using False A"], ["proof (prove)\nusing this:\n  (x, y) \\<notin> r\n  total_on {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d} r\n  x \\<noteq> y\n  x \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n  y \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> r", "unfolding total_on_def"], ["proof (prove)\nusing this:\n  (x, y) \\<notin> r\n  \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n     \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n        x \\<noteq> y \\<longrightarrow> (x, y) \\<in> r \\<or> (y, x) \\<in> r\n  x \\<noteq> y\n  x \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n  y \\<in> {x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}\n\ngoal (1 subgoal):\n 1. (y, x) \\<in> r", "by auto"], ["proof (state)\nthis:\n  (y, x) \\<in> r\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> r \\<Longrightarrow> False", "with *(2-) AA C"], ["proof (chain)\npicking this:\n  dbm_entry_val u (Some y) (Some x) (h y x)\n  dbm_entry_val u None (Some x) (g x)\n  dbm_entry_val u (Some x) None (f x)\n  dbm_entry_val u None (Some y) (g y)\n  dbm_entry_val u (Some y) None (f y)\n  I x = Regions.intv.Intv d\n  I y = Regions.intv.Intv d'\n  Regions.isIntv (I x)\n  Regions.isIntv (I y)\n  \\<not> Regions.isConst (I x)\n  \\<not> Regions.isConst (I y)\n  (x, y) \\<notin> r\n  (y, x) \\<in> r", "have **:\n                \"u y - u x < int d' - d\"\n                \"d < u x\" \"u x < d + 1\" \"d' < u y\" \"u y < d' + 1\""], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some y) (Some x) (h y x)\n  dbm_entry_val u None (Some x) (g x)\n  dbm_entry_val u (Some x) None (f x)\n  dbm_entry_val u None (Some y) (g y)\n  dbm_entry_val u (Some y) None (f y)\n  I x = Regions.intv.Intv d\n  I y = Regions.intv.Intv d'\n  Regions.isIntv (I x)\n  Regions.isIntv (I y)\n  \\<not> Regions.isConst (I x)\n  \\<not> Regions.isConst (I y)\n  (x, y) \\<notin> r\n  (y, x) \\<in> r\n\ngoal (1 subgoal):\n 1. (u y - u x < real_of_int (int d' - int d) &&& real d < u x) &&&\n    u x < real (d + 1) &&& real d' < u y &&& u y < real (d' + 1)", "unfolding f_def g_def h_def"], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some y) (Some x)\n   (if Regions.isIntv (I y) \\<and> Regions.isIntv (I x)\n    then if (x, y) \\<in> r \\<and> (y, x) \\<notin> r\n         then Lt (real_of_int\n                   (int (intv_const (I y)) - int (intv_const (I x)) + 1))\n         else if (y, x) \\<in> r \\<and> (x, y) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I y)) - int (intv_const (I x))))\n              else Le (real_of_int\n                        (int (intv_const (I y)) - int (intv_const (I x))))\n    else if Regions.isConst (I y) \\<and> Regions.isConst (I x)\n         then Le (real_of_int\n                   (int (intv_const (I y)) - int (intv_const (I x))))\n         else if Regions.isIntv (I y) \\<and> Regions.isConst (I x)\n              then Lt (real_of_int\n                        (int (intv_const (I y)) + 1 -\n                         int (intv_const (I x))))\n              else if Regions.isConst (I y) \\<and> Regions.isIntv (I x)\n                   then Lt (real_of_int\n                             (int (intv_const (I y)) -\n                              int (intv_const (I x))))\n                   else \\<infinity>)\n  dbm_entry_val u None (Some x)\n   (if Regions.isIntv (I x) then Lt (real_of_int (- int (intv_const (I x))))\n    else if Regions.isConst (I x)\n         then Le (real_of_int (- int (intv_const (I x))))\n         else Lt (real_of_int (- int (k x))))\n  dbm_entry_val u (Some x) None\n   (if Regions.isIntv (I x) then Lt (real (intv_const (I x) + 1))\n    else if Regions.isConst (I x) then Le (real (intv_const (I x)))\n         else \\<infinity>)\n  dbm_entry_val u None (Some y)\n   (if Regions.isIntv (I y) then Lt (real_of_int (- int (intv_const (I y))))\n    else if Regions.isConst (I y)\n         then Le (real_of_int (- int (intv_const (I y))))\n         else Lt (real_of_int (- int (k y))))\n  dbm_entry_val u (Some y) None\n   (if Regions.isIntv (I y) then Lt (real (intv_const (I y) + 1))\n    else if Regions.isConst (I y) then Le (real (intv_const (I y)))\n         else \\<infinity>)\n  I x = Regions.intv.Intv d\n  I y = Regions.intv.Intv d'\n  Regions.isIntv (I x)\n  Regions.isIntv (I y)\n  \\<not> Regions.isConst (I x)\n  \\<not> Regions.isConst (I y)\n  (x, y) \\<notin> r\n  (y, x) \\<in> r\n\ngoal (1 subgoal):\n 1. (u y - u x < real_of_int (int d' - int d) &&& real d < u x) &&&\n    u x < real (d + 1) &&& real d' < u y &&& u y < real (d' + 1)", "by auto"], ["proof (state)\nthis:\n  u y - u x < real_of_int (int d' - int d)\n  real d < u x\n  u x < real (d + 1)\n  real d' < u y\n  u y < real (d' + 1)\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> r \\<Longrightarrow> False", "from nat_intv_frac_decomp[OF **(2,3)] nat_intv_frac_decomp[OF **(4,5)] **(1)"], ["proof (chain)\npicking this:\n  u x = real d + frac (u x)\n  u y = real d' + frac (u y)\n  u y - u x < real_of_int (int d' - int d)", "have\n                \"frac (u y) < frac (u x)\""], ["proof (prove)\nusing this:\n  u x = real d + frac (u x)\n  u y = real d' + frac (u y)\n  u y - u x < real_of_int (int d' - int d)\n\ngoal (1 subgoal):\n 1. frac (u y) < frac (u x)", "by simp"], ["proof (state)\nthis:\n  frac (u y) < frac (u x)\n\ngoal (1 subgoal):\n 1. (x, y) \\<notin> r \\<Longrightarrow> False", "with \\<open>frac _ \\<le> _\\<close>"], ["proof (chain)\npicking this:\n  frac (u x) \\<le> frac (u y)\n  frac (u y) < frac (u x)", "show False"], ["proof (prove)\nusing this:\n  frac (u x) \\<le> frac (u y)\n  frac (u y) < frac (u x)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x, y) \\<in> r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n     \\<forall>y\\<in>{x \\<in> X. \\<exists>d. I x = Regions.intv.Intv d}.\n        ((x, y) \\<in> r) = (frac (u x) \\<le> frac (u y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<in> R\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [(\\<lambda>i j.\n       if i = 0 then if j = 0 then Le 0 else g (v' j)\n       else if j = 0 then f (v' i)\n            else if i = j then Le 0\n                 else h (v' i) (v' j))]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> R\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  [(\\<lambda>i j.\n       if i = 0 then if j = 0 then Le 0 else g (v' j)\n       else if j = 0 then f (v' i)\n            else if i = j then Le 0\n                 else h (v' i) (v' j))]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> R\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"R \\<subseteq> [?M]\\<^bsub>v,n\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<subseteq> [(\\<lambda>i j.\n                       if i = 0 then if j = 0 then Le 0 else g (v' j)\n                       else if j = 0 then f (v' i)\n                            else if i = j then Le 0\n                                 else h (v' i) (v' j))]\\<^bsub>v,n\\<^esub>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> R \\<Longrightarrow>\n       x \\<in> [(\\<lambda>i j.\n                    if i = 0 then if j = 0 then Le 0 else g (v' j)\n                    else if j = 0 then f (v' i)\n                         else if i = j then Le 0\n                              else h (v' i) (v' j))]\\<^bsub>v,n\\<^esub>", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> R \\<Longrightarrow>\n       x \\<in> [(\\<lambda>i j.\n                    if i = 0 then if j = 0 then Le 0 else g (v' j)\n                    else if j = 0 then f (v' i)\n                         else if i = j then Le 0\n                              else h (v' i) (v' j))]\\<^bsub>v,n\\<^esub>", "assume u: \"u \\<in> R\""], ["proof (state)\nthis:\n  u \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> R \\<Longrightarrow>\n       x \\<in> [(\\<lambda>i j.\n                    if i = 0 then if j = 0 then Le 0 else g (v' j)\n                    else if j = 0 then f (v' i)\n                         else if i = j then Le 0\n                              else h (v' i) (v' j))]\\<^bsub>v,n\\<^esub>", "show \"u \\<in> [?M]\\<^bsub>v,n\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> [(\\<lambda>i j.\n                 if i = 0 then if j = 0 then Le 0 else g (v' j)\n                 else if j = 0 then f (v' i)\n                      else if i = j then Le 0\n                           else h (v' i) (v' j))]\\<^bsub>v,n\\<^esub>", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> {u. Le 0 \\<preceq> (if 0 = 0\n                                then if 0 = 0 then Le 0 else g (v' 0)\n                                else if 0 = 0 then f (v' 0)\n                                     else if 0 = 0 then Le 0\n    else h (v' 0) (v' 0)) \\<and>\n                (\\<forall>c.\n                    v c \\<le> n \\<longrightarrow>\n                    dbm_entry_val u None (Some c)\n                     (if 0 = 0 then if v c = 0 then Le 0 else g (v' (v c))\n                      else if v c = 0 then f (v' 0)\n                           else if 0 = v c then Le 0\n                                else h (v' 0) (v' (v c))) \\<and>\n                    dbm_entry_val u (Some c) None\n                     (if v c = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                      else if 0 = 0 then f (v' (v c))\n                           else if v c = 0 then Le 0\n                                else h (v' (v c)) (v' 0))) \\<and>\n                (\\<forall>c1 c2.\n                    v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                    dbm_entry_val u (Some c1) (Some c2)\n                     (if v c1 = 0\n                      then if v c2 = 0 then Le 0 else g (v' (v c2))\n                      else if v c2 = 0 then f (v' (v c1))\n                           else if v c1 = v c2 then Le 0\n                                else h (v' (v c1)) (v' (v c2))))}", "proof (safe, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. Le 0 \\<preceq> (if 0 = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                    else if 0 = 0 then f (v' 0)\n                         else if 0 = 0 then Le 0 else h (v' 0) (v' 0))\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u None (Some c)\n        (if 0 = 0 then if v c = 0 then Le 0 else g (v' (v c))\n         else if v c = 0 then f (v' 0)\n              else if 0 = v c then Le 0 else h (v' 0) (v' (v c)))\n 3. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None\n        (if v c = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' (v c))\n              else if v c = 0 then Le 0 else h (v' (v c)) (v' 0))\n 4. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if v c1 = 0\n                           then if v c2 = 0 then Le 0 else g (v' (v c2))\n                           else if v c2 = 0 then f (v' (v c1))\n                                else if v c1 = v c2 then Le 0\n                                     else h (v' (v c1)) (v' (v c2)))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. Le 0 \\<preceq> (if 0 = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                    else if 0 = 0 then f (v' 0)\n                         else if 0 = 0 then Le 0 else h (v' 0) (v' 0))\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u None (Some c)\n        (if 0 = 0 then if v c = 0 then Le 0 else g (v' (v c))\n         else if v c = 0 then f (v' 0)\n              else if 0 = v c then Le 0 else h (v' 0) (v' (v c)))\n 3. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None\n        (if v c = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' (v c))\n              else if v c = 0 then Le 0 else h (v' (v c)) (v' 0))\n 4. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if v c1 = 0\n                           then if v c2 = 0 then Le 0 else g (v' (v c2))\n                           else if v c2 = 0 then f (v' (v c1))\n                                else if v c1 = v c2 then Le 0\n                                     else h (v' (v c1)) (v' (v c2)))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Le 0 \\<preceq> (if 0 = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                    else if 0 = 0 then f (v' 0)\n                         else if 0 = 0 then Le 0 else h (v' 0) (v' 0))", "by auto"], ["proof (state)\nthis:\n  Le 0 \\<preceq> (if 0 = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                  else if 0 = 0 then f (v' 0)\n                       else if 0 = 0 then Le 0 else h (v' 0) (v' 0))\n\ngoal (3 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u None (Some c)\n        (if 0 = 0 then if v c = 0 then Le 0 else g (v' (v c))\n         else if v c = 0 then f (v' 0)\n              else if 0 = v c then Le 0 else h (v' 0) (v' (v c)))\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None\n        (if v c = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' (v c))\n              else if v c = 0 then Le 0 else h (v' (v c)) (v' 0))\n 3. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if v c1 = 0\n                           then if v c2 = 0 then Le 0 else g (v' (v c2))\n                           else if v c2 = 0 then f (v' (v c1))\n                                else if v c1 = v c2 then Le 0\n                                     else h (v' (v c1)) (v' (v c2)))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u None (Some c)\n        (if 0 = 0 then if v c = 0 then Le 0 else g (v' (v c))\n         else if v c = 0 then f (v' 0)\n              else if 0 = v c then Le 0 else h (v' 0) (v' (v c)))\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None\n        (if v c = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' (v c))\n              else if v c = 0 then Le 0 else h (v' (v c)) (v' 0))\n 3. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if v c1 = 0\n                           then if v c2 = 0 then Le 0 else g (v' (v c2))\n                           else if v c2 = 0 then f (v' (v c1))\n                                else if v c1 = v c2 then Le 0\n                                     else h (v' (v c1)) (v' (v c2)))", "case (2 c)"], ["proof (state)\nthis:\n  v c \\<le> n\n\ngoal (3 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u None (Some c)\n        (if 0 = 0 then if v c = 0 then Le 0 else g (v' (v c))\n         else if v c = 0 then f (v' 0)\n              else if 0 = v c then Le 0 else h (v' 0) (v' (v c)))\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None\n        (if v c = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' (v c))\n              else if v c = 0 then Le 0 else h (v' (v c)) (v' 0))\n 3. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if v c1 = 0\n                           then if v c2 = 0 then Le 0 else g (v' (v c2))\n                           else if v c2 = 0 then f (v' (v c1))\n                                else if v c1 = v c2 then Le 0\n                                     else h (v' (v c1)) (v' (v c2)))", "with clock_numbering"], ["proof (chain)\npicking this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  v c \\<le> n", "have \"c \\<in> X\""], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  v c \\<le> n\n\ngoal (1 subgoal):\n 1. c \\<in> X", "by metis"], ["proof (state)\nthis:\n  c \\<in> X\n\ngoal (3 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u None (Some c)\n        (if 0 = 0 then if v c = 0 then Le 0 else g (v' (v c))\n         else if v c = 0 then f (v' 0)\n              else if 0 = v c then Le 0 else h (v' 0) (v' (v c)))\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None\n        (if v c = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' (v c))\n              else if v c = 0 then Le 0 else h (v' (v c)) (v' 0))\n 3. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if v c1 = 0\n                           then if v c2 = 0 then Le 0 else g (v' (v c2))\n                           else if v c2 = 0 then f (v' (v c1))\n                                else if v c1 = v c2 then Le 0\n                                     else h (v' (v c1)) (v' (v c2)))", "with clock_numbering"], ["proof (chain)\npicking this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  c \\<in> X", "have *: \"c \\<in> X\" \"v c > 0\" \"v' (v c) = c\""], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  c \\<in> X\n\ngoal (1 subgoal):\n 1. c \\<in> X &&& 0 < v c &&& v' (v c) = c", "unfolding v'_def"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  c \\<in> X\n\ngoal (1 subgoal):\n 1. c \\<in> X &&& 0 < v c &&& (THE ca. ca \\<in> X \\<and> v ca = v c) = c", "by auto"], ["proof (state)\nthis:\n  c \\<in> X\n  0 < v c\n  v' (v c) = c\n\ngoal (3 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u None (Some c)\n        (if 0 = 0 then if v c = 0 then Le 0 else g (v' (v c))\n         else if v c = 0 then f (v' 0)\n              else if 0 = v c then Le 0 else h (v' 0) (v' (v c)))\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None\n        (if v c = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' (v c))\n              else if v c = 0 then Le 0 else h (v' (v c)) (v' 0))\n 3. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if v c1 = 0\n                           then if v c2 = 0 then Le 0 else g (v' (v c2))\n                           else if v c2 = 0 then f (v' (v c1))\n                                else if v c1 = v c2 then Le 0\n                                     else h (v' (v c1)) (v' (v c2)))", "with R u"], ["proof (chain)\npicking this:\n  R = Regions.region X I r\n  Regions.valid_region X k I r\n  u \\<in> R\n  c \\<in> X\n  0 < v c\n  v' (v c) = c", "have \"intv_elem c u (I c)\" \"valid_intv (k c) (I c)\""], ["proof (prove)\nusing this:\n  R = Regions.region X I r\n  Regions.valid_region X k I r\n  u \\<in> R\n  c \\<in> X\n  0 < v c\n  v' (v c) = c\n\ngoal (1 subgoal):\n 1. Regions.intv_elem c u (I c) &&& Regions.valid_intv (k c) (I c)", "by auto"], ["proof (state)\nthis:\n  Regions.intv_elem c u (I c)\n  Regions.valid_intv (k c) (I c)\n\ngoal (3 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u None (Some c)\n        (if 0 = 0 then if v c = 0 then Le 0 else g (v' (v c))\n         else if v c = 0 then f (v' 0)\n              else if 0 = v c then Le 0 else h (v' 0) (v' (v c)))\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None\n        (if v c = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' (v c))\n              else if v c = 0 then Le 0 else h (v' (v c)) (v' 0))\n 3. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if v c1 = 0\n                           then if v c2 = 0 then Le 0 else g (v' (v c2))\n                           else if v c2 = 0 then f (v' (v c1))\n                                else if v c1 = v c2 then Le 0\n                                     else h (v' (v c1)) (v' (v c2)))", "then"], ["proof (chain)\npicking this:\n  Regions.intv_elem c u (I c)\n  Regions.valid_intv (k c) (I c)", "have \"dbm_entry_val u None (Some c) (g c)\""], ["proof (prove)\nusing this:\n  Regions.intv_elem c u (I c)\n  Regions.valid_intv (k c) (I c)\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c) (g c)", "unfolding g_def"], ["proof (prove)\nusing this:\n  Regions.intv_elem c u (I c)\n  Regions.valid_intv (k c) (I c)\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c)\n     (if Regions.isIntv (I c)\n      then Lt (real_of_int (- int (intv_const (I c))))\n      else if Regions.isConst (I c)\n           then Le (real_of_int (- int (intv_const (I c))))\n           else Lt (real_of_int (- int (k c))))", "by (cases \"I c\") auto"], ["proof (state)\nthis:\n  dbm_entry_val u None (Some c) (g c)\n\ngoal (3 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u None (Some c)\n        (if 0 = 0 then if v c = 0 then Le 0 else g (v' (v c))\n         else if v c = 0 then f (v' 0)\n              else if 0 = v c then Le 0 else h (v' 0) (v' (v c)))\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None\n        (if v c = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' (v c))\n              else if v c = 0 then Le 0 else h (v' (v c)) (v' 0))\n 3. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if v c1 = 0\n                           then if v c2 = 0 then Le 0 else g (v' (v c2))\n                           else if v c2 = 0 then f (v' (v c1))\n                                else if v c1 = v c2 then Le 0\n                                     else h (v' (v c1)) (v' (v c2)))", "with *"], ["proof (chain)\npicking this:\n  c \\<in> X\n  0 < v c\n  v' (v c) = c\n  dbm_entry_val u None (Some c) (g c)", "show ?case"], ["proof (prove)\nusing this:\n  c \\<in> X\n  0 < v c\n  v' (v c) = c\n  dbm_entry_val u None (Some c) (g c)\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c)\n     (if 0 = 0 then if v c = 0 then Le 0 else g (v' (v c))\n      else if v c = 0 then f (v' 0)\n           else if 0 = v c then Le 0 else h (v' 0) (v' (v c)))", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u None (Some c)\n   (if 0 = 0 then if v c = 0 then Le 0 else g (v' (v c))\n    else if v c = 0 then f (v' 0)\n         else if 0 = v c then Le 0 else h (v' 0) (v' (v c)))\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None\n        (if v c = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' (v c))\n              else if v c = 0 then Le 0 else h (v' (v c)) (v' 0))\n 2. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if v c1 = 0\n                           then if v c2 = 0 then Le 0 else g (v' (v c2))\n                           else if v c2 = 0 then f (v' (v c1))\n                                else if v c1 = v c2 then Le 0\n                                     else h (v' (v c1)) (v' (v c2)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None\n        (if v c = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' (v c))\n              else if v c = 0 then Le 0 else h (v' (v c)) (v' 0))\n 2. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if v c1 = 0\n                           then if v c2 = 0 then Le 0 else g (v' (v c2))\n                           else if v c2 = 0 then f (v' (v c1))\n                                else if v c1 = v c2 then Le 0\n                                     else h (v' (v c1)) (v' (v c2)))", "case (3 c)"], ["proof (state)\nthis:\n  v c \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None\n        (if v c = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' (v c))\n              else if v c = 0 then Le 0 else h (v' (v c)) (v' 0))\n 2. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if v c1 = 0\n                           then if v c2 = 0 then Le 0 else g (v' (v c2))\n                           else if v c2 = 0 then f (v' (v c1))\n                                else if v c1 = v c2 then Le 0\n                                     else h (v' (v c1)) (v' (v c2)))", "with clock_numbering"], ["proof (chain)\npicking this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  v c \\<le> n", "have \"c \\<in> X\""], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  v c \\<le> n\n\ngoal (1 subgoal):\n 1. c \\<in> X", "by metis"], ["proof (state)\nthis:\n  c \\<in> X\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None\n        (if v c = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' (v c))\n              else if v c = 0 then Le 0 else h (v' (v c)) (v' 0))\n 2. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if v c1 = 0\n                           then if v c2 = 0 then Le 0 else g (v' (v c2))\n                           else if v c2 = 0 then f (v' (v c1))\n                                else if v c1 = v c2 then Le 0\n                                     else h (v' (v c1)) (v' (v c2)))", "with clock_numbering"], ["proof (chain)\npicking this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  c \\<in> X", "have *: \"c \\<in> X\" \"v c > 0\" \"v' (v c) = c\""], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  c \\<in> X\n\ngoal (1 subgoal):\n 1. c \\<in> X &&& 0 < v c &&& v' (v c) = c", "unfolding v'_def"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  c \\<in> X\n\ngoal (1 subgoal):\n 1. c \\<in> X &&& 0 < v c &&& (THE ca. ca \\<in> X \\<and> v ca = v c) = c", "by auto"], ["proof (state)\nthis:\n  c \\<in> X\n  0 < v c\n  v' (v c) = c\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None\n        (if v c = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' (v c))\n              else if v c = 0 then Le 0 else h (v' (v c)) (v' 0))\n 2. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if v c1 = 0\n                           then if v c2 = 0 then Le 0 else g (v' (v c2))\n                           else if v c2 = 0 then f (v' (v c1))\n                                else if v c1 = v c2 then Le 0\n                                     else h (v' (v c1)) (v' (v c2)))", "with R u"], ["proof (chain)\npicking this:\n  R = Regions.region X I r\n  Regions.valid_region X k I r\n  u \\<in> R\n  c \\<in> X\n  0 < v c\n  v' (v c) = c", "have \"intv_elem c u (I c)\" \"valid_intv (k c) (I c)\""], ["proof (prove)\nusing this:\n  R = Regions.region X I r\n  Regions.valid_region X k I r\n  u \\<in> R\n  c \\<in> X\n  0 < v c\n  v' (v c) = c\n\ngoal (1 subgoal):\n 1. Regions.intv_elem c u (I c) &&& Regions.valid_intv (k c) (I c)", "by auto"], ["proof (state)\nthis:\n  Regions.intv_elem c u (I c)\n  Regions.valid_intv (k c) (I c)\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None\n        (if v c = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' (v c))\n              else if v c = 0 then Le 0 else h (v' (v c)) (v' 0))\n 2. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if v c1 = 0\n                           then if v c2 = 0 then Le 0 else g (v' (v c2))\n                           else if v c2 = 0 then f (v' (v c1))\n                                else if v c1 = v c2 then Le 0\n                                     else h (v' (v c1)) (v' (v c2)))", "then"], ["proof (chain)\npicking this:\n  Regions.intv_elem c u (I c)\n  Regions.valid_intv (k c) (I c)", "have \"dbm_entry_val u (Some c) None (f c)\""], ["proof (prove)\nusing this:\n  Regions.intv_elem c u (I c)\n  Regions.valid_intv (k c) (I c)\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) None (f c)", "unfolding f_def"], ["proof (prove)\nusing this:\n  Regions.intv_elem c u (I c)\n  Regions.valid_intv (k c) (I c)\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) None\n     (if Regions.isIntv (I c) then Lt (real (intv_const (I c) + 1))\n      else if Regions.isConst (I c) then Le (real (intv_const (I c)))\n           else \\<infinity>)", "by (cases \"I c\") auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c) None (f c)\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None\n        (if v c = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' (v c))\n              else if v c = 0 then Le 0 else h (v' (v c)) (v' 0))\n 2. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if v c1 = 0\n                           then if v c2 = 0 then Le 0 else g (v' (v c2))\n                           else if v c2 = 0 then f (v' (v c1))\n                                else if v c1 = v c2 then Le 0\n                                     else h (v' (v c1)) (v' (v c2)))", "with *"], ["proof (chain)\npicking this:\n  c \\<in> X\n  0 < v c\n  v' (v c) = c\n  dbm_entry_val u (Some c) None (f c)", "show ?case"], ["proof (prove)\nusing this:\n  c \\<in> X\n  0 < v c\n  v' (v c) = c\n  dbm_entry_val u (Some c) None (f c)\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) None\n     (if v c = 0 then if 0 = 0 then Le 0 else g (v' 0)\n      else if 0 = 0 then f (v' (v c))\n           else if v c = 0 then Le 0 else h (v' (v c)) (v' 0))", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c) None\n   (if v c = 0 then if 0 = 0 then Le 0 else g (v' 0)\n    else if 0 = 0 then f (v' (v c))\n         else if v c = 0 then Le 0 else h (v' (v c)) (v' 0))\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if v c1 = 0\n                           then if v c2 = 0 then Le 0 else g (v' (v c2))\n                           else if v c2 = 0 then f (v' (v c1))\n                                else if v c1 = v c2 then Le 0\n                                     else h (v' (v c1)) (v' (v c2)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if v c1 = 0\n                           then if v c2 = 0 then Le 0 else g (v' (v c2))\n                           else if v c2 = 0 then f (v' (v c1))\n                                else if v c1 = v c2 then Le 0\n                                     else h (v' (v c1)) (v' (v c2)))", "case (4 c1 c2)"], ["proof (state)\nthis:\n  v c1 \\<le> n\n  v c2 \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if v c1 = 0\n                           then if v c2 = 0 then Le 0 else g (v' (v c2))\n                           else if v c2 = 0 then f (v' (v c1))\n                                else if v c1 = v c2 then Le 0\n                                     else h (v' (v c1)) (v' (v c2)))", "with clock_numbering"], ["proof (chain)\npicking this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  v c1 \\<le> n\n  v c2 \\<le> n", "have \"c1 \\<in> X\" \"c2 \\<in> X\""], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  v c1 \\<le> n\n  v c2 \\<le> n\n\ngoal (1 subgoal):\n 1. c1 \\<in> X &&& c2 \\<in> X", "by metis+"], ["proof (state)\nthis:\n  c1 \\<in> X\n  c2 \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if v c1 = 0\n                           then if v c2 = 0 then Le 0 else g (v' (v c2))\n                           else if v c2 = 0 then f (v' (v c1))\n                                else if v c1 = v c2 then Le 0\n                                     else h (v' (v c1)) (v' (v c2)))", "with clock_numbering"], ["proof (chain)\npicking this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  c1 \\<in> X\n  c2 \\<in> X", "have *:\n        \"c1 \\<in> X\" \"v c1 > 0\" \"v' (v c1) = c1\" \"c2 \\<in> X\" \"v c2 > 0\" \"v' (v c2) = c2\""], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  c1 \\<in> X\n  c2 \\<in> X\n\ngoal (1 subgoal):\n 1. (c1 \\<in> X &&& 0 < v c1 &&& v' (v c1) = c1) &&&\n    c2 \\<in> X &&& 0 < v c2 &&& v' (v c2) = c2", "unfolding v'_def"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  c1 \\<in> X\n  c2 \\<in> X\n\ngoal (1 subgoal):\n 1. (c1 \\<in> X &&&\n     0 < v c1 &&& (THE c. c \\<in> X \\<and> v c = v c1) = c1) &&&\n    c2 \\<in> X &&& 0 < v c2 &&& (THE c. c \\<in> X \\<and> v c = v c2) = c2", "by auto"], ["proof (state)\nthis:\n  c1 \\<in> X\n  0 < v c1\n  v' (v c1) = c1\n  c2 \\<in> X\n  0 < v c2\n  v' (v c2) = c2\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if v c1 = 0\n                           then if v c2 = 0 then Le 0 else g (v' (v c2))\n                           else if v c2 = 0 then f (v' (v c1))\n                                else if v c1 = v c2 then Le 0\n                                     else h (v' (v c1)) (v' (v c2)))", "with R u"], ["proof (chain)\npicking this:\n  R = Regions.region X I r\n  Regions.valid_region X k I r\n  u \\<in> R\n  c1 \\<in> X\n  0 < v c1\n  v' (v c1) = c1\n  c2 \\<in> X\n  0 < v c2\n  v' (v c2) = c2", "have\n        \"intv_elem c1 u (I c1)\" \"valid_intv (k c1) (I c1)\"\n        \"intv_elem c2 u (I c2)\" \"valid_intv (k c2) (I c2)\""], ["proof (prove)\nusing this:\n  R = Regions.region X I r\n  Regions.valid_region X k I r\n  u \\<in> R\n  c1 \\<in> X\n  0 < v c1\n  v' (v c1) = c1\n  c2 \\<in> X\n  0 < v c2\n  v' (v c2) = c2\n\ngoal (1 subgoal):\n 1. (Regions.intv_elem c1 u (I c1) &&& Regions.valid_intv (k c1) (I c1)) &&&\n    Regions.intv_elem c2 u (I c2) &&& Regions.valid_intv (k c2) (I c2)", "by auto"], ["proof (state)\nthis:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if v c1 = 0\n                           then if v c2 = 0 then Le 0 else g (v' (v c2))\n                           else if v c2 = 0 then f (v' (v c1))\n                                else if v c1 = v c2 then Le 0\n                                     else h (v' (v c1)) (v' (v c2)))", "then"], ["proof (chain)\npicking this:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)", "have \"dbm_entry_val u (Some c1) (Some c2) (h c1 c2)\""], ["proof (prove)\nusing this:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) (Some c2) (h c1 c2)", "unfolding h_def"], ["proof (prove)\nusing this:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)", "proof(cases \"I c1\", cases \"I c2\", fastforce+, cases \"I c2\", fastforce, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x2 x2a.\n       \\<lbrakk>Regions.intv_elem c1 u (I c1);\n        Regions.valid_intv (k c1) (I c1); Regions.intv_elem c2 u (I c2);\n        Regions.valid_intv (k c2) (I c2); I c1 = Regions.intv.Intv x2;\n        Regions.intv_elem c1 u (I c1); Regions.valid_intv (k c1) (I c1);\n        Regions.intv_elem c2 u (I c2); Regions.valid_intv (k c2) (I c2);\n        I c2 = Regions.intv.Intv x2a\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if Regions.isIntv (I c1) \\<and>\n                              Regions.isIntv (I c2)\n                           then if (c2, c1) \\<in> r \\<and>\n                                   (c1, c2) \\<notin> r\n                                then Lt\n(real_of_int (int (intv_const (I c1)) - int (intv_const (I c2)) + 1))\n                                else if (c1, c2) \\<in> r \\<and>\n  (c2, c1) \\<notin> r\n                                     then Lt\n     (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                                     else Le\n     (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                           else if Regions.isConst (I c1) \\<and>\n                                   Regions.isConst (I c2)\n                                then Le\n(real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                                else if Regions.isIntv (I c1) \\<and>\n  Regions.isConst (I c2)\n                                     then Lt\n     (real_of_int (int (intv_const (I c1)) + 1 - int (intv_const (I c2))))\n                                     else if Regions.isConst (I c1) \\<and>\n       Regions.isIntv (I c2)\n    then Lt (real_of_int\n              (int (intv_const (I c1)) - int (intv_const (I c2))))\n    else \\<infinity>)\n 2. \\<And>x2 x3.\n       \\<lbrakk>Regions.intv_elem c1 u (I c1);\n        Regions.valid_intv (k c1) (I c1); Regions.intv_elem c2 u (I c2);\n        Regions.valid_intv (k c2) (I c2); I c1 = Regions.intv.Intv x2;\n        Regions.intv_elem c1 u (I c1); Regions.valid_intv (k c1) (I c1);\n        Regions.intv_elem c2 u (I c2); Regions.valid_intv (k c2) (I c2);\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if Regions.isIntv (I c1) \\<and>\n                              Regions.isIntv (I c2)\n                           then if (c2, c1) \\<in> r \\<and>\n                                   (c1, c2) \\<notin> r\n                                then Lt\n(real_of_int (int (intv_const (I c1)) - int (intv_const (I c2)) + 1))\n                                else if (c1, c2) \\<in> r \\<and>\n  (c2, c1) \\<notin> r\n                                     then Lt\n     (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                                     else Le\n     (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                           else if Regions.isConst (I c1) \\<and>\n                                   Regions.isConst (I c2)\n                                then Le\n(real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                                else if Regions.isIntv (I c1) \\<and>\n  Regions.isConst (I c2)\n                                     then Lt\n     (real_of_int (int (intv_const (I c1)) + 1 - int (intv_const (I c2))))\n                                     else if Regions.isConst (I c1) \\<and>\n       Regions.isIntv (I c2)\n    then Lt (real_of_int\n              (int (intv_const (I c1)) - int (intv_const (I c2))))\n    else \\<infinity>)\n 3. \\<And>x3.\n       \\<lbrakk>Regions.intv_elem c1 u (I c1);\n        Regions.valid_intv (k c1) (I c1); Regions.intv_elem c2 u (I c2);\n        Regions.valid_intv (k c2) (I c2);\n        I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if Regions.isIntv (I c1) \\<and>\n                              Regions.isIntv (I c2)\n                           then if (c2, c1) \\<in> r \\<and>\n                                   (c1, c2) \\<notin> r\n                                then Lt\n(real_of_int (int (intv_const (I c1)) - int (intv_const (I c2)) + 1))\n                                else if (c1, c2) \\<in> r \\<and>\n  (c2, c1) \\<notin> r\n                                     then Lt\n     (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                                     else Le\n     (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                           else if Regions.isConst (I c1) \\<and>\n                                   Regions.isConst (I c2)\n                                then Le\n(real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                                else if Regions.isIntv (I c1) \\<and>\n  Regions.isConst (I c2)\n                                     then Lt\n     (real_of_int (int (intv_const (I c1)) + 1 - int (intv_const (I c2))))\n                                     else if Regions.isConst (I c1) \\<and>\n       Regions.isIntv (I c2)\n    then Lt (real_of_int\n              (int (intv_const (I c1)) - int (intv_const (I c2))))\n    else \\<infinity>)", "case (1 d d')"], ["proof (state)\nthis:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c1 = Regions.intv.Intv d\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c2 = Regions.intv.Intv d'\n\ngoal (3 subgoals):\n 1. \\<And>x2 x2a.\n       \\<lbrakk>Regions.intv_elem c1 u (I c1);\n        Regions.valid_intv (k c1) (I c1); Regions.intv_elem c2 u (I c2);\n        Regions.valid_intv (k c2) (I c2); I c1 = Regions.intv.Intv x2;\n        Regions.intv_elem c1 u (I c1); Regions.valid_intv (k c1) (I c1);\n        Regions.intv_elem c2 u (I c2); Regions.valid_intv (k c2) (I c2);\n        I c2 = Regions.intv.Intv x2a\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if Regions.isIntv (I c1) \\<and>\n                              Regions.isIntv (I c2)\n                           then if (c2, c1) \\<in> r \\<and>\n                                   (c1, c2) \\<notin> r\n                                then Lt\n(real_of_int (int (intv_const (I c1)) - int (intv_const (I c2)) + 1))\n                                else if (c1, c2) \\<in> r \\<and>\n  (c2, c1) \\<notin> r\n                                     then Lt\n     (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                                     else Le\n     (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                           else if Regions.isConst (I c1) \\<and>\n                                   Regions.isConst (I c2)\n                                then Le\n(real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                                else if Regions.isIntv (I c1) \\<and>\n  Regions.isConst (I c2)\n                                     then Lt\n     (real_of_int (int (intv_const (I c1)) + 1 - int (intv_const (I c2))))\n                                     else if Regions.isConst (I c1) \\<and>\n       Regions.isIntv (I c2)\n    then Lt (real_of_int\n              (int (intv_const (I c1)) - int (intv_const (I c2))))\n    else \\<infinity>)\n 2. \\<And>x2 x3.\n       \\<lbrakk>Regions.intv_elem c1 u (I c1);\n        Regions.valid_intv (k c1) (I c1); Regions.intv_elem c2 u (I c2);\n        Regions.valid_intv (k c2) (I c2); I c1 = Regions.intv.Intv x2;\n        Regions.intv_elem c1 u (I c1); Regions.valid_intv (k c1) (I c1);\n        Regions.intv_elem c2 u (I c2); Regions.valid_intv (k c2) (I c2);\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if Regions.isIntv (I c1) \\<and>\n                              Regions.isIntv (I c2)\n                           then if (c2, c1) \\<in> r \\<and>\n                                   (c1, c2) \\<notin> r\n                                then Lt\n(real_of_int (int (intv_const (I c1)) - int (intv_const (I c2)) + 1))\n                                else if (c1, c2) \\<in> r \\<and>\n  (c2, c1) \\<notin> r\n                                     then Lt\n     (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                                     else Le\n     (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                           else if Regions.isConst (I c1) \\<and>\n                                   Regions.isConst (I c2)\n                                then Le\n(real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                                else if Regions.isIntv (I c1) \\<and>\n  Regions.isConst (I c2)\n                                     then Lt\n     (real_of_int (int (intv_const (I c1)) + 1 - int (intv_const (I c2))))\n                                     else if Regions.isConst (I c1) \\<and>\n       Regions.isIntv (I c2)\n    then Lt (real_of_int\n              (int (intv_const (I c1)) - int (intv_const (I c2))))\n    else \\<infinity>)\n 3. \\<And>x3.\n       \\<lbrakk>Regions.intv_elem c1 u (I c1);\n        Regions.valid_intv (k c1) (I c1); Regions.intv_elem c2 u (I c2);\n        Regions.valid_intv (k c2) (I c2);\n        I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if Regions.isIntv (I c1) \\<and>\n                              Regions.isIntv (I c2)\n                           then if (c2, c1) \\<in> r \\<and>\n                                   (c1, c2) \\<notin> r\n                                then Lt\n(real_of_int (int (intv_const (I c1)) - int (intv_const (I c2)) + 1))\n                                else if (c1, c2) \\<in> r \\<and>\n  (c2, c1) \\<notin> r\n                                     then Lt\n     (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                                     else Le\n     (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                           else if Regions.isConst (I c1) \\<and>\n                                   Regions.isConst (I c2)\n                                then Le\n(real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                                else if Regions.isIntv (I c1) \\<and>\n  Regions.isConst (I c2)\n                                     then Lt\n     (real_of_int (int (intv_const (I c1)) + 1 - int (intv_const (I c2))))\n                                     else if Regions.isConst (I c1) \\<and>\n       Regions.isIntv (I c2)\n    then Lt (real_of_int\n              (int (intv_const (I c1)) - int (intv_const (I c2))))\n    else \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c1 = Regions.intv.Intv d\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c2 = Regions.intv.Intv d'", "show ?case"], ["proof (prove)\nusing this:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c1 = Regions.intv.Intv d\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c2 = Regions.intv.Intv d'\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)", "proof (cases \"(c2, c1) \\<in> r\", goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>Regions.intv_elem c1 u (I c1);\n     Regions.valid_intv (k c1) (I c1); Regions.intv_elem c2 u (I c2);\n     Regions.valid_intv (k c2) (I c2); I c1 = Regions.intv.Intv d;\n     Regions.intv_elem c1 u (I c1); Regions.valid_intv (k c1) (I c1);\n     Regions.intv_elem c2 u (I c2); Regions.valid_intv (k c2) (I c2);\n     I c2 = Regions.intv.Intv d'; (c2, c1) \\<in> r\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                       (if Regions.isIntv (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n                             then Lt (real_of_int\n (int (intv_const (I c1)) - int (intv_const (I c2)) + 1))\n                             else if (c1, c2) \\<in> r \\<and>\n                                     (c2, c1) \\<notin> r\n                                  then Lt\n  (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                                  else Le\n  (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                        else if Regions.isConst (I c1) \\<and>\n                                Regions.isConst (I c2)\n                             then Le (real_of_int\n (int (intv_const (I c1)) - int (intv_const (I c2))))\n                             else if Regions.isIntv (I c1) \\<and>\n                                     Regions.isConst (I c2)\n                                  then Lt\n  (real_of_int (int (intv_const (I c1)) + 1 - int (intv_const (I c2))))\n                                  else if Regions.isConst (I c1) \\<and>\n    Regions.isIntv (I c2)\n then Lt (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n else \\<infinity>)\n 2. \\<lbrakk>Regions.intv_elem c1 u (I c1);\n     Regions.valid_intv (k c1) (I c1); Regions.intv_elem c2 u (I c2);\n     Regions.valid_intv (k c2) (I c2); I c1 = Regions.intv.Intv d;\n     Regions.intv_elem c1 u (I c1); Regions.valid_intv (k c1) (I c1);\n     Regions.intv_elem c2 u (I c2); Regions.valid_intv (k c2) (I c2);\n     I c2 = Regions.intv.Intv d'; (c2, c1) \\<notin> r\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                       (if Regions.isIntv (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n                             then Lt (real_of_int\n (int (intv_const (I c1)) - int (intv_const (I c2)) + 1))\n                             else if (c1, c2) \\<in> r \\<and>\n                                     (c2, c1) \\<notin> r\n                                  then Lt\n  (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                                  else Le\n  (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                        else if Regions.isConst (I c1) \\<and>\n                                Regions.isConst (I c2)\n                             then Le (real_of_int\n (int (intv_const (I c1)) - int (intv_const (I c2))))\n                             else if Regions.isIntv (I c1) \\<and>\n                                     Regions.isConst (I c2)\n                                  then Lt\n  (real_of_int (int (intv_const (I c1)) + 1 - int (intv_const (I c2))))\n                                  else if Regions.isConst (I c1) \\<and>\n    Regions.isIntv (I c2)\n then Lt (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n else \\<infinity>)", "case 1"], ["proof (state)\nthis:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c1 = Regions.intv.Intv d\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c2 = Regions.intv.Intv d'\n  (c2, c1) \\<in> r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>Regions.intv_elem c1 u (I c1);\n     Regions.valid_intv (k c1) (I c1); Regions.intv_elem c2 u (I c2);\n     Regions.valid_intv (k c2) (I c2); I c1 = Regions.intv.Intv d;\n     Regions.intv_elem c1 u (I c1); Regions.valid_intv (k c1) (I c1);\n     Regions.intv_elem c2 u (I c2); Regions.valid_intv (k c2) (I c2);\n     I c2 = Regions.intv.Intv d'; (c2, c1) \\<in> r\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                       (if Regions.isIntv (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n                             then Lt (real_of_int\n (int (intv_const (I c1)) - int (intv_const (I c2)) + 1))\n                             else if (c1, c2) \\<in> r \\<and>\n                                     (c2, c1) \\<notin> r\n                                  then Lt\n  (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                                  else Le\n  (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                        else if Regions.isConst (I c1) \\<and>\n                                Regions.isConst (I c2)\n                             then Le (real_of_int\n (int (intv_const (I c1)) - int (intv_const (I c2))))\n                             else if Regions.isIntv (I c1) \\<and>\n                                     Regions.isConst (I c2)\n                                  then Lt\n  (real_of_int (int (intv_const (I c1)) + 1 - int (intv_const (I c2))))\n                                  else if Regions.isConst (I c1) \\<and>\n    Regions.isIntv (I c2)\n then Lt (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n else \\<infinity>)\n 2. \\<lbrakk>Regions.intv_elem c1 u (I c1);\n     Regions.valid_intv (k c1) (I c1); Regions.intv_elem c2 u (I c2);\n     Regions.valid_intv (k c2) (I c2); I c1 = Regions.intv.Intv d;\n     Regions.intv_elem c1 u (I c1); Regions.valid_intv (k c1) (I c1);\n     Regions.intv_elem c2 u (I c2); Regions.valid_intv (k c2) (I c2);\n     I c2 = Regions.intv.Intv d'; (c2, c1) \\<notin> r\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                       (if Regions.isIntv (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n                             then Lt (real_of_int\n (int (intv_const (I c1)) - int (intv_const (I c2)) + 1))\n                             else if (c1, c2) \\<in> r \\<and>\n                                     (c2, c1) \\<notin> r\n                                  then Lt\n  (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                                  else Le\n  (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                        else if Regions.isConst (I c1) \\<and>\n                                Regions.isConst (I c2)\n                             then Le (real_of_int\n (int (intv_const (I c1)) - int (intv_const (I c2))))\n                             else if Regions.isIntv (I c1) \\<and>\n                                     Regions.isConst (I c2)\n                                  then Lt\n  (real_of_int (int (intv_const (I c1)) + 1 - int (intv_const (I c2))))\n                                  else if Regions.isConst (I c1) \\<and>\n    Regions.isIntv (I c2)\n then Lt (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n else \\<infinity>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)", "proof (cases \"(c1, c2) \\<in> r\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (c1, c2) \\<in> r \\<Longrightarrow>\n    dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)\n 2. (c1, c2) \\<notin> r \\<Longrightarrow>\n    dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)", "case True"], ["proof (state)\nthis:\n  (c1, c2) \\<in> r\n\ngoal (2 subgoals):\n 1. (c1, c2) \\<in> r \\<Longrightarrow>\n    dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)\n 2. (c1, c2) \\<notin> r \\<Longrightarrow>\n    dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)", "with 1 *(1,4) R(1) u"], ["proof (chain)\npicking this:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c1 = Regions.intv.Intv d\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c2 = Regions.intv.Intv d'\n  (c2, c1) \\<in> r\n  c1 \\<in> X\n  c2 \\<in> X\n  R = Regions.region X I r\n  u \\<in> R\n  (c1, c2) \\<in> r", "have \"frac (u c1) = frac (u c2)\""], ["proof (prove)\nusing this:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c1 = Regions.intv.Intv d\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c2 = Regions.intv.Intv d'\n  (c2, c1) \\<in> r\n  c1 \\<in> X\n  c2 \\<in> X\n  R = Regions.region X I r\n  u \\<in> R\n  (c1, c2) \\<in> r\n\ngoal (1 subgoal):\n 1. frac (u c1) = frac (u c2)", "by auto"], ["proof (state)\nthis:\n  frac (u c1) = frac (u c2)\n\ngoal (2 subgoals):\n 1. (c1, c2) \\<in> r \\<Longrightarrow>\n    dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)\n 2. (c1, c2) \\<notin> r \\<Longrightarrow>\n    dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)", "with 1"], ["proof (chain)\npicking this:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c1 = Regions.intv.Intv d\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c2 = Regions.intv.Intv d'\n  (c2, c1) \\<in> r\n  frac (u c1) = frac (u c2)", "have \"u c1 - u c2 = real d - d'\""], ["proof (prove)\nusing this:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c1 = Regions.intv.Intv d\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c2 = Regions.intv.Intv d'\n  (c2, c1) \\<in> r\n  frac (u c1) = frac (u c2)\n\ngoal (1 subgoal):\n 1. u c1 - u c2 = real d - real d'", "by (fastforce dest: nat_intv_frac_decomp)"], ["proof (state)\nthis:\n  u c1 - u c2 = real d - real d'\n\ngoal (2 subgoals):\n 1. (c1, c2) \\<in> r \\<Longrightarrow>\n    dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)\n 2. (c1, c2) \\<notin> r \\<Longrightarrow>\n    dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)", "with 1"], ["proof (chain)\npicking this:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c1 = Regions.intv.Intv d\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c2 = Regions.intv.Intv d'\n  (c2, c1) \\<in> r\n  u c1 - u c2 = real d - real d'", "show ?thesis"], ["proof (prove)\nusing this:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c1 = Regions.intv.Intv d\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c2 = Regions.intv.Intv d'\n  (c2, c1) \\<in> r\n  u c1 - u c2 = real d - real d'\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c1) (Some c2)\n   (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n    then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n         then Lt (real_of_int\n                   (int (intv_const (I c1)) - int (intv_const (I c2)) + 1))\n         else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n    else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n         then Le (real_of_int\n                   (int (intv_const (I c1)) - int (intv_const (I c2))))\n         else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) + 1 -\n                         int (intv_const (I c2))))\n              else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else \\<infinity>)\n\ngoal (1 subgoal):\n 1. (c1, c2) \\<notin> r \\<Longrightarrow>\n    dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (c1, c2) \\<notin> r \\<Longrightarrow>\n    dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)", "case False"], ["proof (state)\nthis:\n  (c1, c2) \\<notin> r\n\ngoal (1 subgoal):\n 1. (c1, c2) \\<notin> r \\<Longrightarrow>\n    dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)", "with 1"], ["proof (chain)\npicking this:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c1 = Regions.intv.Intv d\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c2 = Regions.intv.Intv d'\n  (c2, c1) \\<in> r\n  (c1, c2) \\<notin> r", "show ?thesis"], ["proof (prove)\nusing this:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c1 = Regions.intv.Intv d\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c2 = Regions.intv.Intv d'\n  (c2, c1) \\<in> r\n  (c1, c2) \\<notin> r\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c1) (Some c2)\n   (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n    then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n         then Lt (real_of_int\n                   (int (intv_const (I c1)) - int (intv_const (I c2)) + 1))\n         else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n    else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n         then Le (real_of_int\n                   (int (intv_const (I c1)) - int (intv_const (I c2))))\n         else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) + 1 -\n                         int (intv_const (I c2))))\n              else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c1) (Some c2)\n   (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n    then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n         then Lt (real_of_int\n                   (int (intv_const (I c1)) - int (intv_const (I c2)) + 1))\n         else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n    else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n         then Le (real_of_int\n                   (int (intv_const (I c1)) - int (intv_const (I c2))))\n         else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) + 1 -\n                         int (intv_const (I c2))))\n              else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else \\<infinity>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Regions.intv_elem c1 u (I c1);\n     Regions.valid_intv (k c1) (I c1); Regions.intv_elem c2 u (I c2);\n     Regions.valid_intv (k c2) (I c2); I c1 = Regions.intv.Intv d;\n     Regions.intv_elem c1 u (I c1); Regions.valid_intv (k c1) (I c1);\n     Regions.intv_elem c2 u (I c2); Regions.valid_intv (k c2) (I c2);\n     I c2 = Regions.intv.Intv d'; (c2, c1) \\<notin> r\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                       (if Regions.isIntv (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n                             then Lt (real_of_int\n (int (intv_const (I c1)) - int (intv_const (I c2)) + 1))\n                             else if (c1, c2) \\<in> r \\<and>\n                                     (c2, c1) \\<notin> r\n                                  then Lt\n  (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                                  else Le\n  (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                        else if Regions.isConst (I c1) \\<and>\n                                Regions.isConst (I c2)\n                             then Le (real_of_int\n (int (intv_const (I c1)) - int (intv_const (I c2))))\n                             else if Regions.isIntv (I c1) \\<and>\n                                     Regions.isConst (I c2)\n                                  then Lt\n  (real_of_int (int (intv_const (I c1)) + 1 - int (intv_const (I c2))))\n                                  else if Regions.isConst (I c1) \\<and>\n    Regions.isIntv (I c2)\n then Lt (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n else \\<infinity>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Regions.intv_elem c1 u (I c1);\n     Regions.valid_intv (k c1) (I c1); Regions.intv_elem c2 u (I c2);\n     Regions.valid_intv (k c2) (I c2); I c1 = Regions.intv.Intv d;\n     Regions.intv_elem c1 u (I c1); Regions.valid_intv (k c1) (I c1);\n     Regions.intv_elem c2 u (I c2); Regions.valid_intv (k c2) (I c2);\n     I c2 = Regions.intv.Intv d'; (c2, c1) \\<notin> r\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                       (if Regions.isIntv (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n                             then Lt (real_of_int\n (int (intv_const (I c1)) - int (intv_const (I c2)) + 1))\n                             else if (c1, c2) \\<in> r \\<and>\n                                     (c2, c1) \\<notin> r\n                                  then Lt\n  (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                                  else Le\n  (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                        else if Regions.isConst (I c1) \\<and>\n                                Regions.isConst (I c2)\n                             then Le (real_of_int\n (int (intv_const (I c1)) - int (intv_const (I c2))))\n                             else if Regions.isIntv (I c1) \\<and>\n                                     Regions.isConst (I c2)\n                                  then Lt\n  (real_of_int (int (intv_const (I c1)) + 1 - int (intv_const (I c2))))\n                                  else if Regions.isConst (I c1) \\<and>\n    Regions.isIntv (I c2)\n then Lt (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n else \\<infinity>)", "case 2"], ["proof (state)\nthis:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c1 = Regions.intv.Intv d\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c2 = Regions.intv.Intv d'\n  (c2, c1) \\<notin> r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Regions.intv_elem c1 u (I c1);\n     Regions.valid_intv (k c1) (I c1); Regions.intv_elem c2 u (I c2);\n     Regions.valid_intv (k c2) (I c2); I c1 = Regions.intv.Intv d;\n     Regions.intv_elem c1 u (I c1); Regions.valid_intv (k c1) (I c1);\n     Regions.intv_elem c2 u (I c2); Regions.valid_intv (k c2) (I c2);\n     I c2 = Regions.intv.Intv d'; (c2, c1) \\<notin> r\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                       (if Regions.isIntv (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n                             then Lt (real_of_int\n (int (intv_const (I c1)) - int (intv_const (I c2)) + 1))\n                             else if (c1, c2) \\<in> r \\<and>\n                                     (c2, c1) \\<notin> r\n                                  then Lt\n  (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                                  else Le\n  (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                        else if Regions.isConst (I c1) \\<and>\n                                Regions.isConst (I c2)\n                             then Le (real_of_int\n (int (intv_const (I c1)) - int (intv_const (I c2))))\n                             else if Regions.isIntv (I c1) \\<and>\n                                     Regions.isConst (I c2)\n                                  then Lt\n  (real_of_int (int (intv_const (I c1)) + 1 - int (intv_const (I c2))))\n                                  else if Regions.isConst (I c1) \\<and>\n    Regions.isIntv (I c2)\n then Lt (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n else \\<infinity>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)", "proof (cases \"c1 = c2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c1 = c2 \\<Longrightarrow>\n    dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)\n 2. c1 \\<noteq> c2 \\<Longrightarrow>\n    dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)", "case True"], ["proof (state)\nthis:\n  c1 = c2\n\ngoal (2 subgoals):\n 1. c1 = c2 \\<Longrightarrow>\n    dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)\n 2. c1 \\<noteq> c2 \\<Longrightarrow>\n    dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  c1 = c2", "show ?thesis"], ["proof (prove)\nusing this:\n  c1 = c2\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c1) (Some c2)\n   (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n    then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n         then Lt (real_of_int\n                   (int (intv_const (I c1)) - int (intv_const (I c2)) + 1))\n         else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n    else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n         then Le (real_of_int\n                   (int (intv_const (I c1)) - int (intv_const (I c2))))\n         else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) + 1 -\n                         int (intv_const (I c2))))\n              else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else \\<infinity>)\n\ngoal (1 subgoal):\n 1. c1 \\<noteq> c2 \\<Longrightarrow>\n    dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c1 \\<noteq> c2 \\<Longrightarrow>\n    dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)", "case False"], ["proof (state)\nthis:\n  c1 \\<noteq> c2\n\ngoal (1 subgoal):\n 1. c1 \\<noteq> c2 \\<Longrightarrow>\n    dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)", "with 2 R(2) *(1,4)"], ["proof (chain)\npicking this:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c1 = Regions.intv.Intv d\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c2 = Regions.intv.Intv d'\n  (c2, c1) \\<notin> r\n  Regions.valid_region X k I r\n  c1 \\<in> X\n  c2 \\<in> X\n  c1 \\<noteq> c2", "have \"(c1, c2) \\<in> r\""], ["proof (prove)\nusing this:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c1 = Regions.intv.Intv d\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c2 = Regions.intv.Intv d'\n  (c2, c1) \\<notin> r\n  Regions.valid_region X k I r\n  c1 \\<in> X\n  c2 \\<in> X\n  c1 \\<noteq> c2\n\ngoal (1 subgoal):\n 1. (c1, c2) \\<in> r", "by (fastforce simp: total_on_def)"], ["proof (state)\nthis:\n  (c1, c2) \\<in> r\n\ngoal (1 subgoal):\n 1. c1 \\<noteq> c2 \\<Longrightarrow>\n    dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)", "with 2 *(1,4) R(1) u"], ["proof (chain)\npicking this:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c1 = Regions.intv.Intv d\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c2 = Regions.intv.Intv d'\n  (c2, c1) \\<notin> r\n  c1 \\<in> X\n  c2 \\<in> X\n  R = Regions.region X I r\n  u \\<in> R\n  (c1, c2) \\<in> r", "have \"frac (u c1) < frac (u c2)\""], ["proof (prove)\nusing this:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c1 = Regions.intv.Intv d\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c2 = Regions.intv.Intv d'\n  (c2, c1) \\<notin> r\n  c1 \\<in> X\n  c2 \\<in> X\n  R = Regions.region X I r\n  u \\<in> R\n  (c1, c2) \\<in> r\n\ngoal (1 subgoal):\n 1. frac (u c1) < frac (u c2)", "by auto"], ["proof (state)\nthis:\n  frac (u c1) < frac (u c2)\n\ngoal (1 subgoal):\n 1. c1 \\<noteq> c2 \\<Longrightarrow>\n    dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)", "with 2"], ["proof (chain)\npicking this:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c1 = Regions.intv.Intv d\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c2 = Regions.intv.Intv d'\n  (c2, c1) \\<notin> r\n  frac (u c1) < frac (u c2)", "have \"u c1 - u c2 < real d - d'\""], ["proof (prove)\nusing this:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c1 = Regions.intv.Intv d\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c2 = Regions.intv.Intv d'\n  (c2, c1) \\<notin> r\n  frac (u c1) < frac (u c2)\n\ngoal (1 subgoal):\n 1. u c1 - u c2 < real d - real d'", "by (fastforce dest: nat_intv_frac_decomp)"], ["proof (state)\nthis:\n  u c1 - u c2 < real d - real d'\n\ngoal (1 subgoal):\n 1. c1 \\<noteq> c2 \\<Longrightarrow>\n    dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)", "with 2"], ["proof (chain)\npicking this:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c1 = Regions.intv.Intv d\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c2 = Regions.intv.Intv d'\n  (c2, c1) \\<notin> r\n  u c1 - u c2 < real d - real d'", "show ?thesis"], ["proof (prove)\nusing this:\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c1 = Regions.intv.Intv d\n  Regions.intv_elem c1 u (I c1)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.intv_elem c2 u (I c2)\n  Regions.valid_intv (k c2) (I c2)\n  I c2 = Regions.intv.Intv d'\n  (c2, c1) \\<notin> r\n  u c1 - u c2 < real d - real d'\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) (Some c2)\n     (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n      then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n           then Lt (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                      1))\n           else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n                else Le (real_of_int\n                          (int (intv_const (I c1)) -\n                           int (intv_const (I c2))))\n      else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n           then Le (real_of_int\n                     (int (intv_const (I c1)) - int (intv_const (I c2))))\n           else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                then Lt (real_of_int\n                          (int (intv_const (I c1)) + 1 -\n                           int (intv_const (I c2))))\n                else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                     then Lt (real_of_int\n                               (int (intv_const (I c1)) -\n                                int (intv_const (I c2))))\n                     else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c1) (Some c2)\n   (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n    then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n         then Lt (real_of_int\n                   (int (intv_const (I c1)) - int (intv_const (I c2)) + 1))\n         else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n    else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n         then Le (real_of_int\n                   (int (intv_const (I c1)) - int (intv_const (I c2))))\n         else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) + 1 -\n                         int (intv_const (I c2))))\n              else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c1) (Some c2)\n   (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n    then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n         then Lt (real_of_int\n                   (int (intv_const (I c1)) - int (intv_const (I c2)) + 1))\n         else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n    else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n         then Le (real_of_int\n                   (int (intv_const (I c1)) - int (intv_const (I c2))))\n         else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) + 1 -\n                         int (intv_const (I c2))))\n              else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c1) (Some c2)\n   (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n    then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n         then Lt (real_of_int\n                   (int (intv_const (I c1)) - int (intv_const (I c2)) + 1))\n         else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n    else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n         then Le (real_of_int\n                   (int (intv_const (I c1)) - int (intv_const (I c2))))\n         else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) + 1 -\n                         int (intv_const (I c2))))\n              else if Regions.isConst (I c1) \\<and> Regions.isIntv (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else \\<infinity>)\n\ngoal (2 subgoals):\n 1. \\<And>x2 x3.\n       \\<lbrakk>Regions.intv_elem c1 u (I c1);\n        Regions.valid_intv (k c1) (I c1); Regions.intv_elem c2 u (I c2);\n        Regions.valid_intv (k c2) (I c2); I c1 = Regions.intv.Intv x2;\n        Regions.intv_elem c1 u (I c1); Regions.valid_intv (k c1) (I c1);\n        Regions.intv_elem c2 u (I c2); Regions.valid_intv (k c2) (I c2);\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if Regions.isIntv (I c1) \\<and>\n                              Regions.isIntv (I c2)\n                           then if (c2, c1) \\<in> r \\<and>\n                                   (c1, c2) \\<notin> r\n                                then Lt\n(real_of_int (int (intv_const (I c1)) - int (intv_const (I c2)) + 1))\n                                else if (c1, c2) \\<in> r \\<and>\n  (c2, c1) \\<notin> r\n                                     then Lt\n     (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                                     else Le\n     (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                           else if Regions.isConst (I c1) \\<and>\n                                   Regions.isConst (I c2)\n                                then Le\n(real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                                else if Regions.isIntv (I c1) \\<and>\n  Regions.isConst (I c2)\n                                     then Lt\n     (real_of_int (int (intv_const (I c1)) + 1 - int (intv_const (I c2))))\n                                     else if Regions.isConst (I c1) \\<and>\n       Regions.isIntv (I c2)\n    then Lt (real_of_int\n              (int (intv_const (I c1)) - int (intv_const (I c2))))\n    else \\<infinity>)\n 2. \\<And>x3.\n       \\<lbrakk>Regions.intv_elem c1 u (I c1);\n        Regions.valid_intv (k c1) (I c1); Regions.intv_elem c2 u (I c2);\n        Regions.valid_intv (k c2) (I c2);\n        I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if Regions.isIntv (I c1) \\<and>\n                              Regions.isIntv (I c2)\n                           then if (c2, c1) \\<in> r \\<and>\n                                   (c1, c2) \\<notin> r\n                                then Lt\n(real_of_int (int (intv_const (I c1)) - int (intv_const (I c2)) + 1))\n                                else if (c1, c2) \\<in> r \\<and>\n  (c2, c1) \\<notin> r\n                                     then Lt\n     (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                                     else Le\n     (real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                           else if Regions.isConst (I c1) \\<and>\n                                   Regions.isConst (I c2)\n                                then Le\n(real_of_int (int (intv_const (I c1)) - int (intv_const (I c2))))\n                                else if Regions.isIntv (I c1) \\<and>\n  Regions.isConst (I c2)\n                                     then Lt\n     (real_of_int (int (intv_const (I c1)) + 1 - int (intv_const (I c2))))\n                                     else if Regions.isConst (I c1) \\<and>\n       Regions.isIntv (I c2)\n    then Lt (real_of_int\n              (int (intv_const (I c1)) - int (intv_const (I c2))))\n    else \\<infinity>)", "qed fastforce+"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c1) (Some c2) (h c1 c2)\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (if v c1 = 0\n                           then if v c2 = 0 then Le 0 else g (v' (v c2))\n                           else if v c2 = 0 then f (v' (v c1))\n                                else if v c1 = v c2 then Le 0\n                                     else h (v' (v c1)) (v' (v c2)))", "then"], ["proof (chain)\npicking this:\n  dbm_entry_val u (Some c1) (Some c2) (h c1 c2)", "show ?case"], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some c1) (Some c2) (h c1 c2)\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) (Some c2)\n     (if v c1 = 0 then if v c2 = 0 then Le 0 else g (v' (v c2))\n      else if v c2 = 0 then f (v' (v c1))\n           else if v c1 = v c2 then Le 0 else h (v' (v c1)) (v' (v c2)))", "proof (cases \"v c1 = v c2\", goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>dbm_entry_val u (Some c1) (Some c2) (h c1 c2);\n     v c1 = v c2\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                       (if v c1 = 0\n                        then if v c2 = 0 then Le 0 else g (v' (v c2))\n                        else if v c2 = 0 then f (v' (v c1))\n                             else if v c1 = v c2 then Le 0\n                                  else h (v' (v c1)) (v' (v c2)))\n 2. \\<lbrakk>dbm_entry_val u (Some c1) (Some c2) (h c1 c2);\n     v c1 \\<noteq> v c2\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                       (if v c1 = 0\n                        then if v c2 = 0 then Le 0 else g (v' (v c2))\n                        else if v c2 = 0 then f (v' (v c1))\n                             else if v c1 = v c2 then Le 0\n                                  else h (v' (v c1)) (v' (v c2)))", "case True"], ["proof (state)\nthis:\n  v c1 = v c2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>dbm_entry_val u (Some c1) (Some c2) (h c1 c2);\n     v c1 = v c2\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                       (if v c1 = 0\n                        then if v c2 = 0 then Le 0 else g (v' (v c2))\n                        else if v c2 = 0 then f (v' (v c1))\n                             else if v c1 = v c2 then Le 0\n                                  else h (v' (v c1)) (v' (v c2)))\n 2. \\<lbrakk>dbm_entry_val u (Some c1) (Some c2) (h c1 c2);\n     v c1 \\<noteq> v c2\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                       (if v c1 = 0\n                        then if v c2 = 0 then Le 0 else g (v' (v c2))\n                        else if v c2 = 0 then f (v' (v c1))\n                             else if v c1 = v c2 then Le 0\n                                  else h (v' (v c1)) (v' (v c2)))", "with * clock_numbering"], ["proof (chain)\npicking this:\n  c1 \\<in> X\n  0 < v c1\n  v' (v c1) = c1\n  c2 \\<in> X\n  0 < v c2\n  v' (v c2) = c2\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  v c1 = v c2", "have \"c1 = c2\""], ["proof (prove)\nusing this:\n  c1 \\<in> X\n  0 < v c1\n  v' (v c1) = c1\n  c2 \\<in> X\n  0 < v c2\n  v' (v c2) = c2\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  v c1 = v c2\n\ngoal (1 subgoal):\n 1. c1 = c2", "by auto"], ["proof (state)\nthis:\n  c1 = c2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>dbm_entry_val u (Some c1) (Some c2) (h c1 c2);\n     v c1 = v c2\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                       (if v c1 = 0\n                        then if v c2 = 0 then Le 0 else g (v' (v c2))\n                        else if v c2 = 0 then f (v' (v c1))\n                             else if v c1 = v c2 then Le 0\n                                  else h (v' (v c1)) (v' (v c2)))\n 2. \\<lbrakk>dbm_entry_val u (Some c1) (Some c2) (h c1 c2);\n     v c1 \\<noteq> v c2\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                       (if v c1 = 0\n                        then if v c2 = 0 then Le 0 else g (v' (v c2))\n                        else if v c2 = 0 then f (v' (v c1))\n                             else if v c1 = v c2 then Le 0\n                                  else h (v' (v c1)) (v' (v c2)))", "then"], ["proof (chain)\npicking this:\n  c1 = c2", "show ?thesis"], ["proof (prove)\nusing this:\n  c1 = c2\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) (Some c2)\n     (if v c1 = 0 then if v c2 = 0 then Le 0 else g (v' (v c2))\n      else if v c2 = 0 then f (v' (v c1))\n           else if v c1 = v c2 then Le 0 else h (v' (v c1)) (v' (v c2)))", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c1) (Some c2)\n   (if v c1 = 0 then if v c2 = 0 then Le 0 else g (v' (v c2))\n    else if v c2 = 0 then f (v' (v c1))\n         else if v c1 = v c2 then Le 0 else h (v' (v c1)) (v' (v c2)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>dbm_entry_val u (Some c1) (Some c2) (h c1 c2);\n     v c1 \\<noteq> v c2\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                       (if v c1 = 0\n                        then if v c2 = 0 then Le 0 else g (v' (v c2))\n                        else if v c2 = 0 then f (v' (v c1))\n                             else if v c1 = v c2 then Le 0\n                                  else h (v' (v c1)) (v' (v c2)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>dbm_entry_val u (Some c1) (Some c2) (h c1 c2);\n     v c1 \\<noteq> v c2\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                       (if v c1 = 0\n                        then if v c2 = 0 then Le 0 else g (v' (v c2))\n                        else if v c2 = 0 then f (v' (v c1))\n                             else if v c1 = v c2 then Le 0\n                                  else h (v' (v c1)) (v' (v c2)))", "case 2"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c1) (Some c2) (h c1 c2)\n  v c1 \\<noteq> v c2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>dbm_entry_val u (Some c1) (Some c2) (h c1 c2);\n     v c1 \\<noteq> v c2\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                       (if v c1 = 0\n                        then if v c2 = 0 then Le 0 else g (v' (v c2))\n                        else if v c2 = 0 then f (v' (v c1))\n                             else if v c1 = v c2 then Le 0\n                                  else h (v' (v c1)) (v' (v c2)))", "with *"], ["proof (chain)\npicking this:\n  c1 \\<in> X\n  0 < v c1\n  v' (v c1) = c1\n  c2 \\<in> X\n  0 < v c2\n  v' (v c2) = c2\n  dbm_entry_val u (Some c1) (Some c2) (h c1 c2)\n  v c1 \\<noteq> v c2", "show ?case"], ["proof (prove)\nusing this:\n  c1 \\<in> X\n  0 < v c1\n  v' (v c1) = c1\n  c2 \\<in> X\n  0 < v c2\n  v' (v c2) = c2\n  dbm_entry_val u (Some c1) (Some c2) (h c1 c2)\n  v c1 \\<noteq> v c2\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) (Some c2)\n     (if v c1 = 0 then if v c2 = 0 then Le 0 else g (v' (v c2))\n      else if v c2 = 0 then f (v' (v c1))\n           else if v c1 = v c2 then Le 0 else h (v' (v c1)) (v' (v c2)))", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c1) (Some c2)\n   (if v c1 = 0 then if v c2 = 0 then Le 0 else g (v' (v c2))\n    else if v c2 = 0 then f (v' (v c1))\n         else if v c1 = v c2 then Le 0 else h (v' (v c1)) (v' (v c2)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c1) (Some c2)\n   (if v c1 = 0 then if v c2 = 0 then Le 0 else g (v' (v c2))\n    else if v c2 = 0 then f (v' (v c1))\n         else if v c1 = v c2 then Le 0 else h (v' (v c1)) (v' (v c2)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<in> [(\\<lambda>i j.\n               if i = 0 then if j = 0 then Le 0 else g (v' j)\n               else if j = 0 then f (v' i)\n                    else if i = j then Le 0\n                         else h (v' i) (v' j))]\\<^bsub>v,n\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<subseteq> [(\\<lambda>i j.\n                     if i = 0 then if j = 0 then Le 0 else g (v' j)\n                     else if j = 0 then f (v' i)\n                          else if i = j then Le 0\n                               else h (v' i) (v' j))]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  [(\\<lambda>i j.\n       if i = 0 then if j = 0 then Le 0 else g (v' j)\n       else if j = 0 then f (v' i)\n            else if i = j then Le 0\n                 else h (v' i) (v' j))]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> R\n  R \\<subseteq> [(\\<lambda>i j.\n                     if i = 0 then if j = 0 then Le 0 else g (v' j)\n                     else if j = 0 then f (v' i)\n                          else if i = j then Le 0\n                               else h (v' i) (v' j))]\\<^bsub>v,n\\<^esub>", "have \"[?M]\\<^bsub>v,n\\<^esub> = R\""], ["proof (prove)\nusing this:\n  [(\\<lambda>i j.\n       if i = 0 then if j = 0 then Le 0 else g (v' j)\n       else if j = 0 then f (v' i)\n            else if i = j then Le 0\n                 else h (v' i) (v' j))]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> R\n  R \\<subseteq> [(\\<lambda>i j.\n                     if i = 0 then if j = 0 then Le 0 else g (v' j)\n                     else if j = 0 then f (v' i)\n                          else if i = j then Le 0\n                               else h (v' i) (v' j))]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. [(\\<lambda>i j.\n         if i = 0 then if j = 0 then Le 0 else g (v' j)\n         else if j = 0 then f (v' i)\n              else if i = j then Le 0\n                   else h (v' i) (v' j))]\\<^bsub>v,n\\<^esub> =\n    R", "by blast"], ["proof (state)\nthis:\n  [(\\<lambda>i j.\n       if i = 0 then if j = 0 then Le 0 else g (v' j)\n       else if j = 0 then f (v' i)\n            else if i = j then Le 0\n                 else h (v' i) (v' j))]\\<^bsub>v,n\\<^esub> =\n  R\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  [(\\<lambda>i j.\n       if i = 0 then if j = 0 then Le 0 else g (v' j)\n       else if j = 0 then f (v' i)\n            else if i = j then Le 0\n                 else h (v' i) (v' j))]\\<^bsub>v,n\\<^esub> =\n  R\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<forall> i \\<le> n. \\<forall> j \\<le> n. ?M i 0 = \\<infinity> \\<and> j > 0 \\<and> i \\<noteq> j \\<longrightarrow> ?M i j = \\<infinity> \\<and> ?M j i = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>n.\n       \\<forall>j\\<le>n.\n          (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n           else if 0 = 0 then f (v' i)\n                else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n          \\<infinity> \\<and>\n          0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n          (if i = 0 then if j = 0 then Le 0 else g (v' j)\n           else if j = 0 then f (v' i)\n                else if i = j then Le 0 else h (v' i) (v' j)) =\n          \\<infinity> \\<and>\n          (if j = 0 then if i = 0 then Le 0 else g (v' i)\n           else if i = 0 then f (v' j)\n                else if j = i then Le 0 else h (v' j) (v' i)) =\n          \\<infinity>", "unfolding f_def h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>n.\n       \\<forall>j\\<le>n.\n          (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n           else if 0 = 0\n                then if Regions.isIntv (I (v' i))\n                     then Lt (real (intv_const (I (v' i)) + 1))\n                     else if Regions.isConst (I (v' i))\n                          then Le (real (intv_const (I (v' i))))\n                          else \\<infinity>\n                else if i = 0 then Le 0\n                     else if Regions.isIntv (I (v' i)) \\<and>\n                             Regions.isIntv (I (v' 0))\n                          then if (v' 0, v' i) \\<in> r \\<and>\n                                  (v' i, v' 0) \\<notin> r\n                               then Lt (real_of_int\n   (int (intv_const (I (v' i))) - int (intv_const (I (v' 0))) + 1))\n                               else if (v' i, v' 0) \\<in> r \\<and>\n (v' 0, v' i) \\<notin> r\n                                    then Lt\n    (real_of_int\n      (int (intv_const (I (v' i))) - int (intv_const (I (v' 0)))))\n                                    else Le\n    (real_of_int\n      (int (intv_const (I (v' i))) - int (intv_const (I (v' 0)))))\n                          else if Regions.isConst (I (v' i)) \\<and>\n                                  Regions.isConst (I (v' 0))\n                               then Le (real_of_int\n   (int (intv_const (I (v' i))) - int (intv_const (I (v' 0)))))\n                               else if Regions.isIntv (I (v' i)) \\<and>\n Regions.isConst (I (v' 0))\n                                    then Lt\n    (real_of_int\n      (int (intv_const (I (v' i))) + 1 - int (intv_const (I (v' 0)))))\n                                    else if Regions.isConst\n       (I (v' i)) \\<and>\n      Regions.isIntv (I (v' 0))\n   then Lt (real_of_int\n             (int (intv_const (I (v' i))) - int (intv_const (I (v' 0)))))\n   else \\<infinity>) =\n          \\<infinity> \\<and>\n          0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n          (if i = 0 then if j = 0 then Le 0 else g (v' j)\n           else if j = 0\n                then if Regions.isIntv (I (v' i))\n                     then Lt (real (intv_const (I (v' i)) + 1))\n                     else if Regions.isConst (I (v' i))\n                          then Le (real (intv_const (I (v' i))))\n                          else \\<infinity>\n                else if i = j then Le 0\n                     else if Regions.isIntv (I (v' i)) \\<and>\n                             Regions.isIntv (I (v' j))\n                          then if (v' j, v' i) \\<in> r \\<and>\n                                  (v' i, v' j) \\<notin> r\n                               then Lt (real_of_int\n   (int (intv_const (I (v' i))) - int (intv_const (I (v' j))) + 1))\n                               else if (v' i, v' j) \\<in> r \\<and>\n (v' j, v' i) \\<notin> r\n                                    then Lt\n    (real_of_int\n      (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                                    else Le\n    (real_of_int\n      (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                          else if Regions.isConst (I (v' i)) \\<and>\n                                  Regions.isConst (I (v' j))\n                               then Le (real_of_int\n   (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                               else if Regions.isIntv (I (v' i)) \\<and>\n Regions.isConst (I (v' j))\n                                    then Lt\n    (real_of_int\n      (int (intv_const (I (v' i))) + 1 - int (intv_const (I (v' j)))))\n                                    else if Regions.isConst\n       (I (v' i)) \\<and>\n      Regions.isIntv (I (v' j))\n   then Lt (real_of_int\n             (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n   else \\<infinity>) =\n          \\<infinity> \\<and>\n          (if j = 0 then if i = 0 then Le 0 else g (v' i)\n           else if i = 0\n                then if Regions.isIntv (I (v' j))\n                     then Lt (real (intv_const (I (v' j)) + 1))\n                     else if Regions.isConst (I (v' j))\n                          then Le (real (intv_const (I (v' j))))\n                          else \\<infinity>\n                else if j = i then Le 0\n                     else if Regions.isIntv (I (v' j)) \\<and>\n                             Regions.isIntv (I (v' i))\n                          then if (v' i, v' j) \\<in> r \\<and>\n                                  (v' j, v' i) \\<notin> r\n                               then Lt (real_of_int\n   (int (intv_const (I (v' j))) - int (intv_const (I (v' i))) + 1))\n                               else if (v' j, v' i) \\<in> r \\<and>\n (v' i, v' j) \\<notin> r\n                                    then Lt\n    (real_of_int\n      (int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\n                                    else Le\n    (real_of_int\n      (int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\n                          else if Regions.isConst (I (v' j)) \\<and>\n                                  Regions.isConst (I (v' i))\n                               then Le (real_of_int\n   (int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\n                               else if Regions.isIntv (I (v' j)) \\<and>\n Regions.isConst (I (v' i))\n                                    then Lt\n    (real_of_int\n      (int (intv_const (I (v' j))) + 1 - int (intv_const (I (v' i)))))\n                                    else if Regions.isConst\n       (I (v' j)) \\<and>\n      Regions.isIntv (I (v' i))\n   then Lt (real_of_int\n             (int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\n   else \\<infinity>) =\n          \\<infinity>", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        \\<infinity> \\<and>\n        0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n        (if i = 0 then if j = 0 then Le 0 else g (v' j)\n         else if j = 0 then f (v' i)\n              else if i = j then Le 0 else h (v' i) (v' j)) =\n        \\<infinity> \\<and>\n        (if j = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' j)\n              else if j = i then Le 0 else h (v' j) (v' i)) =\n        \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        \\<infinity> \\<and>\n        0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n        (if i = 0 then if j = 0 then Le 0 else g (v' j)\n         else if j = 0 then f (v' i)\n              else if i = j then Le 0 else h (v' i) (v' j)) =\n        \\<infinity> \\<and>\n        (if j = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' j)\n              else if j = i then Le 0 else h (v' j) (v' i)) =\n        \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<forall> i \\<le> n. ?M i i = Le 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>n.\n       (if i = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' i)\n             else if i = i then Le 0 else h (v' i) (v' i)) =\n       Le 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n.\n     (if i = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' i)\n           else if i = i then Le 0 else h (v' i) (v' i)) =\n     Le 0\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n.\n     (if i = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' i)\n           else if i = i then Le 0 else h (v' i) (v' i)) =\n     Le 0\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n.\n     (if i = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' i)\n           else if i = i then Le 0 else h (v' i) (v' i)) =\n     Le 0\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume A: \"i \\<le> n\" \"j \\<le> n\" \"i > 0\" \"j > 0\" \"?M i 0 \\<noteq> \\<infinity>\" \"?M j 0 \\<noteq> \\<infinity>\""], ["proof (state)\nthis:\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' i)\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  (if j = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' j)\n        else if j = 0 then Le 0 else h (v' j) (v' 0)) \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with clock_numbering(2)"], ["proof (chain)\npicking this:\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' i)\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  (if j = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' j)\n        else if j = 0 then Le 0 else h (v' j) (v' 0)) \\<noteq>\n  \\<infinity>", "obtain c1 c2 where B: \"v c1 = i\" \"v c2 = j\" \"c1 \\<in> X\" \"c2 \\<in> X\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' i)\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  (if j = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' j)\n        else if j = 0 then Le 0 else h (v' j) (v' 0)) \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        \\<lbrakk>v c1 = i; v c2 = j; c1 \\<in> X; c2 \\<in> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by meson"], ["proof (state)\nthis:\n  v c1 = i\n  v c2 = j\n  c1 \\<in> X\n  c2 \\<in> X\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with clock_numbering(1) A"], ["proof (chain)\npicking this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' i)\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  (if j = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' j)\n        else if j = 0 then Le 0 else h (v' j) (v' 0)) \\<noteq>\n  \\<infinity>\n  v c1 = i\n  v c2 = j\n  c1 \\<in> X\n  c2 \\<in> X", "have C: \"v' i = c1\" \"v' j = c2\""], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' i)\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  (if j = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' j)\n        else if j = 0 then Le 0 else h (v' j) (v' 0)) \\<noteq>\n  \\<infinity>\n  v c1 = i\n  v c2 = j\n  c1 \\<in> X\n  c2 \\<in> X\n\ngoal (1 subgoal):\n 1. v' i = c1 &&& v' j = c2", "unfolding v'_def"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  (if i = 0 then if 0 = 0 then Le 0 else g (THE c. c \\<in> X \\<and> v c = 0)\n   else if 0 = 0 then f (THE c. c \\<in> X \\<and> v c = i)\n        else if i = 0 then Le 0\n             else h (THE c. c \\<in> X \\<and> v c = i)\n                   (THE c. c \\<in> X \\<and> v c = 0)) \\<noteq>\n  \\<infinity>\n  (if j = 0 then if 0 = 0 then Le 0 else g (THE c. c \\<in> X \\<and> v c = 0)\n   else if 0 = 0 then f (THE c. c \\<in> X \\<and> v c = j)\n        else if j = 0 then Le 0\n             else h (THE c. c \\<in> X \\<and> v c = j)\n                   (THE c. c \\<in> X \\<and> v c = 0)) \\<noteq>\n  \\<infinity>\n  v c1 = i\n  v c2 = j\n  c1 \\<in> X\n  c2 \\<in> X\n\ngoal (1 subgoal):\n 1. (THE c. c \\<in> X \\<and> v c = i) = c1 &&&\n    (THE c. c \\<in> X \\<and> v c = j) = c2", "by force+"], ["proof (state)\nthis:\n  v' i = c1\n  v' j = c2\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from R(2) B"], ["proof (chain)\npicking this:\n  Regions.valid_region X k I r\n  v c1 = i\n  v c2 = j\n  c1 \\<in> X\n  c2 \\<in> X", "have valid: \"valid_intv (k c1) (I c1)\" \"valid_intv (k c2) (I c2)\""], ["proof (prove)\nusing this:\n  Regions.valid_region X k I r\n  v c1 = i\n  v c2 = j\n  c1 \\<in> X\n  c2 \\<in> X\n\ngoal (1 subgoal):\n 1. Regions.valid_intv (k c1) (I c1) &&& Regions.valid_intv (k c2) (I c2)", "by auto"], ["proof (state)\nthis:\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists> d :: int. (- k (v' j) \\<le> d \\<and> d \\<le> k (v' i) \\<and> ?M i j = Le d \\<and> ?M j i = Le (-d)\n      \\<or> (- k (v' j) \\<le> d - 1 \\<and> d \\<le> k (v' i) \\<and> ?M i j = Lt d \\<and> ?M j i = Lt (-d + 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d.\n       - int (k (v' j)) \\<le> d \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Le (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Le (real_of_int (- d)) \\<or>\n       - int (k (v' j)) \\<le> d - 1 \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Lt (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Lt (real_of_int (- d + 1))", "proof (cases \"i = j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow>\n    \\<exists>d.\n       - int (k (v' j)) \\<le> d \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Le (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Le (real_of_int (- d)) \\<or>\n       - int (k (v' j)) \\<le> d - 1 \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Lt (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Lt (real_of_int (- d + 1))\n 2. i \\<noteq> j \\<Longrightarrow>\n    \\<exists>d.\n       - int (k (v' j)) \\<le> d \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Le (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Le (real_of_int (- d)) \\<or>\n       - int (k (v' j)) \\<le> d - 1 \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Lt (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Lt (real_of_int (- d + 1))", "case True"], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow>\n    \\<exists>d.\n       - int (k (v' j)) \\<le> d \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Le (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Le (real_of_int (- d)) \\<or>\n       - int (k (v' j)) \\<le> d - 1 \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Lt (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Lt (real_of_int (- d + 1))\n 2. i \\<noteq> j \\<Longrightarrow>\n    \\<exists>d.\n       - int (k (v' j)) \\<le> d \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Le (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Le (real_of_int (- d)) \\<or>\n       - int (k (v' j)) \\<le> d - 1 \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Lt (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Lt (real_of_int (- d + 1))", "then"], ["proof (chain)\npicking this:\n  i = j", "show ?thesis"], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       - int (k (v' j)) \\<le> d \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Le (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Le (real_of_int (- d)) \\<or>\n       - int (k (v' j)) \\<le> d - 1 \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Lt (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Lt (real_of_int (- d + 1))", "by auto"], ["proof (state)\nthis:\n  \\<exists>d.\n     - int (k (v' j)) \\<le> d \\<and>\n     d \\<le> int (k (v' i)) \\<and>\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) =\n     Le (real_of_int d) \\<and>\n     (if j = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' j)\n           else if j = i then Le 0 else h (v' j) (v' i)) =\n     Le (real_of_int (- d)) \\<or>\n     - int (k (v' j)) \\<le> d - 1 \\<and>\n     d \\<le> int (k (v' i)) \\<and>\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) =\n     Lt (real_of_int d) \\<and>\n     (if j = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' j)\n           else if j = i then Le 0 else h (v' j) (v' i)) =\n     Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    \\<exists>d.\n       - int (k (v' j)) \\<le> d \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Le (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Le (real_of_int (- d)) \\<or>\n       - int (k (v' j)) \\<le> d - 1 \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Lt (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Lt (real_of_int (- d + 1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    \\<exists>d.\n       - int (k (v' j)) \\<le> d \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Le (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Le (real_of_int (- d)) \\<or>\n       - int (k (v' j)) \\<le> d - 1 \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Lt (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Lt (real_of_int (- d + 1))", "case False"], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    \\<exists>d.\n       - int (k (v' j)) \\<le> d \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Le (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Le (real_of_int (- d)) \\<or>\n       - int (k (v' j)) \\<le> d - 1 \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Lt (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Lt (real_of_int (- d + 1))", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> j", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       - int (k (v' j)) \\<le> d \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Le (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Le (real_of_int (- d)) \\<or>\n       - int (k (v' j)) \\<le> d - 1 \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Lt (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Lt (real_of_int (- d + 1))", "proof (cases \"I c1\", goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 2. \\<And>x2.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 3. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "case 1"], ["proof (state)\nthis:\n  i \\<noteq> j\n  I c1 = Regions.intv.Const x1_\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 2. \\<And>x2.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 3. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> j\n  I c1 = Regions.intv.Const x1_", "show ?case"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  I c1 = Regions.intv.Const x1_\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       - int (k (v' j)) \\<le> d \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Le (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Le (real_of_int (- d)) \\<or>\n       - int (k (v' j)) \\<le> d - 1 \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Lt (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Lt (real_of_int (- d + 1))", "proof (cases \"I c2\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1a.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Const x1a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 2. \\<And>x2.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 3. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "case Const"], ["proof (state)\nthis:\n  I c2 = Regions.intv.Const x1_\n\ngoal (3 subgoals):\n 1. \\<And>x1a.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1___;\n        I c2 = Regions.intv.Const x1a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 2. \\<And>x2.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1___;\n        I c2 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 3. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1___;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "let ?d = \"int (intv_const (I c1)) - int (intv_const (I c2))\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1a.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1___;\n        I c2 = Regions.intv.Const x1a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 2. \\<And>x2.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1___;\n        I c2 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 3. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1___;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "from Const 1"], ["proof (chain)\npicking this:\n  I c2 = Regions.intv.Const x1_\n  i \\<noteq> j\n  I c1 = Regions.intv.Const x1___", "have \"isConst (I c1)\" \"isConst (I c2)\""], ["proof (prove)\nusing this:\n  I c2 = Regions.intv.Const x1_\n  i \\<noteq> j\n  I c1 = Regions.intv.Const x1___\n\ngoal (1 subgoal):\n 1. Regions.isConst (I c1) &&& Regions.isConst (I c2)", "by auto"], ["proof (state)\nthis:\n  Regions.isConst (I c1)\n  Regions.isConst (I c2)\n\ngoal (3 subgoals):\n 1. \\<And>x1a.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1___;\n        I c2 = Regions.intv.Const x1a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 2. \\<And>x2.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1___;\n        I c2 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 3. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1___;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "with A(1-4) C valid"], ["proof (chain)\npicking this:\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  v' i = c1\n  v' j = c2\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n  Regions.isConst (I c1)\n  Regions.isConst (I c2)", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  v' i = c1\n  v' j = c2\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n  Regions.isConst (I c1)\n  Regions.isConst (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       - int (k (v' j)) \\<le> d \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Le (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Le (real_of_int (- d)) \\<or>\n       - int (k (v' j)) \\<le> d - 1 \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Lt (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Lt (real_of_int (- d + 1))", "unfolding h_def"], ["proof (prove)\nusing this:\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  v' i = c1\n  v' j = c2\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n  Regions.isConst (I c1)\n  Regions.isConst (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       - int (k (v' j)) \\<le> d \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0\n                  else if Regions.isIntv (I (v' i)) \\<and>\n                          Regions.isIntv (I (v' j))\n                       then if (v' j, v' i) \\<in> r \\<and>\n                               (v' i, v' j) \\<notin> r\n                            then Lt (real_of_int\n(int (intv_const (I (v' i))) - int (intv_const (I (v' j))) + 1))\n                            else if (v' i, v' j) \\<in> r \\<and>\n                                    (v' j, v' i) \\<notin> r\n                                 then Lt\n (real_of_int (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                                 else Le\n (real_of_int (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                       else if Regions.isConst (I (v' i)) \\<and>\n                               Regions.isConst (I (v' j))\n                            then Le (real_of_int\n(int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                            else if Regions.isIntv (I (v' i)) \\<and>\n                                    Regions.isConst (I (v' j))\n                                 then Lt\n (real_of_int\n   (int (intv_const (I (v' i))) + 1 - int (intv_const (I (v' j)))))\n                                 else if Regions.isConst (I (v' i)) \\<and>\n   Regions.isIntv (I (v' j))\nthen Lt (real_of_int\n          (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\nelse \\<infinity>) =\n       Le (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0\n                  else if Regions.isIntv (I (v' j)) \\<and>\n                          Regions.isIntv (I (v' i))\n                       then if (v' i, v' j) \\<in> r \\<and>\n                               (v' j, v' i) \\<notin> r\n                            then Lt (real_of_int\n(int (intv_const (I (v' j))) - int (intv_const (I (v' i))) + 1))\n                            else if (v' j, v' i) \\<in> r \\<and>\n                                    (v' i, v' j) \\<notin> r\n                                 then Lt\n (real_of_int (int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\n                                 else Le\n (real_of_int (int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\n                       else if Regions.isConst (I (v' j)) \\<and>\n                               Regions.isConst (I (v' i))\n                            then Le (real_of_int\n(int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\n                            else if Regions.isIntv (I (v' j)) \\<and>\n                                    Regions.isConst (I (v' i))\n                                 then Lt\n (real_of_int\n   (int (intv_const (I (v' j))) + 1 - int (intv_const (I (v' i)))))\n                                 else if Regions.isConst (I (v' j)) \\<and>\n   Regions.isIntv (I (v' i))\nthen Lt (real_of_int\n          (int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\nelse \\<infinity>) =\n       Le (real_of_int (- d)) \\<or>\n       - int (k (v' j)) \\<le> d - 1 \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0\n                  else if Regions.isIntv (I (v' i)) \\<and>\n                          Regions.isIntv (I (v' j))\n                       then if (v' j, v' i) \\<in> r \\<and>\n                               (v' i, v' j) \\<notin> r\n                            then Lt (real_of_int\n(int (intv_const (I (v' i))) - int (intv_const (I (v' j))) + 1))\n                            else if (v' i, v' j) \\<in> r \\<and>\n                                    (v' j, v' i) \\<notin> r\n                                 then Lt\n (real_of_int (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                                 else Le\n (real_of_int (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                       else if Regions.isConst (I (v' i)) \\<and>\n                               Regions.isConst (I (v' j))\n                            then Le (real_of_int\n(int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                            else if Regions.isIntv (I (v' i)) \\<and>\n                                    Regions.isConst (I (v' j))\n                                 then Lt\n (real_of_int\n   (int (intv_const (I (v' i))) + 1 - int (intv_const (I (v' j)))))\n                                 else if Regions.isConst (I (v' i)) \\<and>\n   Regions.isIntv (I (v' j))\nthen Lt (real_of_int\n          (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\nelse \\<infinity>) =\n       Lt (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0\n                  else if Regions.isIntv (I (v' j)) \\<and>\n                          Regions.isIntv (I (v' i))\n                       then if (v' i, v' j) \\<in> r \\<and>\n                               (v' j, v' i) \\<notin> r\n                            then Lt (real_of_int\n(int (intv_const (I (v' j))) - int (intv_const (I (v' i))) + 1))\n                            else if (v' j, v' i) \\<in> r \\<and>\n                                    (v' i, v' j) \\<notin> r\n                                 then Lt\n (real_of_int (int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\n                                 else Le\n (real_of_int (int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\n                       else if Regions.isConst (I (v' j)) \\<and>\n                               Regions.isConst (I (v' i))\n                            then Le (real_of_int\n(int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\n                            else if Regions.isIntv (I (v' j)) \\<and>\n                                    Regions.isConst (I (v' i))\n                                 then Lt\n (real_of_int\n   (int (intv_const (I (v' j))) + 1 - int (intv_const (I (v' i)))))\n                                 else if Regions.isConst (I (v' j)) \\<and>\n   Regions.isIntv (I (v' i))\nthen Lt (real_of_int\n          (int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\nelse \\<infinity>) =\n       Lt (real_of_int (- d + 1))", "by (intro exI[where x = ?d]) auto"], ["proof (state)\nthis:\n  \\<exists>d.\n     - int (k (v' j)) \\<le> d \\<and>\n     d \\<le> int (k (v' i)) \\<and>\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) =\n     Le (real_of_int d) \\<and>\n     (if j = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' j)\n           else if j = i then Le 0 else h (v' j) (v' i)) =\n     Le (real_of_int (- d)) \\<or>\n     - int (k (v' j)) \\<le> d - 1 \\<and>\n     d \\<le> int (k (v' i)) \\<and>\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) =\n     Lt (real_of_int d) \\<and>\n     (if j = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' j)\n           else if j = i then Le 0 else h (v' j) (v' i)) =\n     Lt (real_of_int (- d + 1))\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1___;\n        I c2 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 2. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1___;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 2. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "case Intv"], ["proof (state)\nthis:\n  I c2 = Regions.intv.Intv x2_\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 2. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "let ?d = \"int(intv_const (I c1)) - int (intv_const (I c2))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 2. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "from Intv 1"], ["proof (chain)\npicking this:\n  I c2 = Regions.intv.Intv x2_\n  i \\<noteq> j\n  I c1 = Regions.intv.Const x1_", "have \"isConst (I c1)\" \"isIntv (I c2)\""], ["proof (prove)\nusing this:\n  I c2 = Regions.intv.Intv x2_\n  i \\<noteq> j\n  I c1 = Regions.intv.Const x1_\n\ngoal (1 subgoal):\n 1. Regions.isConst (I c1) &&& Regions.isIntv (I c2)", "by auto"], ["proof (state)\nthis:\n  Regions.isConst (I c1)\n  Regions.isIntv (I c2)\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 2. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "with A(1-4) C valid"], ["proof (chain)\npicking this:\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  v' i = c1\n  v' j = c2\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n  Regions.isConst (I c1)\n  Regions.isIntv (I c2)", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  v' i = c1\n  v' j = c2\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n  Regions.isConst (I c1)\n  Regions.isIntv (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       - int (k (v' j)) \\<le> d \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Le (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Le (real_of_int (- d)) \\<or>\n       - int (k (v' j)) \\<le> d - 1 \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Lt (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Lt (real_of_int (- d + 1))", "unfolding h_def"], ["proof (prove)\nusing this:\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  v' i = c1\n  v' j = c2\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n  Regions.isConst (I c1)\n  Regions.isIntv (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       - int (k (v' j)) \\<le> d \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0\n                  else if Regions.isIntv (I (v' i)) \\<and>\n                          Regions.isIntv (I (v' j))\n                       then if (v' j, v' i) \\<in> r \\<and>\n                               (v' i, v' j) \\<notin> r\n                            then Lt (real_of_int\n(int (intv_const (I (v' i))) - int (intv_const (I (v' j))) + 1))\n                            else if (v' i, v' j) \\<in> r \\<and>\n                                    (v' j, v' i) \\<notin> r\n                                 then Lt\n (real_of_int (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                                 else Le\n (real_of_int (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                       else if Regions.isConst (I (v' i)) \\<and>\n                               Regions.isConst (I (v' j))\n                            then Le (real_of_int\n(int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                            else if Regions.isIntv (I (v' i)) \\<and>\n                                    Regions.isConst (I (v' j))\n                                 then Lt\n (real_of_int\n   (int (intv_const (I (v' i))) + 1 - int (intv_const (I (v' j)))))\n                                 else if Regions.isConst (I (v' i)) \\<and>\n   Regions.isIntv (I (v' j))\nthen Lt (real_of_int\n          (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\nelse \\<infinity>) =\n       Le (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0\n                  else if Regions.isIntv (I (v' j)) \\<and>\n                          Regions.isIntv (I (v' i))\n                       then if (v' i, v' j) \\<in> r \\<and>\n                               (v' j, v' i) \\<notin> r\n                            then Lt (real_of_int\n(int (intv_const (I (v' j))) - int (intv_const (I (v' i))) + 1))\n                            else if (v' j, v' i) \\<in> r \\<and>\n                                    (v' i, v' j) \\<notin> r\n                                 then Lt\n (real_of_int (int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\n                                 else Le\n (real_of_int (int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\n                       else if Regions.isConst (I (v' j)) \\<and>\n                               Regions.isConst (I (v' i))\n                            then Le (real_of_int\n(int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\n                            else if Regions.isIntv (I (v' j)) \\<and>\n                                    Regions.isConst (I (v' i))\n                                 then Lt\n (real_of_int\n   (int (intv_const (I (v' j))) + 1 - int (intv_const (I (v' i)))))\n                                 else if Regions.isConst (I (v' j)) \\<and>\n   Regions.isIntv (I (v' i))\nthen Lt (real_of_int\n          (int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\nelse \\<infinity>) =\n       Le (real_of_int (- d)) \\<or>\n       - int (k (v' j)) \\<le> d - 1 \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0\n                  else if Regions.isIntv (I (v' i)) \\<and>\n                          Regions.isIntv (I (v' j))\n                       then if (v' j, v' i) \\<in> r \\<and>\n                               (v' i, v' j) \\<notin> r\n                            then Lt (real_of_int\n(int (intv_const (I (v' i))) - int (intv_const (I (v' j))) + 1))\n                            else if (v' i, v' j) \\<in> r \\<and>\n                                    (v' j, v' i) \\<notin> r\n                                 then Lt\n (real_of_int (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                                 else Le\n (real_of_int (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                       else if Regions.isConst (I (v' i)) \\<and>\n                               Regions.isConst (I (v' j))\n                            then Le (real_of_int\n(int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                            else if Regions.isIntv (I (v' i)) \\<and>\n                                    Regions.isConst (I (v' j))\n                                 then Lt\n (real_of_int\n   (int (intv_const (I (v' i))) + 1 - int (intv_const (I (v' j)))))\n                                 else if Regions.isConst (I (v' i)) \\<and>\n   Regions.isIntv (I (v' j))\nthen Lt (real_of_int\n          (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\nelse \\<infinity>) =\n       Lt (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0\n                  else if Regions.isIntv (I (v' j)) \\<and>\n                          Regions.isIntv (I (v' i))\n                       then if (v' i, v' j) \\<in> r \\<and>\n                               (v' j, v' i) \\<notin> r\n                            then Lt (real_of_int\n(int (intv_const (I (v' j))) - int (intv_const (I (v' i))) + 1))\n                            else if (v' j, v' i) \\<in> r \\<and>\n                                    (v' i, v' j) \\<notin> r\n                                 then Lt\n (real_of_int (int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\n                                 else Le\n (real_of_int (int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\n                       else if Regions.isConst (I (v' j)) \\<and>\n                               Regions.isConst (I (v' i))\n                            then Le (real_of_int\n(int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\n                            else if Regions.isIntv (I (v' j)) \\<and>\n                                    Regions.isConst (I (v' i))\n                                 then Lt\n (real_of_int\n   (int (intv_const (I (v' j))) + 1 - int (intv_const (I (v' i)))))\n                                 else if Regions.isConst (I (v' j)) \\<and>\n   Regions.isIntv (I (v' i))\nthen Lt (real_of_int\n          (int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\nelse \\<infinity>) =\n       Lt (real_of_int (- d + 1))", "by (intro exI[where x = ?d]) auto"], ["proof (state)\nthis:\n  \\<exists>d.\n     - int (k (v' j)) \\<le> d \\<and>\n     d \\<le> int (k (v' i)) \\<and>\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) =\n     Le (real_of_int d) \\<and>\n     (if j = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' j)\n           else if j = i then Le 0 else h (v' j) (v' i)) =\n     Le (real_of_int (- d)) \\<or>\n     - int (k (v' j)) \\<le> d - 1 \\<and>\n     d \\<le> int (k (v' i)) \\<and>\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) =\n     Lt (real_of_int d) \\<and>\n     (if j = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' j)\n           else if j = i then Le 0 else h (v' j) (v' i)) =\n     Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "case Greater"], ["proof (state)\nthis:\n  I c2 = Regions.intv.Greater x3_\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "then"], ["proof (chain)\npicking this:\n  I c2 = Regions.intv.Greater x3_", "have \"\\<not> isIntv (I c2)\" \"\\<not> isConst (I c2)\""], ["proof (prove)\nusing this:\n  I c2 = Regions.intv.Greater x3_\n\ngoal (1 subgoal):\n 1. \\<not> Regions.isIntv (I c2) &&& \\<not> Regions.isConst (I c2)", "by auto"], ["proof (state)\nthis:\n  \\<not> Regions.isIntv (I c2)\n  \\<not> Regions.isConst (I c2)\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "with A 1(1) C"], ["proof (chain)\npicking this:\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' i)\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  (if j = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' j)\n        else if j = 0 then Le 0 else h (v' j) (v' 0)) \\<noteq>\n  \\<infinity>\n  i \\<noteq> j\n  v' i = c1\n  v' j = c2\n  \\<not> Regions.isIntv (I c2)\n  \\<not> Regions.isConst (I c2)", "have False"], ["proof (prove)\nusing this:\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' i)\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  (if j = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' j)\n        else if j = 0 then Le 0 else h (v' j) (v' 0)) \\<noteq>\n  \\<infinity>\n  i \\<noteq> j\n  v' i = c1\n  v' j = c2\n  \\<not> Regions.isIntv (I c2)\n  \\<not> Regions.isConst (I c2)\n\ngoal (1 subgoal):\n 1. False", "unfolding f_def"], ["proof (prove)\nusing this:\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0\n        then if Regions.isIntv (I (v' i))\n             then Lt (real (intv_const (I (v' i)) + 1))\n             else if Regions.isConst (I (v' i))\n                  then Le (real (intv_const (I (v' i)))) else \\<infinity>\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  (if j = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0\n        then if Regions.isIntv (I (v' j))\n             then Lt (real (intv_const (I (v' j)) + 1))\n             else if Regions.isConst (I (v' j))\n                  then Le (real (intv_const (I (v' j)))) else \\<infinity>\n        else if j = 0 then Le 0 else h (v' j) (v' 0)) \\<noteq>\n  \\<infinity>\n  i \\<noteq> j\n  v' i = c1\n  v' j = c2\n  \\<not> Regions.isIntv (I c2)\n  \\<not> Regions.isConst (I c2)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       - int (k (v' j)) \\<le> d \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Le (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Le (real_of_int (- d)) \\<or>\n       - int (k (v' j)) \\<le> d - 1 \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Lt (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Lt (real_of_int (- d + 1))", "by fast"], ["proof (state)\nthis:\n  \\<exists>d.\n     - int (k (v' j)) \\<le> d \\<and>\n     d \\<le> int (k (v' i)) \\<and>\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) =\n     Le (real_of_int d) \\<and>\n     (if j = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' j)\n           else if j = i then Le 0 else h (v' j) (v' i)) =\n     Le (real_of_int (- d)) \\<or>\n     - int (k (v' j)) \\<le> d - 1 \\<and>\n     d \\<le> int (k (v' i)) \\<and>\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) =\n     Lt (real_of_int d) \\<and>\n     (if j = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' j)\n           else if j = i then Le 0 else h (v' j) (v' i)) =\n     Lt (real_of_int (- d + 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d.\n     - int (k (v' j)) \\<le> d \\<and>\n     d \\<le> int (k (v' i)) \\<and>\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) =\n     Le (real_of_int d) \\<and>\n     (if j = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' j)\n           else if j = i then Le 0 else h (v' j) (v' i)) =\n     Le (real_of_int (- d)) \\<or>\n     - int (k (v' j)) \\<le> d - 1 \\<and>\n     d \\<le> int (k (v' i)) \\<and>\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) =\n     Lt (real_of_int d) \\<and>\n     (if j = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' j)\n           else if j = i then Le 0 else h (v' j) (v' i)) =\n     Lt (real_of_int (- d + 1))\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 2. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 2. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "case 2"], ["proof (state)\nthis:\n  i \\<noteq> j\n  I c1 = Regions.intv.Intv x2_\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 2. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> j\n  I c1 = Regions.intv.Intv x2_", "show ?case"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  I c1 = Regions.intv.Intv x2_\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       - int (k (v' j)) \\<le> d \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Le (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Le (real_of_int (- d)) \\<or>\n       - int (k (v' j)) \\<le> d - 1 \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Lt (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Lt (real_of_int (- d + 1))", "proof (cases \"I c2\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Const x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 2. \\<And>x2a.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Intv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 3. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "case Const"], ["proof (state)\nthis:\n  I c2 = Regions.intv.Const x1_\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Const x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 2. \\<And>x2a.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Intv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 3. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "let ?d = \"int (intv_const (I c1)) + 1 - int (intv_const (I c2))\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Const x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 2. \\<And>x2a.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Intv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 3. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "from Const 2"], ["proof (chain)\npicking this:\n  I c2 = Regions.intv.Const x1_\n  i \\<noteq> j\n  I c1 = Regions.intv.Intv x2_", "have \"isIntv (I c1)\" \"isConst (I c2)\""], ["proof (prove)\nusing this:\n  I c2 = Regions.intv.Const x1_\n  i \\<noteq> j\n  I c1 = Regions.intv.Intv x2_\n\ngoal (1 subgoal):\n 1. Regions.isIntv (I c1) &&& Regions.isConst (I c2)", "by auto"], ["proof (state)\nthis:\n  Regions.isIntv (I c1)\n  Regions.isConst (I c2)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Const x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 2. \\<And>x2a.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Intv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 3. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "with A(1-4) C valid"], ["proof (chain)\npicking this:\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  v' i = c1\n  v' j = c2\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n  Regions.isIntv (I c1)\n  Regions.isConst (I c2)", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  v' i = c1\n  v' j = c2\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n  Regions.isIntv (I c1)\n  Regions.isConst (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       - int (k (v' j)) \\<le> d \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Le (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Le (real_of_int (- d)) \\<or>\n       - int (k (v' j)) \\<le> d - 1 \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Lt (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Lt (real_of_int (- d + 1))", "unfolding h_def"], ["proof (prove)\nusing this:\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  v' i = c1\n  v' j = c2\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n  Regions.isIntv (I c1)\n  Regions.isConst (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       - int (k (v' j)) \\<le> d \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0\n                  else if Regions.isIntv (I (v' i)) \\<and>\n                          Regions.isIntv (I (v' j))\n                       then if (v' j, v' i) \\<in> r \\<and>\n                               (v' i, v' j) \\<notin> r\n                            then Lt (real_of_int\n(int (intv_const (I (v' i))) - int (intv_const (I (v' j))) + 1))\n                            else if (v' i, v' j) \\<in> r \\<and>\n                                    (v' j, v' i) \\<notin> r\n                                 then Lt\n (real_of_int (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                                 else Le\n (real_of_int (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                       else if Regions.isConst (I (v' i)) \\<and>\n                               Regions.isConst (I (v' j))\n                            then Le (real_of_int\n(int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                            else if Regions.isIntv (I (v' i)) \\<and>\n                                    Regions.isConst (I (v' j))\n                                 then Lt\n (real_of_int\n   (int (intv_const (I (v' i))) + 1 - int (intv_const (I (v' j)))))\n                                 else if Regions.isConst (I (v' i)) \\<and>\n   Regions.isIntv (I (v' j))\nthen Lt (real_of_int\n          (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\nelse \\<infinity>) =\n       Le (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0\n                  else if Regions.isIntv (I (v' j)) \\<and>\n                          Regions.isIntv (I (v' i))\n                       then if (v' i, v' j) \\<in> r \\<and>\n                               (v' j, v' i) \\<notin> r\n                            then Lt (real_of_int\n(int (intv_const (I (v' j))) - int (intv_const (I (v' i))) + 1))\n                            else if (v' j, v' i) \\<in> r \\<and>\n                                    (v' i, v' j) \\<notin> r\n                                 then Lt\n (real_of_int (int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\n                                 else Le\n (real_of_int (int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\n                       else if Regions.isConst (I (v' j)) \\<and>\n                               Regions.isConst (I (v' i))\n                            then Le (real_of_int\n(int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\n                            else if Regions.isIntv (I (v' j)) \\<and>\n                                    Regions.isConst (I (v' i))\n                                 then Lt\n (real_of_int\n   (int (intv_const (I (v' j))) + 1 - int (intv_const (I (v' i)))))\n                                 else if Regions.isConst (I (v' j)) \\<and>\n   Regions.isIntv (I (v' i))\nthen Lt (real_of_int\n          (int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\nelse \\<infinity>) =\n       Le (real_of_int (- d)) \\<or>\n       - int (k (v' j)) \\<le> d - 1 \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0\n                  else if Regions.isIntv (I (v' i)) \\<and>\n                          Regions.isIntv (I (v' j))\n                       then if (v' j, v' i) \\<in> r \\<and>\n                               (v' i, v' j) \\<notin> r\n                            then Lt (real_of_int\n(int (intv_const (I (v' i))) - int (intv_const (I (v' j))) + 1))\n                            else if (v' i, v' j) \\<in> r \\<and>\n                                    (v' j, v' i) \\<notin> r\n                                 then Lt\n (real_of_int (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                                 else Le\n (real_of_int (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                       else if Regions.isConst (I (v' i)) \\<and>\n                               Regions.isConst (I (v' j))\n                            then Le (real_of_int\n(int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                            else if Regions.isIntv (I (v' i)) \\<and>\n                                    Regions.isConst (I (v' j))\n                                 then Lt\n (real_of_int\n   (int (intv_const (I (v' i))) + 1 - int (intv_const (I (v' j)))))\n                                 else if Regions.isConst (I (v' i)) \\<and>\n   Regions.isIntv (I (v' j))\nthen Lt (real_of_int\n          (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\nelse \\<infinity>) =\n       Lt (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0\n                  else if Regions.isIntv (I (v' j)) \\<and>\n                          Regions.isIntv (I (v' i))\n                       then if (v' i, v' j) \\<in> r \\<and>\n                               (v' j, v' i) \\<notin> r\n                            then Lt (real_of_int\n(int (intv_const (I (v' j))) - int (intv_const (I (v' i))) + 1))\n                            else if (v' j, v' i) \\<in> r \\<and>\n                                    (v' i, v' j) \\<notin> r\n                                 then Lt\n (real_of_int (int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\n                                 else Le\n (real_of_int (int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\n                       else if Regions.isConst (I (v' j)) \\<and>\n                               Regions.isConst (I (v' i))\n                            then Le (real_of_int\n(int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\n                            else if Regions.isIntv (I (v' j)) \\<and>\n                                    Regions.isConst (I (v' i))\n                                 then Lt\n (real_of_int\n   (int (intv_const (I (v' j))) + 1 - int (intv_const (I (v' i)))))\n                                 else if Regions.isConst (I (v' j)) \\<and>\n   Regions.isIntv (I (v' i))\nthen Lt (real_of_int\n          (int (intv_const (I (v' j))) - int (intv_const (I (v' i)))))\nelse \\<infinity>) =\n       Lt (real_of_int (- d + 1))", "by (intro exI[where x = ?d]) auto"], ["proof (state)\nthis:\n  \\<exists>d.\n     - int (k (v' j)) \\<le> d \\<and>\n     d \\<le> int (k (v' i)) \\<and>\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) =\n     Le (real_of_int d) \\<and>\n     (if j = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' j)\n           else if j = i then Le 0 else h (v' j) (v' i)) =\n     Le (real_of_int (- d)) \\<or>\n     - int (k (v' j)) \\<le> d - 1 \\<and>\n     d \\<le> int (k (v' i)) \\<and>\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) =\n     Lt (real_of_int d) \\<and>\n     (if j = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' j)\n           else if j = i then Le 0 else h (v' j) (v' i)) =\n     Lt (real_of_int (- d + 1))\n\ngoal (2 subgoals):\n 1. \\<And>x2a.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Intv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 2. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2a.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Intv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 2. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "case Intv"], ["proof (state)\nthis:\n  I c2 = Regions.intv.Intv x2_\n\ngoal (2 subgoals):\n 1. \\<And>x2a.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2___;\n        I c2 = Regions.intv.Intv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 2. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2___;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "with 2"], ["proof (chain)\npicking this:\n  i \\<noteq> j\n  I c1 = Regions.intv.Intv x2___\n  I c2 = Regions.intv.Intv x2_", "have *: \"isIntv (I c1)\" \"isIntv (I c2)\""], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  I c1 = Regions.intv.Intv x2___\n  I c2 = Regions.intv.Intv x2_\n\ngoal (1 subgoal):\n 1. Regions.isIntv (I c1) &&& Regions.isIntv (I c2)", "by auto"], ["proof (state)\nthis:\n  Regions.isIntv (I c1)\n  Regions.isIntv (I c2)\n\ngoal (2 subgoals):\n 1. \\<And>x2a.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2___;\n        I c2 = Regions.intv.Intv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))\n 2. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2___;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "from Intv A(1-4) C"], ["proof (chain)\npicking this:\n  I c2 = Regions.intv.Intv x2_\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  v' i = c1\n  v' j = c2", "show ?thesis"], ["proof (prove)\nusing this:\n  I c2 = Regions.intv.Intv x2_\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  v' i = c1\n  v' j = c2\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       - int (k (v' j)) \\<le> d \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Le (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Le (real_of_int (- d)) \\<or>\n       - int (k (v' j)) \\<le> d - 1 \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Lt (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Lt (real_of_int (- d + 1))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>I c2 = Regions.intv.Intv x2_; i \\<le> n; j \\<le> n; 0 < i;\n     0 < j; v' i = c1; v' j = c2\\<rbrakk>\n    \\<Longrightarrow> j \\<noteq> i \\<longrightarrow>\n                      (\\<exists>d.\n                          - int (k c2) \\<le> d \\<and>\n                          d \\<le> int (k c1) \\<and>\n                          h c1 c2 = Le (real_of_int d) \\<and>\n                          h c2 c1 = Le (- real_of_int d) \\<or>\n                          - int (k c2) < d \\<and>\n                          d \\<le> int (k c1) \\<and>\n                          h c1 c2 = Lt (real_of_int d) \\<and>\n                          h c2 c1 = Lt (1 - real_of_int d))", "proof (standard, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>I c2 = Regions.intv.Intv x2_; i \\<le> n; j \\<le> n; 0 < i;\n     0 < j; v' i = c1; v' j = c2; j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         - int (k c2) \\<le> d \\<and>\n                         d \\<le> int (k c1) \\<and>\n                         h c1 c2 = Le (real_of_int d) \\<and>\n                         h c2 c1 = Le (- real_of_int d) \\<or>\n                         - int (k c2) < d \\<and>\n                         d \\<le> int (k c1) \\<and>\n                         h c1 c2 = Lt (real_of_int d) \\<and>\n                         h c2 c1 = Lt (1 - real_of_int d)", "case 1"], ["proof (state)\nthis:\n  I c2 = Regions.intv.Intv x2_\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  v' i = c1\n  v' j = c2\n  j \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>I c2 = Regions.intv.Intv x2_; i \\<le> n; j \\<le> n; 0 < i;\n     0 < j; v' i = c1; v' j = c2; j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         - int (k c2) \\<le> d \\<and>\n                         d \\<le> int (k c1) \\<and>\n                         h c1 c2 = Le (real_of_int d) \\<and>\n                         h c2 c1 = Le (- real_of_int d) \\<or>\n                         - int (k c2) < d \\<and>\n                         d \\<le> int (k c1) \\<and>\n                         h c1 c2 = Lt (real_of_int d) \\<and>\n                         h c2 c1 = Lt (1 - real_of_int d)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)", "proof (cases \"(c2, c1) \\<in> r\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (c2, c1) \\<in> r \\<Longrightarrow>\n    \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)\n 2. (c2, c1) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)", "case True"], ["proof (state)\nthis:\n  (c2, c1) \\<in> r\n\ngoal (2 subgoals):\n 1. (c2, c1) \\<in> r \\<Longrightarrow>\n    \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)\n 2. (c2, c1) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)", "note T = this"], ["proof (state)\nthis:\n  (c2, c1) \\<in> r\n\ngoal (2 subgoals):\n 1. (c2, c1) \\<in> r \\<Longrightarrow>\n    \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)\n 2. (c2, c1) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)", "proof (cases \"(c1, c2) \\<in> r\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (c1, c2) \\<in> r \\<Longrightarrow>\n    \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)\n 2. (c1, c2) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)", "case True"], ["proof (state)\nthis:\n  (c1, c2) \\<in> r\n\ngoal (2 subgoals):\n 1. (c1, c2) \\<in> r \\<Longrightarrow>\n    \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)\n 2. (c1, c2) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)", "let ?d = \"int (intv_const (I c1)) - int (intv_const (I c2))\""], ["proof (state)\ngoal (2 subgoals):\n 1. (c1, c2) \\<in> r \\<Longrightarrow>\n    \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)\n 2. (c1, c2) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)", "from True T * valid"], ["proof (chain)\npicking this:\n  (c1, c2) \\<in> r\n  (c2, c1) \\<in> r\n  Regions.isIntv (I c1)\n  Regions.isIntv (I c2)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)", "show ?thesis"], ["proof (prove)\nusing this:\n  (c1, c2) \\<in> r\n  (c2, c1) \\<in> r\n  Regions.isIntv (I c1)\n  Regions.isIntv (I c2)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)", "unfolding h_def"], ["proof (prove)\nusing this:\n  (c1, c2) \\<in> r\n  (c2, c1) \\<in> r\n  Regions.isIntv (I c1)\n  Regions.isIntv (I c2)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n        then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n             then Lt (real_of_int\n                       (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                        1))\n             else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                  then Lt (real_of_int\n                            (int (intv_const (I c1)) -\n                             int (intv_const (I c2))))\n                  else Le (real_of_int\n                            (int (intv_const (I c1)) -\n                             int (intv_const (I c2))))\n        else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n             then Le (real_of_int\n                       (int (intv_const (I c1)) - int (intv_const (I c2))))\n             else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                  then Lt (real_of_int\n                            (int (intv_const (I c1)) + 1 -\n                             int (intv_const (I c2))))\n                  else if Regions.isConst (I c1) \\<and>\n                          Regions.isIntv (I c2)\n                       then Lt (real_of_int\n                                 (int (intv_const (I c1)) -\n                                  int (intv_const (I c2))))\n                       else \\<infinity>) =\n       Le (real_of_int d) \\<and>\n       (if Regions.isIntv (I c2) \\<and> Regions.isIntv (I c1)\n        then if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n             then Lt (real_of_int\n                       (int (intv_const (I c2)) - int (intv_const (I c1)) +\n                        1))\n             else if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n                  then Lt (real_of_int\n                            (int (intv_const (I c2)) -\n                             int (intv_const (I c1))))\n                  else Le (real_of_int\n                            (int (intv_const (I c2)) -\n                             int (intv_const (I c1))))\n        else if Regions.isConst (I c2) \\<and> Regions.isConst (I c1)\n             then Le (real_of_int\n                       (int (intv_const (I c2)) - int (intv_const (I c1))))\n             else if Regions.isIntv (I c2) \\<and> Regions.isConst (I c1)\n                  then Lt (real_of_int\n                            (int (intv_const (I c2)) + 1 -\n                             int (intv_const (I c1))))\n                  else if Regions.isConst (I c2) \\<and>\n                          Regions.isIntv (I c1)\n                       then Lt (real_of_int\n                                 (int (intv_const (I c2)) -\n                                  int (intv_const (I c1))))\n                       else \\<infinity>) =\n       Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n        then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n             then Lt (real_of_int\n                       (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                        1))\n             else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                  then Lt (real_of_int\n                            (int (intv_const (I c1)) -\n                             int (intv_const (I c2))))\n                  else Le (real_of_int\n                            (int (intv_const (I c1)) -\n                             int (intv_const (I c2))))\n        else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n             then Le (real_of_int\n                       (int (intv_const (I c1)) - int (intv_const (I c2))))\n             else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                  then Lt (real_of_int\n                            (int (intv_const (I c1)) + 1 -\n                             int (intv_const (I c2))))\n                  else if Regions.isConst (I c1) \\<and>\n                          Regions.isIntv (I c2)\n                       then Lt (real_of_int\n                                 (int (intv_const (I c1)) -\n                                  int (intv_const (I c2))))\n                       else \\<infinity>) =\n       Lt (real_of_int d) \\<and>\n       (if Regions.isIntv (I c2) \\<and> Regions.isIntv (I c1)\n        then if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n             then Lt (real_of_int\n                       (int (intv_const (I c2)) - int (intv_const (I c1)) +\n                        1))\n             else if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n                  then Lt (real_of_int\n                            (int (intv_const (I c2)) -\n                             int (intv_const (I c1))))\n                  else Le (real_of_int\n                            (int (intv_const (I c2)) -\n                             int (intv_const (I c1))))\n        else if Regions.isConst (I c2) \\<and> Regions.isConst (I c1)\n             then Le (real_of_int\n                       (int (intv_const (I c2)) - int (intv_const (I c1))))\n             else if Regions.isIntv (I c2) \\<and> Regions.isConst (I c1)\n                  then Lt (real_of_int\n                            (int (intv_const (I c2)) + 1 -\n                             int (intv_const (I c1))))\n                  else if Regions.isConst (I c2) \\<and>\n                          Regions.isIntv (I c1)\n                       then Lt (real_of_int\n                                 (int (intv_const (I c2)) -\n                                  int (intv_const (I c1))))\n                       else \\<infinity>) =\n       Lt (1 - real_of_int d)", "by (intro exI[where x = ?d]) auto"], ["proof (state)\nthis:\n  \\<exists>d.\n     - int (k c2) \\<le> d \\<and>\n     d \\<le> int (k c1) \\<and>\n     h c1 c2 = Le (real_of_int d) \\<and>\n     h c2 c1 = Le (- real_of_int d) \\<or>\n     - int (k c2) < d \\<and>\n     d \\<le> int (k c1) \\<and>\n     h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)\n\ngoal (1 subgoal):\n 1. (c1, c2) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (c1, c2) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)", "case False"], ["proof (state)\nthis:\n  (c1, c2) \\<notin> r\n\ngoal (1 subgoal):\n 1. (c1, c2) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)", "let ?d = \"int (intv_const (I c1)) - int (intv_const (I c2)) + 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. (c1, c2) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)", "from False T * valid"], ["proof (chain)\npicking this:\n  (c1, c2) \\<notin> r\n  (c2, c1) \\<in> r\n  Regions.isIntv (I c1)\n  Regions.isIntv (I c2)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)", "show ?thesis"], ["proof (prove)\nusing this:\n  (c1, c2) \\<notin> r\n  (c2, c1) \\<in> r\n  Regions.isIntv (I c1)\n  Regions.isIntv (I c2)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)", "unfolding h_def"], ["proof (prove)\nusing this:\n  (c1, c2) \\<notin> r\n  (c2, c1) \\<in> r\n  Regions.isIntv (I c1)\n  Regions.isIntv (I c2)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n        then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n             then Lt (real_of_int\n                       (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                        1))\n             else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                  then Lt (real_of_int\n                            (int (intv_const (I c1)) -\n                             int (intv_const (I c2))))\n                  else Le (real_of_int\n                            (int (intv_const (I c1)) -\n                             int (intv_const (I c2))))\n        else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n             then Le (real_of_int\n                       (int (intv_const (I c1)) - int (intv_const (I c2))))\n             else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                  then Lt (real_of_int\n                            (int (intv_const (I c1)) + 1 -\n                             int (intv_const (I c2))))\n                  else if Regions.isConst (I c1) \\<and>\n                          Regions.isIntv (I c2)\n                       then Lt (real_of_int\n                                 (int (intv_const (I c1)) -\n                                  int (intv_const (I c2))))\n                       else \\<infinity>) =\n       Le (real_of_int d) \\<and>\n       (if Regions.isIntv (I c2) \\<and> Regions.isIntv (I c1)\n        then if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n             then Lt (real_of_int\n                       (int (intv_const (I c2)) - int (intv_const (I c1)) +\n                        1))\n             else if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n                  then Lt (real_of_int\n                            (int (intv_const (I c2)) -\n                             int (intv_const (I c1))))\n                  else Le (real_of_int\n                            (int (intv_const (I c2)) -\n                             int (intv_const (I c1))))\n        else if Regions.isConst (I c2) \\<and> Regions.isConst (I c1)\n             then Le (real_of_int\n                       (int (intv_const (I c2)) - int (intv_const (I c1))))\n             else if Regions.isIntv (I c2) \\<and> Regions.isConst (I c1)\n                  then Lt (real_of_int\n                            (int (intv_const (I c2)) + 1 -\n                             int (intv_const (I c1))))\n                  else if Regions.isConst (I c2) \\<and>\n                          Regions.isIntv (I c1)\n                       then Lt (real_of_int\n                                 (int (intv_const (I c2)) -\n                                  int (intv_const (I c1))))\n                       else \\<infinity>) =\n       Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n        then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n             then Lt (real_of_int\n                       (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                        1))\n             else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                  then Lt (real_of_int\n                            (int (intv_const (I c1)) -\n                             int (intv_const (I c2))))\n                  else Le (real_of_int\n                            (int (intv_const (I c1)) -\n                             int (intv_const (I c2))))\n        else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n             then Le (real_of_int\n                       (int (intv_const (I c1)) - int (intv_const (I c2))))\n             else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                  then Lt (real_of_int\n                            (int (intv_const (I c1)) + 1 -\n                             int (intv_const (I c2))))\n                  else if Regions.isConst (I c1) \\<and>\n                          Regions.isIntv (I c2)\n                       then Lt (real_of_int\n                                 (int (intv_const (I c1)) -\n                                  int (intv_const (I c2))))\n                       else \\<infinity>) =\n       Lt (real_of_int d) \\<and>\n       (if Regions.isIntv (I c2) \\<and> Regions.isIntv (I c1)\n        then if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n             then Lt (real_of_int\n                       (int (intv_const (I c2)) - int (intv_const (I c1)) +\n                        1))\n             else if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n                  then Lt (real_of_int\n                            (int (intv_const (I c2)) -\n                             int (intv_const (I c1))))\n                  else Le (real_of_int\n                            (int (intv_const (I c2)) -\n                             int (intv_const (I c1))))\n        else if Regions.isConst (I c2) \\<and> Regions.isConst (I c1)\n             then Le (real_of_int\n                       (int (intv_const (I c2)) - int (intv_const (I c1))))\n             else if Regions.isIntv (I c2) \\<and> Regions.isConst (I c1)\n                  then Lt (real_of_int\n                            (int (intv_const (I c2)) + 1 -\n                             int (intv_const (I c1))))\n                  else if Regions.isConst (I c2) \\<and>\n                          Regions.isIntv (I c1)\n                       then Lt (real_of_int\n                                 (int (intv_const (I c2)) -\n                                  int (intv_const (I c1))))\n                       else \\<infinity>) =\n       Lt (1 - real_of_int d)", "by (intro exI[where x = ?d]) auto"], ["proof (state)\nthis:\n  \\<exists>d.\n     - int (k c2) \\<le> d \\<and>\n     d \\<le> int (k c1) \\<and>\n     h c1 c2 = Le (real_of_int d) \\<and>\n     h c2 c1 = Le (- real_of_int d) \\<or>\n     - int (k c2) < d \\<and>\n     d \\<le> int (k c1) \\<and>\n     h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d.\n     - int (k c2) \\<le> d \\<and>\n     d \\<le> int (k c1) \\<and>\n     h c1 c2 = Le (real_of_int d) \\<and>\n     h c2 c1 = Le (- real_of_int d) \\<or>\n     - int (k c2) < d \\<and>\n     d \\<le> int (k c1) \\<and>\n     h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)\n\ngoal (1 subgoal):\n 1. (c2, c1) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (c2, c1) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)", "case False"], ["proof (state)\nthis:\n  (c2, c1) \\<notin> r\n\ngoal (1 subgoal):\n 1. (c2, c1) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)", "let ?d = \"int (intv_const (I c1)) - int (intv_const (I c2))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (c2, c1) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)", "from False * valid"], ["proof (chain)\npicking this:\n  (c2, c1) \\<notin> r\n  Regions.isIntv (I c1)\n  Regions.isIntv (I c2)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)", "show ?thesis"], ["proof (prove)\nusing this:\n  (c2, c1) \\<notin> r\n  Regions.isIntv (I c1)\n  Regions.isIntv (I c2)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Le (real_of_int d) \\<and>\n       h c2 c1 = Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)", "unfolding h_def"], ["proof (prove)\nusing this:\n  (c2, c1) \\<notin> r\n  Regions.isIntv (I c1)\n  Regions.isIntv (I c2)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       - int (k c2) \\<le> d \\<and>\n       d \\<le> int (k c1) \\<and>\n       (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n        then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n             then Lt (real_of_int\n                       (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                        1))\n             else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                  then Lt (real_of_int\n                            (int (intv_const (I c1)) -\n                             int (intv_const (I c2))))\n                  else Le (real_of_int\n                            (int (intv_const (I c1)) -\n                             int (intv_const (I c2))))\n        else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n             then Le (real_of_int\n                       (int (intv_const (I c1)) - int (intv_const (I c2))))\n             else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                  then Lt (real_of_int\n                            (int (intv_const (I c1)) + 1 -\n                             int (intv_const (I c2))))\n                  else if Regions.isConst (I c1) \\<and>\n                          Regions.isIntv (I c2)\n                       then Lt (real_of_int\n                                 (int (intv_const (I c1)) -\n                                  int (intv_const (I c2))))\n                       else \\<infinity>) =\n       Le (real_of_int d) \\<and>\n       (if Regions.isIntv (I c2) \\<and> Regions.isIntv (I c1)\n        then if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n             then Lt (real_of_int\n                       (int (intv_const (I c2)) - int (intv_const (I c1)) +\n                        1))\n             else if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n                  then Lt (real_of_int\n                            (int (intv_const (I c2)) -\n                             int (intv_const (I c1))))\n                  else Le (real_of_int\n                            (int (intv_const (I c2)) -\n                             int (intv_const (I c1))))\n        else if Regions.isConst (I c2) \\<and> Regions.isConst (I c1)\n             then Le (real_of_int\n                       (int (intv_const (I c2)) - int (intv_const (I c1))))\n             else if Regions.isIntv (I c2) \\<and> Regions.isConst (I c1)\n                  then Lt (real_of_int\n                            (int (intv_const (I c2)) + 1 -\n                             int (intv_const (I c1))))\n                  else if Regions.isConst (I c2) \\<and>\n                          Regions.isIntv (I c1)\n                       then Lt (real_of_int\n                                 (int (intv_const (I c2)) -\n                                  int (intv_const (I c1))))\n                       else \\<infinity>) =\n       Le (- real_of_int d) \\<or>\n       - int (k c2) < d \\<and>\n       d \\<le> int (k c1) \\<and>\n       (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n        then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n             then Lt (real_of_int\n                       (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                        1))\n             else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                  then Lt (real_of_int\n                            (int (intv_const (I c1)) -\n                             int (intv_const (I c2))))\n                  else Le (real_of_int\n                            (int (intv_const (I c1)) -\n                             int (intv_const (I c2))))\n        else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n             then Le (real_of_int\n                       (int (intv_const (I c1)) - int (intv_const (I c2))))\n             else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                  then Lt (real_of_int\n                            (int (intv_const (I c1)) + 1 -\n                             int (intv_const (I c2))))\n                  else if Regions.isConst (I c1) \\<and>\n                          Regions.isIntv (I c2)\n                       then Lt (real_of_int\n                                 (int (intv_const (I c1)) -\n                                  int (intv_const (I c2))))\n                       else \\<infinity>) =\n       Lt (real_of_int d) \\<and>\n       (if Regions.isIntv (I c2) \\<and> Regions.isIntv (I c1)\n        then if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n             then Lt (real_of_int\n                       (int (intv_const (I c2)) - int (intv_const (I c1)) +\n                        1))\n             else if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n                  then Lt (real_of_int\n                            (int (intv_const (I c2)) -\n                             int (intv_const (I c1))))\n                  else Le (real_of_int\n                            (int (intv_const (I c2)) -\n                             int (intv_const (I c1))))\n        else if Regions.isConst (I c2) \\<and> Regions.isConst (I c1)\n             then Le (real_of_int\n                       (int (intv_const (I c2)) - int (intv_const (I c1))))\n             else if Regions.isIntv (I c2) \\<and> Regions.isConst (I c1)\n                  then Lt (real_of_int\n                            (int (intv_const (I c2)) + 1 -\n                             int (intv_const (I c1))))\n                  else if Regions.isConst (I c2) \\<and>\n                          Regions.isIntv (I c1)\n                       then Lt (real_of_int\n                                 (int (intv_const (I c2)) -\n                                  int (intv_const (I c1))))\n                       else \\<infinity>) =\n       Lt (1 - real_of_int d)", "by (intro exI[where x = ?d]) auto"], ["proof (state)\nthis:\n  \\<exists>d.\n     - int (k c2) \\<le> d \\<and>\n     d \\<le> int (k c1) \\<and>\n     h c1 c2 = Le (real_of_int d) \\<and>\n     h c2 c1 = Le (- real_of_int d) \\<or>\n     - int (k c2) < d \\<and>\n     d \\<le> int (k c1) \\<and>\n     h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d.\n     - int (k c2) \\<le> d \\<and>\n     d \\<le> int (k c1) \\<and>\n     h c1 c2 = Le (real_of_int d) \\<and>\n     h c2 c1 = Le (- real_of_int d) \\<or>\n     - int (k c2) < d \\<and>\n     d \\<le> int (k c1) \\<and>\n     h c1 c2 = Lt (real_of_int d) \\<and> h c2 c1 = Lt (1 - real_of_int d)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d.\n     - int (k (v' j)) \\<le> d \\<and>\n     d \\<le> int (k (v' i)) \\<and>\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) =\n     Le (real_of_int d) \\<and>\n     (if j = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' j)\n           else if j = i then Le 0 else h (v' j) (v' i)) =\n     Le (real_of_int (- d)) \\<or>\n     - int (k (v' j)) \\<le> d - 1 \\<and>\n     d \\<le> int (k (v' i)) \\<and>\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) =\n     Lt (real_of_int d) \\<and>\n     (if j = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' j)\n           else if j = i then Le 0 else h (v' j) (v' i)) =\n     Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2___;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "case Greater"], ["proof (state)\nthis:\n  I c2 = Regions.intv.Greater x3_\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "then"], ["proof (chain)\npicking this:\n  I c2 = Regions.intv.Greater x3_", "have \"\\<not> isIntv (I c2)\" \"\\<not> isConst (I c2)\""], ["proof (prove)\nusing this:\n  I c2 = Regions.intv.Greater x3_\n\ngoal (1 subgoal):\n 1. \\<not> Regions.isIntv (I c2) &&& \\<not> Regions.isConst (I c2)", "by auto"], ["proof (state)\nthis:\n  \\<not> Regions.isIntv (I c2)\n  \\<not> Regions.isConst (I c2)\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "with A 2(1) C"], ["proof (chain)\npicking this:\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' i)\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  (if j = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' j)\n        else if j = 0 then Le 0 else h (v' j) (v' 0)) \\<noteq>\n  \\<infinity>\n  i \\<noteq> j\n  v' i = c1\n  v' j = c2\n  \\<not> Regions.isIntv (I c2)\n  \\<not> Regions.isConst (I c2)", "have False"], ["proof (prove)\nusing this:\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' i)\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  (if j = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' j)\n        else if j = 0 then Le 0 else h (v' j) (v' 0)) \\<noteq>\n  \\<infinity>\n  i \\<noteq> j\n  v' i = c1\n  v' j = c2\n  \\<not> Regions.isIntv (I c2)\n  \\<not> Regions.isConst (I c2)\n\ngoal (1 subgoal):\n 1. False", "unfolding f_def"], ["proof (prove)\nusing this:\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0\n        then if Regions.isIntv (I (v' i))\n             then Lt (real (intv_const (I (v' i)) + 1))\n             else if Regions.isConst (I (v' i))\n                  then Le (real (intv_const (I (v' i)))) else \\<infinity>\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  (if j = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0\n        then if Regions.isIntv (I (v' j))\n             then Lt (real (intv_const (I (v' j)) + 1))\n             else if Regions.isConst (I (v' j))\n                  then Le (real (intv_const (I (v' j)))) else \\<infinity>\n        else if j = 0 then Le 0 else h (v' j) (v' 0)) \\<noteq>\n  \\<infinity>\n  i \\<noteq> j\n  v' i = c1\n  v' j = c2\n  \\<not> Regions.isIntv (I c2)\n  \\<not> Regions.isConst (I c2)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       - int (k (v' j)) \\<le> d \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Le (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Le (real_of_int (- d)) \\<or>\n       - int (k (v' j)) \\<le> d - 1 \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Lt (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Lt (real_of_int (- d + 1))", "by fast"], ["proof (state)\nthis:\n  \\<exists>d.\n     - int (k (v' j)) \\<le> d \\<and>\n     d \\<le> int (k (v' i)) \\<and>\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) =\n     Le (real_of_int d) \\<and>\n     (if j = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' j)\n           else if j = i then Le 0 else h (v' j) (v' i)) =\n     Le (real_of_int (- d)) \\<or>\n     - int (k (v' j)) \\<le> d - 1 \\<and>\n     d \\<le> int (k (v' i)) \\<and>\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) =\n     Lt (real_of_int d) \\<and>\n     (if j = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' j)\n           else if j = i then Le 0 else h (v' j) (v' i)) =\n     Lt (real_of_int (- d + 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d.\n     - int (k (v' j)) \\<le> d \\<and>\n     d \\<le> int (k (v' i)) \\<and>\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) =\n     Le (real_of_int d) \\<and>\n     (if j = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' j)\n           else if j = i then Le 0 else h (v' j) (v' i)) =\n     Le (real_of_int (- d)) \\<or>\n     - int (k (v' j)) \\<le> d - 1 \\<and>\n     d \\<le> int (k (v' i)) \\<and>\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) =\n     Lt (real_of_int d) \\<and>\n     (if j = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' j)\n           else if j = i then Le 0 else h (v' j) (v' i)) =\n     Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "case 3"], ["proof (state)\nthis:\n  i \\<noteq> j\n  I c1 = Regions.intv.Greater x3_\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> j\n  I c1 = Regions.intv.Greater x3_", "have \"\\<not> isIntv (I c1)\" \"\\<not> isConst (I c1)\""], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  I c1 = Regions.intv.Greater x3_\n\ngoal (1 subgoal):\n 1. \\<not> Regions.isIntv (I c1) &&& \\<not> Regions.isConst (I c1)", "by auto"], ["proof (state)\nthis:\n  \\<not> Regions.isIntv (I c1)\n  \\<not> Regions.isConst (I c1)\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "with A 3(1) C"], ["proof (chain)\npicking this:\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' i)\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  (if j = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' j)\n        else if j = 0 then Le 0 else h (v' j) (v' 0)) \\<noteq>\n  \\<infinity>\n  i \\<noteq> j\n  v' i = c1\n  v' j = c2\n  \\<not> Regions.isIntv (I c1)\n  \\<not> Regions.isConst (I c1)", "have False"], ["proof (prove)\nusing this:\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' i)\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  (if j = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' j)\n        else if j = 0 then Le 0 else h (v' j) (v' 0)) \\<noteq>\n  \\<infinity>\n  i \\<noteq> j\n  v' i = c1\n  v' j = c2\n  \\<not> Regions.isIntv (I c1)\n  \\<not> Regions.isConst (I c1)\n\ngoal (1 subgoal):\n 1. False", "unfolding f_def"], ["proof (prove)\nusing this:\n  i \\<le> n\n  j \\<le> n\n  0 < i\n  0 < j\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0\n        then if Regions.isIntv (I (v' i))\n             then Lt (real (intv_const (I (v' i)) + 1))\n             else if Regions.isConst (I (v' i))\n                  then Le (real (intv_const (I (v' i)))) else \\<infinity>\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  (if j = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0\n        then if Regions.isIntv (I (v' j))\n             then Lt (real (intv_const (I (v' j)) + 1))\n             else if Regions.isConst (I (v' j))\n                  then Le (real (intv_const (I (v' j)))) else \\<infinity>\n        else if j = 0 then Le 0 else h (v' j) (v' 0)) \\<noteq>\n  \\<infinity>\n  i \\<noteq> j\n  v' i = c1\n  v' j = c2\n  \\<not> Regions.isIntv (I c1)\n  \\<not> Regions.isConst (I c1)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> j; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Le (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Le (real_of_int (- d)) \\<or>\n                            - int (k (v' j)) \\<le> d - 1 \\<and>\n                            d \\<le> int (k (v' i)) \\<and>\n                            (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                             else if j = 0 then f (v' i)\n                                  else if i = j then Le 0\n else h (v' i) (v' j)) =\n                            Lt (real_of_int d) \\<and>\n                            (if j = 0 then if i = 0 then Le 0 else g (v' i)\n                             else if i = 0 then f (v' j)\n                                  else if j = i then Le 0\n else h (v' j) (v' i)) =\n                            Lt (real_of_int (- d + 1))", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       - int (k (v' j)) \\<le> d \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Le (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Le (real_of_int (- d)) \\<or>\n       - int (k (v' j)) \\<le> d - 1 \\<and>\n       d \\<le> int (k (v' i)) \\<and>\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) =\n       Lt (real_of_int d) \\<and>\n       (if j = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' j)\n             else if j = i then Le 0 else h (v' j) (v' i)) =\n       Lt (real_of_int (- d + 1))", "by fast"], ["proof (state)\nthis:\n  \\<exists>d.\n     - int (k (v' j)) \\<le> d \\<and>\n     d \\<le> int (k (v' i)) \\<and>\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) =\n     Le (real_of_int d) \\<and>\n     (if j = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' j)\n           else if j = i then Le 0 else h (v' j) (v' i)) =\n     Le (real_of_int (- d)) \\<or>\n     - int (k (v' j)) \\<le> d - 1 \\<and>\n     d \\<le> int (k (v' i)) \\<and>\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) =\n     Lt (real_of_int d) \\<and>\n     (if j = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' j)\n           else if j = i then Le 0 else h (v' j) (v' i)) =\n     Lt (real_of_int (- d + 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d.\n     - int (k (v' j)) \\<le> d \\<and>\n     d \\<le> int (k (v' i)) \\<and>\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) =\n     Le (real_of_int d) \\<and>\n     (if j = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' j)\n           else if j = i then Le 0 else h (v' j) (v' i)) =\n     Le (real_of_int (- d)) \\<or>\n     - int (k (v' j)) \\<le> d - 1 \\<and>\n     d \\<le> int (k (v' i)) \\<and>\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) =\n     Lt (real_of_int d) \\<and>\n     (if j = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' j)\n           else if j = i then Le 0 else h (v' j) (v' i)) =\n     Lt (real_of_int (- d + 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d.\n     - int (k (v' j)) \\<le> d \\<and>\n     d \\<le> int (k (v' i)) \\<and>\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) =\n     Le (real_of_int d) \\<and>\n     (if j = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' j)\n           else if j = i then Le 0 else h (v' j) (v' i)) =\n     Le (real_of_int (- d)) \\<or>\n     - int (k (v' j)) \\<le> d - 1 \\<and>\n     d \\<le> int (k (v' i)) \\<and>\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) =\n     Lt (real_of_int d) \\<and>\n     (if j = 0 then if i = 0 then Le 0 else g (v' i)\n      else if i = 0 then f (v' j)\n           else if j = i then Le 0 else h (v' j) (v' i)) =\n     Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i3 \\<le> n; ?j3 \\<le> n; 0 < ?i3; 0 < ?j3;\n   (if ?i3 = 0 then if 0 = 0 then Le 0 else g (v' 0)\n    else if 0 = 0 then f (v' ?i3)\n         else if ?i3 = 0 then Le 0 else h (v' ?i3) (v' 0)) \\<noteq>\n   \\<infinity>;\n   (if ?j3 = 0 then if 0 = 0 then Le 0 else g (v' 0)\n    else if 0 = 0 then f (v' ?j3)\n         else if ?j3 = 0 then Le 0 else h (v' ?j3) (v' 0)) \\<noteq>\n   \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>d.\n                       - int (k (v' ?j3)) \\<le> d \\<and>\n                       d \\<le> int (k (v' ?i3)) \\<and>\n                       (if ?i3 = 0 then if ?j3 = 0 then Le 0 else g (v' ?j3)\n                        else if ?j3 = 0 then f (v' ?i3)\n                             else if ?i3 = ?j3 then Le 0\n                                  else h (v' ?i3) (v' ?j3)) =\n                       Le (real_of_int d) \\<and>\n                       (if ?j3 = 0 then if ?i3 = 0 then Le 0 else g (v' ?i3)\n                        else if ?i3 = 0 then f (v' ?j3)\n                             else if ?j3 = ?i3 then Le 0\n                                  else h (v' ?j3) (v' ?i3)) =\n                       Le (real_of_int (- d)) \\<or>\n                       - int (k (v' ?j3)) \\<le> d - 1 \\<and>\n                       d \\<le> int (k (v' ?i3)) \\<and>\n                       (if ?i3 = 0 then if ?j3 = 0 then Le 0 else g (v' ?j3)\n                        else if ?j3 = 0 then f (v' ?i3)\n                             else if ?i3 = ?j3 then Le 0\n                                  else h (v' ?i3) (v' ?j3)) =\n                       Lt (real_of_int d) \\<and>\n                       (if ?j3 = 0 then if ?i3 = 0 then Le 0 else g (v' ?i3)\n                        else if ?i3 = 0 then f (v' ?j3)\n                             else if ?j3 = ?i3 then Le 0\n                                  else h (v' ?j3) (v' ?i3)) =\n                       Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?i3 \\<le> n; ?j3 \\<le> n; 0 < ?i3; 0 < ?j3;\n   (if ?i3 = 0 then if 0 = 0 then Le 0 else g (v' 0)\n    else if 0 = 0 then f (v' ?i3)\n         else if ?i3 = 0 then Le 0 else h (v' ?i3) (v' 0)) \\<noteq>\n   \\<infinity>;\n   (if ?j3 = 0 then if 0 = 0 then Le 0 else g (v' 0)\n    else if 0 = 0 then f (v' ?j3)\n         else if ?j3 = 0 then Le 0 else h (v' ?j3) (v' 0)) \\<noteq>\n   \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>d.\n                       - int (k (v' ?j3)) \\<le> d \\<and>\n                       d \\<le> int (k (v' ?i3)) \\<and>\n                       (if ?i3 = 0 then if ?j3 = 0 then Le 0 else g (v' ?j3)\n                        else if ?j3 = 0 then f (v' ?i3)\n                             else if ?i3 = ?j3 then Le 0\n                                  else h (v' ?i3) (v' ?j3)) =\n                       Le (real_of_int d) \\<and>\n                       (if ?j3 = 0 then if ?i3 = 0 then Le 0 else g (v' ?i3)\n                        else if ?i3 = 0 then f (v' ?j3)\n                             else if ?j3 = ?i3 then Le 0\n                                  else h (v' ?j3) (v' ?i3)) =\n                       Le (real_of_int (- d)) \\<or>\n                       - int (k (v' ?j3)) \\<le> d - 1 \\<and>\n                       d \\<le> int (k (v' ?i3)) \\<and>\n                       (if ?i3 = 0 then if ?j3 = 0 then Le 0 else g (v' ?j3)\n                        else if ?j3 = 0 then f (v' ?i3)\n                             else if ?i3 = ?j3 then Le 0\n                                  else h (v' ?i3) (v' ?j3)) =\n                       Lt (real_of_int d) \\<and>\n                       (if ?j3 = 0 then if ?i3 = 0 then Le 0 else g (v' ?i3)\n                        else if ?i3 = 0 then f (v' ?j3)\n                             else if ?j3 = ?i3 then Le 0\n                                  else h (v' ?j3) (v' ?i3)) =\n                       Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?i3 \\<le> n; ?j3 \\<le> n; 0 < ?i3; 0 < ?j3;\n   (if ?i3 = 0 then if 0 = 0 then Le 0 else g (v' 0)\n    else if 0 = 0 then f (v' ?i3)\n         else if ?i3 = 0 then Le 0 else h (v' ?i3) (v' 0)) \\<noteq>\n   \\<infinity>;\n   (if ?j3 = 0 then if 0 = 0 then Le 0 else g (v' 0)\n    else if 0 = 0 then f (v' ?j3)\n         else if ?j3 = 0 then Le 0 else h (v' ?j3) (v' 0)) \\<noteq>\n   \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>d.\n                       - int (k (v' ?j3)) \\<le> d \\<and>\n                       d \\<le> int (k (v' ?i3)) \\<and>\n                       (if ?i3 = 0 then if ?j3 = 0 then Le 0 else g (v' ?j3)\n                        else if ?j3 = 0 then f (v' ?i3)\n                             else if ?i3 = ?j3 then Le 0\n                                  else h (v' ?i3) (v' ?j3)) =\n                       Le (real_of_int d) \\<and>\n                       (if ?j3 = 0 then if ?i3 = 0 then Le 0 else g (v' ?i3)\n                        else if ?i3 = 0 then f (v' ?j3)\n                             else if ?j3 = ?i3 then Le 0\n                                  else h (v' ?j3) (v' ?i3)) =\n                       Le (real_of_int (- d)) \\<or>\n                       - int (k (v' ?j3)) \\<le> d - 1 \\<and>\n                       d \\<le> int (k (v' ?i3)) \\<and>\n                       (if ?i3 = 0 then if ?j3 = 0 then Le 0 else g (v' ?j3)\n                        else if ?j3 = 0 then f (v' ?i3)\n                             else if ?i3 = ?j3 then Le 0\n                                  else h (v' ?i3) (v' ?j3)) =\n                       Lt (real_of_int d) \\<and>\n                       (if ?j3 = 0 then if ?i3 = 0 then Le 0 else g (v' ?i3)\n                        else if ?i3 = 0 then f (v' ?j3)\n                             else if ?j3 = ?i3 then Le 0\n                                  else h (v' ?j3) (v' ?i3)) =\n                       Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume A: \"i \\<le> n\" \"i > 0\" \"?M i 0 \\<noteq> \\<infinity>\""], ["proof (state)\nthis:\n  i \\<le> n\n  0 < i\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' i)\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with clock_numbering(2)"], ["proof (chain)\npicking this:\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  i \\<le> n\n  0 < i\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' i)\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>", "obtain c1 where B: \"v c1 = i\" \"c1 \\<in> X\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  i \\<le> n\n  0 < i\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' i)\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>c1.\n        \\<lbrakk>v c1 = i; c1 \\<in> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by meson"], ["proof (state)\nthis:\n  v c1 = i\n  c1 \\<in> X\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with clock_numbering(1) A"], ["proof (chain)\npicking this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  i \\<le> n\n  0 < i\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' i)\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  v c1 = i\n  c1 \\<in> X", "have C: \"v' i = c1\""], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  i \\<le> n\n  0 < i\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' i)\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  v c1 = i\n  c1 \\<in> X\n\ngoal (1 subgoal):\n 1. v' i = c1", "unfolding v'_def"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  i \\<le> n\n  0 < i\n  (if i = 0 then if 0 = 0 then Le 0 else g (THE c. c \\<in> X \\<and> v c = 0)\n   else if 0 = 0 then f (THE c. c \\<in> X \\<and> v c = i)\n        else if i = 0 then Le 0\n             else h (THE c. c \\<in> X \\<and> v c = i)\n                   (THE c. c \\<in> X \\<and> v c = 0)) \\<noteq>\n  \\<infinity>\n  v c1 = i\n  c1 \\<in> X\n\ngoal (1 subgoal):\n 1. (THE c. c \\<in> X \\<and> v c = i) = c1", "by force+"], ["proof (state)\nthis:\n  v' i = c1\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from R(2) B"], ["proof (chain)\npicking this:\n  Regions.valid_region X k I r\n  v c1 = i\n  c1 \\<in> X", "have valid: \"valid_intv (k c1) (I c1)\""], ["proof (prove)\nusing this:\n  Regions.valid_region X k I r\n  v c1 = i\n  c1 \\<in> X\n\ngoal (1 subgoal):\n 1. Regions.valid_intv (k c1) (I c1)", "by auto"], ["proof (state)\nthis:\n  Regions.valid_intv (k c1) (I c1)\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists> d :: int. d \\<le> k (v' i) \\<and> d \\<ge> 0\n      \\<and> (?M i 0 = Le d \\<and> ?M 0 i = Le (-d) \\<or> ?M i 0 = Lt d \\<and> ?M 0 i = Lt (-d + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d\\<le>int (k (v' i)).\n       0 \\<le> d \\<and>\n       ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Le (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int (- d)) \\<or>\n        (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Lt (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int (- d + 1)))", "proof (cases \"i = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>d\\<le>int (k (v' i)).\n       0 \\<le> d \\<and>\n       ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Le (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int (- d)) \\<or>\n        (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Lt (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int (- d + 1)))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>d\\<le>int (k (v' i)).\n       0 \\<le> d \\<and>\n       ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Le (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int (- d)) \\<or>\n        (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Lt (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int (- d + 1)))", "case True"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>d\\<le>int (k (v' i)).\n       0 \\<le> d \\<and>\n       ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Le (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int (- d)) \\<or>\n        (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Lt (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int (- d + 1)))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>d\\<le>int (k (v' i)).\n       0 \\<le> d \\<and>\n       ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Le (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int (- d)) \\<or>\n        (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Lt (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int (- d + 1)))", "then"], ["proof (chain)\npicking this:\n  i = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. \\<exists>d\\<le>int (k (v' i)).\n       0 \\<le> d \\<and>\n       ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Le (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int (- d)) \\<or>\n        (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Lt (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int (- d + 1)))", "by auto"], ["proof (state)\nthis:\n  \\<exists>d\\<le>int (k (v' i)).\n     0 \\<le> d \\<and>\n     ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n       else if 0 = 0 then f (v' i)\n            else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n      Le (real_of_int d) \\<and>\n      (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n       else if i = 0 then f (v' 0)\n            else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n      Le (real_of_int (- d)) \\<or>\n      (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n       else if 0 = 0 then f (v' i)\n            else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n      Lt (real_of_int d) \\<and>\n      (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n       else if i = 0 then f (v' 0)\n            else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n      Lt (real_of_int (- d + 1)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>d\\<le>int (k (v' i)).\n       0 \\<le> d \\<and>\n       ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Le (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int (- d)) \\<or>\n        (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Lt (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int (- d + 1)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>d\\<le>int (k (v' i)).\n       0 \\<le> d \\<and>\n       ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Le (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int (- d)) \\<or>\n        (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Lt (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int (- d + 1)))", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>d\\<le>int (k (v' i)).\n       0 \\<le> d \\<and>\n       ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Le (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int (- d)) \\<or>\n        (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Lt (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int (- d + 1)))", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>d\\<le>int (k (v' i)).\n       0 \\<le> d \\<and>\n       ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Le (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int (- d)) \\<or>\n        (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Lt (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int (- d + 1)))", "proof (cases \"I c1\", goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Const x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))\n 2. \\<And>x2.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))\n 3. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))", "case 1"], ["proof (state)\nthis:\n  i \\<noteq> 0\n  I c1 = Regions.intv.Const x1_\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Const x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))\n 2. \\<And>x2.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))\n 3. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))", "let ?d = \"int (intv_const (I c1))\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Const x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))\n 2. \\<And>x2.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))\n 3. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))", "from 1"], ["proof (chain)\npicking this:\n  i \\<noteq> 0\n  I c1 = Regions.intv.Const x1_", "have \"isConst (I c1)\" \"\\<not> isIntv (I c1)\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  I c1 = Regions.intv.Const x1_\n\ngoal (1 subgoal):\n 1. Regions.isConst (I c1) &&& \\<not> Regions.isIntv (I c1)", "by auto"], ["proof (state)\nthis:\n  Regions.isConst (I c1)\n  \\<not> Regions.isIntv (I c1)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Const x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))\n 2. \\<And>x2.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))\n 3. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))", "with A C valid"], ["proof (chain)\npicking this:\n  i \\<le> n\n  0 < i\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' i)\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  v' i = c1\n  Regions.valid_intv (k c1) (I c1)\n  Regions.isConst (I c1)\n  \\<not> Regions.isIntv (I c1)", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' i)\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  v' i = c1\n  Regions.valid_intv (k c1) (I c1)\n  Regions.isConst (I c1)\n  \\<not> Regions.isIntv (I c1)\n\ngoal (1 subgoal):\n 1. \\<exists>d\\<le>int (k (v' i)).\n       0 \\<le> d \\<and>\n       ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Le (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int (- d)) \\<or>\n        (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Lt (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int (- d + 1)))", "unfolding f_def g_def"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  (if i = 0\n   then if 0 = 0 then Le 0\n        else if Regions.isIntv (I (v' 0))\n             then Lt (real_of_int (- int (intv_const (I (v' 0)))))\n             else if Regions.isConst (I (v' 0))\n                  then Le (real_of_int (- int (intv_const (I (v' 0)))))\n                  else Lt (real_of_int (- int (k (v' 0))))\n   else if 0 = 0\n        then if Regions.isIntv (I (v' i))\n             then Lt (real (intv_const (I (v' i)) + 1))\n             else if Regions.isConst (I (v' i))\n                  then Le (real (intv_const (I (v' i)))) else \\<infinity>\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  v' i = c1\n  Regions.valid_intv (k c1) (I c1)\n  Regions.isConst (I c1)\n  \\<not> Regions.isIntv (I c1)\n\ngoal (1 subgoal):\n 1. \\<exists>d\\<le>int (k (v' i)).\n       0 \\<le> d \\<and>\n       ((if i = 0\n         then if 0 = 0 then Le 0\n              else if Regions.isIntv (I (v' 0))\n                   then Lt (real_of_int (- int (intv_const (I (v' 0)))))\n                   else if Regions.isConst (I (v' 0))\n                        then Le (real_of_int\n                                  (- int (intv_const (I (v' 0)))))\n                        else Lt (real_of_int (- int (k (v' 0))))\n         else if 0 = 0\n              then if Regions.isIntv (I (v' i))\n                   then Lt (real (intv_const (I (v' i)) + 1))\n                   else if Regions.isConst (I (v' i))\n                        then Le (real (intv_const (I (v' i))))\n                        else \\<infinity>\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Le (real_of_int d) \\<and>\n        (if 0 = 0\n         then if i = 0 then Le 0\n              else if Regions.isIntv (I (v' i))\n                   then Lt (real_of_int (- int (intv_const (I (v' i)))))\n                   else if Regions.isConst (I (v' i))\n                        then Le (real_of_int\n                                  (- int (intv_const (I (v' i)))))\n                        else Lt (real_of_int (- int (k (v' i))))\n         else if i = 0\n              then if Regions.isIntv (I (v' 0))\n                   then Lt (real (intv_const (I (v' 0)) + 1))\n                   else if Regions.isConst (I (v' 0))\n                        then Le (real (intv_const (I (v' 0))))\n                        else \\<infinity>\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int (- d)) \\<or>\n        (if i = 0\n         then if 0 = 0 then Le 0\n              else if Regions.isIntv (I (v' 0))\n                   then Lt (real_of_int (- int (intv_const (I (v' 0)))))\n                   else if Regions.isConst (I (v' 0))\n                        then Le (real_of_int\n                                  (- int (intv_const (I (v' 0)))))\n                        else Lt (real_of_int (- int (k (v' 0))))\n         else if 0 = 0\n              then if Regions.isIntv (I (v' i))\n                   then Lt (real (intv_const (I (v' i)) + 1))\n                   else if Regions.isConst (I (v' i))\n                        then Le (real (intv_const (I (v' i))))\n                        else \\<infinity>\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Lt (real_of_int d) \\<and>\n        (if 0 = 0\n         then if i = 0 then Le 0\n              else if Regions.isIntv (I (v' i))\n                   then Lt (real_of_int (- int (intv_const (I (v' i)))))\n                   else if Regions.isConst (I (v' i))\n                        then Le (real_of_int\n                                  (- int (intv_const (I (v' i)))))\n                        else Lt (real_of_int (- int (k (v' i))))\n         else if i = 0\n              then if Regions.isIntv (I (v' 0))\n                   then Lt (real (intv_const (I (v' 0)) + 1))\n                   else if Regions.isConst (I (v' 0))\n                        then Le (real (intv_const (I (v' 0))))\n                        else \\<infinity>\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int (- d + 1)))", "by (intro exI[where x = ?d]) auto"], ["proof (state)\nthis:\n  \\<exists>d\\<le>int (k (v' i)).\n     0 \\<le> d \\<and>\n     ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n       else if 0 = 0 then f (v' i)\n            else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n      Le (real_of_int d) \\<and>\n      (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n       else if i = 0 then f (v' 0)\n            else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n      Le (real_of_int (- d)) \\<or>\n      (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n       else if 0 = 0 then f (v' i)\n            else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n      Lt (real_of_int d) \\<and>\n      (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n       else if i = 0 then f (v' 0)\n            else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n      Lt (real_of_int (- d + 1)))\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))\n 2. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))\n 2. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))", "case 2"], ["proof (state)\nthis:\n  i \\<noteq> 0\n  I c1 = Regions.intv.Intv x2_\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))\n 2. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))", "let ?d = \"int (intv_const (I c1)) + 1\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))\n 2. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))", "from 2"], ["proof (chain)\npicking this:\n  i \\<noteq> 0\n  I c1 = Regions.intv.Intv x2_", "have \"isIntv(I c1)\" \"\\<not> isConst (I c1)\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  I c1 = Regions.intv.Intv x2_\n\ngoal (1 subgoal):\n 1. Regions.isIntv (I c1) &&& \\<not> Regions.isConst (I c1)", "by auto"], ["proof (state)\nthis:\n  Regions.isIntv (I c1)\n  \\<not> Regions.isConst (I c1)\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))\n 2. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))", "with A C valid"], ["proof (chain)\npicking this:\n  i \\<le> n\n  0 < i\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' i)\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  v' i = c1\n  Regions.valid_intv (k c1) (I c1)\n  Regions.isIntv (I c1)\n  \\<not> Regions.isConst (I c1)", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' i)\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  v' i = c1\n  Regions.valid_intv (k c1) (I c1)\n  Regions.isIntv (I c1)\n  \\<not> Regions.isConst (I c1)\n\ngoal (1 subgoal):\n 1. \\<exists>d\\<le>int (k (v' i)).\n       0 \\<le> d \\<and>\n       ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Le (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int (- d)) \\<or>\n        (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Lt (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int (- d + 1)))", "unfolding f_def g_def"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  (if i = 0\n   then if 0 = 0 then Le 0\n        else if Regions.isIntv (I (v' 0))\n             then Lt (real_of_int (- int (intv_const (I (v' 0)))))\n             else if Regions.isConst (I (v' 0))\n                  then Le (real_of_int (- int (intv_const (I (v' 0)))))\n                  else Lt (real_of_int (- int (k (v' 0))))\n   else if 0 = 0\n        then if Regions.isIntv (I (v' i))\n             then Lt (real (intv_const (I (v' i)) + 1))\n             else if Regions.isConst (I (v' i))\n                  then Le (real (intv_const (I (v' i)))) else \\<infinity>\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  v' i = c1\n  Regions.valid_intv (k c1) (I c1)\n  Regions.isIntv (I c1)\n  \\<not> Regions.isConst (I c1)\n\ngoal (1 subgoal):\n 1. \\<exists>d\\<le>int (k (v' i)).\n       0 \\<le> d \\<and>\n       ((if i = 0\n         then if 0 = 0 then Le 0\n              else if Regions.isIntv (I (v' 0))\n                   then Lt (real_of_int (- int (intv_const (I (v' 0)))))\n                   else if Regions.isConst (I (v' 0))\n                        then Le (real_of_int\n                                  (- int (intv_const (I (v' 0)))))\n                        else Lt (real_of_int (- int (k (v' 0))))\n         else if 0 = 0\n              then if Regions.isIntv (I (v' i))\n                   then Lt (real (intv_const (I (v' i)) + 1))\n                   else if Regions.isConst (I (v' i))\n                        then Le (real (intv_const (I (v' i))))\n                        else \\<infinity>\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Le (real_of_int d) \\<and>\n        (if 0 = 0\n         then if i = 0 then Le 0\n              else if Regions.isIntv (I (v' i))\n                   then Lt (real_of_int (- int (intv_const (I (v' i)))))\n                   else if Regions.isConst (I (v' i))\n                        then Le (real_of_int\n                                  (- int (intv_const (I (v' i)))))\n                        else Lt (real_of_int (- int (k (v' i))))\n         else if i = 0\n              then if Regions.isIntv (I (v' 0))\n                   then Lt (real (intv_const (I (v' 0)) + 1))\n                   else if Regions.isConst (I (v' 0))\n                        then Le (real (intv_const (I (v' 0))))\n                        else \\<infinity>\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int (- d)) \\<or>\n        (if i = 0\n         then if 0 = 0 then Le 0\n              else if Regions.isIntv (I (v' 0))\n                   then Lt (real_of_int (- int (intv_const (I (v' 0)))))\n                   else if Regions.isConst (I (v' 0))\n                        then Le (real_of_int\n                                  (- int (intv_const (I (v' 0)))))\n                        else Lt (real_of_int (- int (k (v' 0))))\n         else if 0 = 0\n              then if Regions.isIntv (I (v' i))\n                   then Lt (real (intv_const (I (v' i)) + 1))\n                   else if Regions.isConst (I (v' i))\n                        then Le (real (intv_const (I (v' i))))\n                        else \\<infinity>\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Lt (real_of_int d) \\<and>\n        (if 0 = 0\n         then if i = 0 then Le 0\n              else if Regions.isIntv (I (v' i))\n                   then Lt (real_of_int (- int (intv_const (I (v' i)))))\n                   else if Regions.isConst (I (v' i))\n                        then Le (real_of_int\n                                  (- int (intv_const (I (v' i)))))\n                        else Lt (real_of_int (- int (k (v' i))))\n         else if i = 0\n              then if Regions.isIntv (I (v' 0))\n                   then Lt (real (intv_const (I (v' 0)) + 1))\n                   else if Regions.isConst (I (v' 0))\n                        then Le (real (intv_const (I (v' 0))))\n                        else \\<infinity>\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int (- d + 1)))", "by (intro exI[where x = ?d]) auto"], ["proof (state)\nthis:\n  \\<exists>d\\<le>int (k (v' i)).\n     0 \\<le> d \\<and>\n     ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n       else if 0 = 0 then f (v' i)\n            else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n      Le (real_of_int d) \\<and>\n      (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n       else if i = 0 then f (v' 0)\n            else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n      Le (real_of_int (- d)) \\<or>\n      (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n       else if 0 = 0 then f (v' i)\n            else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n      Lt (real_of_int d) \\<and>\n      (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n       else if i = 0 then f (v' 0)\n            else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n      Lt (real_of_int (- d + 1)))\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))", "case 3"], ["proof (state)\nthis:\n  i \\<noteq> 0\n  I c1 = Regions.intv.Greater x3_\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> 0\n  I c1 = Regions.intv.Greater x3_", "have \"\\<not> isIntv (I c1)\" \"\\<not> isConst (I c1)\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  I c1 = Regions.intv.Greater x3_\n\ngoal (1 subgoal):\n 1. \\<not> Regions.isIntv (I c1) &&& \\<not> Regions.isConst (I c1)", "by auto"], ["proof (state)\nthis:\n  \\<not> Regions.isIntv (I c1)\n  \\<not> Regions.isConst (I c1)\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))", "with A 3(1) C"], ["proof (chain)\npicking this:\n  i \\<le> n\n  0 < i\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' i)\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  i \\<noteq> 0\n  v' i = c1\n  \\<not> Regions.isIntv (I c1)\n  \\<not> Regions.isConst (I c1)", "have False"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0 then f (v' i)\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  i \\<noteq> 0\n  v' i = c1\n  \\<not> Regions.isIntv (I c1)\n  \\<not> Regions.isConst (I c1)\n\ngoal (1 subgoal):\n 1. False", "unfolding f_def"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n   else if 0 = 0\n        then if Regions.isIntv (I (v' i))\n             then Lt (real (intv_const (I (v' i)) + 1))\n             else if Regions.isConst (I (v' i))\n                  then Le (real (intv_const (I (v' i)))) else \\<infinity>\n        else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n  \\<infinity>\n  i \\<noteq> 0\n  v' i = c1\n  \\<not> Regions.isIntv (I c1)\n  \\<not> Regions.isConst (I c1)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<le>int (k (v' i)).\n                            0 \\<le> d \\<and>\n                            ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Le (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int (- d)) \\<or>\n                             (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                              else if 0 = 0 then f (v' i)\n                                   else if i = 0 then Le 0\n  else h (v' i) (v' 0)) =\n                             Lt (real_of_int d) \\<and>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int (- d + 1)))", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>d\\<le>int (k (v' i)).\n       0 \\<le> d \\<and>\n       ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Le (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int (- d)) \\<or>\n        (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n         else if 0 = 0 then f (v' i)\n              else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n        Lt (real_of_int d) \\<and>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int (- d + 1)))", "by fast"], ["proof (state)\nthis:\n  \\<exists>d\\<le>int (k (v' i)).\n     0 \\<le> d \\<and>\n     ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n       else if 0 = 0 then f (v' i)\n            else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n      Le (real_of_int d) \\<and>\n      (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n       else if i = 0 then f (v' 0)\n            else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n      Le (real_of_int (- d)) \\<or>\n      (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n       else if 0 = 0 then f (v' i)\n            else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n      Lt (real_of_int d) \\<and>\n      (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n       else if i = 0 then f (v' 0)\n            else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n      Lt (real_of_int (- d + 1)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d\\<le>int (k (v' i)).\n     0 \\<le> d \\<and>\n     ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n       else if 0 = 0 then f (v' i)\n            else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n      Le (real_of_int d) \\<and>\n      (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n       else if i = 0 then f (v' 0)\n            else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n      Le (real_of_int (- d)) \\<or>\n      (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n       else if 0 = 0 then f (v' i)\n            else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n      Lt (real_of_int d) \\<and>\n      (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n       else if i = 0 then f (v' 0)\n            else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n      Lt (real_of_int (- d + 1)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d\\<le>int (k (v' i)).\n     0 \\<le> d \\<and>\n     ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n       else if 0 = 0 then f (v' i)\n            else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n      Le (real_of_int d) \\<and>\n      (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n       else if i = 0 then f (v' 0)\n            else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n      Le (real_of_int (- d)) \\<or>\n      (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n       else if 0 = 0 then f (v' i)\n            else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n      Lt (real_of_int d) \\<and>\n      (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n       else if i = 0 then f (v' 0)\n            else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n      Lt (real_of_int (- d + 1)))\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i3 \\<le> n; 0 < ?i3;\n   (if ?i3 = 0 then if 0 = 0 then Le 0 else g (v' 0)\n    else if 0 = 0 then f (v' ?i3)\n         else if ?i3 = 0 then Le 0 else h (v' ?i3) (v' 0)) \\<noteq>\n   \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>d\\<le>int (k (v' ?i3)).\n                       0 \\<le> d \\<and>\n                       ((if ?i3 = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                         else if 0 = 0 then f (v' ?i3)\n                              else if ?i3 = 0 then Le 0\n                                   else h (v' ?i3) (v' 0)) =\n                        Le (real_of_int d) \\<and>\n                        (if 0 = 0 then if ?i3 = 0 then Le 0 else g (v' ?i3)\n                         else if ?i3 = 0 then f (v' 0)\n                              else if 0 = ?i3 then Le 0\n                                   else h (v' 0) (v' ?i3)) =\n                        Le (real_of_int (- d)) \\<or>\n                        (if ?i3 = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                         else if 0 = 0 then f (v' ?i3)\n                              else if ?i3 = 0 then Le 0\n                                   else h (v' ?i3) (v' 0)) =\n                        Lt (real_of_int d) \\<and>\n                        (if 0 = 0 then if ?i3 = 0 then Le 0 else g (v' ?i3)\n                         else if ?i3 = 0 then f (v' 0)\n                              else if 0 = ?i3 then Le 0\n                                   else h (v' 0) (v' ?i3)) =\n                        Lt (real_of_int (- d + 1)))\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?i3 \\<le> n; 0 < ?i3;\n   (if ?i3 = 0 then if 0 = 0 then Le 0 else g (v' 0)\n    else if 0 = 0 then f (v' ?i3)\n         else if ?i3 = 0 then Le 0 else h (v' ?i3) (v' 0)) \\<noteq>\n   \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>d\\<le>int (k (v' ?i3)).\n                       0 \\<le> d \\<and>\n                       ((if ?i3 = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                         else if 0 = 0 then f (v' ?i3)\n                              else if ?i3 = 0 then Le 0\n                                   else h (v' ?i3) (v' 0)) =\n                        Le (real_of_int d) \\<and>\n                        (if 0 = 0 then if ?i3 = 0 then Le 0 else g (v' ?i3)\n                         else if ?i3 = 0 then f (v' 0)\n                              else if 0 = ?i3 then Le 0\n                                   else h (v' 0) (v' ?i3)) =\n                        Le (real_of_int (- d)) \\<or>\n                        (if ?i3 = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                         else if 0 = 0 then f (v' ?i3)\n                              else if ?i3 = 0 then Le 0\n                                   else h (v' ?i3) (v' 0)) =\n                        Lt (real_of_int d) \\<and>\n                        (if 0 = 0 then if ?i3 = 0 then Le 0 else g (v' ?i3)\n                         else if ?i3 = 0 then f (v' 0)\n                              else if 0 = ?i3 then Le 0\n                                   else h (v' 0) (v' ?i3)) =\n                        Lt (real_of_int (- d + 1)))\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?i3 \\<le> n; 0 < ?i3;\n   (if ?i3 = 0 then if 0 = 0 then Le 0 else g (v' 0)\n    else if 0 = 0 then f (v' ?i3)\n         else if ?i3 = 0 then Le 0 else h (v' ?i3) (v' 0)) \\<noteq>\n   \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>d\\<le>int (k (v' ?i3)).\n                       0 \\<le> d \\<and>\n                       ((if ?i3 = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                         else if 0 = 0 then f (v' ?i3)\n                              else if ?i3 = 0 then Le 0\n                                   else h (v' ?i3) (v' 0)) =\n                        Le (real_of_int d) \\<and>\n                        (if 0 = 0 then if ?i3 = 0 then Le 0 else g (v' ?i3)\n                         else if ?i3 = 0 then f (v' 0)\n                              else if 0 = ?i3 then Le 0\n                                   else h (v' 0) (v' ?i3)) =\n                        Le (real_of_int (- d)) \\<or>\n                        (if ?i3 = 0 then if 0 = 0 then Le 0 else g (v' 0)\n                         else if 0 = 0 then f (v' ?i3)\n                              else if ?i3 = 0 then Le 0\n                                   else h (v' ?i3) (v' 0)) =\n                        Lt (real_of_int d) \\<and>\n                        (if 0 = 0 then if ?i3 = 0 then Le 0 else g (v' ?i3)\n                         else if ?i3 = 0 then f (v' 0)\n                              else if 0 = ?i3 then Le 0\n                                   else h (v' 0) (v' ?i3)) =\n                        Lt (real_of_int (- d + 1)))\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume A: \"i \\<le> n\" \"i > 0\""], ["proof (state)\nthis:\n  i \\<le> n\n  0 < i\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with clock_numbering(2)"], ["proof (chain)\npicking this:\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  i \\<le> n\n  0 < i", "obtain c1 where B: \"v c1 = i\" \"c1 \\<in> X\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  i \\<le> n\n  0 < i\n\ngoal (1 subgoal):\n 1. (\\<And>c1.\n        \\<lbrakk>v c1 = i; c1 \\<in> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by meson"], ["proof (state)\nthis:\n  v c1 = i\n  c1 \\<in> X\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with clock_numbering(1) A"], ["proof (chain)\npicking this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  i \\<le> n\n  0 < i\n  v c1 = i\n  c1 \\<in> X", "have C: \"v' i = c1\""], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  i \\<le> n\n  0 < i\n  v c1 = i\n  c1 \\<in> X\n\ngoal (1 subgoal):\n 1. v' i = c1", "unfolding v'_def"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  i \\<le> n\n  0 < i\n  v c1 = i\n  c1 \\<in> X\n\ngoal (1 subgoal):\n 1. (THE c. c \\<in> X \\<and> v c = i) = c1", "by force+"], ["proof (state)\nthis:\n  v' i = c1\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from R(2) B"], ["proof (chain)\npicking this:\n  Regions.valid_region X k I r\n  v c1 = i\n  c1 \\<in> X", "have valid: \"valid_intv (k c1) (I c1)\""], ["proof (prove)\nusing this:\n  Regions.valid_region X k I r\n  v c1 = i\n  c1 \\<in> X\n\ngoal (1 subgoal):\n 1. Regions.valid_intv (k c1) (I c1)", "by auto"], ["proof (state)\nthis:\n  Regions.valid_intv (k c1) (I c1)\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists> d :: int. - k (v' i) \\<le> d \\<and> d \\<le> 0 \\<and> (?M 0 i = Le d \\<or> ?M 0 i = Lt d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d\\<ge>- int (k (v' i)).\n       d \\<le> 0 \\<and>\n       ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int d) \\<or>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int d))", "proof (cases \"i = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>d\\<ge>- int (k (v' i)).\n       d \\<le> 0 \\<and>\n       ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int d) \\<or>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int d))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>d\\<ge>- int (k (v' i)).\n       d \\<le> 0 \\<and>\n       ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int d) \\<or>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int d))", "case True"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>d\\<ge>- int (k (v' i)).\n       d \\<le> 0 \\<and>\n       ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int d) \\<or>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int d))\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>d\\<ge>- int (k (v' i)).\n       d \\<le> 0 \\<and>\n       ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int d) \\<or>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int d))", "then"], ["proof (chain)\npicking this:\n  i = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. \\<exists>d\\<ge>- int (k (v' i)).\n       d \\<le> 0 \\<and>\n       ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int d) \\<or>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int d))", "by auto"], ["proof (state)\nthis:\n  \\<exists>d\\<ge>- int (k (v' i)).\n     d \\<le> 0 \\<and>\n     ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n       else if i = 0 then f (v' 0)\n            else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n      Le (real_of_int d) \\<or>\n      (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n       else if i = 0 then f (v' 0)\n            else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n      Lt (real_of_int d))\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>d\\<ge>- int (k (v' i)).\n       d \\<le> 0 \\<and>\n       ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int d) \\<or>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int d))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>d\\<ge>- int (k (v' i)).\n       d \\<le> 0 \\<and>\n       ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int d) \\<or>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int d))", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>d\\<ge>- int (k (v' i)).\n       d \\<le> 0 \\<and>\n       ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int d) \\<or>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int d))", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>d\\<ge>- int (k (v' i)).\n       d \\<le> 0 \\<and>\n       ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int d) \\<or>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int d))", "proof (cases \"I c1\", goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Const x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))\n 2. \\<And>x2.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))\n 3. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))", "case 1"], ["proof (state)\nthis:\n  i \\<noteq> 0\n  I c1 = Regions.intv.Const x1_\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Const x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))\n 2. \\<And>x2.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))\n 3. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))", "let ?d = \"- int (intv_const (I c1))\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Const x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))\n 2. \\<And>x2.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))\n 3. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))", "from 1"], ["proof (chain)\npicking this:\n  i \\<noteq> 0\n  I c1 = Regions.intv.Const x1_", "have \"isConst (I c1)\" \"\\<not> isIntv (I c1)\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  I c1 = Regions.intv.Const x1_\n\ngoal (1 subgoal):\n 1. Regions.isConst (I c1) &&& \\<not> Regions.isIntv (I c1)", "by auto"], ["proof (state)\nthis:\n  Regions.isConst (I c1)\n  \\<not> Regions.isIntv (I c1)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Const x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))\n 2. \\<And>x2.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))\n 3. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))", "with A C valid"], ["proof (chain)\npicking this:\n  i \\<le> n\n  0 < i\n  v' i = c1\n  Regions.valid_intv (k c1) (I c1)\n  Regions.isConst (I c1)\n  \\<not> Regions.isIntv (I c1)", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  v' i = c1\n  Regions.valid_intv (k c1) (I c1)\n  Regions.isConst (I c1)\n  \\<not> Regions.isIntv (I c1)\n\ngoal (1 subgoal):\n 1. \\<exists>d\\<ge>- int (k (v' i)).\n       d \\<le> 0 \\<and>\n       ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int d) \\<or>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int d))", "unfolding f_def g_def"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  v' i = c1\n  Regions.valid_intv (k c1) (I c1)\n  Regions.isConst (I c1)\n  \\<not> Regions.isIntv (I c1)\n\ngoal (1 subgoal):\n 1. \\<exists>d\\<ge>- int (k (v' i)).\n       d \\<le> 0 \\<and>\n       ((if 0 = 0\n         then if i = 0 then Le 0\n              else if Regions.isIntv (I (v' i))\n                   then Lt (real_of_int (- int (intv_const (I (v' i)))))\n                   else if Regions.isConst (I (v' i))\n                        then Le (real_of_int\n                                  (- int (intv_const (I (v' i)))))\n                        else Lt (real_of_int (- int (k (v' i))))\n         else if i = 0\n              then if Regions.isIntv (I (v' 0))\n                   then Lt (real (intv_const (I (v' 0)) + 1))\n                   else if Regions.isConst (I (v' 0))\n                        then Le (real (intv_const (I (v' 0))))\n                        else \\<infinity>\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int d) \\<or>\n        (if 0 = 0\n         then if i = 0 then Le 0\n              else if Regions.isIntv (I (v' i))\n                   then Lt (real_of_int (- int (intv_const (I (v' i)))))\n                   else if Regions.isConst (I (v' i))\n                        then Le (real_of_int\n                                  (- int (intv_const (I (v' i)))))\n                        else Lt (real_of_int (- int (k (v' i))))\n         else if i = 0\n              then if Regions.isIntv (I (v' 0))\n                   then Lt (real (intv_const (I (v' 0)) + 1))\n                   else if Regions.isConst (I (v' 0))\n                        then Le (real (intv_const (I (v' 0))))\n                        else \\<infinity>\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int d))", "by (intro exI[where x = ?d]) auto"], ["proof (state)\nthis:\n  \\<exists>d\\<ge>- int (k (v' i)).\n     d \\<le> 0 \\<and>\n     ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n       else if i = 0 then f (v' 0)\n            else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n      Le (real_of_int d) \\<or>\n      (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n       else if i = 0 then f (v' 0)\n            else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n      Lt (real_of_int d))\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))\n 2. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))\n 2. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))", "case 2"], ["proof (state)\nthis:\n  i \\<noteq> 0\n  I c1 = Regions.intv.Intv x2_\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))\n 2. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))", "let ?d = \"- int (intv_const (I c1))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))\n 2. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))", "from 2"], ["proof (chain)\npicking this:\n  i \\<noteq> 0\n  I c1 = Regions.intv.Intv x2_", "have \"isIntv(I c1)\" \"\\<not> isConst (I c1)\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  I c1 = Regions.intv.Intv x2_\n\ngoal (1 subgoal):\n 1. Regions.isIntv (I c1) &&& \\<not> Regions.isConst (I c1)", "by auto"], ["proof (state)\nthis:\n  Regions.isIntv (I c1)\n  \\<not> Regions.isConst (I c1)\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))\n 2. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))", "with A C valid"], ["proof (chain)\npicking this:\n  i \\<le> n\n  0 < i\n  v' i = c1\n  Regions.valid_intv (k c1) (I c1)\n  Regions.isIntv (I c1)\n  \\<not> Regions.isConst (I c1)", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  v' i = c1\n  Regions.valid_intv (k c1) (I c1)\n  Regions.isIntv (I c1)\n  \\<not> Regions.isConst (I c1)\n\ngoal (1 subgoal):\n 1. \\<exists>d\\<ge>- int (k (v' i)).\n       d \\<le> 0 \\<and>\n       ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int d) \\<or>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int d))", "unfolding f_def g_def"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  v' i = c1\n  Regions.valid_intv (k c1) (I c1)\n  Regions.isIntv (I c1)\n  \\<not> Regions.isConst (I c1)\n\ngoal (1 subgoal):\n 1. \\<exists>d\\<ge>- int (k (v' i)).\n       d \\<le> 0 \\<and>\n       ((if 0 = 0\n         then if i = 0 then Le 0\n              else if Regions.isIntv (I (v' i))\n                   then Lt (real_of_int (- int (intv_const (I (v' i)))))\n                   else if Regions.isConst (I (v' i))\n                        then Le (real_of_int\n                                  (- int (intv_const (I (v' i)))))\n                        else Lt (real_of_int (- int (k (v' i))))\n         else if i = 0\n              then if Regions.isIntv (I (v' 0))\n                   then Lt (real (intv_const (I (v' 0)) + 1))\n                   else if Regions.isConst (I (v' 0))\n                        then Le (real (intv_const (I (v' 0))))\n                        else \\<infinity>\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int d) \\<or>\n        (if 0 = 0\n         then if i = 0 then Le 0\n              else if Regions.isIntv (I (v' i))\n                   then Lt (real_of_int (- int (intv_const (I (v' i)))))\n                   else if Regions.isConst (I (v' i))\n                        then Le (real_of_int\n                                  (- int (intv_const (I (v' i)))))\n                        else Lt (real_of_int (- int (k (v' i))))\n         else if i = 0\n              then if Regions.isIntv (I (v' 0))\n                   then Lt (real (intv_const (I (v' 0)) + 1))\n                   else if Regions.isConst (I (v' 0))\n                        then Le (real (intv_const (I (v' 0))))\n                        else \\<infinity>\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int d))", "by (intro exI[where x = ?d]) auto"], ["proof (state)\nthis:\n  \\<exists>d\\<ge>- int (k (v' i)).\n     d \\<le> 0 \\<and>\n     ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n       else if i = 0 then f (v' 0)\n            else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n      Le (real_of_int d) \\<or>\n      (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n       else if i = 0 then f (v' 0)\n            else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n      Lt (real_of_int d))\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))", "case 3"], ["proof (state)\nthis:\n  i \\<noteq> 0\n  I c1 = Regions.intv.Greater x3_\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))", "let ?d = \"- (k c1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))", "from 3"], ["proof (chain)\npicking this:\n  i \\<noteq> 0\n  I c1 = Regions.intv.Greater x3_", "have \"\\<not> isIntv (I c1)\" \"\\<not> isConst (I c1)\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  I c1 = Regions.intv.Greater x3_\n\ngoal (1 subgoal):\n 1. \\<not> Regions.isIntv (I c1) &&& \\<not> Regions.isConst (I c1)", "by auto"], ["proof (state)\nthis:\n  \\<not> Regions.isIntv (I c1)\n  \\<not> Regions.isConst (I c1)\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>i \\<noteq> 0; I c1 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' i)).\n                            d \\<le> 0 \\<and>\n                            ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Le (real_of_int d) \\<or>\n                             (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n                              else if i = 0 then f (v' 0)\n                                   else if 0 = i then Le 0\n  else h (v' 0) (v' i)) =\n                             Lt (real_of_int d))", "with A C"], ["proof (chain)\npicking this:\n  i \\<le> n\n  0 < i\n  v' i = c1\n  \\<not> Regions.isIntv (I c1)\n  \\<not> Regions.isConst (I c1)", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  v' i = c1\n  \\<not> Regions.isIntv (I c1)\n  \\<not> Regions.isConst (I c1)\n\ngoal (1 subgoal):\n 1. \\<exists>d\\<ge>- int (k (v' i)).\n       d \\<le> 0 \\<and>\n       ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int d) \\<or>\n        (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int d))", "unfolding g_def"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  v' i = c1\n  \\<not> Regions.isIntv (I c1)\n  \\<not> Regions.isConst (I c1)\n\ngoal (1 subgoal):\n 1. \\<exists>d\\<ge>- int (k (v' i)).\n       d \\<le> 0 \\<and>\n       ((if 0 = 0\n         then if i = 0 then Le 0\n              else if Regions.isIntv (I (v' i))\n                   then Lt (real_of_int (- int (intv_const (I (v' i)))))\n                   else if Regions.isConst (I (v' i))\n                        then Le (real_of_int\n                                  (- int (intv_const (I (v' i)))))\n                        else Lt (real_of_int (- int (k (v' i))))\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Le (real_of_int d) \\<or>\n        (if 0 = 0\n         then if i = 0 then Le 0\n              else if Regions.isIntv (I (v' i))\n                   then Lt (real_of_int (- int (intv_const (I (v' i)))))\n                   else if Regions.isConst (I (v' i))\n                        then Le (real_of_int\n                                  (- int (intv_const (I (v' i)))))\n                        else Lt (real_of_int (- int (k (v' i))))\n         else if i = 0 then f (v' 0)\n              else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n        Lt (real_of_int d))", "by (intro exI[where x = ?d]) auto"], ["proof (state)\nthis:\n  \\<exists>d\\<ge>- int (k (v' i)).\n     d \\<le> 0 \\<and>\n     ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n       else if i = 0 then f (v' 0)\n            else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n      Le (real_of_int d) \\<or>\n      (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n       else if i = 0 then f (v' 0)\n            else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n      Lt (real_of_int d))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d\\<ge>- int (k (v' i)).\n     d \\<le> 0 \\<and>\n     ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n       else if i = 0 then f (v' 0)\n            else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n      Le (real_of_int d) \\<or>\n      (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n       else if i = 0 then f (v' 0)\n            else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n      Lt (real_of_int d))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d\\<ge>- int (k (v' i)).\n     d \\<le> 0 \\<and>\n     ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n       else if i = 0 then f (v' 0)\n            else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n      Le (real_of_int d) \\<or>\n      (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n       else if i = 0 then f (v' 0)\n            else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n      Lt (real_of_int d))\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i3 \\<le> n; 0 < ?i3\\<rbrakk>\n  \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' ?i3)).\n                       d \\<le> 0 \\<and>\n                       ((if 0 = 0 then if ?i3 = 0 then Le 0 else g (v' ?i3)\n                         else if ?i3 = 0 then f (v' 0)\n                              else if 0 = ?i3 then Le 0\n                                   else h (v' 0) (v' ?i3)) =\n                        Le (real_of_int d) \\<or>\n                        (if 0 = 0 then if ?i3 = 0 then Le 0 else g (v' ?i3)\n                         else if ?i3 = 0 then f (v' 0)\n                              else if 0 = ?i3 then Le 0\n                                   else h (v' 0) (v' ?i3)) =\n                        Lt (real_of_int d))\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>?i3 \\<le> n; 0 < ?i3\\<rbrakk>\n  \\<Longrightarrow> \\<exists>d\\<ge>- int (k (v' ?i3)).\n                       d \\<le> 0 \\<and>\n                       ((if 0 = 0 then if ?i3 = 0 then Le 0 else g (v' ?i3)\n                         else if ?i3 = 0 then f (v' 0)\n                              else if 0 = ?i3 then Le 0\n                                   else h (v' 0) (v' ?i3)) =\n                        Le (real_of_int d) \\<or>\n                        (if 0 = 0 then if ?i3 = 0 then Le 0 else g (v' ?i3)\n                         else if ?i3 = 0 then f (v' 0)\n                              else if 0 = ?i3 then Le 0\n                                   else h (v' 0) (v' ?i3)) =\n                        Lt (real_of_int d))\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<forall> i. \\<forall> j. ?M i j \\<noteq> \\<infinity> \\<longrightarrow> get_const (?M i j) \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) \\<noteq>\n       \\<infinity> \\<longrightarrow>\n       get_const\n        (if i = 0 then if j = 0 then Le 0 else g (v' j)\n         else if j = 0 then f (v' i)\n              else if i = j then Le 0 else h (v' i) (v' j))\n       \\<in> \\<int>", "unfolding f_def g_def h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       (if i = 0\n        then if j = 0 then Le 0\n             else if Regions.isIntv (I (v' j))\n                  then Lt (real_of_int (- int (intv_const (I (v' j)))))\n                  else if Regions.isConst (I (v' j))\n                       then Le (real_of_int (- int (intv_const (I (v' j)))))\n                       else Lt (real_of_int (- int (k (v' j))))\n        else if j = 0\n             then if Regions.isIntv (I (v' i))\n                  then Lt (real (intv_const (I (v' i)) + 1))\n                  else if Regions.isConst (I (v' i))\n                       then Le (real (intv_const (I (v' i))))\n                       else \\<infinity>\n             else if i = j then Le 0\n                  else if Regions.isIntv (I (v' i)) \\<and>\n                          Regions.isIntv (I (v' j))\n                       then if (v' j, v' i) \\<in> r \\<and>\n                               (v' i, v' j) \\<notin> r\n                            then Lt (real_of_int\n(int (intv_const (I (v' i))) - int (intv_const (I (v' j))) + 1))\n                            else if (v' i, v' j) \\<in> r \\<and>\n                                    (v' j, v' i) \\<notin> r\n                                 then Lt\n (real_of_int (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                                 else Le\n (real_of_int (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                       else if Regions.isConst (I (v' i)) \\<and>\n                               Regions.isConst (I (v' j))\n                            then Le (real_of_int\n(int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                            else if Regions.isIntv (I (v' i)) \\<and>\n                                    Regions.isConst (I (v' j))\n                                 then Lt\n (real_of_int\n   (int (intv_const (I (v' i))) + 1 - int (intv_const (I (v' j)))))\n                                 else if Regions.isConst (I (v' i)) \\<and>\n   Regions.isIntv (I (v' j))\nthen Lt (real_of_int\n          (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\nelse \\<infinity>) \\<noteq>\n       \\<infinity> \\<longrightarrow>\n       get_const\n        (if i = 0\n         then if j = 0 then Le 0\n              else if Regions.isIntv (I (v' j))\n                   then Lt (real_of_int (- int (intv_const (I (v' j)))))\n                   else if Regions.isConst (I (v' j))\n                        then Le (real_of_int\n                                  (- int (intv_const (I (v' j)))))\n                        else Lt (real_of_int (- int (k (v' j))))\n         else if j = 0\n              then if Regions.isIntv (I (v' i))\n                   then Lt (real (intv_const (I (v' i)) + 1))\n                   else if Regions.isConst (I (v' i))\n                        then Le (real (intv_const (I (v' i))))\n                        else \\<infinity>\n              else if i = j then Le 0\n                   else if Regions.isIntv (I (v' i)) \\<and>\n                           Regions.isIntv (I (v' j))\n                        then if (v' j, v' i) \\<in> r \\<and>\n                                (v' i, v' j) \\<notin> r\n                             then Lt (real_of_int\n (int (intv_const (I (v' i))) - int (intv_const (I (v' j))) + 1))\n                             else if (v' i, v' j) \\<in> r \\<and>\n                                     (v' j, v' i) \\<notin> r\n                                  then Lt\n  (real_of_int (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                                  else Le\n  (real_of_int (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                        else if Regions.isConst (I (v' i)) \\<and>\n                                Regions.isConst (I (v' j))\n                             then Le (real_of_int\n (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n                             else if Regions.isIntv (I (v' i)) \\<and>\n                                     Regions.isConst (I (v' j))\n                                  then Lt\n  (real_of_int\n    (int (intv_const (I (v' i))) + 1 - int (intv_const (I (v' j)))))\n                                  else if Regions.isConst (I (v' i)) \\<and>\n    Regions.isIntv (I (v' j))\n then Lt (real_of_int\n           (int (intv_const (I (v' i))) - int (intv_const (I (v' j)))))\n else \\<infinity>)\n       \\<in> \\<int>", "by auto"], ["proof (state)\nthis:\n  \\<forall>i j.\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) \\<noteq>\n     \\<infinity> \\<longrightarrow>\n     get_const\n      (if i = 0 then if j = 0 then Le 0 else g (v' j)\n       else if j = 0 then f (v' i)\n            else if i = j then Le 0 else h (v' i) (v' j))\n     \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  \\<forall>i j.\n     (if i = 0 then if j = 0 then Le 0 else g (v' j)\n      else if j = 0 then f (v' i)\n           else if i = j then Le 0 else h (v' i) (v' j)) \\<noteq>\n     \\<infinity> \\<longrightarrow>\n     get_const\n      (if i = 0 then if j = 0 then Le 0 else g (v' j)\n       else if j = 0 then f (v' i)\n            else if i = j then Le 0 else h (v' i) (v' j))\n     \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<forall> i \\<le> n. \\<forall> j \\<le> n. i > 0 \\<and> j > 0 \\<and> ?M i j \\<noteq> \\<infinity>\n    \\<longrightarrow> (\\<exists> d:: int. (?M i j = Le d \\<or> ?M i j = Lt d) \\<and> (- k (v' j)) \\<le> d \\<and> d \\<le> k (v' i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>n.\n       \\<forall>j\\<le>n.\n          0 < i \\<and>\n          0 < j \\<and>\n          (if i = 0 then if j = 0 then Le 0 else g (v' j)\n           else if j = 0 then f (v' i)\n                else if i = j then Le 0 else h (v' i) (v' j)) \\<noteq>\n          \\<infinity> \\<longrightarrow>\n          (\\<exists>d.\n              ((if i = 0 then if j = 0 then Le 0 else g (v' j)\n                else if j = 0 then f (v' i)\n                     else if i = j then Le 0 else h (v' i) (v' j)) =\n               Le (real_of_int d) \\<or>\n               (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                else if j = 0 then f (v' i)\n                     else if i = j then Le 0 else h (v' i) (v' j)) =\n               Lt (real_of_int d)) \\<and>\n              - int (k (v' j)) \\<le> d \\<and> d \\<le> int (k (v' i)))", "proof (auto, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i \\<le> n; 0 < i; i \\<noteq> j; 0 < j; j \\<le> n;\n        h (v' i) (v' j) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h (v' i) (v' j) = Le (real_of_int d) \\<or>\n                             h (v' i) (v' j) = Lt (real_of_int d)) \\<and>\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i))", "case A: (1 i j)"], ["proof (state)\nthis:\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  j \\<le> n\n  h (v' i) (v' j) \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i \\<le> n; 0 < i; i \\<noteq> j; 0 < j; j \\<le> n;\n        h (v' i) (v' j) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h (v' i) (v' j) = Le (real_of_int d) \\<or>\n                             h (v' i) (v' j) = Lt (real_of_int d)) \\<and>\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i))", "with clock_numbering(2)"], ["proof (chain)\npicking this:\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  j \\<le> n\n  h (v' i) (v' j) \\<noteq> \\<infinity>", "obtain c1 c2 where B: \"v c1 = i\" \"c1 \\<in> X\" \"v c2 = j\" \"c2 \\<in> X\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  j \\<le> n\n  h (v' i) (v' j) \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        \\<lbrakk>v c1 = i; c1 \\<in> X; v c2 = j; c2 \\<in> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by meson"], ["proof (state)\nthis:\n  v c1 = i\n  c1 \\<in> X\n  v c2 = j\n  c2 \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i \\<le> n; 0 < i; i \\<noteq> j; 0 < j; j \\<le> n;\n        h (v' i) (v' j) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h (v' i) (v' j) = Le (real_of_int d) \\<or>\n                             h (v' i) (v' j) = Lt (real_of_int d)) \\<and>\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i))", "with clock_numbering(1) A"], ["proof (chain)\npicking this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  j \\<le> n\n  h (v' i) (v' j) \\<noteq> \\<infinity>\n  v c1 = i\n  c1 \\<in> X\n  v c2 = j\n  c2 \\<in> X", "have C: \"v' i = c1\" \"v' j = c2\""], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  j \\<le> n\n  h (v' i) (v' j) \\<noteq> \\<infinity>\n  v c1 = i\n  c1 \\<in> X\n  v c2 = j\n  c2 \\<in> X\n\ngoal (1 subgoal):\n 1. v' i = c1 &&& v' j = c2", "unfolding v'_def"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  j \\<le> n\n  h (THE c. c \\<in> X \\<and> v c = i)\n   (THE c. c \\<in> X \\<and> v c = j) \\<noteq>\n  \\<infinity>\n  v c1 = i\n  c1 \\<in> X\n  v c2 = j\n  c2 \\<in> X\n\ngoal (1 subgoal):\n 1. (THE c. c \\<in> X \\<and> v c = i) = c1 &&&\n    (THE c. c \\<in> X \\<and> v c = j) = c2", "by force+"], ["proof (state)\nthis:\n  v' i = c1\n  v' j = c2\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i \\<le> n; 0 < i; i \\<noteq> j; 0 < j; j \\<le> n;\n        h (v' i) (v' j) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h (v' i) (v' j) = Le (real_of_int d) \\<or>\n                             h (v' i) (v' j) = Lt (real_of_int d)) \\<and>\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i))", "from R(2) B"], ["proof (chain)\npicking this:\n  Regions.valid_region X k I r\n  v c1 = i\n  c1 \\<in> X\n  v c2 = j\n  c2 \\<in> X", "have valid: \"valid_intv (k c1) (I c1)\" \"valid_intv (k c2) (I c2)\""], ["proof (prove)\nusing this:\n  Regions.valid_region X k I r\n  v c1 = i\n  c1 \\<in> X\n  v c2 = j\n  c2 \\<in> X\n\ngoal (1 subgoal):\n 1. Regions.valid_intv (k c1) (I c1) &&& Regions.valid_intv (k c2) (I c2)", "by auto"], ["proof (state)\nthis:\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i \\<le> n; 0 < i; i \\<noteq> j; 0 < j; j \\<le> n;\n        h (v' i) (v' j) \\<noteq> \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h (v' i) (v' j) = Le (real_of_int d) \\<or>\n                             h (v' i) (v' j) = Lt (real_of_int d)) \\<and>\n                            - int (k (v' j)) \\<le> d \\<and>\n                            d \\<le> int (k (v' i))", "with A B C"], ["proof (chain)\npicking this:\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  j \\<le> n\n  h (v' i) (v' j) \\<noteq> \\<infinity>\n  v c1 = i\n  c1 \\<in> X\n  v c2 = j\n  c2 \\<in> X\n  v' i = c1\n  v' j = c2\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)", "show ?case"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  j \\<le> n\n  h (v' i) (v' j) \\<noteq> \\<infinity>\n  v c1 = i\n  c1 \\<in> X\n  v c2 = j\n  c2 \\<in> X\n  v' i = c1\n  v' j = c2\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       (h (v' i) (v' j) = Le (real_of_int d) \\<or>\n        h (v' i) (v' j) = Lt (real_of_int d)) \\<and>\n       - int (k (v' j)) \\<le> d \\<and> d \\<le> int (k (v' i))", "proof (simp, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> n; 0 < i; i \\<noteq> j; 0 < j; j \\<le> n;\n     h c1 c2 \\<noteq> \\<infinity>; v c1 = i; c1 \\<in> X; v c2 = j;\n     c2 \\<in> X; v' i = c1; v' j = c2; Regions.valid_intv (k c1) (I c1);\n     Regions.valid_intv (k c2) (I c2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         (h c1 c2 = Le (real_of_int d) \\<or>\n                          h c1 c2 = Lt (real_of_int d)) \\<and>\n                         - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "case 1"], ["proof (state)\nthis:\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  j \\<le> n\n  h c1 c2 \\<noteq> \\<infinity>\n  v c1 = i\n  c1 \\<in> X\n  v c2 = j\n  c2 \\<in> X\n  v' i = c1\n  v' j = c2\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<le> n; 0 < i; i \\<noteq> j; 0 < j; j \\<le> n;\n     h c1 c2 \\<noteq> \\<infinity>; v c1 = i; c1 \\<in> X; v c2 = j;\n     c2 \\<in> X; v' i = c1; v' j = c2; Regions.valid_intv (k c1) (I c1);\n     Regions.valid_intv (k c2) (I c2)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         (h c1 c2 = Le (real_of_int d) \\<or>\n                          h c1 c2 = Lt (real_of_int d)) \\<and>\n                         - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "proof (cases \"I c1\", goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       I c1 = Regions.intv.Const x1 \\<Longrightarrow>\n       \\<exists>d.\n          (h c1 c2 = Le (real_of_int d) \\<or>\n           h c1 c2 = Lt (real_of_int d)) \\<and>\n          - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. \\<And>x2.\n       I c1 = Regions.intv.Intv x2 \\<Longrightarrow>\n       \\<exists>d.\n          (h c1 c2 = Le (real_of_int d) \\<or>\n           h c1 c2 = Lt (real_of_int d)) \\<and>\n          - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 3. \\<And>x3.\n       I c1 = Regions.intv.Greater x3 \\<Longrightarrow>\n       \\<exists>d.\n          (h c1 c2 = Le (real_of_int d) \\<or>\n           h c1 c2 = Lt (real_of_int d)) \\<and>\n          - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "case 1"], ["proof (state)\nthis:\n  I c1 = Regions.intv.Const x1_\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       I c1 = Regions.intv.Const x1 \\<Longrightarrow>\n       \\<exists>d.\n          (h c1 c2 = Le (real_of_int d) \\<or>\n           h c1 c2 = Lt (real_of_int d)) \\<and>\n          - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. \\<And>x2.\n       I c1 = Regions.intv.Intv x2 \\<Longrightarrow>\n       \\<exists>d.\n          (h c1 c2 = Le (real_of_int d) \\<or>\n           h c1 c2 = Lt (real_of_int d)) \\<and>\n          - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 3. \\<And>x3.\n       I c1 = Regions.intv.Greater x3 \\<Longrightarrow>\n       \\<exists>d.\n          (h c1 c2 = Le (real_of_int d) \\<or>\n           h c1 c2 = Lt (real_of_int d)) \\<and>\n          - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "then"], ["proof (chain)\npicking this:\n  I c1 = Regions.intv.Const x1_", "show ?case"], ["proof (prove)\nusing this:\n  I c1 = Regions.intv.Const x1_\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "proof (cases \"I c2\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1a.\n       \\<lbrakk>I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Const x1a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. \\<And>x2.\n       \\<lbrakk>I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 3. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "case Const"], ["proof (state)\nthis:\n  I c2 = Regions.intv.Const x1_\n\ngoal (3 subgoals):\n 1. \\<And>x1a.\n       \\<lbrakk>I c1 = Regions.intv.Const x1___;\n        I c2 = Regions.intv.Const x1a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. \\<And>x2.\n       \\<lbrakk>I c1 = Regions.intv.Const x1___;\n        I c2 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 3. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Const x1___;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "let ?d = \"int (intv_const (I c1)) - int (intv_const (I c2))\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1a.\n       \\<lbrakk>I c1 = Regions.intv.Const x1___;\n        I c2 = Regions.intv.Const x1a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. \\<And>x2.\n       \\<lbrakk>I c1 = Regions.intv.Const x1___;\n        I c2 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 3. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Const x1___;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "from Const 1"], ["proof (chain)\npicking this:\n  I c2 = Regions.intv.Const x1_\n  I c1 = Regions.intv.Const x1___", "have \"isConst (I c1)\" \"isConst (I c2)\""], ["proof (prove)\nusing this:\n  I c2 = Regions.intv.Const x1_\n  I c1 = Regions.intv.Const x1___\n\ngoal (1 subgoal):\n 1. Regions.isConst (I c1) &&& Regions.isConst (I c2)", "by auto"], ["proof (state)\nthis:\n  Regions.isConst (I c1)\n  Regions.isConst (I c2)\n\ngoal (3 subgoals):\n 1. \\<And>x1a.\n       \\<lbrakk>I c1 = Regions.intv.Const x1___;\n        I c2 = Regions.intv.Const x1a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. \\<And>x2.\n       \\<lbrakk>I c1 = Regions.intv.Const x1___;\n        I c2 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 3. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Const x1___;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "with A(1-4) C valid"], ["proof (chain)\npicking this:\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  v' i = c1\n  v' j = c2\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n  Regions.isConst (I c1)\n  Regions.isConst (I c2)", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  v' i = c1\n  v' j = c2\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n  Regions.isConst (I c1)\n  Regions.isConst (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "unfolding h_def"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  v' i = c1\n  v' j = c2\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n  Regions.isConst (I c1)\n  Regions.isConst (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       ((if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n         then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                         1))\n              else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else Le (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n         else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n              then Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) + 1 -\n                              int (intv_const (I c2))))\n                   else if Regions.isConst (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then Lt (real_of_int\n                                  (int (intv_const (I c1)) -\n                                   int (intv_const (I c2))))\n                        else \\<infinity>) =\n        Le (real_of_int d) \\<or>\n        (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n         then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                         1))\n              else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else Le (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n         else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n              then Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) + 1 -\n                              int (intv_const (I c2))))\n                   else if Regions.isConst (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then Lt (real_of_int\n                                  (int (intv_const (I c1)) -\n                                   int (intv_const (I c2))))\n                        else \\<infinity>) =\n        Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "by (intro exI[where x = ?d]) auto"], ["proof (state)\nthis:\n  \\<exists>d.\n     (h c1 c2 = Le (real_of_int d) \\<or>\n      h c1 c2 = Lt (real_of_int d)) \\<and>\n     - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>I c1 = Regions.intv.Const x1___;\n        I c2 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Const x1___;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "case Intv"], ["proof (state)\nthis:\n  I c2 = Regions.intv.Intv x2_\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "let ?d = \"int(intv_const (I c1)) - int (intv_const (I c2))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "from Intv 1"], ["proof (chain)\npicking this:\n  I c2 = Regions.intv.Intv x2_\n  I c1 = Regions.intv.Const x1_", "have \"isConst (I c1)\" \"isIntv (I c2)\""], ["proof (prove)\nusing this:\n  I c2 = Regions.intv.Intv x2_\n  I c1 = Regions.intv.Const x1_\n\ngoal (1 subgoal):\n 1. Regions.isConst (I c1) &&& Regions.isIntv (I c2)", "by auto"], ["proof (state)\nthis:\n  Regions.isConst (I c1)\n  Regions.isIntv (I c2)\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Intv x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "with A(1-4) C valid"], ["proof (chain)\npicking this:\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  v' i = c1\n  v' j = c2\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n  Regions.isConst (I c1)\n  Regions.isIntv (I c2)", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  v' i = c1\n  v' j = c2\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n  Regions.isConst (I c1)\n  Regions.isIntv (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "unfolding h_def"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  v' i = c1\n  v' j = c2\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n  Regions.isConst (I c1)\n  Regions.isIntv (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       ((if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n         then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                         1))\n              else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else Le (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n         else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n              then Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) + 1 -\n                              int (intv_const (I c2))))\n                   else if Regions.isConst (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then Lt (real_of_int\n                                  (int (intv_const (I c1)) -\n                                   int (intv_const (I c2))))\n                        else \\<infinity>) =\n        Le (real_of_int d) \\<or>\n        (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n         then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                         1))\n              else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else Le (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n         else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n              then Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) + 1 -\n                              int (intv_const (I c2))))\n                   else if Regions.isConst (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then Lt (real_of_int\n                                  (int (intv_const (I c1)) -\n                                   int (intv_const (I c2))))\n                        else \\<infinity>) =\n        Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "by (intro exI[where x = ?d]) auto"], ["proof (state)\nthis:\n  \\<exists>d.\n     (h c1 c2 = Le (real_of_int d) \\<or>\n      h c1 c2 = Lt (real_of_int d)) \\<and>\n     - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "case Greater"], ["proof (state)\nthis:\n  I c2 = Regions.intv.Greater x3_\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "then"], ["proof (chain)\npicking this:\n  I c2 = Regions.intv.Greater x3_", "have \"\\<not> isIntv (I c2)\" \"\\<not> isConst (I c2)\""], ["proof (prove)\nusing this:\n  I c2 = Regions.intv.Greater x3_\n\ngoal (1 subgoal):\n 1. \\<not> Regions.isIntv (I c2) &&& \\<not> Regions.isConst (I c2)", "by auto"], ["proof (state)\nthis:\n  \\<not> Regions.isIntv (I c2)\n  \\<not> Regions.isConst (I c2)\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Const x1_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "with A 1(1) C"], ["proof (chain)\npicking this:\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  j \\<le> n\n  h (v' i) (v' j) \\<noteq> \\<infinity>\n  I c1 = Regions.intv.Const x1_\n  v' i = c1\n  v' j = c2\n  \\<not> Regions.isIntv (I c2)\n  \\<not> Regions.isConst (I c2)", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  j \\<le> n\n  h (v' i) (v' j) \\<noteq> \\<infinity>\n  I c1 = Regions.intv.Const x1_\n  v' i = c1\n  v' j = c2\n  \\<not> Regions.isIntv (I c2)\n  \\<not> Regions.isConst (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "unfolding h_def"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  j \\<le> n\n  (if Regions.isIntv (I (v' i)) \\<and> Regions.isIntv (I (v' j))\n   then if (v' j, v' i) \\<in> r \\<and> (v' i, v' j) \\<notin> r\n        then Lt (real_of_int\n                  (int (intv_const (I (v' i))) -\n                   int (intv_const (I (v' j))) +\n                   1))\n        else if (v' i, v' j) \\<in> r \\<and> (v' j, v' i) \\<notin> r\n             then Lt (real_of_int\n                       (int (intv_const (I (v' i))) -\n                        int (intv_const (I (v' j)))))\n             else Le (real_of_int\n                       (int (intv_const (I (v' i))) -\n                        int (intv_const (I (v' j)))))\n   else if Regions.isConst (I (v' i)) \\<and> Regions.isConst (I (v' j))\n        then Le (real_of_int\n                  (int (intv_const (I (v' i))) -\n                   int (intv_const (I (v' j)))))\n        else if Regions.isIntv (I (v' i)) \\<and> Regions.isConst (I (v' j))\n             then Lt (real_of_int\n                       (int (intv_const (I (v' i))) + 1 -\n                        int (intv_const (I (v' j)))))\n             else if Regions.isConst (I (v' i)) \\<and>\n                     Regions.isIntv (I (v' j))\n                  then Lt (real_of_int\n                            (int (intv_const (I (v' i))) -\n                             int (intv_const (I (v' j)))))\n                  else \\<infinity>) \\<noteq>\n  \\<infinity>\n  I c1 = Regions.intv.Const x1_\n  v' i = c1\n  v' j = c2\n  \\<not> Regions.isIntv (I c2)\n  \\<not> Regions.isConst (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       ((if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n         then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                         1))\n              else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else Le (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n         else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n              then Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) + 1 -\n                              int (intv_const (I c2))))\n                   else if Regions.isConst (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then Lt (real_of_int\n                                  (int (intv_const (I c1)) -\n                                   int (intv_const (I c2))))\n                        else \\<infinity>) =\n        Le (real_of_int d) \\<or>\n        (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n         then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                         1))\n              else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else Le (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n         else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n              then Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) + 1 -\n                              int (intv_const (I c2))))\n                   else if Regions.isConst (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then Lt (real_of_int\n                                  (int (intv_const (I c1)) -\n                                   int (intv_const (I c2))))\n                        else \\<infinity>) =\n        Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "by simp"], ["proof (state)\nthis:\n  \\<exists>d.\n     (h c1 c2 = Le (real_of_int d) \\<or>\n      h c1 c2 = Lt (real_of_int d)) \\<and>\n     - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d.\n     (h c1 c2 = Le (real_of_int d) \\<or>\n      h c1 c2 = Lt (real_of_int d)) \\<and>\n     - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       I c1 = Regions.intv.Intv x2 \\<Longrightarrow>\n       \\<exists>d.\n          (h c1 c2 = Le (real_of_int d) \\<or>\n           h c1 c2 = Lt (real_of_int d)) \\<and>\n          - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. \\<And>x3.\n       I c1 = Regions.intv.Greater x3 \\<Longrightarrow>\n       \\<exists>d.\n          (h c1 c2 = Le (real_of_int d) \\<or>\n           h c1 c2 = Lt (real_of_int d)) \\<and>\n          - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       I c1 = Regions.intv.Intv x2 \\<Longrightarrow>\n       \\<exists>d.\n          (h c1 c2 = Le (real_of_int d) \\<or>\n           h c1 c2 = Lt (real_of_int d)) \\<and>\n          - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. \\<And>x3.\n       I c1 = Regions.intv.Greater x3 \\<Longrightarrow>\n       \\<exists>d.\n          (h c1 c2 = Le (real_of_int d) \\<or>\n           h c1 c2 = Lt (real_of_int d)) \\<and>\n          - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "case 2"], ["proof (state)\nthis:\n  I c1 = Regions.intv.Intv x2_\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       I c1 = Regions.intv.Intv x2 \\<Longrightarrow>\n       \\<exists>d.\n          (h c1 c2 = Le (real_of_int d) \\<or>\n           h c1 c2 = Lt (real_of_int d)) \\<and>\n          - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. \\<And>x3.\n       I c1 = Regions.intv.Greater x3 \\<Longrightarrow>\n       \\<exists>d.\n          (h c1 c2 = Le (real_of_int d) \\<or>\n           h c1 c2 = Lt (real_of_int d)) \\<and>\n          - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "then"], ["proof (chain)\npicking this:\n  I c1 = Regions.intv.Intv x2_", "show ?case"], ["proof (prove)\nusing this:\n  I c1 = Regions.intv.Intv x2_\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "proof (cases \"I c2\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Const x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. \\<And>x2a.\n       \\<lbrakk>I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Intv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 3. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "case Const"], ["proof (state)\nthis:\n  I c2 = Regions.intv.Const x1_\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Const x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. \\<And>x2a.\n       \\<lbrakk>I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Intv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 3. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "let ?d = \"int (intv_const (I c1)) + 1 - int (intv_const (I c2))\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Const x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. \\<And>x2a.\n       \\<lbrakk>I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Intv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 3. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "from Const 2"], ["proof (chain)\npicking this:\n  I c2 = Regions.intv.Const x1_\n  I c1 = Regions.intv.Intv x2_", "have \"isIntv (I c1)\" \"isConst (I c2)\""], ["proof (prove)\nusing this:\n  I c2 = Regions.intv.Const x1_\n  I c1 = Regions.intv.Intv x2_\n\ngoal (1 subgoal):\n 1. Regions.isIntv (I c1) &&& Regions.isConst (I c2)", "by auto"], ["proof (state)\nthis:\n  Regions.isIntv (I c1)\n  Regions.isConst (I c2)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Const x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. \\<And>x2a.\n       \\<lbrakk>I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Intv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 3. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "with A(1-4) C valid"], ["proof (chain)\npicking this:\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  v' i = c1\n  v' j = c2\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n  Regions.isIntv (I c1)\n  Regions.isConst (I c2)", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  v' i = c1\n  v' j = c2\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n  Regions.isIntv (I c1)\n  Regions.isConst (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "unfolding h_def"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  v' i = c1\n  v' j = c2\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n  Regions.isIntv (I c1)\n  Regions.isConst (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       ((if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n         then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                         1))\n              else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else Le (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n         else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n              then Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) + 1 -\n                              int (intv_const (I c2))))\n                   else if Regions.isConst (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then Lt (real_of_int\n                                  (int (intv_const (I c1)) -\n                                   int (intv_const (I c2))))\n                        else \\<infinity>) =\n        Le (real_of_int d) \\<or>\n        (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n         then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                         1))\n              else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else Le (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n         else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n              then Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) + 1 -\n                              int (intv_const (I c2))))\n                   else if Regions.isConst (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then Lt (real_of_int\n                                  (int (intv_const (I c1)) -\n                                   int (intv_const (I c2))))\n                        else \\<infinity>) =\n        Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "by (intro exI[where x = ?d]) auto"], ["proof (state)\nthis:\n  \\<exists>d.\n     (h c1 c2 = Le (real_of_int d) \\<or>\n      h c1 c2 = Lt (real_of_int d)) \\<and>\n     - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n\ngoal (2 subgoals):\n 1. \\<And>x2a.\n       \\<lbrakk>I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Intv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2a.\n       \\<lbrakk>I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Intv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "case Intv"], ["proof (state)\nthis:\n  I c2 = Regions.intv.Intv x2_\n\ngoal (2 subgoals):\n 1. \\<And>x2a.\n       \\<lbrakk>I c1 = Regions.intv.Intv x2___;\n        I c2 = Regions.intv.Intv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Intv x2___;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "with 2"], ["proof (chain)\npicking this:\n  I c1 = Regions.intv.Intv x2___\n  I c2 = Regions.intv.Intv x2_", "have *: \"isIntv (I c1)\" \"isIntv (I c2)\""], ["proof (prove)\nusing this:\n  I c1 = Regions.intv.Intv x2___\n  I c2 = Regions.intv.Intv x2_\n\ngoal (1 subgoal):\n 1. Regions.isIntv (I c1) &&& Regions.isIntv (I c2)", "by auto"], ["proof (state)\nthis:\n  Regions.isIntv (I c1)\n  Regions.isIntv (I c2)\n\ngoal (2 subgoals):\n 1. \\<And>x2a.\n       \\<lbrakk>I c1 = Regions.intv.Intv x2___;\n        I c2 = Regions.intv.Intv x2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Intv x2___;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "from Intv A(1-4) C"], ["proof (chain)\npicking this:\n  I c2 = Regions.intv.Intv x2_\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  v' i = c1\n  v' j = c2", "show ?thesis"], ["proof (prove)\nusing this:\n  I c2 = Regions.intv.Intv x2_\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  v' i = c1\n  v' j = c2\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "proof (cases \"(c2, c1) \\<in> r\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (c2, c1) \\<in> r \\<Longrightarrow>\n    \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. (c2, c1) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "case True"], ["proof (state)\nthis:\n  (c2, c1) \\<in> r\n\ngoal (2 subgoals):\n 1. (c2, c1) \\<in> r \\<Longrightarrow>\n    \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. (c2, c1) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "note T = this"], ["proof (state)\nthis:\n  (c2, c1) \\<in> r\n\ngoal (2 subgoals):\n 1. (c2, c1) \\<in> r \\<Longrightarrow>\n    \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. (c2, c1) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "proof (cases \"(c1, c2) \\<in> r\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (c1, c2) \\<in> r \\<Longrightarrow>\n    \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. (c1, c2) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "case True"], ["proof (state)\nthis:\n  (c1, c2) \\<in> r\n\ngoal (2 subgoals):\n 1. (c1, c2) \\<in> r \\<Longrightarrow>\n    \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. (c1, c2) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "let ?d = \"int (intv_const (I c1)) - int (intv_const (I c2))\""], ["proof (state)\ngoal (2 subgoals):\n 1. (c1, c2) \\<in> r \\<Longrightarrow>\n    \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n 2. (c1, c2) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "from True T * valid"], ["proof (chain)\npicking this:\n  (c1, c2) \\<in> r\n  (c2, c1) \\<in> r\n  Regions.isIntv (I c1)\n  Regions.isIntv (I c2)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)", "show ?thesis"], ["proof (prove)\nusing this:\n  (c1, c2) \\<in> r\n  (c2, c1) \\<in> r\n  Regions.isIntv (I c1)\n  Regions.isIntv (I c2)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "unfolding h_def"], ["proof (prove)\nusing this:\n  (c1, c2) \\<in> r\n  (c2, c1) \\<in> r\n  Regions.isIntv (I c1)\n  Regions.isIntv (I c2)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       ((if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n         then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                         1))\n              else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else Le (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n         else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n              then Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) + 1 -\n                              int (intv_const (I c2))))\n                   else if Regions.isConst (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then Lt (real_of_int\n                                  (int (intv_const (I c1)) -\n                                   int (intv_const (I c2))))\n                        else \\<infinity>) =\n        Le (real_of_int d) \\<or>\n        (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n         then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                         1))\n              else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else Le (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n         else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n              then Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) + 1 -\n                              int (intv_const (I c2))))\n                   else if Regions.isConst (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then Lt (real_of_int\n                                  (int (intv_const (I c1)) -\n                                   int (intv_const (I c2))))\n                        else \\<infinity>) =\n        Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "by (intro exI[where x = ?d]) auto"], ["proof (state)\nthis:\n  \\<exists>d.\n     (h c1 c2 = Le (real_of_int d) \\<or>\n      h c1 c2 = Lt (real_of_int d)) \\<and>\n     - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n\ngoal (1 subgoal):\n 1. (c1, c2) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (c1, c2) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "case False"], ["proof (state)\nthis:\n  (c1, c2) \\<notin> r\n\ngoal (1 subgoal):\n 1. (c1, c2) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "let ?d = \"int (intv_const (I c1)) - int (intv_const (I c2)) + 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. (c1, c2) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "from False T * valid"], ["proof (chain)\npicking this:\n  (c1, c2) \\<notin> r\n  (c2, c1) \\<in> r\n  Regions.isIntv (I c1)\n  Regions.isIntv (I c2)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)", "show ?thesis"], ["proof (prove)\nusing this:\n  (c1, c2) \\<notin> r\n  (c2, c1) \\<in> r\n  Regions.isIntv (I c1)\n  Regions.isIntv (I c2)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "unfolding h_def"], ["proof (prove)\nusing this:\n  (c1, c2) \\<notin> r\n  (c2, c1) \\<in> r\n  Regions.isIntv (I c1)\n  Regions.isIntv (I c2)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       ((if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n         then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                         1))\n              else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else Le (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n         else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n              then Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) + 1 -\n                              int (intv_const (I c2))))\n                   else if Regions.isConst (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then Lt (real_of_int\n                                  (int (intv_const (I c1)) -\n                                   int (intv_const (I c2))))\n                        else \\<infinity>) =\n        Le (real_of_int d) \\<or>\n        (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n         then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                         1))\n              else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else Le (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n         else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n              then Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) + 1 -\n                              int (intv_const (I c2))))\n                   else if Regions.isConst (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then Lt (real_of_int\n                                  (int (intv_const (I c1)) -\n                                   int (intv_const (I c2))))\n                        else \\<infinity>) =\n        Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "by (intro exI[where x = ?d]) auto"], ["proof (state)\nthis:\n  \\<exists>d.\n     (h c1 c2 = Le (real_of_int d) \\<or>\n      h c1 c2 = Lt (real_of_int d)) \\<and>\n     - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d.\n     (h c1 c2 = Le (real_of_int d) \\<or>\n      h c1 c2 = Lt (real_of_int d)) \\<and>\n     - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n\ngoal (1 subgoal):\n 1. (c2, c1) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (c2, c1) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "case False"], ["proof (state)\nthis:\n  (c2, c1) \\<notin> r\n\ngoal (1 subgoal):\n 1. (c2, c1) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "let ?d = \"int (intv_const (I c1)) - int (intv_const (I c2))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (c2, c1) \\<notin> r \\<Longrightarrow>\n    \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "from False * valid"], ["proof (chain)\npicking this:\n  (c2, c1) \\<notin> r\n  Regions.isIntv (I c1)\n  Regions.isIntv (I c2)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)", "show ?thesis"], ["proof (prove)\nusing this:\n  (c2, c1) \\<notin> r\n  Regions.isIntv (I c1)\n  Regions.isIntv (I c2)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "unfolding h_def"], ["proof (prove)\nusing this:\n  (c2, c1) \\<notin> r\n  Regions.isIntv (I c1)\n  Regions.isIntv (I c2)\n  Regions.valid_intv (k c1) (I c1)\n  Regions.valid_intv (k c2) (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       ((if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n         then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                         1))\n              else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else Le (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n         else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n              then Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) + 1 -\n                              int (intv_const (I c2))))\n                   else if Regions.isConst (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then Lt (real_of_int\n                                  (int (intv_const (I c1)) -\n                                   int (intv_const (I c2))))\n                        else \\<infinity>) =\n        Le (real_of_int d) \\<or>\n        (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n         then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                         1))\n              else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else Le (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n         else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n              then Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) + 1 -\n                              int (intv_const (I c2))))\n                   else if Regions.isConst (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then Lt (real_of_int\n                                  (int (intv_const (I c1)) -\n                                   int (intv_const (I c2))))\n                        else \\<infinity>) =\n        Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "by (intro exI[where x = ?d]) auto"], ["proof (state)\nthis:\n  \\<exists>d.\n     (h c1 c2 = Le (real_of_int d) \\<or>\n      h c1 c2 = Lt (real_of_int d)) \\<and>\n     - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d.\n     (h c1 c2 = Le (real_of_int d) \\<or>\n      h c1 c2 = Lt (real_of_int d)) \\<and>\n     - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d.\n     (h c1 c2 = Le (real_of_int d) \\<or>\n      h c1 c2 = Lt (real_of_int d)) \\<and>\n     - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Intv x2___;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "case Greater"], ["proof (state)\nthis:\n  I c2 = Regions.intv.Greater x3_\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "then"], ["proof (chain)\npicking this:\n  I c2 = Regions.intv.Greater x3_", "have \"\\<not> isIntv (I c2)\" \"\\<not> isConst (I c2)\""], ["proof (prove)\nusing this:\n  I c2 = Regions.intv.Greater x3_\n\ngoal (1 subgoal):\n 1. \\<not> Regions.isIntv (I c2) &&& \\<not> Regions.isConst (I c2)", "by auto"], ["proof (state)\nthis:\n  \\<not> Regions.isIntv (I c2)\n  \\<not> Regions.isConst (I c2)\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       \\<lbrakk>I c1 = Regions.intv.Intv x2_;\n        I c2 = Regions.intv.Greater x3\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            (h c1 c2 = Le (real_of_int d) \\<or>\n                             h c1 c2 = Lt (real_of_int d)) \\<and>\n                            - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "with A 2(1) C"], ["proof (chain)\npicking this:\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  j \\<le> n\n  h (v' i) (v' j) \\<noteq> \\<infinity>\n  I c1 = Regions.intv.Intv x2_\n  v' i = c1\n  v' j = c2\n  \\<not> Regions.isIntv (I c2)\n  \\<not> Regions.isConst (I c2)", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  j \\<le> n\n  h (v' i) (v' j) \\<noteq> \\<infinity>\n  I c1 = Regions.intv.Intv x2_\n  v' i = c1\n  v' j = c2\n  \\<not> Regions.isIntv (I c2)\n  \\<not> Regions.isConst (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "unfolding h_def"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  j \\<le> n\n  (if Regions.isIntv (I (v' i)) \\<and> Regions.isIntv (I (v' j))\n   then if (v' j, v' i) \\<in> r \\<and> (v' i, v' j) \\<notin> r\n        then Lt (real_of_int\n                  (int (intv_const (I (v' i))) -\n                   int (intv_const (I (v' j))) +\n                   1))\n        else if (v' i, v' j) \\<in> r \\<and> (v' j, v' i) \\<notin> r\n             then Lt (real_of_int\n                       (int (intv_const (I (v' i))) -\n                        int (intv_const (I (v' j)))))\n             else Le (real_of_int\n                       (int (intv_const (I (v' i))) -\n                        int (intv_const (I (v' j)))))\n   else if Regions.isConst (I (v' i)) \\<and> Regions.isConst (I (v' j))\n        then Le (real_of_int\n                  (int (intv_const (I (v' i))) -\n                   int (intv_const (I (v' j)))))\n        else if Regions.isIntv (I (v' i)) \\<and> Regions.isConst (I (v' j))\n             then Lt (real_of_int\n                       (int (intv_const (I (v' i))) + 1 -\n                        int (intv_const (I (v' j)))))\n             else if Regions.isConst (I (v' i)) \\<and>\n                     Regions.isIntv (I (v' j))\n                  then Lt (real_of_int\n                            (int (intv_const (I (v' i))) -\n                             int (intv_const (I (v' j)))))\n                  else \\<infinity>) \\<noteq>\n  \\<infinity>\n  I c1 = Regions.intv.Intv x2_\n  v' i = c1\n  v' j = c2\n  \\<not> Regions.isIntv (I c2)\n  \\<not> Regions.isConst (I c2)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       ((if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n         then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                         1))\n              else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else Le (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n         else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n              then Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) + 1 -\n                              int (intv_const (I c2))))\n                   else if Regions.isConst (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then Lt (real_of_int\n                                  (int (intv_const (I c1)) -\n                                   int (intv_const (I c2))))\n                        else \\<infinity>) =\n        Le (real_of_int d) \\<or>\n        (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n         then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                         1))\n              else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else Le (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n         else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n              then Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) + 1 -\n                              int (intv_const (I c2))))\n                   else if Regions.isConst (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then Lt (real_of_int\n                                  (int (intv_const (I c1)) -\n                                   int (intv_const (I c2))))\n                        else \\<infinity>) =\n        Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "by simp"], ["proof (state)\nthis:\n  \\<exists>d.\n     (h c1 c2 = Le (real_of_int d) \\<or>\n      h c1 c2 = Lt (real_of_int d)) \\<and>\n     - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d.\n     (h c1 c2 = Le (real_of_int d) \\<or>\n      h c1 c2 = Lt (real_of_int d)) \\<and>\n     - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       I c1 = Regions.intv.Greater x3 \\<Longrightarrow>\n       \\<exists>d.\n          (h c1 c2 = Le (real_of_int d) \\<or>\n           h c1 c2 = Lt (real_of_int d)) \\<and>\n          - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x3.\n       I c1 = Regions.intv.Greater x3 \\<Longrightarrow>\n       \\<exists>d.\n          (h c1 c2 = Le (real_of_int d) \\<or>\n           h c1 c2 = Lt (real_of_int d)) \\<and>\n          - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "case 3"], ["proof (state)\nthis:\n  I c1 = Regions.intv.Greater x3_\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       I c1 = Regions.intv.Greater x3 \\<Longrightarrow>\n       \\<exists>d.\n          (h c1 c2 = Le (real_of_int d) \\<or>\n           h c1 c2 = Lt (real_of_int d)) \\<and>\n          - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "then"], ["proof (chain)\npicking this:\n  I c1 = Regions.intv.Greater x3_", "have \"\\<not> isIntv (I c1)\" \"\\<not> isConst (I c1)\""], ["proof (prove)\nusing this:\n  I c1 = Regions.intv.Greater x3_\n\ngoal (1 subgoal):\n 1. \\<not> Regions.isIntv (I c1) &&& \\<not> Regions.isConst (I c1)", "by auto"], ["proof (state)\nthis:\n  \\<not> Regions.isIntv (I c1)\n  \\<not> Regions.isConst (I c1)\n\ngoal (1 subgoal):\n 1. \\<And>x3.\n       I c1 = Regions.intv.Greater x3 \\<Longrightarrow>\n       \\<exists>d.\n          (h c1 c2 = Le (real_of_int d) \\<or>\n           h c1 c2 = Lt (real_of_int d)) \\<and>\n          - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "with A 3(1) C"], ["proof (chain)\npicking this:\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  j \\<le> n\n  h (v' i) (v' j) \\<noteq> \\<infinity>\n  I c1 = Regions.intv.Greater x3_\n  v' i = c1\n  v' j = c2\n  \\<not> Regions.isIntv (I c1)\n  \\<not> Regions.isConst (I c1)", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  j \\<le> n\n  h (v' i) (v' j) \\<noteq> \\<infinity>\n  I c1 = Regions.intv.Greater x3_\n  v' i = c1\n  v' j = c2\n  \\<not> Regions.isIntv (I c1)\n  \\<not> Regions.isConst (I c1)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       (h c1 c2 = Le (real_of_int d) \\<or>\n        h c1 c2 = Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "unfolding h_def"], ["proof (prove)\nusing this:\n  i \\<le> n\n  0 < i\n  i \\<noteq> j\n  0 < j\n  j \\<le> n\n  (if Regions.isIntv (I (v' i)) \\<and> Regions.isIntv (I (v' j))\n   then if (v' j, v' i) \\<in> r \\<and> (v' i, v' j) \\<notin> r\n        then Lt (real_of_int\n                  (int (intv_const (I (v' i))) -\n                   int (intv_const (I (v' j))) +\n                   1))\n        else if (v' i, v' j) \\<in> r \\<and> (v' j, v' i) \\<notin> r\n             then Lt (real_of_int\n                       (int (intv_const (I (v' i))) -\n                        int (intv_const (I (v' j)))))\n             else Le (real_of_int\n                       (int (intv_const (I (v' i))) -\n                        int (intv_const (I (v' j)))))\n   else if Regions.isConst (I (v' i)) \\<and> Regions.isConst (I (v' j))\n        then Le (real_of_int\n                  (int (intv_const (I (v' i))) -\n                   int (intv_const (I (v' j)))))\n        else if Regions.isIntv (I (v' i)) \\<and> Regions.isConst (I (v' j))\n             then Lt (real_of_int\n                       (int (intv_const (I (v' i))) + 1 -\n                        int (intv_const (I (v' j)))))\n             else if Regions.isConst (I (v' i)) \\<and>\n                     Regions.isIntv (I (v' j))\n                  then Lt (real_of_int\n                            (int (intv_const (I (v' i))) -\n                             int (intv_const (I (v' j)))))\n                  else \\<infinity>) \\<noteq>\n  \\<infinity>\n  I c1 = Regions.intv.Greater x3_\n  v' i = c1\n  v' j = c2\n  \\<not> Regions.isIntv (I c1)\n  \\<not> Regions.isConst (I c1)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       ((if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n         then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                         1))\n              else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else Le (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n         else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n              then Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) + 1 -\n                              int (intv_const (I c2))))\n                   else if Regions.isConst (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then Lt (real_of_int\n                                  (int (intv_const (I c1)) -\n                                   int (intv_const (I c2))))\n                        else \\<infinity>) =\n        Le (real_of_int d) \\<or>\n        (if Regions.isIntv (I c1) \\<and> Regions.isIntv (I c2)\n         then if (c2, c1) \\<in> r \\<and> (c1, c2) \\<notin> r\n              then Lt (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2)) +\n                         1))\n              else if (c1, c2) \\<in> r \\<and> (c2, c1) \\<notin> r\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n                   else Le (real_of_int\n                             (int (intv_const (I c1)) -\n                              int (intv_const (I c2))))\n         else if Regions.isConst (I c1) \\<and> Regions.isConst (I c2)\n              then Le (real_of_int\n                        (int (intv_const (I c1)) - int (intv_const (I c2))))\n              else if Regions.isIntv (I c1) \\<and> Regions.isConst (I c2)\n                   then Lt (real_of_int\n                             (int (intv_const (I c1)) + 1 -\n                              int (intv_const (I c2))))\n                   else if Regions.isConst (I c1) \\<and>\n                           Regions.isIntv (I c2)\n                        then Lt (real_of_int\n                                  (int (intv_const (I c1)) -\n                                   int (intv_const (I c2))))\n                        else \\<infinity>) =\n        Lt (real_of_int d)) \\<and>\n       - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)", "by simp"], ["proof (state)\nthis:\n  \\<exists>d.\n     (h c1 c2 = Le (real_of_int d) \\<or>\n      h c1 c2 = Lt (real_of_int d)) \\<and>\n     - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d.\n     (h c1 c2 = Le (real_of_int d) \\<or>\n      h c1 c2 = Lt (real_of_int d)) \\<and>\n     - int (k c2) \\<le> d \\<and> d \\<le> int (k c1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d.\n     (h (v' i) (v' j) = Le (real_of_int d) \\<or>\n      h (v' i) (v' j) = Lt (real_of_int d)) \\<and>\n     - int (k (v' j)) \\<le> d \\<and> d \\<le> int (k (v' i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        0 < i \\<and>\n        0 < j \\<and>\n        (if i = 0 then if j = 0 then Le 0 else g (v' j)\n         else if j = 0 then f (v' i)\n              else if i = j then Le 0 else h (v' i) (v' j)) \\<noteq>\n        \\<infinity> \\<longrightarrow>\n        (\\<exists>d.\n            ((if i = 0 then if j = 0 then Le 0 else g (v' j)\n              else if j = 0 then f (v' i)\n                   else if i = j then Le 0 else h (v' i) (v' j)) =\n             Le (real_of_int d) \\<or>\n             (if i = 0 then if j = 0 then Le 0 else g (v' j)\n              else if j = 0 then f (v' i)\n                   else if i = j then Le 0 else h (v' i) (v' j)) =\n             Lt (real_of_int d)) \\<and>\n            - int (k (v' j)) \\<le> d \\<and> d \\<le> int (k (v' i)))\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        0 < i \\<and>\n        0 < j \\<and>\n        (if i = 0 then if j = 0 then Le 0 else g (v' j)\n         else if j = 0 then f (v' i)\n              else if i = j then Le 0 else h (v' i) (v' j)) \\<noteq>\n        \\<infinity> \\<longrightarrow>\n        (\\<exists>d.\n            ((if i = 0 then if j = 0 then Le 0 else g (v' j)\n              else if j = 0 then f (v' i)\n                   else if i = j then Le 0 else h (v' i) (v' j)) =\n             Le (real_of_int d) \\<or>\n             (if i = 0 then if j = 0 then Le 0 else g (v' j)\n              else if j = 0 then f (v' i)\n                   else if i = j then Le 0 else h (v' i) (v' j)) =\n             Lt (real_of_int d)) \\<and>\n            - int (k (v' j)) \\<le> d \\<and> d \\<le> int (k (v' i)))\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n         \\<forall>i\\<le>n. M i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M i 0 \\<noteq> \\<infinity> \\<and>\n               M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Le (real_of_int d) \\<and>\n                   M j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (v' j)) \\<le> d - 1 \\<and>\n                   d \\<le> int (k (v' i)) \\<and>\n                   M i j = Lt (real_of_int d) \\<and>\n                   M j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (v' i)).\n                0 \\<le> d \\<and>\n                (M i 0 = Le (real_of_int d) \\<and>\n                 M 0 i = Le (real_of_int (- d)) \\<or>\n                 M i 0 = Lt (real_of_int d) \\<and>\n                 M 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (v' i)).\n                d \\<le> 0 \\<and>\n                (M 0 i = Le (real_of_int d) \\<or>\n                 M 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M i j = Le (real_of_int d) \\<or>\n                    M i j = Lt (real_of_int d)) \\<and>\n                   - int (k (v' j)) \\<le> d \\<and>\n                   d \\<le> int (k (v' i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "apply (rule that)"], ["proof (prove)\ngoal (8 subgoals):\n 1. [?M1]\\<^bsub>v,n\\<^esub> = R\n 2. \\<forall>i\\<le>n.\n       \\<forall>j\\<le>n.\n          ?M1 i 0 = \\<infinity> \\<and>\n          0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n          ?M1 i j = \\<infinity> \\<and> ?M1 j i = \\<infinity>\n 3. \\<forall>i\\<le>n. ?M1 i i = Le 0\n 4. \\<forall>i\\<le>n.\n       \\<forall>j\\<le>n.\n          0 < i \\<and>\n          0 < j \\<and>\n          ?M1 i 0 \\<noteq> \\<infinity> \\<and>\n          ?M1 j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n          (\\<exists>d.\n              - int (k (v' j)) \\<le> d \\<and>\n              d \\<le> int (k (v' i)) \\<and>\n              ?M1 i j = Le (real_of_int d) \\<and>\n              ?M1 j i = Le (real_of_int (- d)) \\<or>\n              - int (k (v' j)) \\<le> d - 1 \\<and>\n              d \\<le> int (k (v' i)) \\<and>\n              ?M1 i j = Lt (real_of_int d) \\<and>\n              ?M1 j i = Lt (real_of_int (- d + 1)))\n 5. \\<forall>i\\<le>n.\n       0 < i \\<and> ?M1 i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n       (\\<exists>d\\<le>int (k (v' i)).\n           0 \\<le> d \\<and>\n           (?M1 i 0 = Le (real_of_int d) \\<and>\n            ?M1 0 i = Le (real_of_int (- d)) \\<or>\n            ?M1 i 0 = Lt (real_of_int d) \\<and>\n            ?M1 0 i = Lt (real_of_int (- d + 1))))\n 6. \\<forall>i\\<le>n.\n       0 < i \\<longrightarrow>\n       (\\<exists>d\\<ge>- int (k (v' i)).\n           d \\<le> 0 \\<and>\n           (?M1 0 i = Le (real_of_int d) \\<or>\n            ?M1 0 i = Lt (real_of_int d)))\n 7. \\<forall>i j.\n       ?M1 i j \\<noteq> \\<infinity> \\<longrightarrow>\n       get_const (?M1 i j) \\<in> \\<int>\n 8. \\<forall>i\\<le>n.\n       \\<forall>j\\<le>n.\n          ?M1 i j \\<noteq> \\<infinity> \\<and>\n          0 < i \\<and> 0 < j \\<longrightarrow>\n          (\\<exists>d.\n              (?M1 i j = Le (real_of_int d) \\<or>\n               ?M1 i j = Lt (real_of_int d)) \\<and>\n              - int (k (v' j)) \\<le> d \\<and> d \\<le> int (k (v' i)))", "apply (rule calculation(1))"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<forall>i\\<le>n.\n       \\<forall>j\\<le>n.\n          (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n           else if 0 = 0 then f (v' i)\n                else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n          \\<infinity> \\<and>\n          0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n          (if i = 0 then if j = 0 then Le 0 else g (v' j)\n           else if j = 0 then f (v' i)\n                else if i = j then Le 0 else h (v' i) (v' j)) =\n          \\<infinity> \\<and>\n          (if j = 0 then if i = 0 then Le 0 else g (v' i)\n           else if i = 0 then f (v' j)\n                else if j = i then Le 0 else h (v' j) (v' i)) =\n          \\<infinity>\n 2. \\<forall>i\\<le>n.\n       (if i = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' i)\n             else if i = i then Le 0 else h (v' i) (v' i)) =\n       Le 0\n 3. \\<forall>i\\<le>n.\n       \\<forall>j\\<le>n.\n          0 < i \\<and>\n          0 < j \\<and>\n          (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n           else if 0 = 0 then f (v' i)\n                else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n          \\<infinity> \\<and>\n          (if j = 0 then if 0 = 0 then Le 0 else g (v' 0)\n           else if 0 = 0 then f (v' j)\n                else if j = 0 then Le 0 else h (v' j) (v' 0)) \\<noteq>\n          \\<infinity> \\<longrightarrow>\n          (\\<exists>d.\n              - int (k (v' j)) \\<le> d \\<and>\n              d \\<le> int (k (v' i)) \\<and>\n              (if i = 0 then if j = 0 then Le 0 else g (v' j)\n               else if j = 0 then f (v' i)\n                    else if i = j then Le 0 else h (v' i) (v' j)) =\n              Le (real_of_int d) \\<and>\n              (if j = 0 then if i = 0 then Le 0 else g (v' i)\n               else if i = 0 then f (v' j)\n                    else if j = i then Le 0 else h (v' j) (v' i)) =\n              Le (real_of_int (- d)) \\<or>\n              - int (k (v' j)) \\<le> d - 1 \\<and>\n              d \\<le> int (k (v' i)) \\<and>\n              (if i = 0 then if j = 0 then Le 0 else g (v' j)\n               else if j = 0 then f (v' i)\n                    else if i = j then Le 0 else h (v' i) (v' j)) =\n              Lt (real_of_int d) \\<and>\n              (if j = 0 then if i = 0 then Le 0 else g (v' i)\n               else if i = 0 then f (v' j)\n                    else if j = i then Le 0 else h (v' j) (v' i)) =\n              Lt (real_of_int (- d + 1)))\n 4. \\<forall>i\\<le>n.\n       0 < i \\<and>\n       (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n        else if 0 = 0 then f (v' i)\n             else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n       \\<infinity> \\<longrightarrow>\n       (\\<exists>d\\<le>int (k (v' i)).\n           0 \\<le> d \\<and>\n           ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n             else if 0 = 0 then f (v' i)\n                  else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n            Le (real_of_int d) \\<and>\n            (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n             else if i = 0 then f (v' 0)\n                  else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n            Le (real_of_int (- d)) \\<or>\n            (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n             else if 0 = 0 then f (v' i)\n                  else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n            Lt (real_of_int d) \\<and>\n            (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n             else if i = 0 then f (v' 0)\n                  else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n            Lt (real_of_int (- d + 1))))\n 5. \\<forall>i\\<le>n.\n       0 < i \\<longrightarrow>\n       (\\<exists>d\\<ge>- int (k (v' i)).\n           d \\<le> 0 \\<and>\n           ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n             else if i = 0 then f (v' 0)\n                  else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n            Le (real_of_int d) \\<or>\n            (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n             else if i = 0 then f (v' 0)\n                  else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n            Lt (real_of_int d)))\n 6. \\<forall>i j.\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) \\<noteq>\n       \\<infinity> \\<longrightarrow>\n       get_const\n        (if i = 0 then if j = 0 then Le 0 else g (v' j)\n         else if j = 0 then f (v' i)\n              else if i = j then Le 0 else h (v' i) (v' j))\n       \\<in> \\<int>\n 7. \\<forall>i\\<le>n.\n       \\<forall>j\\<le>n.\n          (if i = 0 then if j = 0 then Le 0 else g (v' j)\n           else if j = 0 then f (v' i)\n                else if i = j then Le 0 else h (v' i) (v' j)) \\<noteq>\n          \\<infinity> \\<and>\n          0 < i \\<and> 0 < j \\<longrightarrow>\n          (\\<exists>d.\n              ((if i = 0 then if j = 0 then Le 0 else g (v' j)\n                else if j = 0 then f (v' i)\n                     else if i = j then Le 0 else h (v' i) (v' j)) =\n               Le (real_of_int d) \\<or>\n               (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                else if j = 0 then f (v' i)\n                     else if i = j then Le 0 else h (v' i) (v' j)) =\n               Lt (real_of_int d)) \\<and>\n              - int (k (v' j)) \\<le> d \\<and> d \\<le> int (k (v' i)))", "apply (rule calculation(2))"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<forall>i\\<le>n.\n       (if i = 0 then if i = 0 then Le 0 else g (v' i)\n        else if i = 0 then f (v' i)\n             else if i = i then Le 0 else h (v' i) (v' i)) =\n       Le 0\n 2. \\<forall>i\\<le>n.\n       \\<forall>j\\<le>n.\n          0 < i \\<and>\n          0 < j \\<and>\n          (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n           else if 0 = 0 then f (v' i)\n                else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n          \\<infinity> \\<and>\n          (if j = 0 then if 0 = 0 then Le 0 else g (v' 0)\n           else if 0 = 0 then f (v' j)\n                else if j = 0 then Le 0 else h (v' j) (v' 0)) \\<noteq>\n          \\<infinity> \\<longrightarrow>\n          (\\<exists>d.\n              - int (k (v' j)) \\<le> d \\<and>\n              d \\<le> int (k (v' i)) \\<and>\n              (if i = 0 then if j = 0 then Le 0 else g (v' j)\n               else if j = 0 then f (v' i)\n                    else if i = j then Le 0 else h (v' i) (v' j)) =\n              Le (real_of_int d) \\<and>\n              (if j = 0 then if i = 0 then Le 0 else g (v' i)\n               else if i = 0 then f (v' j)\n                    else if j = i then Le 0 else h (v' j) (v' i)) =\n              Le (real_of_int (- d)) \\<or>\n              - int (k (v' j)) \\<le> d - 1 \\<and>\n              d \\<le> int (k (v' i)) \\<and>\n              (if i = 0 then if j = 0 then Le 0 else g (v' j)\n               else if j = 0 then f (v' i)\n                    else if i = j then Le 0 else h (v' i) (v' j)) =\n              Lt (real_of_int d) \\<and>\n              (if j = 0 then if i = 0 then Le 0 else g (v' i)\n               else if i = 0 then f (v' j)\n                    else if j = i then Le 0 else h (v' j) (v' i)) =\n              Lt (real_of_int (- d + 1)))\n 3. \\<forall>i\\<le>n.\n       0 < i \\<and>\n       (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n        else if 0 = 0 then f (v' i)\n             else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n       \\<infinity> \\<longrightarrow>\n       (\\<exists>d\\<le>int (k (v' i)).\n           0 \\<le> d \\<and>\n           ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n             else if 0 = 0 then f (v' i)\n                  else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n            Le (real_of_int d) \\<and>\n            (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n             else if i = 0 then f (v' 0)\n                  else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n            Le (real_of_int (- d)) \\<or>\n            (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n             else if 0 = 0 then f (v' i)\n                  else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n            Lt (real_of_int d) \\<and>\n            (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n             else if i = 0 then f (v' 0)\n                  else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n            Lt (real_of_int (- d + 1))))\n 4. \\<forall>i\\<le>n.\n       0 < i \\<longrightarrow>\n       (\\<exists>d\\<ge>- int (k (v' i)).\n           d \\<le> 0 \\<and>\n           ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n             else if i = 0 then f (v' 0)\n                  else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n            Le (real_of_int d) \\<or>\n            (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n             else if i = 0 then f (v' 0)\n                  else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n            Lt (real_of_int d)))\n 5. \\<forall>i j.\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) \\<noteq>\n       \\<infinity> \\<longrightarrow>\n       get_const\n        (if i = 0 then if j = 0 then Le 0 else g (v' j)\n         else if j = 0 then f (v' i)\n              else if i = j then Le 0 else h (v' i) (v' j))\n       \\<in> \\<int>\n 6. \\<forall>i\\<le>n.\n       \\<forall>j\\<le>n.\n          (if i = 0 then if j = 0 then Le 0 else g (v' j)\n           else if j = 0 then f (v' i)\n                else if i = j then Le 0 else h (v' i) (v' j)) \\<noteq>\n          \\<infinity> \\<and>\n          0 < i \\<and> 0 < j \\<longrightarrow>\n          (\\<exists>d.\n              ((if i = 0 then if j = 0 then Le 0 else g (v' j)\n                else if j = 0 then f (v' i)\n                     else if i = j then Le 0 else h (v' i) (v' j)) =\n               Le (real_of_int d) \\<or>\n               (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                else if j = 0 then f (v' i)\n                     else if i = j then Le 0 else h (v' i) (v' j)) =\n               Lt (real_of_int d)) \\<and>\n              - int (k (v' j)) \\<le> d \\<and> d \\<le> int (k (v' i)))", "apply (rule calculation(3))"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<forall>i\\<le>n.\n       \\<forall>j\\<le>n.\n          0 < i \\<and>\n          0 < j \\<and>\n          (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n           else if 0 = 0 then f (v' i)\n                else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n          \\<infinity> \\<and>\n          (if j = 0 then if 0 = 0 then Le 0 else g (v' 0)\n           else if 0 = 0 then f (v' j)\n                else if j = 0 then Le 0 else h (v' j) (v' 0)) \\<noteq>\n          \\<infinity> \\<longrightarrow>\n          (\\<exists>d.\n              - int (k (v' j)) \\<le> d \\<and>\n              d \\<le> int (k (v' i)) \\<and>\n              (if i = 0 then if j = 0 then Le 0 else g (v' j)\n               else if j = 0 then f (v' i)\n                    else if i = j then Le 0 else h (v' i) (v' j)) =\n              Le (real_of_int d) \\<and>\n              (if j = 0 then if i = 0 then Le 0 else g (v' i)\n               else if i = 0 then f (v' j)\n                    else if j = i then Le 0 else h (v' j) (v' i)) =\n              Le (real_of_int (- d)) \\<or>\n              - int (k (v' j)) \\<le> d - 1 \\<and>\n              d \\<le> int (k (v' i)) \\<and>\n              (if i = 0 then if j = 0 then Le 0 else g (v' j)\n               else if j = 0 then f (v' i)\n                    else if i = j then Le 0 else h (v' i) (v' j)) =\n              Lt (real_of_int d) \\<and>\n              (if j = 0 then if i = 0 then Le 0 else g (v' i)\n               else if i = 0 then f (v' j)\n                    else if j = i then Le 0 else h (v' j) (v' i)) =\n              Lt (real_of_int (- d + 1)))\n 2. \\<forall>i\\<le>n.\n       0 < i \\<and>\n       (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n        else if 0 = 0 then f (v' i)\n             else if i = 0 then Le 0 else h (v' i) (v' 0)) \\<noteq>\n       \\<infinity> \\<longrightarrow>\n       (\\<exists>d\\<le>int (k (v' i)).\n           0 \\<le> d \\<and>\n           ((if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n             else if 0 = 0 then f (v' i)\n                  else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n            Le (real_of_int d) \\<and>\n            (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n             else if i = 0 then f (v' 0)\n                  else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n            Le (real_of_int (- d)) \\<or>\n            (if i = 0 then if 0 = 0 then Le 0 else g (v' 0)\n             else if 0 = 0 then f (v' i)\n                  else if i = 0 then Le 0 else h (v' i) (v' 0)) =\n            Lt (real_of_int d) \\<and>\n            (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n             else if i = 0 then f (v' 0)\n                  else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n            Lt (real_of_int (- d + 1))))\n 3. \\<forall>i\\<le>n.\n       0 < i \\<longrightarrow>\n       (\\<exists>d\\<ge>- int (k (v' i)).\n           d \\<le> 0 \\<and>\n           ((if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n             else if i = 0 then f (v' 0)\n                  else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n            Le (real_of_int d) \\<or>\n            (if 0 = 0 then if i = 0 then Le 0 else g (v' i)\n             else if i = 0 then f (v' 0)\n                  else if 0 = i then Le 0 else h (v' 0) (v' i)) =\n            Lt (real_of_int d)))\n 4. \\<forall>i j.\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) \\<noteq>\n       \\<infinity> \\<longrightarrow>\n       get_const\n        (if i = 0 then if j = 0 then Le 0 else g (v' j)\n         else if j = 0 then f (v' i)\n              else if i = j then Le 0 else h (v' i) (v' j))\n       \\<in> \\<int>\n 5. \\<forall>i\\<le>n.\n       \\<forall>j\\<le>n.\n          (if i = 0 then if j = 0 then Le 0 else g (v' j)\n           else if j = 0 then f (v' i)\n                else if i = j then Le 0 else h (v' i) (v' j)) \\<noteq>\n          \\<infinity> \\<and>\n          0 < i \\<and> 0 < j \\<longrightarrow>\n          (\\<exists>d.\n              ((if i = 0 then if j = 0 then Le 0 else g (v' j)\n                else if j = 0 then f (v' i)\n                     else if i = j then Le 0 else h (v' i) (v' j)) =\n               Le (real_of_int d) \\<or>\n               (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                else if j = 0 then f (v' i)\n                     else if i = j then Le 0 else h (v' i) (v' j)) =\n               Lt (real_of_int d)) \\<and>\n              - int (k (v' j)) \\<le> d \\<and> d \\<le> int (k (v' i)))", "apply (blast intro: calculation)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>i j.\n       (if i = 0 then if j = 0 then Le 0 else g (v' j)\n        else if j = 0 then f (v' i)\n             else if i = j then Le 0 else h (v' i) (v' j)) \\<noteq>\n       \\<infinity> \\<longrightarrow>\n       get_const\n        (if i = 0 then if j = 0 then Le 0 else g (v' j)\n         else if j = 0 then f (v' i)\n              else if i = j then Le 0 else h (v' i) (v' j))\n       \\<in> \\<int>\n 2. \\<forall>i\\<le>n.\n       \\<forall>j\\<le>n.\n          (if i = 0 then if j = 0 then Le 0 else g (v' j)\n           else if j = 0 then f (v' i)\n                else if i = j then Le 0 else h (v' i) (v' j)) \\<noteq>\n          \\<infinity> \\<and>\n          0 < i \\<and> 0 < j \\<longrightarrow>\n          (\\<exists>d.\n              ((if i = 0 then if j = 0 then Le 0 else g (v' j)\n                else if j = 0 then f (v' i)\n                     else if i = j then Le 0 else h (v' i) (v' j)) =\n               Le (real_of_int d) \\<or>\n               (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                else if j = 0 then f (v' i)\n                     else if i = j then Le 0 else h (v' i) (v' j)) =\n               Lt (real_of_int d)) \\<and>\n              - int (k (v' j)) \\<le> d \\<and> d \\<le> int (k (v' i)))", "apply (rule calculation(7))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>n.\n       \\<forall>j\\<le>n.\n          (if i = 0 then if j = 0 then Le 0 else g (v' j)\n           else if j = 0 then f (v' i)\n                else if i = j then Le 0 else h (v' i) (v' j)) \\<noteq>\n          \\<infinity> \\<and>\n          0 < i \\<and> 0 < j \\<longrightarrow>\n          (\\<exists>d.\n              ((if i = 0 then if j = 0 then Le 0 else g (v' j)\n                else if j = 0 then f (v' i)\n                     else if i = j then Le 0 else h (v' i) (v' j)) =\n               Le (real_of_int d) \\<or>\n               (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                else if j = 0 then f (v' i)\n                     else if i = j then Le 0 else h (v' i) (v' j)) =\n               Lt (real_of_int d)) \\<and>\n              - int (k (v' j)) \\<le> d \\<and> d \\<le> int (k (v' i)))", "using calculation(8)"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        0 < i \\<and>\n        0 < j \\<and>\n        (if i = 0 then if j = 0 then Le 0 else g (v' j)\n         else if j = 0 then f (v' i)\n              else if i = j then Le 0 else h (v' i) (v' j)) \\<noteq>\n        \\<infinity> \\<longrightarrow>\n        (\\<exists>d.\n            ((if i = 0 then if j = 0 then Le 0 else g (v' j)\n              else if j = 0 then f (v' i)\n                   else if i = j then Le 0 else h (v' i) (v' j)) =\n             Le (real_of_int d) \\<or>\n             (if i = 0 then if j = 0 then Le 0 else g (v' j)\n              else if j = 0 then f (v' i)\n                   else if i = j then Le 0 else h (v' i) (v' j)) =\n             Lt (real_of_int d)) \\<and>\n            - int (k (v' j)) \\<le> d \\<and> d \\<le> int (k (v' i)))\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>n.\n       \\<forall>j\\<le>n.\n          (if i = 0 then if j = 0 then Le 0 else g (v' j)\n           else if j = 0 then f (v' i)\n                else if i = j then Le 0 else h (v' i) (v' j)) \\<noteq>\n          \\<infinity> \\<and>\n          0 < i \\<and> 0 < j \\<longrightarrow>\n          (\\<exists>d.\n              ((if i = 0 then if j = 0 then Le 0 else g (v' j)\n                else if j = 0 then f (v' i)\n                     else if i = j then Le 0 else h (v' i) (v' j)) =\n               Le (real_of_int d) \\<or>\n               (if i = 0 then if j = 0 then Le 0 else g (v' j)\n                else if j = 0 then f (v' i)\n                     else if i = j then Le 0 else h (v' i) (v' j)) =\n               Lt (real_of_int d)) \\<and>\n              - int (k (v' j)) \\<le> d \\<and> d \\<le> int (k (v' i)))", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma len_inf_elem:\n  \"(a, b) \\<in> set (arcs i j xs) \\<Longrightarrow> M a b = \\<infinity> \\<Longrightarrow> len M i j xs = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<in> set (arcs i j xs); M a b = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> len M i j xs = \\<infinity>", "apply (induction rule: arcs.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ba.\n       \\<lbrakk>(a, b) \\<in> set (arcs aa ba []);\n        M a b = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> len M aa ba [] = \\<infinity>\n 2. \\<And>aa ba x xs.\n       \\<lbrakk>\\<lbrakk>(a, b) \\<in> set (arcs x ba xs);\n                 M a b = \\<infinity>\\<rbrakk>\n                \\<Longrightarrow> len M x ba xs = \\<infinity>;\n        (a, b) \\<in> set (arcs aa ba (x # xs)); M a b = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> len M aa ba (x # xs) = \\<infinity>", "apply (auto simp: mult)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba x xs.\n       \\<lbrakk>len M x ba xs = \\<infinity>; M a b = \\<infinity>;\n        (a, b) \\<in> set (arcs x ba xs)\\<rbrakk>\n       \\<Longrightarrow> dbm_add (M aa x) \\<infinity> = \\<infinity>", "apply (rename_tac a' b' x xs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a' b' x xs.\n       \\<lbrakk>len M x b' xs = \\<infinity>; M a b = \\<infinity>;\n        (a, b) \\<in> set (arcs x b' xs)\\<rbrakk>\n       \\<Longrightarrow> dbm_add (M a' x) \\<infinity> = \\<infinity>", "apply (case_tac \"M a' x\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a' b' x xs x1.\n       \\<lbrakk>len M x b' xs = \\<infinity>; M a b = \\<infinity>;\n        (a, b) \\<in> set (arcs x b' xs); M a' x = Le x1\\<rbrakk>\n       \\<Longrightarrow> dbm_add (M a' x) \\<infinity> = \\<infinity>\n 2. \\<And>a' b' x xs x2.\n       \\<lbrakk>len M x b' xs = \\<infinity>; M a b = \\<infinity>;\n        (a, b) \\<in> set (arcs x b' xs); M a' x = Lt x2\\<rbrakk>\n       \\<Longrightarrow> dbm_add (M a' x) \\<infinity> = \\<infinity>\n 3. \\<And>a' b' x xs.\n       \\<lbrakk>len M x b' xs = \\<infinity>; M a b = \\<infinity>;\n        (a, b) \\<in> set (arcs x b' xs); M a' x = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> dbm_add (M a' x) \\<infinity> = \\<infinity>", "by auto"], ["", "lemma dbm_add_strict_right_mono_neutral: \"a < Le d \\<Longrightarrow> a + Le (-d) < Le 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < Le d \\<Longrightarrow> a + Le (- d) < Le (0::'a)", "unfolding less mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<prec> Le d \\<Longrightarrow> dbm_add a (Le (- d)) \\<prec> Le (0::'a)", "by (cases a) (auto elim!: dbm_lt.cases)"], ["", "lemma dbm_lt_not_inf_less[intro]: \"A \\<noteq> \\<infinity> \\<Longrightarrow> A \\<prec> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<noteq> \\<infinity> \\<Longrightarrow> A \\<prec> \\<infinity>", "by (cases A) auto"], ["", "lemma add_inf[simp]:\n  \"a + \\<infinity> = \\<infinity>\" \"\\<infinity> + a = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + \\<infinity> = \\<infinity> &&& \\<infinity> + a = \\<infinity>", "unfolding mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. dbm_add a \\<infinity> = \\<infinity> &&&\n    dbm_add \\<infinity> a = \\<infinity>", "by (cases a) auto"], ["", "lemma inf_lt[simp,dest!]:\n  \"\\<infinity> < x \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<infinity> < x \\<Longrightarrow> False", "by (cases x) (auto simp: less)"], ["", "lemma zone_diag_lt:\n  assumes \"a \\<le> n\" \"b \\<le> n\" and C: \"v c1 = a\" \"v c2 = b\" and not0: \"a > 0\" \"b > 0\"\n  shows \"[(\\<lambda> i j. if i = a \\<and> j = b then Lt d else \\<infinity>)]\\<^bsub>v,n\\<^esub> = {u. u c1 - u c2 < d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(\\<lambda>i j.\n         if i = a \\<and> j = b then Lt d\n         else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n    {u. u c1 - u c2 < d}", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Lt d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = a \\<and> v c = b then Lt d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = a \\<and> 0 = b then Lt d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = a \\<and> v c2 = b then Lt d else \\<infinity>))} =\n    {u. u c1 - u c2 < d}", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Lt d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = a \\<and> v c = b then Lt d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = a \\<and> 0 = b then Lt d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = a \\<and> v c2 = b then Lt d else \\<infinity>))}\n    \\<subseteq> {u. u c1 - u c2 < d}\n 2. {u. u c1 - u c2 < d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Lt d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = a \\<and> v c = b then Lt d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = a \\<and> 0 = b then Lt d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = a \\<and> v c2 = b then Lt d\n                          else \\<infinity>))}", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Lt d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = a \\<and> v c = b then Lt d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = a \\<and> 0 = b then Lt d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = a \\<and> v c2 = b then Lt d else \\<infinity>))}\n    \\<subseteq> {u. u c1 - u c2 < d}\n 2. {u. u c1 - u c2 < d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Lt d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = a \\<and> v c = b then Lt d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = a \\<and> 0 = b then Lt d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = a \\<and> v c2 = b then Lt d\n                          else \\<infinity>))}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Lt d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = a \\<and> v c = b then Lt d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = a \\<and> 0 = b then Lt d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = a \\<and> v c2 = b then Lt d else \\<infinity>))}\n    \\<subseteq> {u. u c1 - u c2 < d}", "using \\<open>a \\<le> n\\<close> \\<open>b \\<le> n\\<close> C"], ["proof (prove)\nusing this:\n  a \\<le> n\n  b \\<le> n\n  v c1 = a\n  v c2 = b\n\ngoal (1 subgoal):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Lt d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = a \\<and> v c = b then Lt d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = a \\<and> 0 = b then Lt d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = a \\<and> v c2 = b then Lt d else \\<infinity>))}\n    \\<subseteq> {u. u c1 - u c2 < d}", "by fastforce"], ["proof (state)\nthis:\n  {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Lt d\n                            else \\<infinity>) \\<and>\n      (\\<forall>c.\n          v c \\<le> n \\<longrightarrow>\n          dbm_entry_val u None (Some c)\n           (if 0 = a \\<and> v c = b then Lt d else \\<infinity>) \\<and>\n          dbm_entry_val u (Some c) None\n           (if v c = a \\<and> 0 = b then Lt d else \\<infinity>)) \\<and>\n      (\\<forall>c1 c2.\n          v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n          dbm_entry_val u (Some c1) (Some c2)\n           (if v c1 = a \\<and> v c2 = b then Lt d else \\<infinity>))}\n  \\<subseteq> {u. u c1 - u c2 < d}\n\ngoal (1 subgoal):\n 1. {u. u c1 - u c2 < d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Lt d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = a \\<and> v c = b then Lt d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = a \\<and> 0 = b then Lt d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = a \\<and> v c2 = b then Lt d\n                          else \\<infinity>))}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {u. u c1 - u c2 < d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Lt d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = a \\<and> v c = b then Lt d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = a \\<and> 0 = b then Lt d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = a \\<and> v c2 = b then Lt d\n                          else \\<infinity>))}", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. {u. u c1 - u c2 < d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Lt d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = a \\<and> v c = b then Lt d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = a \\<and> 0 = b then Lt d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = a \\<and> v c2 = b then Lt d\n                          else \\<infinity>))}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. {u. u c1 - u c2 < d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Lt d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = a \\<and> v c = b then Lt d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = a \\<and> 0 = b then Lt d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = a \\<and> v c2 = b then Lt d\n                          else \\<infinity>))}", "proof (safe, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       x c1 - x c2 < d \\<Longrightarrow>\n       Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Lt d\n                             else \\<infinity>)\n 2. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 < d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some c)\n                          (if 0 = a \\<and> v c = b then Lt d\n                           else \\<infinity>)\n 3. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 < d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c) None\n                          (if v c = a \\<and> 0 = b then Lt d\n                           else \\<infinity>)\n 4. \\<And>x c1a c2a.\n       \\<lbrakk>x c1 - x c2 < d; v c1a \\<le> n; v c2a \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1a) (Some c2a)\n                          (if v c1a = a \\<and> v c2a = b then Lt d\n                           else \\<infinity>)", "case 1"], ["proof (state)\nthis:\n  x_ c1 - x_ c2 < d\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x c1 - x c2 < d \\<Longrightarrow>\n       Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Lt d\n                             else \\<infinity>)\n 2. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 < d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some c)\n                          (if 0 = a \\<and> v c = b then Lt d\n                           else \\<infinity>)\n 3. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 < d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c) None\n                          (if v c = a \\<and> 0 = b then Lt d\n                           else \\<infinity>)\n 4. \\<And>x c1a c2a.\n       \\<lbrakk>x c1 - x c2 < d; v c1a \\<le> n; v c2a \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1a) (Some c2a)\n                          (if v c1a = a \\<and> v c2a = b then Lt d\n                           else \\<infinity>)", "from not0"], ["proof (chain)\npicking this:\n  0 < a\n  0 < b", "show ?case"], ["proof (prove)\nusing this:\n  0 < a\n  0 < b\n\ngoal (1 subgoal):\n 1. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Lt d else \\<infinity>)", "unfolding dbm_le_def"], ["proof (prove)\nusing this:\n  0 < a\n  0 < b\n\ngoal (1 subgoal):\n 1. Le (0::'a) \\<prec> (if 0 = a \\<and> 0 = b then Lt d\n                        else \\<infinity>) \\<or>\n    Le (0::'a) = (if 0 = a \\<and> 0 = b then Lt d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Lt d else \\<infinity>)\n\ngoal (3 subgoals):\n 1. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 < d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some c)\n                          (if 0 = a \\<and> v c = b then Lt d\n                           else \\<infinity>)\n 2. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 < d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c) None\n                          (if v c = a \\<and> 0 = b then Lt d\n                           else \\<infinity>)\n 3. \\<And>x c1a c2a.\n       \\<lbrakk>x c1 - x c2 < d; v c1a \\<le> n; v c2a \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1a) (Some c2a)\n                          (if v c1a = a \\<and> v c2a = b then Lt d\n                           else \\<infinity>)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 < d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some c)\n                          (if 0 = a \\<and> v c = b then Lt d\n                           else \\<infinity>)\n 2. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 < d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c) None\n                          (if v c = a \\<and> 0 = b then Lt d\n                           else \\<infinity>)\n 3. \\<And>x c1a c2a.\n       \\<lbrakk>x c1 - x c2 < d; v c1a \\<le> n; v c2a \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1a) (Some c2a)\n                          (if v c1a = a \\<and> v c2a = b then Lt d\n                           else \\<infinity>)", "case 2"], ["proof (state)\nthis:\n  x_ c1 - x_ c2 < d\n  v c_ \\<le> n\n\ngoal (3 subgoals):\n 1. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 < d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some c)\n                          (if 0 = a \\<and> v c = b then Lt d\n                           else \\<infinity>)\n 2. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 < d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c) None\n                          (if v c = a \\<and> 0 = b then Lt d\n                           else \\<infinity>)\n 3. \\<And>x c1a c2a.\n       \\<lbrakk>x c1 - x c2 < d; v c1a \\<le> n; v c2a \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1a) (Some c2a)\n                          (if v c1a = a \\<and> v c2a = b then Lt d\n                           else \\<infinity>)", "with not0"], ["proof (chain)\npicking this:\n  0 < a\n  0 < b\n  x_ c1 - x_ c2 < d\n  v c_ \\<le> n", "show ?case"], ["proof (prove)\nusing this:\n  0 < a\n  0 < b\n  x_ c1 - x_ c2 < d\n  v c_ \\<le> n\n\ngoal (1 subgoal):\n 1. dbm_entry_val x_ None (Some c_)\n     (if 0 = a \\<and> v c_ = b then Lt d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val x_ None (Some c_)\n   (if 0 = a \\<and> v c_ = b then Lt d else \\<infinity>)\n\ngoal (2 subgoals):\n 1. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 < d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c) None\n                          (if v c = a \\<and> 0 = b then Lt d\n                           else \\<infinity>)\n 2. \\<And>x c1a c2a.\n       \\<lbrakk>x c1 - x c2 < d; v c1a \\<le> n; v c2a \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1a) (Some c2a)\n                          (if v c1a = a \\<and> v c2a = b then Lt d\n                           else \\<infinity>)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 < d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c) None\n                          (if v c = a \\<and> 0 = b then Lt d\n                           else \\<infinity>)\n 2. \\<And>x c1a c2a.\n       \\<lbrakk>x c1 - x c2 < d; v c1a \\<le> n; v c2a \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1a) (Some c2a)\n                          (if v c1a = a \\<and> v c2a = b then Lt d\n                           else \\<infinity>)", "case 3"], ["proof (state)\nthis:\n  x_ c1 - x_ c2 < d\n  v c_ \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 < d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c) None\n                          (if v c = a \\<and> 0 = b then Lt d\n                           else \\<infinity>)\n 2. \\<And>x c1a c2a.\n       \\<lbrakk>x c1 - x c2 < d; v c1a \\<le> n; v c2a \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1a) (Some c2a)\n                          (if v c1a = a \\<and> v c2a = b then Lt d\n                           else \\<infinity>)", "with not0"], ["proof (chain)\npicking this:\n  0 < a\n  0 < b\n  x_ c1 - x_ c2 < d\n  v c_ \\<le> n", "show ?case"], ["proof (prove)\nusing this:\n  0 < a\n  0 < b\n  x_ c1 - x_ c2 < d\n  v c_ \\<le> n\n\ngoal (1 subgoal):\n 1. dbm_entry_val x_ (Some c_) None\n     (if v c_ = a \\<and> 0 = b then Lt d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val x_ (Some c_) None\n   (if v c_ = a \\<and> 0 = b then Lt d else \\<infinity>)\n\ngoal (1 subgoal):\n 1. \\<And>x c1a c2a.\n       \\<lbrakk>x c1 - x c2 < d; v c1a \\<le> n; v c2a \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1a) (Some c2a)\n                          (if v c1a = a \\<and> v c2a = b then Lt d\n                           else \\<infinity>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x c1a c2a.\n       \\<lbrakk>x c1 - x c2 < d; v c1a \\<le> n; v c2a \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1a) (Some c2a)\n                          (if v c1a = a \\<and> v c2a = b then Lt d\n                           else \\<infinity>)", "case (4 u' y z)"], ["proof (state)\nthis:\n  u' c1 - u' c2 < d\n  v y \\<le> n\n  v z \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>x c1a c2a.\n       \\<lbrakk>x c1 - x c2 < d; v c1a \\<le> n; v c2a \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1a) (Some c2a)\n                          (if v c1a = a \\<and> v c2a = b then Lt d\n                           else \\<infinity>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = b then Lt d else \\<infinity>)", "proof (cases \"v y = a \\<and> v z = b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v y = a \\<and> v z = b \\<Longrightarrow>\n    dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = b then Lt d else \\<infinity>)\n 2. \\<not> (v y = a \\<and> v z = b) \\<Longrightarrow>\n    dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = b then Lt d else \\<infinity>)", "case True"], ["proof (state)\nthis:\n  v y = a \\<and> v z = b\n\ngoal (2 subgoals):\n 1. v y = a \\<and> v z = b \\<Longrightarrow>\n    dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = b then Lt d else \\<infinity>)\n 2. \\<not> (v y = a \\<and> v z = b) \\<Longrightarrow>\n    dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = b then Lt d else \\<infinity>)", "with 4 clock_numbering C \\<open>a \\<le> n\\<close> \\<open>b \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  u' c1 - u' c2 < d\n  v y \\<le> n\n  v z \\<le> n\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  v c1 = a\n  v c2 = b\n  a \\<le> n\n  b \\<le> n\n  v y = a \\<and> v z = b", "have \"u' y - u' z < d\""], ["proof (prove)\nusing this:\n  u' c1 - u' c2 < d\n  v y \\<le> n\n  v z \\<le> n\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  v c1 = a\n  v c2 = b\n  a \\<le> n\n  b \\<le> n\n  v y = a \\<and> v z = b\n\ngoal (1 subgoal):\n 1. u' y - u' z < d", "by metis"], ["proof (state)\nthis:\n  u' y - u' z < d\n\ngoal (2 subgoals):\n 1. v y = a \\<and> v z = b \\<Longrightarrow>\n    dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = b then Lt d else \\<infinity>)\n 2. \\<not> (v y = a \\<and> v z = b) \\<Longrightarrow>\n    dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = b then Lt d else \\<infinity>)", "with True"], ["proof (chain)\npicking this:\n  v y = a \\<and> v z = b\n  u' y - u' z < d", "show ?thesis"], ["proof (prove)\nusing this:\n  v y = a \\<and> v z = b\n  u' y - u' z < d\n\ngoal (1 subgoal):\n 1. dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = b then Lt d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u' (Some y) (Some z)\n   (if v y = a \\<and> v z = b then Lt d else \\<infinity>)\n\ngoal (1 subgoal):\n 1. \\<not> (v y = a \\<and> v z = b) \\<Longrightarrow>\n    dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = b then Lt d else \\<infinity>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (v y = a \\<and> v z = b) \\<Longrightarrow>\n    dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = b then Lt d else \\<infinity>)", "case False"], ["proof (state)\nthis:\n  \\<not> (v y = a \\<and> v z = b)\n\ngoal (1 subgoal):\n 1. \\<not> (v y = a \\<and> v z = b) \\<Longrightarrow>\n    dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = b then Lt d else \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  \\<not> (v y = a \\<and> v z = b)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (v y = a \\<and> v z = b)\n\ngoal (1 subgoal):\n 1. dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = b then Lt d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u' (Some y) (Some z)\n   (if v y = a \\<and> v z = b then Lt d else \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dbm_entry_val u' (Some y) (Some z)\n   (if v y = a \\<and> v z = b then Lt d else \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {u. u c1 - u c2 < d}\n  \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Lt d\n  else \\<infinity>) \\<and>\n                  (\\<forall>c.\n                      v c \\<le> n \\<longrightarrow>\n                      dbm_entry_val u None (Some c)\n                       (if 0 = a \\<and> v c = b then Lt d\n                        else \\<infinity>) \\<and>\n                      dbm_entry_val u (Some c) None\n                       (if v c = a \\<and> 0 = b then Lt d\n                        else \\<infinity>)) \\<and>\n                  (\\<forall>c1 c2.\n                      v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                      dbm_entry_val u (Some c1) (Some c2)\n                       (if v c1 = a \\<and> v c2 = b then Lt d\n                        else \\<infinity>))}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zone_diag_le:\n  assumes \"a \\<le> n\" \"b \\<le> n\" and C: \"v c1 = a\" \"v c2 = b\" and not0: \"a > 0\" \"b > 0\"\n  shows \"[(\\<lambda> i j. if i = a \\<and> j = b then Le d else \\<infinity>)]\\<^bsub>v,n\\<^esub> = {u. u c1 - u c2 \\<le> d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(\\<lambda>i j.\n         if i = a \\<and> j = b then Le d\n         else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n    {u. u c1 - u c2 \\<le> d}", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Le d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = a \\<and> v c = b then Le d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = a \\<and> 0 = b then Le d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = a \\<and> v c2 = b then Le d else \\<infinity>))} =\n    {u. u c1 - u c2 \\<le> d}", "proof (rule, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Le d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = a \\<and> v c = b then Le d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = a \\<and> 0 = b then Le d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = a \\<and> v c2 = b then Le d else \\<infinity>))}\n    \\<subseteq> {u. u c1 - u c2 \\<le> d}\n 2. {u. u c1 - u c2 \\<le> d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Le d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = a \\<and> v c = b then Le d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = a \\<and> 0 = b then Le d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = a \\<and> v c2 = b then Le d\n                          else \\<infinity>))}", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Le d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = a \\<and> v c = b then Le d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = a \\<and> 0 = b then Le d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = a \\<and> v c2 = b then Le d else \\<infinity>))}\n    \\<subseteq> {u. u c1 - u c2 \\<le> d}\n 2. {u. u c1 - u c2 \\<le> d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Le d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = a \\<and> v c = b then Le d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = a \\<and> 0 = b then Le d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = a \\<and> v c2 = b then Le d\n                          else \\<infinity>))}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Le d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = a \\<and> v c = b then Le d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = a \\<and> 0 = b then Le d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = a \\<and> v c2 = b then Le d else \\<infinity>))}\n    \\<subseteq> {u. u c1 - u c2 \\<le> d}", "using \\<open>a \\<le> n\\<close> \\<open>b \\<le> n\\<close> C"], ["proof (prove)\nusing this:\n  a \\<le> n\n  b \\<le> n\n  v c1 = a\n  v c2 = b\n\ngoal (1 subgoal):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Le d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = a \\<and> v c = b then Le d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = a \\<and> 0 = b then Le d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = a \\<and> v c2 = b then Le d else \\<infinity>))}\n    \\<subseteq> {u. u c1 - u c2 \\<le> d}", "by fastforce"], ["proof (state)\nthis:\n  {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Le d\n                            else \\<infinity>) \\<and>\n      (\\<forall>c.\n          v c \\<le> n \\<longrightarrow>\n          dbm_entry_val u None (Some c)\n           (if 0 = a \\<and> v c = b then Le d else \\<infinity>) \\<and>\n          dbm_entry_val u (Some c) None\n           (if v c = a \\<and> 0 = b then Le d else \\<infinity>)) \\<and>\n      (\\<forall>c1 c2.\n          v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n          dbm_entry_val u (Some c1) (Some c2)\n           (if v c1 = a \\<and> v c2 = b then Le d else \\<infinity>))}\n  \\<subseteq> {u. u c1 - u c2 \\<le> d}\n\ngoal (1 subgoal):\n 1. {u. u c1 - u c2 \\<le> d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Le d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = a \\<and> v c = b then Le d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = a \\<and> 0 = b then Le d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = a \\<and> v c2 = b then Le d\n                          else \\<infinity>))}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {u. u c1 - u c2 \\<le> d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Le d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = a \\<and> v c = b then Le d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = a \\<and> 0 = b then Le d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = a \\<and> v c2 = b then Le d\n                          else \\<infinity>))}", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. {u. u c1 - u c2 \\<le> d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Le d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = a \\<and> v c = b then Le d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = a \\<and> 0 = b then Le d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = a \\<and> v c2 = b then Le d\n                          else \\<infinity>))}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. {u. u c1 - u c2 \\<le> d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Le d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = a \\<and> v c = b then Le d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = a \\<and> 0 = b then Le d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = a \\<and> v c2 = b then Le d\n                          else \\<infinity>))}", "proof (safe, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       x c1 - x c2 \\<le> d \\<Longrightarrow>\n       Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Le d\n                             else \\<infinity>)\n 2. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 \\<le> d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some c)\n                          (if 0 = a \\<and> v c = b then Le d\n                           else \\<infinity>)\n 3. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 \\<le> d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c) None\n                          (if v c = a \\<and> 0 = b then Le d\n                           else \\<infinity>)\n 4. \\<And>x c1a c2a.\n       \\<lbrakk>x c1 - x c2 \\<le> d; v c1a \\<le> n; v c2a \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1a) (Some c2a)\n                          (if v c1a = a \\<and> v c2a = b then Le d\n                           else \\<infinity>)", "case 1"], ["proof (state)\nthis:\n  x_ c1 - x_ c2 \\<le> d\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x c1 - x c2 \\<le> d \\<Longrightarrow>\n       Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Le d\n                             else \\<infinity>)\n 2. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 \\<le> d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some c)\n                          (if 0 = a \\<and> v c = b then Le d\n                           else \\<infinity>)\n 3. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 \\<le> d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c) None\n                          (if v c = a \\<and> 0 = b then Le d\n                           else \\<infinity>)\n 4. \\<And>x c1a c2a.\n       \\<lbrakk>x c1 - x c2 \\<le> d; v c1a \\<le> n; v c2a \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1a) (Some c2a)\n                          (if v c1a = a \\<and> v c2a = b then Le d\n                           else \\<infinity>)", "from not0"], ["proof (chain)\npicking this:\n  0 < a\n  0 < b", "show ?case"], ["proof (prove)\nusing this:\n  0 < a\n  0 < b\n\ngoal (1 subgoal):\n 1. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Le d else \\<infinity>)", "unfolding dbm_le_def"], ["proof (prove)\nusing this:\n  0 < a\n  0 < b\n\ngoal (1 subgoal):\n 1. Le (0::'a) \\<prec> (if 0 = a \\<and> 0 = b then Le d\n                        else \\<infinity>) \\<or>\n    Le (0::'a) = (if 0 = a \\<and> 0 = b then Le d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Le d else \\<infinity>)\n\ngoal (3 subgoals):\n 1. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 \\<le> d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some c)\n                          (if 0 = a \\<and> v c = b then Le d\n                           else \\<infinity>)\n 2. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 \\<le> d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c) None\n                          (if v c = a \\<and> 0 = b then Le d\n                           else \\<infinity>)\n 3. \\<And>x c1a c2a.\n       \\<lbrakk>x c1 - x c2 \\<le> d; v c1a \\<le> n; v c2a \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1a) (Some c2a)\n                          (if v c1a = a \\<and> v c2a = b then Le d\n                           else \\<infinity>)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 \\<le> d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some c)\n                          (if 0 = a \\<and> v c = b then Le d\n                           else \\<infinity>)\n 2. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 \\<le> d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c) None\n                          (if v c = a \\<and> 0 = b then Le d\n                           else \\<infinity>)\n 3. \\<And>x c1a c2a.\n       \\<lbrakk>x c1 - x c2 \\<le> d; v c1a \\<le> n; v c2a \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1a) (Some c2a)\n                          (if v c1a = a \\<and> v c2a = b then Le d\n                           else \\<infinity>)", "case 2"], ["proof (state)\nthis:\n  x_ c1 - x_ c2 \\<le> d\n  v c_ \\<le> n\n\ngoal (3 subgoals):\n 1. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 \\<le> d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some c)\n                          (if 0 = a \\<and> v c = b then Le d\n                           else \\<infinity>)\n 2. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 \\<le> d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c) None\n                          (if v c = a \\<and> 0 = b then Le d\n                           else \\<infinity>)\n 3. \\<And>x c1a c2a.\n       \\<lbrakk>x c1 - x c2 \\<le> d; v c1a \\<le> n; v c2a \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1a) (Some c2a)\n                          (if v c1a = a \\<and> v c2a = b then Le d\n                           else \\<infinity>)", "with not0"], ["proof (chain)\npicking this:\n  0 < a\n  0 < b\n  x_ c1 - x_ c2 \\<le> d\n  v c_ \\<le> n", "show ?case"], ["proof (prove)\nusing this:\n  0 < a\n  0 < b\n  x_ c1 - x_ c2 \\<le> d\n  v c_ \\<le> n\n\ngoal (1 subgoal):\n 1. dbm_entry_val x_ None (Some c_)\n     (if 0 = a \\<and> v c_ = b then Le d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val x_ None (Some c_)\n   (if 0 = a \\<and> v c_ = b then Le d else \\<infinity>)\n\ngoal (2 subgoals):\n 1. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 \\<le> d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c) None\n                          (if v c = a \\<and> 0 = b then Le d\n                           else \\<infinity>)\n 2. \\<And>x c1a c2a.\n       \\<lbrakk>x c1 - x c2 \\<le> d; v c1a \\<le> n; v c2a \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1a) (Some c2a)\n                          (if v c1a = a \\<and> v c2a = b then Le d\n                           else \\<infinity>)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 \\<le> d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c) None\n                          (if v c = a \\<and> 0 = b then Le d\n                           else \\<infinity>)\n 2. \\<And>x c1a c2a.\n       \\<lbrakk>x c1 - x c2 \\<le> d; v c1a \\<le> n; v c2a \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1a) (Some c2a)\n                          (if v c1a = a \\<and> v c2a = b then Le d\n                           else \\<infinity>)", "case 3"], ["proof (state)\nthis:\n  x_ c1 - x_ c2 \\<le> d\n  v c_ \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>x c.\n       \\<lbrakk>x c1 - x c2 \\<le> d; v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c) None\n                          (if v c = a \\<and> 0 = b then Le d\n                           else \\<infinity>)\n 2. \\<And>x c1a c2a.\n       \\<lbrakk>x c1 - x c2 \\<le> d; v c1a \\<le> n; v c2a \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1a) (Some c2a)\n                          (if v c1a = a \\<and> v c2a = b then Le d\n                           else \\<infinity>)", "with not0"], ["proof (chain)\npicking this:\n  0 < a\n  0 < b\n  x_ c1 - x_ c2 \\<le> d\n  v c_ \\<le> n", "show ?case"], ["proof (prove)\nusing this:\n  0 < a\n  0 < b\n  x_ c1 - x_ c2 \\<le> d\n  v c_ \\<le> n\n\ngoal (1 subgoal):\n 1. dbm_entry_val x_ (Some c_) None\n     (if v c_ = a \\<and> 0 = b then Le d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val x_ (Some c_) None\n   (if v c_ = a \\<and> 0 = b then Le d else \\<infinity>)\n\ngoal (1 subgoal):\n 1. \\<And>x c1a c2a.\n       \\<lbrakk>x c1 - x c2 \\<le> d; v c1a \\<le> n; v c2a \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1a) (Some c2a)\n                          (if v c1a = a \\<and> v c2a = b then Le d\n                           else \\<infinity>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x c1a c2a.\n       \\<lbrakk>x c1 - x c2 \\<le> d; v c1a \\<le> n; v c2a \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1a) (Some c2a)\n                          (if v c1a = a \\<and> v c2a = b then Le d\n                           else \\<infinity>)", "case (4 u' y z)"], ["proof (state)\nthis:\n  u' c1 - u' c2 \\<le> d\n  v y \\<le> n\n  v z \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>x c1a c2a.\n       \\<lbrakk>x c1 - x c2 \\<le> d; v c1a \\<le> n; v c2a \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1a) (Some c2a)\n                          (if v c1a = a \\<and> v c2a = b then Le d\n                           else \\<infinity>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = b then Le d else \\<infinity>)", "proof (cases \"v y = a \\<and> v z = b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v y = a \\<and> v z = b \\<Longrightarrow>\n    dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = b then Le d else \\<infinity>)\n 2. \\<not> (v y = a \\<and> v z = b) \\<Longrightarrow>\n    dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = b then Le d else \\<infinity>)", "case True"], ["proof (state)\nthis:\n  v y = a \\<and> v z = b\n\ngoal (2 subgoals):\n 1. v y = a \\<and> v z = b \\<Longrightarrow>\n    dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = b then Le d else \\<infinity>)\n 2. \\<not> (v y = a \\<and> v z = b) \\<Longrightarrow>\n    dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = b then Le d else \\<infinity>)", "with 4 clock_numbering C \\<open>a \\<le> n\\<close> \\<open>b \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  u' c1 - u' c2 \\<le> d\n  v y \\<le> n\n  v z \\<le> n\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  v c1 = a\n  v c2 = b\n  a \\<le> n\n  b \\<le> n\n  v y = a \\<and> v z = b", "have \"u' y - u' z \\<le> d\""], ["proof (prove)\nusing this:\n  u' c1 - u' c2 \\<le> d\n  v y \\<le> n\n  v z \\<le> n\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  v c1 = a\n  v c2 = b\n  a \\<le> n\n  b \\<le> n\n  v y = a \\<and> v z = b\n\ngoal (1 subgoal):\n 1. u' y - u' z \\<le> d", "by metis"], ["proof (state)\nthis:\n  u' y - u' z \\<le> d\n\ngoal (2 subgoals):\n 1. v y = a \\<and> v z = b \\<Longrightarrow>\n    dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = b then Le d else \\<infinity>)\n 2. \\<not> (v y = a \\<and> v z = b) \\<Longrightarrow>\n    dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = b then Le d else \\<infinity>)", "with True"], ["proof (chain)\npicking this:\n  v y = a \\<and> v z = b\n  u' y - u' z \\<le> d", "show ?thesis"], ["proof (prove)\nusing this:\n  v y = a \\<and> v z = b\n  u' y - u' z \\<le> d\n\ngoal (1 subgoal):\n 1. dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = b then Le d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u' (Some y) (Some z)\n   (if v y = a \\<and> v z = b then Le d else \\<infinity>)\n\ngoal (1 subgoal):\n 1. \\<not> (v y = a \\<and> v z = b) \\<Longrightarrow>\n    dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = b then Le d else \\<infinity>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (v y = a \\<and> v z = b) \\<Longrightarrow>\n    dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = b then Le d else \\<infinity>)", "case False"], ["proof (state)\nthis:\n  \\<not> (v y = a \\<and> v z = b)\n\ngoal (1 subgoal):\n 1. \\<not> (v y = a \\<and> v z = b) \\<Longrightarrow>\n    dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = b then Le d else \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  \\<not> (v y = a \\<and> v z = b)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (v y = a \\<and> v z = b)\n\ngoal (1 subgoal):\n 1. dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = b then Le d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u' (Some y) (Some z)\n   (if v y = a \\<and> v z = b then Le d else \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dbm_entry_val u' (Some y) (Some z)\n   (if v y = a \\<and> v z = b then Le d else \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {u. u c1 - u c2 \\<le> d}\n  \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = b then Le d\n  else \\<infinity>) \\<and>\n                  (\\<forall>c.\n                      v c \\<le> n \\<longrightarrow>\n                      dbm_entry_val u None (Some c)\n                       (if 0 = a \\<and> v c = b then Le d\n                        else \\<infinity>) \\<and>\n                      dbm_entry_val u (Some c) None\n                       (if v c = a \\<and> 0 = b then Le d\n                        else \\<infinity>)) \\<and>\n                  (\\<forall>c1 c2.\n                      v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                      dbm_entry_val u (Some c1) (Some c2)\n                       (if v c1 = a \\<and> v c2 = b then Le d\n                        else \\<infinity>))}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zone_diag_lt_2:\n  assumes \"a \\<le> n\" and C: \"v c = a\" and not0: \"a > 0\"\n  shows \"[(\\<lambda> i j. if i = a \\<and> j = 0 then Lt d else \\<infinity>)]\\<^bsub>v,n\\<^esub> = {u. u c < d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(\\<lambda>i j.\n         if i = a \\<and> j = 0 then Lt d\n         else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n    {u. u c < d}", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Lt d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = a \\<and> v c = 0 then Lt d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = a \\<and> 0 = 0 then Lt d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = a \\<and> v c2 = 0 then Lt d else \\<infinity>))} =\n    {u. u c < d}", "proof (rule, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Lt d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = a \\<and> v c = 0 then Lt d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = a \\<and> 0 = 0 then Lt d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = a \\<and> v c2 = 0 then Lt d else \\<infinity>))}\n    \\<subseteq> {u. u c < d}\n 2. {u. u c < d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Lt d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = a \\<and> v c = 0 then Lt d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = a \\<and> 0 = 0 then Lt d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = a \\<and> v c2 = 0 then Lt d\n                          else \\<infinity>))}", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Lt d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = a \\<and> v c = 0 then Lt d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = a \\<and> 0 = 0 then Lt d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = a \\<and> v c2 = 0 then Lt d else \\<infinity>))}\n    \\<subseteq> {u. u c < d}\n 2. {u. u c < d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Lt d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = a \\<and> v c = 0 then Lt d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = a \\<and> 0 = 0 then Lt d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = a \\<and> v c2 = 0 then Lt d\n                          else \\<infinity>))}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Lt d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = a \\<and> v c = 0 then Lt d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = a \\<and> 0 = 0 then Lt d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = a \\<and> v c2 = 0 then Lt d else \\<infinity>))}\n    \\<subseteq> {u. u c < d}", "using \\<open>a \\<le> n\\<close> C"], ["proof (prove)\nusing this:\n  a \\<le> n\n  v c = a\n\ngoal (1 subgoal):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Lt d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = a \\<and> v c = 0 then Lt d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = a \\<and> 0 = 0 then Lt d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = a \\<and> v c2 = 0 then Lt d else \\<infinity>))}\n    \\<subseteq> {u. u c < d}", "by fastforce"], ["proof (state)\nthis:\n  {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Lt d\n                            else \\<infinity>) \\<and>\n      (\\<forall>c.\n          v c \\<le> n \\<longrightarrow>\n          dbm_entry_val u None (Some c)\n           (if 0 = a \\<and> v c = 0 then Lt d else \\<infinity>) \\<and>\n          dbm_entry_val u (Some c) None\n           (if v c = a \\<and> 0 = 0 then Lt d else \\<infinity>)) \\<and>\n      (\\<forall>c1 c2.\n          v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n          dbm_entry_val u (Some c1) (Some c2)\n           (if v c1 = a \\<and> v c2 = 0 then Lt d else \\<infinity>))}\n  \\<subseteq> {u. u c < d}\n\ngoal (1 subgoal):\n 1. {u. u c < d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Lt d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = a \\<and> v c = 0 then Lt d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = a \\<and> 0 = 0 then Lt d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = a \\<and> v c2 = 0 then Lt d\n                          else \\<infinity>))}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {u. u c < d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Lt d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = a \\<and> v c = 0 then Lt d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = a \\<and> 0 = 0 then Lt d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = a \\<and> v c2 = 0 then Lt d\n                          else \\<infinity>))}", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. {u. u c < d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Lt d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = a \\<and> v c = 0 then Lt d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = a \\<and> 0 = 0 then Lt d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = a \\<and> v c2 = 0 then Lt d\n                          else \\<infinity>))}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. {u. u c < d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Lt d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = a \\<and> v c = 0 then Lt d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = a \\<and> 0 = 0 then Lt d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = a \\<and> v c2 = 0 then Lt d\n                          else \\<infinity>))}", "proof (safe, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       x c < d \\<Longrightarrow>\n       Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Lt d\n                             else \\<infinity>)\n 2. \\<And>x ca.\n       \\<lbrakk>x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some ca)\n                          (if 0 = a \\<and> v ca = 0 then Lt d\n                           else \\<infinity>)\n 3. \\<And>x ca.\n       \\<lbrakk>x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = a \\<and> 0 = 0 then Lt d\n                           else \\<infinity>)\n 4. \\<And>x c1 c2.\n       \\<lbrakk>x c < d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = a \\<and> v c2 = 0 then Lt d\n                           else \\<infinity>)", "case 1"], ["proof (state)\nthis:\n  x_ c < d\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x c < d \\<Longrightarrow>\n       Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Lt d\n                             else \\<infinity>)\n 2. \\<And>x ca.\n       \\<lbrakk>x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some ca)\n                          (if 0 = a \\<and> v ca = 0 then Lt d\n                           else \\<infinity>)\n 3. \\<And>x ca.\n       \\<lbrakk>x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = a \\<and> 0 = 0 then Lt d\n                           else \\<infinity>)\n 4. \\<And>x c1 c2.\n       \\<lbrakk>x c < d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = a \\<and> v c2 = 0 then Lt d\n                           else \\<infinity>)", "from not0"], ["proof (chain)\npicking this:\n  0 < a", "show ?case"], ["proof (prove)\nusing this:\n  0 < a\n\ngoal (1 subgoal):\n 1. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Lt d else \\<infinity>)", "unfolding dbm_le_def"], ["proof (prove)\nusing this:\n  0 < a\n\ngoal (1 subgoal):\n 1. Le (0::'a) \\<prec> (if 0 = a \\<and> 0 = 0 then Lt d\n                        else \\<infinity>) \\<or>\n    Le (0::'a) = (if 0 = a \\<and> 0 = 0 then Lt d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Lt d else \\<infinity>)\n\ngoal (3 subgoals):\n 1. \\<And>x ca.\n       \\<lbrakk>x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some ca)\n                          (if 0 = a \\<and> v ca = 0 then Lt d\n                           else \\<infinity>)\n 2. \\<And>x ca.\n       \\<lbrakk>x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = a \\<and> 0 = 0 then Lt d\n                           else \\<infinity>)\n 3. \\<And>x c1 c2.\n       \\<lbrakk>x c < d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = a \\<and> v c2 = 0 then Lt d\n                           else \\<infinity>)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x ca.\n       \\<lbrakk>x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some ca)\n                          (if 0 = a \\<and> v ca = 0 then Lt d\n                           else \\<infinity>)\n 2. \\<And>x ca.\n       \\<lbrakk>x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = a \\<and> 0 = 0 then Lt d\n                           else \\<infinity>)\n 3. \\<And>x c1 c2.\n       \\<lbrakk>x c < d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = a \\<and> v c2 = 0 then Lt d\n                           else \\<infinity>)", "case 2"], ["proof (state)\nthis:\n  x_ c < d\n  v c_ \\<le> n\n\ngoal (3 subgoals):\n 1. \\<And>x ca.\n       \\<lbrakk>x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some ca)\n                          (if 0 = a \\<and> v ca = 0 then Lt d\n                           else \\<infinity>)\n 2. \\<And>x ca.\n       \\<lbrakk>x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = a \\<and> 0 = 0 then Lt d\n                           else \\<infinity>)\n 3. \\<And>x c1 c2.\n       \\<lbrakk>x c < d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = a \\<and> v c2 = 0 then Lt d\n                           else \\<infinity>)", "with not0"], ["proof (chain)\npicking this:\n  0 < a\n  x_ c < d\n  v c_ \\<le> n", "show ?case"], ["proof (prove)\nusing this:\n  0 < a\n  x_ c < d\n  v c_ \\<le> n\n\ngoal (1 subgoal):\n 1. dbm_entry_val x_ None (Some c_)\n     (if 0 = a \\<and> v c_ = 0 then Lt d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val x_ None (Some c_)\n   (if 0 = a \\<and> v c_ = 0 then Lt d else \\<infinity>)\n\ngoal (2 subgoals):\n 1. \\<And>x ca.\n       \\<lbrakk>x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = a \\<and> 0 = 0 then Lt d\n                           else \\<infinity>)\n 2. \\<And>x c1 c2.\n       \\<lbrakk>x c < d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = a \\<and> v c2 = 0 then Lt d\n                           else \\<infinity>)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x ca.\n       \\<lbrakk>x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = a \\<and> 0 = 0 then Lt d\n                           else \\<infinity>)\n 2. \\<And>x c1 c2.\n       \\<lbrakk>x c < d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = a \\<and> v c2 = 0 then Lt d\n                           else \\<infinity>)", "case (3 u c)"], ["proof (state)\nthis:\n  u c < d\n  v c \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>x ca.\n       \\<lbrakk>x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = a \\<and> 0 = 0 then Lt d\n                           else \\<infinity>)\n 2. \\<And>x c1 c2.\n       \\<lbrakk>x c < d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = a \\<and> v c2 = 0 then Lt d\n                           else \\<infinity>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) None\n     (if v c = a \\<and> 0 = 0 then Lt d else \\<infinity>)", "proof (cases \"v c = a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v c = a \\<Longrightarrow>\n    dbm_entry_val u (Some c) None\n     (if v c = a \\<and> 0 = 0 then Lt d else \\<infinity>)\n 2. v c \\<noteq> a \\<Longrightarrow>\n    dbm_entry_val u (Some c) None\n     (if v c = a \\<and> 0 = 0 then Lt d else \\<infinity>)", "case False"], ["proof (state)\nthis:\n  v c \\<noteq> a\n\ngoal (2 subgoals):\n 1. v c = a \\<Longrightarrow>\n    dbm_entry_val u (Some c) None\n     (if v c = a \\<and> 0 = 0 then Lt d else \\<infinity>)\n 2. v c \\<noteq> a \\<Longrightarrow>\n    dbm_entry_val u (Some c) None\n     (if v c = a \\<and> 0 = 0 then Lt d else \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  v c \\<noteq> a", "show ?thesis"], ["proof (prove)\nusing this:\n  v c \\<noteq> a\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) None\n     (if v c = a \\<and> 0 = 0 then Lt d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c) None\n   (if v c = a \\<and> 0 = 0 then Lt d else \\<infinity>)\n\ngoal (1 subgoal):\n 1. v c = a \\<Longrightarrow>\n    dbm_entry_val u (Some c) None\n     (if v c = a \\<and> 0 = 0 then Lt d else \\<infinity>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v c = a \\<Longrightarrow>\n    dbm_entry_val u (Some c) None\n     (if v c = a \\<and> 0 = 0 then Lt d else \\<infinity>)", "case True"], ["proof (state)\nthis:\n  v c = a\n\ngoal (1 subgoal):\n 1. v c = a \\<Longrightarrow>\n    dbm_entry_val u (Some c) None\n     (if v c = a \\<and> 0 = 0 then Lt d else \\<infinity>)", "with 3 clock_numbering C \\<open>a \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  u c < d\n  v c \\<le> n\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  v c = a\n  a \\<le> n\n  v c = a", "have \"u c < d\""], ["proof (prove)\nusing this:\n  u c < d\n  v c \\<le> n\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  v c = a\n  a \\<le> n\n  v c = a\n\ngoal (1 subgoal):\n 1. u c < d", "by metis"], ["proof (state)\nthis:\n  u c < d\n\ngoal (1 subgoal):\n 1. v c = a \\<Longrightarrow>\n    dbm_entry_val u (Some c) None\n     (if v c = a \\<and> 0 = 0 then Lt d else \\<infinity>)", "with C"], ["proof (chain)\npicking this:\n  v c = a\n  u c < d", "show ?thesis"], ["proof (prove)\nusing this:\n  v c = a\n  u c < d\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) None\n     (if v c = a \\<and> 0 = 0 then Lt d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c) None\n   (if v c = a \\<and> 0 = 0 then Lt d else \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c) None\n   (if v c = a \\<and> 0 = 0 then Lt d else \\<infinity>)\n\ngoal (1 subgoal):\n 1. \\<And>x c1 c2.\n       \\<lbrakk>x c < d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = a \\<and> v c2 = 0 then Lt d\n                           else \\<infinity>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x c1 c2.\n       \\<lbrakk>x c < d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = a \\<and> v c2 = 0 then Lt d\n                           else \\<infinity>)", "case (4 u' y z)"], ["proof (state)\nthis:\n  u' c < d\n  v y \\<le> n\n  v z \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>x c1 c2.\n       \\<lbrakk>x c < d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = a \\<and> v c2 = 0 then Lt d\n                           else \\<infinity>)", "from clock_numbering(1)"], ["proof (chain)\npicking this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)", "have \"0 < v z\""], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n\ngoal (1 subgoal):\n 1. 0 < v z", "by auto"], ["proof (state)\nthis:\n  0 < v z\n\ngoal (1 subgoal):\n 1. \\<And>x c1 c2.\n       \\<lbrakk>x c < d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = a \\<and> v c2 = 0 then Lt d\n                           else \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  0 < v z", "show ?case"], ["proof (prove)\nusing this:\n  0 < v z\n\ngoal (1 subgoal):\n 1. dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = 0 then Lt d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u' (Some y) (Some z)\n   (if v y = a \\<and> v z = 0 then Lt d else \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {u. u c < d}\n  \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Lt d\n  else \\<infinity>) \\<and>\n                  (\\<forall>c.\n                      v c \\<le> n \\<longrightarrow>\n                      dbm_entry_val u None (Some c)\n                       (if 0 = a \\<and> v c = 0 then Lt d\n                        else \\<infinity>) \\<and>\n                      dbm_entry_val u (Some c) None\n                       (if v c = a \\<and> 0 = 0 then Lt d\n                        else \\<infinity>)) \\<and>\n                  (\\<forall>c1 c2.\n                      v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                      dbm_entry_val u (Some c1) (Some c2)\n                       (if v c1 = a \\<and> v c2 = 0 then Lt d\n                        else \\<infinity>))}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zone_diag_le_2:\n  assumes \"a \\<le> n\" and C: \"v c = a\" and not0: \"a > 0\"\n  shows \"[(\\<lambda> i j. if i = a \\<and> j = 0 then Le d else \\<infinity>)]\\<^bsub>v,n\\<^esub> = {u. u c \\<le> d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(\\<lambda>i j.\n         if i = a \\<and> j = 0 then Le d\n         else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n    {u. u c \\<le> d}", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Le d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = a \\<and> v c = 0 then Le d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = a \\<and> 0 = 0 then Le d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = a \\<and> v c2 = 0 then Le d else \\<infinity>))} =\n    {u. u c \\<le> d}", "proof (rule, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Le d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = a \\<and> v c = 0 then Le d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = a \\<and> 0 = 0 then Le d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = a \\<and> v c2 = 0 then Le d else \\<infinity>))}\n    \\<subseteq> {u. u c \\<le> d}\n 2. {u. u c \\<le> d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Le d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = a \\<and> v c = 0 then Le d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = a \\<and> 0 = 0 then Le d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = a \\<and> v c2 = 0 then Le d\n                          else \\<infinity>))}", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Le d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = a \\<and> v c = 0 then Le d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = a \\<and> 0 = 0 then Le d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = a \\<and> v c2 = 0 then Le d else \\<infinity>))}\n    \\<subseteq> {u. u c \\<le> d}\n 2. {u. u c \\<le> d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Le d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = a \\<and> v c = 0 then Le d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = a \\<and> 0 = 0 then Le d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = a \\<and> v c2 = 0 then Le d\n                          else \\<infinity>))}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Le d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = a \\<and> v c = 0 then Le d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = a \\<and> 0 = 0 then Le d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = a \\<and> v c2 = 0 then Le d else \\<infinity>))}\n    \\<subseteq> {u. u c \\<le> d}", "using \\<open>a \\<le> n\\<close> C"], ["proof (prove)\nusing this:\n  a \\<le> n\n  v c = a\n\ngoal (1 subgoal):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Le d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = a \\<and> v c = 0 then Le d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = a \\<and> 0 = 0 then Le d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = a \\<and> v c2 = 0 then Le d else \\<infinity>))}\n    \\<subseteq> {u. u c \\<le> d}", "by fastforce"], ["proof (state)\nthis:\n  {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Le d\n                            else \\<infinity>) \\<and>\n      (\\<forall>c.\n          v c \\<le> n \\<longrightarrow>\n          dbm_entry_val u None (Some c)\n           (if 0 = a \\<and> v c = 0 then Le d else \\<infinity>) \\<and>\n          dbm_entry_val u (Some c) None\n           (if v c = a \\<and> 0 = 0 then Le d else \\<infinity>)) \\<and>\n      (\\<forall>c1 c2.\n          v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n          dbm_entry_val u (Some c1) (Some c2)\n           (if v c1 = a \\<and> v c2 = 0 then Le d else \\<infinity>))}\n  \\<subseteq> {u. u c \\<le> d}\n\ngoal (1 subgoal):\n 1. {u. u c \\<le> d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Le d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = a \\<and> v c = 0 then Le d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = a \\<and> 0 = 0 then Le d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = a \\<and> v c2 = 0 then Le d\n                          else \\<infinity>))}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {u. u c \\<le> d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Le d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = a \\<and> v c = 0 then Le d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = a \\<and> 0 = 0 then Le d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = a \\<and> v c2 = 0 then Le d\n                          else \\<infinity>))}", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. {u. u c \\<le> d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Le d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = a \\<and> v c = 0 then Le d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = a \\<and> 0 = 0 then Le d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = a \\<and> v c2 = 0 then Le d\n                          else \\<infinity>))}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. {u. u c \\<le> d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Le d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = a \\<and> v c = 0 then Le d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = a \\<and> 0 = 0 then Le d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = a \\<and> v c2 = 0 then Le d\n                          else \\<infinity>))}", "proof (safe, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       x c \\<le> d \\<Longrightarrow>\n       Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Le d\n                             else \\<infinity>)\n 2. \\<And>x ca.\n       \\<lbrakk>x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some ca)\n                          (if 0 = a \\<and> v ca = 0 then Le d\n                           else \\<infinity>)\n 3. \\<And>x ca.\n       \\<lbrakk>x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = a \\<and> 0 = 0 then Le d\n                           else \\<infinity>)\n 4. \\<And>x c1 c2.\n       \\<lbrakk>x c \\<le> d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = a \\<and> v c2 = 0 then Le d\n                           else \\<infinity>)", "case 1"], ["proof (state)\nthis:\n  x_ c \\<le> d\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x c \\<le> d \\<Longrightarrow>\n       Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Le d\n                             else \\<infinity>)\n 2. \\<And>x ca.\n       \\<lbrakk>x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some ca)\n                          (if 0 = a \\<and> v ca = 0 then Le d\n                           else \\<infinity>)\n 3. \\<And>x ca.\n       \\<lbrakk>x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = a \\<and> 0 = 0 then Le d\n                           else \\<infinity>)\n 4. \\<And>x c1 c2.\n       \\<lbrakk>x c \\<le> d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = a \\<and> v c2 = 0 then Le d\n                           else \\<infinity>)", "from not0"], ["proof (chain)\npicking this:\n  0 < a", "show ?case"], ["proof (prove)\nusing this:\n  0 < a\n\ngoal (1 subgoal):\n 1. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Le d else \\<infinity>)", "unfolding dbm_le_def"], ["proof (prove)\nusing this:\n  0 < a\n\ngoal (1 subgoal):\n 1. Le (0::'a) \\<prec> (if 0 = a \\<and> 0 = 0 then Le d\n                        else \\<infinity>) \\<or>\n    Le (0::'a) = (if 0 = a \\<and> 0 = 0 then Le d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Le d else \\<infinity>)\n\ngoal (3 subgoals):\n 1. \\<And>x ca.\n       \\<lbrakk>x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some ca)\n                          (if 0 = a \\<and> v ca = 0 then Le d\n                           else \\<infinity>)\n 2. \\<And>x ca.\n       \\<lbrakk>x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = a \\<and> 0 = 0 then Le d\n                           else \\<infinity>)\n 3. \\<And>x c1 c2.\n       \\<lbrakk>x c \\<le> d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = a \\<and> v c2 = 0 then Le d\n                           else \\<infinity>)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x ca.\n       \\<lbrakk>x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some ca)\n                          (if 0 = a \\<and> v ca = 0 then Le d\n                           else \\<infinity>)\n 2. \\<And>x ca.\n       \\<lbrakk>x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = a \\<and> 0 = 0 then Le d\n                           else \\<infinity>)\n 3. \\<And>x c1 c2.\n       \\<lbrakk>x c \\<le> d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = a \\<and> v c2 = 0 then Le d\n                           else \\<infinity>)", "case 2"], ["proof (state)\nthis:\n  x_ c \\<le> d\n  v c_ \\<le> n\n\ngoal (3 subgoals):\n 1. \\<And>x ca.\n       \\<lbrakk>x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some ca)\n                          (if 0 = a \\<and> v ca = 0 then Le d\n                           else \\<infinity>)\n 2. \\<And>x ca.\n       \\<lbrakk>x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = a \\<and> 0 = 0 then Le d\n                           else \\<infinity>)\n 3. \\<And>x c1 c2.\n       \\<lbrakk>x c \\<le> d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = a \\<and> v c2 = 0 then Le d\n                           else \\<infinity>)", "with not0"], ["proof (chain)\npicking this:\n  0 < a\n  x_ c \\<le> d\n  v c_ \\<le> n", "show ?case"], ["proof (prove)\nusing this:\n  0 < a\n  x_ c \\<le> d\n  v c_ \\<le> n\n\ngoal (1 subgoal):\n 1. dbm_entry_val x_ None (Some c_)\n     (if 0 = a \\<and> v c_ = 0 then Le d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val x_ None (Some c_)\n   (if 0 = a \\<and> v c_ = 0 then Le d else \\<infinity>)\n\ngoal (2 subgoals):\n 1. \\<And>x ca.\n       \\<lbrakk>x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = a \\<and> 0 = 0 then Le d\n                           else \\<infinity>)\n 2. \\<And>x c1 c2.\n       \\<lbrakk>x c \\<le> d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = a \\<and> v c2 = 0 then Le d\n                           else \\<infinity>)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x ca.\n       \\<lbrakk>x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = a \\<and> 0 = 0 then Le d\n                           else \\<infinity>)\n 2. \\<And>x c1 c2.\n       \\<lbrakk>x c \\<le> d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = a \\<and> v c2 = 0 then Le d\n                           else \\<infinity>)", "case (3 u c)"], ["proof (state)\nthis:\n  u c \\<le> d\n  v c \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>x ca.\n       \\<lbrakk>x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = a \\<and> 0 = 0 then Le d\n                           else \\<infinity>)\n 2. \\<And>x c1 c2.\n       \\<lbrakk>x c \\<le> d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = a \\<and> v c2 = 0 then Le d\n                           else \\<infinity>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) None\n     (if v c = a \\<and> 0 = 0 then Le d else \\<infinity>)", "proof (cases \"v c = a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v c = a \\<Longrightarrow>\n    dbm_entry_val u (Some c) None\n     (if v c = a \\<and> 0 = 0 then Le d else \\<infinity>)\n 2. v c \\<noteq> a \\<Longrightarrow>\n    dbm_entry_val u (Some c) None\n     (if v c = a \\<and> 0 = 0 then Le d else \\<infinity>)", "case False"], ["proof (state)\nthis:\n  v c \\<noteq> a\n\ngoal (2 subgoals):\n 1. v c = a \\<Longrightarrow>\n    dbm_entry_val u (Some c) None\n     (if v c = a \\<and> 0 = 0 then Le d else \\<infinity>)\n 2. v c \\<noteq> a \\<Longrightarrow>\n    dbm_entry_val u (Some c) None\n     (if v c = a \\<and> 0 = 0 then Le d else \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  v c \\<noteq> a", "show ?thesis"], ["proof (prove)\nusing this:\n  v c \\<noteq> a\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) None\n     (if v c = a \\<and> 0 = 0 then Le d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c) None\n   (if v c = a \\<and> 0 = 0 then Le d else \\<infinity>)\n\ngoal (1 subgoal):\n 1. v c = a \\<Longrightarrow>\n    dbm_entry_val u (Some c) None\n     (if v c = a \\<and> 0 = 0 then Le d else \\<infinity>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v c = a \\<Longrightarrow>\n    dbm_entry_val u (Some c) None\n     (if v c = a \\<and> 0 = 0 then Le d else \\<infinity>)", "case True"], ["proof (state)\nthis:\n  v c = a\n\ngoal (1 subgoal):\n 1. v c = a \\<Longrightarrow>\n    dbm_entry_val u (Some c) None\n     (if v c = a \\<and> 0 = 0 then Le d else \\<infinity>)", "with 3 clock_numbering C \\<open>a \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  u c \\<le> d\n  v c \\<le> n\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  v c = a\n  a \\<le> n\n  v c = a", "have \"u c \\<le> d\""], ["proof (prove)\nusing this:\n  u c \\<le> d\n  v c \\<le> n\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  v c = a\n  a \\<le> n\n  v c = a\n\ngoal (1 subgoal):\n 1. u c \\<le> d", "by metis"], ["proof (state)\nthis:\n  u c \\<le> d\n\ngoal (1 subgoal):\n 1. v c = a \\<Longrightarrow>\n    dbm_entry_val u (Some c) None\n     (if v c = a \\<and> 0 = 0 then Le d else \\<infinity>)", "with C"], ["proof (chain)\npicking this:\n  v c = a\n  u c \\<le> d", "show ?thesis"], ["proof (prove)\nusing this:\n  v c = a\n  u c \\<le> d\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) None\n     (if v c = a \\<and> 0 = 0 then Le d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c) None\n   (if v c = a \\<and> 0 = 0 then Le d else \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c) None\n   (if v c = a \\<and> 0 = 0 then Le d else \\<infinity>)\n\ngoal (1 subgoal):\n 1. \\<And>x c1 c2.\n       \\<lbrakk>x c \\<le> d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = a \\<and> v c2 = 0 then Le d\n                           else \\<infinity>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x c1 c2.\n       \\<lbrakk>x c \\<le> d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = a \\<and> v c2 = 0 then Le d\n                           else \\<infinity>)", "case (4 u' y z)"], ["proof (state)\nthis:\n  u' c \\<le> d\n  v y \\<le> n\n  v z \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>x c1 c2.\n       \\<lbrakk>x c \\<le> d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = a \\<and> v c2 = 0 then Le d\n                           else \\<infinity>)", "from clock_numbering(1)"], ["proof (chain)\npicking this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)", "have \"0 < v z\""], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n\ngoal (1 subgoal):\n 1. 0 < v z", "by auto"], ["proof (state)\nthis:\n  0 < v z\n\ngoal (1 subgoal):\n 1. \\<And>x c1 c2.\n       \\<lbrakk>x c \\<le> d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = a \\<and> v c2 = 0 then Le d\n                           else \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  0 < v z", "show ?case"], ["proof (prove)\nusing this:\n  0 < v z\n\ngoal (1 subgoal):\n 1. dbm_entry_val u' (Some y) (Some z)\n     (if v y = a \\<and> v z = 0 then Le d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u' (Some y) (Some z)\n   (if v y = a \\<and> v z = 0 then Le d else \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {u. u c \\<le> d}\n  \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = a \\<and> 0 = 0 then Le d\n  else \\<infinity>) \\<and>\n                  (\\<forall>c.\n                      v c \\<le> n \\<longrightarrow>\n                      dbm_entry_val u None (Some c)\n                       (if 0 = a \\<and> v c = 0 then Le d\n                        else \\<infinity>) \\<and>\n                      dbm_entry_val u (Some c) None\n                       (if v c = a \\<and> 0 = 0 then Le d\n                        else \\<infinity>)) \\<and>\n                  (\\<forall>c1 c2.\n                      v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                      dbm_entry_val u (Some c1) (Some c2)\n                       (if v c1 = a \\<and> v c2 = 0 then Le d\n                        else \\<infinity>))}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zone_diag_lt_3:\n  assumes \"a \\<le> n\" and C: \"v c = a\" and not0: \"a > 0\"\n  shows \"[(\\<lambda> i j. if i = 0 \\<and> j = a then Lt d else \\<infinity>)]\\<^bsub>v,n\\<^esub> = {u. - u c < d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(\\<lambda>i j.\n         if i = 0 \\<and> j = a then Lt d\n         else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n    {u. - u c < d}", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Lt d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = 0 \\<and> v c = a then Lt d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = 0 \\<and> 0 = a then Lt d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = 0 \\<and> v c2 = a then Lt d else \\<infinity>))} =\n    {u. - u c < d}", "proof (rule, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Lt d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = 0 \\<and> v c = a then Lt d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = 0 \\<and> 0 = a then Lt d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = 0 \\<and> v c2 = a then Lt d else \\<infinity>))}\n    \\<subseteq> {u. - u c < d}\n 2. {u. - u c < d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Lt d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = 0 \\<and> v c = a then Lt d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = 0 \\<and> 0 = a then Lt d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = 0 \\<and> v c2 = a then Lt d\n                          else \\<infinity>))}", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Lt d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = 0 \\<and> v c = a then Lt d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = 0 \\<and> 0 = a then Lt d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = 0 \\<and> v c2 = a then Lt d else \\<infinity>))}\n    \\<subseteq> {u. - u c < d}\n 2. {u. - u c < d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Lt d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = 0 \\<and> v c = a then Lt d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = 0 \\<and> 0 = a then Lt d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = 0 \\<and> v c2 = a then Lt d\n                          else \\<infinity>))}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Lt d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = 0 \\<and> v c = a then Lt d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = 0 \\<and> 0 = a then Lt d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = 0 \\<and> v c2 = a then Lt d else \\<infinity>))}\n    \\<subseteq> {u. - u c < d}", "using \\<open>a \\<le> n\\<close> C"], ["proof (prove)\nusing this:\n  a \\<le> n\n  v c = a\n\ngoal (1 subgoal):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Lt d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = 0 \\<and> v c = a then Lt d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = 0 \\<and> 0 = a then Lt d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = 0 \\<and> v c2 = a then Lt d else \\<infinity>))}\n    \\<subseteq> {u. - u c < d}", "by fastforce"], ["proof (state)\nthis:\n  {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Lt d\n                            else \\<infinity>) \\<and>\n      (\\<forall>c.\n          v c \\<le> n \\<longrightarrow>\n          dbm_entry_val u None (Some c)\n           (if 0 = 0 \\<and> v c = a then Lt d else \\<infinity>) \\<and>\n          dbm_entry_val u (Some c) None\n           (if v c = 0 \\<and> 0 = a then Lt d else \\<infinity>)) \\<and>\n      (\\<forall>c1 c2.\n          v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n          dbm_entry_val u (Some c1) (Some c2)\n           (if v c1 = 0 \\<and> v c2 = a then Lt d else \\<infinity>))}\n  \\<subseteq> {u. - u c < d}\n\ngoal (1 subgoal):\n 1. {u. - u c < d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Lt d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = 0 \\<and> v c = a then Lt d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = 0 \\<and> 0 = a then Lt d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = 0 \\<and> v c2 = a then Lt d\n                          else \\<infinity>))}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {u. - u c < d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Lt d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = 0 \\<and> v c = a then Lt d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = 0 \\<and> 0 = a then Lt d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = 0 \\<and> v c2 = a then Lt d\n                          else \\<infinity>))}", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. {u. - u c < d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Lt d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = 0 \\<and> v c = a then Lt d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = 0 \\<and> 0 = a then Lt d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = 0 \\<and> v c2 = a then Lt d\n                          else \\<infinity>))}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. {u. - u c < d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Lt d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = 0 \\<and> v c = a then Lt d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = 0 \\<and> 0 = a then Lt d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = 0 \\<and> v c2 = a then Lt d\n                          else \\<infinity>))}", "proof (safe, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       - x c < d \\<Longrightarrow>\n       Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Lt d\n                             else \\<infinity>)\n 2. \\<And>x ca.\n       \\<lbrakk>- x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some ca)\n                          (if 0 = 0 \\<and> v ca = a then Lt d\n                           else \\<infinity>)\n 3. \\<And>x ca.\n       \\<lbrakk>- x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = 0 \\<and> 0 = a then Lt d\n                           else \\<infinity>)\n 4. \\<And>x c1 c2.\n       \\<lbrakk>- x c < d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = 0 \\<and> v c2 = a then Lt d\n                           else \\<infinity>)", "case 1"], ["proof (state)\nthis:\n  - x_ c < d\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       - x c < d \\<Longrightarrow>\n       Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Lt d\n                             else \\<infinity>)\n 2. \\<And>x ca.\n       \\<lbrakk>- x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some ca)\n                          (if 0 = 0 \\<and> v ca = a then Lt d\n                           else \\<infinity>)\n 3. \\<And>x ca.\n       \\<lbrakk>- x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = 0 \\<and> 0 = a then Lt d\n                           else \\<infinity>)\n 4. \\<And>x c1 c2.\n       \\<lbrakk>- x c < d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = 0 \\<and> v c2 = a then Lt d\n                           else \\<infinity>)", "from not0"], ["proof (chain)\npicking this:\n  0 < a", "show ?case"], ["proof (prove)\nusing this:\n  0 < a\n\ngoal (1 subgoal):\n 1. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Lt d else \\<infinity>)", "unfolding dbm_le_def"], ["proof (prove)\nusing this:\n  0 < a\n\ngoal (1 subgoal):\n 1. Le (0::'a) \\<prec> (if 0 = 0 \\<and> 0 = a then Lt d\n                        else \\<infinity>) \\<or>\n    Le (0::'a) = (if 0 = 0 \\<and> 0 = a then Lt d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Lt d else \\<infinity>)\n\ngoal (3 subgoals):\n 1. \\<And>x ca.\n       \\<lbrakk>- x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some ca)\n                          (if 0 = 0 \\<and> v ca = a then Lt d\n                           else \\<infinity>)\n 2. \\<And>x ca.\n       \\<lbrakk>- x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = 0 \\<and> 0 = a then Lt d\n                           else \\<infinity>)\n 3. \\<And>x c1 c2.\n       \\<lbrakk>- x c < d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = 0 \\<and> v c2 = a then Lt d\n                           else \\<infinity>)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x ca.\n       \\<lbrakk>- x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some ca)\n                          (if 0 = 0 \\<and> v ca = a then Lt d\n                           else \\<infinity>)\n 2. \\<And>x ca.\n       \\<lbrakk>- x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = 0 \\<and> 0 = a then Lt d\n                           else \\<infinity>)\n 3. \\<And>x c1 c2.\n       \\<lbrakk>- x c < d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = 0 \\<and> v c2 = a then Lt d\n                           else \\<infinity>)", "case (2 u c)"], ["proof (state)\nthis:\n  - u c < d\n  v c \\<le> n\n\ngoal (3 subgoals):\n 1. \\<And>x ca.\n       \\<lbrakk>- x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some ca)\n                          (if 0 = 0 \\<and> v ca = a then Lt d\n                           else \\<infinity>)\n 2. \\<And>x ca.\n       \\<lbrakk>- x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = 0 \\<and> 0 = a then Lt d\n                           else \\<infinity>)\n 3. \\<And>x c1 c2.\n       \\<lbrakk>- x c < d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = 0 \\<and> v c2 = a then Lt d\n                           else \\<infinity>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c)\n     (if 0 = 0 \\<and> v c = a then Lt d else \\<infinity>)", "proof (cases \"v c = a\", goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. v c = a \\<Longrightarrow>\n    dbm_entry_val u None (Some c)\n     (if 0 = 0 \\<and> v c = a then Lt d else \\<infinity>)\n 2. v c \\<noteq> a \\<Longrightarrow>\n    dbm_entry_val u None (Some c)\n     (if 0 = 0 \\<and> v c = a then Lt d else \\<infinity>)", "case False"], ["proof (state)\nthis:\n  v c \\<noteq> a\n\ngoal (2 subgoals):\n 1. v c = a \\<Longrightarrow>\n    dbm_entry_val u None (Some c)\n     (if 0 = 0 \\<and> v c = a then Lt d else \\<infinity>)\n 2. v c \\<noteq> a \\<Longrightarrow>\n    dbm_entry_val u None (Some c)\n     (if 0 = 0 \\<and> v c = a then Lt d else \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  v c \\<noteq> a", "show ?thesis"], ["proof (prove)\nusing this:\n  v c \\<noteq> a\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c)\n     (if 0 = 0 \\<and> v c = a then Lt d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u None (Some c)\n   (if 0 = 0 \\<and> v c = a then Lt d else \\<infinity>)\n\ngoal (1 subgoal):\n 1. v c = a \\<Longrightarrow>\n    dbm_entry_val u None (Some c)\n     (if 0 = 0 \\<and> v c = a then Lt d else \\<infinity>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v c = a \\<Longrightarrow>\n    dbm_entry_val u None (Some c)\n     (if 0 = 0 \\<and> v c = a then Lt d else \\<infinity>)", "case True"], ["proof (state)\nthis:\n  v c = a\n\ngoal (1 subgoal):\n 1. v c = a \\<Longrightarrow>\n    dbm_entry_val u None (Some c)\n     (if 0 = 0 \\<and> v c = a then Lt d else \\<infinity>)", "with 2 clock_numbering C \\<open>a \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  - u c < d\n  v c \\<le> n\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  v c = a\n  a \\<le> n\n  v c = a", "have \"- u c < d\""], ["proof (prove)\nusing this:\n  - u c < d\n  v c \\<le> n\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  v c = a\n  a \\<le> n\n  v c = a\n\ngoal (1 subgoal):\n 1. - u c < d", "by metis"], ["proof (state)\nthis:\n  - u c < d\n\ngoal (1 subgoal):\n 1. v c = a \\<Longrightarrow>\n    dbm_entry_val u None (Some c)\n     (if 0 = 0 \\<and> v c = a then Lt d else \\<infinity>)", "with C"], ["proof (chain)\npicking this:\n  v c = a\n  - u c < d", "show ?thesis"], ["proof (prove)\nusing this:\n  v c = a\n  - u c < d\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c)\n     (if 0 = 0 \\<and> v c = a then Lt d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u None (Some c)\n   (if 0 = 0 \\<and> v c = a then Lt d else \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dbm_entry_val u None (Some c)\n   (if 0 = 0 \\<and> v c = a then Lt d else \\<infinity>)\n\ngoal (2 subgoals):\n 1. \\<And>x ca.\n       \\<lbrakk>- x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = 0 \\<and> 0 = a then Lt d\n                           else \\<infinity>)\n 2. \\<And>x c1 c2.\n       \\<lbrakk>- x c < d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = 0 \\<and> v c2 = a then Lt d\n                           else \\<infinity>)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x ca.\n       \\<lbrakk>- x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = 0 \\<and> 0 = a then Lt d\n                           else \\<infinity>)\n 2. \\<And>x c1 c2.\n       \\<lbrakk>- x c < d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = 0 \\<and> v c2 = a then Lt d\n                           else \\<infinity>)", "case (3 u)"], ["proof (state)\nthis:\n  - u c < d\n  v c_ \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>x ca.\n       \\<lbrakk>- x c < d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = 0 \\<and> 0 = a then Lt d\n                           else \\<infinity>)\n 2. \\<And>x c1 c2.\n       \\<lbrakk>- x c < d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = 0 \\<and> v c2 = a then Lt d\n                           else \\<infinity>)", "with not0"], ["proof (chain)\npicking this:\n  0 < a\n  - u c < d\n  v c_ \\<le> n", "show ?case"], ["proof (prove)\nusing this:\n  0 < a\n  - u c < d\n  v c_ \\<le> n\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c_) None\n     (if v c_ = 0 \\<and> 0 = a then Lt d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c_) None\n   (if v c_ = 0 \\<and> 0 = a then Lt d else \\<infinity>)\n\ngoal (1 subgoal):\n 1. \\<And>x c1 c2.\n       \\<lbrakk>- x c < d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = 0 \\<and> v c2 = a then Lt d\n                           else \\<infinity>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x c1 c2.\n       \\<lbrakk>- x c < d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = 0 \\<and> v c2 = a then Lt d\n                           else \\<infinity>)", "case (4 u' y z)"], ["proof (state)\nthis:\n  - u' c < d\n  v y \\<le> n\n  v z \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>x c1 c2.\n       \\<lbrakk>- x c < d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = 0 \\<and> v c2 = a then Lt d\n                           else \\<infinity>)", "from clock_numbering(1)"], ["proof (chain)\npicking this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)", "have \"0 < v y\""], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n\ngoal (1 subgoal):\n 1. 0 < v y", "by auto"], ["proof (state)\nthis:\n  0 < v y\n\ngoal (1 subgoal):\n 1. \\<And>x c1 c2.\n       \\<lbrakk>- x c < d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = 0 \\<and> v c2 = a then Lt d\n                           else \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  0 < v y", "show ?case"], ["proof (prove)\nusing this:\n  0 < v y\n\ngoal (1 subgoal):\n 1. dbm_entry_val u' (Some y) (Some z)\n     (if v y = 0 \\<and> v z = a then Lt d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u' (Some y) (Some z)\n   (if v y = 0 \\<and> v z = a then Lt d else \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {u. - u c < d}\n  \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Lt d\n  else \\<infinity>) \\<and>\n                  (\\<forall>c.\n                      v c \\<le> n \\<longrightarrow>\n                      dbm_entry_val u None (Some c)\n                       (if 0 = 0 \\<and> v c = a then Lt d\n                        else \\<infinity>) \\<and>\n                      dbm_entry_val u (Some c) None\n                       (if v c = 0 \\<and> 0 = a then Lt d\n                        else \\<infinity>)) \\<and>\n                  (\\<forall>c1 c2.\n                      v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                      dbm_entry_val u (Some c1) (Some c2)\n                       (if v c1 = 0 \\<and> v c2 = a then Lt d\n                        else \\<infinity>))}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma len_int_closed:\n  \"\\<forall> i j. (M i j :: real) \\<in> \\<int> \\<Longrightarrow> len M i j xs \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j. M i j \\<in> \\<int> \\<Longrightarrow>\n    len M i j xs \\<in> \\<int>", "by (induction xs arbitrary: i) auto"], ["", "lemma get_const_distr:\n  \"a \\<noteq> \\<infinity> \\<Longrightarrow> b \\<noteq> \\<infinity> \\<Longrightarrow> get_const (a + b) = get_const a + get_const b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a \\<noteq> \\<infinity>; b \\<noteq> \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> get_const (a + b) = get_const a + get_const b", "by (cases a) (cases b, auto simp: mult)+"], ["", "lemma len_int_dbm_closed:\n  \"\\<forall> (i, j) \\<in> set (arcs i j xs). (get_const (M i j) :: real) \\<in> \\<int> \\<and> M i j \\<noteq> \\<infinity>\n  \\<Longrightarrow> get_const (len M i j xs) \\<in> \\<int> \\<and> len M i j xs \\<noteq> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(i, j)\\<in>set (arcs i j xs).\n       get_const (M i j) \\<in> \\<int> \\<and>\n       M i j \\<noteq> \\<infinity> \\<Longrightarrow>\n    get_const (len M i j xs) \\<in> \\<int> \\<and>\n    len M i j xs \\<noteq> \\<infinity>", "by (induction xs arbitrary: i) (auto simp: get_const_distr, simp add: dbm_add_not_inf mult)"], ["", "lemma zone_diag_le_3:\n  assumes \"a \\<le> n\" and C: \"v c = a\" and not0: \"a > 0\"\n  shows \"[(\\<lambda> i j. if i = 0 \\<and> j = a then Le d else \\<infinity>)]\\<^bsub>v,n\\<^esub> = {u. - u c \\<le> d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(\\<lambda>i j.\n         if i = 0 \\<and> j = a then Le d\n         else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n    {u. - u c \\<le> d}", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Le d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = 0 \\<and> v c = a then Le d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = 0 \\<and> 0 = a then Le d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = 0 \\<and> v c2 = a then Le d else \\<infinity>))} =\n    {u. - u c \\<le> d}", "proof (rule, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Le d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = 0 \\<and> v c = a then Le d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = 0 \\<and> 0 = a then Le d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = 0 \\<and> v c2 = a then Le d else \\<infinity>))}\n    \\<subseteq> {u. - u c \\<le> d}\n 2. {u. - u c \\<le> d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Le d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = 0 \\<and> v c = a then Le d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = 0 \\<and> 0 = a then Le d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = 0 \\<and> v c2 = a then Le d\n                          else \\<infinity>))}", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Le d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = 0 \\<and> v c = a then Le d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = 0 \\<and> 0 = a then Le d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = 0 \\<and> v c2 = a then Le d else \\<infinity>))}\n    \\<subseteq> {u. - u c \\<le> d}\n 2. {u. - u c \\<le> d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Le d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = 0 \\<and> v c = a then Le d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = 0 \\<and> 0 = a then Le d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = 0 \\<and> v c2 = a then Le d\n                          else \\<infinity>))}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Le d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = 0 \\<and> v c = a then Le d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = 0 \\<and> 0 = a then Le d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = 0 \\<and> v c2 = a then Le d else \\<infinity>))}\n    \\<subseteq> {u. - u c \\<le> d}", "using \\<open>a \\<le> n\\<close> C"], ["proof (prove)\nusing this:\n  a \\<le> n\n  v c = a\n\ngoal (1 subgoal):\n 1. {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Le d\n                              else \\<infinity>) \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c)\n             (if 0 = 0 \\<and> v c = a then Le d else \\<infinity>) \\<and>\n            dbm_entry_val u (Some c) None\n             (if v c = 0 \\<and> 0 = a then Le d else \\<infinity>)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (if v c1 = 0 \\<and> v c2 = a then Le d else \\<infinity>))}\n    \\<subseteq> {u. - u c \\<le> d}", "by fastforce"], ["proof (state)\nthis:\n  {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Le d\n                            else \\<infinity>) \\<and>\n      (\\<forall>c.\n          v c \\<le> n \\<longrightarrow>\n          dbm_entry_val u None (Some c)\n           (if 0 = 0 \\<and> v c = a then Le d else \\<infinity>) \\<and>\n          dbm_entry_val u (Some c) None\n           (if v c = 0 \\<and> 0 = a then Le d else \\<infinity>)) \\<and>\n      (\\<forall>c1 c2.\n          v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n          dbm_entry_val u (Some c1) (Some c2)\n           (if v c1 = 0 \\<and> v c2 = a then Le d else \\<infinity>))}\n  \\<subseteq> {u. - u c \\<le> d}\n\ngoal (1 subgoal):\n 1. {u. - u c \\<le> d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Le d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = 0 \\<and> v c = a then Le d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = 0 \\<and> 0 = a then Le d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = 0 \\<and> v c2 = a then Le d\n                          else \\<infinity>))}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {u. - u c \\<le> d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Le d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = 0 \\<and> v c = a then Le d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = 0 \\<and> 0 = a then Le d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = 0 \\<and> v c2 = a then Le d\n                          else \\<infinity>))}", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. {u. - u c \\<le> d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Le d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = 0 \\<and> v c = a then Le d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = 0 \\<and> 0 = a then Le d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = 0 \\<and> v c2 = a then Le d\n                          else \\<infinity>))}", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. {u. - u c \\<le> d}\n    \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Le d\n    else \\<infinity>) \\<and>\n                    (\\<forall>c.\n                        v c \\<le> n \\<longrightarrow>\n                        dbm_entry_val u None (Some c)\n                         (if 0 = 0 \\<and> v c = a then Le d\n                          else \\<infinity>) \\<and>\n                        dbm_entry_val u (Some c) None\n                         (if v c = 0 \\<and> 0 = a then Le d\n                          else \\<infinity>)) \\<and>\n                    (\\<forall>c1 c2.\n                        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                        dbm_entry_val u (Some c1) (Some c2)\n                         (if v c1 = 0 \\<and> v c2 = a then Le d\n                          else \\<infinity>))}", "proof (safe, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       - x c \\<le> d \\<Longrightarrow>\n       Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Le d\n                             else \\<infinity>)\n 2. \\<And>x ca.\n       \\<lbrakk>- x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some ca)\n                          (if 0 = 0 \\<and> v ca = a then Le d\n                           else \\<infinity>)\n 3. \\<And>x ca.\n       \\<lbrakk>- x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = 0 \\<and> 0 = a then Le d\n                           else \\<infinity>)\n 4. \\<And>x c1 c2.\n       \\<lbrakk>- x c \\<le> d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = 0 \\<and> v c2 = a then Le d\n                           else \\<infinity>)", "case 1"], ["proof (state)\nthis:\n  - x_ c \\<le> d\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       - x c \\<le> d \\<Longrightarrow>\n       Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Le d\n                             else \\<infinity>)\n 2. \\<And>x ca.\n       \\<lbrakk>- x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some ca)\n                          (if 0 = 0 \\<and> v ca = a then Le d\n                           else \\<infinity>)\n 3. \\<And>x ca.\n       \\<lbrakk>- x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = 0 \\<and> 0 = a then Le d\n                           else \\<infinity>)\n 4. \\<And>x c1 c2.\n       \\<lbrakk>- x c \\<le> d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = 0 \\<and> v c2 = a then Le d\n                           else \\<infinity>)", "from not0"], ["proof (chain)\npicking this:\n  0 < a", "show ?case"], ["proof (prove)\nusing this:\n  0 < a\n\ngoal (1 subgoal):\n 1. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Le d else \\<infinity>)", "unfolding dbm_le_def"], ["proof (prove)\nusing this:\n  0 < a\n\ngoal (1 subgoal):\n 1. Le (0::'a) \\<prec> (if 0 = 0 \\<and> 0 = a then Le d\n                        else \\<infinity>) \\<or>\n    Le (0::'a) = (if 0 = 0 \\<and> 0 = a then Le d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Le d else \\<infinity>)\n\ngoal (3 subgoals):\n 1. \\<And>x ca.\n       \\<lbrakk>- x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some ca)\n                          (if 0 = 0 \\<and> v ca = a then Le d\n                           else \\<infinity>)\n 2. \\<And>x ca.\n       \\<lbrakk>- x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = 0 \\<and> 0 = a then Le d\n                           else \\<infinity>)\n 3. \\<And>x c1 c2.\n       \\<lbrakk>- x c \\<le> d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = 0 \\<and> v c2 = a then Le d\n                           else \\<infinity>)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x ca.\n       \\<lbrakk>- x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some ca)\n                          (if 0 = 0 \\<and> v ca = a then Le d\n                           else \\<infinity>)\n 2. \\<And>x ca.\n       \\<lbrakk>- x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = 0 \\<and> 0 = a then Le d\n                           else \\<infinity>)\n 3. \\<And>x c1 c2.\n       \\<lbrakk>- x c \\<le> d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = 0 \\<and> v c2 = a then Le d\n                           else \\<infinity>)", "case (2 u c)"], ["proof (state)\nthis:\n  - u c \\<le> d\n  v c \\<le> n\n\ngoal (3 subgoals):\n 1. \\<And>x ca.\n       \\<lbrakk>- x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x None (Some ca)\n                          (if 0 = 0 \\<and> v ca = a then Le d\n                           else \\<infinity>)\n 2. \\<And>x ca.\n       \\<lbrakk>- x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = 0 \\<and> 0 = a then Le d\n                           else \\<infinity>)\n 3. \\<And>x c1 c2.\n       \\<lbrakk>- x c \\<le> d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = 0 \\<and> v c2 = a then Le d\n                           else \\<infinity>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c)\n     (if 0 = 0 \\<and> v c = a then Le d else \\<infinity>)", "proof (cases \"v c = a\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v c = a \\<Longrightarrow>\n    dbm_entry_val u None (Some c)\n     (if 0 = 0 \\<and> v c = a then Le d else \\<infinity>)\n 2. v c \\<noteq> a \\<Longrightarrow>\n    dbm_entry_val u None (Some c)\n     (if 0 = 0 \\<and> v c = a then Le d else \\<infinity>)", "case False"], ["proof (state)\nthis:\n  v c \\<noteq> a\n\ngoal (2 subgoals):\n 1. v c = a \\<Longrightarrow>\n    dbm_entry_val u None (Some c)\n     (if 0 = 0 \\<and> v c = a then Le d else \\<infinity>)\n 2. v c \\<noteq> a \\<Longrightarrow>\n    dbm_entry_val u None (Some c)\n     (if 0 = 0 \\<and> v c = a then Le d else \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  v c \\<noteq> a", "show ?thesis"], ["proof (prove)\nusing this:\n  v c \\<noteq> a\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c)\n     (if 0 = 0 \\<and> v c = a then Le d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u None (Some c)\n   (if 0 = 0 \\<and> v c = a then Le d else \\<infinity>)\n\ngoal (1 subgoal):\n 1. v c = a \\<Longrightarrow>\n    dbm_entry_val u None (Some c)\n     (if 0 = 0 \\<and> v c = a then Le d else \\<infinity>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v c = a \\<Longrightarrow>\n    dbm_entry_val u None (Some c)\n     (if 0 = 0 \\<and> v c = a then Le d else \\<infinity>)", "case True"], ["proof (state)\nthis:\n  v c = a\n\ngoal (1 subgoal):\n 1. v c = a \\<Longrightarrow>\n    dbm_entry_val u None (Some c)\n     (if 0 = 0 \\<and> v c = a then Le d else \\<infinity>)", "with 2 clock_numbering C \\<open>a \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  - u c \\<le> d\n  v c \\<le> n\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  v c = a\n  a \\<le> n\n  v c = a", "have \"- u c \\<le> d\""], ["proof (prove)\nusing this:\n  - u c \\<le> d\n  v c \\<le> n\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  v c = a\n  a \\<le> n\n  v c = a\n\ngoal (1 subgoal):\n 1. - u c \\<le> d", "by metis"], ["proof (state)\nthis:\n  - u c \\<le> d\n\ngoal (1 subgoal):\n 1. v c = a \\<Longrightarrow>\n    dbm_entry_val u None (Some c)\n     (if 0 = 0 \\<and> v c = a then Le d else \\<infinity>)", "with C"], ["proof (chain)\npicking this:\n  v c = a\n  - u c \\<le> d", "show ?thesis"], ["proof (prove)\nusing this:\n  v c = a\n  - u c \\<le> d\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c)\n     (if 0 = 0 \\<and> v c = a then Le d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u None (Some c)\n   (if 0 = 0 \\<and> v c = a then Le d else \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dbm_entry_val u None (Some c)\n   (if 0 = 0 \\<and> v c = a then Le d else \\<infinity>)\n\ngoal (2 subgoals):\n 1. \\<And>x ca.\n       \\<lbrakk>- x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = 0 \\<and> 0 = a then Le d\n                           else \\<infinity>)\n 2. \\<And>x c1 c2.\n       \\<lbrakk>- x c \\<le> d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = 0 \\<and> v c2 = a then Le d\n                           else \\<infinity>)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x ca.\n       \\<lbrakk>- x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = 0 \\<and> 0 = a then Le d\n                           else \\<infinity>)\n 2. \\<And>x c1 c2.\n       \\<lbrakk>- x c \\<le> d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = 0 \\<and> v c2 = a then Le d\n                           else \\<infinity>)", "case (3 u)"], ["proof (state)\nthis:\n  - u c \\<le> d\n  v c_ \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>x ca.\n       \\<lbrakk>- x c \\<le> d; v ca \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some ca) None\n                          (if v ca = 0 \\<and> 0 = a then Le d\n                           else \\<infinity>)\n 2. \\<And>x c1 c2.\n       \\<lbrakk>- x c \\<le> d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = 0 \\<and> v c2 = a then Le d\n                           else \\<infinity>)", "with not0"], ["proof (chain)\npicking this:\n  0 < a\n  - u c \\<le> d\n  v c_ \\<le> n", "show ?case"], ["proof (prove)\nusing this:\n  0 < a\n  - u c \\<le> d\n  v c_ \\<le> n\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c_) None\n     (if v c_ = 0 \\<and> 0 = a then Le d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c_) None\n   (if v c_ = 0 \\<and> 0 = a then Le d else \\<infinity>)\n\ngoal (1 subgoal):\n 1. \\<And>x c1 c2.\n       \\<lbrakk>- x c \\<le> d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = 0 \\<and> v c2 = a then Le d\n                           else \\<infinity>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x c1 c2.\n       \\<lbrakk>- x c \\<le> d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = 0 \\<and> v c2 = a then Le d\n                           else \\<infinity>)", "case (4 u' y z)"], ["proof (state)\nthis:\n  - u' c \\<le> d\n  v y \\<le> n\n  v z \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>x c1 c2.\n       \\<lbrakk>- x c \\<le> d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = 0 \\<and> v c2 = a then Le d\n                           else \\<infinity>)", "from clock_numbering(1)"], ["proof (chain)\npicking this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)", "have \"0 < v y\""], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n\ngoal (1 subgoal):\n 1. 0 < v y", "by auto"], ["proof (state)\nthis:\n  0 < v y\n\ngoal (1 subgoal):\n 1. \\<And>x c1 c2.\n       \\<lbrakk>- x c \\<le> d; v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val x (Some c1) (Some c2)\n                          (if v c1 = 0 \\<and> v c2 = a then Le d\n                           else \\<infinity>)", "then"], ["proof (chain)\npicking this:\n  0 < v y", "show ?case"], ["proof (prove)\nusing this:\n  0 < v y\n\ngoal (1 subgoal):\n 1. dbm_entry_val u' (Some y) (Some z)\n     (if v y = 0 \\<and> v z = a then Le d else \\<infinity>)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u' (Some y) (Some z)\n   (if v y = 0 \\<and> v z = a then Le d else \\<infinity>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {u. - u c \\<le> d}\n  \\<subseteq> {u. Le (0::'a) \\<preceq> (if 0 = 0 \\<and> 0 = a then Le d\n  else \\<infinity>) \\<and>\n                  (\\<forall>c.\n                      v c \\<le> n \\<longrightarrow>\n                      dbm_entry_val u None (Some c)\n                       (if 0 = 0 \\<and> v c = a then Le d\n                        else \\<infinity>) \\<and>\n                      dbm_entry_val u (Some c) None\n                       (if v c = 0 \\<and> 0 = a then Le d\n                        else \\<infinity>)) \\<and>\n                  (\\<forall>c1 c2.\n                      v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                      dbm_entry_val u (Some c1) (Some c2)\n                       (if v c1 = 0 \\<and> v c2 = a then Le d\n                        else \\<infinity>))}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dbm_lt':\n  assumes \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\" \"M a b \\<le> Lt d\" \"a \\<le> n\" \"b \\<le> n\" \"v c1 = a\" \"v c2 = b\" \"a > 0\" \"b > 0\"\n  shows \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 < d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 < d}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 < d}", "from assms"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\n  M a b \\<le> Lt d\n  a \\<le> n\n  b \\<le> n\n  v c1 = a\n  v c2 = b\n  0 < a\n  0 < b", "have \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> [(\\<lambda> i j. if i = a \\<and> j = b then Lt d else \\<infinity>)]\\<^bsub>v,n\\<^esub>\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\n  M a b \\<le> Lt d\n  a \\<le> n\n  b \\<le> n\n  v c1 = a\n  v c2 = b\n  0 < a\n  0 < b\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub>\n    \\<subseteq> [(\\<lambda>i j.\n                     if i = a \\<and> j = b then Lt d\n                     else \\<infinity>)]\\<^bsub>v,n\\<^esub>", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> \\<subseteq> V;\n        M (v c1) (v c2) \\<le> Lt d; v c1 \\<le> n; v c2 \\<le> n; 0 < v c1;\n        0 < v c2; a = v c1; b = v c2;\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [(\\<lambda>i j.\nif i = v c1 \\<and> j = v c2 then Lt d else \\<infinity>)]\\<^bsub>v,n\\<^esub>", "apply (rule DBM_le_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> \\<subseteq> V;\n        M (v c1) (v c2) \\<le> Lt d; v c1 \\<le> n; v c2 \\<le> n; 0 < v c1;\n        0 < v c2; a = v c1; b = v c2;\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i j.\n                            i \\<le> n \\<longrightarrow>\n                            j \\<le> n \\<longrightarrow>\n                            ?M15 x i\n                             j \\<preceq> (if i = v c1 \\<and> j = v c2\n    then Lt d else \\<infinity>)\n 2. \\<And>x.\n       \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> \\<subseteq> V;\n        M (v c1) (v c2) \\<le> Lt d; v c1 \\<le> n; v c2 \\<le> n; 0 < v c1;\n        0 < v c2; a = v c1; b = v c2;\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [?M15 x]\\<^bsub>v,n\\<^esub>", "unfolding less_eq dbm_le_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> \\<subseteq> V;\n        M (v c1) (v c2) \\<prec> Lt d \\<or> M (v c1) (v c2) = Lt d;\n        v c1 \\<le> n; v c2 \\<le> n; 0 < v c1; 0 < v c2; a = v c1; b = v c2;\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i j.\n                            i \\<le> n \\<longrightarrow>\n                            j \\<le> n \\<longrightarrow>\n                            ?M15 x i\n                             j \\<prec> (if i = v c1 \\<and> j = v c2\n  then Lt d else \\<infinity>) \\<or>\n                            ?M15 x i j =\n                            (if i = v c1 \\<and> j = v c2 then Lt d\n                             else \\<infinity>)\n 2. \\<And>x.\n       \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> \\<subseteq> V;\n        M (v c1) (v c2) \\<prec> Lt d \\<or> M (v c1) (v c2) = Lt d;\n        v c1 \\<le> n; v c2 \\<le> n; 0 < v c1; 0 < v c2; a = v c1; b = v c2;\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [?M15 x]\\<^bsub>v,n\\<^esub>", "by auto"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = a \\<and> j = b then Lt d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 < d}", "moreover"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = a \\<and> j = b then Lt d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 < d}", "from zone_diag_lt[OF \\<open>a \\<le> n\\<close> \\<open>b \\<le> n\\<close> assms(5-)]"], ["proof (chain)\npicking this:\n  [(\\<lambda>i j.\n       if i = a \\<and> j = b then Lt ?d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. u c1 - u c2 < ?d}", "have \"[(\\<lambda> i j. if i = a \\<and> j = b then Lt d else \\<infinity>)]\\<^bsub>v,n\\<^esub> = {u. u c1 - u c2 < d}\""], ["proof (prove)\nusing this:\n  [(\\<lambda>i j.\n       if i = a \\<and> j = b then Lt ?d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. u c1 - u c2 < ?d}\n\ngoal (1 subgoal):\n 1. [(\\<lambda>i j.\n         if i = a \\<and> j = b then Lt d\n         else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n    {u. u c1 - u c2 < d}", "by blast"], ["proof (state)\nthis:\n  [(\\<lambda>i j.\n       if i = a \\<and> j = b then Lt d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. u c1 - u c2 < d}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 < d}", "moreover"], ["proof (state)\nthis:\n  [(\\<lambda>i j.\n       if i = a \\<and> j = b then Lt d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. u c1 - u c2 < d}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 < d}", "from assms"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\n  M a b \\<le> Lt d\n  a \\<le> n\n  b \\<le> n\n  v c1 = a\n  v c2 = b\n  0 < a\n  0 < b", "have \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\n  M a b \\<le> Lt d\n  a \\<le> n\n  b \\<le> n\n  v c1 = a\n  v c2 = b\n  0 < a\n  0 < b\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> V", "by auto"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 < d}", "ultimately"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = a \\<and> j = b then Lt d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n  [(\\<lambda>i j.\n       if i = a \\<and> j = b then Lt d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. u c1 - u c2 < d}\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> V", "show ?thesis"], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = a \\<and> j = b then Lt d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n  [(\\<lambda>i j.\n       if i = a \\<and> j = b then Lt d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. u c1 - u c2 < d}\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 < d}", "by auto"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 < d}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dbm_lt'2:\n  assumes \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\" \"M a 0 \\<le> Lt d\" \"a \\<le> n\" \"v c1 = a\" \"a > 0\"\n  shows \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 < d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 < d}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 < d}", "from assms(2)"], ["proof (chain)\npicking this:\n  M a 0 \\<le> Lt d", "have \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> [(\\<lambda> i j. if i = a \\<and> j = 0 then Lt d else \\<infinity>)]\\<^bsub>v,n\\<^esub>\""], ["proof (prove)\nusing this:\n  M a 0 \\<le> Lt d\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub>\n    \\<subseteq> [(\\<lambda>i j.\n                     if i = a \\<and> j = 0 then Lt d\n                     else \\<infinity>)]\\<^bsub>v,n\\<^esub>", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>M a 0 \\<le> Lt d; x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [(\\<lambda>i j.\nif i = a \\<and> j = 0 then Lt d else \\<infinity>)]\\<^bsub>v,n\\<^esub>", "apply (rule DBM_le_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>M a 0 \\<le> Lt d; x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i j.\n                            i \\<le> n \\<longrightarrow>\n                            j \\<le> n \\<longrightarrow>\n                            ?M2 x i\n                             j \\<preceq> (if i = a \\<and> j = 0 then Lt d\n    else \\<infinity>)\n 2. \\<And>x.\n       \\<lbrakk>M a 0 \\<le> Lt d; x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [?M2 x]\\<^bsub>v,n\\<^esub>", "unfolding less_eq dbm_le_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>M a 0 \\<prec> Lt d \\<or> M a 0 = Lt d;\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i j.\n                            i \\<le> n \\<longrightarrow>\n                            j \\<le> n \\<longrightarrow>\n                            ?M2 x i\n                             j \\<prec> (if i = a \\<and> j = 0 then Lt d\n  else \\<infinity>) \\<or>\n                            ?M2 x i j =\n                            (if i = a \\<and> j = 0 then Lt d\n                             else \\<infinity>)\n 2. \\<And>x.\n       \\<lbrakk>M a 0 \\<prec> Lt d \\<or> M a 0 = Lt d;\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [?M2 x]\\<^bsub>v,n\\<^esub>", "by auto"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = a \\<and> j = 0 then Lt d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 < d}", "moreover"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = a \\<and> j = 0 then Lt d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 < d}", "from zone_diag_lt_2[OF \\<open>a \\<le> n\\<close> assms(4,5)]"], ["proof (chain)\npicking this:\n  [(\\<lambda>i j.\n       if i = a \\<and> j = 0 then Lt ?d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. u c1 < ?d}", "have \"[(\\<lambda> i j. if i = a \\<and> j = 0 then Lt d else \\<infinity>)]\\<^bsub>v,n\\<^esub> = {u. u c1 < d}\""], ["proof (prove)\nusing this:\n  [(\\<lambda>i j.\n       if i = a \\<and> j = 0 then Lt ?d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. u c1 < ?d}\n\ngoal (1 subgoal):\n 1. [(\\<lambda>i j.\n         if i = a \\<and> j = 0 then Lt d\n         else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n    {u. u c1 < d}", "by blast"], ["proof (state)\nthis:\n  [(\\<lambda>i j.\n       if i = a \\<and> j = 0 then Lt d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. u c1 < d}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 < d}", "ultimately"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = a \\<and> j = 0 then Lt d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n  [(\\<lambda>i j.\n       if i = a \\<and> j = 0 then Lt d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. u c1 < d}", "show ?thesis"], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = a \\<and> j = 0 then Lt d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n  [(\\<lambda>i j.\n       if i = a \\<and> j = 0 then Lt d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. u c1 < d}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 < d}", "using assms(1)"], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = a \\<and> j = 0 then Lt d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n  [(\\<lambda>i j.\n       if i = a \\<and> j = 0 then Lt d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. u c1 < d}\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 < d}", "by auto"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 < d}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dbm_lt'3:\n  assumes \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\" \"M 0 a \\<le> Lt d\" \"a \\<le> n\" \"v c1 = a\" \"a > 0\"\n  shows \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c1 < d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c1 < d}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c1 < d}", "from assms(2)"], ["proof (chain)\npicking this:\n  M 0 a \\<le> Lt d", "have \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> [(\\<lambda> i j. if i = 0 \\<and> j = a then Lt d else \\<infinity>)]\\<^bsub>v,n\\<^esub>\""], ["proof (prove)\nusing this:\n  M 0 a \\<le> Lt d\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub>\n    \\<subseteq> [(\\<lambda>i j.\n                     if i = 0 \\<and> j = a then Lt d\n                     else \\<infinity>)]\\<^bsub>v,n\\<^esub>", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>M 0 a \\<le> Lt d; x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [(\\<lambda>i j.\nif i = 0 \\<and> j = a then Lt d else \\<infinity>)]\\<^bsub>v,n\\<^esub>", "apply (rule DBM_le_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>M 0 a \\<le> Lt d; x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i j.\n                            i \\<le> n \\<longrightarrow>\n                            j \\<le> n \\<longrightarrow>\n                            ?M2 x i\n                             j \\<preceq> (if i = 0 \\<and> j = a then Lt d\n    else \\<infinity>)\n 2. \\<And>x.\n       \\<lbrakk>M 0 a \\<le> Lt d; x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [?M2 x]\\<^bsub>v,n\\<^esub>", "unfolding less_eq dbm_le_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>M 0 a \\<prec> Lt d \\<or> M 0 a = Lt d;\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i j.\n                            i \\<le> n \\<longrightarrow>\n                            j \\<le> n \\<longrightarrow>\n                            ?M2 x i\n                             j \\<prec> (if i = 0 \\<and> j = a then Lt d\n  else \\<infinity>) \\<or>\n                            ?M2 x i j =\n                            (if i = 0 \\<and> j = a then Lt d\n                             else \\<infinity>)\n 2. \\<And>x.\n       \\<lbrakk>M 0 a \\<prec> Lt d \\<or> M 0 a = Lt d;\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [?M2 x]\\<^bsub>v,n\\<^esub>", "by auto"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = 0 \\<and> j = a then Lt d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c1 < d}", "moreover"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = 0 \\<and> j = a then Lt d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c1 < d}", "from zone_diag_lt_3[OF \\<open>a \\<le> n\\<close> assms(4,5)]"], ["proof (chain)\npicking this:\n  [(\\<lambda>i j.\n       if i = 0 \\<and> j = a then Lt ?d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. - u c1 < ?d}", "have \"[(\\<lambda> i j. if i = 0 \\<and> j = a then Lt d else \\<infinity>)]\\<^bsub>v,n\\<^esub> = {u. - u c1 < d}\""], ["proof (prove)\nusing this:\n  [(\\<lambda>i j.\n       if i = 0 \\<and> j = a then Lt ?d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. - u c1 < ?d}\n\ngoal (1 subgoal):\n 1. [(\\<lambda>i j.\n         if i = 0 \\<and> j = a then Lt d\n         else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n    {u. - u c1 < d}", "by blast"], ["proof (state)\nthis:\n  [(\\<lambda>i j.\n       if i = 0 \\<and> j = a then Lt d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. - u c1 < d}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c1 < d}", "ultimately"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = 0 \\<and> j = a then Lt d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n  [(\\<lambda>i j.\n       if i = 0 \\<and> j = a then Lt d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. - u c1 < d}", "show ?thesis"], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = 0 \\<and> j = a then Lt d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n  [(\\<lambda>i j.\n       if i = 0 \\<and> j = a then Lt d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. - u c1 < d}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c1 < d}", "using assms(1)"], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = 0 \\<and> j = a then Lt d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n  [(\\<lambda>i j.\n       if i = 0 \\<and> j = a then Lt d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. - u c1 < d}\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c1 < d}", "by auto"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c1 < d}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dbm_le':\n  assumes \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\" \"M a b \\<le> Le d\" \"a \\<le> n\" \"b \\<le> n\" \"v c1 = a\" \"v c2 = b\" \"a > 0\" \"b > 0\"\n  shows \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> d}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> d}", "from assms"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\n  M a b \\<le> Le d\n  a \\<le> n\n  b \\<le> n\n  v c1 = a\n  v c2 = b\n  0 < a\n  0 < b", "have \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> [(\\<lambda> i j. if i = a \\<and> j = b then Le d else \\<infinity>)]\\<^bsub>v,n\\<^esub>\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\n  M a b \\<le> Le d\n  a \\<le> n\n  b \\<le> n\n  v c1 = a\n  v c2 = b\n  0 < a\n  0 < b\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub>\n    \\<subseteq> [(\\<lambda>i j.\n                     if i = a \\<and> j = b then Le d\n                     else \\<infinity>)]\\<^bsub>v,n\\<^esub>", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> \\<subseteq> V;\n        M (v c1) (v c2) \\<le> Le d; v c1 \\<le> n; v c2 \\<le> n; 0 < v c1;\n        0 < v c2; a = v c1; b = v c2;\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [(\\<lambda>i j.\nif i = v c1 \\<and> j = v c2 then Le d else \\<infinity>)]\\<^bsub>v,n\\<^esub>", "apply (rule DBM_le_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> \\<subseteq> V;\n        M (v c1) (v c2) \\<le> Le d; v c1 \\<le> n; v c2 \\<le> n; 0 < v c1;\n        0 < v c2; a = v c1; b = v c2;\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i j.\n                            i \\<le> n \\<longrightarrow>\n                            j \\<le> n \\<longrightarrow>\n                            ?M15 x i\n                             j \\<preceq> (if i = v c1 \\<and> j = v c2\n    then Le d else \\<infinity>)\n 2. \\<And>x.\n       \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> \\<subseteq> V;\n        M (v c1) (v c2) \\<le> Le d; v c1 \\<le> n; v c2 \\<le> n; 0 < v c1;\n        0 < v c2; a = v c1; b = v c2;\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [?M15 x]\\<^bsub>v,n\\<^esub>", "unfolding less_eq dbm_le_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> \\<subseteq> V;\n        M (v c1) (v c2) \\<prec> Le d \\<or> M (v c1) (v c2) = Le d;\n        v c1 \\<le> n; v c2 \\<le> n; 0 < v c1; 0 < v c2; a = v c1; b = v c2;\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i j.\n                            i \\<le> n \\<longrightarrow>\n                            j \\<le> n \\<longrightarrow>\n                            ?M15 x i\n                             j \\<prec> (if i = v c1 \\<and> j = v c2\n  then Le d else \\<infinity>) \\<or>\n                            ?M15 x i j =\n                            (if i = v c1 \\<and> j = v c2 then Le d\n                             else \\<infinity>)\n 2. \\<And>x.\n       \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> \\<subseteq> V;\n        M (v c1) (v c2) \\<prec> Le d \\<or> M (v c1) (v c2) = Le d;\n        v c1 \\<le> n; v c2 \\<le> n; 0 < v c1; 0 < v c2; a = v c1; b = v c2;\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [?M15 x]\\<^bsub>v,n\\<^esub>", "by auto"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = a \\<and> j = b then Le d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> d}", "moreover"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = a \\<and> j = b then Le d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> d}", "from zone_diag_le[OF \\<open>a \\<le> n\\<close> \\<open>b \\<le> n\\<close> assms(5-)]"], ["proof (chain)\npicking this:\n  [(\\<lambda>i j.\n       if i = a \\<and> j = b then Le ?d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. u c1 - u c2 \\<le> ?d}", "have \"[(\\<lambda> i j. if i = a \\<and> j = b then Le d else \\<infinity>)]\\<^bsub>v,n\\<^esub> = {u. u c1 - u c2 \\<le> d}\""], ["proof (prove)\nusing this:\n  [(\\<lambda>i j.\n       if i = a \\<and> j = b then Le ?d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. u c1 - u c2 \\<le> ?d}\n\ngoal (1 subgoal):\n 1. [(\\<lambda>i j.\n         if i = a \\<and> j = b then Le d\n         else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n    {u. u c1 - u c2 \\<le> d}", "by blast"], ["proof (state)\nthis:\n  [(\\<lambda>i j.\n       if i = a \\<and> j = b then Le d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. u c1 - u c2 \\<le> d}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> d}", "moreover"], ["proof (state)\nthis:\n  [(\\<lambda>i j.\n       if i = a \\<and> j = b then Le d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. u c1 - u c2 \\<le> d}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> d}", "from assms"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\n  M a b \\<le> Le d\n  a \\<le> n\n  b \\<le> n\n  v c1 = a\n  v c2 = b\n  0 < a\n  0 < b", "have \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\n  M a b \\<le> Le d\n  a \\<le> n\n  b \\<le> n\n  v c1 = a\n  v c2 = b\n  0 < a\n  0 < b\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> V", "by auto"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> d}", "ultimately"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = a \\<and> j = b then Le d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n  [(\\<lambda>i j.\n       if i = a \\<and> j = b then Le d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. u c1 - u c2 \\<le> d}\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> V", "show ?thesis"], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = a \\<and> j = b then Le d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n  [(\\<lambda>i j.\n       if i = a \\<and> j = b then Le d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. u c1 - u c2 \\<le> d}\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> d}", "by auto"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> d}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dbm_le'2:\n  assumes \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\" \"M a 0 \\<le> Le d\" \"a \\<le> n\" \"v c1 = a\" \"a > 0\"\n  shows \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 \\<le> d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 \\<le> d}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 \\<le> d}", "from assms(2)"], ["proof (chain)\npicking this:\n  M a 0 \\<le> Le d", "have \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> [(\\<lambda> i j. if i = a \\<and> j = 0 then Le d else \\<infinity>)]\\<^bsub>v,n\\<^esub>\""], ["proof (prove)\nusing this:\n  M a 0 \\<le> Le d\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub>\n    \\<subseteq> [(\\<lambda>i j.\n                     if i = a \\<and> j = 0 then Le d\n                     else \\<infinity>)]\\<^bsub>v,n\\<^esub>", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>M a 0 \\<le> Le d; x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [(\\<lambda>i j.\nif i = a \\<and> j = 0 then Le d else \\<infinity>)]\\<^bsub>v,n\\<^esub>", "apply (rule DBM_le_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>M a 0 \\<le> Le d; x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i j.\n                            i \\<le> n \\<longrightarrow>\n                            j \\<le> n \\<longrightarrow>\n                            ?M2 x i\n                             j \\<preceq> (if i = a \\<and> j = 0 then Le d\n    else \\<infinity>)\n 2. \\<And>x.\n       \\<lbrakk>M a 0 \\<le> Le d; x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [?M2 x]\\<^bsub>v,n\\<^esub>", "unfolding less_eq dbm_le_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>M a 0 \\<prec> Le d \\<or> M a 0 = Le d;\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i j.\n                            i \\<le> n \\<longrightarrow>\n                            j \\<le> n \\<longrightarrow>\n                            ?M2 x i\n                             j \\<prec> (if i = a \\<and> j = 0 then Le d\n  else \\<infinity>) \\<or>\n                            ?M2 x i j =\n                            (if i = a \\<and> j = 0 then Le d\n                             else \\<infinity>)\n 2. \\<And>x.\n       \\<lbrakk>M a 0 \\<prec> Le d \\<or> M a 0 = Le d;\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [?M2 x]\\<^bsub>v,n\\<^esub>", "by auto"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = a \\<and> j = 0 then Le d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 \\<le> d}", "moreover"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = a \\<and> j = 0 then Le d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 \\<le> d}", "from zone_diag_le_2[OF \\<open>a \\<le> n\\<close> assms(4,5)]"], ["proof (chain)\npicking this:\n  [(\\<lambda>i j.\n       if i = a \\<and> j = 0 then Le ?d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. u c1 \\<le> ?d}", "have \"[(\\<lambda> i j. if i = a \\<and> j = 0 then Le d else \\<infinity>)]\\<^bsub>v,n\\<^esub> = {u. u c1 \\<le> d}\""], ["proof (prove)\nusing this:\n  [(\\<lambda>i j.\n       if i = a \\<and> j = 0 then Le ?d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. u c1 \\<le> ?d}\n\ngoal (1 subgoal):\n 1. [(\\<lambda>i j.\n         if i = a \\<and> j = 0 then Le d\n         else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n    {u. u c1 \\<le> d}", "by blast"], ["proof (state)\nthis:\n  [(\\<lambda>i j.\n       if i = a \\<and> j = 0 then Le d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. u c1 \\<le> d}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 \\<le> d}", "ultimately"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = a \\<and> j = 0 then Le d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n  [(\\<lambda>i j.\n       if i = a \\<and> j = 0 then Le d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. u c1 \\<le> d}", "show ?thesis"], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = a \\<and> j = 0 then Le d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n  [(\\<lambda>i j.\n       if i = a \\<and> j = 0 then Le d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. u c1 \\<le> d}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 \\<le> d}", "using assms(1)"], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = a \\<and> j = 0 then Le d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n  [(\\<lambda>i j.\n       if i = a \\<and> j = 0 then Le d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. u c1 \\<le> d}\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 \\<le> d}", "by auto"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 \\<le> d}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dbm_le'3:\n  assumes \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\" \"M 0 a \\<le> Le d\" \"a \\<le> n\" \"v c1 = a\" \"a > 0\"\n  shows \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c1 \\<le> d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c1 \\<le> d}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c1 \\<le> d}", "from assms(2)"], ["proof (chain)\npicking this:\n  M 0 a \\<le> Le d", "have \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> [(\\<lambda> i j. if i = 0 \\<and> j = a then Le d else \\<infinity>)]\\<^bsub>v,n\\<^esub>\""], ["proof (prove)\nusing this:\n  M 0 a \\<le> Le d\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub>\n    \\<subseteq> [(\\<lambda>i j.\n                     if i = 0 \\<and> j = a then Le d\n                     else \\<infinity>)]\\<^bsub>v,n\\<^esub>", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>M 0 a \\<le> Le d; x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [(\\<lambda>i j.\nif i = 0 \\<and> j = a then Le d else \\<infinity>)]\\<^bsub>v,n\\<^esub>", "apply (rule DBM_le_subset)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>M 0 a \\<le> Le d; x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i j.\n                            i \\<le> n \\<longrightarrow>\n                            j \\<le> n \\<longrightarrow>\n                            ?M2 x i\n                             j \\<preceq> (if i = 0 \\<and> j = a then Le d\n    else \\<infinity>)\n 2. \\<And>x.\n       \\<lbrakk>M 0 a \\<le> Le d; x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [?M2 x]\\<^bsub>v,n\\<^esub>", "unfolding less_eq dbm_le_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>M 0 a \\<prec> Le d \\<or> M 0 a = Le d;\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>i j.\n                            i \\<le> n \\<longrightarrow>\n                            j \\<le> n \\<longrightarrow>\n                            ?M2 x i\n                             j \\<prec> (if i = 0 \\<and> j = a then Le d\n  else \\<infinity>) \\<or>\n                            ?M2 x i j =\n                            (if i = 0 \\<and> j = a then Le d\n                             else \\<infinity>)\n 2. \\<And>x.\n       \\<lbrakk>M 0 a \\<prec> Le d \\<or> M 0 a = Le d;\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [?M2 x]\\<^bsub>v,n\\<^esub>", "by auto"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = 0 \\<and> j = a then Le d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c1 \\<le> d}", "moreover"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = 0 \\<and> j = a then Le d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c1 \\<le> d}", "from zone_diag_le_3[OF \\<open>a \\<le> n\\<close> assms(4,5)]"], ["proof (chain)\npicking this:\n  [(\\<lambda>i j.\n       if i = 0 \\<and> j = a then Le ?d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. - u c1 \\<le> ?d}", "have \"[(\\<lambda> i j. if i = 0 \\<and> j = a then Le d else \\<infinity>)]\\<^bsub>v,n\\<^esub> = {u. - u c1 \\<le> d}\""], ["proof (prove)\nusing this:\n  [(\\<lambda>i j.\n       if i = 0 \\<and> j = a then Le ?d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. - u c1 \\<le> ?d}\n\ngoal (1 subgoal):\n 1. [(\\<lambda>i j.\n         if i = 0 \\<and> j = a then Le d\n         else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n    {u. - u c1 \\<le> d}", "by blast"], ["proof (state)\nthis:\n  [(\\<lambda>i j.\n       if i = 0 \\<and> j = a then Le d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. - u c1 \\<le> d}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c1 \\<le> d}", "ultimately"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = 0 \\<and> j = a then Le d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n  [(\\<lambda>i j.\n       if i = 0 \\<and> j = a then Le d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. - u c1 \\<le> d}", "show ?thesis"], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = 0 \\<and> j = a then Le d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n  [(\\<lambda>i j.\n       if i = 0 \\<and> j = a then Le d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. - u c1 \\<le> d}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c1 \\<le> d}", "using assms(1)"], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [(\\<lambda>i j.\n                   if i = 0 \\<and> j = a then Le d\n                   else \\<infinity>)]\\<^bsub>v,n\\<^esub>\n  [(\\<lambda>i j.\n       if i = 0 \\<and> j = a then Le d\n       else \\<infinity>)]\\<^bsub>v,n\\<^esub> =\n  {u. - u c1 \\<le> d}\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> V\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c1 \\<le> d}", "by auto"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c1 \\<le> d}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma int_zone_dbm:\n  assumes \"\\<forall> (_,d) \\<in> collect_clock_pairs cc. d \\<in> \\<int>\" \"\\<forall> c \\<in> collect_clks cc. v c \\<le> n\"\n  obtains M where \"{u. u \\<turnstile> cc} = [M]\\<^bsub>v,n\\<^esub>\" and \"dbm_int M n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>{u. u \\<turnstile> cc} = [M]\\<^bsub>v,n\\<^esub>;\n         dbm_int M n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using int_zone_dbm[OF _ assms] clock_numbering(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>c.\n              0 < v c \\<and>\n              (\\<forall>x y.\n                  v x \\<le> n \\<and>\n                  v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n                  x = y);\n   \\<And>M.\n      \\<lbrakk>{u. u \\<turnstile> cc} = [M]\\<^bsub>v,n\\<^esub>;\n       dbm_int M n\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>{u. u \\<turnstile> cc} = [M]\\<^bsub>v,n\\<^esub>;\n         dbm_int M n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemma non_empty_dbm_diag_set':\n  assumes \"clock_numbering' v n\" \"\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<noteq> \\<infinity> \\<longrightarrow> get_const (M i j) \\<in> \\<int>\"\n          \"[M]\\<^bsub>v,n\\<^esub> \\<noteq> {}\"\n  obtains M' where \"[M]\\<^bsub>v,n\\<^esub> = [M']\\<^bsub>v,n\\<^esub> \\<and> (\\<forall>i\\<le>n. \\<forall>j\\<le>n. M' i j \\<noteq> \\<infinity> \\<longrightarrow> get_const (M' i j) \\<in> \\<int>)\n    \\<and> (\\<forall> i \\<le> n. M' i i = \\<one>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        [M]\\<^bsub>v,n\\<^esub> = [M']\\<^bsub>v,n\\<^esub> \\<and>\n        dbm_int M' n \\<and>\n        (\\<forall>i\\<le>n. M' i i = \\<one>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        [M]\\<^bsub>v,n\\<^esub> = [M']\\<^bsub>v,n\\<^esub> \\<and>\n        dbm_int M' n \\<and>\n        (\\<forall>i\\<le>n. M' i i = \\<one>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "let ?M = \"\\<lambda>i j. if i = j then \\<one> else M i j\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        [M]\\<^bsub>v,n\\<^esub> = [M']\\<^bsub>v,n\\<^esub> \\<and>\n        dbm_int M' n \\<and>\n        (\\<forall>i\\<le>n. M' i i = \\<one>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from non_empty_dbm_diag_set[OF assms(1,3)]"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub> =\n  [(\\<lambda>i j. if i = j then \\<one> else M i j)]\\<^bsub>v,n\\<^esub>", "have \"[M]\\<^bsub>v,n\\<^esub> = [?M]\\<^bsub>v,n\\<^esub>\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub> =\n  [(\\<lambda>i j. if i = j then \\<one> else M i j)]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> =\n    [(\\<lambda>i j. if i = j then \\<one> else M i j)]\\<^bsub>v,n\\<^esub>", "by auto"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub> =\n  [(\\<lambda>i j. if i = j then \\<one> else M i j)]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        [M]\\<^bsub>v,n\\<^esub> = [M']\\<^bsub>v,n\\<^esub> \\<and>\n        dbm_int M' n \\<and>\n        (\\<forall>i\\<le>n. M' i i = \\<one>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub> =\n  [(\\<lambda>i j. if i = j then \\<one> else M i j)]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        [M]\\<^bsub>v,n\\<^esub> = [M']\\<^bsub>v,n\\<^esub> \\<and>\n        dbm_int M' n \\<and>\n        (\\<forall>i\\<le>n. M' i i = \\<one>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from assms(2)"], ["proof (chain)\npicking this:\n  dbm_int M n", "have \"\\<forall>i\\<le>n. \\<forall>j\\<le>n. ?M i j \\<noteq> \\<infinity> \\<longrightarrow> get_const (?M i j) \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  dbm_int M n\n\ngoal (1 subgoal):\n 1. dbm_int (\\<lambda>i j. if i = j then \\<one> else M i j) n", "unfolding neutral"], ["proof (prove)\nusing this:\n  dbm_int M n\n\ngoal (1 subgoal):\n 1. dbm_int (\\<lambda>i j. if i = j then Le (0::'a) else M i j) n", "by auto"], ["proof (state)\nthis:\n  dbm_int (\\<lambda>i j. if i = j then \\<one> else M i j) n\n\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        [M]\\<^bsub>v,n\\<^esub> = [M']\\<^bsub>v,n\\<^esub> \\<and>\n        dbm_int M' n \\<and>\n        (\\<forall>i\\<le>n. M' i i = \\<one>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  dbm_int (\\<lambda>i j. if i = j then \\<one> else M i j) n\n\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        [M]\\<^bsub>v,n\\<^esub> = [M']\\<^bsub>v,n\\<^esub> \\<and>\n        dbm_int M' n \\<and>\n        (\\<forall>i\\<le>n. M' i i = \\<one>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"\\<forall> i \\<le> n. ?M i i = \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>n. (if i = i then \\<one> else M i i) = \\<one>", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n. (if i = i then \\<one> else M i i) = \\<one>\n\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        [M]\\<^bsub>v,n\\<^esub> = [M']\\<^bsub>v,n\\<^esub> \\<and>\n        dbm_int M' n \\<and>\n        (\\<forall>i\\<le>n. M' i i = \\<one>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub> =\n  [(\\<lambda>i j. if i = j then \\<one> else M i j)]\\<^bsub>v,n\\<^esub>\n  dbm_int (\\<lambda>i j. if i = j then \\<one> else M i j) n\n  \\<forall>i\\<le>n. (if i = i then \\<one> else M i i) = \\<one>", "show ?thesis"], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub> =\n  [(\\<lambda>i j. if i = j then \\<one> else M i j)]\\<^bsub>v,n\\<^esub>\n  dbm_int (\\<lambda>i j. if i = j then \\<one> else M i j) n\n  \\<forall>i\\<le>n. (if i = i then \\<one> else M i i) = \\<one>\n\ngoal (1 subgoal):\n 1. thesis", "by (auto intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dbm_entry_int:\n  \"x \\<noteq> \\<infinity> \\<Longrightarrow> get_const x \\<in> \\<int> \\<Longrightarrow> \\<exists> d :: int. x = Le d \\<or> x = Lt d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> \\<infinity>; get_const x \\<in> \\<int>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         x = Le (real_of_int d) \\<or> x = Lt (real_of_int d)", "apply (cases x)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>x \\<noteq> \\<infinity>; get_const x \\<in> \\<int>;\n        x = Le x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            x = Le (real_of_int d) \\<or>\n                            x = Lt (real_of_int d)\n 2. \\<And>x2.\n       \\<lbrakk>x \\<noteq> \\<infinity>; get_const x \\<in> \\<int>;\n        x = Lt x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            x = Le (real_of_int d) \\<or>\n                            x = Lt (real_of_int d)\n 3. \\<lbrakk>x \\<noteq> \\<infinity>; get_const x \\<in> \\<int>;\n     x = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         x = Le (real_of_int d) \\<or> x = Lt (real_of_int d)", "using Ints_cases"], ["proof (prove)\nusing this:\n  \\<lbrakk>?q \\<in> \\<int>;\n   \\<And>z. ?q = of_int z \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>x \\<noteq> \\<infinity>; get_const x \\<in> \\<int>;\n        x = Le x1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            x = Le (real_of_int d) \\<or>\n                            x = Lt (real_of_int d)\n 2. \\<And>x2.\n       \\<lbrakk>x \\<noteq> \\<infinity>; get_const x \\<in> \\<int>;\n        x = Lt x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            x = Le (real_of_int d) \\<or>\n                            x = Lt (real_of_int d)\n 3. \\<lbrakk>x \\<noteq> \\<infinity>; get_const x \\<in> \\<int>;\n     x = \\<infinity>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         x = Le (real_of_int d) \\<or> x = Lt (real_of_int d)", "by auto"], ["", "abbreviation \"vabstr \\<equiv> beta_interp.vabstr\""], ["", "section \\<open>Bouyer's Main Theorem\\<close>"], ["", "theorem region_zone_intersect_empty_approx_correct:\n  assumes \"R \\<in> \\<R>\" \"Z \\<subseteq> V\" \"R \\<inter> Z = {}\" \"vabstr Z M\"\n  shows \"R \\<inter> Approx\\<^sub>\\<beta> Z = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "define v' where \"v' i = (THE c. c \\<in> X \\<and> v c = i)\" for i"], ["proof (state)\nthis:\n  v' ?i = (THE c. c \\<in> X \\<and> v c = ?i)\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from region_dbm[OF assms(1)]"], ["proof (chain)\npicking this:\n  (\\<And>M.\n      \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n       \\<forall>i\\<le>n.\n          \\<forall>j\\<le>n.\n             M i 0 = \\<infinity> \\<and>\n             0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n             M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n       \\<forall>i\\<le>n. M i i = Le 0;\n       \\<forall>i\\<le>n.\n          \\<forall>j\\<le>n.\n             0 < i \\<and>\n             0 < j \\<and>\n             M i 0 \\<noteq> \\<infinity> \\<and>\n             M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n             (\\<exists>d.\n                 - int (k (THE c. c \\<in> X \\<and> v c = j)) \\<le> d \\<and>\n                 d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i)) \\<and>\n                 M i j = Le (real_of_int d) \\<and>\n                 M j i = Le (real_of_int (- d)) \\<or>\n                 - int (k (THE c. c \\<in> X \\<and> v c = j))\n                 \\<le> d - 1 \\<and>\n                 d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i)) \\<and>\n                 M i j = Lt (real_of_int d) \\<and>\n                 M j i = Lt (real_of_int (- d + 1)));\n       \\<forall>i\\<le>n.\n          0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n          (\\<exists>d\\<le>int (k (THE c. c \\<in> X \\<and> v c = i)).\n              0 \\<le> d \\<and>\n              (M i 0 = Le (real_of_int d) \\<and>\n               M 0 i = Le (real_of_int (- d)) \\<or>\n               M i 0 = Lt (real_of_int d) \\<and>\n               M 0 i = Lt (real_of_int (- d + 1))));\n       \\<forall>i\\<le>n.\n          0 < i \\<longrightarrow>\n          (\\<exists>d\\<ge>- int (k (THE c. c \\<in> X \\<and> v c = i)).\n              d \\<le> 0 \\<and>\n              (M 0 i = Le (real_of_int d) \\<or>\n               M 0 i = Lt (real_of_int d)));\n       \\<forall>i j.\n          M i j \\<noteq> \\<infinity> \\<longrightarrow>\n          get_const (M i j) \\<in> \\<int>;\n       \\<forall>i\\<le>n.\n          \\<forall>j\\<le>n.\n             M i j \\<noteq> \\<infinity> \\<and>\n             0 < i \\<and> 0 < j \\<longrightarrow>\n             (\\<exists>d.\n                 (M i j = Le (real_of_int d) \\<or>\n                  M i j = Lt (real_of_int d)) \\<and>\n                 - int (k (THE c. c \\<in> X \\<and> v c = j)) \\<le> d \\<and>\n                 d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i)))\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain M\\<^sub>R where M\\<^sub>R:\n    \"[M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\" \"\\<forall>i\\<le>n. \\<forall>j\\<le>n. M\\<^sub>R i 0 = \\<infinity> \\<and> 0 < j \\<and> i \\<noteq> j \\<longrightarrow> M\\<^sub>R i j = \\<infinity> \\<and> M\\<^sub>R j i = \\<infinity>\"\n    \"\\<forall>i\\<le>n. M\\<^sub>R i i = Le 0\"\n    \"\\<forall>i\\<le>n. \\<forall>j\\<le>n. 0 < i \\<and> 0 < j \\<and> M\\<^sub>R i 0 \\<noteq> \\<infinity> \\<and> M\\<^sub>R j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n     (\\<exists>d. - int (k (THE c. c \\<in> X \\<and> v c = j)) \\<le> d \\<and> d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i))\n          \\<and> M\\<^sub>R i j = Le d \\<and> M\\<^sub>R j i = Le (real_of_int (- d))\n        \\<or> - int (k (THE c. c \\<in> X \\<and> v c = j)) \\<le> d - 1 \\<and> d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i))\n          \\<and> M\\<^sub>R i j = Lt d \\<and> M\\<^sub>R j i = Lt (real_of_int (- d + 1)))\"\n    \"\\<forall>i\\<le>n. 0 < i \\<and> M\\<^sub>R i 0 \\<noteq> \\<infinity> \\<longrightarrow> (\\<exists>d\\<le>int (k (THE c. c \\<in> X \\<and> v c = i)). d \\<ge> 0 \\<and>\n      (M\\<^sub>R i 0 = Le d \\<and> M\\<^sub>R 0 i = Le (real_of_int (- d)) \\<or> M\\<^sub>R i 0 = Lt d \\<and> M\\<^sub>R 0 i = Lt (real_of_int (- d + 1))))\"\n    \"\\<forall>i\\<le>n. 0 < i \\<longrightarrow> (\\<exists>d\\<ge>- int (k (THE c. c \\<in> X \\<and> v c = i)). d \\<le> 0 \\<and> (M\\<^sub>R 0 i = Le d \\<or> M\\<^sub>R 0 i = Lt d))\"\n    \"\\<forall>i j. M\\<^sub>R i j \\<noteq> \\<infinity> \\<longrightarrow> get_const (M\\<^sub>R i j) \\<in> \\<int>\"\n    \"\\<forall>i\\<le>n. \\<forall>j\\<le>n. M\\<^sub>R i j \\<noteq> \\<infinity> \\<and> 0 < i \\<and> 0 < j \\<longrightarrow> (\\<exists>d. (M\\<^sub>R i j = Le d \\<or> M\\<^sub>R i j = Lt d)\n        \\<and> - int (k (THE c. c \\<in> X \\<and> v c = j)) \\<le> d \\<and> d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i)))\""], ["proof (prove)\nusing this:\n  (\\<And>M.\n      \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = R;\n       \\<forall>i\\<le>n.\n          \\<forall>j\\<le>n.\n             M i 0 = \\<infinity> \\<and>\n             0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n             M i j = \\<infinity> \\<and> M j i = \\<infinity>;\n       \\<forall>i\\<le>n. M i i = Le 0;\n       \\<forall>i\\<le>n.\n          \\<forall>j\\<le>n.\n             0 < i \\<and>\n             0 < j \\<and>\n             M i 0 \\<noteq> \\<infinity> \\<and>\n             M j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n             (\\<exists>d.\n                 - int (k (THE c. c \\<in> X \\<and> v c = j)) \\<le> d \\<and>\n                 d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i)) \\<and>\n                 M i j = Le (real_of_int d) \\<and>\n                 M j i = Le (real_of_int (- d)) \\<or>\n                 - int (k (THE c. c \\<in> X \\<and> v c = j))\n                 \\<le> d - 1 \\<and>\n                 d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i)) \\<and>\n                 M i j = Lt (real_of_int d) \\<and>\n                 M j i = Lt (real_of_int (- d + 1)));\n       \\<forall>i\\<le>n.\n          0 < i \\<and> M i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n          (\\<exists>d\\<le>int (k (THE c. c \\<in> X \\<and> v c = i)).\n              0 \\<le> d \\<and>\n              (M i 0 = Le (real_of_int d) \\<and>\n               M 0 i = Le (real_of_int (- d)) \\<or>\n               M i 0 = Lt (real_of_int d) \\<and>\n               M 0 i = Lt (real_of_int (- d + 1))));\n       \\<forall>i\\<le>n.\n          0 < i \\<longrightarrow>\n          (\\<exists>d\\<ge>- int (k (THE c. c \\<in> X \\<and> v c = i)).\n              d \\<le> 0 \\<and>\n              (M 0 i = Le (real_of_int d) \\<or>\n               M 0 i = Lt (real_of_int d)));\n       \\<forall>i j.\n          M i j \\<noteq> \\<infinity> \\<longrightarrow>\n          get_const (M i j) \\<in> \\<int>;\n       \\<forall>i\\<le>n.\n          \\<forall>j\\<le>n.\n             M i j \\<noteq> \\<infinity> \\<and>\n             0 < i \\<and> 0 < j \\<longrightarrow>\n             (\\<exists>d.\n                 (M i j = Le (real_of_int d) \\<or>\n                  M i j = Lt (real_of_int d)) \\<and>\n                 - int (k (THE c. c \\<in> X \\<and> v c = j)) \\<le> d \\<and>\n                 d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i)))\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>M\\<^sub>R.\n        \\<lbrakk>[M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M\\<^sub>R i 0 = \\<infinity> \\<and>\n               0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n               M\\<^sub>R i j = \\<infinity> \\<and>\n               M\\<^sub>R j i = \\<infinity>;\n         \\<forall>i\\<le>n. M\\<^sub>R i i = Le 0;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               0 < i \\<and>\n               0 < j \\<and>\n               M\\<^sub>R i 0 \\<noteq> \\<infinity> \\<and>\n               M\\<^sub>R j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n               (\\<exists>d.\n                   - int (k (THE c. c \\<in> X \\<and> v c = j))\n                   \\<le> d \\<and>\n                   d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i)) \\<and>\n                   M\\<^sub>R i j = Le (real_of_int d) \\<and>\n                   M\\<^sub>R j i = Le (real_of_int (- d)) \\<or>\n                   - int (k (THE c. c \\<in> X \\<and> v c = j))\n                   \\<le> d - 1 \\<and>\n                   d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i)) \\<and>\n                   M\\<^sub>R i j = Lt (real_of_int d) \\<and>\n                   M\\<^sub>R j i = Lt (real_of_int (- d + 1)));\n         \\<forall>i\\<le>n.\n            0 < i \\<and>\n            M\\<^sub>R i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n            (\\<exists>d\\<le>int (k (THE c. c \\<in> X \\<and> v c = i)).\n                0 \\<le> d \\<and>\n                (M\\<^sub>R i 0 = Le (real_of_int d) \\<and>\n                 M\\<^sub>R 0 i = Le (real_of_int (- d)) \\<or>\n                 M\\<^sub>R i 0 = Lt (real_of_int d) \\<and>\n                 M\\<^sub>R 0 i = Lt (real_of_int (- d + 1))));\n         \\<forall>i\\<le>n.\n            0 < i \\<longrightarrow>\n            (\\<exists>d\\<ge>- int (k (THE c. c \\<in> X \\<and> v c = i)).\n                d \\<le> 0 \\<and>\n                (M\\<^sub>R 0 i = Le (real_of_int d) \\<or>\n                 M\\<^sub>R 0 i = Lt (real_of_int d)));\n         \\<forall>i j.\n            M\\<^sub>R i j \\<noteq> \\<infinity> \\<longrightarrow>\n            get_const (M\\<^sub>R i j) \\<in> \\<int>;\n         \\<forall>i\\<le>n.\n            \\<forall>j\\<le>n.\n               M\\<^sub>R i j \\<noteq> \\<infinity> \\<and>\n               0 < i \\<and> 0 < j \\<longrightarrow>\n               (\\<exists>d.\n                   (M\\<^sub>R i j = Le (real_of_int d) \\<or>\n                    M\\<^sub>R i j = Lt (real_of_int d)) \\<and>\n                   - int (k (THE c. c \\<in> X \\<and> v c = j))\n                   \\<le> d \\<and>\n                   d \\<le> int (k (THE c.\nc \\<in> X \\<and> v c = i)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        M\\<^sub>R i 0 = \\<infinity> \\<and>\n        0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n        M\\<^sub>R i j = \\<infinity> \\<and> M\\<^sub>R j i = \\<infinity>\n  \\<forall>i\\<le>n. M\\<^sub>R i i = Le 0\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        0 < i \\<and>\n        0 < j \\<and>\n        M\\<^sub>R i 0 \\<noteq> \\<infinity> \\<and>\n        M\\<^sub>R j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n        (\\<exists>d.\n            - int (k (THE c. c \\<in> X \\<and> v c = j)) \\<le> d \\<and>\n            d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i)) \\<and>\n            M\\<^sub>R i j = Le (real_of_int d) \\<and>\n            M\\<^sub>R j i = Le (real_of_int (- d)) \\<or>\n            - int (k (THE c. c \\<in> X \\<and> v c = j)) \\<le> d - 1 \\<and>\n            d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i)) \\<and>\n            M\\<^sub>R i j = Lt (real_of_int d) \\<and>\n            M\\<^sub>R j i = Lt (real_of_int (- d + 1)))\n  \\<forall>i\\<le>n.\n     0 < i \\<and> M\\<^sub>R i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n     (\\<exists>d\\<le>int (k (THE c. c \\<in> X \\<and> v c = i)).\n         0 \\<le> d \\<and>\n         (M\\<^sub>R i 0 = Le (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Le (real_of_int (- d)) \\<or>\n          M\\<^sub>R i 0 = Lt (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Lt (real_of_int (- d + 1))))\n  \\<forall>i\\<le>n.\n     0 < i \\<longrightarrow>\n     (\\<exists>d\\<ge>- int (k (THE c. c \\<in> X \\<and> v c = i)).\n         d \\<le> 0 \\<and>\n         (M\\<^sub>R 0 i = Le (real_of_int d) \\<or>\n          M\\<^sub>R 0 i = Lt (real_of_int d)))\n  \\<forall>i j.\n     M\\<^sub>R i j \\<noteq> \\<infinity> \\<longrightarrow>\n     get_const (M\\<^sub>R i j) \\<in> \\<int>\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        M\\<^sub>R i j \\<noteq> \\<infinity> \\<and>\n        0 < i \\<and> 0 < j \\<longrightarrow>\n        (\\<exists>d.\n            (M\\<^sub>R i j = Le (real_of_int d) \\<or>\n             M\\<^sub>R i j = Lt (real_of_int d)) \\<and>\n            - int (k (THE c. c \\<in> X \\<and> v c = j)) \\<le> d \\<and>\n            d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i)))\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (cases \"R = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. R = {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. R \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case True"], ["proof (state)\nthis:\n  R = {}\n\ngoal (2 subgoals):\n 1. R = {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. R \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  R = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  R = {}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. R \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. R \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case False"], ["proof (state)\nthis:\n  R \\<noteq> {}\n\ngoal (1 subgoal):\n 1. R \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from clock_numbering(2)"], ["proof (chain)\npicking this:\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)", "have cn_weak: \"\\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists> c. v c = k)\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)", "by auto"], ["proof (state)\nthis:\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\n\ngoal (1 subgoal):\n 1. R \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (cases \"Z = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Z = {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case True"], ["proof (state)\nthis:\n  Z = {}\n\ngoal (2 subgoals):\n 1. Z = {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  Z = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  Z = {}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "using beta_interp.apx_empty"], ["proof (prove)\nusing this:\n  Z = {}\n  Approx\\<^sub>\\<beta> {} = {}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by blast"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case False"], ["proof (state)\nthis:\n  Z \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from assms(4)"], ["proof (chain)\npicking this:\n  Z = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n", "have\n        \"Z = [M]\\<^bsub>v,n\\<^esub>\" \"\\<forall> i\\<le>n. \\<forall> j\\<le>n. M i j \\<noteq> \\<infinity> \\<longrightarrow> get_const (M i j) \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  Z = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n\n\ngoal (1 subgoal):\n 1. Z = [M]\\<^bsub>v,n\\<^esub> &&& dbm_int M n", "by auto"], ["proof (state)\nthis:\n  Z = [M]\\<^bsub>v,n\\<^esub>\n  dbm_int M n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from this(1) non_empty_dbm_diag_set'[OF clock_numbering(1) this(2)] \\<open>Z \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  Z = [M]\\<^bsub>v,n\\<^esub>\n  \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> \\<noteq> {};\n   \\<And>M'.\n      [M]\\<^bsub>v,n\\<^esub> = [M']\\<^bsub>v,n\\<^esub> \\<and>\n      dbm_int M' n \\<and>\n      (\\<forall>i\\<le>n. M' i i = \\<one>) \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  Z \\<noteq> {}", "obtain M where M:\n        \"Z = [M]\\<^bsub>v,n\\<^esub> \\<and> (\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<noteq> \\<infinity> \\<longrightarrow> get_const (M i j) \\<in> \\<int>) \\<and> (\\<forall>i\\<le>n. M i i = \\<one>)\""], ["proof (prove)\nusing this:\n  Z = [M]\\<^bsub>v,n\\<^esub>\n  \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> \\<noteq> {};\n   \\<And>M'.\n      [M]\\<^bsub>v,n\\<^esub> = [M']\\<^bsub>v,n\\<^esub> \\<and>\n      dbm_int M' n \\<and>\n      (\\<forall>i\\<le>n. M' i i = \\<one>) \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  Z \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        Z = [M]\\<^bsub>v,n\\<^esub> \\<and>\n        dbm_int M n \\<and>\n        (\\<forall>i\\<le>n. M i i = \\<one>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Z = [M]\\<^bsub>v,n\\<^esub> \\<and>\n  dbm_int M n \\<and> (\\<forall>i\\<le>n. M i i = \\<one>)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with not_empty_cyc_free[OF cn_weak] False"], ["proof (chain)\npicking this:\n  [?M]\\<^bsub>v,n\\<^esub> \\<noteq> {} \\<Longrightarrow>\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len ?M i i xs\n  Z \\<noteq> {}\n  Z = [M]\\<^bsub>v,n\\<^esub> \\<and>\n  dbm_int M n \\<and> (\\<forall>i\\<le>n. M i i = \\<one>)", "have \"cyc_free M n\""], ["proof (prove)\nusing this:\n  [?M]\\<^bsub>v,n\\<^esub> \\<noteq> {} \\<Longrightarrow>\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len ?M i i xs\n  Z \\<noteq> {}\n  Z = [M]\\<^bsub>v,n\\<^esub> \\<and>\n  dbm_int M n \\<and> (\\<forall>i\\<le>n. M i i = \\<one>)\n\ngoal (1 subgoal):\n 1. \\<forall>i xs.\n       i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n       \\<one> \\<le> len M i i xs", "by auto"], ["proof (state)\nthis:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs", "have \"cycle_free M n\""], ["proof (prove)\nusing this:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs\n\ngoal (1 subgoal):\n 1. cycle_free M n", "using cycle_free_diag_equiv"], ["proof (prove)\nusing this:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs\n  (\\<forall>i xs.\n      i \\<le> ?n \\<and> set xs \\<subseteq> {0..?n} \\<longrightarrow>\n      \\<one> \\<le> len ?M i i xs) =\n  cycle_free ?M ?n\n\ngoal (1 subgoal):\n 1. cycle_free M n", "by auto"], ["proof (state)\nthis:\n  cycle_free M n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from M"], ["proof (chain)\npicking this:\n  Z = [M]\\<^bsub>v,n\\<^esub> \\<and>\n  dbm_int M n \\<and> (\\<forall>i\\<le>n. M i i = \\<one>)", "have \"Z = [FW M n]\\<^bsub>v,n\\<^esub>\""], ["proof (prove)\nusing this:\n  Z = [M]\\<^bsub>v,n\\<^esub> \\<and>\n  dbm_int M n \\<and> (\\<forall>i\\<le>n. M i i = \\<one>)\n\ngoal (1 subgoal):\n 1. Z = [FW M n]\\<^bsub>v,n\\<^esub>", "unfolding neutral"], ["proof (prove)\nusing this:\n  Z = [M]\\<^bsub>v,n\\<^esub> \\<and>\n  dbm_int M n \\<and> (\\<forall>i\\<le>n. M i i = Le 0)\n\ngoal (1 subgoal):\n 1. Z = [FW M n]\\<^bsub>v,n\\<^esub>", "by (auto intro!: FW_zone_equiv[OF cn_weak])"], ["proof (state)\nthis:\n  Z = [FW M n]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  Z = [FW M n]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from fw_canonical[OF \\<open>cycle_free M _\\<close>] M"], ["proof (chain)\npicking this:\n  canonical (FW M n) n\n  Z = [M]\\<^bsub>v,n\\<^esub> \\<and>\n  dbm_int M n \\<and> (\\<forall>i\\<le>n. M i i = \\<one>)", "have \"canonical (FW M n) n\""], ["proof (prove)\nusing this:\n  canonical (FW M n) n\n  Z = [M]\\<^bsub>v,n\\<^esub> \\<and>\n  dbm_int M n \\<and> (\\<forall>i\\<le>n. M i i = \\<one>)\n\ngoal (1 subgoal):\n 1. canonical (FW M n) n", "unfolding neutral"], ["proof (prove)\nusing this:\n  canonical (FW M n) n\n  Z = [M]\\<^bsub>v,n\\<^esub> \\<and>\n  dbm_int M n \\<and> (\\<forall>i\\<le>n. M i i = Le 0)\n\ngoal (1 subgoal):\n 1. canonical (FW M n) n", "by auto"], ["proof (state)\nthis:\n  canonical (FW M n) n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  canonical (FW M n) n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from FW_int_preservation M"], ["proof (chain)\npicking this:\n  dbm_int ?M ?n \\<Longrightarrow> dbm_int (FW ?M ?n) ?n\n  Z = [M]\\<^bsub>v,n\\<^esub> \\<and>\n  dbm_int M n \\<and> (\\<forall>i\\<le>n. M i i = \\<one>)", "have\n        \"\\<forall>i\\<le>n. \\<forall>j\\<le>n. FW M n i j \\<noteq> \\<infinity> \\<longrightarrow> get_const (FW M n i j) \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  dbm_int ?M ?n \\<Longrightarrow> dbm_int (FW ?M ?n) ?n\n  Z = [M]\\<^bsub>v,n\\<^esub> \\<and>\n  dbm_int M n \\<and> (\\<forall>i\\<le>n. M i i = \\<one>)\n\ngoal (1 subgoal):\n 1. dbm_int (FW M n) n", "by auto"], ["proof (state)\nthis:\n  dbm_int (FW M n) n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  Z = [FW M n]\\<^bsub>v,n\\<^esub>\n  canonical (FW M n) n\n  dbm_int (FW M n) n", "obtain M where M:\n        \"[M]\\<^bsub>v,n\\<^esub> = Z\" \"canonical M n\" \"\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<noteq> \\<infinity> \\<longrightarrow> get_const (M i j) \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  Z = [FW M n]\\<^bsub>v,n\\<^esub>\n  canonical (FW M n) n\n  dbm_int (FW M n) n\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>[M]\\<^bsub>v,n\\<^esub> = Z; canonical M n;\n         dbm_int M n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub> = Z\n  canonical M n\n  dbm_int M n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "let ?M = \"\\<lambda> i j. min (M i j) (M\\<^sub>R i j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from M(1) M\\<^sub>R(1) assms"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub> = Z\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  R \\<in> \\<R>\n  Z \\<subseteq> V\n  R \\<inter> Z = {}\n  Z = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n", "have \"[M]\\<^bsub>v,n\\<^esub> \\<inter> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = {}\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub> = Z\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  R \\<in> \\<R>\n  Z \\<subseteq> V\n  R \\<inter> Z = {}\n  Z = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<inter> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = {}", "by auto"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub> \\<inter> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub> \\<inter> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from DBM_le_subset[folded less_eq, of n ?M M]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>i j.\n              i \\<le> n \\<longrightarrow>\n              j \\<le> n \\<longrightarrow>\n              min (M i j) (M\\<^sub>R i j) \\<le> M i j;\n   ?u \\<in> [(\\<lambda>i j.\n                 min (M i j) (M\\<^sub>R i j))]\\<^bsub>?v,n\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> ?u \\<in> [M]\\<^bsub>?v,n\\<^esub>", "have \"[?M]\\<^bsub>v,n\\<^esub> \\<subseteq> [M]\\<^bsub>v,n\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>i j.\n              i \\<le> n \\<longrightarrow>\n              j \\<le> n \\<longrightarrow>\n              min (M i j) (M\\<^sub>R i j) \\<le> M i j;\n   ?u \\<in> [(\\<lambda>i j.\n                 min (M i j) (M\\<^sub>R i j))]\\<^bsub>?v,n\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> ?u \\<in> [M]\\<^bsub>?v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. [(\\<lambda>i j. min (M i j) (M\\<^sub>R i j))]\\<^bsub>v,n\\<^esub>\n    \\<subseteq> [M]\\<^bsub>v,n\\<^esub>", "by auto"], ["proof (state)\nthis:\n  [(\\<lambda>i j. min (M i j) (M\\<^sub>R i j))]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [M]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  [(\\<lambda>i j. min (M i j) (M\\<^sub>R i j))]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [M]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from DBM_le_subset[folded less_eq, of n ?M M\\<^sub>R]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>i j.\n              i \\<le> n \\<longrightarrow>\n              j \\<le> n \\<longrightarrow>\n              min (M i j) (M\\<^sub>R i j) \\<le> M\\<^sub>R i j;\n   ?u \\<in> [(\\<lambda>i j.\n                 min (M i j) (M\\<^sub>R i j))]\\<^bsub>?v,n\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> ?u \\<in> [M\\<^sub>R]\\<^bsub>?v,n\\<^esub>", "have \"[?M]\\<^bsub>v,n\\<^esub> \\<subseteq> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>i j.\n              i \\<le> n \\<longrightarrow>\n              j \\<le> n \\<longrightarrow>\n              min (M i j) (M\\<^sub>R i j) \\<le> M\\<^sub>R i j;\n   ?u \\<in> [(\\<lambda>i j.\n                 min (M i j) (M\\<^sub>R i j))]\\<^bsub>?v,n\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> ?u \\<in> [M\\<^sub>R]\\<^bsub>?v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. [(\\<lambda>i j. min (M i j) (M\\<^sub>R i j))]\\<^bsub>v,n\\<^esub>\n    \\<subseteq> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>", "by auto"], ["proof (state)\nthis:\n  [(\\<lambda>i j. min (M i j) (M\\<^sub>R i j))]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub> \\<inter> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = {}\n  [(\\<lambda>i j. min (M i j) (M\\<^sub>R i j))]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [M]\\<^bsub>v,n\\<^esub>\n  [(\\<lambda>i j. min (M i j) (M\\<^sub>R i j))]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>", "have \"[?M]\\<^bsub>v,n\\<^esub> = {}\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub> \\<inter> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = {}\n  [(\\<lambda>i j. min (M i j) (M\\<^sub>R i j))]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [M]\\<^bsub>v,n\\<^esub>\n  [(\\<lambda>i j. min (M i j) (M\\<^sub>R i j))]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. [(\\<lambda>i j. min (M i j) (M\\<^sub>R i j))]\\<^bsub>v,n\\<^esub> = {}", "by blast"], ["proof (state)\nthis:\n  [(\\<lambda>i j. min (M i j) (M\\<^sub>R i j))]\\<^bsub>v,n\\<^esub> = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  [(\\<lambda>i j. min (M i j) (M\\<^sub>R i j))]\\<^bsub>v,n\\<^esub> = {}", "have \"\\<not> cyc_free ?M n\""], ["proof (prove)\nusing this:\n  [(\\<lambda>i j. min (M i j) (M\\<^sub>R i j))]\\<^bsub>v,n\\<^esub> = {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i xs.\n               i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n               \\<one>\n               \\<le> len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i xs)", "using cyc_free_not_empty[of n ?M v] clock_numbering(1)"], ["proof (prove)\nusing this:\n  [(\\<lambda>i j. min (M i j) (M\\<^sub>R i j))]\\<^bsub>v,n\\<^esub> = {}\n  \\<lbrakk>\\<forall>i xs.\n              i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n              \\<one>\n              \\<le> len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i xs;\n   \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\\<rbrakk>\n  \\<Longrightarrow> [(\\<lambda>i j.\n                         min (M i j)\n                          (M\\<^sub>R i j))]\\<^bsub>v,n\\<^esub> \\<noteq>\n                    {}\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i xs.\n               i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n               \\<one>\n               \\<le> len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i xs)", "by auto"], ["proof (state)\nthis:\n  \\<not> (\\<forall>i xs.\n             i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n             \\<one>\n             \\<le> len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i xs)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>i xs.\n             i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n             \\<one>\n             \\<le> len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i xs)", "obtain i xs where xs: \"i \\<le> n\" \"set xs \\<subseteq> {0..n}\" \"len ?M i i xs < \\<one>\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i xs.\n             i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n             \\<one>\n             \\<le> len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i xs)\n\ngoal (1 subgoal):\n 1. (\\<And>i xs.\n        \\<lbrakk>i \\<le> n; set xs \\<subseteq> {0..n};\n         len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i xs\n         < \\<one>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i xs < \\<one>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from this(1,2) canonical_shorten_rotate_neg_cycle[OF M(2) this(2,1,3)]"], ["proof (chain)\npicking this:\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  \\<exists>j ys.\n     len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) j j ys < \\<one> \\<and>\n     set (j # ys) \\<subseteq> set (i # xs) \\<and>\n     successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n      (arcs j j ys) \\<and>\n     distinct ys \\<and>\n     j \\<notin> set ys \\<and>\n     (ys \\<noteq> [] \\<longrightarrow>\n      min (M j (hd ys)) (M\\<^sub>R j (hd ys)) \\<noteq> M j (hd ys) \\<or>\n      min (M (last ys) j) (M\\<^sub>R (last ys) j) \\<noteq> M (last ys) j)", "obtain i ys where ys:\n        \"len ?M i i ys < \\<one>\"\n        \"set ys \\<subseteq> {0..n}\" \"successive (\\<lambda>(a, b). ?M a b = M a b) (arcs i i ys)\" \"i \\<le> n\"\n        and distinct: \"distinct ys\" \"i \\<notin> set ys\"\n        and cycle_closes: \"ys \\<noteq> [] \\<longrightarrow> ?M i (hd ys) \\<noteq> M i (hd ys) \\<or> ?M (last ys) i \\<noteq> M (last ys) i\""], ["proof (prove)\nusing this:\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  \\<exists>j ys.\n     len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) j j ys < \\<one> \\<and>\n     set (j # ys) \\<subseteq> set (i # xs) \\<and>\n     successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n      (arcs j j ys) \\<and>\n     distinct ys \\<and>\n     j \\<notin> set ys \\<and>\n     (ys \\<noteq> [] \\<longrightarrow>\n      min (M j (hd ys)) (M\\<^sub>R j (hd ys)) \\<noteq> M j (hd ys) \\<or>\n      min (M (last ys) j) (M\\<^sub>R (last ys) j) \\<noteq> M (last ys) j)\n\ngoal (1 subgoal):\n 1. (\\<And>i ys.\n        \\<lbrakk>len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys\n                 < \\<one>;\n         set ys \\<subseteq> {0..n};\n         successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n          (arcs i i ys);\n         i \\<le> n; distinct ys; i \\<notin> set ys;\n         ys \\<noteq> [] \\<longrightarrow>\n         min (M i (hd ys)) (M\\<^sub>R i (hd ys)) \\<noteq> M i (hd ys) \\<or>\n         min (M (last ys) i) (M\\<^sub>R (last ys) i) \\<noteq>\n         M (last ys) i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < \\<one>\n  set ys \\<subseteq> {0..n}\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs i i ys)\n  i \\<le> n\n  distinct ys\n  i \\<notin> set ys\n  ys \\<noteq> [] \\<longrightarrow>\n  min (M i (hd ys)) (M\\<^sub>R i (hd ys)) \\<noteq> M i (hd ys) \\<or>\n  min (M (last ys) i) (M\\<^sub>R (last ys) i) \\<noteq> M (last ys) i\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "have one_M_aux:\n        \"len ?M i j ys = len M\\<^sub>R i j ys\" if \"\\<forall> (a,b) \\<in> set (arcs i j ys). M a b \\<ge> M\\<^sub>R a b\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i j ys =\n    len M\\<^sub>R i j ys", "using that"], ["proof (prove)\nusing this:\n  \\<forall>(a, b)\\<in>set (arcs i j ys). M\\<^sub>R a b \\<le> M a b\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i j ys =\n    len M\\<^sub>R i j ys", "by (induction ys arbitrary: i) (auto simp: min_def)"], ["proof (state)\nthis:\n  \\<forall>(a, b)\\<in>set (arcs i ?j1 ys).\n     M\\<^sub>R a b \\<le> M a b \\<Longrightarrow>\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i ?j1 ys =\n  len M\\<^sub>R i ?j1 ys\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "have one_M: \"\\<exists> (a,b) \\<in> set (arcs i i ys). M a b < M\\<^sub>R a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(a, b)\\<in>set (arcs i i ys). M a b < M\\<^sub>R a b", "proof (rule ccontr, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>(a, b)\\<in>set (arcs i i ys).\n               M a b < M\\<^sub>R a b) \\<Longrightarrow>\n    False", "case 1"], ["proof (state)\nthis:\n  \\<not> (\\<exists>(a, b)\\<in>set (arcs i i ys). M a b < M\\<^sub>R a b)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>(a, b)\\<in>set (arcs i i ys).\n               M a b < M\\<^sub>R a b) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>(a, b)\\<in>set (arcs i i ys). M a b < M\\<^sub>R a b)", "have \"\\<forall>(a, b)\\<in>set (arcs i i ys). M\\<^sub>R a b \\<le> M a b\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>(a, b)\\<in>set (arcs i i ys). M a b < M\\<^sub>R a b)\n\ngoal (1 subgoal):\n 1. \\<forall>(a, b)\\<in>set (arcs i i ys). M\\<^sub>R a b \\<le> M a b", "by auto"], ["proof (state)\nthis:\n  \\<forall>(a, b)\\<in>set (arcs i i ys). M\\<^sub>R a b \\<le> M a b\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>(a, b)\\<in>set (arcs i i ys).\n               M a b < M\\<^sub>R a b) \\<Longrightarrow>\n    False", "from one_M_aux[OF this]"], ["proof (chain)\npicking this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys =\n  len M\\<^sub>R i i ys", "have \"len ?M i i ys = len M\\<^sub>R i i ys\""], ["proof (prove)\nusing this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys =\n  len M\\<^sub>R i i ys\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys =\n    len M\\<^sub>R i i ys", "."], ["proof (state)\nthis:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys =\n  len M\\<^sub>R i i ys\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>(a, b)\\<in>set (arcs i i ys).\n               M a b < M\\<^sub>R a b) \\<Longrightarrow>\n    False", "with Nil ys(1) xs(3)"], ["proof (chain)\npicking this:\n  ([], []) \\<in> listrel ?r\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < \\<one>\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i__ i__ xs < \\<one>\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys =\n  len M\\<^sub>R i i ys", "have \"len M\\<^sub>R i i ys < \\<one>\""], ["proof (prove)\nusing this:\n  ([], []) \\<in> listrel ?r\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < \\<one>\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i__ i__ xs < \\<one>\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys =\n  len M\\<^sub>R i i ys\n\ngoal (1 subgoal):\n 1. len M\\<^sub>R i i ys < \\<one>", "by simp"], ["proof (state)\nthis:\n  len M\\<^sub>R i i ys < \\<one>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>(a, b)\\<in>set (arcs i i ys).\n               M a b < M\\<^sub>R a b) \\<Longrightarrow>\n    False", "from DBM_val_bounded_neg_cycle[OF _ \\<open>i \\<le> n\\<close> \\<open>set ys \\<subseteq> _\\<close> this cn_weak]"], ["proof (chain)\npicking this:\n  ?u \\<turnstile>\\<^bsub>v,n\\<^esub> M\\<^sub>R \\<Longrightarrow> False", "have \"[M\\<^sub>R]\\<^bsub>v,n\\<^esub> = {}\""], ["proof (prove)\nusing this:\n  ?u \\<turnstile>\\<^bsub>v,n\\<^esub> M\\<^sub>R \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = {}", "unfolding DBM_zone_repr_def"], ["proof (prove)\nusing this:\n  ?u \\<turnstile>\\<^bsub>v,n\\<^esub> M\\<^sub>R \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. {u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M\\<^sub>R} = {}", "by auto"], ["proof (state)\nthis:\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>(a, b)\\<in>set (arcs i i ys).\n               M a b < M\\<^sub>R a b) \\<Longrightarrow>\n    False", "with \\<open>R \\<noteq> {}\\<close> M\\<^sub>R(1)"], ["proof (chain)\npicking this:\n  R \\<noteq> {}\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = {}", "show False"], ["proof (prove)\nusing this:\n  R \\<noteq> {}\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>(a, b)\\<in>set (arcs i i ys). M a b < M\\<^sub>R a b\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "have one_M_R_aux:\n        \"len ?M i j ys = len M i j ys\" if \"\\<forall> (a,b) \\<in> set (arcs i j ys). M a b \\<le> M\\<^sub>R a b\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i j ys = len M i j ys", "using that"], ["proof (prove)\nusing this:\n  \\<forall>(a, b)\\<in>set (arcs i j ys). M a b \\<le> M\\<^sub>R a b\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i j ys = len M i j ys", "by (induction ys arbitrary: i) (auto simp: min_def)"], ["proof (state)\nthis:\n  \\<forall>(a, b)\\<in>set (arcs i ?j1 ys).\n     M a b \\<le> M\\<^sub>R a b \\<Longrightarrow>\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i ?j1 ys = len M i ?j1 ys\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "have one_M_R: \"\\<exists> (a,b) \\<in> set (arcs i i ys). M a b > M\\<^sub>R a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>(a, b)\\<in>set (arcs i i ys). M\\<^sub>R a b < M a b", "proof (rule ccontr, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>(a, b)\\<in>set (arcs i i ys).\n               M\\<^sub>R a b < M a b) \\<Longrightarrow>\n    False", "case 1"], ["proof (state)\nthis:\n  \\<not> (\\<exists>(a, b)\\<in>set (arcs i i ys). M\\<^sub>R a b < M a b)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>(a, b)\\<in>set (arcs i i ys).\n               M\\<^sub>R a b < M a b) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>(a, b)\\<in>set (arcs i i ys). M\\<^sub>R a b < M a b)", "have \"\\<forall>(a, b)\\<in>set (arcs i i ys). M\\<^sub>R a b \\<ge> M a b\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>(a, b)\\<in>set (arcs i i ys). M\\<^sub>R a b < M a b)\n\ngoal (1 subgoal):\n 1. \\<forall>(a, b)\\<in>set (arcs i i ys). M a b \\<le> M\\<^sub>R a b", "by auto"], ["proof (state)\nthis:\n  \\<forall>(a, b)\\<in>set (arcs i i ys). M a b \\<le> M\\<^sub>R a b\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>(a, b)\\<in>set (arcs i i ys).\n               M\\<^sub>R a b < M a b) \\<Longrightarrow>\n    False", "from one_M_R_aux[OF this]"], ["proof (chain)\npicking this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys = len M i i ys", "have \"len ?M i i ys = len M i i ys\""], ["proof (prove)\nusing this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys = len M i i ys\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys = len M i i ys", "."], ["proof (state)\nthis:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys = len M i i ys\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>(a, b)\\<in>set (arcs i i ys).\n               M\\<^sub>R a b < M a b) \\<Longrightarrow>\n    False", "with Nil ys(1) xs(3)"], ["proof (chain)\npicking this:\n  ([], []) \\<in> listrel ?r\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < \\<one>\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i__ i__ xs < \\<one>\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys = len M i i ys", "have \"len M i i ys < \\<one>\""], ["proof (prove)\nusing this:\n  ([], []) \\<in> listrel ?r\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < \\<one>\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i__ i__ xs < \\<one>\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys = len M i i ys\n\ngoal (1 subgoal):\n 1. len M i i ys < \\<one>", "by simp"], ["proof (state)\nthis:\n  len M i i ys < \\<one>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>(a, b)\\<in>set (arcs i i ys).\n               M\\<^sub>R a b < M a b) \\<Longrightarrow>\n    False", "from DBM_val_bounded_neg_cycle[OF _ \\<open>i \\<le> n\\<close> \\<open>set ys \\<subseteq> _\\<close> this cn_weak]"], ["proof (chain)\npicking this:\n  ?u \\<turnstile>\\<^bsub>v,n\\<^esub> M \\<Longrightarrow> False", "have \"[M]\\<^bsub>v,n\\<^esub> = {}\""], ["proof (prove)\nusing this:\n  ?u \\<turnstile>\\<^bsub>v,n\\<^esub> M \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> = {}", "unfolding DBM_zone_repr_def"], ["proof (prove)\nusing this:\n  ?u \\<turnstile>\\<^bsub>v,n\\<^esub> M \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. {u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M} = {}", "by auto"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub> = {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>(a, b)\\<in>set (arcs i i ys).\n               M\\<^sub>R a b < M a b) \\<Longrightarrow>\n    False", "with \\<open>Z \\<noteq> {}\\<close> M(1)"], ["proof (chain)\npicking this:\n  Z \\<noteq> {}\n  [M]\\<^bsub>v,n\\<^esub> = Z\n  [M]\\<^bsub>v,n\\<^esub> = {}", "show False"], ["proof (prove)\nusing this:\n  Z \\<noteq> {}\n  [M]\\<^bsub>v,n\\<^esub> = Z\n  [M]\\<^bsub>v,n\\<^esub> = {}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>(a, b)\\<in>set (arcs i i ys). M\\<^sub>R a b < M a b\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "have 0: \"(0,0) \\<notin> set (arcs i i ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0, 0) \\<notin> set (arcs i i ys)", "proof (cases \"ys = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow> (0, 0) \\<notin> set (arcs i i ys)\n 2. ys \\<noteq> [] \\<Longrightarrow> (0, 0) \\<notin> set (arcs i i ys)", "case False"], ["proof (state)\nthis:\n  ys \\<noteq> []\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow> (0, 0) \\<notin> set (arcs i i ys)\n 2. ys \\<noteq> [] \\<Longrightarrow> (0, 0) \\<notin> set (arcs i i ys)", "with distinct"], ["proof (chain)\npicking this:\n  distinct ys\n  i \\<notin> set ys\n  ys \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct ys\n  i \\<notin> set ys\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. (0, 0) \\<notin> set (arcs i i ys)", "using arcs_distinct1"], ["proof (prove)\nusing this:\n  distinct ys\n  i \\<notin> set ys\n  ys \\<noteq> []\n  \\<lbrakk>?i \\<notin> set ?xs; ?j \\<notin> set ?xs; distinct ?xs;\n   ?xs \\<noteq> []; (?a, ?b) \\<in> set (arcs ?i ?j ?xs)\\<rbrakk>\n  \\<Longrightarrow> ?a \\<noteq> ?b\n\ngoal (1 subgoal):\n 1. (0, 0) \\<notin> set (arcs i i ys)", "by blast"], ["proof (state)\nthis:\n  (0, 0) \\<notin> set (arcs i i ys)\n\ngoal (1 subgoal):\n 1. ys = [] \\<Longrightarrow> (0, 0) \\<notin> set (arcs i i ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ys = [] \\<Longrightarrow> (0, 0) \\<notin> set (arcs i i ys)", "case True"], ["proof (state)\nthis:\n  ys = []\n\ngoal (1 subgoal):\n 1. ys = [] \\<Longrightarrow> (0, 0) \\<notin> set (arcs i i ys)", "with ys(1)"], ["proof (chain)\npicking this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < \\<one>\n  ys = []", "have \"?M i i < \\<one>\""], ["proof (prove)\nusing this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < \\<one>\n  ys = []\n\ngoal (1 subgoal):\n 1. min (M i i) (M\\<^sub>R i i) < \\<one>", "by auto"], ["proof (state)\nthis:\n  min (M i i) (M\\<^sub>R i i) < \\<one>\n\ngoal (1 subgoal):\n 1. ys = [] \\<Longrightarrow> (0, 0) \\<notin> set (arcs i i ys)", "then"], ["proof (chain)\npicking this:\n  min (M i i) (M\\<^sub>R i i) < \\<one>", "have \"M i i < \\<one> \\<or> M\\<^sub>R i i < \\<one>\""], ["proof (prove)\nusing this:\n  min (M i i) (M\\<^sub>R i i) < \\<one>\n\ngoal (1 subgoal):\n 1. M i i < \\<one> \\<or> M\\<^sub>R i i < \\<one>", "by (simp add: min_less_iff_disj)"], ["proof (state)\nthis:\n  M i i < \\<one> \\<or> M\\<^sub>R i i < \\<one>\n\ngoal (1 subgoal):\n 1. ys = [] \\<Longrightarrow> (0, 0) \\<notin> set (arcs i i ys)", "from one_M one_M_R True"], ["proof (chain)\npicking this:\n  \\<exists>(a, b)\\<in>set (arcs i i ys). M a b < M\\<^sub>R a b\n  \\<exists>(a, b)\\<in>set (arcs i i ys). M\\<^sub>R a b < M a b\n  ys = []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>(a, b)\\<in>set (arcs i i ys). M a b < M\\<^sub>R a b\n  \\<exists>(a, b)\\<in>set (arcs i i ys). M\\<^sub>R a b < M a b\n  ys = []\n\ngoal (1 subgoal):\n 1. (0, 0) \\<notin> set (arcs i i ys)", "by auto"], ["proof (state)\nthis:\n  (0, 0) \\<notin> set (arcs i i ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (0, 0) \\<notin> set (arcs i i ys)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  (0, 0) \\<notin> set (arcs i i ys)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume A: \"(a,b) \\<in> set (arcs i i ys)\""], ["proof (state)\nthis:\n  (a, b) \\<in> set (arcs i i ys)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume not0: \"a > 0\""], ["proof (state)\nthis:\n  0 < a\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from aux1[OF ys(4,4,2) A]"], ["proof (chain)\npicking this:\n  a \\<le> n \\<and> b \\<le> n", "have C2: \"a \\<le> n\""], ["proof (prove)\nusing this:\n  a \\<le> n \\<and> b \\<le> n\n\ngoal (1 subgoal):\n 1. a \\<le> n", "by auto"], ["proof (state)\nthis:\n  a \\<le> n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  a \\<le> n", "obtain c1 where C: \"v c1 = a\" \"c1 \\<in> X\""], ["proof (prove)\nusing this:\n  a \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>c1.\n        \\<lbrakk>v c1 = a; c1 \\<in> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using clock_numbering(2) not0"], ["proof (prove)\nusing this:\n  a \\<le> n\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  0 < a\n\ngoal (1 subgoal):\n 1. (\\<And>c1.\n        \\<lbrakk>v c1 = a; c1 \\<in> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding v'_def"], ["proof (prove)\nusing this:\n  a \\<le> n\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  0 < a\n\ngoal (1 subgoal):\n 1. (\\<And>c1.\n        \\<lbrakk>v c1 = a; c1 \\<in> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by meson"], ["proof (state)\nthis:\n  v c1 = a\n  c1 \\<in> X\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  v c1 = a\n  c1 \\<in> X", "have \"v' a = c1\""], ["proof (prove)\nusing this:\n  v c1 = a\n  c1 \\<in> X\n\ngoal (1 subgoal):\n 1. v' a = c1", "using clock_numbering C2 not0"], ["proof (prove)\nusing this:\n  v c1 = a\n  c1 \\<in> X\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  a \\<le> n\n  0 < a\n\ngoal (1 subgoal):\n 1. v' a = c1", "unfolding v'_def"], ["proof (prove)\nusing this:\n  v c1 = a\n  c1 \\<in> X\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  a \\<le> n\n  0 < a\n\ngoal (1 subgoal):\n 1. (THE c. c \\<in> X \\<and> v c = a) = c1", "by fastforce"], ["proof (state)\nthis:\n  v' a = c1\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C C2"], ["proof (chain)\npicking this:\n  v c1 = a\n  c1 \\<in> X\n  a \\<le> n\n  v' a = c1", "have \"\\<exists> c \\<in> X. v c = a \\<and> v' a = c\" \"a \\<le> n\""], ["proof (prove)\nusing this:\n  v c1 = a\n  c1 \\<in> X\n  a \\<le> n\n  v' a = c1\n\ngoal (1 subgoal):\n 1. \\<exists>c\\<in>X. v c = a \\<and> v' a = c &&& a \\<le> n", "by auto"], ["proof (state)\nthis:\n  \\<exists>c\\<in>X. v c = a \\<and> v' a = c\n  a \\<le> n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?a3\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c\\<in>X. v c = ?a3 \\<and> v' ?a3 = c\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?a3\\<rbrakk>\n  \\<Longrightarrow> ?a3 \\<le> n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "note clock_dest_1 = this"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?a3\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c\\<in>X. v c = ?a3 \\<and> v' ?a3 = c\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?a3\\<rbrakk>\n  \\<Longrightarrow> ?a3 \\<le> n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?a3\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c\\<in>X. v c = ?a3 \\<and> v' ?a3 = c\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?a3\\<rbrakk>\n  \\<Longrightarrow> ?a3 \\<le> n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume A: \"(a,b) \\<in> set (arcs i i ys)\""], ["proof (state)\nthis:\n  (a, b) \\<in> set (arcs i i ys)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume not0: \"b > 0\""], ["proof (state)\nthis:\n  0 < b\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from aux1[OF ys(4,4,2) A]"], ["proof (chain)\npicking this:\n  a \\<le> n \\<and> b \\<le> n", "have C2: \"b \\<le> n\""], ["proof (prove)\nusing this:\n  a \\<le> n \\<and> b \\<le> n\n\ngoal (1 subgoal):\n 1. b \\<le> n", "by auto"], ["proof (state)\nthis:\n  b \\<le> n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  b \\<le> n", "obtain c2 where C: \"v c2 = b\" \"c2 \\<in> X\""], ["proof (prove)\nusing this:\n  b \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>c2.\n        \\<lbrakk>v c2 = b; c2 \\<in> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using clock_numbering(2) not0"], ["proof (prove)\nusing this:\n  b \\<le> n\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  0 < b\n\ngoal (1 subgoal):\n 1. (\\<And>c2.\n        \\<lbrakk>v c2 = b; c2 \\<in> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding v'_def"], ["proof (prove)\nusing this:\n  b \\<le> n\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  0 < b\n\ngoal (1 subgoal):\n 1. (\\<And>c2.\n        \\<lbrakk>v c2 = b; c2 \\<in> X\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by meson"], ["proof (state)\nthis:\n  v c2 = b\n  c2 \\<in> X\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  v c2 = b\n  c2 \\<in> X", "have \"v' b = c2\""], ["proof (prove)\nusing this:\n  v c2 = b\n  c2 \\<in> X\n\ngoal (1 subgoal):\n 1. v' b = c2", "using clock_numbering C2 not0"], ["proof (prove)\nusing this:\n  v c2 = b\n  c2 \\<in> X\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  b \\<le> n\n  0 < b\n\ngoal (1 subgoal):\n 1. v' b = c2", "unfolding v'_def"], ["proof (prove)\nusing this:\n  v c2 = b\n  c2 \\<in> X\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n  b \\<le> n\n  0 < b\n\ngoal (1 subgoal):\n 1. (THE c. c \\<in> X \\<and> v c = b) = c2", "by fastforce"], ["proof (state)\nthis:\n  v' b = c2\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C C2"], ["proof (chain)\npicking this:\n  v c2 = b\n  c2 \\<in> X\n  b \\<le> n\n  v' b = c2", "have \"\\<exists> c \\<in> X. v c = b \\<and> v' b = c\" \"b \\<le> n\""], ["proof (prove)\nusing this:\n  v c2 = b\n  c2 \\<in> X\n  b \\<le> n\n  v' b = c2\n\ngoal (1 subgoal):\n 1. \\<exists>c\\<in>X. v c = b \\<and> v' b = c &&& b \\<le> n", "by auto"], ["proof (state)\nthis:\n  \\<exists>c\\<in>X. v c = b \\<and> v' b = c\n  b \\<le> n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?b3\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c\\<in>X. v c = ?b3 \\<and> v' ?b3 = c\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?b3\\<rbrakk>\n  \\<Longrightarrow> ?b3 \\<le> n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "note clock_dest_2 = this"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?b3\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c\\<in>X. v c = ?b3 \\<and> v' ?b3 = c\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?b3\\<rbrakk>\n  \\<Longrightarrow> ?b3 \\<le> n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "have clock_dest:\n        \"\\<And> a b. (a,b) \\<in> set (arcs i i ys) \\<Longrightarrow> a > 0 \\<Longrightarrow> b > 0 \\<Longrightarrow>\n          \\<exists> c1 \\<in> X. \\<exists> c2 \\<in> X. v c1 = a \\<and> v c2 = b \\<and> v' a = c1 \\<and> v' b = c2 &&& a \\<le> n &&& b \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> set (arcs i i ys); 0 < a; 0 < b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c1\\<in>X.\n                            \\<exists>c2\\<in>X.\n                               v c1 = a \\<and>\n                               v c2 = b \\<and>\n                               v' a = c1 \\<and> v' b = c2 &&&\n                         a \\<le> n &&& b \\<le> n", "using clock_dest_1 clock_dest_2"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?a3\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c\\<in>X. v c = ?a3 \\<and> v' ?a3 = c\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?a3\\<rbrakk>\n  \\<Longrightarrow> ?a3 \\<le> n\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?b3\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c\\<in>X. v c = ?b3 \\<and> v' ?b3 = c\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?b3\\<rbrakk>\n  \\<Longrightarrow> ?b3 \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> set (arcs i i ys); 0 < a; 0 < b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c1\\<in>X.\n                            \\<exists>c2\\<in>X.\n                               v c1 = a \\<and>\n                               v c2 = b \\<and>\n                               v' a = c1 \\<and> v' b = c2 &&&\n                         a \\<le> n &&& b \\<le> n", "by (auto) presburger"], ["proof (state)\nthis:\n  \\<lbrakk>(?a1, ?b1) \\<in> set (arcs i i ys); 0 < ?a1; 0 < ?b1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c1\\<in>X.\n                       \\<exists>c2\\<in>X.\n                          v c1 = ?a1 \\<and>\n                          v c2 = ?b1 \\<and>\n                          v' ?a1 = c1 \\<and> v' ?b1 = c2 &&&\n                    ?a1 \\<le> n &&& ?b1 \\<le> n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(?a1, ?b1) \\<in> set (arcs i i ys); 0 < ?a1; 0 < ?b1\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c1\\<in>X.\n                       \\<exists>c2\\<in>X.\n                          v c1 = ?a1 \\<and>\n                          v c2 = ?b1 \\<and>\n                          v' ?a1 = c1 \\<and> v' ?b1 = c2 &&&\n                    ?a1 \\<le> n &&& ?b1 \\<le> n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume A: \"(a,0) \\<in> set (arcs i i ys)\""], ["proof (state)\nthis:\n  (a, 0) \\<in> set (arcs i i ys)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume not0: \"a > 0\""], ["proof (state)\nthis:\n  0 < a\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume bounded: \"M\\<^sub>R a 0 \\<noteq> \\<infinity>\""], ["proof (state)\nthis:\n  M\\<^sub>R a 0 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume lt: \"M a 0 < M\\<^sub>R a 0\""], ["proof (state)\nthis:\n  M a 0 < M\\<^sub>R a 0\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from clock_dest_1[OF A not0]"], ["proof (chain)\npicking this:\n  \\<exists>c\\<in>X. v c = a \\<and> v' a = c\n  a \\<le> n", "obtain c1 where C:\n          \"v c1 = a\" \"c1 \\<in> X\" \"v' a = c1\" and C2: \"a \\<le> n\""], ["proof (prove)\nusing this:\n  \\<exists>c\\<in>X. v c = a \\<and> v' a = c\n  a \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>c1.\n        \\<lbrakk>v c1 = a; c1 \\<in> X; v' a = c1; a \\<le> n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v c1 = a\n  c1 \\<in> X\n  v' a = c1\n  a \\<le> n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from C2 not0 bounded M\\<^sub>R(5)"], ["proof (chain)\npicking this:\n  a \\<le> n\n  0 < a\n  M\\<^sub>R a 0 \\<noteq> \\<infinity>\n  \\<forall>i\\<le>n.\n     0 < i \\<and> M\\<^sub>R i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n     (\\<exists>d\\<le>int (k (THE c. c \\<in> X \\<and> v c = i)).\n         0 \\<le> d \\<and>\n         (M\\<^sub>R i 0 = Le (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Le (real_of_int (- d)) \\<or>\n          M\\<^sub>R i 0 = Lt (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Lt (real_of_int (- d + 1))))", "obtain d :: int where *:\n          \"d \\<le> int (k (v' a))\"\n          \"M\\<^sub>R a 0 = Le d \\<and> M\\<^sub>R 0 a = Le (- d) \\<or> M\\<^sub>R a 0 = Lt d \\<and> M\\<^sub>R 0 a = Lt (- d + 1)\""], ["proof (prove)\nusing this:\n  a \\<le> n\n  0 < a\n  M\\<^sub>R a 0 \\<noteq> \\<infinity>\n  \\<forall>i\\<le>n.\n     0 < i \\<and> M\\<^sub>R i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n     (\\<exists>d\\<le>int (k (THE c. c \\<in> X \\<and> v c = i)).\n         0 \\<le> d \\<and>\n         (M\\<^sub>R i 0 = Le (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Le (real_of_int (- d)) \\<or>\n          M\\<^sub>R i 0 = Lt (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Lt (real_of_int (- d + 1))))\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>d \\<le> int (k (v' a));\n         M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n         M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<or>\n         M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n         M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding v'_def"], ["proof (prove)\nusing this:\n  a \\<le> n\n  0 < a\n  M\\<^sub>R a 0 \\<noteq> \\<infinity>\n  \\<forall>i\\<le>n.\n     0 < i \\<and> M\\<^sub>R i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n     (\\<exists>d\\<le>int (k (THE c. c \\<in> X \\<and> v c = i)).\n         0 \\<le> d \\<and>\n         (M\\<^sub>R i 0 = Le (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Le (real_of_int (- d)) \\<or>\n          M\\<^sub>R i 0 = Lt (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Lt (real_of_int (- d + 1))))\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>d \\<le> int (k (THE c. c \\<in> X \\<and> v c = a));\n         M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n         M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<or>\n         M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n         M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  d \\<le> int (k (v' a))\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C"], ["proof (chain)\npicking this:\n  v c1 = a\n  c1 \\<in> X\n  v' a = c1\n  d \\<le> int (k (v' a))\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))", "have **: \"d \\<le> int (k c1)\""], ["proof (prove)\nusing this:\n  v c1 = a\n  c1 \\<in> X\n  v' a = c1\n  d \\<le> int (k (v' a))\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. d \\<le> int (k c1)", "by auto"], ["proof (state)\nthis:\n  d \\<le> int (k c1)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from *(2)"], ["proof (chain)\npicking this:\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))", "have ?thesis"], ["proof (prove)\nusing this:\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 1"], ["proof (state)\nthis:\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Le (real_of_int (- d))\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with lt"], ["proof (chain)\npicking this:\n  M a 0 < M\\<^sub>R a 0\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Le (real_of_int (- d))", "have \"M a 0 < Le d\""], ["proof (prove)\nusing this:\n  M a 0 < M\\<^sub>R a 0\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Le (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. M a 0 < Le (real_of_int d)", "by auto"], ["proof (state)\nthis:\n  M a 0 < Le (real_of_int d)\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  M a 0 < Le (real_of_int d)", "have \"M a 0 \\<le> Lt d\""], ["proof (prove)\nusing this:\n  M a 0 < Le (real_of_int d)\n\ngoal (1 subgoal):\n 1. M a 0 \\<le> Lt (real_of_int d)", "unfolding less less_eq dbm_le_def"], ["proof (prove)\nusing this:\n  M a 0 \\<prec> Le (real_of_int d)\n\ngoal (1 subgoal):\n 1. M a 0 \\<prec> Lt (real_of_int d) \\<or> M a 0 = Lt (real_of_int d)", "by (fastforce elim!: dbm_lt.cases)"], ["proof (state)\nthis:\n  M a 0 \\<le> Lt (real_of_int d)\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from dbm_lt'2[OF assms(2)[folded M(1)] this C2 C(1) not0]"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 < real_of_int d}", "have\n            \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 < d}\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 < real_of_int d}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 < real_of_int d}", "by auto"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 < real_of_int d}\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from beta_interp.\\<beta>_boundedness_lt'[OF ** C(2) this]"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 < real_of_int d}", "have\n            \"Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>) \\<subseteq> {u \\<in> V. u c1 < d}\""], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 < real_of_int d}\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n    \\<subseteq> {u \\<in> V. u c1 < real_of_int d}", "."], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 < real_of_int d}\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 < real_of_int d}\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 < real_of_int d}\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix u"], ["proof (state)\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume u: \"u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\""], ["proof (state)\nthis:\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C C2"], ["proof (chain)\npicking this:\n  v c1 = a\n  c1 \\<in> X\n  v' a = c1\n  a \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>", "have\n              \"dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)\" \"dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)\""], ["proof (prove)\nusing this:\n  v c1 = a\n  c1 \\<in> X\n  v' a = c1\n  a \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) None (M\\<^sub>R a 0) &&&\n    dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  v c1 = a\n  c1 \\<in> X\n  v' a = c1\n  a \\<le> n\n  u \\<in> {u. Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n              (\\<forall>c.\n                  v c \\<le> n \\<longrightarrow>\n                  dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n                  dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n              (\\<forall>c1 c2.\n                  v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                  dbm_entry_val u (Some c1) (Some c2)\n                   (M\\<^sub>R (v c1) (v c2)))}\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) None (M\\<^sub>R a 0) &&&\n    dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)\n  dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)\n  dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)", "have \"u c1 = d\""], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)\n  dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)\n\ngoal (1 subgoal):\n 1. u c1 = real_of_int d", "using 1"], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)\n  dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Le (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. u c1 = real_of_int d", "by auto"], ["proof (state)\nthis:\n  u c1 = real_of_int d\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  u c1 = real_of_int d", "have \"u \\<notin> {u \\<in> V. u c1 < d}\""], ["proof (prove)\nusing this:\n  u c1 = real_of_int d\n\ngoal (1 subgoal):\n 1. u \\<notin> {u \\<in> V. u c1 < real_of_int d}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> {u \\<in> V. u c1 < real_of_int d}\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 < real_of_int d}\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 < real_of_int d}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 < real_of_int d}", "show ?thesis"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 < real_of_int d}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 < real_of_int d}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "using M\\<^sub>R(1) M(1)"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 < real_of_int d}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 < real_of_int d}\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  [M]\\<^bsub>v,n\\<^esub> = Z\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 2"], ["proof (state)\nthis:\n  M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from 2 lt"], ["proof (chain)\npicking this:\n  M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))\n  M a 0 < M\\<^sub>R a 0", "have \"M a 0 \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))\n  M a 0 < M\\<^sub>R a 0\n\ngoal (1 subgoal):\n 1. M a 0 \\<noteq> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  M a 0 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with dbm_entry_int[OF this] M(3) \\<open>a \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  get_const (M a 0) \\<in> \\<int> \\<Longrightarrow>\n  \\<exists>d. M a 0 = Le (real_of_int d) \\<or> M a 0 = Lt (real_of_int d)\n  dbm_int M n\n  a \\<le> n\n  M a 0 \\<noteq> \\<infinity>", "obtain d' :: int where d': \"M a 0 = Le d' \\<or> M a 0 = Lt d'\""], ["proof (prove)\nusing this:\n  get_const (M a 0) \\<in> \\<int> \\<Longrightarrow>\n  \\<exists>d. M a 0 = Le (real_of_int d) \\<or> M a 0 = Lt (real_of_int d)\n  dbm_int M n\n  a \\<le> n\n  M a 0 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>d'.\n        M a 0 = Le (real_of_int d') \\<or>\n        M a 0 = Lt (real_of_int d') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M a 0 = Le (real_of_int d') \\<or> M a 0 = Lt (real_of_int d')\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  M a 0 = Le (real_of_int d') \\<or> M a 0 = Lt (real_of_int d')", "have \"M a 0 \\<le> Le (d - 1)\""], ["proof (prove)\nusing this:\n  M a 0 = Le (real_of_int d') \\<or> M a 0 = Lt (real_of_int d')\n\ngoal (1 subgoal):\n 1. M a 0 \\<le> Le (real_of_int (d - 1))", "using lt 2"], ["proof (prove)\nusing this:\n  M a 0 = Le (real_of_int d') \\<or> M a 0 = Lt (real_of_int d')\n  M a 0 < M\\<^sub>R a 0\n  M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. M a 0 \\<le> Le (real_of_int (d - 1))", "apply (auto simp: less_eq dbm_le_def less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Le (real_of_int d') \\<prec> Lt (real_of_int d);\n     M\\<^sub>R a 0 = Lt (real_of_int d);\n     M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n     real_of_int d' \\<noteq> real_of_int d - 1;\n     M a 0 = Le (real_of_int d')\\<rbrakk>\n    \\<Longrightarrow> Le (real_of_int d') \\<prec> Le (real_of_int d - 1)\n 2. \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (real_of_int d);\n     M\\<^sub>R a 0 = Lt (real_of_int d);\n     M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n     M a 0 = Lt (real_of_int d')\\<rbrakk>\n    \\<Longrightarrow> Lt (real_of_int d') \\<prec> Le (real_of_int d - 1)", "apply (cases rule: dbm_lt.cases)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>Le (real_of_int d') \\<prec> Lt (real_of_int d);\n     M\\<^sub>R a 0 = Lt (real_of_int d);\n     M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n     real_of_int d' \\<noteq> real_of_int d - 1;\n     M a 0 = Le (real_of_int d')\\<rbrakk>\n    \\<Longrightarrow> ?a1.6 \\<prec> ?a2.6\n 2. \\<And>uu_.\n       \\<lbrakk>Le (real_of_int d') \\<prec> Lt (real_of_int d);\n        M\\<^sub>R a 0 = Lt (real_of_int d);\n        M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n        real_of_int d' \\<noteq> real_of_int d - 1;\n        M a 0 = Le (real_of_int d'); ?a1.6 = Lt uu_;\n        ?a2.6 = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> Le (real_of_int d') \\<prec> Le (real_of_int d - 1)\n 3. \\<And>uv_.\n       \\<lbrakk>Le (real_of_int d') \\<prec> Lt (real_of_int d);\n        M\\<^sub>R a 0 = Lt (real_of_int d);\n        M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n        real_of_int d' \\<noteq> real_of_int d - 1;\n        M a 0 = Le (real_of_int d'); ?a1.6 = Le uv_;\n        ?a2.6 = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> Le (real_of_int d') \\<prec> Le (real_of_int d - 1)\n 4. \\<And>aa b.\n       \\<lbrakk>Le (real_of_int d') \\<prec> Lt (real_of_int d);\n        M\\<^sub>R a 0 = Lt (real_of_int d);\n        M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n        real_of_int d' \\<noteq> real_of_int d - 1;\n        M a 0 = Le (real_of_int d'); ?a1.6 = Le aa; ?a2.6 = Le b;\n        aa < b\\<rbrakk>\n       \\<Longrightarrow> Le (real_of_int d') \\<prec> Le (real_of_int d - 1)\n 5. \\<And>aa b.\n       \\<lbrakk>Le (real_of_int d') \\<prec> Lt (real_of_int d);\n        M\\<^sub>R a 0 = Lt (real_of_int d);\n        M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n        real_of_int d' \\<noteq> real_of_int d - 1;\n        M a 0 = Le (real_of_int d'); ?a1.6 = Le aa; ?a2.6 = Lt b;\n        aa < b\\<rbrakk>\n       \\<Longrightarrow> Le (real_of_int d') \\<prec> Le (real_of_int d - 1)\n 6. \\<And>aa b.\n       \\<lbrakk>Le (real_of_int d') \\<prec> Lt (real_of_int d);\n        M\\<^sub>R a 0 = Lt (real_of_int d);\n        M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n        real_of_int d' \\<noteq> real_of_int d - 1;\n        M a 0 = Le (real_of_int d'); ?a1.6 = Lt aa; ?a2.6 = Le b;\n        aa \\<le> b\\<rbrakk>\n       \\<Longrightarrow> Le (real_of_int d') \\<prec> Le (real_of_int d - 1)\n 7. \\<And>aa b.\n       \\<lbrakk>Le (real_of_int d') \\<prec> Lt (real_of_int d);\n        M\\<^sub>R a 0 = Lt (real_of_int d);\n        M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n        real_of_int d' \\<noteq> real_of_int d - 1;\n        M a 0 = Le (real_of_int d'); ?a1.6 = Lt aa; ?a2.6 = Lt b;\n        aa < b\\<rbrakk>\n       \\<Longrightarrow> Le (real_of_int d') \\<prec> Le (real_of_int d - 1)\n 8. \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (real_of_int d);\n     M\\<^sub>R a 0 = Lt (real_of_int d);\n     M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n     M a 0 = Lt (real_of_int d')\\<rbrakk>\n    \\<Longrightarrow> Lt (real_of_int d') \\<prec> Le (real_of_int d - 1)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (real_of_int d);\n     M\\<^sub>R a 0 = Lt (real_of_int d);\n     M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n     M a 0 = Lt (real_of_int d')\\<rbrakk>\n    \\<Longrightarrow> Lt (real_of_int d') \\<prec> Le (real_of_int d - 1)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (real_of_int d);\n     M\\<^sub>R a 0 = Lt (real_of_int d);\n     M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n     M a 0 = Lt (real_of_int d')\\<rbrakk>\n    \\<Longrightarrow> real_of_int d' \\<le> real_of_int d - 1", "apply (cases rule: dbm_lt.cases)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (real_of_int d);\n     M\\<^sub>R a 0 = Lt (real_of_int d);\n     M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n     M a 0 = Lt (real_of_int d')\\<rbrakk>\n    \\<Longrightarrow> ?a1.21 \\<prec> ?a2.21\n 2. \\<And>uu_.\n       \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (real_of_int d);\n        M\\<^sub>R a 0 = Lt (real_of_int d);\n        M\\<^sub>R 0 a = Lt (1 - real_of_int d); M a 0 = Lt (real_of_int d');\n        ?a1.21 = Lt uu_; ?a2.21 = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> real_of_int d' \\<le> real_of_int d - 1\n 3. \\<And>uv_.\n       \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (real_of_int d);\n        M\\<^sub>R a 0 = Lt (real_of_int d);\n        M\\<^sub>R 0 a = Lt (1 - real_of_int d); M a 0 = Lt (real_of_int d');\n        ?a1.21 = Le uv_; ?a2.21 = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> real_of_int d' \\<le> real_of_int d - 1\n 4. \\<And>aa b.\n       \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (real_of_int d);\n        M\\<^sub>R a 0 = Lt (real_of_int d);\n        M\\<^sub>R 0 a = Lt (1 - real_of_int d); M a 0 = Lt (real_of_int d');\n        ?a1.21 = Le aa; ?a2.21 = Le b; aa < b\\<rbrakk>\n       \\<Longrightarrow> real_of_int d' \\<le> real_of_int d - 1\n 5. \\<And>aa b.\n       \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (real_of_int d);\n        M\\<^sub>R a 0 = Lt (real_of_int d);\n        M\\<^sub>R 0 a = Lt (1 - real_of_int d); M a 0 = Lt (real_of_int d');\n        ?a1.21 = Le aa; ?a2.21 = Lt b; aa < b\\<rbrakk>\n       \\<Longrightarrow> real_of_int d' \\<le> real_of_int d - 1\n 6. \\<And>aa b.\n       \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (real_of_int d);\n        M\\<^sub>R a 0 = Lt (real_of_int d);\n        M\\<^sub>R 0 a = Lt (1 - real_of_int d); M a 0 = Lt (real_of_int d');\n        ?a1.21 = Lt aa; ?a2.21 = Le b; aa \\<le> b\\<rbrakk>\n       \\<Longrightarrow> real_of_int d' \\<le> real_of_int d - 1\n 7. \\<And>aa b.\n       \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (real_of_int d);\n        M\\<^sub>R a 0 = Lt (real_of_int d);\n        M\\<^sub>R 0 a = Lt (1 - real_of_int d); M a 0 = Lt (real_of_int d');\n        ?a1.21 = Lt aa; ?a2.21 = Lt b; aa < b\\<rbrakk>\n       \\<Longrightarrow> real_of_int d' \\<le> real_of_int d - 1", "by auto"], ["proof (state)\nthis:\n  M a 0 \\<le> Le (real_of_int (d - 1))\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with lt"], ["proof (chain)\npicking this:\n  M a 0 < M\\<^sub>R a 0\n  M a 0 \\<le> Le (real_of_int (d - 1))", "have \"M a 0 \\<le> Le (d - 1)\""], ["proof (prove)\nusing this:\n  M a 0 < M\\<^sub>R a 0\n  M a 0 \\<le> Le (real_of_int (d - 1))\n\ngoal (1 subgoal):\n 1. M a 0 \\<le> Le (real_of_int (d - 1))", "by auto"], ["proof (state)\nthis:\n  M a 0 \\<le> Le (real_of_int (d - 1))\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from dbm_le'2[OF assms(2)[folded M(1)] this C2 C(1) not0]"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (d - 1)}", "have\n            \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 \\<le> d - 1}\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (d - 1)}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub>\n    \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (d - 1)}", "by auto"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (d - 1)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from beta_interp.\\<beta>_boundedness_le'[OF _ C(2) this] **"], ["proof (chain)\npicking this:\n  d - 1 \\<le> int (k c1) \\<Longrightarrow>\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (d - 1)}\n  d \\<le> int (k c1)", "have\n            \"Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>) \\<subseteq> {u \\<in> V. u c1 \\<le> d - 1}\""], ["proof (prove)\nusing this:\n  d - 1 \\<le> int (k c1) \\<Longrightarrow>\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (d - 1)}\n  d \\<le> int (k c1)\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n    \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (d - 1)}", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (d - 1)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (d - 1)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (d - 1)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume u: \"u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\""], ["proof (state)\nthis:\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C C2"], ["proof (chain)\npicking this:\n  v c1 = a\n  c1 \\<in> X\n  v' a = c1\n  a \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>", "have\n              \"dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)\""], ["proof (prove)\nusing this:\n  v c1 = a\n  c1 \\<in> X\n  v' a = c1\n  a \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  v c1 = a\n  c1 \\<in> X\n  v' a = c1\n  a \\<le> n\n  u \\<in> {u. Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n              (\\<forall>c.\n                  v c \\<le> n \\<longrightarrow>\n                  dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n                  dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n              (\\<forall>c1 c2.\n                  v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                  dbm_entry_val u (Some c1) (Some c2)\n                   (M\\<^sub>R (v c1) (v c2)))}\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)", "have \"u c1 > d - 1\""], ["proof (prove)\nusing this:\n  dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)\n\ngoal (1 subgoal):\n 1. real_of_int (d - 1) < u c1", "using 2"], ["proof (prove)\nusing this:\n  dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)\n  M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. real_of_int (d - 1) < u c1", "by auto"], ["proof (state)\nthis:\n  real_of_int (d - 1) < u c1\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  real_of_int (d - 1) < u c1", "have \"u \\<notin> {u \\<in> V. u c1 \\<le> d - 1}\""], ["proof (prove)\nusing this:\n  real_of_int (d - 1) < u c1\n\ngoal (1 subgoal):\n 1. u \\<notin> {u \\<in> V. u c1 \\<le> real_of_int (d - 1)}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> {u \\<in> V. u c1 \\<le> real_of_int (d - 1)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 \\<le> real_of_int (d - 1)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (d - 1)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 \\<le> real_of_int (d - 1)}", "show ?thesis"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (d - 1)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 \\<le> real_of_int (d - 1)}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "using M\\<^sub>R(1) M(1)"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (d - 1)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 \\<le> real_of_int (d - 1)}\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  [M]\\<^bsub>v,n\\<^esub> = Z\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, 0) \\<in> set (arcs i i ys); 0 < ?a3;\n   M\\<^sub>R ?a3 0 \\<noteq> \\<infinity>; M ?a3 0 < M\\<^sub>R ?a3 0\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "note bounded_zero_1 = this"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, 0) \\<in> set (arcs i i ys); 0 < ?a3;\n   M\\<^sub>R ?a3 0 \\<noteq> \\<infinity>; M ?a3 0 < M\\<^sub>R ?a3 0\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, 0) \\<in> set (arcs i i ys); 0 < ?a3;\n   M\\<^sub>R ?a3 0 \\<noteq> \\<infinity>; M ?a3 0 < M\\<^sub>R ?a3 0\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume A: \"(0,a) \\<in> set (arcs i i ys)\""], ["proof (state)\nthis:\n  (0, a) \\<in> set (arcs i i ys)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume not0: \"a > 0\""], ["proof (state)\nthis:\n  0 < a\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume bounded: \"M\\<^sub>R a 0 \\<noteq> \\<infinity>\""], ["proof (state)\nthis:\n  M\\<^sub>R a 0 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume lt: \"M 0 a < M\\<^sub>R 0 a\""], ["proof (state)\nthis:\n  M 0 a < M\\<^sub>R 0 a\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from clock_dest_2[OF A not0]"], ["proof (chain)\npicking this:\n  \\<exists>c\\<in>X. v c = a \\<and> v' a = c\n  a \\<le> n", "obtain c1 where C:\n          \"v c1 = a\" \"c1 \\<in> X\" \"v' a = c1\" and C2: \"a \\<le> n\""], ["proof (prove)\nusing this:\n  \\<exists>c\\<in>X. v c = a \\<and> v' a = c\n  a \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>c1.\n        \\<lbrakk>v c1 = a; c1 \\<in> X; v' a = c1; a \\<le> n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v c1 = a\n  c1 \\<in> X\n  v' a = c1\n  a \\<le> n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from C2 not0 bounded M\\<^sub>R(5)"], ["proof (chain)\npicking this:\n  a \\<le> n\n  0 < a\n  M\\<^sub>R a 0 \\<noteq> \\<infinity>\n  \\<forall>i\\<le>n.\n     0 < i \\<and> M\\<^sub>R i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n     (\\<exists>d\\<le>int (k (THE c. c \\<in> X \\<and> v c = i)).\n         0 \\<le> d \\<and>\n         (M\\<^sub>R i 0 = Le (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Le (real_of_int (- d)) \\<or>\n          M\\<^sub>R i 0 = Lt (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Lt (real_of_int (- d + 1))))", "obtain d :: int where *:\n          \"d \\<le> int (k (v' a))\"\n          \"M\\<^sub>R a 0 = Le d \\<and> M\\<^sub>R 0 a = Le (- d) \\<or> M\\<^sub>R a 0 = Lt d \\<and> M\\<^sub>R 0 a = Lt (- d + 1)\""], ["proof (prove)\nusing this:\n  a \\<le> n\n  0 < a\n  M\\<^sub>R a 0 \\<noteq> \\<infinity>\n  \\<forall>i\\<le>n.\n     0 < i \\<and> M\\<^sub>R i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n     (\\<exists>d\\<le>int (k (THE c. c \\<in> X \\<and> v c = i)).\n         0 \\<le> d \\<and>\n         (M\\<^sub>R i 0 = Le (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Le (real_of_int (- d)) \\<or>\n          M\\<^sub>R i 0 = Lt (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Lt (real_of_int (- d + 1))))\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>d \\<le> int (k (v' a));\n         M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n         M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<or>\n         M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n         M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding v'_def"], ["proof (prove)\nusing this:\n  a \\<le> n\n  0 < a\n  M\\<^sub>R a 0 \\<noteq> \\<infinity>\n  \\<forall>i\\<le>n.\n     0 < i \\<and> M\\<^sub>R i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n     (\\<exists>d\\<le>int (k (THE c. c \\<in> X \\<and> v c = i)).\n         0 \\<le> d \\<and>\n         (M\\<^sub>R i 0 = Le (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Le (real_of_int (- d)) \\<or>\n          M\\<^sub>R i 0 = Lt (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Lt (real_of_int (- d + 1))))\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>d \\<le> int (k (THE c. c \\<in> X \\<and> v c = a));\n         M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n         M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<or>\n         M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n         M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  d \\<le> int (k (v' a))\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C"], ["proof (chain)\npicking this:\n  v c1 = a\n  c1 \\<in> X\n  v' a = c1\n  d \\<le> int (k (v' a))\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))", "have **: \"- int (k c1) \\<le> - d\""], ["proof (prove)\nusing this:\n  v c1 = a\n  c1 \\<in> X\n  v' a = c1\n  d \\<le> int (k (v' a))\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. - int (k c1) \\<le> - d", "by auto"], ["proof (state)\nthis:\n  - int (k c1) \\<le> - d\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from *(2)"], ["proof (chain)\npicking this:\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))", "have ?thesis"], ["proof (prove)\nusing this:\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 1"], ["proof (state)\nthis:\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Le (real_of_int (- d))\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with lt"], ["proof (chain)\npicking this:\n  M 0 a < M\\<^sub>R 0 a\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Le (real_of_int (- d))", "have \"M 0 a < Le (-d)\""], ["proof (prove)\nusing this:\n  M 0 a < M\\<^sub>R 0 a\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Le (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. M 0 a < Le (real_of_int (- d))", "by auto"], ["proof (state)\nthis:\n  M 0 a < Le (real_of_int (- d))\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  M 0 a < Le (real_of_int (- d))", "have \"M 0 a \\<le> Lt (-d)\""], ["proof (prove)\nusing this:\n  M 0 a < Le (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. M 0 a \\<le> Lt (real_of_int (- d))", "unfolding less less_eq dbm_le_def"], ["proof (prove)\nusing this:\n  M 0 a \\<prec> Le (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. M 0 a \\<prec> Lt (real_of_int (- d)) \\<or>\n    M 0 a = Lt (real_of_int (- d))", "by (fastforce elim!: dbm_lt.cases)"], ["proof (state)\nthis:\n  M 0 a \\<le> Lt (real_of_int (- d))\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from dbm_lt'3[OF assms(2)[folded M(1)] this C2 C(1) not0]"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c1 < real_of_int (- d)}", "have\n            \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. d < u c1}\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c1 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. real_of_int d < u c1}", "by auto"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. real_of_int d < u c1}\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from beta_interp.\\<beta>_boundedness_gt'[OF _ C(2) this] **"], ["proof (chain)\npicking this:\n  d \\<le> int (k c1) \\<Longrightarrow>\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. real_of_int d < u c1}\n  - int (k c1) \\<le> - d", "have\n            \"Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>) \\<subseteq> {u \\<in> V. - u c1 < -d}\""], ["proof (prove)\nusing this:\n  d \\<le> int (k c1) \\<Longrightarrow>\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. real_of_int d < u c1}\n  - int (k c1) \\<le> - d\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n    \\<subseteq> {u \\<in> V. - u c1 < real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. - u c1 < real_of_int (- d)}\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. - u c1 < real_of_int (- d)}\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. - u c1 < real_of_int (- d)}\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix u"], ["proof (state)\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume u: \"u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\""], ["proof (state)\nthis:\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C C2"], ["proof (chain)\npicking this:\n  v c1 = a\n  c1 \\<in> X\n  v' a = c1\n  a \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>", "have\n              \"dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)\" \"dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)\""], ["proof (prove)\nusing this:\n  v c1 = a\n  c1 \\<in> X\n  v' a = c1\n  a \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) None (M\\<^sub>R a 0) &&&\n    dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  v c1 = a\n  c1 \\<in> X\n  v' a = c1\n  a \\<le> n\n  u \\<in> {u. Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n              (\\<forall>c.\n                  v c \\<le> n \\<longrightarrow>\n                  dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n                  dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n              (\\<forall>c1 c2.\n                  v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                  dbm_entry_val u (Some c1) (Some c2)\n                   (M\\<^sub>R (v c1) (v c2)))}\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) None (M\\<^sub>R a 0) &&&\n    dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)\n  dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with 1"], ["proof (chain)\npicking this:\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Le (real_of_int (- d))\n  dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)\n  dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)", "have \"u \\<notin> {u \\<in> V. - u c1 < -d}\""], ["proof (prove)\nusing this:\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Le (real_of_int (- d))\n  dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)\n  dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)\n\ngoal (1 subgoal):\n 1. u \\<notin> {u \\<in> V. - u c1 < real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> {u \\<in> V. - u c1 < real_of_int (- d)}\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. - u c1 < real_of_int (- d)}\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. - u c1 < real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. - u c1 < real_of_int (- d)}", "show ?thesis"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. - u c1 < real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. - u c1 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "using M\\<^sub>R(1) M(1)"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. - u c1 < real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. - u c1 < real_of_int (- d)}\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  [M]\\<^bsub>v,n\\<^esub> = Z\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 2"], ["proof (state)\nthis:\n  M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from 2 lt"], ["proof (chain)\npicking this:\n  M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))\n  M 0 a < M\\<^sub>R 0 a", "have \"M 0 a \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))\n  M 0 a < M\\<^sub>R 0 a\n\ngoal (1 subgoal):\n 1. M 0 a \\<noteq> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  M 0 a \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with dbm_entry_int[OF this] M(3) \\<open>a \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  get_const (M 0 a) \\<in> \\<int> \\<Longrightarrow>\n  \\<exists>d. M 0 a = Le (real_of_int d) \\<or> M 0 a = Lt (real_of_int d)\n  dbm_int M n\n  a \\<le> n\n  M 0 a \\<noteq> \\<infinity>", "obtain d' :: int where d': \"M 0 a = Le d' \\<or> M 0 a = Lt d'\""], ["proof (prove)\nusing this:\n  get_const (M 0 a) \\<in> \\<int> \\<Longrightarrow>\n  \\<exists>d. M 0 a = Le (real_of_int d) \\<or> M 0 a = Lt (real_of_int d)\n  dbm_int M n\n  a \\<le> n\n  M 0 a \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>d'.\n        M 0 a = Le (real_of_int d') \\<or>\n        M 0 a = Lt (real_of_int d') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M 0 a = Le (real_of_int d') \\<or> M 0 a = Lt (real_of_int d')\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  M 0 a = Le (real_of_int d') \\<or> M 0 a = Lt (real_of_int d')", "have \"M 0 a \\<le> Le (-d)\""], ["proof (prove)\nusing this:\n  M 0 a = Le (real_of_int d') \\<or> M 0 a = Lt (real_of_int d')\n\ngoal (1 subgoal):\n 1. M 0 a \\<le> Le (real_of_int (- d))", "using lt 2"], ["proof (prove)\nusing this:\n  M 0 a = Le (real_of_int d') \\<or> M 0 a = Lt (real_of_int d')\n  M 0 a < M\\<^sub>R 0 a\n  M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. M 0 a \\<le> Le (real_of_int (- d))", "apply (auto simp: less_eq dbm_le_def less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Le (real_of_int d') \\<prec> Lt (1 - real_of_int d);\n     M\\<^sub>R a 0 = Lt (real_of_int d);\n     M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n     real_of_int d' \\<noteq> - real_of_int d;\n     M 0 a = Le (real_of_int d')\\<rbrakk>\n    \\<Longrightarrow> Le (real_of_int d') \\<prec> Le (- real_of_int d)\n 2. \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (1 - real_of_int d);\n     M\\<^sub>R a 0 = Lt (real_of_int d);\n     M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n     M 0 a = Lt (real_of_int d')\\<rbrakk>\n    \\<Longrightarrow> Lt (real_of_int d') \\<prec> Le (- real_of_int d)", "apply (cases rule: dbm_lt.cases)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>Le (real_of_int d') \\<prec> Lt (1 - real_of_int d);\n     M\\<^sub>R a 0 = Lt (real_of_int d);\n     M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n     real_of_int d' \\<noteq> - real_of_int d;\n     M 0 a = Le (real_of_int d')\\<rbrakk>\n    \\<Longrightarrow> ?a1.6 \\<prec> ?a2.6\n 2. \\<And>uu_.\n       \\<lbrakk>Le (real_of_int d') \\<prec> Lt (1 - real_of_int d);\n        M\\<^sub>R a 0 = Lt (real_of_int d);\n        M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n        real_of_int d' \\<noteq> - real_of_int d;\n        M 0 a = Le (real_of_int d'); ?a1.6 = Lt uu_;\n        ?a2.6 = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> Le (real_of_int d') \\<prec> Le (- real_of_int d)\n 3. \\<And>uv_.\n       \\<lbrakk>Le (real_of_int d') \\<prec> Lt (1 - real_of_int d);\n        M\\<^sub>R a 0 = Lt (real_of_int d);\n        M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n        real_of_int d' \\<noteq> - real_of_int d;\n        M 0 a = Le (real_of_int d'); ?a1.6 = Le uv_;\n        ?a2.6 = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> Le (real_of_int d') \\<prec> Le (- real_of_int d)\n 4. \\<And>aa b.\n       \\<lbrakk>Le (real_of_int d') \\<prec> Lt (1 - real_of_int d);\n        M\\<^sub>R a 0 = Lt (real_of_int d);\n        M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n        real_of_int d' \\<noteq> - real_of_int d;\n        M 0 a = Le (real_of_int d'); ?a1.6 = Le aa; ?a2.6 = Le b;\n        aa < b\\<rbrakk>\n       \\<Longrightarrow> Le (real_of_int d') \\<prec> Le (- real_of_int d)\n 5. \\<And>aa b.\n       \\<lbrakk>Le (real_of_int d') \\<prec> Lt (1 - real_of_int d);\n        M\\<^sub>R a 0 = Lt (real_of_int d);\n        M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n        real_of_int d' \\<noteq> - real_of_int d;\n        M 0 a = Le (real_of_int d'); ?a1.6 = Le aa; ?a2.6 = Lt b;\n        aa < b\\<rbrakk>\n       \\<Longrightarrow> Le (real_of_int d') \\<prec> Le (- real_of_int d)\n 6. \\<And>aa b.\n       \\<lbrakk>Le (real_of_int d') \\<prec> Lt (1 - real_of_int d);\n        M\\<^sub>R a 0 = Lt (real_of_int d);\n        M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n        real_of_int d' \\<noteq> - real_of_int d;\n        M 0 a = Le (real_of_int d'); ?a1.6 = Lt aa; ?a2.6 = Le b;\n        aa \\<le> b\\<rbrakk>\n       \\<Longrightarrow> Le (real_of_int d') \\<prec> Le (- real_of_int d)\n 7. \\<And>aa b.\n       \\<lbrakk>Le (real_of_int d') \\<prec> Lt (1 - real_of_int d);\n        M\\<^sub>R a 0 = Lt (real_of_int d);\n        M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n        real_of_int d' \\<noteq> - real_of_int d;\n        M 0 a = Le (real_of_int d'); ?a1.6 = Lt aa; ?a2.6 = Lt b;\n        aa < b\\<rbrakk>\n       \\<Longrightarrow> Le (real_of_int d') \\<prec> Le (- real_of_int d)\n 8. \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (1 - real_of_int d);\n     M\\<^sub>R a 0 = Lt (real_of_int d);\n     M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n     M 0 a = Lt (real_of_int d')\\<rbrakk>\n    \\<Longrightarrow> Lt (real_of_int d') \\<prec> Le (- real_of_int d)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Le (real_of_int d') \\<prec> Lt (1 - real_of_int d);\n     M\\<^sub>R a 0 = Lt (real_of_int d);\n     M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n     real_of_int d' \\<noteq> - real_of_int d; M 0 a = Le (real_of_int d');\n     real_of_int d' < 1 - real_of_int d\\<rbrakk>\n    \\<Longrightarrow> Le (real_of_int d') \\<prec> Le (- real_of_int d)\n 2. \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (1 - real_of_int d);\n     M\\<^sub>R a 0 = Lt (real_of_int d);\n     M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n     M 0 a = Lt (real_of_int d')\\<rbrakk>\n    \\<Longrightarrow> Lt (real_of_int d') \\<prec> Le (- real_of_int d)", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Le (real_of_int d') \\<prec> Lt (1 - real_of_int d);\n     M\\<^sub>R a 0 = Lt (real_of_int d);\n     M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n     real_of_int d' \\<noteq> - real_of_int d; M 0 a = Le (real_of_int d');\n     real_of_int d' < 1 - real_of_int d\\<rbrakk>\n    \\<Longrightarrow> real_of_int d' < - real_of_int d\n 2. \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (1 - real_of_int d);\n     M\\<^sub>R a 0 = Lt (real_of_int d);\n     M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n     M 0 a = Lt (real_of_int d')\\<rbrakk>\n    \\<Longrightarrow> Lt (real_of_int d') \\<prec> Le (- real_of_int d)", "apply (metis get_const.simps(2) 2 of_int_less_iff of_int_minus zless_add1_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (1 - real_of_int d);\n     M\\<^sub>R a 0 = Lt (real_of_int d);\n     M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n     M 0 a = Lt (real_of_int d')\\<rbrakk>\n    \\<Longrightarrow> Lt (real_of_int d') \\<prec> Le (- real_of_int d)", "apply (cases rule: dbm_lt.cases)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (1 - real_of_int d);\n     M\\<^sub>R a 0 = Lt (real_of_int d);\n     M\\<^sub>R 0 a = Lt (1 - real_of_int d);\n     M 0 a = Lt (real_of_int d')\\<rbrakk>\n    \\<Longrightarrow> ?a1.22 \\<prec> ?a2.22\n 2. \\<And>uu_.\n       \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (1 - real_of_int d);\n        M\\<^sub>R a 0 = Lt (real_of_int d);\n        M\\<^sub>R 0 a = Lt (1 - real_of_int d); M 0 a = Lt (real_of_int d');\n        ?a1.22 = Lt uu_; ?a2.22 = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> Lt (real_of_int d') \\<prec> Le (- real_of_int d)\n 3. \\<And>uv_.\n       \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (1 - real_of_int d);\n        M\\<^sub>R a 0 = Lt (real_of_int d);\n        M\\<^sub>R 0 a = Lt (1 - real_of_int d); M 0 a = Lt (real_of_int d');\n        ?a1.22 = Le uv_; ?a2.22 = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> Lt (real_of_int d') \\<prec> Le (- real_of_int d)\n 4. \\<And>aa b.\n       \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (1 - real_of_int d);\n        M\\<^sub>R a 0 = Lt (real_of_int d);\n        M\\<^sub>R 0 a = Lt (1 - real_of_int d); M 0 a = Lt (real_of_int d');\n        ?a1.22 = Le aa; ?a2.22 = Le b; aa < b\\<rbrakk>\n       \\<Longrightarrow> Lt (real_of_int d') \\<prec> Le (- real_of_int d)\n 5. \\<And>aa b.\n       \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (1 - real_of_int d);\n        M\\<^sub>R a 0 = Lt (real_of_int d);\n        M\\<^sub>R 0 a = Lt (1 - real_of_int d); M 0 a = Lt (real_of_int d');\n        ?a1.22 = Le aa; ?a2.22 = Lt b; aa < b\\<rbrakk>\n       \\<Longrightarrow> Lt (real_of_int d') \\<prec> Le (- real_of_int d)\n 6. \\<And>aa b.\n       \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (1 - real_of_int d);\n        M\\<^sub>R a 0 = Lt (real_of_int d);\n        M\\<^sub>R 0 a = Lt (1 - real_of_int d); M 0 a = Lt (real_of_int d');\n        ?a1.22 = Lt aa; ?a2.22 = Le b; aa \\<le> b\\<rbrakk>\n       \\<Longrightarrow> Lt (real_of_int d') \\<prec> Le (- real_of_int d)\n 7. \\<And>aa b.\n       \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (1 - real_of_int d);\n        M\\<^sub>R a 0 = Lt (real_of_int d);\n        M\\<^sub>R 0 a = Lt (1 - real_of_int d); M 0 a = Lt (real_of_int d');\n        ?a1.22 = Lt aa; ?a2.22 = Lt b; aa < b\\<rbrakk>\n       \\<Longrightarrow> Lt (real_of_int d') \\<prec> Le (- real_of_int d)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (1 - real_of_int d);\n     M\\<^sub>R a 0 = Lt (real_of_int d);\n     M\\<^sub>R 0 a = Lt (1 - real_of_int d); M 0 a = Lt (real_of_int d');\n     real_of_int d' < 1 - real_of_int d\\<rbrakk>\n    \\<Longrightarrow> Lt (real_of_int d') \\<prec> Le (- real_of_int d)", "apply (rule dbm_lt.intros(5))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (1 - real_of_int d);\n     M\\<^sub>R a 0 = Lt (real_of_int d);\n     M\\<^sub>R 0 a = Lt (1 - real_of_int d); M 0 a = Lt (real_of_int d');\n     real_of_int d' < 1 - real_of_int d\\<rbrakk>\n    \\<Longrightarrow> real_of_int d' \\<le> - real_of_int d", "by (simp add: int_lt_Suc_le)"], ["proof (state)\nthis:\n  M 0 a \\<le> Le (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from dbm_le'3[OF assms(2)[folded M(1)] this C2 C(1) not0]"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. - u c1 \\<le> real_of_int (- d)}", "have\n            \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. d \\<le> u c1}\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. - u c1 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. real_of_int d \\<le> u c1}", "by auto"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. real_of_int d \\<le> u c1}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from beta_interp.\\<beta>_boundedness_ge'[OF _ C(2) this] **"], ["proof (chain)\npicking this:\n  d \\<le> int (k c1) \\<Longrightarrow>\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. real_of_int d \\<le> u c1}\n  - int (k c1) \\<le> - d", "have\n            \"Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>) \\<subseteq> {u \\<in> V. - u c1 \\<le> -d}\""], ["proof (prove)\nusing this:\n  d \\<le> int (k c1) \\<Longrightarrow>\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. real_of_int d \\<le> u c1}\n  - int (k c1) \\<le> - d\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n    \\<subseteq> {u \\<in> V. - u c1 \\<le> real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. - u c1 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. - u c1 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. - u c1 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume u: \"u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\""], ["proof (state)\nthis:\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C C2"], ["proof (chain)\npicking this:\n  v c1 = a\n  c1 \\<in> X\n  v' a = c1\n  a \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>", "have\n              \"dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)\""], ["proof (prove)\nusing this:\n  v c1 = a\n  c1 \\<in> X\n  v' a = c1\n  a \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  v c1 = a\n  c1 \\<in> X\n  v' a = c1\n  a \\<le> n\n  u \\<in> {u. Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n              (\\<forall>c.\n                  v c \\<le> n \\<longrightarrow>\n                  dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n                  dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n              (\\<forall>c1 c2.\n                  v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                  dbm_entry_val u (Some c1) (Some c2)\n                   (M\\<^sub>R (v c1) (v c2)))}\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with 2"], ["proof (chain)\npicking this:\n  M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))\n  dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)", "have \"u \\<notin> {u \\<in> V. - u c1 \\<le> -d}\""], ["proof (prove)\nusing this:\n  M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 a = Lt (real_of_int (- d + 1))\n  dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)\n\ngoal (1 subgoal):\n 1. u \\<notin> {u \\<in> V. - u c1 \\<le> real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> {u \\<in> V. - u c1 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. - u c1 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. - u c1 \\<le> real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. - u c1 \\<le> real_of_int (- d)}", "show ?thesis"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. - u c1 \\<le> real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. - u c1 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "using M\\<^sub>R(1) M(1)"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. - u c1 \\<le> real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. - u c1 \\<le> real_of_int (- d)}\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  [M]\\<^bsub>v,n\\<^esub> = Z\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(0, ?a3) \\<in> set (arcs i i ys); 0 < ?a3;\n   M\\<^sub>R ?a3 0 \\<noteq> \\<infinity>; M 0 ?a3 < M\\<^sub>R 0 ?a3\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "note bounded_zero_2 = this"], ["proof (state)\nthis:\n  \\<lbrakk>(0, ?a3) \\<in> set (arcs i i ys); 0 < ?a3;\n   M\\<^sub>R ?a3 0 \\<noteq> \\<infinity>; M 0 ?a3 < M\\<^sub>R 0 ?a3\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(0, ?a3) \\<in> set (arcs i i ys); 0 < ?a3;\n   M\\<^sub>R ?a3 0 \\<noteq> \\<infinity>; M 0 ?a3 < M\\<^sub>R 0 ?a3\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix a b c c1 c2"], ["proof (state)\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume A: \"(a,b) \\<in> set (arcs i i ys)\""], ["proof (state)\nthis:\n  (a, b) \\<in> set (arcs i i ys)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume not0: \"a > 0\" \"b > 0\""], ["proof (state)\nthis:\n  0 < a\n  0 < b\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume lt: \"M a b = Lt c\""], ["proof (state)\nthis:\n  M a b = Lt c\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume neg: \"M a b + M\\<^sub>R b a < \\<one>\""], ["proof (state)\nthis:\n  M a b + M\\<^sub>R b a < \\<one>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume C: \"v c1 = a\" \"v c2 = b\" \"c1 \\<in> X\" \"c2 \\<in> X\" and C2: \"a \\<le> n\" \"b \\<le> n\""], ["proof (state)\nthis:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume valid: \"-k c2 \\<le> -get_const (M\\<^sub>R b a)\" \"-get_const (M\\<^sub>R b a) \\<le> k c1\""], ["proof (state)\nthis:\n  real_of_int (- int (k c2)) \\<le> - get_const (M\\<^sub>R b a)\n  - get_const (M\\<^sub>R b a) \\<le> real (k c1)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from neg"], ["proof (chain)\npicking this:\n  M a b + M\\<^sub>R b a < \\<one>", "have \"M\\<^sub>R b a \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  M a b + M\\<^sub>R b a < \\<one>\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b a \\<noteq> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  M\\<^sub>R b a \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  M\\<^sub>R b a \\<noteq> \\<infinity>", "obtain d where *: \"M\\<^sub>R b a = Le d \\<or> M\\<^sub>R b a = Lt d\""], ["proof (prove)\nusing this:\n  M\\<^sub>R b a \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        M\\<^sub>R b a = Le d \\<or> M\\<^sub>R b a = Lt d \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"M\\<^sub>R b a\", auto)+"], ["proof (state)\nthis:\n  M\\<^sub>R b a = Le d \\<or> M\\<^sub>R b a = Lt d\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with M\\<^sub>R(7) \\<open>_ _ _ \\<noteq> \\<infinity>\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i j.\n     M\\<^sub>R i j \\<noteq> \\<infinity> \\<longrightarrow>\n     get_const (M\\<^sub>R i j) \\<in> \\<int>\n  M\\<^sub>R b a \\<noteq> \\<infinity>\n  M\\<^sub>R b a = Le d \\<or> M\\<^sub>R b a = Lt d", "have \"d \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     M\\<^sub>R i j \\<noteq> \\<infinity> \\<longrightarrow>\n     get_const (M\\<^sub>R i j) \\<in> \\<int>\n  M\\<^sub>R b a \\<noteq> \\<infinity>\n  M\\<^sub>R b a = Le d \\<or> M\\<^sub>R b a = Lt d\n\ngoal (1 subgoal):\n 1. d \\<in> \\<int>", "by fastforce"], ["proof (state)\nthis:\n  d \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with *"], ["proof (chain)\npicking this:\n  M\\<^sub>R b a = Le d \\<or> M\\<^sub>R b a = Lt d\n  d \\<in> \\<int>", "obtain d :: int where *: \"M\\<^sub>R b a = Le d \\<or> M\\<^sub>R b a = Lt d\""], ["proof (prove)\nusing this:\n  M\\<^sub>R b a = Le d \\<or> M\\<^sub>R b a = Lt d\n  d \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        M\\<^sub>R b a = Le (real_of_int d) \\<or>\n        M\\<^sub>R b a = Lt (real_of_int d) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Ints_cases"], ["proof (prove)\nusing this:\n  M\\<^sub>R b a = Le d \\<or> M\\<^sub>R b a = Lt d\n  d \\<in> \\<int>\n  \\<lbrakk>?q \\<in> \\<int>;\n   \\<And>z. ?q = of_int z \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        M\\<^sub>R b a = Le (real_of_int d) \\<or>\n        M\\<^sub>R b a = Lt (real_of_int d) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with valid"], ["proof (chain)\npicking this:\n  real_of_int (- int (k c2)) \\<le> - get_const (M\\<^sub>R b a)\n  - get_const (M\\<^sub>R b a) \\<le> real (k c1)\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)", "have valid: \"- k c2 \\<le> -d\" \"-d \\<le> k c1\""], ["proof (prove)\nusing this:\n  real_of_int (- int (k c2)) \\<le> - get_const (M\\<^sub>R b a)\n  - get_const (M\\<^sub>R b a) \\<le> real (k c1)\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. - int (k c2) \\<le> - d &&& - d \\<le> int (k c1)", "by auto"], ["proof (state)\nthis:\n  - int (k c2) \\<le> - d\n  - d \\<le> int (k c1)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from * neg lt"], ["proof (chain)\npicking this:\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)\n  M a b + M\\<^sub>R b a < \\<one>\n  M a b = Lt c", "have \"M a b \\<le> Lt (-d)\""], ["proof (prove)\nusing this:\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)\n  M a b + M\\<^sub>R b a < \\<one>\n  M a b = Lt c\n\ngoal (1 subgoal):\n 1. M a b \\<le> Lt (real_of_int (- d))", "unfolding less_eq dbm_le_def mult neutral less"], ["proof (prove)\nusing this:\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)\n  dbm_add (M a b) (M\\<^sub>R b a) \\<prec> Le 0\n  M a b = Lt c\n\ngoal (1 subgoal):\n 1. M a b \\<prec> Lt (real_of_int (- d)) \\<or>\n    M a b = Lt (real_of_int (- d))", "by (auto elim!: dbm_lt.cases)"], ["proof (state)\nthis:\n  M a b \\<le> Lt (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from dbm_lt'[OF assms(2)[folded M(1)] this C2 C(1,2) not0]"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}", "have\n          \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 < - d}\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub>\n    \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}", "."], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from beta_interp.\\<beta>_boundedness_diag_lt'[OF valid C(3,4) this]"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}", "have\n          \"Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>) \\<subseteq> {u \\<in> V. u c1 - u c2 < -d}\""], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n    \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}", "."], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume u: \"u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\""], ["proof (state)\nthis:\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C C2"], ["proof (chain)\npicking this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>", "have\n            \"dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)\""], ["proof (prove)\nusing this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  u \\<in> {u. Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n              (\\<forall>c.\n                  v c \\<le> n \\<longrightarrow>\n                  dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n                  dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n              (\\<forall>c1 c2.\n                  v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                  dbm_entry_val u (Some c1) (Some c2)\n                   (M\\<^sub>R (v c1) (v c2)))}\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with *"], ["proof (chain)\npicking this:\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)\n  dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)", "have \"u \\<notin> {u \\<in> V. u c1 - u c2 < -d}\""], ["proof (prove)\nusing this:\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)\n  dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)\n\ngoal (1 subgoal):\n 1. u \\<notin> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}", "have ?thesis"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "using M\\<^sub>R(1) M(1)"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  [M]\\<^bsub>v,n\\<^esub> = Z\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?a3; 0 < ?b3;\n   M ?a3 ?b3 = Lt ?c3; M ?a3 ?b3 + M\\<^sub>R ?b3 ?a3 < \\<one>;\n   v ?c1.3 = ?a3; v ?c2.3 = ?b3; ?c1.3 \\<in> X; ?c2.3 \\<in> X; ?a3 \\<le> n;\n   ?b3 \\<le> n;\n   real_of_int (- int (k ?c2.3)) \\<le> - get_const (M\\<^sub>R ?b3 ?a3);\n   - get_const (M\\<^sub>R ?b3 ?a3) \\<le> real (k ?c1.3)\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "note neg_sum_lt = this"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?a3; 0 < ?b3;\n   M ?a3 ?b3 = Lt ?c3; M ?a3 ?b3 + M\\<^sub>R ?b3 ?a3 < \\<one>;\n   v ?c1.3 = ?a3; v ?c2.3 = ?b3; ?c1.3 \\<in> X; ?c2.3 \\<in> X; ?a3 \\<le> n;\n   ?b3 \\<le> n;\n   real_of_int (- int (k ?c2.3)) \\<le> - get_const (M\\<^sub>R ?b3 ?a3);\n   - get_const (M\\<^sub>R ?b3 ?a3) \\<le> real (k ?c1.3)\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?a3; 0 < ?b3;\n   M ?a3 ?b3 = Lt ?c3; M ?a3 ?b3 + M\\<^sub>R ?b3 ?a3 < \\<one>;\n   v ?c1.3 = ?a3; v ?c2.3 = ?b3; ?c1.3 \\<in> X; ?c2.3 \\<in> X; ?a3 \\<le> n;\n   ?b3 \\<le> n;\n   real_of_int (- int (k ?c2.3)) \\<le> - get_const (M\\<^sub>R ?b3 ?a3);\n   - get_const (M\\<^sub>R ?b3 ?a3) \\<le> real (k ?c1.3)\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume A: \"(a,b) \\<in> set (arcs i i ys)\""], ["proof (state)\nthis:\n  (a, b) \\<in> set (arcs i i ys)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume not0: \"a > 0\" \"b > 0\""], ["proof (state)\nthis:\n  0 < a\n  0 < b\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume neg: \"M a b + M\\<^sub>R b a < \\<one>\""], ["proof (state)\nthis:\n  M a b + M\\<^sub>R b a < \\<one>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from clock_dest[OF A not0]"], ["proof (chain)\npicking this:\n  \\<exists>c1\\<in>X.\n     \\<exists>c2\\<in>X.\n        v c1 = a \\<and> v c2 = b \\<and> v' a = c1 \\<and> v' b = c2 &&&\n  a \\<le> n &&& b \\<le> n", "obtain c1 c2 where\n          C: \"v c1 = a\" \"v c2 = b\" \"c1 \\<in> X\" \"c2 \\<in> X\" and C2: \"a \\<le> n\" \"b \\<le> n\""], ["proof (prove)\nusing this:\n  \\<exists>c1\\<in>X.\n     \\<exists>c2\\<in>X.\n        v c1 = a \\<and> v c2 = b \\<and> v' a = c1 \\<and> v' b = c2 &&&\n  a \\<le> n &&& b \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        \\<lbrakk>v c1 = a; v c2 = b; c1 \\<in> X; c2 \\<in> X; a \\<le> n;\n         b \\<le> n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n", "have C3: \"v' a = c1\" \"v' b = c2\""], ["proof (prove)\nusing this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n\ngoal (1 subgoal):\n 1. v' a = c1 &&& v' b = c2", "unfolding v'_def"], ["proof (prove)\nusing this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n\ngoal (1 subgoal):\n 1. (THE c. c \\<in> X \\<and> v c = a) = c1 &&&\n    (THE c. c \\<in> X \\<and> v c = b) = c2", "using clock_numbering(1)"], ["proof (prove)\nusing this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n\ngoal (1 subgoal):\n 1. (THE c. c \\<in> X \\<and> v c = a) = c1 &&&\n    (THE c. c \\<in> X \\<and> v c = b) = c2", "by auto"], ["proof (state)\nthis:\n  v' a = c1\n  v' b = c2\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from neg"], ["proof (chain)\npicking this:\n  M a b + M\\<^sub>R b a < \\<one>", "have inf: \"M a b \\<noteq> \\<infinity>\" \"M\\<^sub>R b a \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  M a b + M\\<^sub>R b a < \\<one>\n\ngoal (1 subgoal):\n 1. M a b \\<noteq> \\<infinity> &&& M\\<^sub>R b a \\<noteq> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  M a b \\<noteq> \\<infinity>\n  M\\<^sub>R b a \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from M\\<^sub>R(8) inf not0 C(3,4) C2 C3"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        M\\<^sub>R i j \\<noteq> \\<infinity> \\<and>\n        0 < i \\<and> 0 < j \\<longrightarrow>\n        (\\<exists>d.\n            (M\\<^sub>R i j = Le (real_of_int d) \\<or>\n             M\\<^sub>R i j = Lt (real_of_int d)) \\<and>\n            - int (k (THE c. c \\<in> X \\<and> v c = j)) \\<le> d \\<and>\n            d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i)))\n  M a b \\<noteq> \\<infinity>\n  M\\<^sub>R b a \\<noteq> \\<infinity>\n  0 < a\n  0 < b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  v' a = c1\n  v' b = c2", "obtain d :: int where d:\n          \"M\\<^sub>R b a = Le d \\<or> M\\<^sub>R b a = Lt d\" \"- int (k c1) \\<le> d\" \"d \\<le> int (k c2)\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        M\\<^sub>R i j \\<noteq> \\<infinity> \\<and>\n        0 < i \\<and> 0 < j \\<longrightarrow>\n        (\\<exists>d.\n            (M\\<^sub>R i j = Le (real_of_int d) \\<or>\n             M\\<^sub>R i j = Lt (real_of_int d)) \\<and>\n            - int (k (THE c. c \\<in> X \\<and> v c = j)) \\<le> d \\<and>\n            d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i)))\n  M a b \\<noteq> \\<infinity>\n  M\\<^sub>R b a \\<noteq> \\<infinity>\n  0 < a\n  0 < b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  v' a = c1\n  v' b = c2\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>M\\<^sub>R b a = Le (real_of_int d) \\<or>\n                 M\\<^sub>R b a = Lt (real_of_int d);\n         - int (k c1) \\<le> d; d \\<le> int (k c2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding v'_def"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        M\\<^sub>R i j \\<noteq> \\<infinity> \\<and>\n        0 < i \\<and> 0 < j \\<longrightarrow>\n        (\\<exists>d.\n            (M\\<^sub>R i j = Le (real_of_int d) \\<or>\n             M\\<^sub>R i j = Lt (real_of_int d)) \\<and>\n            - int (k (THE c. c \\<in> X \\<and> v c = j)) \\<le> d \\<and>\n            d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i)))\n  M a b \\<noteq> \\<infinity>\n  M\\<^sub>R b a \\<noteq> \\<infinity>\n  0 < a\n  0 < b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  (THE c. c \\<in> X \\<and> v c = a) = c1\n  (THE c. c \\<in> X \\<and> v c = b) = c2\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>M\\<^sub>R b a = Le (real_of_int d) \\<or>\n                 M\\<^sub>R b a = Lt (real_of_int d);\n         - int (k c1) \\<le> d; d \\<le> int (k c2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> int (k c2)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from inf"], ["proof (chain)\npicking this:\n  M a b \\<noteq> \\<infinity>\n  M\\<^sub>R b a \\<noteq> \\<infinity>", "obtain c where c: \"M a b = Le c \\<or> M a b = Lt c\""], ["proof (prove)\nusing this:\n  M a b \\<noteq> \\<infinity>\n  M\\<^sub>R b a \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        M a b = Le c \\<or> M a b = Lt c \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"M a b\") auto"], ["proof (state)\nthis:\n  M a b = Le c \\<or> M a b = Lt c\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  M a b = Le c \\<or> M a b = Lt c\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume **: \"M a b \\<le> Lt (-d)\""], ["proof (state)\nthis:\n  M a b \\<le> Lt (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from dbm_lt'[OF assms(2)[folded M(1)] this C2 C(1,2) not0]"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}", "have\n            \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 < (- d)}\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub>\n    \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}", "."], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from beta_interp.\\<beta>_boundedness_diag_lt'[OF _ _ C(3,4) this] d"], ["proof (chain)\npicking this:\n  \\<lbrakk>- int (k c2) \\<le> - d; - d \\<le> int (k c1)\\<rbrakk>\n  \\<Longrightarrow> Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n                    \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> int (k c2)", "have\n            \"Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>) \\<subseteq> {u \\<in> V. u c1 - u c2 < -d}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>- int (k c2) \\<le> - d; - d \\<le> int (k c1)\\<rbrakk>\n  \\<Longrightarrow> Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n                    \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> int (k c2)\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n    \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume u: \"u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\""], ["proof (state)\nthis:\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C C2"], ["proof (chain)\npicking this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>", "have\n              \"dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)\""], ["proof (prove)\nusing this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  u \\<in> {u. Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n              (\\<forall>c.\n                  v c \\<le> n \\<longrightarrow>\n                  dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n                  dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n              (\\<forall>c1 c2.\n                  v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                  dbm_entry_val u (Some c1) (Some c2)\n                   (M\\<^sub>R (v c1) (v c2)))}\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with d"], ["proof (chain)\npicking this:\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> int (k c2)\n  dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)", "have \"u \\<notin> {u \\<in> V. u c1 - u c2 < -d}\""], ["proof (prove)\nusing this:\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> int (k c2)\n  dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)\n\ngoal (1 subgoal):\n 1. u \\<notin> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}", "have ?thesis"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "using M\\<^sub>R(1) M(1)"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 - u c2 < real_of_int (- d)}\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  [M]\\<^bsub>v,n\\<^esub> = Z\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  M a b \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "note aux = this"], ["proof (state)\nthis:\n  M a b \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from c"], ["proof (chain)\npicking this:\n  M a b = Le c \\<or> M a b = Lt c", "have ?thesis"], ["proof (prove)\nusing this:\n  M a b = Le c \\<or> M a b = Lt c\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. M a b = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M a b = Lt c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 2"], ["proof (state)\nthis:\n  M a b = Lt c\n\ngoal (2 subgoals):\n 1. M a b = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M a b = Lt c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with neg d"], ["proof (chain)\npicking this:\n  M a b + M\\<^sub>R b a < \\<one>\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> int (k c2)\n  M a b = Lt c", "have \"M a b \\<le> Lt (-d)\""], ["proof (prove)\nusing this:\n  M a b + M\\<^sub>R b a < \\<one>\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> int (k c2)\n  M a b = Lt c\n\ngoal (1 subgoal):\n 1. M a b \\<le> Lt (real_of_int (- d))", "unfolding less_eq dbm_le_def mult neutral less"], ["proof (prove)\nusing this:\n  dbm_add (M a b) (M\\<^sub>R b a) \\<prec> Le 0\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> int (k c2)\n  M a b = Lt c\n\ngoal (1 subgoal):\n 1. M a b \\<prec> Lt (real_of_int (- d)) \\<or>\n    M a b = Lt (real_of_int (- d))", "by (auto elim!: dbm_lt.cases)"], ["proof (state)\nthis:\n  M a b \\<le> Lt (real_of_int (- d))\n\ngoal (2 subgoals):\n 1. M a b = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M a b = Lt c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with aux"], ["proof (chain)\npicking this:\n  M a b \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  M a b \\<le> Lt (real_of_int (- d))", "show ?thesis"], ["proof (prove)\nusing this:\n  M a b \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  M a b \\<le> Lt (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "."], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. M a b = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M a b = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 1"], ["proof (state)\nthis:\n  M a b = Le c\n\ngoal (1 subgoal):\n 1. M a b = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "note A = this"], ["proof (state)\nthis:\n  M a b = Le c\n\ngoal (1 subgoal):\n 1. M a b = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from d(1)"], ["proof (chain)\npicking this:\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)", "show ?thesis"], ["proof (prove)\nusing this:\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. M\\<^sub>R b a = Le (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R b a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 1"], ["proof (state)\nthis:\n  M\\<^sub>R b a = Le (real_of_int d)\n\ngoal (2 subgoals):\n 1. M\\<^sub>R b a = Le (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R b a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with A neg d"], ["proof (chain)\npicking this:\n  M a b = Le c\n  M a b + M\\<^sub>R b a < \\<one>\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> int (k c2)\n  M\\<^sub>R b a = Le (real_of_int d)", "have \"M a b \\<le> Lt (-d)\""], ["proof (prove)\nusing this:\n  M a b = Le c\n  M a b + M\\<^sub>R b a < \\<one>\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> int (k c2)\n  M\\<^sub>R b a = Le (real_of_int d)\n\ngoal (1 subgoal):\n 1. M a b \\<le> Lt (real_of_int (- d))", "unfolding less_eq dbm_le_def mult neutral less"], ["proof (prove)\nusing this:\n  M a b = Le c\n  dbm_add (M a b) (M\\<^sub>R b a) \\<prec> Le 0\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> int (k c2)\n  M\\<^sub>R b a = Le (real_of_int d)\n\ngoal (1 subgoal):\n 1. M a b \\<prec> Lt (real_of_int (- d)) \\<or>\n    M a b = Lt (real_of_int (- d))", "by (auto elim!: dbm_lt.cases)"], ["proof (state)\nthis:\n  M a b \\<le> Lt (real_of_int (- d))\n\ngoal (2 subgoals):\n 1. M\\<^sub>R b a = Le (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R b a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with aux"], ["proof (chain)\npicking this:\n  M a b \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  M a b \\<le> Lt (real_of_int (- d))", "show ?thesis"], ["proof (prove)\nusing this:\n  M a b \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  M a b \\<le> Lt (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "."], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M\\<^sub>R b a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 2"], ["proof (state)\nthis:\n  M\\<^sub>R b a = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with A neg d"], ["proof (chain)\npicking this:\n  M a b = Le c\n  M a b + M\\<^sub>R b a < \\<one>\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> int (k c2)\n  M\\<^sub>R b a = Lt (real_of_int d)", "have \"M a b \\<le> Le (-d)\""], ["proof (prove)\nusing this:\n  M a b = Le c\n  M a b + M\\<^sub>R b a < \\<one>\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> int (k c2)\n  M\\<^sub>R b a = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. M a b \\<le> Le (real_of_int (- d))", "unfolding less_eq dbm_le_def mult neutral less"], ["proof (prove)\nusing this:\n  M a b = Le c\n  dbm_add (M a b) (M\\<^sub>R b a) \\<prec> Le 0\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> int (k c2)\n  M\\<^sub>R b a = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. M a b \\<prec> Le (real_of_int (- d)) \\<or>\n    M a b = Le (real_of_int (- d))", "by (auto elim!: dbm_lt.cases)"], ["proof (state)\nthis:\n  M a b \\<le> Le (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from dbm_le'[OF assms(2)[folded M(1)] this C2 C(1,2) not0]"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- d)}", "have\n              \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> - d}\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub>\n    \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- d)}", "."], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from beta_interp.\\<beta>_boundedness_diag_le'[OF _ _ C(3,4) this] d"], ["proof (chain)\npicking this:\n  \\<lbrakk>- int (k c2) \\<le> - d; - d \\<le> int (k c1)\\<rbrakk>\n  \\<Longrightarrow> Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n                    \\<subseteq> {u \\<in> V.\n                                 u c1 - u c2 \\<le> real_of_int (- d)}\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> int (k c2)", "have\n              \"Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>) \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> -d}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>- int (k c2) \\<le> - d; - d \\<le> int (k c1)\\<rbrakk>\n  \\<Longrightarrow> Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n                    \\<subseteq> {u \\<in> V.\n                                 u c1 - u c2 \\<le> real_of_int (- d)}\n  M\\<^sub>R b a = Le (real_of_int d) \\<or>\n  M\\<^sub>R b a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> int (k c2)\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n    \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. M\\<^sub>R b a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume u: \"u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\""], ["proof (state)\nthis:\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C C2"], ["proof (chain)\npicking this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>", "have\n                \"dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)\""], ["proof (prove)\nusing this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  u \\<in> {u. Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n              (\\<forall>c.\n                  v c \\<le> n \\<longrightarrow>\n                  dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n                  dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n              (\\<forall>c1 c2.\n                  v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                  dbm_entry_val u (Some c1) (Some c2)\n                   (M\\<^sub>R (v c1) (v c2)))}\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with A 2"], ["proof (chain)\npicking this:\n  M a b = Le c\n  M\\<^sub>R b a = Lt (real_of_int d)\n  dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)", "have \"u \\<notin> {u \\<in> V. u c1 - u c2 \\<le> -d}\""], ["proof (prove)\nusing this:\n  M a b = Le c\n  M\\<^sub>R b a = Lt (real_of_int d)\n  dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)\n\ngoal (1 subgoal):\n 1. u \\<notin> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- d)}", "show ?thesis"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "using M\\<^sub>R(1) M(1)"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- d)}\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  [M]\\<^bsub>v,n\\<^esub> = Z\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?a3; 0 < ?b3;\n   M ?a3 ?b3 + M\\<^sub>R ?b3 ?a3 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "note neg_sum_1 = this"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?a3; 0 < ?b3;\n   M ?a3 ?b3 + M\\<^sub>R ?b3 ?a3 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?a3; 0 < ?b3;\n   M ?a3 ?b3 + M\\<^sub>R ?b3 ?a3 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume A: \"(a,0) \\<in> set (arcs i i ys)\""], ["proof (state)\nthis:\n  (a, 0) \\<in> set (arcs i i ys)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume not0: \"a > 0\""], ["proof (state)\nthis:\n  0 < a\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume neg: \"M a 0 + M\\<^sub>R 0 a < \\<one>\""], ["proof (state)\nthis:\n  M a 0 + M\\<^sub>R 0 a < \\<one>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from clock_dest_1[OF A not0]"], ["proof (chain)\npicking this:\n  \\<exists>c\\<in>X. v c = a \\<and> v' a = c\n  a \\<le> n", "obtain c1 where C: \"v c1 = a\" \"c1 \\<in> X\" and C2: \"a \\<le> n\""], ["proof (prove)\nusing this:\n  \\<exists>c\\<in>X. v c = a \\<and> v' a = c\n  a \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>c1.\n        \\<lbrakk>v c1 = a; c1 \\<in> X; a \\<le> n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v c1 = a\n  c1 \\<in> X\n  a \\<le> n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with clock_numbering(1)"], ["proof (chain)\npicking this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  v c1 = a\n  c1 \\<in> X\n  a \\<le> n", "have C3: \"v' a = c1\""], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  v c1 = a\n  c1 \\<in> X\n  a \\<le> n\n\ngoal (1 subgoal):\n 1. v' a = c1", "unfolding v'_def"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  v c1 = a\n  c1 \\<in> X\n  a \\<le> n\n\ngoal (1 subgoal):\n 1. (THE c. c \\<in> X \\<and> v c = a) = c1", "by auto"], ["proof (state)\nthis:\n  v' a = c1\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from neg"], ["proof (chain)\npicking this:\n  M a 0 + M\\<^sub>R 0 a < \\<one>", "have inf: \"M a 0 \\<noteq> \\<infinity>\" \"M\\<^sub>R 0 a \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  M a 0 + M\\<^sub>R 0 a < \\<one>\n\ngoal (1 subgoal):\n 1. M a 0 \\<noteq> \\<infinity> &&& M\\<^sub>R 0 a \\<noteq> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  M a 0 \\<noteq> \\<infinity>\n  M\\<^sub>R 0 a \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from M\\<^sub>R(6) not0 C2 C3"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>n.\n     0 < i \\<longrightarrow>\n     (\\<exists>d\\<ge>- int (k (THE c. c \\<in> X \\<and> v c = i)).\n         d \\<le> 0 \\<and>\n         (M\\<^sub>R 0 i = Le (real_of_int d) \\<or>\n          M\\<^sub>R 0 i = Lt (real_of_int d)))\n  0 < a\n  a \\<le> n\n  v' a = c1", "obtain d :: int where d:\n          \"M\\<^sub>R 0 a = Le d \\<or> M\\<^sub>R 0 a = Lt d\" \"- int (k c1) \\<le> d\" \"d \\<le> 0\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n.\n     0 < i \\<longrightarrow>\n     (\\<exists>d\\<ge>- int (k (THE c. c \\<in> X \\<and> v c = i)).\n         d \\<le> 0 \\<and>\n         (M\\<^sub>R 0 i = Le (real_of_int d) \\<or>\n          M\\<^sub>R 0 i = Lt (real_of_int d)))\n  0 < a\n  a \\<le> n\n  v' a = c1\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>M\\<^sub>R 0 a = Le (real_of_int d) \\<or>\n                 M\\<^sub>R 0 a = Lt (real_of_int d);\n         - int (k c1) \\<le> d; d \\<le> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding v'_def"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n.\n     0 < i \\<longrightarrow>\n     (\\<exists>d\\<ge>- int (k (THE c. c \\<in> X \\<and> v c = i)).\n         d \\<le> 0 \\<and>\n         (M\\<^sub>R 0 i = Le (real_of_int d) \\<or>\n          M\\<^sub>R 0 i = Lt (real_of_int d)))\n  0 < a\n  a \\<le> n\n  (THE c. c \\<in> X \\<and> v c = a) = c1\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>M\\<^sub>R 0 a = Le (real_of_int d) \\<or>\n                 M\\<^sub>R 0 a = Lt (real_of_int d);\n         - int (k c1) \\<le> d; d \\<le> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M\\<^sub>R 0 a = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> 0\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from inf"], ["proof (chain)\npicking this:\n  M a 0 \\<noteq> \\<infinity>\n  M\\<^sub>R 0 a \\<noteq> \\<infinity>", "obtain c where c: \"M a 0 = Le c \\<or> M a 0 = Lt c\""], ["proof (prove)\nusing this:\n  M a 0 \\<noteq> \\<infinity>\n  M\\<^sub>R 0 a \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        M a 0 = Le c \\<or> M a 0 = Lt c \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"M a 0\") auto"], ["proof (state)\nthis:\n  M a 0 = Le c \\<or> M a 0 = Lt c\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  M a 0 = Le c \\<or> M a 0 = Lt c\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume \"M a 0 \\<le> Lt (-d)\""], ["proof (state)\nthis:\n  M a 0 \\<le> Lt (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from dbm_lt'2[OF assms(2)[folded M(1)] this C2 C(1) not0]"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 < real_of_int (- d)}", "have\n            \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 < - d}\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 < real_of_int (- d)}", "."], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from beta_interp.\\<beta>_boundedness_lt'[OF _ C(2) this] d"], ["proof (chain)\npicking this:\n  - d \\<le> int (k c1) \\<Longrightarrow>\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 < real_of_int (- d)}\n  M\\<^sub>R 0 a = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> 0", "have\n            \"Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>) \\<subseteq> {u \\<in> V. u c1 < -d}\""], ["proof (prove)\nusing this:\n  - d \\<le> int (k c1) \\<Longrightarrow>\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 < real_of_int (- d)}\n  M\\<^sub>R 0 a = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> 0\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n    \\<subseteq> {u \\<in> V. u c1 < real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume u: \"u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\""], ["proof (state)\nthis:\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C C2"], ["proof (chain)\npicking this:\n  v c1 = a\n  c1 \\<in> X\n  a \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>", "have\n              \"dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)\""], ["proof (prove)\nusing this:\n  v c1 = a\n  c1 \\<in> X\n  a \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  v c1 = a\n  c1 \\<in> X\n  a \\<le> n\n  u \\<in> {u. Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n              (\\<forall>c.\n                  v c \\<le> n \\<longrightarrow>\n                  dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n                  dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n              (\\<forall>c1 c2.\n                  v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                  dbm_entry_val u (Some c1) (Some c2)\n                   (M\\<^sub>R (v c1) (v c2)))}\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with d"], ["proof (chain)\npicking this:\n  M\\<^sub>R 0 a = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> 0\n  dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)", "have \"u \\<notin> {u \\<in> V. u c1 < -d}\""], ["proof (prove)\nusing this:\n  M\\<^sub>R 0 a = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> 0\n  dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)\n\ngoal (1 subgoal):\n 1. u \\<notin> {u \\<in> V. u c1 < real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> {u \\<in> V. u c1 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 < real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 < real_of_int (- d)}", "have ?thesis"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 < real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "using M\\<^sub>R(1) M(1)"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 < real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 < real_of_int (- d)}\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  [M]\\<^bsub>v,n\\<^esub> = Z\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  M a 0 \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "note aux = this"], ["proof (state)\nthis:\n  M a 0 \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from c"], ["proof (chain)\npicking this:\n  M a 0 = Le c \\<or> M a 0 = Lt c", "have ?thesis"], ["proof (prove)\nusing this:\n  M a 0 = Le c \\<or> M a 0 = Lt c\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. M a 0 = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M a 0 = Lt c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 2"], ["proof (state)\nthis:\n  M a 0 = Lt c\n\ngoal (2 subgoals):\n 1. M a 0 = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M a 0 = Lt c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with neg d"], ["proof (chain)\npicking this:\n  M a 0 + M\\<^sub>R 0 a < \\<one>\n  M\\<^sub>R 0 a = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> 0\n  M a 0 = Lt c", "have \"M a 0 \\<le> Lt (-d)\""], ["proof (prove)\nusing this:\n  M a 0 + M\\<^sub>R 0 a < \\<one>\n  M\\<^sub>R 0 a = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> 0\n  M a 0 = Lt c\n\ngoal (1 subgoal):\n 1. M a 0 \\<le> Lt (real_of_int (- d))", "unfolding less_eq dbm_le_def mult neutral less"], ["proof (prove)\nusing this:\n  dbm_add (M a 0) (M\\<^sub>R 0 a) \\<prec> Le 0\n  M\\<^sub>R 0 a = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> 0\n  M a 0 = Lt c\n\ngoal (1 subgoal):\n 1. M a 0 \\<prec> Lt (real_of_int (- d)) \\<or>\n    M a 0 = Lt (real_of_int (- d))", "by (auto elim!: dbm_lt.cases)"], ["proof (state)\nthis:\n  M a 0 \\<le> Lt (real_of_int (- d))\n\ngoal (2 subgoals):\n 1. M a 0 = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M a 0 = Lt c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with aux"], ["proof (chain)\npicking this:\n  M a 0 \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  M a 0 \\<le> Lt (real_of_int (- d))", "show ?thesis"], ["proof (prove)\nusing this:\n  M a 0 \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  M a 0 \\<le> Lt (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "."], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. M a 0 = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M a 0 = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 1"], ["proof (state)\nthis:\n  M a 0 = Le c\n\ngoal (1 subgoal):\n 1. M a 0 = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "note A = this"], ["proof (state)\nthis:\n  M a 0 = Le c\n\ngoal (1 subgoal):\n 1. M a 0 = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from d(1)"], ["proof (chain)\npicking this:\n  M\\<^sub>R 0 a = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 a = Lt (real_of_int d)", "show ?thesis"], ["proof (prove)\nusing this:\n  M\\<^sub>R 0 a = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 a = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. M\\<^sub>R 0 a = Le (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R 0 a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 1"], ["proof (state)\nthis:\n  M\\<^sub>R 0 a = Le (real_of_int d)\n\ngoal (2 subgoals):\n 1. M\\<^sub>R 0 a = Le (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R 0 a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with A neg d"], ["proof (chain)\npicking this:\n  M a 0 = Le c\n  M a 0 + M\\<^sub>R 0 a < \\<one>\n  M\\<^sub>R 0 a = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> 0\n  M\\<^sub>R 0 a = Le (real_of_int d)", "have \"M a 0 \\<le> Lt (-d)\""], ["proof (prove)\nusing this:\n  M a 0 = Le c\n  M a 0 + M\\<^sub>R 0 a < \\<one>\n  M\\<^sub>R 0 a = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> 0\n  M\\<^sub>R 0 a = Le (real_of_int d)\n\ngoal (1 subgoal):\n 1. M a 0 \\<le> Lt (real_of_int (- d))", "unfolding less_eq dbm_le_def mult neutral less"], ["proof (prove)\nusing this:\n  M a 0 = Le c\n  dbm_add (M a 0) (M\\<^sub>R 0 a) \\<prec> Le 0\n  M\\<^sub>R 0 a = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> 0\n  M\\<^sub>R 0 a = Le (real_of_int d)\n\ngoal (1 subgoal):\n 1. M a 0 \\<prec> Lt (real_of_int (- d)) \\<or>\n    M a 0 = Lt (real_of_int (- d))", "by (auto elim!: dbm_lt.cases)"], ["proof (state)\nthis:\n  M a 0 \\<le> Lt (real_of_int (- d))\n\ngoal (2 subgoals):\n 1. M\\<^sub>R 0 a = Le (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R 0 a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with aux"], ["proof (chain)\npicking this:\n  M a 0 \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  M a 0 \\<le> Lt (real_of_int (- d))", "show ?thesis"], ["proof (prove)\nusing this:\n  M a 0 \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  M a 0 \\<le> Lt (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "."], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 2"], ["proof (state)\nthis:\n  M\\<^sub>R 0 a = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with A neg d"], ["proof (chain)\npicking this:\n  M a 0 = Le c\n  M a 0 + M\\<^sub>R 0 a < \\<one>\n  M\\<^sub>R 0 a = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> 0\n  M\\<^sub>R 0 a = Lt (real_of_int d)", "have \"M a 0 \\<le> Le (-d)\""], ["proof (prove)\nusing this:\n  M a 0 = Le c\n  M a 0 + M\\<^sub>R 0 a < \\<one>\n  M\\<^sub>R 0 a = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> 0\n  M\\<^sub>R 0 a = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. M a 0 \\<le> Le (real_of_int (- d))", "unfolding less_eq dbm_le_def mult neutral less"], ["proof (prove)\nusing this:\n  M a 0 = Le c\n  dbm_add (M a 0) (M\\<^sub>R 0 a) \\<prec> Le 0\n  M\\<^sub>R 0 a = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> 0\n  M\\<^sub>R 0 a = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. M a 0 \\<prec> Le (real_of_int (- d)) \\<or>\n    M a 0 = Le (real_of_int (- d))", "by (auto elim!: dbm_lt.cases)"], ["proof (state)\nthis:\n  M a 0 \\<le> Le (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from dbm_le'2[OF assms(2)[folded M(1)] this C2 C(1) not0]"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (- d)}", "have\n              \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 \\<le> - d}\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub>\n    \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (- d)}", "."], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from beta_interp.\\<beta>_boundedness_le'[OF _ C(2) this] d"], ["proof (chain)\npicking this:\n  - d \\<le> int (k c1) \\<Longrightarrow>\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (- d)}\n  M\\<^sub>R 0 a = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> 0", "have\n              \"Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>) \\<subseteq> {u \\<in> V. u c1 \\<le> -d}\""], ["proof (prove)\nusing this:\n  - d \\<le> int (k c1) \\<Longrightarrow>\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (- d)}\n  M\\<^sub>R 0 a = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 a = Lt (real_of_int d)\n  - int (k c1) \\<le> d\n  d \\<le> 0\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n    \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume u: \"u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\""], ["proof (state)\nthis:\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C C2"], ["proof (chain)\npicking this:\n  v c1 = a\n  c1 \\<in> X\n  a \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>", "have\n                \"dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)\""], ["proof (prove)\nusing this:\n  v c1 = a\n  c1 \\<in> X\n  a \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  v c1 = a\n  c1 \\<in> X\n  a \\<le> n\n  u \\<in> {u. Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n              (\\<forall>c.\n                  v c \\<le> n \\<longrightarrow>\n                  dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n                  dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n              (\\<forall>c1 c2.\n                  v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                  dbm_entry_val u (Some c1) (Some c2)\n                   (M\\<^sub>R (v c1) (v c2)))}\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with A 2"], ["proof (chain)\npicking this:\n  M a 0 = Le c\n  M\\<^sub>R 0 a = Lt (real_of_int d)\n  dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)", "have \"u \\<notin> {u \\<in> V. u c1 \\<le> -d}\""], ["proof (prove)\nusing this:\n  M a 0 = Le c\n  M\\<^sub>R 0 a = Lt (real_of_int d)\n  dbm_entry_val u None (Some c1) (M\\<^sub>R 0 a)\n\ngoal (1 subgoal):\n 1. u \\<notin> {u \\<in> V. u c1 \\<le> real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> {u \\<in> V. u c1 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 a = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 \\<le> real_of_int (- d)}", "show ?thesis"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "using M\\<^sub>R(1) M(1)"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 \\<le> real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 \\<le> real_of_int (- d)}\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  [M]\\<^bsub>v,n\\<^esub> = Z\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, 0) \\<in> set (arcs i i ys); 0 < ?a3;\n   M ?a3 0 + M\\<^sub>R 0 ?a3 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "note neg_sum_1' = this"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, 0) \\<in> set (arcs i i ys); 0 < ?a3;\n   M ?a3 0 + M\\<^sub>R 0 ?a3 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, 0) \\<in> set (arcs i i ys); 0 < ?a3;\n   M ?a3 0 + M\\<^sub>R 0 ?a3 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume A: \"(0,b) \\<in> set (arcs i i ys)\""], ["proof (state)\nthis:\n  (0, b) \\<in> set (arcs i i ys)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume not0: \"b > 0\""], ["proof (state)\nthis:\n  0 < b\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume neg: \"M 0 b + M\\<^sub>R b 0 < \\<one>\""], ["proof (state)\nthis:\n  M 0 b + M\\<^sub>R b 0 < \\<one>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from clock_dest_2[OF A not0]"], ["proof (chain)\npicking this:\n  \\<exists>c\\<in>X. v c = b \\<and> v' b = c\n  b \\<le> n", "obtain c2 where\n          C:  \"v c2 = b\" \"c2 \\<in> X\" and C2: \"b \\<le> n\""], ["proof (prove)\nusing this:\n  \\<exists>c\\<in>X. v c = b \\<and> v' b = c\n  b \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>c2.\n        \\<lbrakk>v c2 = b; c2 \\<in> X; b \\<le> n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v c2 = b\n  c2 \\<in> X\n  b \\<le> n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with clock_numbering(1)"], ["proof (chain)\npicking this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  v c2 = b\n  c2 \\<in> X\n  b \\<le> n", "have C3: \"v' b = c2\""], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  v c2 = b\n  c2 \\<in> X\n  b \\<le> n\n\ngoal (1 subgoal):\n 1. v' b = c2", "unfolding v'_def"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  v c2 = b\n  c2 \\<in> X\n  b \\<le> n\n\ngoal (1 subgoal):\n 1. (THE c. c \\<in> X \\<and> v c = b) = c2", "by auto"], ["proof (state)\nthis:\n  v' b = c2\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from neg"], ["proof (chain)\npicking this:\n  M 0 b + M\\<^sub>R b 0 < \\<one>", "have \"M 0 b \\<noteq> \\<infinity>\" \"M\\<^sub>R b 0 \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  M 0 b + M\\<^sub>R b 0 < \\<one>\n\ngoal (1 subgoal):\n 1. M 0 b \\<noteq> \\<infinity> &&& M\\<^sub>R b 0 \\<noteq> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  M 0 b \\<noteq> \\<infinity>\n  M\\<^sub>R b 0 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with M\\<^sub>R(5) not0 C2 C3"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>n.\n     0 < i \\<and> M\\<^sub>R i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n     (\\<exists>d\\<le>int (k (THE c. c \\<in> X \\<and> v c = i)).\n         0 \\<le> d \\<and>\n         (M\\<^sub>R i 0 = Le (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Le (real_of_int (- d)) \\<or>\n          M\\<^sub>R i 0 = Lt (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Lt (real_of_int (- d + 1))))\n  0 < b\n  b \\<le> n\n  v' b = c2\n  M 0 b \\<noteq> \\<infinity>\n  M\\<^sub>R b 0 \\<noteq> \\<infinity>", "obtain d :: int where d:\n          \"M\\<^sub>R b 0 = Le d \\<or> M\\<^sub>R b 0 = Lt d\" \"d \\<le> k c2\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n.\n     0 < i \\<and> M\\<^sub>R i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n     (\\<exists>d\\<le>int (k (THE c. c \\<in> X \\<and> v c = i)).\n         0 \\<le> d \\<and>\n         (M\\<^sub>R i 0 = Le (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Le (real_of_int (- d)) \\<or>\n          M\\<^sub>R i 0 = Lt (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Lt (real_of_int (- d + 1))))\n  0 < b\n  b \\<le> n\n  v' b = c2\n  M 0 b \\<noteq> \\<infinity>\n  M\\<^sub>R b 0 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>M\\<^sub>R b 0 = Le (real_of_int d) \\<or>\n                 M\\<^sub>R b 0 = Lt (real_of_int d);\n         d \\<le> int (k c2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding v'_def"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n.\n     0 < i \\<and> M\\<^sub>R i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n     (\\<exists>d\\<le>int (k (THE c. c \\<in> X \\<and> v c = i)).\n         0 \\<le> d \\<and>\n         (M\\<^sub>R i 0 = Le (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Le (real_of_int (- d)) \\<or>\n          M\\<^sub>R i 0 = Lt (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Lt (real_of_int (- d + 1))))\n  0 < b\n  b \\<le> n\n  (THE c. c \\<in> X \\<and> v c = b) = c2\n  M 0 b \\<noteq> \\<infinity>\n  M\\<^sub>R b 0 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>M\\<^sub>R b 0 = Le (real_of_int d) \\<or>\n                 M\\<^sub>R b 0 = Lt (real_of_int d);\n         d \\<le> int (k c2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  M\\<^sub>R b 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R b 0 = Lt (real_of_int d)\n  d \\<le> int (k c2)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from \\<open>M 0 b \\<noteq> \\<infinity>\\<close>"], ["proof (chain)\npicking this:\n  M 0 b \\<noteq> \\<infinity>", "obtain c where c: \"M 0 b = Le c \\<or> M 0 b = Lt c\""], ["proof (prove)\nusing this:\n  M 0 b \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        M 0 b = Le c \\<or> M 0 b = Lt c \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"M 0 b\") auto"], ["proof (state)\nthis:\n  M 0 b = Le c \\<or> M 0 b = Lt c\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  M 0 b = Le c \\<or> M 0 b = Lt c\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume \"M 0 b \\<le> Lt (-d)\""], ["proof (state)\nthis:\n  M 0 b \\<le> Lt (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from dbm_lt'3[OF assms(2)[folded M(1)] this C2 C(1) not0]"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c2 < real_of_int (- d)}", "have\n            \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c2 > d}\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. real_of_int d < u c2}", "by simp"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. real_of_int d < u c2}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from beta_interp.\\<beta>_boundedness_gt'[OF _ C(2) this] d"], ["proof (chain)\npicking this:\n  d \\<le> int (k c2) \\<Longrightarrow>\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. real_of_int d < u c2}\n  M\\<^sub>R b 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R b 0 = Lt (real_of_int d)\n  d \\<le> int (k c2)", "have\n            \"Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>) \\<subseteq> {u \\<in> V. - u c2 < -d}\""], ["proof (prove)\nusing this:\n  d \\<le> int (k c2) \\<Longrightarrow>\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. real_of_int d < u c2}\n  M\\<^sub>R b 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R b 0 = Lt (real_of_int d)\n  d \\<le> int (k c2)\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n    \\<subseteq> {u \\<in> V. - u c2 < real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. - u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. - u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. - u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume u: \"u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\""], ["proof (state)\nthis:\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C C2"], ["proof (chain)\npicking this:\n  v c2 = b\n  c2 \\<in> X\n  b \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>", "have\n              \"dbm_entry_val u (Some c2) None (M\\<^sub>R b 0)\""], ["proof (prove)\nusing this:\n  v c2 = b\n  c2 \\<in> X\n  b \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c2) None (M\\<^sub>R b 0)", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  v c2 = b\n  c2 \\<in> X\n  b \\<le> n\n  u \\<in> {u. Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n              (\\<forall>c.\n                  v c \\<le> n \\<longrightarrow>\n                  dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n                  dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n              (\\<forall>c1 c2.\n                  v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                  dbm_entry_val u (Some c1) (Some c2)\n                   (M\\<^sub>R (v c1) (v c2)))}\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c2) None (M\\<^sub>R b 0)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c2) None (M\\<^sub>R b 0)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with d"], ["proof (chain)\npicking this:\n  M\\<^sub>R b 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R b 0 = Lt (real_of_int d)\n  d \\<le> int (k c2)\n  dbm_entry_val u (Some c2) None (M\\<^sub>R b 0)", "have \"u \\<notin> {u \\<in> V. - u c2 < -d}\""], ["proof (prove)\nusing this:\n  M\\<^sub>R b 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R b 0 = Lt (real_of_int d)\n  d \\<le> int (k c2)\n  dbm_entry_val u (Some c2) None (M\\<^sub>R b 0)\n\ngoal (1 subgoal):\n 1. u \\<notin> {u \\<in> V. - u c2 < real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> {u \\<in> V. - u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. - u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. - u c2 < real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. - u c2 < real_of_int (- d)}", "have ?thesis"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. - u c2 < real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. - u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "using M\\<^sub>R(1) M(1)"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. - u c2 < real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. - u c2 < real_of_int (- d)}\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  [M]\\<^bsub>v,n\\<^esub> = Z\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  M 0 b \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "note aux = this"], ["proof (state)\nthis:\n  M 0 b \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from c"], ["proof (chain)\npicking this:\n  M 0 b = Le c \\<or> M 0 b = Lt c", "have ?thesis"], ["proof (prove)\nusing this:\n  M 0 b = Le c \\<or> M 0 b = Lt c\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. M 0 b = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M 0 b = Lt c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 2"], ["proof (state)\nthis:\n  M 0 b = Lt c\n\ngoal (2 subgoals):\n 1. M 0 b = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M 0 b = Lt c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with neg d"], ["proof (chain)\npicking this:\n  M 0 b + M\\<^sub>R b 0 < \\<one>\n  M\\<^sub>R b 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R b 0 = Lt (real_of_int d)\n  d \\<le> int (k c2)\n  M 0 b = Lt c", "have \"M 0 b \\<le> Lt (-d)\""], ["proof (prove)\nusing this:\n  M 0 b + M\\<^sub>R b 0 < \\<one>\n  M\\<^sub>R b 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R b 0 = Lt (real_of_int d)\n  d \\<le> int (k c2)\n  M 0 b = Lt c\n\ngoal (1 subgoal):\n 1. M 0 b \\<le> Lt (real_of_int (- d))", "unfolding less_eq dbm_le_def mult neutral less"], ["proof (prove)\nusing this:\n  dbm_add (M 0 b) (M\\<^sub>R b 0) \\<prec> Le 0\n  M\\<^sub>R b 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R b 0 = Lt (real_of_int d)\n  d \\<le> int (k c2)\n  M 0 b = Lt c\n\ngoal (1 subgoal):\n 1. M 0 b \\<prec> Lt (real_of_int (- d)) \\<or>\n    M 0 b = Lt (real_of_int (- d))", "by (auto elim!: dbm_lt.cases)"], ["proof (state)\nthis:\n  M 0 b \\<le> Lt (real_of_int (- d))\n\ngoal (2 subgoals):\n 1. M 0 b = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M 0 b = Lt c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with aux"], ["proof (chain)\npicking this:\n  M 0 b \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  M 0 b \\<le> Lt (real_of_int (- d))", "show ?thesis"], ["proof (prove)\nusing this:\n  M 0 b \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  M 0 b \\<le> Lt (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "."], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. M 0 b = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M 0 b = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case A: 1"], ["proof (state)\nthis:\n  M 0 b = Le c\n\ngoal (1 subgoal):\n 1. M 0 b = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from d(1)"], ["proof (chain)\npicking this:\n  M\\<^sub>R b 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R b 0 = Lt (real_of_int d)", "show ?thesis"], ["proof (prove)\nusing this:\n  M\\<^sub>R b 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R b 0 = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. M\\<^sub>R b 0 = Le (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R b 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 1"], ["proof (state)\nthis:\n  M\\<^sub>R b 0 = Le (real_of_int d)\n\ngoal (2 subgoals):\n 1. M\\<^sub>R b 0 = Le (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R b 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with A neg"], ["proof (chain)\npicking this:\n  M 0 b = Le c\n  M 0 b + M\\<^sub>R b 0 < \\<one>\n  M\\<^sub>R b 0 = Le (real_of_int d)", "have \"M 0 b \\<le> Lt (-d)\""], ["proof (prove)\nusing this:\n  M 0 b = Le c\n  M 0 b + M\\<^sub>R b 0 < \\<one>\n  M\\<^sub>R b 0 = Le (real_of_int d)\n\ngoal (1 subgoal):\n 1. M 0 b \\<le> Lt (real_of_int (- d))", "unfolding less_eq dbm_le_def mult neutral less"], ["proof (prove)\nusing this:\n  M 0 b = Le c\n  dbm_add (M 0 b) (M\\<^sub>R b 0) \\<prec> Le 0\n  M\\<^sub>R b 0 = Le (real_of_int d)\n\ngoal (1 subgoal):\n 1. M 0 b \\<prec> Lt (real_of_int (- d)) \\<or>\n    M 0 b = Lt (real_of_int (- d))", "by (auto elim!: dbm_lt.cases)"], ["proof (state)\nthis:\n  M 0 b \\<le> Lt (real_of_int (- d))\n\ngoal (2 subgoals):\n 1. M\\<^sub>R b 0 = Le (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R b 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with aux"], ["proof (chain)\npicking this:\n  M 0 b \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  M 0 b \\<le> Lt (real_of_int (- d))", "show ?thesis"], ["proof (prove)\nusing this:\n  M 0 b \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  M 0 b \\<le> Lt (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "."], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M\\<^sub>R b 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 2"], ["proof (state)\nthis:\n  M\\<^sub>R b 0 = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with A neg c"], ["proof (chain)\npicking this:\n  M 0 b = Le c\n  M 0 b + M\\<^sub>R b 0 < \\<one>\n  M 0 b = Le c \\<or> M 0 b = Lt c\n  M\\<^sub>R b 0 = Lt (real_of_int d)", "have \"M 0 b \\<le> Le (-d)\""], ["proof (prove)\nusing this:\n  M 0 b = Le c\n  M 0 b + M\\<^sub>R b 0 < \\<one>\n  M 0 b = Le c \\<or> M 0 b = Lt c\n  M\\<^sub>R b 0 = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. M 0 b \\<le> Le (real_of_int (- d))", "unfolding less_eq dbm_le_def mult neutral less"], ["proof (prove)\nusing this:\n  M 0 b = Le c\n  dbm_add (M 0 b) (M\\<^sub>R b 0) \\<prec> Le 0\n  M 0 b = Le c \\<or> M 0 b = Lt c\n  M\\<^sub>R b 0 = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. M 0 b \\<prec> Le (real_of_int (- d)) \\<or>\n    M 0 b = Le (real_of_int (- d))", "by (auto elim!: dbm_lt.cases)"], ["proof (state)\nthis:\n  M 0 b \\<le> Le (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from dbm_le'3[OF assms(2)[folded M(1)] this C2 C(1) not0]"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. - u c2 \\<le> real_of_int (- d)}", "have\n              \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c2 \\<ge> d}\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. - u c2 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. real_of_int d \\<le> u c2}", "by simp"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. real_of_int d \\<le> u c2}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from beta_interp.\\<beta>_boundedness_ge'[OF _ C(2) this] d(2)"], ["proof (chain)\npicking this:\n  d \\<le> int (k c2) \\<Longrightarrow>\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. real_of_int d \\<le> u c2}\n  d \\<le> int (k c2)", "have\n              \"Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>) \\<subseteq> {u \\<in> V. - u c2 \\<le> -d}\""], ["proof (prove)\nusing this:\n  d \\<le> int (k c2) \\<Longrightarrow>\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. real_of_int d \\<le> u c2}\n  d \\<le> int (k c2)\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n    \\<subseteq> {u \\<in> V. - u c2 \\<le> real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. - u c2 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. - u c2 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. - u c2 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. M\\<^sub>R b 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume u: \"u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\""], ["proof (state)\nthis:\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C C2"], ["proof (chain)\npicking this:\n  v c2 = b\n  c2 \\<in> X\n  b \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>", "have\n                \"dbm_entry_val u (Some c2) None (M\\<^sub>R b 0)\""], ["proof (prove)\nusing this:\n  v c2 = b\n  c2 \\<in> X\n  b \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c2) None (M\\<^sub>R b 0)", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  v c2 = b\n  c2 \\<in> X\n  b \\<le> n\n  u \\<in> {u. Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n              (\\<forall>c.\n                  v c \\<le> n \\<longrightarrow>\n                  dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n                  dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n              (\\<forall>c1 c2.\n                  v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                  dbm_entry_val u (Some c1) (Some c2)\n                   (M\\<^sub>R (v c1) (v c2)))}\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c2) None (M\\<^sub>R b 0)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c2) None (M\\<^sub>R b 0)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with A 2"], ["proof (chain)\npicking this:\n  M 0 b = Le c\n  M\\<^sub>R b 0 = Lt (real_of_int d)\n  dbm_entry_val u (Some c2) None (M\\<^sub>R b 0)", "have \"u \\<notin> {u \\<in> V. - u c2 \\<le> -d}\""], ["proof (prove)\nusing this:\n  M 0 b = Le c\n  M\\<^sub>R b 0 = Lt (real_of_int d)\n  dbm_entry_val u (Some c2) None (M\\<^sub>R b 0)\n\ngoal (1 subgoal):\n 1. u \\<notin> {u \\<in> V. - u c2 \\<le> real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> {u \\<in> V. - u c2 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. - u c2 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. - u c2 \\<le> real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. - u c2 \\<le> real_of_int (- d)}", "show ?thesis"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. - u c2 \\<le> real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. - u c2 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "using M\\<^sub>R(1) M(1)"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. - u c2 \\<le> real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. - u c2 \\<le> real_of_int (- d)}\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  [M]\\<^bsub>v,n\\<^esub> = Z\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(0, ?b3) \\<in> set (arcs i i ys); 0 < ?b3;\n   M 0 ?b3 + M\\<^sub>R ?b3 0 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "note neg_sum_1'' = this"], ["proof (state)\nthis:\n  \\<lbrakk>(0, ?b3) \\<in> set (arcs i i ys); 0 < ?b3;\n   M 0 ?b3 + M\\<^sub>R ?b3 0 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(0, ?b3) \\<in> set (arcs i i ys); 0 < ?b3;\n   M 0 ?b3 + M\\<^sub>R ?b3 0 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume A: \"(a,b) \\<in> set (arcs i i ys)\""], ["proof (state)\nthis:\n  (a, b) \\<in> set (arcs i i ys)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume not0: \"b > 0\" \"a > 0\""], ["proof (state)\nthis:\n  0 < b\n  0 < a\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume neg: \"M\\<^sub>R a b + M b a < \\<one>\""], ["proof (state)\nthis:\n  M\\<^sub>R a b + M b a < \\<one>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from clock_dest[OF A not0(2,1)]"], ["proof (chain)\npicking this:\n  \\<exists>c1\\<in>X.\n     \\<exists>c2\\<in>X.\n        v c1 = a \\<and> v c2 = b \\<and> v' a = c1 \\<and> v' b = c2 &&&\n  a \\<le> n &&& b \\<le> n", "obtain c1 c2 where\n          C: \"v c1 = a\" \"v c2 = b\" \"c1 \\<in> X\" \"c2 \\<in> X\" and C2: \"a \\<le> n\" \"b \\<le> n\""], ["proof (prove)\nusing this:\n  \\<exists>c1\\<in>X.\n     \\<exists>c2\\<in>X.\n        v c1 = a \\<and> v c2 = b \\<and> v' a = c1 \\<and> v' b = c2 &&&\n  a \\<le> n &&& b \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        \\<lbrakk>v c1 = a; v c2 = b; c1 \\<in> X; c2 \\<in> X; a \\<le> n;\n         b \\<le> n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n", "have C3: \"v' a = c1\" \"v' b = c2\""], ["proof (prove)\nusing this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n\ngoal (1 subgoal):\n 1. v' a = c1 &&& v' b = c2", "unfolding v'_def"], ["proof (prove)\nusing this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n\ngoal (1 subgoal):\n 1. (THE c. c \\<in> X \\<and> v c = a) = c1 &&&\n    (THE c. c \\<in> X \\<and> v c = b) = c2", "using clock_numbering(1)"], ["proof (prove)\nusing this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n\ngoal (1 subgoal):\n 1. (THE c. c \\<in> X \\<and> v c = a) = c1 &&&\n    (THE c. c \\<in> X \\<and> v c = b) = c2", "by auto"], ["proof (state)\nthis:\n  v' a = c1\n  v' b = c2\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from neg"], ["proof (chain)\npicking this:\n  M\\<^sub>R a b + M b a < \\<one>", "have inf: \"M b a \\<noteq> \\<infinity>\" \"M\\<^sub>R a b \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  M\\<^sub>R a b + M b a < \\<one>\n\ngoal (1 subgoal):\n 1. M b a \\<noteq> \\<infinity> &&& M\\<^sub>R a b \\<noteq> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  M b a \\<noteq> \\<infinity>\n  M\\<^sub>R a b \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with M\\<^sub>R(8) not0 C(3,4) C2 C3"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        M\\<^sub>R i j \\<noteq> \\<infinity> \\<and>\n        0 < i \\<and> 0 < j \\<longrightarrow>\n        (\\<exists>d.\n            (M\\<^sub>R i j = Le (real_of_int d) \\<or>\n             M\\<^sub>R i j = Lt (real_of_int d)) \\<and>\n            - int (k (THE c. c \\<in> X \\<and> v c = j)) \\<le> d \\<and>\n            d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i)))\n  0 < b\n  0 < a\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  v' a = c1\n  v' b = c2\n  M b a \\<noteq> \\<infinity>\n  M\\<^sub>R a b \\<noteq> \\<infinity>", "obtain d :: int where d:\n          \"M\\<^sub>R a b = Le d \\<or> M\\<^sub>R a b = Lt d\" \"d \\<ge> -int (k c2)\" \"d \\<le> int (k c1)\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        M\\<^sub>R i j \\<noteq> \\<infinity> \\<and>\n        0 < i \\<and> 0 < j \\<longrightarrow>\n        (\\<exists>d.\n            (M\\<^sub>R i j = Le (real_of_int d) \\<or>\n             M\\<^sub>R i j = Lt (real_of_int d)) \\<and>\n            - int (k (THE c. c \\<in> X \\<and> v c = j)) \\<le> d \\<and>\n            d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i)))\n  0 < b\n  0 < a\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  v' a = c1\n  v' b = c2\n  M b a \\<noteq> \\<infinity>\n  M\\<^sub>R a b \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>M\\<^sub>R a b = Le (real_of_int d) \\<or>\n                 M\\<^sub>R a b = Lt (real_of_int d);\n         - int (k c2) \\<le> d; d \\<le> int (k c1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding v'_def"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        M\\<^sub>R i j \\<noteq> \\<infinity> \\<and>\n        0 < i \\<and> 0 < j \\<longrightarrow>\n        (\\<exists>d.\n            (M\\<^sub>R i j = Le (real_of_int d) \\<or>\n             M\\<^sub>R i j = Lt (real_of_int d)) \\<and>\n            - int (k (THE c. c \\<in> X \\<and> v c = j)) \\<le> d \\<and>\n            d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i)))\n  0 < b\n  0 < a\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  (THE c. c \\<in> X \\<and> v c = a) = c1\n  (THE c. c \\<in> X \\<and> v c = b) = c2\n  M b a \\<noteq> \\<infinity>\n  M\\<^sub>R a b \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>M\\<^sub>R a b = Le (real_of_int d) \\<or>\n                 M\\<^sub>R a b = Lt (real_of_int d);\n         - int (k c2) \\<le> d; d \\<le> int (k c1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  M\\<^sub>R a b = Le (real_of_int d) \\<or>\n  M\\<^sub>R a b = Lt (real_of_int d)\n  - int (k c2) \\<le> d\n  d \\<le> int (k c1)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from inf"], ["proof (chain)\npicking this:\n  M b a \\<noteq> \\<infinity>\n  M\\<^sub>R a b \\<noteq> \\<infinity>", "obtain c where c: \"M b a = Le c \\<or> M b a = Lt c\""], ["proof (prove)\nusing this:\n  M b a \\<noteq> \\<infinity>\n  M\\<^sub>R a b \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        M b a = Le c \\<or> M b a = Lt c \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"M b a\") auto"], ["proof (state)\nthis:\n  M b a = Le c \\<or> M b a = Lt c\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  M b a = Le c \\<or> M b a = Lt c\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume \"M b a \\<le> Lt (-d)\""], ["proof (state)\nthis:\n  M b a \\<le> Lt (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from dbm_lt'[OF assms(2)[folded M(1)] this C2(2,1) C(2,1) not0]"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c2 - u c1 < real_of_int (- d)}", "have\n            \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c2 - u c1 < - d}\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c2 - u c1 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub>\n    \\<subseteq> {u \\<in> V. u c2 - u c1 < real_of_int (- d)}", "."], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c2 - u c1 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from beta_interp.\\<beta>_boundedness_diag_lt'[OF _ _ C(4,3) this] d"], ["proof (chain)\npicking this:\n  \\<lbrakk>- int (k c1) \\<le> - d; - d \\<le> int (k c2)\\<rbrakk>\n  \\<Longrightarrow> Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n                    \\<subseteq> {u \\<in> V. u c2 - u c1 < real_of_int (- d)}\n  M\\<^sub>R a b = Le (real_of_int d) \\<or>\n  M\\<^sub>R a b = Lt (real_of_int d)\n  - int (k c2) \\<le> d\n  d \\<le> int (k c1)", "have \"Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>) \\<subseteq> {u \\<in> V. u c2 - u c1 < -d}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>- int (k c1) \\<le> - d; - d \\<le> int (k c2)\\<rbrakk>\n  \\<Longrightarrow> Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n                    \\<subseteq> {u \\<in> V. u c2 - u c1 < real_of_int (- d)}\n  M\\<^sub>R a b = Le (real_of_int d) \\<or>\n  M\\<^sub>R a b = Lt (real_of_int d)\n  - int (k c2) \\<le> d\n  d \\<le> int (k c1)\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n    \\<subseteq> {u \\<in> V. u c2 - u c1 < real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 - u c1 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 - u c1 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 - u c1 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume u: \"u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\""], ["proof (state)\nthis:\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C C2"], ["proof (chain)\npicking this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>", "have\n              \"dbm_entry_val u (Some c1) (Some c2) (M\\<^sub>R a b)\""], ["proof (prove)\nusing this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) (Some c2) (M\\<^sub>R a b)", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  u \\<in> {u. Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n              (\\<forall>c.\n                  v c \\<le> n \\<longrightarrow>\n                  dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n                  dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n              (\\<forall>c1 c2.\n                  v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                  dbm_entry_val u (Some c1) (Some c2)\n                   (M\\<^sub>R (v c1) (v c2)))}\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) (Some c2) (M\\<^sub>R a b)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c1) (Some c2) (M\\<^sub>R a b)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with d"], ["proof (chain)\npicking this:\n  M\\<^sub>R a b = Le (real_of_int d) \\<or>\n  M\\<^sub>R a b = Lt (real_of_int d)\n  - int (k c2) \\<le> d\n  d \\<le> int (k c1)\n  dbm_entry_val u (Some c1) (Some c2) (M\\<^sub>R a b)", "have \"u \\<notin> {u \\<in> V. u c2 - u c1 < -d}\""], ["proof (prove)\nusing this:\n  M\\<^sub>R a b = Le (real_of_int d) \\<or>\n  M\\<^sub>R a b = Lt (real_of_int d)\n  - int (k c2) \\<le> d\n  d \\<le> int (k c1)\n  dbm_entry_val u (Some c1) (Some c2) (M\\<^sub>R a b)\n\ngoal (1 subgoal):\n 1. u \\<notin> {u \\<in> V. u c2 - u c1 < real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> {u \\<in> V. u c2 - u c1 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c2 - u c1 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 - u c1 < real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c2 - u c1 < real_of_int (- d)}", "have ?thesis"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 - u c1 < real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c2 - u c1 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "using M\\<^sub>R(1) M(1)"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 - u c1 < real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c2 - u c1 < real_of_int (- d)}\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  [M]\\<^bsub>v,n\\<^esub> = Z\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  M b a \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "note aux = this"], ["proof (state)\nthis:\n  M b a \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from c"], ["proof (chain)\npicking this:\n  M b a = Le c \\<or> M b a = Lt c", "have ?thesis"], ["proof (prove)\nusing this:\n  M b a = Le c \\<or> M b a = Lt c\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. M b a = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M b a = Lt c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 2"], ["proof (state)\nthis:\n  M b a = Lt c\n\ngoal (2 subgoals):\n 1. M b a = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M b a = Lt c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with neg d"], ["proof (chain)\npicking this:\n  M\\<^sub>R a b + M b a < \\<one>\n  M\\<^sub>R a b = Le (real_of_int d) \\<or>\n  M\\<^sub>R a b = Lt (real_of_int d)\n  - int (k c2) \\<le> d\n  d \\<le> int (k c1)\n  M b a = Lt c", "have \"M b a \\<le> Lt (-d)\""], ["proof (prove)\nusing this:\n  M\\<^sub>R a b + M b a < \\<one>\n  M\\<^sub>R a b = Le (real_of_int d) \\<or>\n  M\\<^sub>R a b = Lt (real_of_int d)\n  - int (k c2) \\<le> d\n  d \\<le> int (k c1)\n  M b a = Lt c\n\ngoal (1 subgoal):\n 1. M b a \\<le> Lt (real_of_int (- d))", "unfolding less_eq dbm_le_def mult neutral less"], ["proof (prove)\nusing this:\n  dbm_add (M\\<^sub>R a b) (M b a) \\<prec> Le 0\n  M\\<^sub>R a b = Le (real_of_int d) \\<or>\n  M\\<^sub>R a b = Lt (real_of_int d)\n  - int (k c2) \\<le> d\n  d \\<le> int (k c1)\n  M b a = Lt c\n\ngoal (1 subgoal):\n 1. M b a \\<prec> Lt (real_of_int (- d)) \\<or>\n    M b a = Lt (real_of_int (- d))", "by (auto elim!: dbm_lt.cases)"], ["proof (state)\nthis:\n  M b a \\<le> Lt (real_of_int (- d))\n\ngoal (2 subgoals):\n 1. M b a = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M b a = Lt c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with aux"], ["proof (chain)\npicking this:\n  M b a \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  M b a \\<le> Lt (real_of_int (- d))", "show ?thesis"], ["proof (prove)\nusing this:\n  M b a \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  M b a \\<le> Lt (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "."], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. M b a = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M b a = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case A: 1"], ["proof (state)\nthis:\n  M b a = Le c\n\ngoal (1 subgoal):\n 1. M b a = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from d(1)"], ["proof (chain)\npicking this:\n  M\\<^sub>R a b = Le (real_of_int d) \\<or>\n  M\\<^sub>R a b = Lt (real_of_int d)", "show ?thesis"], ["proof (prove)\nusing this:\n  M\\<^sub>R a b = Le (real_of_int d) \\<or>\n  M\\<^sub>R a b = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. M\\<^sub>R a b = Le (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 1"], ["proof (state)\nthis:\n  M\\<^sub>R a b = Le (real_of_int d)\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a b = Le (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with A neg d"], ["proof (chain)\npicking this:\n  M b a = Le c\n  M\\<^sub>R a b + M b a < \\<one>\n  M\\<^sub>R a b = Le (real_of_int d) \\<or>\n  M\\<^sub>R a b = Lt (real_of_int d)\n  - int (k c2) \\<le> d\n  d \\<le> int (k c1)\n  M\\<^sub>R a b = Le (real_of_int d)", "have \"M b a \\<le> Lt (-d)\""], ["proof (prove)\nusing this:\n  M b a = Le c\n  M\\<^sub>R a b + M b a < \\<one>\n  M\\<^sub>R a b = Le (real_of_int d) \\<or>\n  M\\<^sub>R a b = Lt (real_of_int d)\n  - int (k c2) \\<le> d\n  d \\<le> int (k c1)\n  M\\<^sub>R a b = Le (real_of_int d)\n\ngoal (1 subgoal):\n 1. M b a \\<le> Lt (real_of_int (- d))", "unfolding less_eq dbm_le_def mult neutral less"], ["proof (prove)\nusing this:\n  M b a = Le c\n  dbm_add (M\\<^sub>R a b) (M b a) \\<prec> Le 0\n  M\\<^sub>R a b = Le (real_of_int d) \\<or>\n  M\\<^sub>R a b = Lt (real_of_int d)\n  - int (k c2) \\<le> d\n  d \\<le> int (k c1)\n  M\\<^sub>R a b = Le (real_of_int d)\n\ngoal (1 subgoal):\n 1. M b a \\<prec> Lt (real_of_int (- d)) \\<or>\n    M b a = Lt (real_of_int (- d))", "by (auto elim!: dbm_lt.cases)"], ["proof (state)\nthis:\n  M b a \\<le> Lt (real_of_int (- d))\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a b = Le (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with aux"], ["proof (chain)\npicking this:\n  M b a \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  M b a \\<le> Lt (real_of_int (- d))", "show ?thesis"], ["proof (prove)\nusing this:\n  M b a \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  M b a \\<le> Lt (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "."], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M\\<^sub>R a b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 2"], ["proof (state)\nthis:\n  M\\<^sub>R a b = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with A neg d"], ["proof (chain)\npicking this:\n  M b a = Le c\n  M\\<^sub>R a b + M b a < \\<one>\n  M\\<^sub>R a b = Le (real_of_int d) \\<or>\n  M\\<^sub>R a b = Lt (real_of_int d)\n  - int (k c2) \\<le> d\n  d \\<le> int (k c1)\n  M\\<^sub>R a b = Lt (real_of_int d)", "have \"M b a \\<le> Le (-d)\""], ["proof (prove)\nusing this:\n  M b a = Le c\n  M\\<^sub>R a b + M b a < \\<one>\n  M\\<^sub>R a b = Le (real_of_int d) \\<or>\n  M\\<^sub>R a b = Lt (real_of_int d)\n  - int (k c2) \\<le> d\n  d \\<le> int (k c1)\n  M\\<^sub>R a b = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. M b a \\<le> Le (real_of_int (- d))", "unfolding less_eq dbm_le_def mult neutral less"], ["proof (prove)\nusing this:\n  M b a = Le c\n  dbm_add (M\\<^sub>R a b) (M b a) \\<prec> Le 0\n  M\\<^sub>R a b = Le (real_of_int d) \\<or>\n  M\\<^sub>R a b = Lt (real_of_int d)\n  - int (k c2) \\<le> d\n  d \\<le> int (k c1)\n  M\\<^sub>R a b = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. M b a \\<prec> Le (real_of_int (- d)) \\<or>\n    M b a = Le (real_of_int (- d))", "by (auto elim!: dbm_lt.cases)"], ["proof (state)\nthis:\n  M b a \\<le> Le (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from dbm_le'[OF assms(2)[folded M(1)] this C2(2,1) C(2,1) not0]"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c2 - u c1 \\<le> real_of_int (- d)}", "have\n              \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c2 - u c1 \\<le> - d}\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c2 - u c1 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub>\n    \\<subseteq> {u \\<in> V. u c2 - u c1 \\<le> real_of_int (- d)}", "."], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c2 - u c1 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from beta_interp.\\<beta>_boundedness_diag_le'[OF _ _ C(4,3) this] d"], ["proof (chain)\npicking this:\n  \\<lbrakk>- int (k c1) \\<le> - d; - d \\<le> int (k c2)\\<rbrakk>\n  \\<Longrightarrow> Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n                    \\<subseteq> {u \\<in> V.\n                                 u c2 - u c1 \\<le> real_of_int (- d)}\n  M\\<^sub>R a b = Le (real_of_int d) \\<or>\n  M\\<^sub>R a b = Lt (real_of_int d)\n  - int (k c2) \\<le> d\n  d \\<le> int (k c1)", "have \"Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>) \\<subseteq> {u \\<in> V. u c2 - u c1 \\<le> -d}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>- int (k c1) \\<le> - d; - d \\<le> int (k c2)\\<rbrakk>\n  \\<Longrightarrow> Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n                    \\<subseteq> {u \\<in> V.\n                                 u c2 - u c1 \\<le> real_of_int (- d)}\n  M\\<^sub>R a b = Le (real_of_int d) \\<or>\n  M\\<^sub>R a b = Lt (real_of_int d)\n  - int (k c2) \\<le> d\n  d \\<le> int (k c1)\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n    \\<subseteq> {u \\<in> V. u c2 - u c1 \\<le> real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 - u c1 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 - u c1 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 - u c1 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. M\\<^sub>R a b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume u: \"u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\""], ["proof (state)\nthis:\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C C2"], ["proof (chain)\npicking this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>", "have\n                \"dbm_entry_val u (Some c1) (Some c2) (M\\<^sub>R a b)\""], ["proof (prove)\nusing this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) (Some c2) (M\\<^sub>R a b)", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  u \\<in> {u. Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n              (\\<forall>c.\n                  v c \\<le> n \\<longrightarrow>\n                  dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n                  dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n              (\\<forall>c1 c2.\n                  v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                  dbm_entry_val u (Some c1) (Some c2)\n                   (M\\<^sub>R (v c1) (v c2)))}\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) (Some c2) (M\\<^sub>R a b)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c1) (Some c2) (M\\<^sub>R a b)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with A 2"], ["proof (chain)\npicking this:\n  M b a = Le c\n  M\\<^sub>R a b = Lt (real_of_int d)\n  dbm_entry_val u (Some c1) (Some c2) (M\\<^sub>R a b)", "have \"u \\<notin> {u \\<in> V. u c2 - u c1 \\<le> -d}\""], ["proof (prove)\nusing this:\n  M b a = Le c\n  M\\<^sub>R a b = Lt (real_of_int d)\n  dbm_entry_val u (Some c1) (Some c2) (M\\<^sub>R a b)\n\ngoal (1 subgoal):\n 1. u \\<notin> {u \\<in> V. u c2 - u c1 \\<le> real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> {u \\<in> V. u c2 - u c1 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c2 - u c1 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 - u c1 \\<le> real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c2 - u c1 \\<le> real_of_int (- d)}", "show ?thesis"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 - u c1 \\<le> real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c2 - u c1 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "using M\\<^sub>R(1) M(1)"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 - u c1 \\<le> real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c2 - u c1 \\<le> real_of_int (- d)}\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  [M]\\<^bsub>v,n\\<^esub> = Z\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?b3; 0 < ?a3;\n   M\\<^sub>R ?a3 ?b3 + M ?b3 ?a3 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "note neg_sum_2 = this"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?b3; 0 < ?a3;\n   M\\<^sub>R ?a3 ?b3 + M ?b3 ?a3 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?b3; 0 < ?a3;\n   M\\<^sub>R ?a3 ?b3 + M ?b3 ?a3 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume A: \"(a,0) \\<in> set (arcs i i ys)\""], ["proof (state)\nthis:\n  (a, 0) \\<in> set (arcs i i ys)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume not0: \"a > 0\""], ["proof (state)\nthis:\n  0 < a\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume neg: \"M\\<^sub>R a 0 + M 0 a < \\<one>\""], ["proof (state)\nthis:\n  M\\<^sub>R a 0 + M 0 a < \\<one>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from clock_dest_1[OF A not0]"], ["proof (chain)\npicking this:\n  \\<exists>c\\<in>X. v c = a \\<and> v' a = c\n  a \\<le> n", "obtain c1 where C: \"v c1 = a\" \"c1 \\<in> X\" and C2: \"a \\<le> n\""], ["proof (prove)\nusing this:\n  \\<exists>c\\<in>X. v c = a \\<and> v' a = c\n  a \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>c1.\n        \\<lbrakk>v c1 = a; c1 \\<in> X; a \\<le> n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v c1 = a\n  c1 \\<in> X\n  a \\<le> n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with clock_numbering(1)"], ["proof (chain)\npicking this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  v c1 = a\n  c1 \\<in> X\n  a \\<le> n", "have C3: \"v' a = c1\""], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  v c1 = a\n  c1 \\<in> X\n  a \\<le> n\n\ngoal (1 subgoal):\n 1. v' a = c1", "unfolding v'_def"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  v c1 = a\n  c1 \\<in> X\n  a \\<le> n\n\ngoal (1 subgoal):\n 1. (THE c. c \\<in> X \\<and> v c = a) = c1", "by auto"], ["proof (state)\nthis:\n  v' a = c1\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from neg"], ["proof (chain)\npicking this:\n  M\\<^sub>R a 0 + M 0 a < \\<one>", "have inf: \"M 0 a \\<noteq> \\<infinity>\" \"M\\<^sub>R a 0 \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  M\\<^sub>R a 0 + M 0 a < \\<one>\n\ngoal (1 subgoal):\n 1. M 0 a \\<noteq> \\<infinity> &&& M\\<^sub>R a 0 \\<noteq> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  M 0 a \\<noteq> \\<infinity>\n  M\\<^sub>R a 0 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with M\\<^sub>R(5) not0 C2 C3"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>n.\n     0 < i \\<and> M\\<^sub>R i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n     (\\<exists>d\\<le>int (k (THE c. c \\<in> X \\<and> v c = i)).\n         0 \\<le> d \\<and>\n         (M\\<^sub>R i 0 = Le (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Le (real_of_int (- d)) \\<or>\n          M\\<^sub>R i 0 = Lt (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Lt (real_of_int (- d + 1))))\n  0 < a\n  a \\<le> n\n  v' a = c1\n  M 0 a \\<noteq> \\<infinity>\n  M\\<^sub>R a 0 \\<noteq> \\<infinity>", "obtain d :: int where d:\n          \"M\\<^sub>R a 0 = Le d \\<or> M\\<^sub>R a 0 = Lt d\" \"d \\<le> int (k c1)\" \"d \\<ge> 0\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n.\n     0 < i \\<and> M\\<^sub>R i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n     (\\<exists>d\\<le>int (k (THE c. c \\<in> X \\<and> v c = i)).\n         0 \\<le> d \\<and>\n         (M\\<^sub>R i 0 = Le (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Le (real_of_int (- d)) \\<or>\n          M\\<^sub>R i 0 = Lt (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Lt (real_of_int (- d + 1))))\n  0 < a\n  a \\<le> n\n  v' a = c1\n  M 0 a \\<noteq> \\<infinity>\n  M\\<^sub>R a 0 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>M\\<^sub>R a 0 = Le (real_of_int d) \\<or>\n                 M\\<^sub>R a 0 = Lt (real_of_int d);\n         d \\<le> int (k c1); 0 \\<le> d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding v'_def"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n.\n     0 < i \\<and> M\\<^sub>R i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n     (\\<exists>d\\<le>int (k (THE c. c \\<in> X \\<and> v c = i)).\n         0 \\<le> d \\<and>\n         (M\\<^sub>R i 0 = Le (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Le (real_of_int (- d)) \\<or>\n          M\\<^sub>R i 0 = Lt (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Lt (real_of_int (- d + 1))))\n  0 < a\n  a \\<le> n\n  (THE c. c \\<in> X \\<and> v c = a) = c1\n  M 0 a \\<noteq> \\<infinity>\n  M\\<^sub>R a 0 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>M\\<^sub>R a 0 = Le (real_of_int d) \\<or>\n                 M\\<^sub>R a 0 = Lt (real_of_int d);\n         d \\<le> int (k c1); 0 \\<le> d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d)\n  d \\<le> int (k c1)\n  0 \\<le> d\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from inf"], ["proof (chain)\npicking this:\n  M 0 a \\<noteq> \\<infinity>\n  M\\<^sub>R a 0 \\<noteq> \\<infinity>", "obtain c where c: \"M 0 a = Le c \\<or> M 0 a = Lt c\""], ["proof (prove)\nusing this:\n  M 0 a \\<noteq> \\<infinity>\n  M\\<^sub>R a 0 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        M 0 a = Le c \\<or> M 0 a = Lt c \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"M 0 a\") auto"], ["proof (state)\nthis:\n  M 0 a = Le c \\<or> M 0 a = Lt c\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  M 0 a = Le c \\<or> M 0 a = Lt c\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume \"M 0 a \\<le> Lt (-d)\""], ["proof (state)\nthis:\n  M 0 a \\<le> Lt (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from dbm_lt'3[OF assms(2)[folded M(1)] this C2 C(1) not0]"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c1 < real_of_int (- d)}", "have\n            \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 > d}\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. - u c1 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. real_of_int d < u c1}", "by simp"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. real_of_int d < u c1}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from beta_interp.\\<beta>_boundedness_gt'[OF _ C(2) this] d"], ["proof (chain)\npicking this:\n  d \\<le> int (k c1) \\<Longrightarrow>\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. real_of_int d < u c1}\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d)\n  d \\<le> int (k c1)\n  0 \\<le> d", "have\n            \"Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>) \\<subseteq> {u \\<in> V. u c1 > d}\""], ["proof (prove)\nusing this:\n  d \\<le> int (k c1) \\<Longrightarrow>\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. real_of_int d < u c1}\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d)\n  d \\<le> int (k c1)\n  0 \\<le> d\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n    \\<subseteq> {u \\<in> V. real_of_int d < u c1}", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. real_of_int d < u c1}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. real_of_int d < u c1}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. real_of_int d < u c1}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume u: \"u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\""], ["proof (state)\nthis:\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C C2"], ["proof (chain)\npicking this:\n  v c1 = a\n  c1 \\<in> X\n  a \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>", "have\n              \"dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)\""], ["proof (prove)\nusing this:\n  v c1 = a\n  c1 \\<in> X\n  a \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  v c1 = a\n  c1 \\<in> X\n  a \\<le> n\n  u \\<in> {u. Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n              (\\<forall>c.\n                  v c \\<le> n \\<longrightarrow>\n                  dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n                  dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n              (\\<forall>c1 c2.\n                  v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                  dbm_entry_val u (Some c1) (Some c2)\n                   (M\\<^sub>R (v c1) (v c2)))}\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with d"], ["proof (chain)\npicking this:\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d)\n  d \\<le> int (k c1)\n  0 \\<le> d\n  dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)", "have \"u \\<notin> {u \\<in> V. u c1 > d}\""], ["proof (prove)\nusing this:\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d)\n  d \\<le> int (k c1)\n  0 \\<le> d\n  dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)\n\ngoal (1 subgoal):\n 1. u \\<notin> {u \\<in> V. real_of_int d < u c1}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> {u \\<in> V. real_of_int d < u c1}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. real_of_int d < u c1}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. real_of_int d < u c1}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. real_of_int d < u c1}", "have ?thesis"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. real_of_int d < u c1}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. real_of_int d < u c1}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "using M\\<^sub>R(1) M(1)"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. real_of_int d < u c1}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. real_of_int d < u c1}\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  [M]\\<^bsub>v,n\\<^esub> = Z\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  M 0 a \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "note aux = this"], ["proof (state)\nthis:\n  M 0 a \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from c"], ["proof (chain)\npicking this:\n  M 0 a = Le c \\<or> M 0 a = Lt c", "have ?thesis"], ["proof (prove)\nusing this:\n  M 0 a = Le c \\<or> M 0 a = Lt c\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. M 0 a = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M 0 a = Lt c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 2"], ["proof (state)\nthis:\n  M 0 a = Lt c\n\ngoal (2 subgoals):\n 1. M 0 a = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M 0 a = Lt c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with neg d"], ["proof (chain)\npicking this:\n  M\\<^sub>R a 0 + M 0 a < \\<one>\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d)\n  d \\<le> int (k c1)\n  0 \\<le> d\n  M 0 a = Lt c", "have \"M 0 a \\<le> Lt (-d)\""], ["proof (prove)\nusing this:\n  M\\<^sub>R a 0 + M 0 a < \\<one>\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d)\n  d \\<le> int (k c1)\n  0 \\<le> d\n  M 0 a = Lt c\n\ngoal (1 subgoal):\n 1. M 0 a \\<le> Lt (real_of_int (- d))", "unfolding less_eq dbm_le_def mult neutral less"], ["proof (prove)\nusing this:\n  dbm_add (M\\<^sub>R a 0) (M 0 a) \\<prec> Le 0\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d)\n  d \\<le> int (k c1)\n  0 \\<le> d\n  M 0 a = Lt c\n\ngoal (1 subgoal):\n 1. M 0 a \\<prec> Lt (real_of_int (- d)) \\<or>\n    M 0 a = Lt (real_of_int (- d))", "by (auto elim!: dbm_lt.cases)"], ["proof (state)\nthis:\n  M 0 a \\<le> Lt (real_of_int (- d))\n\ngoal (2 subgoals):\n 1. M 0 a = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M 0 a = Lt c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with aux"], ["proof (chain)\npicking this:\n  M 0 a \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  M 0 a \\<le> Lt (real_of_int (- d))", "show ?thesis"], ["proof (prove)\nusing this:\n  M 0 a \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  M 0 a \\<le> Lt (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "."], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. M 0 a = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M 0 a = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case A: 1"], ["proof (state)\nthis:\n  M 0 a = Le c\n\ngoal (1 subgoal):\n 1. M 0 a = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from d(1)"], ["proof (chain)\npicking this:\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d)", "show ?thesis"], ["proof (prove)\nusing this:\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 1"], ["proof (state)\nthis:\n  M\\<^sub>R a 0 = Le (real_of_int d)\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with A neg d"], ["proof (chain)\npicking this:\n  M 0 a = Le c\n  M\\<^sub>R a 0 + M 0 a < \\<one>\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d)\n  d \\<le> int (k c1)\n  0 \\<le> d\n  M\\<^sub>R a 0 = Le (real_of_int d)", "have \"M 0 a \\<le> Lt (-d)\""], ["proof (prove)\nusing this:\n  M 0 a = Le c\n  M\\<^sub>R a 0 + M 0 a < \\<one>\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d)\n  d \\<le> int (k c1)\n  0 \\<le> d\n  M\\<^sub>R a 0 = Le (real_of_int d)\n\ngoal (1 subgoal):\n 1. M 0 a \\<le> Lt (real_of_int (- d))", "unfolding less_eq dbm_le_def mult neutral less"], ["proof (prove)\nusing this:\n  M 0 a = Le c\n  dbm_add (M\\<^sub>R a 0) (M 0 a) \\<prec> Le 0\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d)\n  d \\<le> int (k c1)\n  0 \\<le> d\n  M\\<^sub>R a 0 = Le (real_of_int d)\n\ngoal (1 subgoal):\n 1. M 0 a \\<prec> Lt (real_of_int (- d)) \\<or>\n    M 0 a = Lt (real_of_int (- d))", "by (auto elim!: dbm_lt.cases)"], ["proof (state)\nthis:\n  M 0 a \\<le> Lt (real_of_int (- d))\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = Le (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R a 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with aux"], ["proof (chain)\npicking this:\n  M 0 a \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  M 0 a \\<le> Lt (real_of_int (- d))", "show ?thesis"], ["proof (prove)\nusing this:\n  M 0 a \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  M 0 a \\<le> Lt (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "."], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 2"], ["proof (state)\nthis:\n  M\\<^sub>R a 0 = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with A neg d"], ["proof (chain)\npicking this:\n  M 0 a = Le c\n  M\\<^sub>R a 0 + M 0 a < \\<one>\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d)\n  d \\<le> int (k c1)\n  0 \\<le> d\n  M\\<^sub>R a 0 = Lt (real_of_int d)", "have \"M 0 a \\<le> Le (-d)\""], ["proof (prove)\nusing this:\n  M 0 a = Le c\n  M\\<^sub>R a 0 + M 0 a < \\<one>\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d)\n  d \\<le> int (k c1)\n  0 \\<le> d\n  M\\<^sub>R a 0 = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. M 0 a \\<le> Le (real_of_int (- d))", "unfolding less_eq dbm_le_def mult neutral less"], ["proof (prove)\nusing this:\n  M 0 a = Le c\n  dbm_add (M\\<^sub>R a 0) (M 0 a) \\<prec> Le 0\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d)\n  d \\<le> int (k c1)\n  0 \\<le> d\n  M\\<^sub>R a 0 = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. M 0 a \\<prec> Le (real_of_int (- d)) \\<or>\n    M 0 a = Le (real_of_int (- d))", "by (auto elim!: dbm_lt.cases)"], ["proof (state)\nthis:\n  M 0 a \\<le> Le (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from dbm_le'3[OF assms(2)[folded M(1)] this C2 C(1) not0]"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. - u c1 \\<le> real_of_int (- d)}", "have\n              \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 \\<ge> d}\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. - u c1 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. real_of_int d \\<le> u c1}", "by simp"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. real_of_int d \\<le> u c1}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from beta_interp.\\<beta>_boundedness_ge'[OF _ C(2) this] d"], ["proof (chain)\npicking this:\n  d \\<le> int (k c1) \\<Longrightarrow>\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. real_of_int d \\<le> u c1}\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d)\n  d \\<le> int (k c1)\n  0 \\<le> d", "have\n              \"Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>) \\<subseteq> {u \\<in> V. u c1 \\<ge> d}\""], ["proof (prove)\nusing this:\n  d \\<le> int (k c1) \\<Longrightarrow>\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. real_of_int d \\<le> u c1}\n  M\\<^sub>R a 0 = Le (real_of_int d) \\<or>\n  M\\<^sub>R a 0 = Lt (real_of_int d)\n  d \\<le> int (k c1)\n  0 \\<le> d\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n    \\<subseteq> {u \\<in> V. real_of_int d \\<le> u c1}", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. real_of_int d \\<le> u c1}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. real_of_int d \\<le> u c1}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. real_of_int d \\<le> u c1}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume u: \"u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\""], ["proof (state)\nthis:\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C C2"], ["proof (chain)\npicking this:\n  v c1 = a\n  c1 \\<in> X\n  a \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>", "have\n                \"dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)\""], ["proof (prove)\nusing this:\n  v c1 = a\n  c1 \\<in> X\n  a \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  v c1 = a\n  c1 \\<in> X\n  a \\<le> n\n  u \\<in> {u. Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n              (\\<forall>c.\n                  v c \\<le> n \\<longrightarrow>\n                  dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n                  dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n              (\\<forall>c1 c2.\n                  v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                  dbm_entry_val u (Some c1) (Some c2)\n                   (M\\<^sub>R (v c1) (v c2)))}\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with A 2"], ["proof (chain)\npicking this:\n  M 0 a = Le c\n  M\\<^sub>R a 0 = Lt (real_of_int d)\n  dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)", "have \"u \\<notin> {u \\<in> V. u c1 \\<ge> d}\""], ["proof (prove)\nusing this:\n  M 0 a = Le c\n  M\\<^sub>R a 0 = Lt (real_of_int d)\n  dbm_entry_val u (Some c1) None (M\\<^sub>R a 0)\n\ngoal (1 subgoal):\n 1. u \\<notin> {u \\<in> V. real_of_int d \\<le> u c1}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> {u \\<in> V. real_of_int d \\<le> u c1}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. real_of_int d \\<le> u c1}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. real_of_int d \\<le> u c1}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. real_of_int d \\<le> u c1}", "show ?thesis"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. real_of_int d \\<le> u c1}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. real_of_int d \\<le> u c1}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "using M\\<^sub>R(1) M(1)"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. real_of_int d \\<le> u c1}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. real_of_int d \\<le> u c1}\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  [M]\\<^bsub>v,n\\<^esub> = Z\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, 0) \\<in> set (arcs i i ys); 0 < ?a3;\n   M\\<^sub>R ?a3 0 + M 0 ?a3 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "note neg_sum_2' = this"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, 0) \\<in> set (arcs i i ys); 0 < ?a3;\n   M\\<^sub>R ?a3 0 + M 0 ?a3 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, 0) \\<in> set (arcs i i ys); 0 < ?a3;\n   M\\<^sub>R ?a3 0 + M 0 ?a3 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume A: \"(0,b) \\<in> set (arcs i i ys)\""], ["proof (state)\nthis:\n  (0, b) \\<in> set (arcs i i ys)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume not0: \"b > 0\""], ["proof (state)\nthis:\n  0 < b\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume neg: \"M\\<^sub>R 0 b + M b 0 < \\<one>\""], ["proof (state)\nthis:\n  M\\<^sub>R 0 b + M b 0 < \\<one>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from clock_dest_2[OF A not0]"], ["proof (chain)\npicking this:\n  \\<exists>c\\<in>X. v c = b \\<and> v' b = c\n  b \\<le> n", "obtain c2 where\n          C:  \"v c2 = b\" \"c2 \\<in> X\" and C2: \"b \\<le> n\""], ["proof (prove)\nusing this:\n  \\<exists>c\\<in>X. v c = b \\<and> v' b = c\n  b \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>c2.\n        \\<lbrakk>v c2 = b; c2 \\<in> X; b \\<le> n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v c2 = b\n  c2 \\<in> X\n  b \\<le> n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with clock_numbering(1)"], ["proof (chain)\npicking this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  v c2 = b\n  c2 \\<in> X\n  b \\<le> n", "have C3: \"v' b = c2\""], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  v c2 = b\n  c2 \\<in> X\n  b \\<le> n\n\ngoal (1 subgoal):\n 1. v' b = c2", "unfolding v'_def"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  v c2 = b\n  c2 \\<in> X\n  b \\<le> n\n\ngoal (1 subgoal):\n 1. (THE c. c \\<in> X \\<and> v c = b) = c2", "by auto"], ["proof (state)\nthis:\n  v' b = c2\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from neg"], ["proof (chain)\npicking this:\n  M\\<^sub>R 0 b + M b 0 < \\<one>", "have \"M b 0 \\<noteq> \\<infinity>\" \"M\\<^sub>R 0 b \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  M\\<^sub>R 0 b + M b 0 < \\<one>\n\ngoal (1 subgoal):\n 1. M b 0 \\<noteq> \\<infinity> &&& M\\<^sub>R 0 b \\<noteq> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  M b 0 \\<noteq> \\<infinity>\n  M\\<^sub>R 0 b \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with M\\<^sub>R(6) not0 C2 C3"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>n.\n     0 < i \\<longrightarrow>\n     (\\<exists>d\\<ge>- int (k (THE c. c \\<in> X \\<and> v c = i)).\n         d \\<le> 0 \\<and>\n         (M\\<^sub>R 0 i = Le (real_of_int d) \\<or>\n          M\\<^sub>R 0 i = Lt (real_of_int d)))\n  0 < b\n  b \\<le> n\n  v' b = c2\n  M b 0 \\<noteq> \\<infinity>\n  M\\<^sub>R 0 b \\<noteq> \\<infinity>", "obtain d :: int where d:\n          \"M\\<^sub>R 0 b = Le d \\<or> M\\<^sub>R 0 b = Lt d\" \"-d \\<le> k c2\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n.\n     0 < i \\<longrightarrow>\n     (\\<exists>d\\<ge>- int (k (THE c. c \\<in> X \\<and> v c = i)).\n         d \\<le> 0 \\<and>\n         (M\\<^sub>R 0 i = Le (real_of_int d) \\<or>\n          M\\<^sub>R 0 i = Lt (real_of_int d)))\n  0 < b\n  b \\<le> n\n  v' b = c2\n  M b 0 \\<noteq> \\<infinity>\n  M\\<^sub>R 0 b \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>M\\<^sub>R 0 b = Le (real_of_int d) \\<or>\n                 M\\<^sub>R 0 b = Lt (real_of_int d);\n         - d \\<le> int (k c2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding v'_def"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n.\n     0 < i \\<longrightarrow>\n     (\\<exists>d\\<ge>- int (k (THE c. c \\<in> X \\<and> v c = i)).\n         d \\<le> 0 \\<and>\n         (M\\<^sub>R 0 i = Le (real_of_int d) \\<or>\n          M\\<^sub>R 0 i = Lt (real_of_int d)))\n  0 < b\n  b \\<le> n\n  (THE c. c \\<in> X \\<and> v c = b) = c2\n  M b 0 \\<noteq> \\<infinity>\n  M\\<^sub>R 0 b \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>M\\<^sub>R 0 b = Le (real_of_int d) \\<or>\n                 M\\<^sub>R 0 b = Lt (real_of_int d);\n         - d \\<le> int (k c2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  M\\<^sub>R 0 b = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 b = Lt (real_of_int d)\n  - d \\<le> int (k c2)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from \\<open>M b 0 \\<noteq> \\<infinity>\\<close>"], ["proof (chain)\npicking this:\n  M b 0 \\<noteq> \\<infinity>", "obtain c where c: \"M b 0 = Le c \\<or> M b 0 = Lt c\""], ["proof (prove)\nusing this:\n  M b 0 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        M b 0 = Le c \\<or> M b 0 = Lt c \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"M b 0\") auto"], ["proof (state)\nthis:\n  M b 0 = Le c \\<or> M b 0 = Lt c\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  M b 0 = Le c \\<or> M b 0 = Lt c\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume \"M b 0 \\<le> Lt (-d)\""], ["proof (state)\nthis:\n  M b 0 \\<le> Lt (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from dbm_lt'2[OF assms(2)[folded M(1)] this C2 C(1) not0]"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c2 < real_of_int (- d)}", "have\n            \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c2 < - d}\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c2 < real_of_int (- d)}", "by simp"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from beta_interp.\\<beta>_boundedness_lt'[OF _ C(2) this] d"], ["proof (chain)\npicking this:\n  - d \\<le> int (k c2) \\<Longrightarrow>\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 < real_of_int (- d)}\n  M\\<^sub>R 0 b = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 b = Lt (real_of_int d)\n  - d \\<le> int (k c2)", "have\n            \"Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>) \\<subseteq> {u \\<in> V. u c2 < -d}\""], ["proof (prove)\nusing this:\n  - d \\<le> int (k c2) \\<Longrightarrow>\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 < real_of_int (- d)}\n  M\\<^sub>R 0 b = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 b = Lt (real_of_int d)\n  - d \\<le> int (k c2)\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n    \\<subseteq> {u \\<in> V. u c2 < real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume u: \"u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\""], ["proof (state)\nthis:\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C C2"], ["proof (chain)\npicking this:\n  v c2 = b\n  c2 \\<in> X\n  b \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>", "have\n              \"dbm_entry_val u None (Some c2) (M\\<^sub>R 0 b)\""], ["proof (prove)\nusing this:\n  v c2 = b\n  c2 \\<in> X\n  b \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c2) (M\\<^sub>R 0 b)", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  v c2 = b\n  c2 \\<in> X\n  b \\<le> n\n  u \\<in> {u. Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n              (\\<forall>c.\n                  v c \\<le> n \\<longrightarrow>\n                  dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n                  dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n              (\\<forall>c1 c2.\n                  v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                  dbm_entry_val u (Some c1) (Some c2)\n                   (M\\<^sub>R (v c1) (v c2)))}\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c2) (M\\<^sub>R 0 b)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u None (Some c2) (M\\<^sub>R 0 b)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with d"], ["proof (chain)\npicking this:\n  M\\<^sub>R 0 b = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 b = Lt (real_of_int d)\n  - d \\<le> int (k c2)\n  dbm_entry_val u None (Some c2) (M\\<^sub>R 0 b)", "have \"u \\<notin> {u \\<in> V. u c2 < -d}\""], ["proof (prove)\nusing this:\n  M\\<^sub>R 0 b = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 b = Lt (real_of_int d)\n  - d \\<le> int (k c2)\n  dbm_entry_val u None (Some c2) (M\\<^sub>R 0 b)\n\ngoal (1 subgoal):\n 1. u \\<notin> {u \\<in> V. u c2 < real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> {u \\<in> V. u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 < real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c2 < real_of_int (- d)}", "have ?thesis"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 < real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c2 < real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "using M\\<^sub>R(1) M(1)"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 < real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c2 < real_of_int (- d)}\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  [M]\\<^bsub>v,n\\<^esub> = Z\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  M b 0 \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "note aux = this"], ["proof (state)\nthis:\n  M b 0 \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from c"], ["proof (chain)\npicking this:\n  M b 0 = Le c \\<or> M b 0 = Lt c", "have ?thesis"], ["proof (prove)\nusing this:\n  M b 0 = Le c \\<or> M b 0 = Lt c\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. M b 0 = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M b 0 = Lt c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 2"], ["proof (state)\nthis:\n  M b 0 = Lt c\n\ngoal (2 subgoals):\n 1. M b 0 = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M b 0 = Lt c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with neg d"], ["proof (chain)\npicking this:\n  M\\<^sub>R 0 b + M b 0 < \\<one>\n  M\\<^sub>R 0 b = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 b = Lt (real_of_int d)\n  - d \\<le> int (k c2)\n  M b 0 = Lt c", "have \"M b 0 \\<le> Lt (-d)\""], ["proof (prove)\nusing this:\n  M\\<^sub>R 0 b + M b 0 < \\<one>\n  M\\<^sub>R 0 b = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 b = Lt (real_of_int d)\n  - d \\<le> int (k c2)\n  M b 0 = Lt c\n\ngoal (1 subgoal):\n 1. M b 0 \\<le> Lt (real_of_int (- d))", "unfolding less_eq dbm_le_def mult neutral less"], ["proof (prove)\nusing this:\n  dbm_add (M\\<^sub>R 0 b) (M b 0) \\<prec> Le 0\n  M\\<^sub>R 0 b = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 b = Lt (real_of_int d)\n  - d \\<le> int (k c2)\n  M b 0 = Lt c\n\ngoal (1 subgoal):\n 1. M b 0 \\<prec> Lt (real_of_int (- d)) \\<or>\n    M b 0 = Lt (real_of_int (- d))", "by (auto elim!: dbm_lt.cases)"], ["proof (state)\nthis:\n  M b 0 \\<le> Lt (real_of_int (- d))\n\ngoal (2 subgoals):\n 1. M b 0 = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M b 0 = Lt c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with aux"], ["proof (chain)\npicking this:\n  M b 0 \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  M b 0 \\<le> Lt (real_of_int (- d))", "show ?thesis"], ["proof (prove)\nusing this:\n  M b 0 \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  M b 0 \\<le> Lt (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "."], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. M b 0 = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M b 0 = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 1"], ["proof (state)\nthis:\n  M b 0 = Le c\n\ngoal (1 subgoal):\n 1. M b 0 = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "note A = this"], ["proof (state)\nthis:\n  M b 0 = Le c\n\ngoal (1 subgoal):\n 1. M b 0 = Le c \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from d(1)"], ["proof (chain)\npicking this:\n  M\\<^sub>R 0 b = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 b = Lt (real_of_int d)", "show ?thesis"], ["proof (prove)\nusing this:\n  M\\<^sub>R 0 b = Le (real_of_int d) \\<or>\n  M\\<^sub>R 0 b = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. M\\<^sub>R 0 b = Le (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R 0 b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 1"], ["proof (state)\nthis:\n  M\\<^sub>R 0 b = Le (real_of_int d)\n\ngoal (2 subgoals):\n 1. M\\<^sub>R 0 b = Le (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R 0 b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with A neg"], ["proof (chain)\npicking this:\n  M b 0 = Le c\n  M\\<^sub>R 0 b + M b 0 < \\<one>\n  M\\<^sub>R 0 b = Le (real_of_int d)", "have \"M b 0 \\<le> Lt (-d)\""], ["proof (prove)\nusing this:\n  M b 0 = Le c\n  M\\<^sub>R 0 b + M b 0 < \\<one>\n  M\\<^sub>R 0 b = Le (real_of_int d)\n\ngoal (1 subgoal):\n 1. M b 0 \\<le> Lt (real_of_int (- d))", "unfolding less_eq dbm_le_def mult neutral less"], ["proof (prove)\nusing this:\n  M b 0 = Le c\n  dbm_add (M\\<^sub>R 0 b) (M b 0) \\<prec> Le 0\n  M\\<^sub>R 0 b = Le (real_of_int d)\n\ngoal (1 subgoal):\n 1. M b 0 \\<prec> Lt (real_of_int (- d)) \\<or>\n    M b 0 = Lt (real_of_int (- d))", "by (auto elim!: dbm_lt.cases)"], ["proof (state)\nthis:\n  M b 0 \\<le> Lt (real_of_int (- d))\n\ngoal (2 subgoals):\n 1. M\\<^sub>R 0 b = Le (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R 0 b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with aux"], ["proof (chain)\npicking this:\n  M b 0 \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  M b 0 \\<le> Lt (real_of_int (- d))", "show ?thesis"], ["proof (prove)\nusing this:\n  M b 0 \\<le> Lt (real_of_int (- d)) \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  M b 0 \\<le> Lt (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "."], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 2"], ["proof (state)\nthis:\n  M\\<^sub>R 0 b = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with A neg c"], ["proof (chain)\npicking this:\n  M b 0 = Le c\n  M\\<^sub>R 0 b + M b 0 < \\<one>\n  M b 0 = Le c \\<or> M b 0 = Lt c\n  M\\<^sub>R 0 b = Lt (real_of_int d)", "have \"M b 0 \\<le> Le (-d)\""], ["proof (prove)\nusing this:\n  M b 0 = Le c\n  M\\<^sub>R 0 b + M b 0 < \\<one>\n  M b 0 = Le c \\<or> M b 0 = Lt c\n  M\\<^sub>R 0 b = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. M b 0 \\<le> Le (real_of_int (- d))", "unfolding less_eq dbm_le_def mult neutral less"], ["proof (prove)\nusing this:\n  M b 0 = Le c\n  dbm_add (M\\<^sub>R 0 b) (M b 0) \\<prec> Le 0\n  M b 0 = Le c \\<or> M b 0 = Lt c\n  M\\<^sub>R 0 b = Lt (real_of_int d)\n\ngoal (1 subgoal):\n 1. M b 0 \\<prec> Le (real_of_int (- d)) \\<or>\n    M b 0 = Le (real_of_int (- d))", "by (auto elim!: dbm_lt.cases)"], ["proof (state)\nthis:\n  M b 0 \\<le> Le (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from dbm_le'2[OF assms(2)[folded M(1)] this C2 C(1) not0]"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c2 \\<le> real_of_int (- d)}", "have\n              \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c2 \\<le> - d}\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c2 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub>\n    \\<subseteq> {u \\<in> V. u c2 \\<le> real_of_int (- d)}", "by simp"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c2 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from beta_interp.\\<beta>_boundedness_le'[OF _ C(2) this] d(2)"], ["proof (chain)\npicking this:\n  - d \\<le> int (k c2) \\<Longrightarrow>\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 \\<le> real_of_int (- d)}\n  - d \\<le> int (k c2)", "have\n              \"Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>) \\<subseteq> {u \\<in> V. u c2 \\<le> -d}\""], ["proof (prove)\nusing this:\n  - d \\<le> int (k c2) \\<Longrightarrow>\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 \\<le> real_of_int (- d)}\n  - d \\<le> int (k c2)\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n    \\<subseteq> {u \\<in> V. u c2 \\<le> real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume u: \"u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\""], ["proof (state)\nthis:\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C C2"], ["proof (chain)\npicking this:\n  v c2 = b\n  c2 \\<in> X\n  b \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>", "have\n                \"dbm_entry_val u None (Some c2) (M\\<^sub>R 0 b)\""], ["proof (prove)\nusing this:\n  v c2 = b\n  c2 \\<in> X\n  b \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c2) (M\\<^sub>R 0 b)", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  v c2 = b\n  c2 \\<in> X\n  b \\<le> n\n  u \\<in> {u. Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n              (\\<forall>c.\n                  v c \\<le> n \\<longrightarrow>\n                  dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n                  dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n              (\\<forall>c1 c2.\n                  v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                  dbm_entry_val u (Some c1) (Some c2)\n                   (M\\<^sub>R (v c1) (v c2)))}\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c2) (M\\<^sub>R 0 b)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u None (Some c2) (M\\<^sub>R 0 b)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with A 2"], ["proof (chain)\npicking this:\n  M b 0 = Le c\n  M\\<^sub>R 0 b = Lt (real_of_int d)\n  dbm_entry_val u None (Some c2) (M\\<^sub>R 0 b)", "have \"u \\<notin> {u \\<in> V. u c2 \\<le> -d}\""], ["proof (prove)\nusing this:\n  M b 0 = Le c\n  M\\<^sub>R 0 b = Lt (real_of_int d)\n  dbm_entry_val u None (Some c2) (M\\<^sub>R 0 b)\n\ngoal (1 subgoal):\n 1. u \\<notin> {u \\<in> V. u c2 \\<le> real_of_int (- d)}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> {u \\<in> V. u c2 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c2 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 b = Lt (real_of_int d) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 \\<le> real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c2 \\<le> real_of_int (- d)}", "show ?thesis"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 \\<le> real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c2 \\<le> real_of_int (- d)}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "using M\\<^sub>R(1) M(1)"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c2 \\<le> real_of_int (- d)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c2 \\<le> real_of_int (- d)}\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  [M]\\<^bsub>v,n\\<^esub> = Z\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(0, ?b3) \\<in> set (arcs i i ys); 0 < ?b3;\n   M\\<^sub>R 0 ?b3 + M ?b3 0 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "note neg_sum_2'' = this"], ["proof (state)\nthis:\n  \\<lbrakk>(0, ?b3) \\<in> set (arcs i i ys); 0 < ?b3;\n   M\\<^sub>R 0 ?b3 + M ?b3 0 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(0, ?b3) \\<in> set (arcs i i ys); 0 < ?b3;\n   M\\<^sub>R 0 ?b3 + M ?b3 0 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume A: \"(a,b) \\<in> set (arcs i i ys)\""], ["proof (state)\nthis:\n  (a, b) \\<in> set (arcs i i ys)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume not0: \"a > 0\" \"b > 0\""], ["proof (state)\nthis:\n  0 < a\n  0 < b\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume bounded: \"M\\<^sub>R a 0 \\<noteq> \\<infinity>\" \"M\\<^sub>R b 0 \\<noteq> \\<infinity>\""], ["proof (state)\nthis:\n  M\\<^sub>R a 0 \\<noteq> \\<infinity>\n  M\\<^sub>R b 0 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume lt: \"M a b < M\\<^sub>R a b\""], ["proof (state)\nthis:\n  M a b < M\\<^sub>R a b\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from clock_dest[OF A not0]"], ["proof (chain)\npicking this:\n  \\<exists>c1\\<in>X.\n     \\<exists>c2\\<in>X.\n        v c1 = a \\<and> v c2 = b \\<and> v' a = c1 \\<and> v' b = c2 &&&\n  a \\<le> n &&& b \\<le> n", "obtain c1 c2 where\n          C: \"v c1 = a\" \"v c2 = b\" \"c1 \\<in> X\" \"c2 \\<in> X\" and C2: \"a \\<le> n\" \"b \\<le> n\""], ["proof (prove)\nusing this:\n  \\<exists>c1\\<in>X.\n     \\<exists>c2\\<in>X.\n        v c1 = a \\<and> v c2 = b \\<and> v' a = c1 \\<and> v' b = c2 &&&\n  a \\<le> n &&& b \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        \\<lbrakk>v c1 = a; v c2 = b; c1 \\<in> X; c2 \\<in> X; a \\<le> n;\n         b \\<le> n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from C C2 clock_numbering(1,3)"], ["proof (chain)\npicking this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>c\\<in>X. v c \\<le> n", "have C3: \"v' b = c2\" \"v' a = c1\""], ["proof (prove)\nusing this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>c\\<in>X. v c \\<le> n\n\ngoal (1 subgoal):\n 1. v' b = c2 &&& v' a = c1", "unfolding v'_def"], ["proof (prove)\nusing this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>c\\<in>X. v c \\<le> n\n\ngoal (1 subgoal):\n 1. (THE c. c \\<in> X \\<and> v c = b) = c2 &&&\n    (THE c. c \\<in> X \\<and> v c = a) = c1", "by blast+"], ["proof (state)\nthis:\n  v' b = c2\n  v' a = c1\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C C2 not0 bounded M\\<^sub>R(4)"], ["proof (chain)\npicking this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  0 < a\n  0 < b\n  M\\<^sub>R a 0 \\<noteq> \\<infinity>\n  M\\<^sub>R b 0 \\<noteq> \\<infinity>\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        0 < i \\<and>\n        0 < j \\<and>\n        M\\<^sub>R i 0 \\<noteq> \\<infinity> \\<and>\n        M\\<^sub>R j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n        (\\<exists>d.\n            - int (k (THE c. c \\<in> X \\<and> v c = j)) \\<le> d \\<and>\n            d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i)) \\<and>\n            M\\<^sub>R i j = Le (real_of_int d) \\<and>\n            M\\<^sub>R j i = Le (real_of_int (- d)) \\<or>\n            - int (k (THE c. c \\<in> X \\<and> v c = j)) \\<le> d - 1 \\<and>\n            d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i)) \\<and>\n            M\\<^sub>R i j = Lt (real_of_int d) \\<and>\n            M\\<^sub>R j i = Lt (real_of_int (- d + 1)))\n  v' b = c2\n  v' a = c1", "obtain d :: int where *:\n          \"- int (k c2) \\<le> d \\<and> d \\<le> int (k c1) \\<and> M\\<^sub>R a b = Le d \\<and> M\\<^sub>R b a = Le (- d)\n         \\<or> - int (k c2) \\<le> d - 1 \\<and> d \\<le> int (k c1) \\<and> M\\<^sub>R a b = Lt d \\<and> M\\<^sub>R b a = Lt (- d + 1)\""], ["proof (prove)\nusing this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  0 < a\n  0 < b\n  M\\<^sub>R a 0 \\<noteq> \\<infinity>\n  M\\<^sub>R b 0 \\<noteq> \\<infinity>\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        0 < i \\<and>\n        0 < j \\<and>\n        M\\<^sub>R i 0 \\<noteq> \\<infinity> \\<and>\n        M\\<^sub>R j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n        (\\<exists>d.\n            - int (k (THE c. c \\<in> X \\<and> v c = j)) \\<le> d \\<and>\n            d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i)) \\<and>\n            M\\<^sub>R i j = Le (real_of_int d) \\<and>\n            M\\<^sub>R j i = Le (real_of_int (- d)) \\<or>\n            - int (k (THE c. c \\<in> X \\<and> v c = j)) \\<le> d - 1 \\<and>\n            d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i)) \\<and>\n            M\\<^sub>R i j = Lt (real_of_int d) \\<and>\n            M\\<^sub>R j i = Lt (real_of_int (- d + 1)))\n  v' b = c2\n  v' a = c1\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        - int (k c2) \\<le> d \\<and>\n        d \\<le> int (k c1) \\<and>\n        M\\<^sub>R a b = Le (real_of_int d) \\<and>\n        M\\<^sub>R b a = Le (real_of_int (- d)) \\<or>\n        - int (k c2) \\<le> d - 1 \\<and>\n        d \\<le> int (k c1) \\<and>\n        M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n        M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding v'_def"], ["proof (prove)\nusing this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  0 < a\n  0 < b\n  M\\<^sub>R a 0 \\<noteq> \\<infinity>\n  M\\<^sub>R b 0 \\<noteq> \\<infinity>\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        0 < i \\<and>\n        0 < j \\<and>\n        M\\<^sub>R i 0 \\<noteq> \\<infinity> \\<and>\n        M\\<^sub>R j 0 \\<noteq> \\<infinity> \\<longrightarrow>\n        (\\<exists>d.\n            - int (k (THE c. c \\<in> X \\<and> v c = j)) \\<le> d \\<and>\n            d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i)) \\<and>\n            M\\<^sub>R i j = Le (real_of_int d) \\<and>\n            M\\<^sub>R j i = Le (real_of_int (- d)) \\<or>\n            - int (k (THE c. c \\<in> X \\<and> v c = j)) \\<le> d - 1 \\<and>\n            d \\<le> int (k (THE c. c \\<in> X \\<and> v c = i)) \\<and>\n            M\\<^sub>R i j = Lt (real_of_int d) \\<and>\n            M\\<^sub>R j i = Lt (real_of_int (- d + 1)))\n  (THE c. c \\<in> X \\<and> v c = b) = c2\n  (THE c. c \\<in> X \\<and> v c = a) = c1\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        - int (k c2) \\<le> d \\<and>\n        d \\<le> int (k c1) \\<and>\n        M\\<^sub>R a b = Le (real_of_int d) \\<and>\n        M\\<^sub>R b a = Le (real_of_int (- d)) \\<or>\n        - int (k c2) \\<le> d - 1 \\<and>\n        d \\<le> int (k c1) \\<and>\n        M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n        M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  - int (k c2) \\<le> d \\<and>\n  d \\<le> int (k c1) \\<and>\n  M\\<^sub>R a b = Le (real_of_int d) \\<and>\n  M\\<^sub>R b a = Le (real_of_int (- d)) \\<or>\n  - int (k c2) \\<le> d - 1 \\<and>\n  d \\<le> int (k c1) \\<and>\n  M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n  M\\<^sub>R b a = Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from *"], ["proof (chain)\npicking this:\n  - int (k c2) \\<le> d \\<and>\n  d \\<le> int (k c1) \\<and>\n  M\\<^sub>R a b = Le (real_of_int d) \\<and>\n  M\\<^sub>R b a = Le (real_of_int (- d)) \\<or>\n  - int (k c2) \\<le> d - 1 \\<and>\n  d \\<le> int (k c1) \\<and>\n  M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n  M\\<^sub>R b a = Lt (real_of_int (- d + 1))", "have ?thesis"], ["proof (prove)\nusing this:\n  - int (k c2) \\<le> d \\<and>\n  d \\<le> int (k c1) \\<and>\n  M\\<^sub>R a b = Le (real_of_int d) \\<and>\n  M\\<^sub>R b a = Le (real_of_int (- d)) \\<or>\n  - int (k c2) \\<le> d - 1 \\<and>\n  d \\<le> int (k c1) \\<and>\n  M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n  M\\<^sub>R b a = Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. - int (k c2) \\<le> d \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Le (real_of_int d) \\<and>\n    M\\<^sub>R b a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 1"], ["proof (state)\nthis:\n  - int (k c2) \\<le> d \\<and>\n  d \\<le> int (k c1) \\<and>\n  M\\<^sub>R a b = Le (real_of_int d) \\<and>\n  M\\<^sub>R b a = Le (real_of_int (- d))\n\ngoal (2 subgoals):\n 1. - int (k c2) \\<le> d \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Le (real_of_int d) \\<and>\n    M\\<^sub>R b a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with lt"], ["proof (chain)\npicking this:\n  M a b < M\\<^sub>R a b\n  - int (k c2) \\<le> d \\<and>\n  d \\<le> int (k c1) \\<and>\n  M\\<^sub>R a b = Le (real_of_int d) \\<and>\n  M\\<^sub>R b a = Le (real_of_int (- d))", "have \"M a b < Le d\""], ["proof (prove)\nusing this:\n  M a b < M\\<^sub>R a b\n  - int (k c2) \\<le> d \\<and>\n  d \\<le> int (k c1) \\<and>\n  M\\<^sub>R a b = Le (real_of_int d) \\<and>\n  M\\<^sub>R b a = Le (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. M a b < Le (real_of_int d)", "by auto"], ["proof (state)\nthis:\n  M a b < Le (real_of_int d)\n\ngoal (2 subgoals):\n 1. - int (k c2) \\<le> d \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Le (real_of_int d) \\<and>\n    M\\<^sub>R b a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  M a b < Le (real_of_int d)", "have \"M a b \\<le> Lt d\""], ["proof (prove)\nusing this:\n  M a b < Le (real_of_int d)\n\ngoal (1 subgoal):\n 1. M a b \\<le> Lt (real_of_int d)", "unfolding less less_eq dbm_le_def"], ["proof (prove)\nusing this:\n  M a b \\<prec> Le (real_of_int d)\n\ngoal (1 subgoal):\n 1. M a b \\<prec> Lt (real_of_int d) \\<or> M a b = Lt (real_of_int d)", "by (fastforce elim!: dbm_lt.cases)"], ["proof (state)\nthis:\n  M a b \\<le> Lt (real_of_int d)\n\ngoal (2 subgoals):\n 1. - int (k c2) \\<le> d \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Le (real_of_int d) \\<and>\n    M\\<^sub>R b a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from dbm_lt'[OF assms(2)[folded M(1)] this C2 C(1,2) not0]"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int d}", "have\n            \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 < d}\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int d}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub>\n    \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int d}", "."], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int d}\n\ngoal (2 subgoals):\n 1. - int (k c2) \\<le> d \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Le (real_of_int d) \\<and>\n    M\\<^sub>R b a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from beta_interp.\\<beta>_boundedness_diag_lt'[OF _ _ C(3,4) this] 1"], ["proof (chain)\npicking this:\n  \\<lbrakk>- int (k c2) \\<le> d; d \\<le> int (k c1)\\<rbrakk>\n  \\<Longrightarrow> Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n                    \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int d}\n  - int (k c2) \\<le> d \\<and>\n  d \\<le> int (k c1) \\<and>\n  M\\<^sub>R a b = Le (real_of_int d) \\<and>\n  M\\<^sub>R b a = Le (real_of_int (- d))", "have \"Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>) \\<subseteq> {u \\<in> V. u c1 - u c2 < d}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>- int (k c2) \\<le> d; d \\<le> int (k c1)\\<rbrakk>\n  \\<Longrightarrow> Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n                    \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int d}\n  - int (k c2) \\<le> d \\<and>\n  d \\<le> int (k c1) \\<and>\n  M\\<^sub>R a b = Le (real_of_int d) \\<and>\n  M\\<^sub>R b a = Le (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n    \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int d}", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int d}\n\ngoal (2 subgoals):\n 1. - int (k c2) \\<le> d \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Le (real_of_int d) \\<and>\n    M\\<^sub>R b a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int d}\n\ngoal (2 subgoals):\n 1. - int (k c2) \\<le> d \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Le (real_of_int d) \\<and>\n    M\\<^sub>R b a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int d}\n\ngoal (2 subgoals):\n 1. - int (k c2) \\<le> d \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Le (real_of_int d) \\<and>\n    M\\<^sub>R b a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix u"], ["proof (state)\ngoal (2 subgoals):\n 1. - int (k c2) \\<le> d \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Le (real_of_int d) \\<and>\n    M\\<^sub>R b a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume u: \"u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\""], ["proof (state)\nthis:\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (2 subgoals):\n 1. - int (k c2) \\<le> d \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Le (real_of_int d) \\<and>\n    M\\<^sub>R b a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C C2"], ["proof (chain)\npicking this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>", "have\n              \"dbm_entry_val u (Some c1) (Some c2) (M\\<^sub>R a b)\" \"dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)\""], ["proof (prove)\nusing this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) (Some c2) (M\\<^sub>R a b) &&&\n    dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  u \\<in> {u. Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n              (\\<forall>c.\n                  v c \\<le> n \\<longrightarrow>\n                  dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n                  dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n              (\\<forall>c1 c2.\n                  v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                  dbm_entry_val u (Some c1) (Some c2)\n                   (M\\<^sub>R (v c1) (v c2)))}\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) (Some c2) (M\\<^sub>R a b) &&&\n    dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c1) (Some c2) (M\\<^sub>R a b)\n  dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)\n\ngoal (2 subgoals):\n 1. - int (k c2) \\<le> d \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Le (real_of_int d) \\<and>\n    M\\<^sub>R b a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with 1"], ["proof (chain)\npicking this:\n  - int (k c2) \\<le> d \\<and>\n  d \\<le> int (k c1) \\<and>\n  M\\<^sub>R a b = Le (real_of_int d) \\<and>\n  M\\<^sub>R b a = Le (real_of_int (- d))\n  dbm_entry_val u (Some c1) (Some c2) (M\\<^sub>R a b)\n  dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)", "have \"u \\<notin> {u \\<in> V. u c1 - u c2 < d}\""], ["proof (prove)\nusing this:\n  - int (k c2) \\<le> d \\<and>\n  d \\<le> int (k c1) \\<and>\n  M\\<^sub>R a b = Le (real_of_int d) \\<and>\n  M\\<^sub>R b a = Le (real_of_int (- d))\n  dbm_entry_val u (Some c1) (Some c2) (M\\<^sub>R a b)\n  dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)\n\ngoal (1 subgoal):\n 1. u \\<notin> {u \\<in> V. u c1 - u c2 < real_of_int d}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> {u \\<in> V. u c1 - u c2 < real_of_int d}\n\ngoal (2 subgoals):\n 1. - int (k c2) \\<le> d \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Le (real_of_int d) \\<and>\n    M\\<^sub>R b a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 - u c2 < real_of_int d}\n\ngoal (2 subgoals):\n 1. - int (k c2) \\<le> d \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Le (real_of_int d) \\<and>\n    M\\<^sub>R b a = Le (real_of_int (- d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int d}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 - u c2 < real_of_int d}", "show ?thesis"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int d}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 - u c2 < real_of_int d}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "using M\\<^sub>R(1) M(1)"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int d}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 - u c2 < real_of_int d}\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  [M]\\<^bsub>v,n\\<^esub> = Z\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case 2"], ["proof (state)\nthis:\n  - int (k c2) \\<le> d - 1 \\<and>\n  d \\<le> int (k c1) \\<and>\n  M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n  M\\<^sub>R b a = Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with lt"], ["proof (chain)\npicking this:\n  M a b < M\\<^sub>R a b\n  - int (k c2) \\<le> d - 1 \\<and>\n  d \\<le> int (k c1) \\<and>\n  M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n  M\\<^sub>R b a = Lt (real_of_int (- d + 1))", "have \"M a b \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  M a b < M\\<^sub>R a b\n  - int (k c2) \\<le> d - 1 \\<and>\n  d \\<le> int (k c1) \\<and>\n  M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n  M\\<^sub>R b a = Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. M a b \\<noteq> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  M a b \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with dbm_entry_int[OF this] M(3) \\<open>a \\<le> n\\<close> \\<open>b \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  get_const (M a b) \\<in> \\<int> \\<Longrightarrow>\n  \\<exists>d. M a b = Le (real_of_int d) \\<or> M a b = Lt (real_of_int d)\n  dbm_int M n\n  a \\<le> n\n  b \\<le> n\n  M a b \\<noteq> \\<infinity>", "obtain d' :: int where d': \"M a b = Le d' \\<or> M a b = Lt d'\""], ["proof (prove)\nusing this:\n  get_const (M a b) \\<in> \\<int> \\<Longrightarrow>\n  \\<exists>d. M a b = Le (real_of_int d) \\<or> M a b = Lt (real_of_int d)\n  dbm_int M n\n  a \\<le> n\n  b \\<le> n\n  M a b \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>d'.\n        M a b = Le (real_of_int d') \\<or>\n        M a b = Lt (real_of_int d') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M a b = Le (real_of_int d') \\<or> M a b = Lt (real_of_int d')\n\ngoal (1 subgoal):\n 1. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  M a b = Le (real_of_int d') \\<or> M a b = Lt (real_of_int d')", "have \"M a b \\<le> Le (d - 1)\""], ["proof (prove)\nusing this:\n  M a b = Le (real_of_int d') \\<or> M a b = Lt (real_of_int d')\n\ngoal (1 subgoal):\n 1. M a b \\<le> Le (real_of_int (d - 1))", "using lt 2"], ["proof (prove)\nusing this:\n  M a b = Le (real_of_int d') \\<or> M a b = Lt (real_of_int d')\n  M a b < M\\<^sub>R a b\n  - int (k c2) \\<le> d - 1 \\<and>\n  d \\<le> int (k c1) \\<and>\n  M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n  M\\<^sub>R b a = Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. M a b \\<le> Le (real_of_int (d - 1))", "apply (auto simp: less_eq dbm_le_def less)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Le (real_of_int d') \\<prec> Lt (real_of_int d);\n     - int (k c2) < d; d \\<le> int (k c1);\n     M\\<^sub>R a b = Lt (real_of_int d);\n     M\\<^sub>R b a = Lt (1 - real_of_int d);\n     real_of_int d' \\<noteq> real_of_int d - 1;\n     M a b = Le (real_of_int d')\\<rbrakk>\n    \\<Longrightarrow> Le (real_of_int d') \\<prec> Le (real_of_int d - 1)\n 2. \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (real_of_int d);\n     - int (k c2) < d; d \\<le> int (k c1);\n     M\\<^sub>R a b = Lt (real_of_int d);\n     M\\<^sub>R b a = Lt (1 - real_of_int d);\n     M a b = Lt (real_of_int d')\\<rbrakk>\n    \\<Longrightarrow> Lt (real_of_int d') \\<prec> Le (real_of_int d - 1)", "apply (cases rule: dbm_lt.cases)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>Le (real_of_int d') \\<prec> Lt (real_of_int d);\n     - int (k c2) < d; d \\<le> int (k c1);\n     M\\<^sub>R a b = Lt (real_of_int d);\n     M\\<^sub>R b a = Lt (1 - real_of_int d);\n     real_of_int d' \\<noteq> real_of_int d - 1;\n     M a b = Le (real_of_int d')\\<rbrakk>\n    \\<Longrightarrow> ?a1.9 \\<prec> ?a2.9\n 2. \\<And>uu_.\n       \\<lbrakk>Le (real_of_int d') \\<prec> Lt (real_of_int d);\n        - int (k c2) < d; d \\<le> int (k c1);\n        M\\<^sub>R a b = Lt (real_of_int d);\n        M\\<^sub>R b a = Lt (1 - real_of_int d);\n        real_of_int d' \\<noteq> real_of_int d - 1;\n        M a b = Le (real_of_int d'); ?a1.9 = Lt uu_;\n        ?a2.9 = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> Le (real_of_int d') \\<prec> Le (real_of_int d - 1)\n 3. \\<And>uv_.\n       \\<lbrakk>Le (real_of_int d') \\<prec> Lt (real_of_int d);\n        - int (k c2) < d; d \\<le> int (k c1);\n        M\\<^sub>R a b = Lt (real_of_int d);\n        M\\<^sub>R b a = Lt (1 - real_of_int d);\n        real_of_int d' \\<noteq> real_of_int d - 1;\n        M a b = Le (real_of_int d'); ?a1.9 = Le uv_;\n        ?a2.9 = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> Le (real_of_int d') \\<prec> Le (real_of_int d - 1)\n 4. \\<And>aa ba.\n       \\<lbrakk>Le (real_of_int d') \\<prec> Lt (real_of_int d);\n        - int (k c2) < d; d \\<le> int (k c1);\n        M\\<^sub>R a b = Lt (real_of_int d);\n        M\\<^sub>R b a = Lt (1 - real_of_int d);\n        real_of_int d' \\<noteq> real_of_int d - 1;\n        M a b = Le (real_of_int d'); ?a1.9 = Le aa; ?a2.9 = Le ba;\n        aa < ba\\<rbrakk>\n       \\<Longrightarrow> Le (real_of_int d') \\<prec> Le (real_of_int d - 1)\n 5. \\<And>aa ba.\n       \\<lbrakk>Le (real_of_int d') \\<prec> Lt (real_of_int d);\n        - int (k c2) < d; d \\<le> int (k c1);\n        M\\<^sub>R a b = Lt (real_of_int d);\n        M\\<^sub>R b a = Lt (1 - real_of_int d);\n        real_of_int d' \\<noteq> real_of_int d - 1;\n        M a b = Le (real_of_int d'); ?a1.9 = Le aa; ?a2.9 = Lt ba;\n        aa < ba\\<rbrakk>\n       \\<Longrightarrow> Le (real_of_int d') \\<prec> Le (real_of_int d - 1)\n 6. \\<And>aa ba.\n       \\<lbrakk>Le (real_of_int d') \\<prec> Lt (real_of_int d);\n        - int (k c2) < d; d \\<le> int (k c1);\n        M\\<^sub>R a b = Lt (real_of_int d);\n        M\\<^sub>R b a = Lt (1 - real_of_int d);\n        real_of_int d' \\<noteq> real_of_int d - 1;\n        M a b = Le (real_of_int d'); ?a1.9 = Lt aa; ?a2.9 = Le ba;\n        aa \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> Le (real_of_int d') \\<prec> Le (real_of_int d - 1)\n 7. \\<And>aa ba.\n       \\<lbrakk>Le (real_of_int d') \\<prec> Lt (real_of_int d);\n        - int (k c2) < d; d \\<le> int (k c1);\n        M\\<^sub>R a b = Lt (real_of_int d);\n        M\\<^sub>R b a = Lt (1 - real_of_int d);\n        real_of_int d' \\<noteq> real_of_int d - 1;\n        M a b = Le (real_of_int d'); ?a1.9 = Lt aa; ?a2.9 = Lt ba;\n        aa < ba\\<rbrakk>\n       \\<Longrightarrow> Le (real_of_int d') \\<prec> Le (real_of_int d - 1)\n 8. \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (real_of_int d);\n     - int (k c2) < d; d \\<le> int (k c1);\n     M\\<^sub>R a b = Lt (real_of_int d);\n     M\\<^sub>R b a = Lt (1 - real_of_int d);\n     M a b = Lt (real_of_int d')\\<rbrakk>\n    \\<Longrightarrow> Lt (real_of_int d') \\<prec> Le (real_of_int d - 1)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (real_of_int d);\n     - int (k c2) < d; d \\<le> int (k c1);\n     M\\<^sub>R a b = Lt (real_of_int d);\n     M\\<^sub>R b a = Lt (1 - real_of_int d);\n     M a b = Lt (real_of_int d')\\<rbrakk>\n    \\<Longrightarrow> Lt (real_of_int d') \\<prec> Le (real_of_int d - 1)", "apply (rule dbm_lt.intros)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (real_of_int d);\n     - int (k c2) < d; d \\<le> int (k c1);\n     M\\<^sub>R a b = Lt (real_of_int d);\n     M\\<^sub>R b a = Lt (1 - real_of_int d);\n     M a b = Lt (real_of_int d')\\<rbrakk>\n    \\<Longrightarrow> real_of_int d' \\<le> real_of_int d - 1", "apply (cases rule: dbm_lt.cases)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (real_of_int d);\n     - int (k c2) < d; d \\<le> int (k c1);\n     M\\<^sub>R a b = Lt (real_of_int d);\n     M\\<^sub>R b a = Lt (1 - real_of_int d);\n     M a b = Lt (real_of_int d')\\<rbrakk>\n    \\<Longrightarrow> ?a1.24 \\<prec> ?a2.24\n 2. \\<And>uu_.\n       \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (real_of_int d);\n        - int (k c2) < d; d \\<le> int (k c1);\n        M\\<^sub>R a b = Lt (real_of_int d);\n        M\\<^sub>R b a = Lt (1 - real_of_int d); M a b = Lt (real_of_int d');\n        ?a1.24 = Lt uu_; ?a2.24 = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> real_of_int d' \\<le> real_of_int d - 1\n 3. \\<And>uv_.\n       \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (real_of_int d);\n        - int (k c2) < d; d \\<le> int (k c1);\n        M\\<^sub>R a b = Lt (real_of_int d);\n        M\\<^sub>R b a = Lt (1 - real_of_int d); M a b = Lt (real_of_int d');\n        ?a1.24 = Le uv_; ?a2.24 = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> real_of_int d' \\<le> real_of_int d - 1\n 4. \\<And>aa ba.\n       \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (real_of_int d);\n        - int (k c2) < d; d \\<le> int (k c1);\n        M\\<^sub>R a b = Lt (real_of_int d);\n        M\\<^sub>R b a = Lt (1 - real_of_int d); M a b = Lt (real_of_int d');\n        ?a1.24 = Le aa; ?a2.24 = Le ba; aa < ba\\<rbrakk>\n       \\<Longrightarrow> real_of_int d' \\<le> real_of_int d - 1\n 5. \\<And>aa ba.\n       \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (real_of_int d);\n        - int (k c2) < d; d \\<le> int (k c1);\n        M\\<^sub>R a b = Lt (real_of_int d);\n        M\\<^sub>R b a = Lt (1 - real_of_int d); M a b = Lt (real_of_int d');\n        ?a1.24 = Le aa; ?a2.24 = Lt ba; aa < ba\\<rbrakk>\n       \\<Longrightarrow> real_of_int d' \\<le> real_of_int d - 1\n 6. \\<And>aa ba.\n       \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (real_of_int d);\n        - int (k c2) < d; d \\<le> int (k c1);\n        M\\<^sub>R a b = Lt (real_of_int d);\n        M\\<^sub>R b a = Lt (1 - real_of_int d); M a b = Lt (real_of_int d');\n        ?a1.24 = Lt aa; ?a2.24 = Le ba; aa \\<le> ba\\<rbrakk>\n       \\<Longrightarrow> real_of_int d' \\<le> real_of_int d - 1\n 7. \\<And>aa ba.\n       \\<lbrakk>Lt (real_of_int d') \\<prec> Lt (real_of_int d);\n        - int (k c2) < d; d \\<le> int (k c1);\n        M\\<^sub>R a b = Lt (real_of_int d);\n        M\\<^sub>R b a = Lt (1 - real_of_int d); M a b = Lt (real_of_int d');\n        ?a1.24 = Lt aa; ?a2.24 = Lt ba; aa < ba\\<rbrakk>\n       \\<Longrightarrow> real_of_int d' \\<le> real_of_int d - 1", "by auto"], ["proof (state)\nthis:\n  M a b \\<le> Le (real_of_int (d - 1))\n\ngoal (1 subgoal):\n 1. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with lt"], ["proof (chain)\npicking this:\n  M a b < M\\<^sub>R a b\n  M a b \\<le> Le (real_of_int (d - 1))", "have \"M a b \\<le> Le (d - 1)\""], ["proof (prove)\nusing this:\n  M a b < M\\<^sub>R a b\n  M a b \\<le> Le (real_of_int (d - 1))\n\ngoal (1 subgoal):\n 1. M a b \\<le> Le (real_of_int (d - 1))", "by auto"], ["proof (state)\nthis:\n  M a b \\<le> Le (real_of_int (d - 1))\n\ngoal (1 subgoal):\n 1. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from dbm_le'[OF assms(2)[folded M(1)] this C2 C(1,2) not0]"], ["proof (chain)\npicking this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (d - 1)}", "have\n            \"[M]\\<^bsub>v,n\\<^esub> \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> d - 1}\""], ["proof (prove)\nusing this:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (d - 1)}\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub>\n    \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (d - 1)}", "."], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub>\n  \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (d - 1)}\n\ngoal (1 subgoal):\n 1. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from beta_interp.\\<beta>_boundedness_diag_le'[OF _ _ C(3,4) this] 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>- int (k c2) \\<le> d - 1; d - 1 \\<le> int (k c1)\\<rbrakk>\n  \\<Longrightarrow> Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n                    \\<subseteq> {u \\<in> V.\n                                 u c1 - u c2 \\<le> real_of_int (d - 1)}\n  - int (k c2) \\<le> d - 1 \\<and>\n  d \\<le> int (k c1) \\<and>\n  M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n  M\\<^sub>R b a = Lt (real_of_int (- d + 1))", "have \"Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>) \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> d - 1}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>- int (k c2) \\<le> d - 1; d - 1 \\<le> int (k c1)\\<rbrakk>\n  \\<Longrightarrow> Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n                    \\<subseteq> {u \\<in> V.\n                                 u c1 - u c2 \\<le> real_of_int (d - 1)}\n  - int (k c2) \\<le> d - 1 \\<and>\n  d \\<le> int (k c1) \\<and>\n  M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n  M\\<^sub>R b a = Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n    \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (d - 1)}", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (d - 1)}\n\ngoal (1 subgoal):\n 1. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (d - 1)}\n\ngoal (1 subgoal):\n 1. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (d - 1)}\n\ngoal (1 subgoal):\n 1. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume u: \"u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\""], ["proof (state)\nthis:\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C C2"], ["proof (chain)\npicking this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>", "have\n              \"dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)\""], ["proof (prove)\nusing this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  u \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  v c1 = a\n  v c2 = b\n  c1 \\<in> X\n  c2 \\<in> X\n  a \\<le> n\n  b \\<le> n\n  u \\<in> {u. Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n              (\\<forall>c.\n                  v c \\<le> n \\<longrightarrow>\n                  dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n                  dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n              (\\<forall>c1 c2.\n                  v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n                  dbm_entry_val u (Some c1) (Some c2)\n                   (M\\<^sub>R (v c1) (v c2)))}\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)\n\ngoal (1 subgoal):\n 1. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with 2"], ["proof (chain)\npicking this:\n  - int (k c2) \\<le> d - 1 \\<and>\n  d \\<le> int (k c1) \\<and>\n  M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n  M\\<^sub>R b a = Lt (real_of_int (- d + 1))\n  dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)", "have \"u \\<notin> {u \\<in> V. u c1 - u c2 \\<le> d - 1}\""], ["proof (prove)\nusing this:\n  - int (k c2) \\<le> d - 1 \\<and>\n  d \\<le> int (k c1) \\<and>\n  M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n  M\\<^sub>R b a = Lt (real_of_int (- d + 1))\n  dbm_entry_val u (Some c2) (Some c1) (M\\<^sub>R b a)\n\ngoal (1 subgoal):\n 1. u \\<notin> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (d - 1)}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (d - 1)}\n\ngoal (1 subgoal):\n 1. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (d - 1)}\n\ngoal (1 subgoal):\n 1. - int (k c2) \\<le> d - 1 \\<and>\n    d \\<le> int (k c1) \\<and>\n    M\\<^sub>R a b = Lt (real_of_int d) \\<and>\n    M\\<^sub>R b a = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (d - 1)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (d - 1)}", "show ?thesis"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (d - 1)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (d - 1)}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "using M\\<^sub>R(1) M(1)"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> ([M]\\<^bsub>v,n\\<^esub>)\n  \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (d - 1)}\n  ?u3 \\<in> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u3 \\<notin> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (d - 1)}\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  [M]\\<^bsub>v,n\\<^esub> = Z\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?a3; 0 < ?b3;\n   M\\<^sub>R ?a3 0 \\<noteq> \\<infinity>;\n   M\\<^sub>R ?b3 0 \\<noteq> \\<infinity>;\n   M ?a3 ?b3 < M\\<^sub>R ?a3 ?b3\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "note bounded = this"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?a3; 0 < ?b3;\n   M\\<^sub>R ?a3 0 \\<noteq> \\<infinity>;\n   M\\<^sub>R ?b3 0 \\<noteq> \\<infinity>;\n   M ?a3 ?b3 < M\\<^sub>R ?a3 ?b3\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?a3; 0 < ?b3;\n   M\\<^sub>R ?a3 0 \\<noteq> \\<infinity>;\n   M\\<^sub>R ?b3 0 \\<noteq> \\<infinity>;\n   M ?a3 ?b3 < M\\<^sub>R ?a3 ?b3\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume not_bounded: \"\\<forall> (a,b) \\<in> set (arcs i i ys). M a b < M\\<^sub>R a b \\<longrightarrow> M\\<^sub>R a 0 = \\<infinity> \\<or> M\\<^sub>R b 0 = \\<infinity>\""], ["proof (state)\nthis:\n  \\<forall>(a, b)\\<in>set (arcs i i ys).\n     M a b < M\\<^sub>R a b \\<longrightarrow>\n     M\\<^sub>R a 0 = \\<infinity> \\<or> M\\<^sub>R b 0 = \\<infinity>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "have \"\\<exists> y z zs. set zs \\<union> {0, y, z} = set (i # ys) \\<and> len ?M 0 0 (y # z # zs) < Le 0 \\<and> \n                    (\\<forall> (a,b) \\<in> set (arcs 0 0 (y # z # zs)). M a b < M\\<^sub>R a b \\<longrightarrow> a = y \\<and> b = z)\n                    \\<and> M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (cases ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case Nil"], ["proof (state)\nthis:\n  ys = []\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow>\n    \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (cases \"M i i < M\\<^sub>R i i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. M i i < M\\<^sub>R i i \\<Longrightarrow>\n    \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. \\<not> M i i < M\\<^sub>R i i \\<Longrightarrow>\n    \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case True"], ["proof (state)\nthis:\n  M i i < M\\<^sub>R i i\n\ngoal (2 subgoals):\n 1. M i i < M\\<^sub>R i i \\<Longrightarrow>\n    \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. \\<not> M i i < M\\<^sub>R i i \\<Longrightarrow>\n    \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  M i i < M\\<^sub>R i i", "have \"?M i i = M i i\""], ["proof (prove)\nusing this:\n  M i i < M\\<^sub>R i i\n\ngoal (1 subgoal):\n 1. min (M i i) (M\\<^sub>R i i) = M i i", "by (simp add: min.strict_order_iff)"], ["proof (state)\nthis:\n  min (M i i) (M\\<^sub>R i i) = M i i\n\ngoal (2 subgoals):\n 1. M i i < M\\<^sub>R i i \\<Longrightarrow>\n    \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. \\<not> M i i < M\\<^sub>R i i \\<Longrightarrow>\n    \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with Nil ys(1) xs(3)"], ["proof (chain)\npicking this:\n  ys = []\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < \\<one>\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i__ i__ xs < \\<one>\n  min (M i i) (M\\<^sub>R i i) = M i i", "have *: \"M i i < \\<one>\""], ["proof (prove)\nusing this:\n  ys = []\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < \\<one>\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i__ i__ xs < \\<one>\n  min (M i i) (M\\<^sub>R i i) = M i i\n\ngoal (1 subgoal):\n 1. M i i < \\<one>", "by simp"], ["proof (state)\nthis:\n  M i i < \\<one>\n\ngoal (2 subgoals):\n 1. M i i < M\\<^sub>R i i \\<Longrightarrow>\n    \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. \\<not> M i i < M\\<^sub>R i i \\<Longrightarrow>\n    \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with neg_cycle_empty[OF cn_weak _ \\<open>i \\<le> n\\<close>, of \"[]\" M]"], ["proof (chain)\npicking this:\n  \\<lbrakk>set [] \\<subseteq> {0..n}; len M i i [] < \\<one>\\<rbrakk>\n  \\<Longrightarrow> [M]\\<^bsub>v,n\\<^esub> = {}\n  M i i < \\<one>", "have \"[M]\\<^bsub>v,n\\<^esub> = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>set [] \\<subseteq> {0..n}; len M i i [] < \\<one>\\<rbrakk>\n  \\<Longrightarrow> [M]\\<^bsub>v,n\\<^esub> = {}\n  M i i < \\<one>\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> = {}", "by auto"], ["proof (state)\nthis:\n  [M]\\<^bsub>v,n\\<^esub> = {}\n\ngoal (2 subgoals):\n 1. M i i < M\\<^sub>R i i \\<Longrightarrow>\n    \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. \\<not> M i i < M\\<^sub>R i i \\<Longrightarrow>\n    \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with \\<open>Z \\<noteq> {}\\<close> M(1)"], ["proof (chain)\npicking this:\n  Z \\<noteq> {}\n  [M]\\<^bsub>v,n\\<^esub> = Z\n  [M]\\<^bsub>v,n\\<^esub> = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  Z \\<noteq> {}\n  [M]\\<^bsub>v,n\\<^esub> = Z\n  [M]\\<^bsub>v,n\\<^esub> = {}\n\ngoal (1 subgoal):\n 1. \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  \\<exists>y z zs.\n     set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n     len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n     < Le 0 \\<and>\n     (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n         M a b < M\\<^sub>R a b \\<longrightarrow> a = y \\<and> b = z) \\<and>\n     M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n     R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. \\<not> M i i < M\\<^sub>R i i \\<Longrightarrow>\n    \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> M i i < M\\<^sub>R i i \\<Longrightarrow>\n    \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case False"], ["proof (state)\nthis:\n  \\<not> M i i < M\\<^sub>R i i\n\ngoal (1 subgoal):\n 1. \\<not> M i i < M\\<^sub>R i i \\<Longrightarrow>\n    \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  \\<not> M i i < M\\<^sub>R i i", "have \"?M i i = M\\<^sub>R i i\""], ["proof (prove)\nusing this:\n  \\<not> M i i < M\\<^sub>R i i\n\ngoal (1 subgoal):\n 1. min (M i i) (M\\<^sub>R i i) = M\\<^sub>R i i", "by (simp add: min_absorb2)"], ["proof (state)\nthis:\n  min (M i i) (M\\<^sub>R i i) = M\\<^sub>R i i\n\ngoal (1 subgoal):\n 1. \\<not> M i i < M\\<^sub>R i i \\<Longrightarrow>\n    \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with Nil ys(1) xs(3)"], ["proof (chain)\npicking this:\n  ys = []\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < \\<one>\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i__ i__ xs < \\<one>\n  min (M i i) (M\\<^sub>R i i) = M\\<^sub>R i i", "have \"M\\<^sub>R i i < \\<one>\""], ["proof (prove)\nusing this:\n  ys = []\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < \\<one>\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i__ i__ xs < \\<one>\n  min (M i i) (M\\<^sub>R i i) = M\\<^sub>R i i\n\ngoal (1 subgoal):\n 1. M\\<^sub>R i i < \\<one>", "by simp"], ["proof (state)\nthis:\n  M\\<^sub>R i i < \\<one>\n\ngoal (1 subgoal):\n 1. \\<not> M i i < M\\<^sub>R i i \\<Longrightarrow>\n    \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with neg_cycle_empty[OF cn_weak _ \\<open>i \\<le> n\\<close>, of \"[]\" M\\<^sub>R]"], ["proof (chain)\npicking this:\n  \\<lbrakk>set [] \\<subseteq> {0..n}; len M\\<^sub>R i i [] < \\<one>\\<rbrakk>\n  \\<Longrightarrow> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = {}\n  M\\<^sub>R i i < \\<one>", "have \"[M\\<^sub>R]\\<^bsub>v,n\\<^esub> = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>set [] \\<subseteq> {0..n}; len M\\<^sub>R i i [] < \\<one>\\<rbrakk>\n  \\<Longrightarrow> [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = {}\n  M\\<^sub>R i i < \\<one>\n\ngoal (1 subgoal):\n 1. [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = {}", "by auto"], ["proof (state)\nthis:\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = {}\n\ngoal (1 subgoal):\n 1. \\<not> M i i < M\\<^sub>R i i \\<Longrightarrow>\n    \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with \\<open>R \\<noteq> {}\\<close> M\\<^sub>R(1)"], ["proof (chain)\npicking this:\n  R \\<noteq> {}\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  R \\<noteq> {}\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = {}\n\ngoal (1 subgoal):\n 1. \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  \\<exists>y z zs.\n     set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n     len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n     < Le 0 \\<and>\n     (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n         M a b < M\\<^sub>R a b \\<longrightarrow> a = y \\<and> b = z) \\<and>\n     M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n     R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>y z zs.\n     set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n     len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n     < Le 0 \\<and>\n     (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n         M a b < M\\<^sub>R a b \\<longrightarrow> a = y \\<and> b = z) \\<and>\n     M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n     R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case (Cons w ws)"], ["proof (state)\nthis:\n  ys = w # ws\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "note ws = this"], ["proof (state)\nthis:\n  ys = w # ws\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ys = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (cases ws)"], ["proof (state)\ngoal (2 subgoals):\n 1. ws = [] \\<Longrightarrow>\n    \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case Nil"], ["proof (state)\nthis:\n  ws = []\n\ngoal (2 subgoals):\n 1. ws = [] \\<Longrightarrow>\n    \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with ws ys xs(3)"], ["proof (chain)\npicking this:\n  ys = w # ws\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < \\<one>\n  set ys \\<subseteq> {0..n}\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs i i ys)\n  i \\<le> n\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i__ i__ xs < \\<one>\n  ws = []", "have *:\n              \"?M i w + ?M w i < \\<one>\" \"?M w i = M w i \\<longrightarrow> ?M i w \\<noteq> M i w\" \"(i, w) \\<in> set (arcs i i ys)\""], ["proof (prove)\nusing this:\n  ys = w # ws\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < \\<one>\n  set ys \\<subseteq> {0..n}\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs i i ys)\n  i \\<le> n\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i__ i__ xs < \\<one>\n  ws = []\n\ngoal (1 subgoal):\n 1. min (M i w) (M\\<^sub>R i w) + min (M w i) (M\\<^sub>R w i) < \\<one> &&&\n    min (M w i) (M\\<^sub>R w i) = M w i \\<longrightarrow>\n    min (M i w) (M\\<^sub>R i w) \\<noteq> M i w &&&\n    (i, w) \\<in> set (arcs i i ys)", "by auto"], ["proof (state)\nthis:\n  min (M i w) (M\\<^sub>R i w) + min (M w i) (M\\<^sub>R w i) < \\<one>\n  min (M w i) (M\\<^sub>R w i) = M w i \\<longrightarrow>\n  min (M i w) (M\\<^sub>R i w) \\<noteq> M i w\n  (i, w) \\<in> set (arcs i i ys)\n\ngoal (2 subgoals):\n 1. ws = [] \\<Longrightarrow>\n    \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "have \"R \\<inter> Approx\\<^sub>\\<beta> Z = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (cases \"?M w i = M w i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. min (M w i) (M\\<^sub>R w i) = M w i \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. min (M w i) (M\\<^sub>R w i) \\<noteq> M w i \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case True"], ["proof (state)\nthis:\n  min (M w i) (M\\<^sub>R w i) = M w i\n\ngoal (2 subgoals):\n 1. min (M w i) (M\\<^sub>R w i) = M w i \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. min (M w i) (M\\<^sub>R w i) \\<noteq> M w i \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with *(2)"], ["proof (chain)\npicking this:\n  min (M w i) (M\\<^sub>R w i) = M w i \\<longrightarrow>\n  min (M i w) (M\\<^sub>R i w) \\<noteq> M i w\n  min (M w i) (M\\<^sub>R w i) = M w i", "have \"?M i w = M\\<^sub>R i w\""], ["proof (prove)\nusing this:\n  min (M w i) (M\\<^sub>R w i) = M w i \\<longrightarrow>\n  min (M i w) (M\\<^sub>R i w) \\<noteq> M i w\n  min (M w i) (M\\<^sub>R w i) = M w i\n\ngoal (1 subgoal):\n 1. min (M i w) (M\\<^sub>R i w) = M\\<^sub>R i w", "unfolding min_def"], ["proof (prove)\nusing this:\n  (if M w i \\<le> M\\<^sub>R w i then M w i else M\\<^sub>R w i) =\n  M w i \\<longrightarrow>\n  (if M i w \\<le> M\\<^sub>R i w then M i w else M\\<^sub>R i w) \\<noteq>\n  M i w\n  (if M w i \\<le> M\\<^sub>R w i then M w i else M\\<^sub>R w i) = M w i\n\ngoal (1 subgoal):\n 1. (if M i w \\<le> M\\<^sub>R i w then M i w else M\\<^sub>R i w) =\n    M\\<^sub>R i w", "by auto"], ["proof (state)\nthis:\n  min (M i w) (M\\<^sub>R i w) = M\\<^sub>R i w\n\ngoal (2 subgoals):\n 1. min (M w i) (M\\<^sub>R w i) = M w i \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. min (M w i) (M\\<^sub>R w i) \\<noteq> M w i \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with *(1) True"], ["proof (chain)\npicking this:\n  min (M i w) (M\\<^sub>R i w) + min (M w i) (M\\<^sub>R w i) < \\<one>\n  min (M w i) (M\\<^sub>R w i) = M w i\n  min (M i w) (M\\<^sub>R i w) = M\\<^sub>R i w", "have neg: \"M\\<^sub>R i w + M w i < \\<one>\""], ["proof (prove)\nusing this:\n  min (M i w) (M\\<^sub>R i w) + min (M w i) (M\\<^sub>R w i) < \\<one>\n  min (M w i) (M\\<^sub>R w i) = M w i\n  min (M i w) (M\\<^sub>R i w) = M\\<^sub>R i w\n\ngoal (1 subgoal):\n 1. M\\<^sub>R i w + M w i < \\<one>", "by auto"], ["proof (state)\nthis:\n  M\\<^sub>R i w + M w i < \\<one>\n\ngoal (2 subgoals):\n 1. min (M w i) (M\\<^sub>R w i) = M w i \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. min (M w i) (M\\<^sub>R w i) \\<noteq> M w i \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (cases \"i = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. i \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case True"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. i \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (cases \"w = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. w = 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. w \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case True"], ["proof (state)\nthis:\n  w = 0\n\ngoal (2 subgoals):\n 1. w = 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. w \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with 0 \\<open>i = 0\\<close> *(3)"], ["proof (chain)\npicking this:\n  (0, 0) \\<notin> set (arcs i i ys)\n  i = 0\n  (i, w) \\<in> set (arcs i i ys)\n  w = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (0, 0) \\<notin> set (arcs i i ys)\n  i = 0\n  (i, w) \\<in> set (arcs i i ys)\n  w = 0\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case False"], ["proof (state)\nthis:\n  w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with \\<open>i = 0\\<close> neg_sum_2'' *(3) neg"], ["proof (chain)\npicking this:\n  i = 0\n  \\<lbrakk>(0, ?b3) \\<in> set (arcs i i ys); 0 < ?b3;\n   M\\<^sub>R 0 ?b3 + M ?b3 0 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  (i, w) \\<in> set (arcs i i ys)\n  M\\<^sub>R i w + M w i < \\<one>\n  w \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n  \\<lbrakk>(0, ?b3) \\<in> set (arcs i i ys); 0 < ?b3;\n   M\\<^sub>R 0 ?b3 + M ?b3 0 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  (i, w) \\<in> set (arcs i i ys)\n  M\\<^sub>R i w + M w i < \\<one>\n  w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by blast"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (cases \"w = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. w = 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. w \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case True"], ["proof (state)\nthis:\n  w = 0\n\ngoal (2 subgoals):\n 1. w = 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. w \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with \\<open>i \\<noteq> 0\\<close> neg_sum_2' *(3) neg"], ["proof (chain)\npicking this:\n  i \\<noteq> 0\n  \\<lbrakk>(?a3, 0) \\<in> set (arcs i i ys); 0 < ?a3;\n   M\\<^sub>R ?a3 0 + M 0 ?a3 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  (i, w) \\<in> set (arcs i i ys)\n  M\\<^sub>R i w + M w i < \\<one>\n  w = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  \\<lbrakk>(?a3, 0) \\<in> set (arcs i i ys); 0 < ?a3;\n   M\\<^sub>R ?a3 0 + M 0 ?a3 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  (i, w) \\<in> set (arcs i i ys)\n  M\\<^sub>R i w + M w i < \\<one>\n  w = 0\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by blast"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case False"], ["proof (state)\nthis:\n  w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with \\<open>i \\<noteq> 0\\<close> neg_sum_2 *(3) neg"], ["proof (chain)\npicking this:\n  i \\<noteq> 0\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?b3; 0 < ?a3;\n   M\\<^sub>R ?a3 ?b3 + M ?b3 ?a3 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  (i, w) \\<in> set (arcs i i ys)\n  M\\<^sub>R i w + M w i < \\<one>\n  w \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?b3; 0 < ?a3;\n   M\\<^sub>R ?a3 ?b3 + M ?b3 ?a3 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  (i, w) \\<in> set (arcs i i ys)\n  M\\<^sub>R i w + M w i < \\<one>\n  w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by blast"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. min (M w i) (M\\<^sub>R w i) \\<noteq> M w i \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. min (M w i) (M\\<^sub>R w i) \\<noteq> M w i \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case False"], ["proof (state)\nthis:\n  min (M w i) (M\\<^sub>R w i) \\<noteq> M w i\n\ngoal (1 subgoal):\n 1. min (M w i) (M\\<^sub>R w i) \\<noteq> M w i \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "have \"M\\<^sub>R w i < M w i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M\\<^sub>R w i < M w i", "proof (rule ccontr, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> M\\<^sub>R w i < M w i \\<Longrightarrow> False", "case 1"], ["proof (state)\nthis:\n  \\<not> M\\<^sub>R w i < M w i\n\ngoal (1 subgoal):\n 1. \\<not> M\\<^sub>R w i < M w i \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> M\\<^sub>R w i < M w i", "have \"M\\<^sub>R w i \\<ge> M w i\""], ["proof (prove)\nusing this:\n  \\<not> M\\<^sub>R w i < M w i\n\ngoal (1 subgoal):\n 1. M w i \\<le> M\\<^sub>R w i", "by auto"], ["proof (state)\nthis:\n  M w i \\<le> M\\<^sub>R w i\n\ngoal (1 subgoal):\n 1. \\<not> M\\<^sub>R w i < M w i \\<Longrightarrow> False", "with False"], ["proof (chain)\npicking this:\n  min (M w i) (M\\<^sub>R w i) \\<noteq> M w i\n  M w i \\<le> M\\<^sub>R w i", "show False"], ["proof (prove)\nusing this:\n  min (M w i) (M\\<^sub>R w i) \\<noteq> M w i\n  M w i \\<le> M\\<^sub>R w i\n\ngoal (1 subgoal):\n 1. False", "unfolding min_def"], ["proof (prove)\nusing this:\n  (if M w i \\<le> M\\<^sub>R w i then M w i else M\\<^sub>R w i) \\<noteq>\n  M w i\n  M w i \\<le> M\\<^sub>R w i\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M\\<^sub>R w i < M w i\n\ngoal (1 subgoal):\n 1. min (M w i) (M\\<^sub>R w i) \\<noteq> M w i \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with one_M ws Nil"], ["proof (chain)\npicking this:\n  \\<exists>(a, b)\\<in>set (arcs i i ys). M a b < M\\<^sub>R a b\n  ys = w # ws\n  ws = []\n  M\\<^sub>R w i < M w i", "have \"M i w < M\\<^sub>R i w\""], ["proof (prove)\nusing this:\n  \\<exists>(a, b)\\<in>set (arcs i i ys). M a b < M\\<^sub>R a b\n  ys = w # ws\n  ws = []\n  M\\<^sub>R w i < M w i\n\ngoal (1 subgoal):\n 1. M i w < M\\<^sub>R i w", "by auto"], ["proof (state)\nthis:\n  M i w < M\\<^sub>R i w\n\ngoal (1 subgoal):\n 1. min (M w i) (M\\<^sub>R w i) \\<noteq> M w i \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  M i w < M\\<^sub>R i w", "have \"?M i w = M i w\""], ["proof (prove)\nusing this:\n  M i w < M\\<^sub>R i w\n\ngoal (1 subgoal):\n 1. min (M i w) (M\\<^sub>R i w) = M i w", "unfolding min_def"], ["proof (prove)\nusing this:\n  M i w < M\\<^sub>R i w\n\ngoal (1 subgoal):\n 1. (if M i w \\<le> M\\<^sub>R i w then M i w else M\\<^sub>R i w) = M i w", "by auto"], ["proof (state)\nthis:\n  min (M i w) (M\\<^sub>R i w) = M i w\n\ngoal (1 subgoal):\n 1. min (M w i) (M\\<^sub>R w i) \\<noteq> M w i \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  min (M i w) (M\\<^sub>R i w) = M i w\n\ngoal (1 subgoal):\n 1. min (M w i) (M\\<^sub>R w i) \\<noteq> M w i \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from False *(2)"], ["proof (chain)\npicking this:\n  min (M w i) (M\\<^sub>R w i) \\<noteq> M w i\n  min (M w i) (M\\<^sub>R w i) = M w i \\<longrightarrow>\n  min (M i w) (M\\<^sub>R i w) \\<noteq> M i w", "have \"?M w i = M\\<^sub>R w i\""], ["proof (prove)\nusing this:\n  min (M w i) (M\\<^sub>R w i) \\<noteq> M w i\n  min (M w i) (M\\<^sub>R w i) = M w i \\<longrightarrow>\n  min (M i w) (M\\<^sub>R i w) \\<noteq> M i w\n\ngoal (1 subgoal):\n 1. min (M w i) (M\\<^sub>R w i) = M\\<^sub>R w i", "unfolding min_def"], ["proof (prove)\nusing this:\n  (if M w i \\<le> M\\<^sub>R w i then M w i else M\\<^sub>R w i) \\<noteq>\n  M w i\n  (if M w i \\<le> M\\<^sub>R w i then M w i else M\\<^sub>R w i) =\n  M w i \\<longrightarrow>\n  (if M i w \\<le> M\\<^sub>R i w then M i w else M\\<^sub>R i w) \\<noteq>\n  M i w\n\ngoal (1 subgoal):\n 1. (if M w i \\<le> M\\<^sub>R w i then M w i else M\\<^sub>R w i) =\n    M\\<^sub>R w i", "by auto"], ["proof (state)\nthis:\n  min (M w i) (M\\<^sub>R w i) = M\\<^sub>R w i\n\ngoal (1 subgoal):\n 1. min (M w i) (M\\<^sub>R w i) \\<noteq> M w i \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  min (M i w) (M\\<^sub>R i w) = M i w\n  min (M w i) (M\\<^sub>R w i) = M\\<^sub>R w i", "have neg: \"M i w + M\\<^sub>R w i < \\<one>\""], ["proof (prove)\nusing this:\n  min (M i w) (M\\<^sub>R i w) = M i w\n  min (M w i) (M\\<^sub>R w i) = M\\<^sub>R w i\n\ngoal (1 subgoal):\n 1. M i w + M\\<^sub>R w i < \\<one>", "using *(1)"], ["proof (prove)\nusing this:\n  min (M i w) (M\\<^sub>R i w) = M i w\n  min (M w i) (M\\<^sub>R w i) = M\\<^sub>R w i\n  min (M i w) (M\\<^sub>R i w) + min (M w i) (M\\<^sub>R w i) < \\<one>\n\ngoal (1 subgoal):\n 1. M i w + M\\<^sub>R w i < \\<one>", "by auto"], ["proof (state)\nthis:\n  M i w + M\\<^sub>R w i < \\<one>\n\ngoal (1 subgoal):\n 1. min (M w i) (M\\<^sub>R w i) \\<noteq> M w i \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (cases \"i = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. i \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case True"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. i \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (cases \"w = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. w = 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. w \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case True"], ["proof (state)\nthis:\n  w = 0\n\ngoal (2 subgoals):\n 1. w = 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. w \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with 0 \\<open>i = 0\\<close> *(3)"], ["proof (chain)\npicking this:\n  (0, 0) \\<notin> set (arcs i i ys)\n  i = 0\n  (i, w) \\<in> set (arcs i i ys)\n  w = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  (0, 0) \\<notin> set (arcs i i ys)\n  i = 0\n  (i, w) \\<in> set (arcs i i ys)\n  w = 0\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case False"], ["proof (state)\nthis:\n  w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with \\<open>i = 0\\<close> neg_sum_1'' *(3) neg"], ["proof (chain)\npicking this:\n  i = 0\n  \\<lbrakk>(0, ?b3) \\<in> set (arcs i i ys); 0 < ?b3;\n   M 0 ?b3 + M\\<^sub>R ?b3 0 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  (i, w) \\<in> set (arcs i i ys)\n  M i w + M\\<^sub>R w i < \\<one>\n  w \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n  \\<lbrakk>(0, ?b3) \\<in> set (arcs i i ys); 0 < ?b3;\n   M 0 ?b3 + M\\<^sub>R ?b3 0 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  (i, w) \\<in> set (arcs i i ys)\n  M i w + M\\<^sub>R w i < \\<one>\n  w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by blast"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (cases \"w = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. w = 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. w \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case True"], ["proof (state)\nthis:\n  w = 0\n\ngoal (2 subgoals):\n 1. w = 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. w \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with \\<open>i \\<noteq> 0\\<close> neg_sum_1' *(3) neg"], ["proof (chain)\npicking this:\n  i \\<noteq> 0\n  \\<lbrakk>(?a3, 0) \\<in> set (arcs i i ys); 0 < ?a3;\n   M ?a3 0 + M\\<^sub>R 0 ?a3 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  (i, w) \\<in> set (arcs i i ys)\n  M i w + M\\<^sub>R w i < \\<one>\n  w = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  \\<lbrakk>(?a3, 0) \\<in> set (arcs i i ys); 0 < ?a3;\n   M ?a3 0 + M\\<^sub>R 0 ?a3 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  (i, w) \\<in> set (arcs i i ys)\n  M i w + M\\<^sub>R w i < \\<one>\n  w = 0\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by blast"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case False"], ["proof (state)\nthis:\n  w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0 \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with \\<open>i \\<noteq> 0\\<close> neg_sum_1 *(3) neg"], ["proof (chain)\npicking this:\n  i \\<noteq> 0\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?a3; 0 < ?b3;\n   M ?a3 ?b3 + M\\<^sub>R ?b3 ?a3 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  (i, w) \\<in> set (arcs i i ys)\n  M i w + M\\<^sub>R w i < \\<one>\n  w \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?a3; 0 < ?b3;\n   M ?a3 ?b3 + M\\<^sub>R ?b3 ?a3 < \\<one>\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  (i, w) \\<in> set (arcs i i ys)\n  M i w + M\\<^sub>R w i < \\<one>\n  w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by blast"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (2 subgoals):\n 1. ws = [] \\<Longrightarrow>\n    \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by simp"], ["proof (state)\nthis:\n  \\<exists>y z zs.\n     set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n     len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n     < Le 0 \\<and>\n     (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n         M a b < M\\<^sub>R a b \\<longrightarrow> a = y \\<and> b = z) \\<and>\n     M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n     R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case zs: (Cons z zs)"], ["proof (state)\nthis:\n  ws = z # zs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from one_M"], ["proof (chain)\npicking this:\n  \\<exists>(a, b)\\<in>set (arcs i i ys). M a b < M\\<^sub>R a b", "obtain a b where *:\n              \"(a,b) \\<in> set (arcs i i ys)\" \"M a b < M\\<^sub>R a b\""], ["proof (prove)\nusing this:\n  \\<exists>(a, b)\\<in>set (arcs i i ys). M a b < M\\<^sub>R a b\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>(a, b) \\<in> set (arcs i i ys);\n         M a b < M\\<^sub>R a b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  (a, b) \\<in> set (arcs i i ys)\n  M a b < M\\<^sub>R a b\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from cycle_rotate_3'[OF _ *(1) ys(3)] ws cycle_closes"], ["proof (chain)\npicking this:\n  \\<lbrakk>ys \\<noteq> [];\n   \\<not> (case (i, hd ys) of\n           (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b) \\<or>\n   \\<not> (case (last ys, i) of\n           (a, b) \\<Rightarrow>\n             min (M a b) (M\\<^sub>R a b) = M a b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ysa.\n                       len ?M i i ys = len ?M a a (b # ysa) \\<and>\n                       set (a # b # ysa) = set (i # ys) \\<and>\n                       1 + length ysa = length ys \\<and>\n                       set (arcs i i ys) = set (arcs a a (b # ysa)) \\<and>\n                       successive\n                        (\\<lambda>(a, b).\n                            min (M a b) (M\\<^sub>R a b) = M a b)\n                        (arcs a a (b # ysa) @ [(a, b)])\n  ys = w # ws\n  ys \\<noteq> [] \\<longrightarrow>\n  min (M i (hd ys)) (M\\<^sub>R i (hd ys)) \\<noteq> M i (hd ys) \\<or>\n  min (M (last ys) i) (M\\<^sub>R (last ys) i) \\<noteq> M (last ys) i", "obtain ws' where ws':\n              \"len ?M i i ys = len ?M a a (b # ws')\" \"set (a # b # ws') = set (i # ys)\"\n              \"1 + length ws' = length ys\" \"set (arcs i i ys) = set (arcs a a (b # ws'))\"\n              and successive: \"successive (\\<lambda>(a, b). ?M a b = M a b) (arcs a a (b # ws') @ [(a, b)])\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ys \\<noteq> [];\n   \\<not> (case (i, hd ys) of\n           (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b) \\<or>\n   \\<not> (case (last ys, i) of\n           (a, b) \\<Rightarrow>\n             min (M a b) (M\\<^sub>R a b) = M a b)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ysa.\n                       len ?M i i ys = len ?M a a (b # ysa) \\<and>\n                       set (a # b # ysa) = set (i # ys) \\<and>\n                       1 + length ysa = length ys \\<and>\n                       set (arcs i i ys) = set (arcs a a (b # ysa)) \\<and>\n                       successive\n                        (\\<lambda>(a, b).\n                            min (M a b) (M\\<^sub>R a b) = M a b)\n                        (arcs a a (b # ysa) @ [(a, b)])\n  ys = w # ws\n  ys \\<noteq> [] \\<longrightarrow>\n  min (M i (hd ys)) (M\\<^sub>R i (hd ys)) \\<noteq> M i (hd ys) \\<or>\n  min (M (last ys) i) (M\\<^sub>R (last ys) i) \\<noteq> M (last ys) i\n\ngoal (1 subgoal):\n 1. (\\<And>ws'.\n        \\<lbrakk>len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys =\n                 len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a\n                  (b # ws');\n         set (a # b # ws') = set (i # ys); 1 + length ws' = length ys;\n         set (arcs i i ys) = set (arcs a a (b # ws'));\n         successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n          (arcs a a (b # ws') @ [(a, b)])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys =\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws')\n  set (a # b # ws') = set (i # ys)\n  1 + length ws' = length ys\n  set (arcs i i ys) = set (arcs a a (b # ws'))\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs a a (b # ws') @ [(a, b)])\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from successive"], ["proof (chain)\npicking this:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs a a (b # ws') @ [(a, b)])", "have successive_arcs:\n              \"successive (\\<lambda>(a, b). ?M a b = M a b) (arcs a b (b # ws' @ [a]))\""], ["proof (prove)\nusing this:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs a a (b # ws') @ [(a, b)])\n\ngoal (1 subgoal):\n 1. successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n     (arcs a b (b # ws' @ [a]))", "using arcs_decomp_tail"], ["proof (prove)\nusing this:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs a a (b # ws') @ [(a, b)])\n  arcs ?j ?l (?ys @ [?i]) = arcs ?j ?i ?ys @ [(?i, ?l)]\n\ngoal (1 subgoal):\n 1. successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n     (arcs a b (b # ws' @ [a]))", "by auto"], ["proof (state)\nthis:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs a b (b # ws' @ [a]))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from ws'(4) one_M_R *(2)"], ["proof (chain)\npicking this:\n  set (arcs i i ys) = set (arcs a a (b # ws'))\n  \\<exists>(a, b)\\<in>set (arcs i i ys). M\\<^sub>R a b < M a b\n  M a b < M\\<^sub>R a b", "obtain c d where **:\n              \"(c,d) \\<in> set (arcs a a (b # ws'))\" \"M c d > M\\<^sub>R c d\" \"(a,b) \\<noteq> (c,d)\""], ["proof (prove)\nusing this:\n  set (arcs i i ys) = set (arcs a a (b # ws'))\n  \\<exists>(a, b)\\<in>set (arcs i i ys). M\\<^sub>R a b < M a b\n  M a b < M\\<^sub>R a b\n\ngoal (1 subgoal):\n 1. (\\<And>c d.\n        \\<lbrakk>(c, d) \\<in> set (arcs a a (b # ws'));\n         M\\<^sub>R c d < M c d; (a, b) \\<noteq> (c, d)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  (c, d) \\<in> set (arcs a a (b # ws'))\n  M\\<^sub>R c d < M c d\n  (a, b) \\<noteq> (c, d)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from card_distinct[of \"a # b # ws'\"] distinct_card[of \"i # ys\"] ws'(2,3) distinct"], ["proof (chain)\npicking this:\n  card (set (a # b # ws')) = length (a # b # ws') \\<Longrightarrow>\n  distinct (a # b # ws')\n  distinct (i # ys) \\<Longrightarrow> card (set (i # ys)) = length (i # ys)\n  set (a # b # ws') = set (i # ys)\n  1 + length ws' = length ys\n  distinct ys\n  i \\<notin> set ys", "have distinct: \"distinct (a # b # ws')\""], ["proof (prove)\nusing this:\n  card (set (a # b # ws')) = length (a # b # ws') \\<Longrightarrow>\n  distinct (a # b # ws')\n  distinct (i # ys) \\<Longrightarrow> card (set (i # ys)) = length (i # ys)\n  set (a # b # ws') = set (i # ys)\n  1 + length ws' = length ys\n  distinct ys\n  i \\<notin> set ys\n\ngoal (1 subgoal):\n 1. distinct (a # b # ws')", "by simp"], ["proof (state)\nthis:\n  distinct (a # b # ws')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from ws zs ws'(3)"], ["proof (chain)\npicking this:\n  ys = w # ws\n  ws = z # zs\n  1 + length ws' = length ys", "have \"ws' \\<noteq> []\""], ["proof (prove)\nusing this:\n  ys = w # ws\n  ws = z # zs\n  1 + length ws' = length ys\n\ngoal (1 subgoal):\n 1. ws' \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  ws' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  ws' \\<noteq> []", "obtain z zs where z: \"ws' = zs @ [z]\""], ["proof (prove)\nusing this:\n  ws' \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>zs z. ws' = zs @ [z] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis append_butlast_last_id)"], ["proof (state)\nthis:\n  ws' = zs @ [z]\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  ws' = zs @ [z]", "have \"b # ws' = (b # zs) @ [z]\""], ["proof (prove)\nusing this:\n  ws' = zs @ [z]\n\ngoal (1 subgoal):\n 1. b # ws' = (b # zs) @ [z]", "by simp"], ["proof (state)\nthis:\n  b # ws' = (b # zs) @ [z]\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with len_decomp[OF this, of ?M a a] arcs_decomp_tail"], ["proof (chain)\npicking this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws') =\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a z (b # zs) +\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z a []\n  arcs ?j ?l (?ys @ [?i]) = arcs ?j ?i ?ys @ [(?i, ?l)]\n  b # ws' = (b # zs) @ [z]", "have rotated:\n              \"len ?M a a (b # ws') = len ?M z z (a # b # zs)\"\n              \"set (arcs a a (b # ws')) = set (arcs z z (a # b # zs))\""], ["proof (prove)\nusing this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws') =\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a z (b # zs) +\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z a []\n  arcs ?j ?l (?ys @ [?i]) = arcs ?j ?i ?ys @ [(?i, ?l)]\n  b # ws' = (b # zs) @ [z]\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws') =\n    len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z z (a # b # zs) &&&\n    set (arcs a a (b # ws')) = set (arcs z z (a # b # zs))", "by (auto simp add: comm)"], ["proof (state)\nthis:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws') =\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z z (a # b # zs)\n  set (arcs a a (b # ws')) = set (arcs z z (a # b # zs))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from ys(1) xs(3) ws'(1)"], ["proof (chain)\npicking this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < \\<one>\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i__ i__ xs < \\<one>\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys =\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws')", "have \"len ?M a a (b # ws') < \\<one>\""], ["proof (prove)\nusing this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < \\<one>\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i__ i__ xs < \\<one>\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys =\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws')\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws') < \\<one>", "by auto"], ["proof (state)\nthis:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws') < \\<one>\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from ws'(2) ys(2) \\<open>i \\<le> n\\<close> z"], ["proof (chain)\npicking this:\n  set (a # b # ws') = set (i # ys)\n  set ys \\<subseteq> {0..n}\n  i \\<le> n\n  ws' = zs @ [z]", "have n_bounds: \"a \\<le> n\" \"b \\<le> n\" \"set ws' \\<subseteq> {0..n}\" \"z \\<le> n\""], ["proof (prove)\nusing this:\n  set (a # b # ws') = set (i # ys)\n  set ys \\<subseteq> {0..n}\n  i \\<le> n\n  ws' = zs @ [z]\n\ngoal (1 subgoal):\n 1. (a \\<le> n &&& b \\<le> n) &&& set ws' \\<subseteq> {0..n} &&& z \\<le> n", "by auto"], ["proof (state)\nthis:\n  a \\<le> n\n  b \\<le> n\n  set ws' \\<subseteq> {0..n}\n  z \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from *"], ["proof (chain)\npicking this:\n  (a, b) \\<in> set (arcs i i ys)\n  M a b < M\\<^sub>R a b", "have a_b: \"?M a b = M a b\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> set (arcs i i ys)\n  M a b < M\\<^sub>R a b\n\ngoal (1 subgoal):\n 1. min (M a b) (M\\<^sub>R a b) = M a b", "by (simp add: min.strict_order_iff)"], ["proof (state)\nthis:\n  min (M a b) (M\\<^sub>R a b) = M a b\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from successive successive_split[of _ \"arcs a z (b # zs)\" \"[(z,a), (a,b)]\"]"], ["proof (chain)\npicking this:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs a a (b # ws') @ [(a, b)])\n  \\<lbrakk>?xs = arcs a z (b # zs) @ [(z, a), (a, b)];\n   successive ?P ?xs\\<rbrakk>\n  \\<Longrightarrow> successive ?P (arcs a z (b # zs)) \\<and>\n                    successive ?P [(z, a), (a, b)]", "have first: \"successive (\\<lambda>(a, b). ?M a b = M a b) (arcs a z (b # zs))\" and\n                 last_two: \"successive (\\<lambda>(a, b). ?M a b = M a b) [(z, a), (a, b)]\""], ["proof (prove)\nusing this:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs a a (b # ws') @ [(a, b)])\n  \\<lbrakk>?xs = arcs a z (b # zs) @ [(z, a), (a, b)];\n   successive ?P ?xs\\<rbrakk>\n  \\<Longrightarrow> successive ?P (arcs a z (b # zs)) \\<and>\n                    successive ?P [(z, a), (a, b)]\n\ngoal (1 subgoal):\n 1. successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n     (arcs a z (b # zs)) &&&\n    successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n     [(z, a), (a, b)]", "using arcs_decomp_tail z"], ["proof (prove)\nusing this:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs a a (b # ws') @ [(a, b)])\n  \\<lbrakk>?xs = arcs a z (b # zs) @ [(z, a), (a, b)];\n   successive ?P ?xs\\<rbrakk>\n  \\<Longrightarrow> successive ?P (arcs a z (b # zs)) \\<and>\n                    successive ?P [(z, a), (a, b)]\n  arcs ?j ?l (?ys @ [?i]) = arcs ?j ?i ?ys @ [(?i, ?l)]\n  ws' = zs @ [z]\n\ngoal (1 subgoal):\n 1. successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n     (arcs a z (b # zs)) &&&\n    successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n     [(z, a), (a, b)]", "by auto"], ["proof (state)\nthis:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs a z (b # zs))\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   [(z, a), (a, b)]\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from * not_bounded"], ["proof (chain)\npicking this:\n  (a, b) \\<in> set (arcs i i ys)\n  M a b < M\\<^sub>R a b\n  \\<forall>(a, b)\\<in>set (arcs i i ys).\n     M a b < M\\<^sub>R a b \\<longrightarrow>\n     M\\<^sub>R a 0 = \\<infinity> \\<or> M\\<^sub>R b 0 = \\<infinity>", "have not_bounded': \"M\\<^sub>R a 0 = \\<infinity> \\<or> M\\<^sub>R b 0 = \\<infinity>\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> set (arcs i i ys)\n  M a b < M\\<^sub>R a b\n  \\<forall>(a, b)\\<in>set (arcs i i ys).\n     M a b < M\\<^sub>R a b \\<longrightarrow>\n     M\\<^sub>R a 0 = \\<infinity> \\<or> M\\<^sub>R b 0 = \\<infinity>\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = \\<infinity> \\<or> M\\<^sub>R b 0 = \\<infinity>", "by auto"], ["proof (state)\nthis:\n  M\\<^sub>R a 0 = \\<infinity> \\<or> M\\<^sub>R b 0 = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from this(1)"], ["proof (chain)\npicking this:\n  M\\<^sub>R a 0 = \\<infinity> \\<or> M\\<^sub>R b 0 = \\<infinity>", "have \"z = 0\""], ["proof (prove)\nusing this:\n  M\\<^sub>R a 0 = \\<infinity> \\<or> M\\<^sub>R b 0 = \\<infinity>\n\ngoal (1 subgoal):\n 1. z = 0", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = \\<infinity> \\<Longrightarrow> z = 0\n 2. M\\<^sub>R b 0 = \\<infinity> \\<Longrightarrow> z = 0", "assume inf: \"M\\<^sub>R b 0 = \\<infinity>\""], ["proof (state)\nthis:\n  M\\<^sub>R b 0 = \\<infinity>\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = \\<infinity> \\<Longrightarrow> z = 0\n 2. M\\<^sub>R b 0 = \\<infinity> \\<Longrightarrow> z = 0", "from a_b successive"], ["proof (chain)\npicking this:\n  min (M a b) (M\\<^sub>R a b) = M a b\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs a a (b # ws') @ [(a, b)])", "obtain z where z: \"(b,z) \\<in> set (arcs b a ws')\" \"?M b z \\<noteq> M b z\""], ["proof (prove)\nusing this:\n  min (M a b) (M\\<^sub>R a b) = M a b\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs a a (b # ws') @ [(a, b)])\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>(b, z) \\<in> set (arcs b a ws');\n         min (M b z) (M\\<^sub>R b z) \\<noteq> M b z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ws') auto"], ["proof (state)\nthis:\n  (b, z) \\<in> set (arcs b a ws')\n  min (M b z) (M\\<^sub>R b z) \\<noteq> M b z\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = \\<infinity> \\<Longrightarrow> za__ = 0\n 2. M\\<^sub>R b 0 = \\<infinity> \\<Longrightarrow> za__ = 0", "then"], ["proof (chain)\npicking this:\n  (b, z) \\<in> set (arcs b a ws')\n  min (M b z) (M\\<^sub>R b z) \\<noteq> M b z", "have \"?M b z = M\\<^sub>R b z\""], ["proof (prove)\nusing this:\n  (b, z) \\<in> set (arcs b a ws')\n  min (M b z) (M\\<^sub>R b z) \\<noteq> M b z\n\ngoal (1 subgoal):\n 1. min (M b z) (M\\<^sub>R b z) = M\\<^sub>R b z", "by (meson min_def)"], ["proof (state)\nthis:\n  min (M b z) (M\\<^sub>R b z) = M\\<^sub>R b z\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = \\<infinity> \\<Longrightarrow> za__ = 0\n 2. M\\<^sub>R b 0 = \\<infinity> \\<Longrightarrow> za__ = 0", "from arcs_distinct2[OF _ _ _ _ z(1)] distinct"], ["proof (chain)\npicking this:\n  \\<lbrakk>b \\<notin> set ws'; a \\<notin> set ws'; distinct ws';\n   b \\<noteq> a\\<rbrakk>\n  \\<Longrightarrow> b \\<noteq> z\n  distinct (a # b # ws')", "have \"b \\<noteq> z\""], ["proof (prove)\nusing this:\n  \\<lbrakk>b \\<notin> set ws'; a \\<notin> set ws'; distinct ws';\n   b \\<noteq> a\\<rbrakk>\n  \\<Longrightarrow> b \\<noteq> z\n  distinct (a # b # ws')\n\ngoal (1 subgoal):\n 1. b \\<noteq> z", "by auto"], ["proof (state)\nthis:\n  b \\<noteq> z\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = \\<infinity> \\<Longrightarrow> za__ = 0\n 2. M\\<^sub>R b 0 = \\<infinity> \\<Longrightarrow> za__ = 0", "from z n_bounds"], ["proof (chain)\npicking this:\n  (b, z) \\<in> set (arcs b a ws')\n  min (M b z) (M\\<^sub>R b z) \\<noteq> M b z\n  a \\<le> n\n  b \\<le> n\n  set ws' \\<subseteq> {0..n}\n  za__ \\<le> n", "have \"z \\<le> n\""], ["proof (prove)\nusing this:\n  (b, z) \\<in> set (arcs b a ws')\n  min (M b z) (M\\<^sub>R b z) \\<noteq> M b z\n  a \\<le> n\n  b \\<le> n\n  set ws' \\<subseteq> {0..n}\n  za__ \\<le> n\n\ngoal (1 subgoal):\n 1. z \\<le> n", "apply (induction ws' arbitrary: b)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>(b, z) \\<in> set (arcs b a []);\n        min (M b z) (M\\<^sub>R b z) \\<noteq> M b z; a \\<le> n; b \\<le> n;\n        set [] \\<subseteq> {0..n}; za__ \\<le> n\\<rbrakk>\n       \\<Longrightarrow> z \\<le> n\n 2. \\<And>aa ws' b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>(b, z) \\<in> set (arcs b a ws');\n                    min (M b z) (M\\<^sub>R b z) \\<noteq> M b z; a \\<le> n;\n                    b \\<le> n; set ws' \\<subseteq> {0..n};\n                    za__ \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> z \\<le> n;\n        (b, z) \\<in> set (arcs b a (aa # ws'));\n        min (M b z) (M\\<^sub>R b z) \\<noteq> M b z; a \\<le> n; b \\<le> n;\n        set (aa # ws') \\<subseteq> {0..n}; za__ \\<le> n\\<rbrakk>\n       \\<Longrightarrow> z \\<le> n", "apply auto[]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ws' b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>(b, z) \\<in> set (arcs b a ws');\n                    min (M b z) (M\\<^sub>R b z) \\<noteq> M b z; a \\<le> n;\n                    b \\<le> n; set ws' \\<subseteq> {0..n};\n                    za__ \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> z \\<le> n;\n        (b, z) \\<in> set (arcs b a (aa # ws'));\n        min (M b z) (M\\<^sub>R b z) \\<noteq> M b z; a \\<le> n; b \\<le> n;\n        set (aa # ws') \\<subseteq> {0..n}; za__ \\<le> n\\<rbrakk>\n       \\<Longrightarrow> z \\<le> n", "apply (rename_tac ws' b)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ws' b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>(b, z) \\<in> set (arcs b a ws');\n                    min (M b z) (M\\<^sub>R b z) \\<noteq> M b z; a \\<le> n;\n                    b \\<le> n; set ws' \\<subseteq> {0..n};\n                    za__ \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> z \\<le> n;\n        (b, z) \\<in> set (arcs b a (aa # ws'));\n        min (M b z) (M\\<^sub>R b z) \\<noteq> M b z; a \\<le> n; b \\<le> n;\n        set (aa # ws') \\<subseteq> {0..n}; za__ \\<le> n\\<rbrakk>\n       \\<Longrightarrow> z \\<le> n", "apply (case_tac ws')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa ws' b.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>(b, z) \\<in> set (arcs b a ws');\n                    min (M b z) (M\\<^sub>R b z) \\<noteq> M b z; a \\<le> n;\n                    b \\<le> n; set ws' \\<subseteq> {0..n};\n                    za__ \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> z \\<le> n;\n        (b, z) \\<in> set (arcs b a (aa # ws'));\n        min (M b z) (M\\<^sub>R b z) \\<noteq> M b z; a \\<le> n; b \\<le> n;\n        set (aa # ws') \\<subseteq> {0..n}; za__ \\<le> n; ws' = []\\<rbrakk>\n       \\<Longrightarrow> z \\<le> n\n 2. \\<And>aa ws' b aaa list.\n       \\<lbrakk>\\<And>b.\n                   \\<lbrakk>(b, z) \\<in> set (arcs b a ws');\n                    min (M b z) (M\\<^sub>R b z) \\<noteq> M b z; a \\<le> n;\n                    b \\<le> n; set ws' \\<subseteq> {0..n};\n                    za__ \\<le> n\\<rbrakk>\n                   \\<Longrightarrow> z \\<le> n;\n        (b, z) \\<in> set (arcs b a (aa # ws'));\n        min (M b z) (M\\<^sub>R b z) \\<noteq> M b z; a \\<le> n; b \\<le> n;\n        set (aa # ws') \\<subseteq> {0..n}; za__ \\<le> n;\n        ws' = aaa # list\\<rbrakk>\n       \\<Longrightarrow> z \\<le> n", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  z \\<le> n\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = \\<infinity> \\<Longrightarrow> za__ = 0\n 2. M\\<^sub>R b 0 = \\<infinity> \\<Longrightarrow> za__ = 0", "have \"M\\<^sub>R b z = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M\\<^sub>R b z = \\<infinity>", "proof (cases \"z = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> M\\<^sub>R b z = \\<infinity>\n 2. z \\<noteq> 0 \\<Longrightarrow> M\\<^sub>R b z = \\<infinity>", "case True"], ["proof (state)\nthis:\n  z = 0\n\ngoal (2 subgoals):\n 1. z = 0 \\<Longrightarrow> M\\<^sub>R b z = \\<infinity>\n 2. z \\<noteq> 0 \\<Longrightarrow> M\\<^sub>R b z = \\<infinity>", "with inf"], ["proof (chain)\npicking this:\n  M\\<^sub>R b 0 = \\<infinity>\n  z = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  M\\<^sub>R b 0 = \\<infinity>\n  z = 0\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b z = \\<infinity>", "by auto"], ["proof (state)\nthis:\n  M\\<^sub>R b z = \\<infinity>\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> M\\<^sub>R b z = \\<infinity>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> M\\<^sub>R b z = \\<infinity>", "case False"], ["proof (state)\nthis:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> M\\<^sub>R b z = \\<infinity>", "with inf M\\<^sub>R(2) \\<open>b \\<noteq> z\\<close> \\<open>z \\<le> n\\<close> \\<open>b \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  M\\<^sub>R b 0 = \\<infinity>\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        M\\<^sub>R i 0 = \\<infinity> \\<and>\n        0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n        M\\<^sub>R i j = \\<infinity> \\<and> M\\<^sub>R j i = \\<infinity>\n  b \\<noteq> z\n  z \\<le> n\n  b \\<le> n\n  z \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  M\\<^sub>R b 0 = \\<infinity>\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        M\\<^sub>R i 0 = \\<infinity> \\<and>\n        0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n        M\\<^sub>R i j = \\<infinity> \\<and> M\\<^sub>R j i = \\<infinity>\n  b \\<noteq> z\n  z \\<le> n\n  b \\<le> n\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. M\\<^sub>R b z = \\<infinity>", "by blast"], ["proof (state)\nthis:\n  M\\<^sub>R b z = \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M\\<^sub>R b z = \\<infinity>\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = \\<infinity> \\<Longrightarrow> za__ = 0\n 2. M\\<^sub>R b 0 = \\<infinity> \\<Longrightarrow> za__ = 0", "with \\<open>?M b z = M\\<^sub>R b z\\<close>"], ["proof (chain)\npicking this:\n  min (M b z) (M\\<^sub>R b z) = M\\<^sub>R b z\n  M\\<^sub>R b z = \\<infinity>", "have \"len ?M b a ws' = \\<infinity>\""], ["proof (prove)\nusing this:\n  min (M b z) (M\\<^sub>R b z) = M\\<^sub>R b z\n  M\\<^sub>R b z = \\<infinity>\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) b a ws' = \\<infinity>", "by (auto intro: len_inf_elem[OF z(1)])"], ["proof (state)\nthis:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) b a ws' = \\<infinity>\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = \\<infinity> \\<Longrightarrow> za__ = 0\n 2. M\\<^sub>R b 0 = \\<infinity> \\<Longrightarrow> za__ = 0", "then"], ["proof (chain)\npicking this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) b a ws' = \\<infinity>", "have \"\\<infinity> = len ?M a a (b # ws')\""], ["proof (prove)\nusing this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) b a ws' = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<infinity> =\n    len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws')", "by simp"], ["proof (state)\nthis:\n  \\<infinity> =\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws')\n\ngoal (2 subgoals):\n 1. M\\<^sub>R a 0 = \\<infinity> \\<Longrightarrow> za__ = 0\n 2. M\\<^sub>R b 0 = \\<infinity> \\<Longrightarrow> za__ = 0", "with \\<open>len ?M a a _ < \\<one>\\<close>"], ["proof (chain)\npicking this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws') < \\<one>\n  \\<infinity> =\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws')", "show ?thesis"], ["proof (prove)\nusing this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws') < \\<one>\n  \\<infinity> =\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws')\n\ngoal (1 subgoal):\n 1. za__ = 0", "by auto"], ["proof (state)\nthis:\n  za__ = 0\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = \\<infinity> \\<Longrightarrow> za__ = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = \\<infinity> \\<Longrightarrow> z = 0", "assume inf: \"M\\<^sub>R a 0 = \\<infinity>\""], ["proof (state)\nthis:\n  M\\<^sub>R a 0 = \\<infinity>\n\ngoal (1 subgoal):\n 1. M\\<^sub>R a 0 = \\<infinity> \\<Longrightarrow> z = 0", "show \"z = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> False", "assume \"z \\<noteq> 0\""], ["proof (state)\nthis:\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> False", "with last_two a_b"], ["proof (chain)\npicking this:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   [(z, a), (a, b)]\n  min (M a b) (M\\<^sub>R a b) = M a b\n  z \\<noteq> 0", "have \"?M z a = M\\<^sub>R z a\""], ["proof (prove)\nusing this:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   [(z, a), (a, b)]\n  min (M a b) (M\\<^sub>R a b) = M a b\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. min (M z a) (M\\<^sub>R z a) = M\\<^sub>R z a", "by (auto simp: min_def)"], ["proof (state)\nthis:\n  min (M z a) (M\\<^sub>R z a) = M\\<^sub>R z a\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> False", "from distinct z"], ["proof (chain)\npicking this:\n  distinct (a # b # ws')\n  ws' = zs @ [z]", "have \"a \\<noteq> z\""], ["proof (prove)\nusing this:\n  distinct (a # b # ws')\n  ws' = zs @ [z]\n\ngoal (1 subgoal):\n 1. a \\<noteq> z", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> z\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> False", "with \\<open>z \\<noteq> 0\\<close> \\<open>a \\<le> n\\<close> \\<open>z \\<le> n\\<close> M\\<^sub>R(2) inf"], ["proof (chain)\npicking this:\n  z \\<noteq> 0\n  a \\<le> n\n  z \\<le> n\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        M\\<^sub>R i 0 = \\<infinity> \\<and>\n        0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n        M\\<^sub>R i j = \\<infinity> \\<and> M\\<^sub>R j i = \\<infinity>\n  M\\<^sub>R a 0 = \\<infinity>\n  a \\<noteq> z", "have \"M\\<^sub>R z a = \\<infinity>\""], ["proof (prove)\nusing this:\n  z \\<noteq> 0\n  a \\<le> n\n  z \\<le> n\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        M\\<^sub>R i 0 = \\<infinity> \\<and>\n        0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n        M\\<^sub>R i j = \\<infinity> \\<and> M\\<^sub>R j i = \\<infinity>\n  M\\<^sub>R a 0 = \\<infinity>\n  a \\<noteq> z\n\ngoal (1 subgoal):\n 1. M\\<^sub>R z a = \\<infinity>", "by blast"], ["proof (state)\nthis:\n  M\\<^sub>R z a = \\<infinity>\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> False", "with \\<open>?M z a = M\\<^sub>R z a\\<close>"], ["proof (chain)\npicking this:\n  min (M z a) (M\\<^sub>R z a) = M\\<^sub>R z a\n  M\\<^sub>R z a = \\<infinity>", "have \"len ?M z z (a # b # zs) = \\<infinity>\""], ["proof (prove)\nusing this:\n  min (M z a) (M\\<^sub>R z a) = M\\<^sub>R z a\n  M\\<^sub>R z a = \\<infinity>\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z z (a # b # zs) =\n    \\<infinity>", "by (auto intro: len_inf_elem)"], ["proof (state)\nthis:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z z (a # b # zs) =\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. z \\<noteq> 0 \\<Longrightarrow> False", "with \\<open>len ?M a a _ < \\<one>\\<close> rotated"], ["proof (chain)\npicking this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws') < \\<one>\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws') =\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z z (a # b # zs)\n  set (arcs a a (b # ws')) = set (arcs z z (a # b # zs))\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z z (a # b # zs) =\n  \\<infinity>", "show False"], ["proof (prove)\nusing this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws') < \\<one>\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws') =\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z z (a # b # zs)\n  set (arcs a a (b # ws')) = set (arcs z z (a # b # zs))\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z z (a # b # zs) =\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z = 0\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  z = 0\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix c d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume A: \"(c, d) \\<in> set (arcs 0 0 (a # b # zs))\" \"M c d < M\\<^sub>R c d\""], ["proof (state)\nthis:\n  (c, d) \\<in> set (arcs 0 0 (a # b # zs))\n  M c d < M\\<^sub>R c d\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  (c, d) \\<in> set (arcs 0 0 (a # b # zs))\n  M c d < M\\<^sub>R c d", "have *: \"?M c d = M c d\""], ["proof (prove)\nusing this:\n  (c, d) \\<in> set (arcs 0 0 (a # b # zs))\n  M c d < M\\<^sub>R c d\n\ngoal (1 subgoal):\n 1. min (M c d) (M\\<^sub>R c d) = M c d", "by (simp add: min.strict_order_iff)"], ["proof (state)\nthis:\n  min (M c d) (M\\<^sub>R c d) = M c d\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from rotated(2) A \\<open>z = 0\\<close> not_bounded ws'(4)"], ["proof (chain)\npicking this:\n  set (arcs a a (b # ws')) = set (arcs z z (a # b # zs))\n  (c, d) \\<in> set (arcs 0 0 (a # b # zs))\n  M c d < M\\<^sub>R c d\n  z = 0\n  \\<forall>(a, b)\\<in>set (arcs i i ys).\n     M a b < M\\<^sub>R a b \\<longrightarrow>\n     M\\<^sub>R a 0 = \\<infinity> \\<or> M\\<^sub>R b 0 = \\<infinity>\n  set (arcs i i ys) = set (arcs a a (b # ws'))", "have **: \"M\\<^sub>R c 0 = \\<infinity> \\<or> M\\<^sub>R d 0 = \\<infinity>\""], ["proof (prove)\nusing this:\n  set (arcs a a (b # ws')) = set (arcs z z (a # b # zs))\n  (c, d) \\<in> set (arcs 0 0 (a # b # zs))\n  M c d < M\\<^sub>R c d\n  z = 0\n  \\<forall>(a, b)\\<in>set (arcs i i ys).\n     M a b < M\\<^sub>R a b \\<longrightarrow>\n     M\\<^sub>R a 0 = \\<infinity> \\<or> M\\<^sub>R b 0 = \\<infinity>\n  set (arcs i i ys) = set (arcs a a (b # ws'))\n\ngoal (1 subgoal):\n 1. M\\<^sub>R c 0 = \\<infinity> \\<or> M\\<^sub>R d 0 = \\<infinity>", "by auto"], ["proof (state)\nthis:\n  M\\<^sub>R c 0 = \\<infinity> \\<or> M\\<^sub>R d 0 = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  M\\<^sub>R c 0 = \\<infinity> \\<or> M\\<^sub>R d 0 = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume inf: \"M\\<^sub>R c 0 = \\<infinity>\""], ["proof (state)\nthis:\n  M\\<^sub>R c 0 = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume x: \"(x, c) \\<in> set (arcs a 0 (b # zs))\" \"?M x c \\<noteq> M x c\""], ["proof (state)\nthis:\n  (x, c) \\<in> set (arcs a 0 (b # zs))\n  min (M x c) (M\\<^sub>R x c) \\<noteq> M x c\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from x(2)"], ["proof (chain)\npicking this:\n  min (M x c) (M\\<^sub>R x c) \\<noteq> M x c", "have \"?M x c = M\\<^sub>R x c\""], ["proof (prove)\nusing this:\n  min (M x c) (M\\<^sub>R x c) \\<noteq> M x c\n\ngoal (1 subgoal):\n 1. min (M x c) (M\\<^sub>R x c) = M\\<^sub>R x c", "unfolding min_def"], ["proof (prove)\nusing this:\n  (if M x c \\<le> M\\<^sub>R x c then M x c else M\\<^sub>R x c) \\<noteq>\n  M x c\n\ngoal (1 subgoal):\n 1. (if M x c \\<le> M\\<^sub>R x c then M x c else M\\<^sub>R x c) =\n    M\\<^sub>R x c", "by auto"], ["proof (state)\nthis:\n  min (M x c) (M\\<^sub>R x c) = M\\<^sub>R x c\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from arcs_elem[OF x(1)] z \\<open>z = 0\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> set (a # b # zs)\n  c \\<in> set (0 # b # zs)\n  ws' = zs @ [z]\n  z = 0", "have\n                  \"x \\<in> set (a # b # ws')\" \"c \\<in> set (a # b # ws')\""], ["proof (prove)\nusing this:\n  x \\<in> set (a # b # zs)\n  c \\<in> set (0 # b # zs)\n  ws' = zs @ [z]\n  z = 0\n\ngoal (1 subgoal):\n 1. x \\<in> set (a # b # ws') &&& c \\<in> set (a # b # ws')", "by auto"], ["proof (state)\nthis:\n  x \\<in> set (a # b # ws')\n  c \\<in> set (a # b # ws')\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with n_bounds"], ["proof (chain)\npicking this:\n  a \\<le> n\n  b \\<le> n\n  set ws' \\<subseteq> {0..n}\n  z \\<le> n\n  x \\<in> set (a # b # ws')\n  c \\<in> set (a # b # ws')", "have \"x \\<le> n\" \"c \\<le> n\""], ["proof (prove)\nusing this:\n  a \\<le> n\n  b \\<le> n\n  set ws' \\<subseteq> {0..n}\n  z \\<le> n\n  x \\<in> set (a # b # ws')\n  c \\<in> set (a # b # ws')\n\ngoal (1 subgoal):\n 1. x \\<le> n &&& c \\<le> n", "by auto"], ["proof (state)\nthis:\n  x \\<le> n\n  c \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "have \"x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> False", "assume \"x \\<noteq> 0\""], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> False", "from distinct z arcs_distinct1[OF _ _ _ _ x(1)] \\<open>z = 0\\<close>"], ["proof (chain)\npicking this:\n  distinct (a # b # ws')\n  ws' = zs @ [z]\n  \\<lbrakk>a \\<notin> set (b # zs); 0 \\<notin> set (b # zs);\n   distinct (b # zs); b # zs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> x \\<noteq> c\n  z = 0", "have \"x \\<noteq> c\""], ["proof (prove)\nusing this:\n  distinct (a # b # ws')\n  ws' = zs @ [z]\n  \\<lbrakk>a \\<notin> set (b # zs); 0 \\<notin> set (b # zs);\n   distinct (b # zs); b # zs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> x \\<noteq> c\n  z = 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> c", "by auto"], ["proof (state)\nthis:\n  x \\<noteq> c\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> False", "with \\<open>x \\<noteq> 0\\<close> \\<open>c \\<le> n\\<close> \\<open>x \\<le> n\\<close> M\\<^sub>R(2) inf"], ["proof (chain)\npicking this:\n  x \\<noteq> 0\n  c \\<le> n\n  x \\<le> n\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        M\\<^sub>R i 0 = \\<infinity> \\<and>\n        0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n        M\\<^sub>R i j = \\<infinity> \\<and> M\\<^sub>R j i = \\<infinity>\n  M\\<^sub>R c 0 = \\<infinity>\n  x \\<noteq> c", "have \"M\\<^sub>R x c = \\<infinity>\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  c \\<le> n\n  x \\<le> n\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        M\\<^sub>R i 0 = \\<infinity> \\<and>\n        0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n        M\\<^sub>R i j = \\<infinity> \\<and> M\\<^sub>R j i = \\<infinity>\n  M\\<^sub>R c 0 = \\<infinity>\n  x \\<noteq> c\n\ngoal (1 subgoal):\n 1. M\\<^sub>R x c = \\<infinity>", "by blast"], ["proof (state)\nthis:\n  M\\<^sub>R x c = \\<infinity>\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> False", "with \\<open>?M x c = M\\<^sub>R x c\\<close>"], ["proof (chain)\npicking this:\n  min (M x c) (M\\<^sub>R x c) = M\\<^sub>R x c\n  M\\<^sub>R x c = \\<infinity>", "have\n                    \"len ?M a 0 (b # zs) = \\<infinity>\""], ["proof (prove)\nusing this:\n  min (M x c) (M\\<^sub>R x c) = M\\<^sub>R x c\n  M\\<^sub>R x c = \\<infinity>\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a 0 (b # zs) =\n    \\<infinity>", "by (fastforce intro: len_inf_elem[OF x(1)])"], ["proof (state)\nthis:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a 0 (b # zs) = \\<infinity>\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> False", "with \\<open>z = 0\\<close>"], ["proof (chain)\npicking this:\n  z = 0\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a 0 (b # zs) = \\<infinity>", "have \"len ?M z z (a # b # zs) = \\<infinity>\""], ["proof (prove)\nusing this:\n  z = 0\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a 0 (b # zs) = \\<infinity>\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z z (a # b # zs) =\n    \\<infinity>", "by auto"], ["proof (state)\nthis:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z z (a # b # zs) =\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> False", "with \\<open>len ?M a a _ < \\<one>\\<close> rotated"], ["proof (chain)\npicking this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws') < \\<one>\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws') =\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z z (a # b # zs)\n  set (arcs a a (b # ws')) = set (arcs z z (a # b # zs))\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z z (a # b # zs) =\n  \\<infinity>", "show False"], ["proof (prove)\nusing this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws') < \\<one>\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws') =\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z z (a # b # zs)\n  set (arcs a a (b # ws')) = set (arcs z z (a # b # zs))\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z z (a # b # zs) =\n  \\<infinity>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = 0\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with arcs_distinct_dest1[OF _ x(1), of z] z distinct x \\<open>z = 0\\<close>"], ["proof (chain)\npicking this:\n  distinct (z # a # b # zs) \\<Longrightarrow> x \\<noteq> z\n  ws' = zs @ [z]\n  distinct (a # b # ws')\n  (x, c) \\<in> set (arcs a 0 (b # zs))\n  min (M x c) (M\\<^sub>R x c) \\<noteq> M x c\n  z = 0\n  x = 0", "have False"], ["proof (prove)\nusing this:\n  distinct (z # a # b # zs) \\<Longrightarrow> x \\<noteq> z\n  ws' = zs @ [z]\n  distinct (a # b # ws')\n  (x, c) \\<in> set (arcs a 0 (b # zs))\n  min (M x c) (M\\<^sub>R x c) \\<noteq> M x c\n  z = 0\n  x = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>M\\<^sub>R c 0 = \\<infinity>;\n   (?x3, c) \\<in> set (arcs a 0 (b # zs));\n   min (M ?x3 c) (M\\<^sub>R ?x3 c) \\<noteq> M ?x3 c\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "note c_0_inf = this"], ["proof (state)\nthis:\n  \\<lbrakk>M\\<^sub>R c 0 = \\<infinity>;\n   (?x3, c) \\<in> set (arcs a 0 (b # zs));\n   min (M ?x3 c) (M\\<^sub>R ?x3 c) \\<noteq> M ?x3 c\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "have \"a = c \\<and> b = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = c \\<and> b = d", "proof (cases \"(c, d) = (0, a)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (c, d) = (0, a) \\<Longrightarrow> a = c \\<and> b = d\n 2. (c, d) \\<noteq> (0, a) \\<Longrightarrow> a = c \\<and> b = d", "case True"], ["proof (state)\nthis:\n  (c, d) = (0, a)\n\ngoal (2 subgoals):\n 1. (c, d) = (0, a) \\<Longrightarrow> a = c \\<and> b = d\n 2. (c, d) \\<noteq> (0, a) \\<Longrightarrow> a = c \\<and> b = d", "with last_two \\<open>z = 0\\<close> * a_b"], ["proof (chain)\npicking this:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   [(z, a), (a, b)]\n  z = 0\n  min (M c d) (M\\<^sub>R c d) = M c d\n  min (M a b) (M\\<^sub>R a b) = M a b\n  (c, d) = (0, a)", "have False"], ["proof (prove)\nusing this:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   [(z, a), (a, b)]\n  z = 0\n  min (M c d) (M\\<^sub>R c d) = M c d\n  min (M a b) (M\\<^sub>R a b) = M a b\n  (c, d) = (0, a)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. (c, d) = (0, a) \\<Longrightarrow> a = c \\<and> b = d\n 2. (c, d) \\<noteq> (0, a) \\<Longrightarrow> a = c \\<and> b = d", "then"], ["proof (chain)\npicking this:\n  False", "show ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. a = c \\<and> b = d", "by simp"], ["proof (state)\nthis:\n  a = c \\<and> b = d\n\ngoal (1 subgoal):\n 1. (c, d) \\<noteq> (0, a) \\<Longrightarrow> a = c \\<and> b = d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (c, d) \\<noteq> (0, a) \\<Longrightarrow> a = c \\<and> b = d", "case False"], ["proof (state)\nthis:\n  (c, d) \\<noteq> (0, a)\n\ngoal (1 subgoal):\n 1. (c, d) \\<noteq> (0, a) \\<Longrightarrow> a = c \\<and> b = d", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. a = c \\<and> b = d", "proof (rule ccontr, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (a = c \\<and> b = d) \\<Longrightarrow> False", "case 1"], ["proof (state)\nthis:\n  \\<not> (a = c \\<and> b = d)\n\ngoal (1 subgoal):\n 1. \\<not> (a = c \\<and> b = d) \\<Longrightarrow> False", "with False A(1)"], ["proof (chain)\npicking this:\n  (c, d) \\<noteq> (0, a)\n  (c, d) \\<in> set (arcs 0 0 (a # b # zs))\n  \\<not> (a = c \\<and> b = d)", "have ***: \"(c, d) \\<in> set (arcs b 0 zs)\""], ["proof (prove)\nusing this:\n  (c, d) \\<noteq> (0, a)\n  (c, d) \\<in> set (arcs 0 0 (a # b # zs))\n  \\<not> (a = c \\<and> b = d)\n\ngoal (1 subgoal):\n 1. (c, d) \\<in> set (arcs b 0 zs)", "by auto"], ["proof (state)\nthis:\n  (c, d) \\<in> set (arcs b 0 zs)\n\ngoal (1 subgoal):\n 1. \\<not> (a = c \\<and> b = d) \\<Longrightarrow> False", "from successive z \\<open>z = 0\\<close>"], ["proof (chain)\npicking this:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs a a (b # ws') @ [(a, b)])\n  ws' = zs @ [z]\n  z = 0", "have\n                    \"successive (\\<lambda>(a, b). ?M a b = M a b) ([(a, b)] @ arcs b 0 zs @ [(0, a), (a, b)])\""], ["proof (prove)\nusing this:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs a a (b # ws') @ [(a, b)])\n  ws' = zs @ [z]\n  z = 0\n\ngoal (1 subgoal):\n 1. successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n     ([(a, b)] @ arcs b 0 zs @ [(0, a), (a, b)])", "by (simp add: arcs_decomp)"], ["proof (state)\nthis:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   ([(a, b)] @ arcs b 0 zs @ [(0, a), (a, b)])\n\ngoal (1 subgoal):\n 1. \\<not> (a = c \\<and> b = d) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   ([(a, b)] @ arcs b 0 zs @ [(0, a), (a, b)])", "have ****: \"successive (\\<lambda>(a, b). ?M a b = M a b) (arcs b 0 zs)\""], ["proof (prove)\nusing this:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   ([(a, b)] @ arcs b 0 zs @ [(0, a), (a, b)])\n\ngoal (1 subgoal):\n 1. successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n     (arcs b 0 zs)", "using successive_split[of _ \"[(a, b)]\" \"arcs b 0 zs @ [(0, a), (a, b)]\"]\n                        successive_split[of _ \"arcs b 0 zs\" \"[(0, a), (a, b)]\"]"], ["proof (prove)\nusing this:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   ([(a, b)] @ arcs b 0 zs @ [(0, a), (a, b)])\n  \\<lbrakk>?xs = [(a, b)] @ arcs b 0 zs @ [(0, a), (a, b)];\n   successive ?P ?xs\\<rbrakk>\n  \\<Longrightarrow> successive ?P [(a, b)] \\<and>\n                    successive ?P (arcs b 0 zs @ [(0, a), (a, b)])\n  \\<lbrakk>?xs = arcs b 0 zs @ [(0, a), (a, b)]; successive ?P ?xs\\<rbrakk>\n  \\<Longrightarrow> successive ?P (arcs b 0 zs) \\<and>\n                    successive ?P [(0, a), (a, b)]\n\ngoal (1 subgoal):\n 1. successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n     (arcs b 0 zs)", "by auto"], ["proof (state)\nthis:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs b 0 zs)\n\ngoal (1 subgoal):\n 1. \\<not> (a = c \\<and> b = d) \\<Longrightarrow> False", "from successive_predecessor[OF *** _ this] successive z"], ["proof (chain)\npicking this:\n  \\<lbrakk>c \\<noteq> b;\n   case (c, d) of (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b;\n   zs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c.\n                       (zs = [c] \\<and> c = b \\<or>\n                        (\\<exists>ys. zs = c # d # ys \\<and> c = b) \\<or>\n                        (\\<exists>ys. zs = ys @ [c, c] \\<and> d = 0) \\<or>\n                        (\\<exists>ys zs. zs = ys @ c # c # d # zs)) \\<and>\n                       \\<not> (case (c, c) of\n                               (a, b) \\<Rightarrow>\n                                 min (M a b) (M\\<^sub>R a b) = M a b)\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs a a (b # ws') @ [(a, b)])\n  ws' = zs @ [z]", "obtain x where x: \"(x, c) \\<in> set (arcs a 0 (b # zs))\" \"?M x c \\<noteq> M x c\""], ["proof (prove)\nusing this:\n  \\<lbrakk>c \\<noteq> b;\n   case (c, d) of (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b;\n   zs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c.\n                       (zs = [c] \\<and> c = b \\<or>\n                        (\\<exists>ys. zs = c # d # ys \\<and> c = b) \\<or>\n                        (\\<exists>ys. zs = ys @ [c, c] \\<and> d = 0) \\<or>\n                        (\\<exists>ys zs. zs = ys @ c # c # d # zs)) \\<and>\n                       \\<not> (case (c, c) of\n                               (a, b) \\<Rightarrow>\n                                 min (M a b) (M\\<^sub>R a b) = M a b)\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs a a (b # ws') @ [(a, b)])\n  ws' = zs @ [z]\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>(x, c) \\<in> set (arcs a 0 (b # zs));\n         min (M x c) (M\\<^sub>R x c) \\<noteq> M x c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"c = b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>(x, c) \\<in> set (arcs a 0 (b # zs));\n                 min (M x c) (M\\<^sub>R x c) \\<noteq> M x c\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>c \\<noteq> b;\n      case (c, d) of\n      (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b;\n      zs \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> \\<exists>c.\n                          (zs = [c] \\<and> c = b \\<or>\n                           (\\<exists>ys. zs = c # d # ys \\<and> c = b) \\<or>\n                           (\\<exists>ys.\n                               zs = ys @ [c, c] \\<and> d = 0) \\<or>\n                           (\\<exists>ys zs.\n                               zs = ys @ c # c # d # zs)) \\<and>\n                          \\<not> (case (c, c) of\n                                  (a, b) \\<Rightarrow>\n                                    min (M a b) (M\\<^sub>R a b) = M a b);\n     successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n      (arcs a a (b # ws') @ [(a, b)]);\n     ws' = zs @ [z]; c = b\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>x.\n                \\<lbrakk>(x, c) \\<in> set (arcs a 0 (b # zs));\n                 min (M x c) (M\\<^sub>R x c) \\<noteq> M x c\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>c \\<noteq> b;\n      case (c, d) of\n      (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b;\n      zs \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> \\<exists>c.\n                          (zs = [c] \\<and> c = b \\<or>\n                           (\\<exists>ys. zs = c # d # ys \\<and> c = b) \\<or>\n                           (\\<exists>ys.\n                               zs = ys @ [c, c] \\<and> d = 0) \\<or>\n                           (\\<exists>ys zs.\n                               zs = ys @ c # c # d # zs)) \\<and>\n                          \\<not> (case (c, c) of\n                                  (a, b) \\<Rightarrow>\n                                    min (M a b) (M\\<^sub>R a b) = M a b);\n     successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n      (arcs a a (b # ws') @ [(a, b)]);\n     ws' = zs @ [z]; c \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  c \\<noteq> b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>(x, c) \\<in> set (arcs a 0 (b # zs));\n                 min (M x c) (M\\<^sub>R x c) \\<noteq> M x c\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>c \\<noteq> b;\n      case (c, d) of\n      (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b;\n      zs \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> \\<exists>c.\n                          (zs = [c] \\<and> c = b \\<or>\n                           (\\<exists>ys. zs = c # d # ys \\<and> c = b) \\<or>\n                           (\\<exists>ys.\n                               zs = ys @ [c, c] \\<and> d = 0) \\<or>\n                           (\\<exists>ys zs.\n                               zs = ys @ c # c # d # zs)) \\<and>\n                          \\<not> (case (c, c) of\n                                  (a, b) \\<Rightarrow>\n                                    min (M a b) (M\\<^sub>R a b) = M a b);\n     successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n      (arcs a a (b # ws') @ [(a, b)]);\n     ws' = zs @ [z]; c = b\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>x.\n                \\<lbrakk>(x, c) \\<in> set (arcs a 0 (b # zs));\n                 min (M x c) (M\\<^sub>R x c) \\<noteq> M x c\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>c \\<noteq> b;\n      case (c, d) of\n      (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b;\n      zs \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> \\<exists>c.\n                          (zs = [c] \\<and> c = b \\<or>\n                           (\\<exists>ys. zs = c # d # ys \\<and> c = b) \\<or>\n                           (\\<exists>ys.\n                               zs = ys @ [c, c] \\<and> d = 0) \\<or>\n                           (\\<exists>ys zs.\n                               zs = ys @ c # c # d # zs)) \\<and>\n                          \\<not> (case (c, c) of\n                                  (a, b) \\<Rightarrow>\n                                    min (M a b) (M\\<^sub>R a b) = M a b);\n     successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n      (arcs a a (b # ws') @ [(a, b)]);\n     ws' = zs @ [z]; c \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  c \\<noteq> b", "have \"zs \\<noteq> []\""], ["proof (prove)\nusing this:\n  c \\<noteq> b\n\ngoal (1 subgoal):\n 1. zs \\<noteq> []", "using ***"], ["proof (prove)\nusing this:\n  c \\<noteq> b\n  (c, d) \\<in> set (arcs b 0 zs)\n\ngoal (1 subgoal):\n 1. zs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  zs \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>(x, c) \\<in> set (arcs a 0 (b # zs));\n                 min (M x c) (M\\<^sub>R x c) \\<noteq> M x c\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>c \\<noteq> b;\n      case (c, d) of\n      (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b;\n      zs \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> \\<exists>c.\n                          (zs = [c] \\<and> c = b \\<or>\n                           (\\<exists>ys. zs = c # d # ys \\<and> c = b) \\<or>\n                           (\\<exists>ys.\n                               zs = ys @ [c, c] \\<and> d = 0) \\<or>\n                           (\\<exists>ys zs.\n                               zs = ys @ c # c # d # zs)) \\<and>\n                          \\<not> (case (c, c) of\n                                  (a, b) \\<Rightarrow>\n                                    min (M a b) (M\\<^sub>R a b) = M a b);\n     successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n      (arcs a a (b # ws') @ [(a, b)]);\n     ws' = zs @ [z]; c = b\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>x.\n                \\<lbrakk>(x, c) \\<in> set (arcs a 0 (b # zs));\n                 min (M x c) (M\\<^sub>R x c) \\<noteq> M x c\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>c \\<noteq> b;\n      case (c, d) of\n      (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b;\n      zs \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> \\<exists>c.\n                          (zs = [c] \\<and> c = b \\<or>\n                           (\\<exists>ys. zs = c # d # ys \\<and> c = b) \\<or>\n                           (\\<exists>ys.\n                               zs = ys @ [c, c] \\<and> d = 0) \\<or>\n                           (\\<exists>ys zs.\n                               zs = ys @ c # c # d # zs)) \\<and>\n                          \\<not> (case (c, c) of\n                                  (a, b) \\<Rightarrow>\n                                    min (M a b) (M\\<^sub>R a b) = M a b);\n     successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n      (arcs a a (b # ws') @ [(a, b)]);\n     ws' = zs @ [z]; c \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> thesis", "from successive_predecessor[OF *** False **** _ this] *"], ["proof (chain)\npicking this:\n  case (c, d) of\n  (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b \\<Longrightarrow>\n  \\<exists>c.\n     (zs = [c] \\<and> c = b \\<or>\n      (\\<exists>ys. zs = c # d # ys \\<and> c = b) \\<or>\n      (\\<exists>ys. zs = ys @ [c, c] \\<and> d = 0) \\<or>\n      (\\<exists>ys zs. zs = ys @ c # c # d # zs)) \\<and>\n     \\<not> (case (c, c) of\n             (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b)\n  min (M c d) (M\\<^sub>R c d) = M c d", "obtain x where x:\n                      \"(zs = [c] \\<and> x = b \\<or> (\\<exists>ys. zs = c # d # ys \\<and> x = b)\n                        \\<or> (\\<exists>ys. zs = ys @ [x, c] \\<and> d = 0) \\<or> (\\<exists>ys ws. zs = ys @ x # c # d # ws))\"\n                      \"?M x c \\<noteq> M x c\""], ["proof (prove)\nusing this:\n  case (c, d) of\n  (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b \\<Longrightarrow>\n  \\<exists>c.\n     (zs = [c] \\<and> c = b \\<or>\n      (\\<exists>ys. zs = c # d # ys \\<and> c = b) \\<or>\n      (\\<exists>ys. zs = ys @ [c, c] \\<and> d = 0) \\<or>\n      (\\<exists>ys zs. zs = ys @ c # c # d # zs)) \\<and>\n     \\<not> (case (c, c) of\n             (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b)\n  min (M c d) (M\\<^sub>R c d) = M c d\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>zs = [c] \\<and> x = b \\<or>\n                 (\\<exists>ys. zs = c # d # ys \\<and> x = b) \\<or>\n                 (\\<exists>ys. zs = ys @ [x, c] \\<and> d = 0) \\<or>\n                 (\\<exists>ys ws. zs = ys @ x # c # d # ws);\n         min (M x c) (M\\<^sub>R x c) \\<noteq> M x c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast+"], ["proof (state)\nthis:\n  zs = [c] \\<and> x = b \\<or>\n  (\\<exists>ys. zs = c # d # ys \\<and> x = b) \\<or>\n  (\\<exists>ys. zs = ys @ [x, c] \\<and> d = 0) \\<or>\n  (\\<exists>ys ws. zs = ys @ x # c # d # ws)\n  min (M x c) (M\\<^sub>R x c) \\<noteq> M x c\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>(x, c) \\<in> set (arcs a 0 (b # zs));\n                 min (M x c) (M\\<^sub>R x c) \\<noteq> M x c\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>c \\<noteq> b;\n      case (c, d) of\n      (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b;\n      zs \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> \\<exists>c.\n                          (zs = [c] \\<and> c = b \\<or>\n                           (\\<exists>ys. zs = c # d # ys \\<and> c = b) \\<or>\n                           (\\<exists>ys.\n                               zs = ys @ [c, c] \\<and> d = 0) \\<or>\n                           (\\<exists>ys zs.\n                               zs = ys @ c # c # d # zs)) \\<and>\n                          \\<not> (case (c, c) of\n                                  (a, b) \\<Rightarrow>\n                                    min (M a b) (M\\<^sub>R a b) = M a b);\n     successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n      (arcs a a (b # ws') @ [(a, b)]);\n     ws' = zs @ [z]; c = b\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>x.\n                \\<lbrakk>(x, c) \\<in> set (arcs a 0 (b # zs));\n                 min (M x c) (M\\<^sub>R x c) \\<noteq> M x c\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>c \\<noteq> b;\n      case (c, d) of\n      (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b;\n      zs \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> \\<exists>c.\n                          (zs = [c] \\<and> c = b \\<or>\n                           (\\<exists>ys. zs = c # d # ys \\<and> c = b) \\<or>\n                           (\\<exists>ys.\n                               zs = ys @ [c, c] \\<and> d = 0) \\<or>\n                           (\\<exists>ys zs.\n                               zs = ys @ c # c # d # zs)) \\<and>\n                          \\<not> (case (c, c) of\n                                  (a, b) \\<Rightarrow>\n                                    min (M a b) (M\\<^sub>R a b) = M a b);\n     successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n      (arcs a a (b # ws') @ [(a, b)]);\n     ws' = zs @ [z]; c \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> thesis", "from this(1)"], ["proof (chain)\npicking this:\n  zs = [c] \\<and> x = b \\<or>\n  (\\<exists>ys. zs = c # d # ys \\<and> x = b) \\<or>\n  (\\<exists>ys. zs = ys @ [x, c] \\<and> d = 0) \\<or>\n  (\\<exists>ys ws. zs = ys @ x # c # d # ws)", "have \"(x, c) \\<in> set (arcs a 0 (b # zs))\""], ["proof (prove)\nusing this:\n  zs = [c] \\<and> x = b \\<or>\n  (\\<exists>ys. zs = c # d # ys \\<and> x = b) \\<or>\n  (\\<exists>ys. zs = ys @ [x, c] \\<and> d = 0) \\<or>\n  (\\<exists>ys ws. zs = ys @ x # c # d # ws)\n\ngoal (1 subgoal):\n 1. (x, c) \\<in> set (arcs a 0 (b # zs))", "using arcs_decomp"], ["proof (prove)\nusing this:\n  zs = [c] \\<and> x = b \\<or>\n  (\\<exists>ys. zs = c # d # ys \\<and> x = b) \\<or>\n  (\\<exists>ys. zs = ys @ [x, c] \\<and> d = 0) \\<or>\n  (\\<exists>ys ws. zs = ys @ x # c # d # ws)\n  ?xs = ?ys @ ?y # ?zs \\<Longrightarrow>\n  arcs ?x ?z ?xs = arcs ?x ?y ?ys @ arcs ?y ?z ?zs\n\ngoal (1 subgoal):\n 1. (x, c) \\<in> set (arcs a 0 (b # zs))", "by auto"], ["proof (state)\nthis:\n  (x, c) \\<in> set (arcs a 0 (b # zs))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>(x, c) \\<in> set (arcs a 0 (b # zs));\n                 min (M x c) (M\\<^sub>R x c) \\<noteq> M x c\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>c \\<noteq> b;\n      case (c, d) of\n      (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b;\n      zs \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> \\<exists>c.\n                          (zs = [c] \\<and> c = b \\<or>\n                           (\\<exists>ys. zs = c # d # ys \\<and> c = b) \\<or>\n                           (\\<exists>ys.\n                               zs = ys @ [c, c] \\<and> d = 0) \\<or>\n                           (\\<exists>ys zs.\n                               zs = ys @ c # c # d # zs)) \\<and>\n                          \\<not> (case (c, c) of\n                                  (a, b) \\<Rightarrow>\n                                    min (M a b) (M\\<^sub>R a b) = M a b);\n     successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n      (arcs a a (b # ws') @ [(a, b)]);\n     ws' = zs @ [z]; c = b\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>x.\n                \\<lbrakk>(x, c) \\<in> set (arcs a 0 (b # zs));\n                 min (M x c) (M\\<^sub>R x c) \\<noteq> M x c\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>c \\<noteq> b;\n      case (c, d) of\n      (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b;\n      zs \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> \\<exists>c.\n                          (zs = [c] \\<and> c = b \\<or>\n                           (\\<exists>ys. zs = c # d # ys \\<and> c = b) \\<or>\n                           (\\<exists>ys.\n                               zs = ys @ [c, c] \\<and> d = 0) \\<or>\n                           (\\<exists>ys zs.\n                               zs = ys @ c # c # d # zs)) \\<and>\n                          \\<not> (case (c, c) of\n                                  (a, b) \\<Rightarrow>\n                                    min (M a b) (M\\<^sub>R a b) = M a b);\n     successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n      (arcs a a (b # ws') @ [(a, b)]);\n     ws' = zs @ [z]; c \\<noteq> b\\<rbrakk>\n    \\<Longrightarrow> thesis", "with x(2)"], ["proof (chain)\npicking this:\n  min (M x c) (M\\<^sub>R x c) \\<noteq> M x c\n  (x, c) \\<in> set (arcs a 0 (b # zs))", "show ?thesis"], ["proof (prove)\nusing this:\n  min (M x c) (M\\<^sub>R x c) \\<noteq> M x c\n  (x, c) \\<in> set (arcs a 0 (b # zs))\n\ngoal (1 subgoal):\n 1. thesis", "by (auto intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>(x, c) \\<in> set (arcs a 0 (b # zs));\n                 min (M x c) (M\\<^sub>R x c) \\<noteq> M x c\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>c \\<noteq> b;\n      case (c, d) of\n      (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b;\n      zs \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> \\<exists>c.\n                          (zs = [c] \\<and> c = b \\<or>\n                           (\\<exists>ys. zs = c # d # ys \\<and> c = b) \\<or>\n                           (\\<exists>ys.\n                               zs = ys @ [c, c] \\<and> d = 0) \\<or>\n                           (\\<exists>ys zs.\n                               zs = ys @ c # c # d # zs)) \\<and>\n                          \\<not> (case (c, c) of\n                                  (a, b) \\<Rightarrow>\n                                    min (M a b) (M\\<^sub>R a b) = M a b);\n     successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n      (arcs a a (b # ws') @ [(a, b)]);\n     ws' = zs @ [z]; c = b\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>(x, c) \\<in> set (arcs a 0 (b # zs));\n                 min (M x c) (M\\<^sub>R x c) \\<noteq> M x c\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>c \\<noteq> b;\n      case (c, d) of\n      (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b;\n      zs \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> \\<exists>c.\n                          (zs = [c] \\<and> c = b \\<or>\n                           (\\<exists>ys. zs = c # d # ys \\<and> c = b) \\<or>\n                           (\\<exists>ys.\n                               zs = ys @ [c, c] \\<and> d = 0) \\<or>\n                           (\\<exists>ys zs.\n                               zs = ys @ c # c # d # zs)) \\<and>\n                          \\<not> (case (c, c) of\n                                  (a, b) \\<Rightarrow>\n                                    min (M a b) (M\\<^sub>R a b) = M a b);\n     successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n      (arcs a a (b # ws') @ [(a, b)]);\n     ws' = zs @ [z]; c = b\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  c = b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>(x, c) \\<in> set (arcs a 0 (b # zs));\n                 min (M x c) (M\\<^sub>R x c) \\<noteq> M x c\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>c \\<noteq> b;\n      case (c, d) of\n      (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b;\n      zs \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> \\<exists>c.\n                          (zs = [c] \\<and> c = b \\<or>\n                           (\\<exists>ys. zs = c # d # ys \\<and> c = b) \\<or>\n                           (\\<exists>ys.\n                               zs = ys @ [c, c] \\<and> d = 0) \\<or>\n                           (\\<exists>ys zs.\n                               zs = ys @ c # c # d # zs)) \\<and>\n                          \\<not> (case (c, c) of\n                                  (a, b) \\<Rightarrow>\n                                    min (M a b) (M\\<^sub>R a b) = M a b);\n     successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n      (arcs a a (b # ws') @ [(a, b)]);\n     ws' = zs @ [z]; c = b\\<rbrakk>\n    \\<Longrightarrow> thesis", "have ****: \"successive (\\<lambda>(a, b). ?M a b = M a b) (arcs a 0 (b # zs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n     (arcs a 0 (b # zs))", "using first \\<open>z = 0\\<close> arcs_decomp successive_arcs z"], ["proof (prove)\nusing this:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs a z (b # zs))\n  z = 0\n  ?xs = ?ys @ ?y # ?zs \\<Longrightarrow>\n  arcs ?x ?z ?xs = arcs ?x ?y ?ys @ arcs ?y ?z ?zs\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs a b (b # ws' @ [a]))\n  ws' = zs @ [z]\n\ngoal (1 subgoal):\n 1. successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n     (arcs a 0 (b # zs))", "by auto"], ["proof (state)\nthis:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs a 0 (b # zs))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>(x, c) \\<in> set (arcs a 0 (b # zs));\n                 min (M x c) (M\\<^sub>R x c) \\<noteq> M x c\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<lbrakk>c \\<noteq> b;\n      case (c, d) of\n      (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b;\n      zs \\<noteq> []\\<rbrakk>\n     \\<Longrightarrow> \\<exists>c.\n                          (zs = [c] \\<and> c = b \\<or>\n                           (\\<exists>ys. zs = c # d # ys \\<and> c = b) \\<or>\n                           (\\<exists>ys.\n                               zs = ys @ [c, c] \\<and> d = 0) \\<or>\n                           (\\<exists>ys zs.\n                               zs = ys @ c # c # d # zs)) \\<and>\n                          \\<not> (case (c, c) of\n                                  (a, b) \\<Rightarrow>\n                                    min (M a b) (M\\<^sub>R a b) = M a b);\n     successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n      (arcs a a (b # ws') @ [(a, b)]);\n     ws' = zs @ [z]; c = b\\<rbrakk>\n    \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof (cases zs)"], ["proof (state)\ngoal (2 subgoals):\n 1. zs = [] \\<Longrightarrow> thesis\n 2. \\<And>a list. zs = a # list \\<Longrightarrow> thesis", "case Nil"], ["proof (state)\nthis:\n  zs = []\n\ngoal (2 subgoals):\n 1. zs = [] \\<Longrightarrow> thesis\n 2. \\<And>a list. zs = a # list \\<Longrightarrow> thesis", "with **** True *** *"], ["proof (chain)\npicking this:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs a 0 (b # zs))\n  c = b\n  (c, d) \\<in> set (arcs b 0 zs)\n  min (M c d) (M\\<^sub>R c d) = M c d\n  zs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs a 0 (b # zs))\n  c = b\n  (c, d) \\<in> set (arcs b 0 zs)\n  min (M c d) (M\\<^sub>R c d) = M c d\n  zs = []\n\ngoal (1 subgoal):\n 1. thesis", "by (auto intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>a list. zs = a # list \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. zs = a # list \\<Longrightarrow> thesis", "case (Cons u us)"], ["proof (state)\nthis:\n  zs = u # us\n\ngoal (1 subgoal):\n 1. \\<And>a list. zs = a # list \\<Longrightarrow> thesis", "with *** True distinct z \\<open>z = 0\\<close>"], ["proof (chain)\npicking this:\n  (c, d) \\<in> set (arcs b 0 zs)\n  c = b\n  distinct (a # b # ws')\n  ws' = zs @ [z]\n  z = 0\n  zs = u # us", "have \"distinct (b # u # us @ [0])\""], ["proof (prove)\nusing this:\n  (c, d) \\<in> set (arcs b 0 zs)\n  c = b\n  distinct (a # b # ws')\n  ws' = zs @ [z]\n  z = 0\n  zs = u # us\n\ngoal (1 subgoal):\n 1. distinct (b # u # us @ [0])", "by auto"], ["proof (state)\nthis:\n  distinct (b # u # us @ [0])\n\ngoal (1 subgoal):\n 1. \\<And>a list. zs = a # list \\<Longrightarrow> thesis", "from arcs_distinct_fix[OF this] *** True Cons"], ["proof (chain)\npicking this:\n  (b, ?c) \\<in> set (arcs b 0 (u # us)) \\<Longrightarrow> ?c = u\n  (c, d) \\<in> set (arcs b 0 zs)\n  c = b\n  zs = u # us", "have \"d = u\""], ["proof (prove)\nusing this:\n  (b, ?c) \\<in> set (arcs b 0 (u # us)) \\<Longrightarrow> ?c = u\n  (c, d) \\<in> set (arcs b 0 zs)\n  c = b\n  zs = u # us\n\ngoal (1 subgoal):\n 1. d = u", "by auto"], ["proof (state)\nthis:\n  d = u\n\ngoal (1 subgoal):\n 1. \\<And>a list. zs = a # list \\<Longrightarrow> thesis", "with **** * Cons True"], ["proof (chain)\npicking this:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs a 0 (b # zs))\n  min (M c d) (M\\<^sub>R c d) = M c d\n  zs = u # us\n  c = b\n  d = u", "show ?thesis"], ["proof (prove)\nusing this:\n  successive (\\<lambda>(a, b). min (M a b) (M\\<^sub>R a b) = M a b)\n   (arcs a 0 (b # zs))\n  min (M c d) (M\\<^sub>R c d) = M c d\n  zs = u # us\n  c = b\n  d = u\n\ngoal (1 subgoal):\n 1. thesis", "by (auto intro: that)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x, c) \\<in> set (arcs a 0 (b # zs))\n  min (M x c) (M\\<^sub>R x c) \\<noteq> M x c\n\ngoal (1 subgoal):\n 1. \\<not> (a = c \\<and> b = d) \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"d = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. d = 0 \\<Longrightarrow> False\n 2. d \\<noteq> 0 \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  d = 0\n\ngoal (2 subgoals):\n 1. d = 0 \\<Longrightarrow> False\n 2. d \\<noteq> 0 \\<Longrightarrow> False", "from **"], ["proof (chain)\npicking this:\n  M\\<^sub>R c 0 = \\<infinity> \\<or> M\\<^sub>R d 0 = \\<infinity>", "show False"], ["proof (prove)\nusing this:\n  M\\<^sub>R c 0 = \\<infinity> \\<or> M\\<^sub>R d 0 = \\<infinity>\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. M\\<^sub>R c 0 = \\<infinity> \\<Longrightarrow> False\n 2. M\\<^sub>R d 0 = \\<infinity> \\<Longrightarrow> False", "assume \"M\\<^sub>R c 0 = \\<infinity>\""], ["proof (state)\nthis:\n  M\\<^sub>R c 0 = \\<infinity>\n\ngoal (2 subgoals):\n 1. M\\<^sub>R c 0 = \\<infinity> \\<Longrightarrow> False\n 2. M\\<^sub>R d 0 = \\<infinity> \\<Longrightarrow> False", "from c_0_inf[OF this x]"], ["proof (chain)\npicking this:\n  False", "show False"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "."], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. M\\<^sub>R d 0 = \\<infinity> \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M\\<^sub>R d 0 = \\<infinity> \\<Longrightarrow> False", "assume \"M\\<^sub>R d 0 = \\<infinity>\""], ["proof (state)\nthis:\n  M\\<^sub>R d 0 = \\<infinity>\n\ngoal (1 subgoal):\n 1. M\\<^sub>R d 0 = \\<infinity> \\<Longrightarrow> False", "with \\<open>d = 0\\<close> M\\<^sub>R(3)"], ["proof (chain)\npicking this:\n  d = 0\n  \\<forall>i\\<le>n. M\\<^sub>R i i = Le 0\n  M\\<^sub>R d 0 = \\<infinity>", "show False"], ["proof (prove)\nusing this:\n  d = 0\n  \\<forall>i\\<le>n. M\\<^sub>R i i = Le 0\n  M\\<^sub>R d 0 = \\<infinity>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. d \\<noteq> 0 \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. d \\<noteq> 0 \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. d \\<noteq> 0 \\<Longrightarrow> False", "with ***"], ["proof (chain)\npicking this:\n  (c, d) \\<in> set (arcs b 0 zs)\n  d \\<noteq> 0", "have \"zs \\<noteq> []\""], ["proof (prove)\nusing this:\n  (c, d) \\<in> set (arcs b 0 zs)\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. zs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  zs \\<noteq> []\n\ngoal (1 subgoal):\n 1. d \\<noteq> 0 \\<Longrightarrow> False", "from successive_successor[OF \\<open>(c,d) \\<in> set (arcs b 0 zs)\\<close> False **** _ this] *"], ["proof (chain)\npicking this:\n  case (c, d) of\n  (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b \\<Longrightarrow>\n  \\<exists>c.\n     (zs = [d] \\<and> c = 0 \\<or>\n      (\\<exists>ys. zs = d # c # ys) \\<or>\n      (\\<exists>ys. zs = ys @ [c, d] \\<and> c = 0) \\<or>\n      (\\<exists>ys zs. zs = ys @ c # d # c # zs)) \\<and>\n     \\<not> (case (d, c) of\n             (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b)\n  min (M c d) (M\\<^sub>R c d) = M c d", "obtain e where\n                      \"(zs = [d] \\<and> e = 0 \\<or> (\\<exists>ys. zs = d # e # ys) \\<or> (\\<exists>ys. zs = ys @ [c, d] \\<and> e = 0)\n                        \\<or> (\\<exists>ys ws. zs = ys @ c # d # e # ws))\" \"?M d e \\<noteq> M d e\""], ["proof (prove)\nusing this:\n  case (c, d) of\n  (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b \\<Longrightarrow>\n  \\<exists>c.\n     (zs = [d] \\<and> c = 0 \\<or>\n      (\\<exists>ys. zs = d # c # ys) \\<or>\n      (\\<exists>ys. zs = ys @ [c, d] \\<and> c = 0) \\<or>\n      (\\<exists>ys zs. zs = ys @ c # d # c # zs)) \\<and>\n     \\<not> (case (d, c) of\n             (a, b) \\<Rightarrow> min (M a b) (M\\<^sub>R a b) = M a b)\n  min (M c d) (M\\<^sub>R c d) = M c d\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>zs = [d] \\<and> e = 0 \\<or>\n                 (\\<exists>ys. zs = d # e # ys) \\<or>\n                 (\\<exists>ys. zs = ys @ [c, d] \\<and> e = 0) \\<or>\n                 (\\<exists>ys ws. zs = ys @ c # d # e # ws);\n         min (M d e) (M\\<^sub>R d e) \\<noteq> M d e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  zs = [d] \\<and> e = 0 \\<or>\n  (\\<exists>ys. zs = d # e # ys) \\<or>\n  (\\<exists>ys. zs = ys @ [c, d] \\<and> e = 0) \\<or>\n  (\\<exists>ys ws. zs = ys @ c # d # e # ws)\n  min (M d e) (M\\<^sub>R d e) \\<noteq> M d e\n\ngoal (1 subgoal):\n 1. d \\<noteq> 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  zs = [d] \\<and> e = 0 \\<or>\n  (\\<exists>ys. zs = d # e # ys) \\<or>\n  (\\<exists>ys. zs = ys @ [c, d] \\<and> e = 0) \\<or>\n  (\\<exists>ys ws. zs = ys @ c # d # e # ws)\n  min (M d e) (M\\<^sub>R d e) \\<noteq> M d e", "have e: \"(d, e) \\<in> set (arcs b 0 zs)\" \"?M d e \\<noteq> M d e\""], ["proof (prove)\nusing this:\n  zs = [d] \\<and> e = 0 \\<or>\n  (\\<exists>ys. zs = d # e # ys) \\<or>\n  (\\<exists>ys. zs = ys @ [c, d] \\<and> e = 0) \\<or>\n  (\\<exists>ys ws. zs = ys @ c # d # e # ws)\n  min (M d e) (M\\<^sub>R d e) \\<noteq> M d e\n\ngoal (1 subgoal):\n 1. (d, e) \\<in> set (arcs b 0 zs) &&&\n    min (M d e) (M\\<^sub>R d e) \\<noteq> M d e", "using arcs_decomp"], ["proof (prove)\nusing this:\n  zs = [d] \\<and> e = 0 \\<or>\n  (\\<exists>ys. zs = d # e # ys) \\<or>\n  (\\<exists>ys. zs = ys @ [c, d] \\<and> e = 0) \\<or>\n  (\\<exists>ys ws. zs = ys @ c # d # e # ws)\n  min (M d e) (M\\<^sub>R d e) \\<noteq> M d e\n  ?xs = ?ys @ ?y # ?zs \\<Longrightarrow>\n  arcs ?x ?z ?xs = arcs ?x ?y ?ys @ arcs ?y ?z ?zs\n\ngoal (1 subgoal):\n 1. (d, e) \\<in> set (arcs b 0 zs) &&&\n    min (M d e) (M\\<^sub>R d e) \\<noteq> M d e", "by auto"], ["proof (state)\nthis:\n  (d, e) \\<in> set (arcs b 0 zs)\n  min (M d e) (M\\<^sub>R d e) \\<noteq> M d e\n\ngoal (1 subgoal):\n 1. d \\<noteq> 0 \\<Longrightarrow> False", "from **"], ["proof (chain)\npicking this:\n  M\\<^sub>R c 0 = \\<infinity> \\<or> M\\<^sub>R d 0 = \\<infinity>", "show False"], ["proof (prove)\nusing this:\n  M\\<^sub>R c 0 = \\<infinity> \\<or> M\\<^sub>R d 0 = \\<infinity>\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. M\\<^sub>R c 0 = \\<infinity> \\<Longrightarrow> False\n 2. M\\<^sub>R d 0 = \\<infinity> \\<Longrightarrow> False", "assume inf: \"M\\<^sub>R d 0 = \\<infinity>\""], ["proof (state)\nthis:\n  M\\<^sub>R d 0 = \\<infinity>\n\ngoal (2 subgoals):\n 1. M\\<^sub>R c 0 = \\<infinity> \\<Longrightarrow> False\n 2. M\\<^sub>R d 0 = \\<infinity> \\<Longrightarrow> False", "from e"], ["proof (chain)\npicking this:\n  (d, e) \\<in> set (arcs b 0 zs)\n  min (M d e) (M\\<^sub>R d e) \\<noteq> M d e", "have \"?M d e = M\\<^sub>R d e\""], ["proof (prove)\nusing this:\n  (d, e) \\<in> set (arcs b 0 zs)\n  min (M d e) (M\\<^sub>R d e) \\<noteq> M d e\n\ngoal (1 subgoal):\n 1. min (M d e) (M\\<^sub>R d e) = M\\<^sub>R d e", "by (meson min_def)"], ["proof (state)\nthis:\n  min (M d e) (M\\<^sub>R d e) = M\\<^sub>R d e\n\ngoal (2 subgoals):\n 1. M\\<^sub>R c 0 = \\<infinity> \\<Longrightarrow> False\n 2. M\\<^sub>R d 0 = \\<infinity> \\<Longrightarrow> False", "from arcs_distinct2[OF _ _ _ _ e(1)] z \\<open>z = 0\\<close> distinct"], ["proof (chain)\npicking this:\n  \\<lbrakk>b \\<notin> set zs; 0 \\<notin> set zs; distinct zs;\n   b \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> d \\<noteq> e\n  ws' = zs @ [z]\n  z = 0\n  distinct (a # b # ws')", "have \"d \\<noteq> e\""], ["proof (prove)\nusing this:\n  \\<lbrakk>b \\<notin> set zs; 0 \\<notin> set zs; distinct zs;\n   b \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> d \\<noteq> e\n  ws' = zs @ [z]\n  z = 0\n  distinct (a # b # ws')\n\ngoal (1 subgoal):\n 1. d \\<noteq> e", "by auto"], ["proof (state)\nthis:\n  d \\<noteq> e\n\ngoal (2 subgoals):\n 1. M\\<^sub>R c 0 = \\<infinity> \\<Longrightarrow> False\n 2. M\\<^sub>R d 0 = \\<infinity> \\<Longrightarrow> False", "from z n_bounds"], ["proof (chain)\npicking this:\n  ws' = zs @ [z]\n  a \\<le> n\n  b \\<le> n\n  set ws' \\<subseteq> {0..n}\n  z \\<le> n", "have \"set zs \\<subseteq> {0..n}\""], ["proof (prove)\nusing this:\n  ws' = zs @ [z]\n  a \\<le> n\n  b \\<le> n\n  set ws' \\<subseteq> {0..n}\n  z \\<le> n\n\ngoal (1 subgoal):\n 1. set zs \\<subseteq> {0..n}", "by auto"], ["proof (state)\nthis:\n  set zs \\<subseteq> {0..n}\n\ngoal (2 subgoals):\n 1. M\\<^sub>R c 0 = \\<infinity> \\<Longrightarrow> False\n 2. M\\<^sub>R d 0 = \\<infinity> \\<Longrightarrow> False", "with e"], ["proof (chain)\npicking this:\n  (d, e) \\<in> set (arcs b 0 zs)\n  min (M d e) (M\\<^sub>R d e) \\<noteq> M d e\n  set zs \\<subseteq> {0..n}", "have \"e \\<le> n\""], ["proof (prove)\nusing this:\n  (d, e) \\<in> set (arcs b 0 zs)\n  min (M d e) (M\\<^sub>R d e) \\<noteq> M d e\n  set zs \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. e \\<le> n", "apply (induction zs arbitrary: d)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>d.\n       \\<lbrakk>(d, e) \\<in> set (arcs b 0 []);\n        min (M d e) (M\\<^sub>R d e) \\<noteq> M d e;\n        set [] \\<subseteq> {0..n}\\<rbrakk>\n       \\<Longrightarrow> e \\<le> n\n 2. \\<And>a zs d.\n       \\<lbrakk>\\<And>d.\n                   \\<lbrakk>(d, e) \\<in> set (arcs b 0 zs);\n                    min (M d e) (M\\<^sub>R d e) \\<noteq> M d e;\n                    set zs \\<subseteq> {0..n}\\<rbrakk>\n                   \\<Longrightarrow> e \\<le> n;\n        (d, e) \\<in> set (arcs b 0 (a # zs));\n        min (M d e) (M\\<^sub>R d e) \\<noteq> M d e;\n        set (a # zs) \\<subseteq> {0..n}\\<rbrakk>\n       \\<Longrightarrow> e \\<le> n", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a zs d.\n       \\<lbrakk>\\<And>d.\n                   \\<lbrakk>(d, e) \\<in> set (arcs b 0 zs);\n                    min (M d e) (M\\<^sub>R d e) \\<noteq> M d e\\<rbrakk>\n                   \\<Longrightarrow> e \\<le> n;\n        min (M d e) (M\\<^sub>R d e) \\<noteq> M d e; a \\<le> n;\n        set zs \\<subseteq> {0..n}; (d, e) \\<in> set (arcs a 0 zs)\\<rbrakk>\n       \\<Longrightarrow> e \\<le> n", "apply (case_tac zs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a zs d.\n       \\<lbrakk>\\<And>d.\n                   \\<lbrakk>(d, e) \\<in> set (arcs b 0 zs);\n                    min (M d e) (M\\<^sub>R d e) \\<noteq> M d e\\<rbrakk>\n                   \\<Longrightarrow> e \\<le> n;\n        min (M d e) (M\\<^sub>R d e) \\<noteq> M d e; a \\<le> n;\n        set zs \\<subseteq> {0..n}; (d, e) \\<in> set (arcs a 0 zs);\n        zs = []\\<rbrakk>\n       \\<Longrightarrow> e \\<le> n\n 2. \\<And>a zs d aa list.\n       \\<lbrakk>\\<And>d.\n                   \\<lbrakk>(d, e) \\<in> set (arcs b 0 zs);\n                    min (M d e) (M\\<^sub>R d e) \\<noteq> M d e\\<rbrakk>\n                   \\<Longrightarrow> e \\<le> n;\n        min (M d e) (M\\<^sub>R d e) \\<noteq> M d e; a \\<le> n;\n        set zs \\<subseteq> {0..n}; (d, e) \\<in> set (arcs a 0 zs);\n        zs = aa # list\\<rbrakk>\n       \\<Longrightarrow> e \\<le> n", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  e \\<le> n\n\ngoal (2 subgoals):\n 1. M\\<^sub>R c 0 = \\<infinity> \\<Longrightarrow> False\n 2. M\\<^sub>R d 0 = \\<infinity> \\<Longrightarrow> False", "from n_bounds z arcs_elem(2)[OF A(1)]"], ["proof (chain)\npicking this:\n  a \\<le> n\n  b \\<le> n\n  set ws' \\<subseteq> {0..n}\n  z \\<le> n\n  ws' = zs @ [z]\n  d \\<in> set (0 # a # b # zs)", "have \"d \\<le> n\""], ["proof (prove)\nusing this:\n  a \\<le> n\n  b \\<le> n\n  set ws' \\<subseteq> {0..n}\n  z \\<le> n\n  ws' = zs @ [z]\n  d \\<in> set (0 # a # b # zs)\n\ngoal (1 subgoal):\n 1. d \\<le> n", "by auto"], ["proof (state)\nthis:\n  d \\<le> n\n\ngoal (2 subgoals):\n 1. M\\<^sub>R c 0 = \\<infinity> \\<Longrightarrow> False\n 2. M\\<^sub>R d 0 = \\<infinity> \\<Longrightarrow> False", "have \"M\\<^sub>R d e = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M\\<^sub>R d e = \\<infinity>", "proof (cases \"e = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. e = 0 \\<Longrightarrow> M\\<^sub>R d e = \\<infinity>\n 2. e \\<noteq> 0 \\<Longrightarrow> M\\<^sub>R d e = \\<infinity>", "case True"], ["proof (state)\nthis:\n  e = 0\n\ngoal (2 subgoals):\n 1. e = 0 \\<Longrightarrow> M\\<^sub>R d e = \\<infinity>\n 2. e \\<noteq> 0 \\<Longrightarrow> M\\<^sub>R d e = \\<infinity>", "with inf"], ["proof (chain)\npicking this:\n  M\\<^sub>R d 0 = \\<infinity>\n  e = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  M\\<^sub>R d 0 = \\<infinity>\n  e = 0\n\ngoal (1 subgoal):\n 1. M\\<^sub>R d e = \\<infinity>", "by auto"], ["proof (state)\nthis:\n  M\\<^sub>R d e = \\<infinity>\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow> M\\<^sub>R d e = \\<infinity>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow> M\\<^sub>R d e = \\<infinity>", "case False"], ["proof (state)\nthis:\n  e \\<noteq> 0\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow> M\\<^sub>R d e = \\<infinity>", "with inf M\\<^sub>R(2) \\<open>d \\<noteq> e\\<close> \\<open>e \\<le> n\\<close> \\<open>d \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  M\\<^sub>R d 0 = \\<infinity>\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        M\\<^sub>R i 0 = \\<infinity> \\<and>\n        0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n        M\\<^sub>R i j = \\<infinity> \\<and> M\\<^sub>R j i = \\<infinity>\n  d \\<noteq> e\n  e \\<le> n\n  d \\<le> n\n  e \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  M\\<^sub>R d 0 = \\<infinity>\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        M\\<^sub>R i 0 = \\<infinity> \\<and>\n        0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n        M\\<^sub>R i j = \\<infinity> \\<and> M\\<^sub>R j i = \\<infinity>\n  d \\<noteq> e\n  e \\<le> n\n  d \\<le> n\n  e \\<noteq> 0\n\ngoal (1 subgoal):\n 1. M\\<^sub>R d e = \\<infinity>", "by blast"], ["proof (state)\nthis:\n  M\\<^sub>R d e = \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M\\<^sub>R d e = \\<infinity>\n\ngoal (2 subgoals):\n 1. M\\<^sub>R c 0 = \\<infinity> \\<Longrightarrow> False\n 2. M\\<^sub>R d 0 = \\<infinity> \\<Longrightarrow> False", "with \\<open>?M d e = M\\<^sub>R d e\\<close>"], ["proof (chain)\npicking this:\n  min (M d e) (M\\<^sub>R d e) = M\\<^sub>R d e\n  M\\<^sub>R d e = \\<infinity>", "have \"len ?M b 0 zs = \\<infinity>\""], ["proof (prove)\nusing this:\n  min (M d e) (M\\<^sub>R d e) = M\\<^sub>R d e\n  M\\<^sub>R d e = \\<infinity>\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) b 0 zs = \\<infinity>", "by (auto intro: len_inf_elem[OF e(1)])"], ["proof (state)\nthis:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) b 0 zs = \\<infinity>\n\ngoal (2 subgoals):\n 1. M\\<^sub>R c 0 = \\<infinity> \\<Longrightarrow> False\n 2. M\\<^sub>R d 0 = \\<infinity> \\<Longrightarrow> False", "with \\<open>z = 0\\<close> rotated"], ["proof (chain)\npicking this:\n  z = 0\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws') =\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z z (a # b # zs)\n  set (arcs a a (b # ws')) = set (arcs z z (a # b # zs))\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) b 0 zs = \\<infinity>", "have \"\\<infinity> = len ?M a a (b # ws')\""], ["proof (prove)\nusing this:\n  z = 0\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws') =\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z z (a # b # zs)\n  set (arcs a a (b # ws')) = set (arcs z z (a # b # zs))\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) b 0 zs = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<infinity> =\n    len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws')", "by simp"], ["proof (state)\nthis:\n  \\<infinity> =\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws')\n\ngoal (2 subgoals):\n 1. M\\<^sub>R c 0 = \\<infinity> \\<Longrightarrow> False\n 2. M\\<^sub>R d 0 = \\<infinity> \\<Longrightarrow> False", "with \\<open>len ?M a a _ < \\<one>\\<close>"], ["proof (chain)\npicking this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws') < \\<one>\n  \\<infinity> =\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws')", "show ?thesis"], ["proof (prove)\nusing this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws') < \\<one>\n  \\<infinity> =\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws')\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. M\\<^sub>R c 0 = \\<infinity> \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M\\<^sub>R c 0 = \\<infinity> \\<Longrightarrow> False", "assume \"M\\<^sub>R c 0 = \\<infinity>\""], ["proof (state)\nthis:\n  M\\<^sub>R c 0 = \\<infinity>\n\ngoal (1 subgoal):\n 1. M\\<^sub>R c 0 = \\<infinity> \\<Longrightarrow> False", "from c_0_inf[OF this x]"], ["proof (chain)\npicking this:\n  False", "show False"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "."], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a = c \\<and> b = d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  a = c \\<and> b = d\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(?ca3, ?da3) \\<in> set (arcs 0 0 (a # b # zs));\n   M ?ca3 ?da3 < M\\<^sub>R ?ca3 ?da3\\<rbrakk>\n  \\<Longrightarrow> a = ?ca3 \\<and> b = ?da3\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?ca3, ?da3) \\<in> set (arcs 0 0 (a # b # zs));\n   M ?ca3 ?da3 < M\\<^sub>R ?ca3 ?da3\\<rbrakk>\n  \\<Longrightarrow> a = ?ca3 \\<and> b = ?da3", "have \"\\<forall>(c, d)\\<in>set (arcs 0 0 (a # b # zs)). M c d < M\\<^sub>R c d \\<longrightarrow> c = a \\<and> d = b\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?ca3, ?da3) \\<in> set (arcs 0 0 (a # b # zs));\n   M ?ca3 ?da3 < M\\<^sub>R ?ca3 ?da3\\<rbrakk>\n  \\<Longrightarrow> a = ?ca3 \\<and> b = ?da3\n\ngoal (1 subgoal):\n 1. \\<forall>(c, d)\\<in>set (arcs 0 0 (a # b # zs)).\n       M c d < M\\<^sub>R c d \\<longrightarrow> c = a \\<and> d = b", "by blast"], ["proof (state)\nthis:\n  \\<forall>(c, d)\\<in>set (arcs 0 0 (a # b # zs)).\n     M c d < M\\<^sub>R c d \\<longrightarrow> c = a \\<and> d = b\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  \\<forall>(c, d)\\<in>set (arcs 0 0 (a # b # zs)).\n     M c d < M\\<^sub>R c d \\<longrightarrow> c = a \\<and> d = b\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from ys(1) xs(3)"], ["proof (chain)\npicking this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < \\<one>\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i__ i__ xs < \\<one>", "have \"len ?M i i ys < Le 0\""], ["proof (prove)\nusing this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < \\<one>\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i__ i__ xs < \\<one>\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < Le 0", "unfolding neutral"], ["proof (prove)\nusing this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < Le 0\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i__ i__ xs < Le 0\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < Le 0", "by auto"], ["proof (state)\nthis:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < Le 0\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < Le 0\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with rotated ws'(1)"], ["proof (chain)\npicking this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws') =\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z z (a # b # zs)\n  set (arcs a a (b # ws')) = set (arcs z z (a # b # zs))\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys =\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws')\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < Le 0", "have \"len ?M z z (a # b # zs) < Le 0\""], ["proof (prove)\nusing this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws') =\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z z (a # b # zs)\n  set (arcs a a (b # ws')) = set (arcs z z (a # b # zs))\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys =\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) a a (b # ws')\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < Le 0\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z z (a # b # zs) < Le 0", "by auto"], ["proof (state)\nthis:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z z (a # b # zs) < Le 0\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z z (a # b # zs) < Le 0\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from \\<open>z = 0\\<close> z ws'(2)"], ["proof (chain)\npicking this:\n  z = 0\n  ws' = zs @ [z]\n  set (a # b # ws') = set (i # ys)", "have \"set zs \\<union> {0, a, b} = set (i # ys)\""], ["proof (prove)\nusing this:\n  z = 0\n  ws' = zs @ [z]\n  set (a # b # ws') = set (i # ys)\n\ngoal (1 subgoal):\n 1. set zs \\<union> {0, a, b} = set (i # ys)", "by auto"], ["proof (state)\nthis:\n  set zs \\<union> {0, a, b} = set (i # ys)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  set zs \\<union> {0, a, b} = set (i # ys)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from \\<open>z = 0\\<close> distinct z"], ["proof (chain)\npicking this:\n  z = 0\n  distinct (a # b # ws')\n  ws' = zs @ [z]", "have \"distinct (0 # a # b # zs)\""], ["proof (prove)\nusing this:\n  z = 0\n  distinct (a # b # ws')\n  ws' = zs @ [z]\n\ngoal (1 subgoal):\n 1. distinct (0 # a # b # zs)", "by auto"], ["proof (state)\nthis:\n  distinct (0 # a # b # zs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       ws = a # list \\<Longrightarrow>\n       \\<exists>y z zs.\n          set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n          len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n          < Le 0 \\<and>\n          (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n              M a b < M\\<^sub>R a b \\<longrightarrow>\n              a = y \\<and> b = z) \\<and>\n          M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n          R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>(c, d)\\<in>set (arcs 0 0 (a # b # zs)).\n     M c d < M\\<^sub>R c d \\<longrightarrow> c = a \\<and> d = b\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < Le 0\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z z (a # b # zs) < Le 0\n  set zs \\<union> {0, a, b} = set (i # ys)\n  distinct (0 # a # b # zs)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>(c, d)\\<in>set (arcs 0 0 (a # b # zs)).\n     M c d < M\\<^sub>R c d \\<longrightarrow> c = a \\<and> d = b\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < Le 0\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z z (a # b # zs) < Le 0\n  set zs \\<union> {0, a, b} = set (i # ys)\n  distinct (0 # a # b # zs)\n\ngoal (1 subgoal):\n 1. \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "using \\<open>z = 0\\<close> \\<open>M a b < M\\<^sub>R a b\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>(c, d)\\<in>set (arcs 0 0 (a # b # zs)).\n     M c d < M\\<^sub>R c d \\<longrightarrow> c = a \\<and> d = b\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) i i ys < Le 0\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z z (a # b # zs) < Le 0\n  set zs \\<union> {0, a, b} = set (i # ys)\n  distinct (0 # a # b # zs)\n  z = 0\n  M a b < M\\<^sub>R a b\n\ngoal (1 subgoal):\n 1. \\<exists>y z zs.\n       set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n       len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n       < Le 0 \\<and>\n       (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n           M a b < M\\<^sub>R a b \\<longrightarrow>\n           a = y \\<and> b = z) \\<and>\n       M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n       R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by blast"], ["proof (state)\nthis:\n  \\<exists>y z zs.\n     set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n     len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n     < Le 0 \\<and>\n     (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n         M a b < M\\<^sub>R a b \\<longrightarrow> a = y \\<and> b = z) \\<and>\n     M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n     R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>y z zs.\n     set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n     len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n     < Le 0 \\<and>\n     (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n         M a b < M\\<^sub>R a b \\<longrightarrow> a = y \\<and> b = z) \\<and>\n     M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n     R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>y z zs.\n     set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n     len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n     < Le 0 \\<and>\n     (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n         M a b < M\\<^sub>R a b \\<longrightarrow> a = y \\<and> b = z) \\<and>\n     M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n     R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "note * = this"], ["proof (state)\nthis:\n  \\<exists>y z zs.\n     set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n     len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n     < Le 0 \\<and>\n     (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n         M a b < M\\<^sub>R a b \\<longrightarrow> a = y \\<and> b = z) \\<and>\n     M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n     R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  \\<exists>y z zs.\n     set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n     len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n     < Le 0 \\<and>\n     (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n         M a b < M\\<^sub>R a b \\<longrightarrow> a = y \\<and> b = z) \\<and>\n     M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n     R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume \"\\<not> ?thesis\""], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with *"], ["proof (chain)\npicking this:\n  \\<exists>y z zs.\n     set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n     len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n     < Le 0 \\<and>\n     (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n         M a b < M\\<^sub>R a b \\<longrightarrow> a = y \\<and> b = z) \\<and>\n     M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n     R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  R \\<inter> Approx\\<^sub>\\<beta> Z \\<noteq> {}", "obtain y z zs where *:\n            \"set zs \\<union> {0, y, z} = set (i # ys)\" \"len ?M 0 0 (y # z # zs) < Le 0\"\n            \"\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)). M a b < M\\<^sub>R a b \\<longrightarrow> a = y \\<and> b = z\" \"M y z < M\\<^sub>R y z\"\n            and distinct': \"distinct (0 # y # z # zs)\""], ["proof (prove)\nusing this:\n  \\<exists>y z zs.\n     set zs \\<union> {0, y, z} = set (i # ys) \\<and>\n     len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n     < Le 0 \\<and>\n     (\\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n         M a b < M\\<^sub>R a b \\<longrightarrow> a = y \\<and> b = z) \\<and>\n     M y z < M\\<^sub>R y z \\<and> distinct (0 # y # z # zs) \\<or>\n     R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  R \\<inter> Approx\\<^sub>\\<beta> Z \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>zs y z.\n        \\<lbrakk>set zs \\<union> {0, y, z} = set (i # ys);\n         len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs)\n         < Le 0;\n         \\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n            M a b < M\\<^sub>R a b \\<longrightarrow> a = y \\<and> b = z;\n         M y z < M\\<^sub>R y z; distinct (0 # y # z # zs)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  set zs \\<union> {0, y, z} = set (i # ys)\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs) < Le 0\n  \\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n     M a b < M\\<^sub>R a b \\<longrightarrow> a = y \\<and> b = z\n  M y z < M\\<^sub>R y z\n  distinct (0 # y # z # zs)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  set zs \\<union> {0, y, z} = set (i # ys)\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs) < Le 0\n  \\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n     M a b < M\\<^sub>R a b \\<longrightarrow> a = y \\<and> b = z\n  M y z < M\\<^sub>R y z\n  distinct (0 # y # z # zs)", "have \"y \\<noteq> 0\" \"z \\<noteq> 0\""], ["proof (prove)\nusing this:\n  set zs \\<union> {0, y, z} = set (i # ys)\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs) < Le 0\n  \\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n     M a b < M\\<^sub>R a b \\<longrightarrow> a = y \\<and> b = z\n  M y z < M\\<^sub>R y z\n  distinct (0 # y # z # zs)\n\ngoal (1 subgoal):\n 1. y \\<noteq> 0 &&& z \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  y \\<noteq> 0\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "let ?r = \"len M\\<^sub>R z 0 zs\""], ["proof (state)\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "have \"\\<forall>(a, b)\\<in>set (arcs z 0 zs). ?M a b = M\\<^sub>R a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(a, b)\\<in>set (arcs z 0 zs).\n       min (M a b) (M\\<^sub>R a b) = M\\<^sub>R a b", "proof (safe, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (arcs z 0 zs) \\<Longrightarrow>\n       min (M a b) (M\\<^sub>R a b) = M\\<^sub>R a b", "case A: (1 a b)"], ["proof (state)\nthis:\n  (a, b) \\<in> set (arcs z 0 zs)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (arcs z 0 zs) \\<Longrightarrow>\n       min (M a b) (M\\<^sub>R a b) = M\\<^sub>R a b", "have \"M\\<^sub>R a b \\<le> M a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M\\<^sub>R a b \\<le> M a b", "proof (rule ccontr, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> M\\<^sub>R a b \\<le> M a b \\<Longrightarrow> False", "case 1"], ["proof (state)\nthis:\n  \\<not> M\\<^sub>R a b \\<le> M a b\n\ngoal (1 subgoal):\n 1. \\<not> M\\<^sub>R a b \\<le> M a b \\<Longrightarrow> False", "with *(3) A"], ["proof (chain)\npicking this:\n  \\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n     M a b < M\\<^sub>R a b \\<longrightarrow> a = y \\<and> b = z\n  (a, b) \\<in> set (arcs z 0 zs)\n  \\<not> M\\<^sub>R a b \\<le> M a b", "have \"a = y\" \"b = z\""], ["proof (prove)\nusing this:\n  \\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n     M a b < M\\<^sub>R a b \\<longrightarrow> a = y \\<and> b = z\n  (a, b) \\<in> set (arcs z 0 zs)\n  \\<not> M\\<^sub>R a b \\<le> M a b\n\ngoal (1 subgoal):\n 1. a = y &&& b = z", "by auto"], ["proof (state)\nthis:\n  a = y\n  b = z\n\ngoal (1 subgoal):\n 1. \\<not> M\\<^sub>R a b \\<le> M a b \\<Longrightarrow> False", "with A distinct' arcs_distinct3[OF _ A, of y]"], ["proof (chain)\npicking this:\n  (a, b) \\<in> set (arcs z 0 zs)\n  distinct (0 # y # z # zs)\n  distinct (z # 0 # y # zs) \\<Longrightarrow>\n  a \\<noteq> y \\<and> b \\<noteq> y\n  a = y\n  b = z", "show False"], ["proof (prove)\nusing this:\n  (a, b) \\<in> set (arcs z 0 zs)\n  distinct (0 # y # z # zs)\n  distinct (z # 0 # y # zs) \\<Longrightarrow>\n  a \\<noteq> y \\<and> b \\<noteq> y\n  a = y\n  b = z\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M\\<^sub>R a b \\<le> M a b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> set (arcs z 0 zs) \\<Longrightarrow>\n       min (M a b) (M\\<^sub>R a b) = M\\<^sub>R a b", "then"], ["proof (chain)\npicking this:\n  M\\<^sub>R a b \\<le> M a b", "show ?case"], ["proof (prove)\nusing this:\n  M\\<^sub>R a b \\<le> M a b\n\ngoal (1 subgoal):\n 1. min (M a b) (M\\<^sub>R a b) = M\\<^sub>R a b", "by (simp add: min_def)"], ["proof (state)\nthis:\n  min (M a b) (M\\<^sub>R a b) = M\\<^sub>R a b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>(a, b)\\<in>set (arcs z 0 zs).\n     min (M a b) (M\\<^sub>R a b) = M\\<^sub>R a b\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  \\<forall>(a, b)\\<in>set (arcs z 0 zs).\n     min (M a b) (M\\<^sub>R a b) = M\\<^sub>R a b", "have r: \"len ?M z 0 zs = ?r\""], ["proof (prove)\nusing this:\n  \\<forall>(a, b)\\<in>set (arcs z 0 zs).\n     min (M a b) (M\\<^sub>R a b) = M\\<^sub>R a b\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z 0 zs =\n    len M\\<^sub>R z 0 zs", "by (induction zs arbitrary: z) auto"], ["proof (state)\nthis:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z 0 zs =\n  len M\\<^sub>R z 0 zs\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with *(2)"], ["proof (chain)\npicking this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs) < Le 0\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z 0 zs =\n  len M\\<^sub>R z 0 zs", "have **: \"?M 0 y + (?M y z + ?r) < Le 0\""], ["proof (prove)\nusing this:\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) 0 0 (y # z # zs) < Le 0\n  len (\\<lambda>i j. min (M i j) (M\\<^sub>R i j)) z 0 zs =\n  len M\\<^sub>R z 0 zs\n\ngoal (1 subgoal):\n 1. min (M 0 y) (M\\<^sub>R 0 y) +\n    (min (M y z) (M\\<^sub>R y z) + len M\\<^sub>R z 0 zs)\n    < Le 0", "by simp"], ["proof (state)\nthis:\n  min (M 0 y) (M\\<^sub>R 0 y) +\n  (min (M y z) (M\\<^sub>R y z) + len M\\<^sub>R z 0 zs)\n  < Le 0\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from M\\<^sub>R(1) \\<open>R \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  R \\<noteq> {}", "obtain u where u: \"DBM_val_bounded v u M\\<^sub>R n\""], ["proof (prove)\nusing this:\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  R \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M\\<^sub>R \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  {u. Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n      (\\<forall>c.\n          v c \\<le> n \\<longrightarrow>\n          dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n          dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n      (\\<forall>c1 c2.\n          v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n          dbm_entry_val u (Some c1) (Some c2) (M\\<^sub>R (v c1) (v c2)))} =\n  R\n  R \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n        (\\<forall>c.\n            v c \\<le> n \\<longrightarrow>\n            dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n            dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n        (\\<forall>c1 c2.\n            v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n            dbm_entry_val u (Some c1) (Some c2)\n             (M\\<^sub>R (v c1) (v c2))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> M\\<^sub>R\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from *(1) \\<open>i \\<le> n\\<close> \\<open>set ys \\<subseteq> _\\<close>"], ["proof (chain)\npicking this:\n  set zs \\<union> {0, y, z} = set (i # ys)\n  i \\<le> n\n  set ys \\<subseteq> {0..n}", "have \"y \\<le> n\" \"z \\<le> n\""], ["proof (prove)\nusing this:\n  set zs \\<union> {0, y, z} = set (i # ys)\n  i \\<le> n\n  set ys \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. y \\<le> n &&& z \\<le> n", "by fastforce+"], ["proof (state)\nthis:\n  y \\<le> n\n  z \\<le> n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from *(1) ys(2,4)"], ["proof (chain)\npicking this:\n  set zs \\<union> {0, y, z} = set (i # ys)\n  set ys \\<subseteq> {0..n}\n  i \\<le> n", "have \"set zs \\<subseteq> {0 ..n}\""], ["proof (prove)\nusing this:\n  set zs \\<union> {0, y, z} = set (i # ys)\n  set ys \\<subseteq> {0..n}\n  i \\<le> n\n\ngoal (1 subgoal):\n 1. set zs \\<subseteq> {0..n}", "by auto"], ["proof (state)\nthis:\n  set zs \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from \\<open>y \\<le> n\\<close> \\<open>z \\<le> n\\<close> clock_numbering(2) \\<open>y \\<noteq> 0\\<close> \\<open>z \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  y \\<le> n\n  z \\<le> n\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  y \\<noteq> 0\n  z \\<noteq> 0", "obtain c1 c2 where C:\n            \"c1 \\<in> X\" \"c2 \\<in> X\" \"v c1 = y\" \"v c2 = z\""], ["proof (prove)\nusing this:\n  y \\<le> n\n  z \\<le> n\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  y \\<noteq> 0\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>c1 c2.\n        \\<lbrakk>c1 \\<in> X; c2 \\<in> X; v c1 = y; v c2 = z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast+"], ["proof (state)\nthis:\n  c1 \\<in> X\n  c2 \\<in> X\n  v c1 = y\n  v c2 = z\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with clock_numbering(1,3)"], ["proof (chain)\npicking this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>c\\<in>X. v c \\<le> n\n  c1 \\<in> X\n  c2 \\<in> X\n  v c1 = y\n  v c2 = z", "have C2: \"v' y = c1\" \"v' z = c2\""], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>c\\<in>X. v c \\<le> n\n  c1 \\<in> X\n  c2 \\<in> X\n  v c1 = y\n  v c2 = z\n\ngoal (1 subgoal):\n 1. v' y = c1 &&& v' z = c2", "unfolding v'_def"], ["proof (prove)\nusing this:\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>c\\<in>X. v c \\<le> n\n  c1 \\<in> X\n  c2 \\<in> X\n  v c1 = y\n  v c2 = z\n\ngoal (1 subgoal):\n 1. (THE c. c \\<in> X \\<and> v c = y) = c1 &&&\n    (THE c. c \\<in> X \\<and> v c = z) = c2", "by auto"], ["proof (state)\nthis:\n  v' y = c1\n  v' z = c2\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C"], ["proof (chain)\npicking this:\n  c1 \\<in> X\n  c2 \\<in> X\n  v c1 = y\n  v c2 = z\n  v' y = c1\n  v' z = c2", "have \"v (v' z) = z\""], ["proof (prove)\nusing this:\n  c1 \\<in> X\n  c2 \\<in> X\n  v c1 = y\n  v c2 = z\n  v' y = c1\n  v' z = c2\n\ngoal (1 subgoal):\n 1. v (v' z) = z", "by auto"], ["proof (state)\nthis:\n  v (v' z) = z\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with DBM_val_bounded_len'1[OF u, of zs \"v' z\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<notin> set zs; v (v' z) \\<le> n;\n   \\<forall>k\\<in>set zs.\n      0 < k \\<longrightarrow>\n      k \\<le> n \\<and> (\\<exists>c. v c = k)\\<rbrakk>\n  \\<Longrightarrow> dbm_entry_val u (Some (v' z)) None\n                     (len M\\<^sub>R (v (v' z)) 0 zs)\n  v (v' z) = z", "have \"dbm_entry_val u (Some (v' z)) None ?r\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<notin> set zs; v (v' z) \\<le> n;\n   \\<forall>k\\<in>set zs.\n      0 < k \\<longrightarrow>\n      k \\<le> n \\<and> (\\<exists>c. v c = k)\\<rbrakk>\n  \\<Longrightarrow> dbm_entry_val u (Some (v' z)) None\n                     (len M\\<^sub>R (v (v' z)) 0 zs)\n  v (v' z) = z\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some (v' z)) None (len M\\<^sub>R z 0 zs)", "using \\<open>z \\<le> n\\<close> clock_numbering(2) \\<open>set zs \\<subseteq> _\\<close> distinct'"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<notin> set zs; v (v' z) \\<le> n;\n   \\<forall>k\\<in>set zs.\n      0 < k \\<longrightarrow>\n      k \\<le> n \\<and> (\\<exists>c. v c = k)\\<rbrakk>\n  \\<Longrightarrow> dbm_entry_val u (Some (v' z)) None\n                     (len M\\<^sub>R (v (v' z)) 0 zs)\n  v (v' z) = z\n  z \\<le> n\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  set zs \\<subseteq> {0..n}\n  distinct (0 # y # z # zs)\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some (v' z)) None (len M\\<^sub>R z 0 zs)", "by force"], ["proof (state)\nthis:\n  dbm_entry_val u (Some (v' z)) None (len M\\<^sub>R z 0 zs)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from len_inf_elem **"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?a, ?b) \\<in> set (arcs ?i ?j ?xs);\n   ?M ?a ?b = \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> len ?M ?i ?j ?xs = \\<infinity>\n  min (M 0 y) (M\\<^sub>R 0 y) +\n  (min (M y z) (M\\<^sub>R y z) + len M\\<^sub>R z 0 zs)\n  < Le 0", "have tl_not_inf: \"\\<forall>(a, b)\\<in>set (arcs z 0 zs). M\\<^sub>R a b \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?a, ?b) \\<in> set (arcs ?i ?j ?xs);\n   ?M ?a ?b = \\<infinity>\\<rbrakk>\n  \\<Longrightarrow> len ?M ?i ?j ?xs = \\<infinity>\n  min (M 0 y) (M\\<^sub>R 0 y) +\n  (min (M y z) (M\\<^sub>R y z) + len M\\<^sub>R z 0 zs)\n  < Le 0\n\ngoal (1 subgoal):\n 1. \\<forall>(a, b)\\<in>set (arcs z 0 zs).\n       M\\<^sub>R a b \\<noteq> \\<infinity>", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>(a, b)\\<in>set (arcs z 0 zs). M\\<^sub>R a b \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with M\\<^sub>R(7) len_int_dbm_closed"], ["proof (chain)\npicking this:\n  \\<forall>i j.\n     M\\<^sub>R i j \\<noteq> \\<infinity> \\<longrightarrow>\n     get_const (M\\<^sub>R i j) \\<in> \\<int>\n  \\<forall>(i, j)\\<in>set (arcs ?i ?j ?xs).\n     get_const (?M i j) \\<in> \\<int> \\<and>\n     ?M i j \\<noteq> \\<infinity> \\<Longrightarrow>\n  get_const (len ?M ?i ?j ?xs) \\<in> \\<int> \\<and>\n  len ?M ?i ?j ?xs \\<noteq> \\<infinity>\n  \\<forall>(a, b)\\<in>set (arcs z 0 zs). M\\<^sub>R a b \\<noteq> \\<infinity>", "have \"get_const ?r \\<in> \\<int> \\<and> ?r \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     M\\<^sub>R i j \\<noteq> \\<infinity> \\<longrightarrow>\n     get_const (M\\<^sub>R i j) \\<in> \\<int>\n  \\<forall>(i, j)\\<in>set (arcs ?i ?j ?xs).\n     get_const (?M i j) \\<in> \\<int> \\<and>\n     ?M i j \\<noteq> \\<infinity> \\<Longrightarrow>\n  get_const (len ?M ?i ?j ?xs) \\<in> \\<int> \\<and>\n  len ?M ?i ?j ?xs \\<noteq> \\<infinity>\n  \\<forall>(a, b)\\<in>set (arcs z 0 zs). M\\<^sub>R a b \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. get_const (len M\\<^sub>R z 0 zs) \\<in> \\<int> \\<and>\n    len M\\<^sub>R z 0 zs \\<noteq> \\<infinity>", "by blast"], ["proof (state)\nthis:\n  get_const (len M\\<^sub>R z 0 zs) \\<in> \\<int> \\<and>\n  len M\\<^sub>R z 0 zs \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  get_const (len M\\<^sub>R z 0 zs) \\<in> \\<int> \\<and>\n  len M\\<^sub>R z 0 zs \\<noteq> \\<infinity>", "obtain r :: int where r': \"?r = Le r \\<or> ?r = Lt r\""], ["proof (prove)\nusing this:\n  get_const (len M\\<^sub>R z 0 zs) \\<in> \\<int> \\<and>\n  len M\\<^sub>R z 0 zs \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        len M\\<^sub>R z 0 zs = Le (real_of_int r) \\<or>\n        len M\\<^sub>R z 0 zs = Lt (real_of_int r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Ints_cases"], ["proof (prove)\nusing this:\n  get_const (len M\\<^sub>R z 0 zs) \\<in> \\<int> \\<and>\n  len M\\<^sub>R z 0 zs \\<noteq> \\<infinity>\n  \\<lbrakk>?q \\<in> \\<int>;\n   \\<And>z. ?q = of_int z \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        len M\\<^sub>R z 0 zs = Le (real_of_int r) \\<or>\n        len M\\<^sub>R z 0 zs = Lt (real_of_int r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?r) auto"], ["proof (state)\nthis:\n  len M\\<^sub>R z 0 zs = Le (real_of_int r) \\<or>\n  len M\\<^sub>R z 0 zs = Lt (real_of_int r)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from r' \\<open>dbm_entry_val _ _ _ _\\<close> C C2"], ["proof (chain)\npicking this:\n  len M\\<^sub>R z 0 zs = Le (real_of_int r) \\<or>\n  len M\\<^sub>R z 0 zs = Lt (real_of_int r)\n  dbm_entry_val u (Some (v' z)) None (len M\\<^sub>R z 0 zs)\n  c1 \\<in> X\n  c2 \\<in> X\n  v c1 = y\n  v c2 = z\n  v' y = c1\n  v' z = c2", "have le: \"u (v' z) \\<le> r\""], ["proof (prove)\nusing this:\n  len M\\<^sub>R z 0 zs = Le (real_of_int r) \\<or>\n  len M\\<^sub>R z 0 zs = Lt (real_of_int r)\n  dbm_entry_val u (Some (v' z)) None (len M\\<^sub>R z 0 zs)\n  c1 \\<in> X\n  c2 \\<in> X\n  v c1 = y\n  v c2 = z\n  v' y = c1\n  v' z = c2\n\ngoal (1 subgoal):\n 1. u (v' z) \\<le> real_of_int r", "by fastforce"], ["proof (state)\nthis:\n  u (v' z) \\<le> real_of_int r\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from arcs_ex_head"], ["proof (chain)\npicking this:\n  \\<exists>b. (?i, b) \\<in> set (arcs ?i ?j ?xs)", "obtain z' where \"(z, z') \\<in> set (arcs z 0 zs)\""], ["proof (prove)\nusing this:\n  \\<exists>b. (?i, b) \\<in> set (arcs ?i ?j ?xs)\n\ngoal (1 subgoal):\n 1. (\\<And>z'.\n        (z, z') \\<in> set (arcs z 0 zs) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (z, z') \\<in> set (arcs z 0 zs)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  (z, z') \\<in> set (arcs z 0 zs)", "have z':\n            \"(z, z') \\<in> set (arcs 0 0 (y # z # zs))\" \"(z, z') \\<in> set (arcs z 0 zs)\""], ["proof (prove)\nusing this:\n  (z, z') \\<in> set (arcs z 0 zs)\n\ngoal (1 subgoal):\n 1. (z, z') \\<in> set (arcs 0 0 (y # z # zs)) &&&\n    (z, z') \\<in> set (arcs z 0 zs)", "by auto"], ["proof (state)\nthis:\n  (z, z') \\<in> set (arcs 0 0 (y # z # zs))\n  (z, z') \\<in> set (arcs z 0 zs)\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "have \"M\\<^sub>R z 0 \\<noteq> \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M\\<^sub>R z 0 \\<noteq> \\<infinity>", "proof (rule ccontr, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> M\\<^sub>R z 0 \\<noteq> \\<infinity> \\<Longrightarrow> False", "case 1"], ["proof (state)\nthis:\n  \\<not> M\\<^sub>R z 0 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<not> M\\<^sub>R z 0 \\<noteq> \\<infinity> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> M\\<^sub>R z 0 \\<noteq> \\<infinity>", "have inf: \"M\\<^sub>R z 0 = \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<not> M\\<^sub>R z 0 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. M\\<^sub>R z 0 = \\<infinity>", "by auto"], ["proof (state)\nthis:\n  M\\<^sub>R z 0 = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<not> M\\<^sub>R z 0 \\<noteq> \\<infinity> \\<Longrightarrow> False", "have \"M\\<^sub>R z z' = \\<infinity>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M\\<^sub>R z z' = \\<infinity>", "proof (cases \"z' = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. z' = 0 \\<Longrightarrow> M\\<^sub>R z z' = \\<infinity>\n 2. z' \\<noteq> 0 \\<Longrightarrow> M\\<^sub>R z z' = \\<infinity>", "case True"], ["proof (state)\nthis:\n  z' = 0\n\ngoal (2 subgoals):\n 1. z' = 0 \\<Longrightarrow> M\\<^sub>R z z' = \\<infinity>\n 2. z' \\<noteq> 0 \\<Longrightarrow> M\\<^sub>R z z' = \\<infinity>", "with 1"], ["proof (chain)\npicking this:\n  \\<not> M\\<^sub>R z 0 \\<noteq> \\<infinity>\n  z' = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> M\\<^sub>R z 0 \\<noteq> \\<infinity>\n  z' = 0\n\ngoal (1 subgoal):\n 1. M\\<^sub>R z z' = \\<infinity>", "by auto"], ["proof (state)\nthis:\n  M\\<^sub>R z z' = \\<infinity>\n\ngoal (1 subgoal):\n 1. z' \\<noteq> 0 \\<Longrightarrow> M\\<^sub>R z z' = \\<infinity>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. z' \\<noteq> 0 \\<Longrightarrow> M\\<^sub>R z z' = \\<infinity>", "case False"], ["proof (state)\nthis:\n  z' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. z' \\<noteq> 0 \\<Longrightarrow> M\\<^sub>R z z' = \\<infinity>", "from arcs_elem[OF z'(1)] *(1) \\<open>i \\<le> n\\<close> \\<open>set ys \\<subseteq> _\\<close>"], ["proof (chain)\npicking this:\n  z \\<in> set (0 # y # z # zs)\n  z' \\<in> set (0 # y # z # zs)\n  set zs \\<union> {0, y, z} = set (i # ys)\n  i \\<le> n\n  set ys \\<subseteq> {0..n}", "have \"z' \\<le> n\""], ["proof (prove)\nusing this:\n  z \\<in> set (0 # y # z # zs)\n  z' \\<in> set (0 # y # z # zs)\n  set zs \\<union> {0, y, z} = set (i # ys)\n  i \\<le> n\n  set ys \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. z' \\<le> n", "by fastforce"], ["proof (state)\nthis:\n  z' \\<le> n\n\ngoal (1 subgoal):\n 1. z' \\<noteq> 0 \\<Longrightarrow> M\\<^sub>R z z' = \\<infinity>", "moreover"], ["proof (state)\nthis:\n  z' \\<le> n\n\ngoal (1 subgoal):\n 1. z' \\<noteq> 0 \\<Longrightarrow> M\\<^sub>R z z' = \\<infinity>", "from distinct' *(1) arcs_distinct1[OF _ _ _ _ z'(1)]"], ["proof (chain)\npicking this:\n  distinct (0 # y # z # zs)\n  set zs \\<union> {0, y, z} = set (i # ys)\n  \\<lbrakk>0 \\<notin> set (y # z # zs); 0 \\<notin> set (y # z # zs);\n   distinct (y # z # zs); y # z # zs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> z \\<noteq> z'", "have \"z \\<noteq> z'\""], ["proof (prove)\nusing this:\n  distinct (0 # y # z # zs)\n  set zs \\<union> {0, y, z} = set (i # ys)\n  \\<lbrakk>0 \\<notin> set (y # z # zs); 0 \\<notin> set (y # z # zs);\n   distinct (y # z # zs); y # z # zs \\<noteq> []\\<rbrakk>\n  \\<Longrightarrow> z \\<noteq> z'\n\ngoal (1 subgoal):\n 1. z \\<noteq> z'", "by auto"], ["proof (state)\nthis:\n  z \\<noteq> z'\n\ngoal (1 subgoal):\n 1. z' \\<noteq> 0 \\<Longrightarrow> M\\<^sub>R z z' = \\<infinity>", "ultimately"], ["proof (chain)\npicking this:\n  z' \\<le> n\n  z \\<noteq> z'", "show ?thesis"], ["proof (prove)\nusing this:\n  z' \\<le> n\n  z \\<noteq> z'\n\ngoal (1 subgoal):\n 1. M\\<^sub>R z z' = \\<infinity>", "using M\\<^sub>R(2) \\<open>z \\<le> n\\<close> False inf"], ["proof (prove)\nusing this:\n  z' \\<le> n\n  z \\<noteq> z'\n  \\<forall>i\\<le>n.\n     \\<forall>j\\<le>n.\n        M\\<^sub>R i 0 = \\<infinity> \\<and>\n        0 < j \\<and> i \\<noteq> j \\<longrightarrow>\n        M\\<^sub>R i j = \\<infinity> \\<and> M\\<^sub>R j i = \\<infinity>\n  z \\<le> n\n  z' \\<noteq> 0\n  M\\<^sub>R z 0 = \\<infinity>\n\ngoal (1 subgoal):\n 1. M\\<^sub>R z z' = \\<infinity>", "by blast"], ["proof (state)\nthis:\n  M\\<^sub>R z z' = \\<infinity>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M\\<^sub>R z z' = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<not> M\\<^sub>R z 0 \\<noteq> \\<infinity> \\<Longrightarrow> False", "with tl_not_inf z'(2)"], ["proof (chain)\npicking this:\n  \\<forall>(a, b)\\<in>set (arcs z 0 zs). M\\<^sub>R a b \\<noteq> \\<infinity>\n  (z, z') \\<in> set (arcs z 0 zs)\n  M\\<^sub>R z z' = \\<infinity>", "show False"], ["proof (prove)\nusing this:\n  \\<forall>(a, b)\\<in>set (arcs z 0 zs). M\\<^sub>R a b \\<noteq> \\<infinity>\n  (z, z') \\<in> set (arcs z 0 zs)\n  M\\<^sub>R z z' = \\<infinity>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M\\<^sub>R z 0 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with M\\<^sub>R(5) \\<open>z \\<noteq> 0\\<close> \\<open>z \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>n.\n     0 < i \\<and> M\\<^sub>R i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n     (\\<exists>d\\<le>int (k (THE c. c \\<in> X \\<and> v c = i)).\n         0 \\<le> d \\<and>\n         (M\\<^sub>R i 0 = Le (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Le (real_of_int (- d)) \\<or>\n          M\\<^sub>R i 0 = Lt (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Lt (real_of_int (- d + 1))))\n  z \\<noteq> 0\n  z \\<le> n\n  M\\<^sub>R z 0 \\<noteq> \\<infinity>", "obtain d :: int where d:\n            \"M\\<^sub>R z 0 = Le d \\<and> M\\<^sub>R 0 z = Le (-d) \\<or> M\\<^sub>R z 0 = Lt d \\<and> M\\<^sub>R 0 z = Lt (-d + 1)\"\n            \"d \\<le> k (v' z)\" \"0 \\<le> d\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n.\n     0 < i \\<and> M\\<^sub>R i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n     (\\<exists>d\\<le>int (k (THE c. c \\<in> X \\<and> v c = i)).\n         0 \\<le> d \\<and>\n         (M\\<^sub>R i 0 = Le (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Le (real_of_int (- d)) \\<or>\n          M\\<^sub>R i 0 = Lt (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Lt (real_of_int (- d + 1))))\n  z \\<noteq> 0\n  z \\<le> n\n  M\\<^sub>R z 0 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n                 M\\<^sub>R 0 z = Le (real_of_int (- d)) \\<or>\n                 M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n                 M\\<^sub>R 0 z = Lt (real_of_int (- d + 1));\n         d \\<le> int (k (v' z)); 0 \\<le> d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding v'_def"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n.\n     0 < i \\<and> M\\<^sub>R i 0 \\<noteq> \\<infinity> \\<longrightarrow>\n     (\\<exists>d\\<le>int (k (THE c. c \\<in> X \\<and> v c = i)).\n         0 \\<le> d \\<and>\n         (M\\<^sub>R i 0 = Le (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Le (real_of_int (- d)) \\<or>\n          M\\<^sub>R i 0 = Lt (real_of_int d) \\<and>\n          M\\<^sub>R 0 i = Lt (real_of_int (- d + 1))))\n  z \\<noteq> 0\n  z \\<le> n\n  M\\<^sub>R z 0 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n                 M\\<^sub>R 0 z = Le (real_of_int (- d)) \\<or>\n                 M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n                 M\\<^sub>R 0 z = Lt (real_of_int (- d + 1));\n         d \\<le> int (k (THE c. c \\<in> X \\<and> v c = z));\n         0 \\<le> d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Le (real_of_int (- d)) \\<or>\n  M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Lt (real_of_int (- d + 1))\n  d \\<le> int (k (v' z))\n  0 \\<le> d\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "text \\<open>Needs property that len of integral dbm entries is integral and definition of \\<open>M_R\\<close>\\<close>"], ["proof (state)\nthis:\n  M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Le (real_of_int (- d)) \\<or>\n  M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Lt (real_of_int (- d + 1))\n  d \\<le> int (k (v' z))\n  0 \\<le> d\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from this (1)"], ["proof (chain)\npicking this:\n  M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Le (real_of_int (- d)) \\<or>\n  M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Lt (real_of_int (- d + 1))", "have rr: \"?r \\<ge> M\\<^sub>R z 0\""], ["proof (prove)\nusing this:\n  M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Le (real_of_int (- d)) \\<or>\n  M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 z = Le (real_of_int (- d)) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs\n 2. M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 z = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "case A: 1"], ["proof (state)\nthis:\n  M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Le (real_of_int (- d))\n\ngoal (2 subgoals):\n 1. M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 z = Le (real_of_int (- d)) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs\n 2. M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 z = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "with u \\<open>z \\<le> n\\<close> C C2"], ["proof (chain)\npicking this:\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> M\\<^sub>R\n  z \\<le> n\n  c1 \\<in> X\n  c2 \\<in> X\n  v c1 = y\n  v c2 = z\n  v' y = c1\n  v' z = c2\n  M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Le (real_of_int (- d))", "have *: \"- u (v' z) \\<le> -d\""], ["proof (prove)\nusing this:\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> M\\<^sub>R\n  z \\<le> n\n  c1 \\<in> X\n  c2 \\<in> X\n  v c1 = y\n  v c2 = z\n  v' y = c1\n  v' z = c2\n  M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Le (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. - u (v' z) \\<le> real_of_int (- d)", "unfolding DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n  (\\<forall>c.\n      v c \\<le> n \\<longrightarrow>\n      dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n      dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n  (\\<forall>c1 c2.\n      v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n      dbm_entry_val u (Some c1) (Some c2) (M\\<^sub>R (v c1) (v c2)))\n  z \\<le> n\n  c1 \\<in> X\n  c2 \\<in> X\n  v c1 = y\n  v c2 = z\n  v' y = c1\n  v' z = c2\n  M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Le (real_of_int (- d))\n\ngoal (1 subgoal):\n 1. - u (v' z) \\<le> real_of_int (- d)", "by fastforce"], ["proof (state)\nthis:\n  - u (v' z) \\<le> real_of_int (- d)\n\ngoal (2 subgoals):\n 1. M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n    M\\<^sub>R 0 z = Le (real_of_int (- d)) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs\n 2. M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 z = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "from r'"], ["proof (chain)\npicking this:\n  len M\\<^sub>R z 0 zs = Le (real_of_int r) \\<or>\n  len M\\<^sub>R z 0 zs = Lt (real_of_int r)", "show ?case"], ["proof (prove)\nusing this:\n  len M\\<^sub>R z 0 zs = Le (real_of_int r) \\<or>\n  len M\\<^sub>R z 0 zs = Lt (real_of_int r)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. len M\\<^sub>R z 0 zs = Le (real_of_int r) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs\n 2. len M\\<^sub>R z 0 zs = Lt (real_of_int r) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "case 1"], ["proof (state)\nthis:\n  len M\\<^sub>R z 0 zs = Le (real_of_int r)\n\ngoal (2 subgoals):\n 1. len M\\<^sub>R z 0 zs = Le (real_of_int r) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs\n 2. len M\\<^sub>R z 0 zs = Lt (real_of_int r) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "with le * A"], ["proof (chain)\npicking this:\n  u (v' z) \\<le> real_of_int r\n  - u (v' z) \\<le> real_of_int (- d)\n  M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Le (real_of_int (- d))\n  len M\\<^sub>R z 0 zs = Le (real_of_int r)", "show ?case"], ["proof (prove)\nusing this:\n  u (v' z) \\<le> real_of_int r\n  - u (v' z) \\<le> real_of_int (- d)\n  M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Le (real_of_int (- d))\n  len M\\<^sub>R z 0 zs = Le (real_of_int r)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "unfolding less_eq dbm_le_def"], ["proof (prove)\nusing this:\n  u (v' z) \\<le> real_of_int r\n  - u (v' z) \\<le> real_of_int (- d)\n  M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Le (real_of_int (- d))\n  len M\\<^sub>R z 0 zs = Le (real_of_int r)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R z 0 \\<prec> len M\\<^sub>R z 0 zs \\<or>\n    M\\<^sub>R z 0 = len M\\<^sub>R z 0 zs", "by fastforce"], ["proof (state)\nthis:\n  M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs\n\ngoal (1 subgoal):\n 1. len M\\<^sub>R z 0 zs = Lt (real_of_int r) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. len M\\<^sub>R z 0 zs = Lt (real_of_int r) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "case 2"], ["proof (state)\nthis:\n  len M\\<^sub>R z 0 zs = Lt (real_of_int r)\n\ngoal (1 subgoal):\n 1. len M\\<^sub>R z 0 zs = Lt (real_of_int r) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "with \\<open>dbm_entry_val _ _ _ _\\<close> C C2"], ["proof (chain)\npicking this:\n  dbm_entry_val u (Some (v' z)) None (len M\\<^sub>R z 0 zs)\n  c1 \\<in> X\n  c2 \\<in> X\n  v c1 = y\n  v c2 = z\n  v' y = c1\n  v' z = c2\n  len M\\<^sub>R z 0 zs = Lt (real_of_int r)", "have \"u (v' z) < r\""], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some (v' z)) None (len M\\<^sub>R z 0 zs)\n  c1 \\<in> X\n  c2 \\<in> X\n  v c1 = y\n  v c2 = z\n  v' y = c1\n  v' z = c2\n  len M\\<^sub>R z 0 zs = Lt (real_of_int r)\n\ngoal (1 subgoal):\n 1. u (v' z) < real_of_int r", "by fastforce"], ["proof (state)\nthis:\n  u (v' z) < real_of_int r\n\ngoal (1 subgoal):\n 1. len M\\<^sub>R z 0 zs = Lt (real_of_int r) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "with *"], ["proof (chain)\npicking this:\n  - u (v' z) \\<le> real_of_int (- d)\n  u (v' z) < real_of_int r", "have \"r > d\""], ["proof (prove)\nusing this:\n  - u (v' z) \\<le> real_of_int (- d)\n  u (v' z) < real_of_int r\n\ngoal (1 subgoal):\n 1. d < r", "by auto"], ["proof (state)\nthis:\n  d < r\n\ngoal (1 subgoal):\n 1. len M\\<^sub>R z 0 zs = Lt (real_of_int r) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "with A 2"], ["proof (chain)\npicking this:\n  M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Le (real_of_int (- d))\n  len M\\<^sub>R z 0 zs = Lt (real_of_int r)\n  d < r", "show ?case"], ["proof (prove)\nusing this:\n  M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Le (real_of_int (- d))\n  len M\\<^sub>R z 0 zs = Lt (real_of_int r)\n  d < r\n\ngoal (1 subgoal):\n 1. M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "unfolding less_eq dbm_le_def"], ["proof (prove)\nusing this:\n  M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Le (real_of_int (- d))\n  len M\\<^sub>R z 0 zs = Lt (real_of_int r)\n  d < r\n\ngoal (1 subgoal):\n 1. M\\<^sub>R z 0 \\<prec> len M\\<^sub>R z 0 zs \\<or>\n    M\\<^sub>R z 0 = len M\\<^sub>R z 0 zs", "by fastforce"], ["proof (state)\nthis:\n  M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs\n\ngoal (1 subgoal):\n 1. M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 z = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 z = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "case A: 2"], ["proof (state)\nthis:\n  M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 z = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "with u \\<open>z \\<le> n\\<close> C C2"], ["proof (chain)\npicking this:\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> M\\<^sub>R\n  z \\<le> n\n  c1 \\<in> X\n  c2 \\<in> X\n  v c1 = y\n  v c2 = z\n  v' y = c1\n  v' z = c2\n  M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Lt (real_of_int (- d + 1))", "have *: \"- u (v' z) < -d + 1\""], ["proof (prove)\nusing this:\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> M\\<^sub>R\n  z \\<le> n\n  c1 \\<in> X\n  c2 \\<in> X\n  v c1 = y\n  v c2 = z\n  v' y = c1\n  v' z = c2\n  M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. - u (v' z) < real_of_int (- d + 1)", "unfolding DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n  (\\<forall>c.\n      v c \\<le> n \\<longrightarrow>\n      dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n      dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n  (\\<forall>c1 c2.\n      v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n      dbm_entry_val u (Some c1) (Some c2) (M\\<^sub>R (v c1) (v c2)))\n  z \\<le> n\n  c1 \\<in> X\n  c2 \\<in> X\n  v c1 = y\n  v c2 = z\n  v' y = c1\n  v' z = c2\n  M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Lt (real_of_int (- d + 1))\n\ngoal (1 subgoal):\n 1. - u (v' z) < real_of_int (- d + 1)", "by fastforce"], ["proof (state)\nthis:\n  - u (v' z) < real_of_int (- d + 1)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n    M\\<^sub>R 0 z = Lt (real_of_int (- d + 1)) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "from r'"], ["proof (chain)\npicking this:\n  len M\\<^sub>R z 0 zs = Le (real_of_int r) \\<or>\n  len M\\<^sub>R z 0 zs = Lt (real_of_int r)", "show ?case"], ["proof (prove)\nusing this:\n  len M\\<^sub>R z 0 zs = Le (real_of_int r) \\<or>\n  len M\\<^sub>R z 0 zs = Lt (real_of_int r)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. len M\\<^sub>R z 0 zs = Le (real_of_int r) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs\n 2. len M\\<^sub>R z 0 zs = Lt (real_of_int r) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "case 1"], ["proof (state)\nthis:\n  len M\\<^sub>R z 0 zs = Le (real_of_int r)\n\ngoal (2 subgoals):\n 1. len M\\<^sub>R z 0 zs = Le (real_of_int r) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs\n 2. len M\\<^sub>R z 0 zs = Lt (real_of_int r) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "with le * A"], ["proof (chain)\npicking this:\n  u (v' z) \\<le> real_of_int r\n  - u (v' z) < real_of_int (- d + 1)\n  M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Lt (real_of_int (- d + 1))\n  len M\\<^sub>R z 0 zs = Le (real_of_int r)", "show ?case"], ["proof (prove)\nusing this:\n  u (v' z) \\<le> real_of_int r\n  - u (v' z) < real_of_int (- d + 1)\n  M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Lt (real_of_int (- d + 1))\n  len M\\<^sub>R z 0 zs = Le (real_of_int r)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "unfolding less_eq dbm_le_def"], ["proof (prove)\nusing this:\n  u (v' z) \\<le> real_of_int r\n  - u (v' z) < real_of_int (- d + 1)\n  M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Lt (real_of_int (- d + 1))\n  len M\\<^sub>R z 0 zs = Le (real_of_int r)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R z 0 \\<prec> len M\\<^sub>R z 0 zs \\<or>\n    M\\<^sub>R z 0 = len M\\<^sub>R z 0 zs", "by fastforce"], ["proof (state)\nthis:\n  M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs\n\ngoal (1 subgoal):\n 1. len M\\<^sub>R z 0 zs = Lt (real_of_int r) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. len M\\<^sub>R z 0 zs = Lt (real_of_int r) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "case 2"], ["proof (state)\nthis:\n  len M\\<^sub>R z 0 zs = Lt (real_of_int r)\n\ngoal (1 subgoal):\n 1. len M\\<^sub>R z 0 zs = Lt (real_of_int r) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "with \\<open>dbm_entry_val _ _ _ _\\<close> C C2"], ["proof (chain)\npicking this:\n  dbm_entry_val u (Some (v' z)) None (len M\\<^sub>R z 0 zs)\n  c1 \\<in> X\n  c2 \\<in> X\n  v c1 = y\n  v c2 = z\n  v' y = c1\n  v' z = c2\n  len M\\<^sub>R z 0 zs = Lt (real_of_int r)", "have \"u (v' z) \\<le> r\""], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some (v' z)) None (len M\\<^sub>R z 0 zs)\n  c1 \\<in> X\n  c2 \\<in> X\n  v c1 = y\n  v c2 = z\n  v' y = c1\n  v' z = c2\n  len M\\<^sub>R z 0 zs = Lt (real_of_int r)\n\ngoal (1 subgoal):\n 1. u (v' z) \\<le> real_of_int r", "by fastforce"], ["proof (state)\nthis:\n  u (v' z) \\<le> real_of_int r\n\ngoal (1 subgoal):\n 1. len M\\<^sub>R z 0 zs = Lt (real_of_int r) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "with *"], ["proof (chain)\npicking this:\n  - u (v' z) < real_of_int (- d + 1)\n  u (v' z) \\<le> real_of_int r", "have \"r \\<ge> d\""], ["proof (prove)\nusing this:\n  - u (v' z) < real_of_int (- d + 1)\n  u (v' z) \\<le> real_of_int r\n\ngoal (1 subgoal):\n 1. d \\<le> r", "by auto"], ["proof (state)\nthis:\n  d \\<le> r\n\ngoal (1 subgoal):\n 1. len M\\<^sub>R z 0 zs = Lt (real_of_int r) \\<Longrightarrow>\n    M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "with A 2"], ["proof (chain)\npicking this:\n  M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Lt (real_of_int (- d + 1))\n  len M\\<^sub>R z 0 zs = Lt (real_of_int r)\n  d \\<le> r", "show ?case"], ["proof (prove)\nusing this:\n  M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Lt (real_of_int (- d + 1))\n  len M\\<^sub>R z 0 zs = Lt (real_of_int r)\n  d \\<le> r\n\ngoal (1 subgoal):\n 1. M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "unfolding less_eq dbm_le_def"], ["proof (prove)\nusing this:\n  M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Lt (real_of_int (- d + 1))\n  len M\\<^sub>R z 0 zs = Lt (real_of_int r)\n  d \\<le> r\n\ngoal (1 subgoal):\n 1. M\\<^sub>R z 0 \\<prec> len M\\<^sub>R z 0 zs \\<or>\n    M\\<^sub>R z 0 = len M\\<^sub>R z 0 zs", "by fastforce"], ["proof (state)\nthis:\n  M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with *(3) \\<open>y \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n     M a b < M\\<^sub>R a b \\<longrightarrow> a = y \\<and> b = z\n  y \\<noteq> 0\n  M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs", "have \"M 0 y \\<ge> M\\<^sub>R 0 y\""], ["proof (prove)\nusing this:\n  \\<forall>(a, b)\\<in>set (arcs 0 0 (y # z # zs)).\n     M a b < M\\<^sub>R a b \\<longrightarrow> a = y \\<and> b = z\n  y \\<noteq> 0\n  M\\<^sub>R z 0 \\<le> len M\\<^sub>R z 0 zs\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y \\<le> M 0 y", "by fastforce"], ["proof (state)\nthis:\n  M\\<^sub>R 0 y \\<le> M 0 y\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  M\\<^sub>R 0 y \\<le> M 0 y", "have \"?M 0 y = M\\<^sub>R 0 y\""], ["proof (prove)\nusing this:\n  M\\<^sub>R 0 y \\<le> M 0 y\n\ngoal (1 subgoal):\n 1. min (M 0 y) (M\\<^sub>R 0 y) = M\\<^sub>R 0 y", "by (simp add: min.absorb2)"], ["proof (state)\nthis:\n  min (M 0 y) (M\\<^sub>R 0 y) = M\\<^sub>R 0 y\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  min (M 0 y) (M\\<^sub>R 0 y) = M\\<^sub>R 0 y\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from *(4)"], ["proof (chain)\npicking this:\n  M y z < M\\<^sub>R y z", "have \"?M y z = M y z\""], ["proof (prove)\nusing this:\n  M y z < M\\<^sub>R y z\n\ngoal (1 subgoal):\n 1. min (M y z) (M\\<^sub>R y z) = M y z", "unfolding min_def"], ["proof (prove)\nusing this:\n  M y z < M\\<^sub>R y z\n\ngoal (1 subgoal):\n 1. (if M y z \\<le> M\\<^sub>R y z then M y z else M\\<^sub>R y z) = M y z", "by auto"], ["proof (state)\nthis:\n  min (M y z) (M\\<^sub>R y z) = M y z\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  min (M 0 y) (M\\<^sub>R 0 y) = M\\<^sub>R 0 y\n  min (M y z) (M\\<^sub>R y z) = M y z", "have **: \"M\\<^sub>R 0 y + (M y z + M\\<^sub>R z 0) < Le 0\""], ["proof (prove)\nusing this:\n  min (M 0 y) (M\\<^sub>R 0 y) = M\\<^sub>R 0 y\n  min (M y z) (M\\<^sub>R y z) = M y z\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + (M y z + M\\<^sub>R z 0) < Le 0", "using ** add_mono_right[OF add_mono_right[OF rr], of \"M\\<^sub>R 0 y\" \"M y z\"]"], ["proof (prove)\nusing this:\n  min (M 0 y) (M\\<^sub>R 0 y) = M\\<^sub>R 0 y\n  min (M y z) (M\\<^sub>R y z) = M y z\n  min (M 0 y) (M\\<^sub>R 0 y) +\n  (min (M y z) (M\\<^sub>R y z) + len M\\<^sub>R z 0 zs)\n  < Le 0\n  M\\<^sub>R 0 y + (M y z + M\\<^sub>R z 0)\n  \\<le> M\\<^sub>R 0 y + (M y z + len M\\<^sub>R z 0 zs)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + (M y z + M\\<^sub>R z 0) < Le 0", "by simp"], ["proof (state)\nthis:\n  M\\<^sub>R 0 y + (M y z + M\\<^sub>R z 0) < Le 0\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from **"], ["proof (chain)\npicking this:\n  M\\<^sub>R 0 y + (M y z + M\\<^sub>R z 0) < Le 0", "have not_inf: \"M\\<^sub>R 0 y \\<noteq> \\<infinity>\" \"M y z \\<noteq> \\<infinity>\" \"M\\<^sub>R z 0 \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  M\\<^sub>R 0 y + (M y z + M\\<^sub>R z 0) < Le 0\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y \\<noteq> \\<infinity> &&&\n    M y z \\<noteq> \\<infinity> &&& M\\<^sub>R z 0 \\<noteq> \\<infinity>", "by auto"], ["proof (state)\nthis:\n  M\\<^sub>R 0 y \\<noteq> \\<infinity>\n  M y z \\<noteq> \\<infinity>\n  M\\<^sub>R z 0 \\<noteq> \\<infinity>\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from M\\<^sub>R(6) \\<open>y \\<noteq> 0\\<close> \\<open>y \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>n.\n     0 < i \\<longrightarrow>\n     (\\<exists>d\\<ge>- int (k (THE c. c \\<in> X \\<and> v c = i)).\n         d \\<le> 0 \\<and>\n         (M\\<^sub>R 0 i = Le (real_of_int d) \\<or>\n          M\\<^sub>R 0 i = Lt (real_of_int d)))\n  y \\<noteq> 0\n  y \\<le> n", "obtain c :: int where c:\n            \"M\\<^sub>R 0 y = Le c \\<or> M\\<^sub>R 0 y = Lt c\" \"- k (v' y) \\<le> c\" \"c \\<le> 0\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n.\n     0 < i \\<longrightarrow>\n     (\\<exists>d\\<ge>- int (k (THE c. c \\<in> X \\<and> v c = i)).\n         d \\<le> 0 \\<and>\n         (M\\<^sub>R 0 i = Le (real_of_int d) \\<or>\n          M\\<^sub>R 0 i = Lt (real_of_int d)))\n  y \\<noteq> 0\n  y \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>M\\<^sub>R 0 y = Le (real_of_int c) \\<or>\n                 M\\<^sub>R 0 y = Lt (real_of_int c);\n         - int (k (v' y)) \\<le> c; c \\<le> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding v'_def"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n.\n     0 < i \\<longrightarrow>\n     (\\<exists>d\\<ge>- int (k (THE c. c \\<in> X \\<and> v c = i)).\n         d \\<le> 0 \\<and>\n         (M\\<^sub>R 0 i = Le (real_of_int d) \\<or>\n          M\\<^sub>R 0 i = Lt (real_of_int d)))\n  y \\<noteq> 0\n  y \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>M\\<^sub>R 0 y = Le (real_of_int c) \\<or>\n                 M\\<^sub>R 0 y = Lt (real_of_int c);\n         - int (k (THE c. c \\<in> X \\<and> v c = y)) \\<le> c;\n         c \\<le> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  M\\<^sub>R 0 y = Le (real_of_int c) \\<or>\n  M\\<^sub>R 0 y = Lt (real_of_int c)\n  - int (k (v' y)) \\<le> c\n  c \\<le> 0\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "have ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "proof (cases \"M\\<^sub>R 0 y + M\\<^sub>R z 0 = Lt (c + d)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 =\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case True"], ["proof (state)\nthis:\n  M\\<^sub>R 0 y + M\\<^sub>R z 0 = Lt (real_of_int (c + d))\n\ngoal (2 subgoals):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 =\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from **"], ["proof (chain)\npicking this:\n  M\\<^sub>R 0 y + (M y z + M\\<^sub>R z 0) < Le 0", "have \"(M\\<^sub>R 0 y + M\\<^sub>R z 0) + M y z < Le 0\""], ["proof (prove)\nusing this:\n  M\\<^sub>R 0 y + (M y z + M\\<^sub>R z 0) < Le 0\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 + M y z < Le 0", "using comm assoc"], ["proof (prove)\nusing this:\n  M\\<^sub>R 0 y + (M y z + M\\<^sub>R z 0) < Le 0\n  ?a + ?b = ?b + ?a\n  ?a + ?b + ?c = ?a + (?b + ?c)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 + M y z < Le 0", "by metis"], ["proof (state)\nthis:\n  M\\<^sub>R 0 y + M\\<^sub>R z 0 + M y z < Le 0\n\ngoal (2 subgoals):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 =\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with True"], ["proof (chain)\npicking this:\n  M\\<^sub>R 0 y + M\\<^sub>R z 0 = Lt (real_of_int (c + d))\n  M\\<^sub>R 0 y + M\\<^sub>R z 0 + M y z < Le 0", "have **: \"Lt (c + d) + M y z < Le 0\""], ["proof (prove)\nusing this:\n  M\\<^sub>R 0 y + M\\<^sub>R z 0 = Lt (real_of_int (c + d))\n  M\\<^sub>R 0 y + M\\<^sub>R z 0 + M y z < Le 0\n\ngoal (1 subgoal):\n 1. Lt (real_of_int (c + d)) + M y z < Le 0", "by simp"], ["proof (state)\nthis:\n  Lt (real_of_int (c + d)) + M y z < Le 0\n\ngoal (2 subgoals):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 =\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  Lt (real_of_int (c + d)) + M y z < Le 0", "have \"M y z \\<le> Le (- (c + d))\""], ["proof (prove)\nusing this:\n  Lt (real_of_int (c + d)) + M y z < Le 0\n\ngoal (1 subgoal):\n 1. M y z \\<le> Le (real_of_int (- (c + d)))", "unfolding less less_eq dbm_le_def mult"], ["proof (prove)\nusing this:\n  dbm_add (Lt (real_of_int (c + d))) (M y z) \\<prec> Le 0\n\ngoal (1 subgoal):\n 1. M y z \\<prec> Le (real_of_int (- (c + d))) \\<or>\n    M y z = Le (real_of_int (- (c + d)))", "by (cases \"M y z\") (fastforce elim!: dbm_lt.cases)+"], ["proof (state)\nthis:\n  M y z \\<le> Le (real_of_int (- (c + d)))\n\ngoal (2 subgoals):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 =\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from dbm_le'[OF assms(2)[folded M(1)] this \\<open>y \\<le> n\\<close> \\<open>z \\<le> n\\<close> C(3,4)] \\<open>y \\<noteq> 0\\<close> \\<open>z \\<noteq> 0\\<close> M"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < y; 0 < z\\<rbrakk>\n  \\<Longrightarrow> [M]\\<^bsub>v,n\\<^esub>\n                    \\<subseteq> {u \\<in> V.\n                                 u c1 - u c2 \\<le> real_of_int (- (c + d))}\n  y \\<noteq> 0\n  z \\<noteq> 0\n  [M]\\<^bsub>v,n\\<^esub> = Z\n  canonical M n\n  dbm_int M n", "have subs: \"Z \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> - (c + d)}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < y; 0 < z\\<rbrakk>\n  \\<Longrightarrow> [M]\\<^bsub>v,n\\<^esub>\n                    \\<subseteq> {u \\<in> V.\n                                 u c1 - u c2 \\<le> real_of_int (- (c + d))}\n  y \\<noteq> 0\n  z \\<noteq> 0\n  [M]\\<^bsub>v,n\\<^esub> = Z\n  canonical M n\n  dbm_int M n\n\ngoal (1 subgoal):\n 1. Z \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- (c + d))}", "by blast"], ["proof (state)\nthis:\n  Z \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- (c + d))}\n\ngoal (2 subgoals):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 =\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with c d"], ["proof (chain)\npicking this:\n  M\\<^sub>R 0 y = Le (real_of_int c) \\<or>\n  M\\<^sub>R 0 y = Lt (real_of_int c)\n  - int (k (v' y)) \\<le> c\n  c \\<le> 0\n  M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Le (real_of_int (- d)) \\<or>\n  M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Lt (real_of_int (- d + 1))\n  d \\<le> int (k (v' z))\n  0 \\<le> d\n  Z \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- (c + d))}", "have \"- k (v' z) \\<le> - (c + d)\" \"- (c + d) \\<le> k (v' y)\""], ["proof (prove)\nusing this:\n  M\\<^sub>R 0 y = Le (real_of_int c) \\<or>\n  M\\<^sub>R 0 y = Lt (real_of_int c)\n  - int (k (v' y)) \\<le> c\n  c \\<le> 0\n  M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Le (real_of_int (- d)) \\<or>\n  M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Lt (real_of_int (- d + 1))\n  d \\<le> int (k (v' z))\n  0 \\<le> d\n  Z \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- (c + d))}\n\ngoal (1 subgoal):\n 1. - int (k (v' z)) \\<le> - (c + d) &&& - (c + d) \\<le> int (k (v' y))", "by auto"], ["proof (state)\nthis:\n  - int (k (v' z)) \\<le> - (c + d)\n  - (c + d) \\<le> int (k (v' y))\n\ngoal (2 subgoals):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 =\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with beta_interp.\\<beta>_boundedness_diag_le'[OF _ _ C(1,2) subs] C2"], ["proof (chain)\npicking this:\n  \\<lbrakk>- int (k c2) \\<le> - (c + d); - (c + d) \\<le> int (k c1)\\<rbrakk>\n  \\<Longrightarrow> Approx\\<^sub>\\<beta> Z\n                    \\<subseteq> {u \\<in> V.\n                                 u c1 - u c2 \\<le> real_of_int (- (c + d))}\n  v' y = c1\n  v' z = c2\n  - int (k (v' z)) \\<le> - (c + d)\n  - (c + d) \\<le> int (k (v' y))", "have \n              \"Approx\\<^sub>\\<beta> Z \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> - (c + d)}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>- int (k c2) \\<le> - (c + d); - (c + d) \\<le> int (k c1)\\<rbrakk>\n  \\<Longrightarrow> Approx\\<^sub>\\<beta> Z\n                    \\<subseteq> {u \\<in> V.\n                                 u c1 - u c2 \\<le> real_of_int (- (c + d))}\n  v' y = c1\n  v' z = c2\n  - int (k (v' z)) \\<le> - (c + d)\n  - (c + d) \\<le> int (k (v' y))\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> Z\n    \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- (c + d))}", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> Z\n  \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- (c + d))}\n\ngoal (2 subgoals):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 =\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> Z\n  \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- (c + d))}\n\ngoal (2 subgoals):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 =\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> Z\n  \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- (c + d))}\n\ngoal (2 subgoals):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 =\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix u"], ["proof (state)\ngoal (2 subgoals):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 =\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume u: \"u \\<in> R\""], ["proof (state)\nthis:\n  u \\<in> R\n\ngoal (2 subgoals):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 =\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C \\<open>y \\<le> n\\<close> \\<open>z \\<le> n\\<close> M\\<^sub>R(1)"], ["proof (chain)\npicking this:\n  c1 \\<in> X\n  c2 \\<in> X\n  v c1 = y\n  v c2 = z\n  y \\<le> n\n  z \\<le> n\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  u \\<in> R", "have\n                \"dbm_entry_val u (Some c2) None (M\\<^sub>R z 0)\" \"dbm_entry_val u None (Some c1) (M\\<^sub>R 0 y)\""], ["proof (prove)\nusing this:\n  c1 \\<in> X\n  c2 \\<in> X\n  v c1 = y\n  v c2 = z\n  y \\<le> n\n  z \\<le> n\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  u \\<in> R\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c2) None (M\\<^sub>R z 0) &&&\n    dbm_entry_val u None (Some c1) (M\\<^sub>R 0 y)", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  c1 \\<in> X\n  c2 \\<in> X\n  v c1 = y\n  v c2 = z\n  y \\<le> n\n  z \\<le> n\n  {u. Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n      (\\<forall>c.\n          v c \\<le> n \\<longrightarrow>\n          dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n          dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n      (\\<forall>c1 c2.\n          v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n          dbm_entry_val u (Some c1) (Some c2) (M\\<^sub>R (v c1) (v c2)))} =\n  R\n  u \\<in> R\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c2) None (M\\<^sub>R z 0) &&&\n    dbm_entry_val u None (Some c1) (M\\<^sub>R 0 y)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c2) None (M\\<^sub>R z 0)\n  dbm_entry_val u None (Some c1) (M\\<^sub>R 0 y)\n\ngoal (2 subgoals):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 =\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with True c d(1)"], ["proof (chain)\npicking this:\n  M\\<^sub>R 0 y + M\\<^sub>R z 0 = Lt (real_of_int (c + d))\n  M\\<^sub>R 0 y = Le (real_of_int c) \\<or>\n  M\\<^sub>R 0 y = Lt (real_of_int c)\n  - int (k (v' y)) \\<le> c\n  c \\<le> 0\n  M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Le (real_of_int (- d)) \\<or>\n  M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Lt (real_of_int (- d + 1))\n  dbm_entry_val u (Some c2) None (M\\<^sub>R z 0)\n  dbm_entry_val u None (Some c1) (M\\<^sub>R 0 y)", "have \"u \\<notin> {u \\<in> V. u c1 - u c2 \\<le> - (c + d)}\""], ["proof (prove)\nusing this:\n  M\\<^sub>R 0 y + M\\<^sub>R z 0 = Lt (real_of_int (c + d))\n  M\\<^sub>R 0 y = Le (real_of_int c) \\<or>\n  M\\<^sub>R 0 y = Lt (real_of_int c)\n  - int (k (v' y)) \\<le> c\n  c \\<le> 0\n  M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Le (real_of_int (- d)) \\<or>\n  M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Lt (real_of_int (- d + 1))\n  dbm_entry_val u (Some c2) None (M\\<^sub>R z 0)\n  dbm_entry_val u None (Some c1) (M\\<^sub>R 0 y)\n\ngoal (1 subgoal):\n 1. u \\<notin> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- (c + d))}", "unfolding mult"], ["proof (prove)\nusing this:\n  dbm_add (M\\<^sub>R 0 y) (M\\<^sub>R z 0) = Lt (real_of_int (c + d))\n  M\\<^sub>R 0 y = Le (real_of_int c) \\<or>\n  M\\<^sub>R 0 y = Lt (real_of_int c)\n  - int (k (v' y)) \\<le> c\n  c \\<le> 0\n  M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Le (real_of_int (- d)) \\<or>\n  M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Lt (real_of_int (- d + 1))\n  dbm_entry_val u (Some c2) None (M\\<^sub>R z 0)\n  dbm_entry_val u None (Some c1) (M\\<^sub>R 0 y)\n\ngoal (1 subgoal):\n 1. u \\<notin> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- (c + d))}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- (c + d))}\n\ngoal (2 subgoals):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 =\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  ?ua3 \\<in> R \\<Longrightarrow>\n  ?ua3 \\<notin> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- (c + d))}\n\ngoal (2 subgoals):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 =\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n 2. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> Z\n  \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- (c + d))}\n  ?ua3 \\<in> R \\<Longrightarrow>\n  ?ua3 \\<notin> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- (c + d))}", "show ?thesis"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> Z\n  \\<subseteq> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- (c + d))}\n  ?ua3 \\<in> R \\<Longrightarrow>\n  ?ua3 \\<notin> {u \\<in> V. u c1 - u c2 \\<le> real_of_int (- (c + d))}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by blast"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "case False"], ["proof (state)\nthis:\n  M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq> Lt (real_of_int (c + d))\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with c d"], ["proof (chain)\npicking this:\n  M\\<^sub>R 0 y = Le (real_of_int c) \\<or>\n  M\\<^sub>R 0 y = Lt (real_of_int c)\n  - int (k (v' y)) \\<le> c\n  c \\<le> 0\n  M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Le (real_of_int (- d)) \\<or>\n  M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Lt (real_of_int (- d + 1))\n  d \\<le> int (k (v' z))\n  0 \\<le> d\n  M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq> Lt (real_of_int (c + d))", "have \"M\\<^sub>R 0 y + M\\<^sub>R z 0 = Le (c + d)\""], ["proof (prove)\nusing this:\n  M\\<^sub>R 0 y = Le (real_of_int c) \\<or>\n  M\\<^sub>R 0 y = Lt (real_of_int c)\n  - int (k (v' y)) \\<le> c\n  c \\<le> 0\n  M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Le (real_of_int (- d)) \\<or>\n  M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Lt (real_of_int (- d + 1))\n  d \\<le> int (k (v' z))\n  0 \\<le> d\n  M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq> Lt (real_of_int (c + d))\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 = Le (real_of_int (c + d))", "unfolding mult"], ["proof (prove)\nusing this:\n  M\\<^sub>R 0 y = Le (real_of_int c) \\<or>\n  M\\<^sub>R 0 y = Lt (real_of_int c)\n  - int (k (v' y)) \\<le> c\n  c \\<le> 0\n  M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Le (real_of_int (- d)) \\<or>\n  M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Lt (real_of_int (- d + 1))\n  d \\<le> int (k (v' z))\n  0 \\<le> d\n  dbm_add (M\\<^sub>R 0 y) (M\\<^sub>R z 0) \\<noteq> Lt (real_of_int (c + d))\n\ngoal (1 subgoal):\n 1. dbm_add (M\\<^sub>R 0 y) (M\\<^sub>R z 0) = Le (real_of_int (c + d))", "by fastforce"], ["proof (state)\nthis:\n  M\\<^sub>R 0 y + M\\<^sub>R z 0 = Le (real_of_int (c + d))\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  M\\<^sub>R 0 y + M\\<^sub>R z 0 = Le (real_of_int (c + d))\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from **"], ["proof (chain)\npicking this:\n  M\\<^sub>R 0 y + (M y z + M\\<^sub>R z 0) < Le 0", "have \"(M\\<^sub>R 0 y + M\\<^sub>R z 0) + M y z < Le 0\""], ["proof (prove)\nusing this:\n  M\\<^sub>R 0 y + (M y z + M\\<^sub>R z 0) < Le 0\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 + M y z < Le 0", "using comm assoc"], ["proof (prove)\nusing this:\n  M\\<^sub>R 0 y + (M y z + M\\<^sub>R z 0) < Le 0\n  ?a + ?b = ?b + ?a\n  ?a + ?b + ?c = ?a + (?b + ?c)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 + M y z < Le 0", "by metis"], ["proof (state)\nthis:\n  M\\<^sub>R 0 y + M\\<^sub>R z 0 + M y z < Le 0\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  M\\<^sub>R 0 y + M\\<^sub>R z 0 = Le (real_of_int (c + d))\n  M\\<^sub>R 0 y + M\\<^sub>R z 0 + M y z < Le 0", "have **: \"Le (c + d) + M y z < Le 0\""], ["proof (prove)\nusing this:\n  M\\<^sub>R 0 y + M\\<^sub>R z 0 = Le (real_of_int (c + d))\n  M\\<^sub>R 0 y + M\\<^sub>R z 0 + M y z < Le 0\n\ngoal (1 subgoal):\n 1. Le (real_of_int (c + d)) + M y z < Le 0", "by simp"], ["proof (state)\nthis:\n  Le (real_of_int (c + d)) + M y z < Le 0\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  Le (real_of_int (c + d)) + M y z < Le 0", "have \"M y z \\<le> Lt (- (c + d))\""], ["proof (prove)\nusing this:\n  Le (real_of_int (c + d)) + M y z < Le 0\n\ngoal (1 subgoal):\n 1. M y z \\<le> Lt (real_of_int (- (c + d)))", "unfolding less less_eq dbm_le_def mult"], ["proof (prove)\nusing this:\n  dbm_add (Le (real_of_int (c + d))) (M y z) \\<prec> Le 0\n\ngoal (1 subgoal):\n 1. M y z \\<prec> Lt (real_of_int (- (c + d))) \\<or>\n    M y z = Lt (real_of_int (- (c + d)))", "by (cases \"M y z\") (fastforce elim!: dbm_lt.cases)+"], ["proof (state)\nthis:\n  M y z \\<le> Lt (real_of_int (- (c + d)))\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from dbm_lt'[OF assms(2)[folded M(1)] this \\<open>y \\<le> n\\<close> \\<open>z \\<le> n\\<close> C(3,4)] \\<open>y \\<noteq> 0\\<close> \\<open>z \\<noteq> 0\\<close> M"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < y; 0 < z\\<rbrakk>\n  \\<Longrightarrow> [M]\\<^bsub>v,n\\<^esub>\n                    \\<subseteq> {u \\<in> V.\n                                 u c1 - u c2 < real_of_int (- (c + d))}\n  y \\<noteq> 0\n  z \\<noteq> 0\n  [M]\\<^bsub>v,n\\<^esub> = Z\n  canonical M n\n  dbm_int M n", "have subs: \"Z \\<subseteq> {u \\<in> V. u c1 - u c2 < - (c + d)}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < y; 0 < z\\<rbrakk>\n  \\<Longrightarrow> [M]\\<^bsub>v,n\\<^esub>\n                    \\<subseteq> {u \\<in> V.\n                                 u c1 - u c2 < real_of_int (- (c + d))}\n  y \\<noteq> 0\n  z \\<noteq> 0\n  [M]\\<^bsub>v,n\\<^esub> = Z\n  canonical M n\n  dbm_int M n\n\ngoal (1 subgoal):\n 1. Z \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- (c + d))}", "by auto"], ["proof (state)\nthis:\n  Z \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- (c + d))}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from c d(2-) C2"], ["proof (chain)\npicking this:\n  M\\<^sub>R 0 y = Le (real_of_int c) \\<or>\n  M\\<^sub>R 0 y = Lt (real_of_int c)\n  - int (k (v' y)) \\<le> c\n  c \\<le> 0\n  d \\<le> int (k (v' z))\n  0 \\<le> d\n  v' y = c1\n  v' z = c2", "have \"- k c2 \\<le> - (c + d)\" \"- (c + d) \\<le> k c1\""], ["proof (prove)\nusing this:\n  M\\<^sub>R 0 y = Le (real_of_int c) \\<or>\n  M\\<^sub>R 0 y = Lt (real_of_int c)\n  - int (k (v' y)) \\<le> c\n  c \\<le> 0\n  d \\<le> int (k (v' z))\n  0 \\<le> d\n  v' y = c1\n  v' z = c2\n\ngoal (1 subgoal):\n 1. - int (k c2) \\<le> - (c + d) &&& - (c + d) \\<le> int (k c1)", "by auto"], ["proof (state)\nthis:\n  - int (k c2) \\<le> - (c + d)\n  - (c + d) \\<le> int (k c1)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "from beta_interp.\\<beta>_boundedness_diag_lt'[OF this C(1,2) subs]"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> Z\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- (c + d))}", "have \n              \"Approx\\<^sub>\\<beta> Z \\<subseteq> {u \\<in> V. u c1 - u c2 < - (c + d)}\""], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> Z\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- (c + d))}\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> Z\n    \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- (c + d))}", "."], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> Z\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- (c + d))}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "moreover"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> Z\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- (c + d))}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "{"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> Z\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- (c + d))}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "assume u: \"u \\<in> R\""], ["proof (state)\nthis:\n  u \\<in> R\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with C \\<open>y \\<le> n\\<close> \\<open>z \\<le> n\\<close> M\\<^sub>R(1)"], ["proof (chain)\npicking this:\n  c1 \\<in> X\n  c2 \\<in> X\n  v c1 = y\n  v c2 = z\n  y \\<le> n\n  z \\<le> n\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  u \\<in> R", "have\n                \"dbm_entry_val u (Some c2) None (M\\<^sub>R z 0)\" \"dbm_entry_val u None (Some c1) (M\\<^sub>R 0 y)\""], ["proof (prove)\nusing this:\n  c1 \\<in> X\n  c2 \\<in> X\n  v c1 = y\n  v c2 = z\n  y \\<le> n\n  z \\<le> n\n  [M\\<^sub>R]\\<^bsub>v,n\\<^esub> = R\n  u \\<in> R\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c2) None (M\\<^sub>R z 0) &&&\n    dbm_entry_val u None (Some c1) (M\\<^sub>R 0 y)", "unfolding DBM_zone_repr_def DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  c1 \\<in> X\n  c2 \\<in> X\n  v c1 = y\n  v c2 = z\n  y \\<le> n\n  z \\<le> n\n  {u. Le 0 \\<preceq> M\\<^sub>R 0 0 \\<and>\n      (\\<forall>c.\n          v c \\<le> n \\<longrightarrow>\n          dbm_entry_val u None (Some c) (M\\<^sub>R 0 (v c)) \\<and>\n          dbm_entry_val u (Some c) None (M\\<^sub>R (v c) 0)) \\<and>\n      (\\<forall>c1 c2.\n          v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n          dbm_entry_val u (Some c1) (Some c2) (M\\<^sub>R (v c1) (v c2)))} =\n  R\n  u \\<in> R\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c2) None (M\\<^sub>R z 0) &&&\n    dbm_entry_val u None (Some c1) (M\\<^sub>R 0 y)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c2) None (M\\<^sub>R z 0)\n  dbm_entry_val u None (Some c1) (M\\<^sub>R 0 y)\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with c d(1)"], ["proof (chain)\npicking this:\n  M\\<^sub>R 0 y = Le (real_of_int c) \\<or>\n  M\\<^sub>R 0 y = Lt (real_of_int c)\n  - int (k (v' y)) \\<le> c\n  c \\<le> 0\n  M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Le (real_of_int (- d)) \\<or>\n  M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Lt (real_of_int (- d + 1))\n  dbm_entry_val u (Some c2) None (M\\<^sub>R z 0)\n  dbm_entry_val u None (Some c1) (M\\<^sub>R 0 y)", "have \"u \\<notin> {u \\<in> V. u c1 - u c2 < - (c + d)}\""], ["proof (prove)\nusing this:\n  M\\<^sub>R 0 y = Le (real_of_int c) \\<or>\n  M\\<^sub>R 0 y = Lt (real_of_int c)\n  - int (k (v' y)) \\<le> c\n  c \\<le> 0\n  M\\<^sub>R z 0 = Le (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Le (real_of_int (- d)) \\<or>\n  M\\<^sub>R z 0 = Lt (real_of_int d) \\<and>\n  M\\<^sub>R 0 z = Lt (real_of_int (- d + 1))\n  dbm_entry_val u (Some c2) None (M\\<^sub>R z 0)\n  dbm_entry_val u None (Some c1) (M\\<^sub>R 0 y)\n\ngoal (1 subgoal):\n 1. u \\<notin> {u \\<in> V. u c1 - u c2 < real_of_int (- (c + d))}", "by auto"], ["proof (state)\nthis:\n  u \\<notin> {u \\<in> V. u c1 - u c2 < real_of_int (- (c + d))}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  ?ua3 \\<in> R \\<Longrightarrow>\n  ?ua3 \\<notin> {u \\<in> V. u c1 - u c2 < real_of_int (- (c + d))}\n\ngoal (1 subgoal):\n 1. M\\<^sub>R 0 y + M\\<^sub>R z 0 \\<noteq>\n    Lt (real_of_int (c + d)) \\<Longrightarrow>\n    R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "ultimately"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> Z\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- (c + d))}\n  ?ua3 \\<in> R \\<Longrightarrow>\n  ?ua3 \\<notin> {u \\<in> V. u c1 - u c2 < real_of_int (- (c + d))}", "show ?thesis"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> Z\n  \\<subseteq> {u \\<in> V. u c1 - u c2 < real_of_int (- (c + d))}\n  ?ua3 \\<in> R \\<Longrightarrow>\n  ?ua3 \\<notin> {u \\<in> V. u c1 - u c2 < real_of_int (- (c + d))}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z \\<noteq> {} \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "then"], ["proof (chain)\npicking this:\n  R \\<inter> Approx\\<^sub>\\<beta> Z \\<noteq> {} \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "have ?thesis"], ["proof (prove)\nusing this:\n  R \\<inter> Approx\\<^sub>\\<beta> Z \\<noteq> {} \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by auto"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "}"], ["proof (state)\nthis:\n  \\<forall>(a, b)\\<in>set (arcs i i ys).\n     M a b < M\\<^sub>R a b \\<longrightarrow>\n     M\\<^sub>R a 0 = \\<infinity> \\<or>\n     M\\<^sub>R b 0 = \\<infinity> \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "with bounded 0 bounded_zero_1 bounded_zero_2"], ["proof (chain)\npicking this:\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?a3; 0 < ?b3;\n   M\\<^sub>R ?a3 0 \\<noteq> \\<infinity>;\n   M\\<^sub>R ?b3 0 \\<noteq> \\<infinity>;\n   M ?a3 ?b3 < M\\<^sub>R ?a3 ?b3\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  (0, 0) \\<notin> set (arcs i i ys)\n  \\<lbrakk>(?a3, 0) \\<in> set (arcs i i ys); 0 < ?a3;\n   M\\<^sub>R ?a3 0 \\<noteq> \\<infinity>; M ?a3 0 < M\\<^sub>R ?a3 0\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  \\<lbrakk>(0, ?a3) \\<in> set (arcs i i ys); 0 < ?a3;\n   M\\<^sub>R ?a3 0 \\<noteq> \\<infinity>; M 0 ?a3 < M\\<^sub>R 0 ?a3\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  \\<forall>(a, b)\\<in>set (arcs i i ys).\n     M a b < M\\<^sub>R a b \\<longrightarrow>\n     M\\<^sub>R a 0 = \\<infinity> \\<or>\n     M\\<^sub>R b 0 = \\<infinity> \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?a3, ?b3) \\<in> set (arcs i i ys); 0 < ?a3; 0 < ?b3;\n   M\\<^sub>R ?a3 0 \\<noteq> \\<infinity>;\n   M\\<^sub>R ?b3 0 \\<noteq> \\<infinity>;\n   M ?a3 ?b3 < M\\<^sub>R ?a3 ?b3\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  (0, 0) \\<notin> set (arcs i i ys)\n  \\<lbrakk>(?a3, 0) \\<in> set (arcs i i ys); 0 < ?a3;\n   M\\<^sub>R ?a3 0 \\<noteq> \\<infinity>; M ?a3 0 < M\\<^sub>R ?a3 0\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  \\<lbrakk>(0, ?a3) \\<in> set (arcs i i ys); 0 < ?a3;\n   M\\<^sub>R ?a3 0 \\<noteq> \\<infinity>; M 0 ?a3 < M\\<^sub>R 0 ?a3\\<rbrakk>\n  \\<Longrightarrow> R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  \\<forall>(a, b)\\<in>set (arcs i i ys).\n     M a b < M\\<^sub>R a b \\<longrightarrow>\n     M\\<^sub>R a 0 = \\<infinity> \\<or>\n     M\\<^sub>R b 0 = \\<infinity> \\<Longrightarrow>\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. R \\<inter> Approx\\<^sub>\\<beta> Z = {}", "by blast"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Nice Corollaries of Bouyer's Theorem\\<close>"], ["", "lemma \\<R>_V: \"\\<Union> \\<R> = V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> \\<R> = V", "unfolding V_def \\<R>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> {Regions.region X I r |I r. Regions.valid_region X k I r} =\n    {v. \\<forall>x\\<in>X. 0 \\<le> v x}", "using region_cover[of X _ k]"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>X. 0 \\<le> ?u x \\<Longrightarrow>\n  \\<exists>R.\n     R \\<in> {Regions.region X I r |I r.\n              Regions.valid_region X k I r} \\<and>\n     ?u \\<in> R\n\ngoal (1 subgoal):\n 1. \\<Union> {Regions.region X I r |I r. Regions.valid_region X k I r} =\n    {v. \\<forall>x\\<in>X. 0 \\<le> v x}", "by auto"], ["", "lemma regions_beta_V: \"R \\<in> \\<R>\\<^sub>\\<beta> \\<Longrightarrow> R \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<in> \\<R>\\<^sub>\\<beta> \\<Longrightarrow> R \\<subseteq> V", "unfolding V_def \\<R>\\<^sub>\\<beta>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. R \\<in> {Regions_Beta.region X I J r |I J r.\n             Regions_Beta.valid_region X k I J r} \\<Longrightarrow>\n    R \\<subseteq> {v. \\<forall>x\\<in>X. 0 \\<le> v x}", "by auto"], ["", "lemma apx_V: \"Z \\<subseteq> V \\<Longrightarrow> Approx\\<^sub>\\<beta> Z \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<subseteq> V \\<Longrightarrow> Approx\\<^sub>\\<beta> Z \\<subseteq> V", "proof (goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. Z \\<subseteq> V \\<Longrightarrow> Approx\\<^sub>\\<beta> Z \\<subseteq> V", "case 1"], ["proof (state)\nthis:\n  Z \\<subseteq> V\n\ngoal (1 subgoal):\n 1. Z \\<subseteq> V \\<Longrightarrow> Approx\\<^sub>\\<beta> Z \\<subseteq> V", "from beta_interp.apx_in[OF 1]"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> Z\n  \\<in> {S. \\<exists>U M.\n               S = \\<Union> U \\<and>\n               U \\<subseteq> \\<R>\\<^sub>\\<beta> \\<and>\n               Z \\<subseteq> S \\<and>\n               (S = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n) \\<and>\n               beta_interp.normalized M}", "obtain U where \"Approx\\<^sub>\\<beta> Z = \\<Union>U\" \"U \\<subseteq> \\<R>\\<^sub>\\<beta>\""], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> Z\n  \\<in> {S. \\<exists>U M.\n               S = \\<Union> U \\<and>\n               U \\<subseteq> \\<R>\\<^sub>\\<beta> \\<and>\n               Z \\<subseteq> S \\<and>\n               (S = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n) \\<and>\n               beta_interp.normalized M}\n\ngoal (1 subgoal):\n 1. (\\<And>U.\n        \\<lbrakk>Approx\\<^sub>\\<beta> Z = \\<Union> U;\n         U \\<subseteq> \\<R>\\<^sub>\\<beta>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> Z = \\<Union> U\n  U \\<subseteq> \\<R>\\<^sub>\\<beta>\n\ngoal (1 subgoal):\n 1. Z \\<subseteq> V \\<Longrightarrow> Approx\\<^sub>\\<beta> Z \\<subseteq> V", "with regions_beta_V"], ["proof (chain)\npicking this:\n  ?R \\<in> \\<R>\\<^sub>\\<beta> \\<Longrightarrow> ?R \\<subseteq> V\n  Approx\\<^sub>\\<beta> Z = \\<Union> U\n  U \\<subseteq> \\<R>\\<^sub>\\<beta>", "show ?thesis"], ["proof (prove)\nusing this:\n  ?R \\<in> \\<R>\\<^sub>\\<beta> \\<Longrightarrow> ?R \\<subseteq> V\n  Approx\\<^sub>\\<beta> Z = \\<Union> U\n  U \\<subseteq> \\<R>\\<^sub>\\<beta>\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> Z \\<subseteq> V", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> Z \\<subseteq> V\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary approx_\\<beta>_closure_\\<alpha>:\n  assumes \"Z \\<subseteq> V\" \"vabstr Z M\"\n  shows \"Approx\\<^sub>\\<beta> Z \\<subseteq> Closure\\<^sub>\\<alpha> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> Z \\<subseteq> Closure\\<^sub>\\<alpha> Z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> Z \\<subseteq> Closure\\<^sub>\\<alpha> Z", "note T = region_zone_intersect_empty_approx_correct[OF _ assms(1) _ assms(2-)]"], ["proof (state)\nthis:\n  \\<lbrakk>?R \\<in> \\<R>; ?R \\<inter> Z = {}\\<rbrakk>\n  \\<Longrightarrow> ?R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> Z \\<subseteq> Closure\\<^sub>\\<alpha> Z", "have \"- \\<Union>{R \\<in> \\<R>. R \\<inter> Z \\<noteq> {}} = \\<Union>{R \\<in> \\<R>. R \\<inter> Z = {}} \\<union> - V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - \\<Union> {R \\<in> \\<R>. R \\<inter> Z \\<noteq> {}} =\n    \\<Union> {R \\<in> \\<R>. R \\<inter> Z = {}} \\<union> - V", "proof (safe, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<notin> \\<Union>\n                            {R \\<in> \\<R>. R \\<inter> Z \\<noteq> {}};\n        x \\<notin> \\<Union> {R \\<in> \\<R>. R \\<inter> Z = {}};\n        x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x X Xa xa.\n       \\<lbrakk>x \\<in> X; X \\<in> \\<R>; x \\<in> Xa; Xa \\<in> \\<R>;\n        Xa \\<inter> Z = {}; \\<not> False; xa \\<in> X; xa \\<in> Z\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {}\n 3. \\<And>x X xa.\n       \\<lbrakk>x \\<in> X; X \\<in> \\<R>; x \\<notin> V; \\<not> False;\n        xa \\<in> X; xa \\<in> Z\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {}", "case 1"], ["proof (state)\nthis:\n  x_ \\<notin> \\<Union> {R \\<in> \\<R>. R \\<inter> Z \\<noteq> {}}\n  x_ \\<notin> \\<Union> {R \\<in> \\<R>. R \\<inter> Z = {}}\n  x_ \\<in> V\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<notin> \\<Union>\n                            {R \\<in> \\<R>. R \\<inter> Z \\<noteq> {}};\n        x \\<notin> \\<Union> {R \\<in> \\<R>. R \\<inter> Z = {}};\n        x \\<in> V\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x X Xa xa.\n       \\<lbrakk>x \\<in> X; X \\<in> \\<R>; x \\<in> Xa; Xa \\<in> \\<R>;\n        Xa \\<inter> Z = {}; \\<not> False; xa \\<in> X; xa \\<in> Z\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {}\n 3. \\<And>x X xa.\n       \\<lbrakk>x \\<in> X; X \\<in> \\<R>; x \\<notin> V; \\<not> False;\n        xa \\<in> X; xa \\<in> Z\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {}", "with \\<R>_V"], ["proof (chain)\npicking this:\n  \\<Union> \\<R> = V\n  x_ \\<notin> \\<Union> {R \\<in> \\<R>. R \\<inter> Z \\<noteq> {}}\n  x_ \\<notin> \\<Union> {R \\<in> \\<R>. R \\<inter> Z = {}}\n  x_ \\<in> V", "show False"], ["proof (prove)\nusing this:\n  \\<Union> \\<R> = V\n  x_ \\<notin> \\<Union> {R \\<in> \\<R>. R \\<inter> Z \\<noteq> {}}\n  x_ \\<notin> \\<Union> {R \\<in> \\<R>. R \\<inter> Z = {}}\n  x_ \\<in> V\n\ngoal (1 subgoal):\n 1. False", "by fast"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>x X Xa xa.\n       \\<lbrakk>x \\<in> X; X \\<in> \\<R>; x \\<in> Xa; Xa \\<in> \\<R>;\n        Xa \\<inter> Z = {}; \\<not> False; xa \\<in> X; xa \\<in> Z\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {}\n 2. \\<And>x X xa.\n       \\<lbrakk>x \\<in> X; X \\<in> \\<R>; x \\<notin> V; \\<not> False;\n        xa \\<in> X; xa \\<in> Z\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {}", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x X Xa xa.\n       \\<lbrakk>x \\<in> X; X \\<in> \\<R>; x \\<in> Xa; Xa \\<in> \\<R>;\n        Xa \\<inter> Z = {}; \\<not> False; xa \\<in> X; xa \\<in> Z\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {}\n 2. \\<And>x X xa.\n       \\<lbrakk>x \\<in> X; X \\<in> \\<R>; x \\<notin> V; \\<not> False;\n        xa \\<in> X; xa \\<in> Z\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {}", "case 2"], ["proof (state)\nthis:\n  x_ \\<in> X_\n  X_ \\<in> \\<R>\n  x_ \\<in> Xa_\n  Xa_ \\<in> \\<R>\n  Xa_ \\<inter> Z = {}\n  \\<not> False\n  xa_ \\<in> X_\n  xa_ \\<in> Z\n\ngoal (2 subgoals):\n 1. \\<And>x X Xa xa.\n       \\<lbrakk>x \\<in> X; X \\<in> \\<R>; x \\<in> Xa; Xa \\<in> \\<R>;\n        Xa \\<inter> Z = {}; \\<not> False; xa \\<in> X; xa \\<in> Z\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {}\n 2. \\<And>x X xa.\n       \\<lbrakk>x \\<in> X; X \\<in> \\<R>; x \\<notin> V; \\<not> False;\n        xa \\<in> X; xa \\<in> Z\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {}", "then"], ["proof (chain)\npicking this:\n  x_ \\<in> X_\n  X_ \\<in> \\<R>\n  x_ \\<in> Xa_\n  Xa_ \\<in> \\<R>\n  Xa_ \\<inter> Z = {}\n  \\<not> False\n  xa_ \\<in> X_\n  xa_ \\<in> Z", "show ?case"], ["proof (prove)\nusing this:\n  x_ \\<in> X_\n  X_ \\<in> \\<R>\n  x_ \\<in> Xa_\n  Xa_ \\<in> \\<R>\n  Xa_ \\<inter> Z = {}\n  \\<not> False\n  xa_ \\<in> X_\n  xa_ \\<in> Z\n\ngoal (1 subgoal):\n 1. xa_ \\<in> {}", "using alpha_interp.valid_regions_distinct_spec"], ["proof (prove)\nusing this:\n  x_ \\<in> X_\n  X_ \\<in> \\<R>\n  x_ \\<in> Xa_\n  Xa_ \\<in> \\<R>\n  Xa_ \\<inter> Z = {}\n  \\<not> False\n  xa_ \\<in> X_\n  xa_ \\<in> Z\n  \\<lbrakk>?R \\<in> \\<R>; ?R' \\<in> \\<R>; ?v \\<in> ?R; ?v \\<in> ?R'\\<rbrakk>\n  \\<Longrightarrow> ?R = ?R'\n\ngoal (1 subgoal):\n 1. xa_ \\<in> {}", "by fastforce"], ["proof (state)\nthis:\n  xa_ \\<in> {}\n\ngoal (1 subgoal):\n 1. \\<And>x X xa.\n       \\<lbrakk>x \\<in> X; X \\<in> \\<R>; x \\<notin> V; \\<not> False;\n        xa \\<in> X; xa \\<in> Z\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x X xa.\n       \\<lbrakk>x \\<in> X; X \\<in> \\<R>; x \\<notin> V; \\<not> False;\n        xa \\<in> X; xa \\<in> Z\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {}", "case 3"], ["proof (state)\nthis:\n  x_ \\<in> X_\n  X_ \\<in> \\<R>\n  x_ \\<notin> V\n  \\<not> False\n  xa_ \\<in> X_\n  xa_ \\<in> Z\n\ngoal (1 subgoal):\n 1. \\<And>x X xa.\n       \\<lbrakk>x \\<in> X; X \\<in> \\<R>; x \\<notin> V; \\<not> False;\n        xa \\<in> X; xa \\<in> Z\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> {}", "then"], ["proof (chain)\npicking this:\n  x_ \\<in> X_\n  X_ \\<in> \\<R>\n  x_ \\<notin> V\n  \\<not> False\n  xa_ \\<in> X_\n  xa_ \\<in> Z", "show ?case"], ["proof (prove)\nusing this:\n  x_ \\<in> X_\n  X_ \\<in> \\<R>\n  x_ \\<notin> V\n  \\<not> False\n  xa_ \\<in> X_\n  xa_ \\<in> Z\n\ngoal (1 subgoal):\n 1. xa_ \\<in> {}", "using \\<R>_V"], ["proof (prove)\nusing this:\n  x_ \\<in> X_\n  X_ \\<in> \\<R>\n  x_ \\<notin> V\n  \\<not> False\n  xa_ \\<in> X_\n  xa_ \\<in> Z\n  \\<Union> \\<R> = V\n\ngoal (1 subgoal):\n 1. xa_ \\<in> {}", "unfolding V_def"], ["proof (prove)\nusing this:\n  x_ \\<in> X_\n  X_ \\<in> \\<R>\n  x_ \\<notin> {v. \\<forall>x\\<in>X. 0 \\<le> v x}\n  \\<not> False\n  xa_ \\<in> X_\n  xa_ \\<in> Z\n  \\<Union> \\<R> = {v. \\<forall>x\\<in>X. 0 \\<le> v x}\n\ngoal (1 subgoal):\n 1. xa_ \\<in> {}", "by blast"], ["proof (state)\nthis:\n  xa_ \\<in> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  - \\<Union> {R \\<in> \\<R>. R \\<inter> Z \\<noteq> {}} =\n  \\<Union> {R \\<in> \\<R>. R \\<inter> Z = {}} \\<union> - V\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> Z \\<subseteq> Closure\\<^sub>\\<alpha> Z", "with T apx_V[OF assms(1)]"], ["proof (chain)\npicking this:\n  \\<lbrakk>?R \\<in> \\<R>; ?R \\<inter> Z = {}\\<rbrakk>\n  \\<Longrightarrow> ?R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  Approx\\<^sub>\\<beta> Z \\<subseteq> V\n  - \\<Union> {R \\<in> \\<R>. R \\<inter> Z \\<noteq> {}} =\n  \\<Union> {R \\<in> \\<R>. R \\<inter> Z = {}} \\<union> - V", "have \"Approx\\<^sub>\\<beta> Z \\<inter> - \\<Union>{R \\<in> \\<R>. R \\<inter> Z \\<noteq> {}} = {}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?R \\<in> \\<R>; ?R \\<inter> Z = {}\\<rbrakk>\n  \\<Longrightarrow> ?R \\<inter> Approx\\<^sub>\\<beta> Z = {}\n  Approx\\<^sub>\\<beta> Z \\<subseteq> V\n  - \\<Union> {R \\<in> \\<R>. R \\<inter> Z \\<noteq> {}} =\n  \\<Union> {R \\<in> \\<R>. R \\<inter> Z = {}} \\<union> - V\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> Z \\<inter>\n    - \\<Union> {R \\<in> \\<R>. R \\<inter> Z \\<noteq> {}} =\n    {}", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> Z \\<inter>\n  - \\<Union> {R \\<in> \\<R>. R \\<inter> Z \\<noteq> {}} =\n  {}\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> Z \\<subseteq> Closure\\<^sub>\\<alpha> Z", "then"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> Z \\<inter>\n  - \\<Union> {R \\<in> \\<R>. R \\<inter> Z \\<noteq> {}} =\n  {}", "show ?thesis"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> Z \\<inter>\n  - \\<Union> {R \\<in> \\<R>. R \\<inter> Z \\<noteq> {}} =\n  {}\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> Z \\<subseteq> Closure\\<^sub>\\<alpha> Z", "unfolding alpha_interp.cla_def"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> Z \\<inter>\n  - \\<Union> {R \\<in> \\<R>. R \\<inter> Z \\<noteq> {}} =\n  {}\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> Z\n    \\<subseteq> \\<Union> {R \\<in> \\<R>. R \\<inter> Z \\<noteq> {}}", "by blast"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> Z \\<subseteq> Closure\\<^sub>\\<alpha> Z\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"V' \\<equiv> {Z. Z \\<subseteq> V \\<and> (\\<exists> M. vabstr Z M)}\""], ["", "corollary approx_\\<beta>_closure_\\<alpha>': \"Z \\<in> V' \\<Longrightarrow> Approx\\<^sub>\\<beta> Z \\<subseteq> Closure\\<^sub>\\<alpha> Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<in> V' \\<Longrightarrow>\n    Approx\\<^sub>\\<beta> Z \\<subseteq> Closure\\<^sub>\\<alpha> Z", "using approx_\\<beta>_closure_\\<alpha>"], ["proof (prove)\nusing this:\n  \\<lbrakk>?Z \\<subseteq> V;\n   ?Z = [?M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int ?M n\\<rbrakk>\n  \\<Longrightarrow> Approx\\<^sub>\\<beta> ?Z\n                    \\<subseteq> Closure\\<^sub>\\<alpha> ?Z\n\ngoal (1 subgoal):\n 1. Z \\<in> V' \\<Longrightarrow>\n    Approx\\<^sub>\\<beta> Z \\<subseteq> Closure\\<^sub>\\<alpha> Z", "unfolding V'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?Z \\<subseteq> V;\n   ?Z = [?M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int ?M n\\<rbrakk>\n  \\<Longrightarrow> Approx\\<^sub>\\<beta> ?Z\n                    \\<subseteq> Closure\\<^sub>\\<alpha> ?Z\n\ngoal (1 subgoal):\n 1. Z \\<in> {Z. Z \\<subseteq> V \\<and>\n                (\\<exists>M.\n                    Z = [M]\\<^bsub>v,n\\<^esub> \\<and>\n                    dbm_int M n)} \\<Longrightarrow>\n    Approx\\<^sub>\\<beta> Z \\<subseteq> Closure\\<^sub>\\<alpha> Z", "by auto"], ["", "text \\<open>We could prove this more directly too (without using \\<open>Closure\\<^sub>\\<alpha> Z\\<close>), obviously\\<close>"], ["", "lemma apx_empty_iff:\n  assumes \"Z \\<subseteq> V\" \"vabstr Z M\"\n  shows \"Z = {} \\<longleftrightarrow> Approx\\<^sub>\\<beta> Z = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Z = {}) = (Approx\\<^sub>\\<beta> Z = {})", "using alpha_interp.cla_empty_iff[OF assms(1)] approx_\\<beta>_closure_\\<alpha>[OF assms] beta_interp.apx_subset"], ["proof (prove)\nusing this:\n  (Z = {}) = (Closure\\<^sub>\\<alpha> Z = {})\n  Approx\\<^sub>\\<beta> Z \\<subseteq> Closure\\<^sub>\\<alpha> Z\n  ?Z \\<subseteq> Approx\\<^sub>\\<beta> ?Z\n\ngoal (1 subgoal):\n 1. (Z = {}) = (Approx\\<^sub>\\<beta> Z = {})", "by auto"], ["", "lemma apx_empty_iff':\n  assumes \"Z \\<in> V'\" shows \"Z = {} \\<longleftrightarrow> Approx\\<^sub>\\<beta> Z = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Z = {}) = (Approx\\<^sub>\\<beta> Z = {})", "using apx_empty_iff assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?Z \\<subseteq> V;\n   ?Z = [?M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int ?M n\\<rbrakk>\n  \\<Longrightarrow> (?Z = {}) = (Approx\\<^sub>\\<beta> ?Z = {})\n  Z \\<in> V'\n\ngoal (1 subgoal):\n 1. (Z = {}) = (Approx\\<^sub>\\<beta> Z = {})", "unfolding V'_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?Z \\<subseteq> V;\n   ?Z = [?M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int ?M n\\<rbrakk>\n  \\<Longrightarrow> (?Z = {}) = (Approx\\<^sub>\\<beta> ?Z = {})\n  Z \\<in> {Z. Z \\<subseteq> V \\<and>\n              (\\<exists>M. Z = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n)}\n\ngoal (1 subgoal):\n 1. (Z = {}) = (Approx\\<^sub>\\<beta> Z = {})", "by force"], ["", "lemma apx_V':\n  assumes \"Z \\<subseteq> V\" shows \"Approx\\<^sub>\\<beta> Z \\<in> V'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> Z \\<in> V'", "proof (cases \"Z = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Z = {} \\<Longrightarrow> Approx\\<^sub>\\<beta> Z \\<in> V'\n 2. Z \\<noteq> {} \\<Longrightarrow> Approx\\<^sub>\\<beta> Z \\<in> V'", "case True"], ["proof (state)\nthis:\n  Z = {}\n\ngoal (2 subgoals):\n 1. Z = {} \\<Longrightarrow> Approx\\<^sub>\\<beta> Z \\<in> V'\n 2. Z \\<noteq> {} \\<Longrightarrow> Approx\\<^sub>\\<beta> Z \\<in> V'", "with beta_interp.apx_empty beta_interp.empty_zone_dbm"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> {} = {}\n  \\<exists>M.\n     ({} = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n) \\<and>\n     beta_interp.normalized M \\<and> (\\<forall>k\\<le>n. M k k \\<le> Le 0)\n  Z = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> {} = {}\n  \\<exists>M.\n     ({} = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n) \\<and>\n     beta_interp.normalized M \\<and> (\\<forall>k\\<le>n. M k k \\<le> Le 0)\n  Z = {}\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> Z \\<in> V'", "unfolding V'_def neutral"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> {} = {}\n  \\<exists>M.\n     ({} = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n) \\<and>\n     beta_interp.normalized M \\<and> (\\<forall>k\\<le>n. M k k \\<le> Le 0)\n  Z = {}\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> Z\n    \\<in> {Z. Z \\<subseteq> V \\<and>\n              (\\<exists>M. Z = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n)}", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> Z \\<in> V'\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> Approx\\<^sub>\\<beta> Z \\<in> V'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> Approx\\<^sub>\\<beta> Z \\<in> V'", "case False"], ["proof (state)\nthis:\n  Z \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> Approx\\<^sub>\\<beta> Z \\<in> V'", "then"], ["proof (chain)\npicking this:\n  Z \\<noteq> {}", "have non_empty: \"Approx\\<^sub>\\<beta> Z \\<noteq> {}\""], ["proof (prove)\nusing this:\n  Z \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> Z \\<noteq> {}", "using beta_interp.apx_subset"], ["proof (prove)\nusing this:\n  Z \\<noteq> {}\n  ?Z \\<subseteq> Approx\\<^sub>\\<beta> ?Z\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> Z \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> Z \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> Approx\\<^sub>\\<beta> Z \\<in> V'", "from beta_interp.apx_in[OF assms]"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> Z\n  \\<in> {S. \\<exists>U M.\n               S = \\<Union> U \\<and>\n               U \\<subseteq> \\<R>\\<^sub>\\<beta> \\<and>\n               Z \\<subseteq> S \\<and>\n               (S = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n) \\<and>\n               beta_interp.normalized M}", "obtain U M where *:\n    \"Approx\\<^sub>\\<beta> Z = \\<Union>U\" \"U \\<subseteq> \\<R>\\<^sub>\\<beta>\" \"Z \\<subseteq> Approx\\<^sub>\\<beta> Z\" \"vabstr (Approx\\<^sub>\\<beta> Z) M\""], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> Z\n  \\<in> {S. \\<exists>U M.\n               S = \\<Union> U \\<and>\n               U \\<subseteq> \\<R>\\<^sub>\\<beta> \\<and>\n               Z \\<subseteq> S \\<and>\n               (S = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n) \\<and>\n               beta_interp.normalized M}\n\ngoal (1 subgoal):\n 1. (\\<And>U M.\n        \\<lbrakk>Approx\\<^sub>\\<beta> Z = \\<Union> U;\n         U \\<subseteq> \\<R>\\<^sub>\\<beta>;\n         Z \\<subseteq> Approx\\<^sub>\\<beta> Z;\n         Approx\\<^sub>\\<beta> Z = [M]\\<^bsub>v,n\\<^esub> \\<and>\n         dbm_int M n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> Z = \\<Union> U\n  U \\<subseteq> \\<R>\\<^sub>\\<beta>\n  Z \\<subseteq> Approx\\<^sub>\\<beta> Z\n  Approx\\<^sub>\\<beta> Z = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> Approx\\<^sub>\\<beta> Z \\<in> V'", "moreover"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> Z = \\<Union> U\n  U \\<subseteq> \\<R>\\<^sub>\\<beta>\n  Z \\<subseteq> Approx\\<^sub>\\<beta> Z\n  Approx\\<^sub>\\<beta> Z = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> Approx\\<^sub>\\<beta> Z \\<in> V'", "from * beta_interp.\\<R>_union"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> Z = \\<Union> U\n  U \\<subseteq> \\<R>\\<^sub>\\<beta>\n  Z \\<subseteq> Approx\\<^sub>\\<beta> Z\n  Approx\\<^sub>\\<beta> Z = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n\n  \\<Union> \\<R>\\<^sub>\\<beta> = V", "have \"\\<Union> U \\<subseteq> V\""], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> Z = \\<Union> U\n  U \\<subseteq> \\<R>\\<^sub>\\<beta>\n  Z \\<subseteq> Approx\\<^sub>\\<beta> Z\n  Approx\\<^sub>\\<beta> Z = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n\n  \\<Union> \\<R>\\<^sub>\\<beta> = V\n\ngoal (1 subgoal):\n 1. \\<Union> U \\<subseteq> V", "by blast"], ["proof (state)\nthis:\n  \\<Union> U \\<subseteq> V\n\ngoal (1 subgoal):\n 1. Z \\<noteq> {} \\<Longrightarrow> Approx\\<^sub>\\<beta> Z \\<in> V'", "ultimately"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> Z = \\<Union> U\n  U \\<subseteq> \\<R>\\<^sub>\\<beta>\n  Z \\<subseteq> Approx\\<^sub>\\<beta> Z\n  Approx\\<^sub>\\<beta> Z = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n\n  \\<Union> U \\<subseteq> V", "show ?thesis"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> Z = \\<Union> U\n  U \\<subseteq> \\<R>\\<^sub>\\<beta>\n  Z \\<subseteq> Approx\\<^sub>\\<beta> Z\n  Approx\\<^sub>\\<beta> Z = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n\n  \\<Union> U \\<subseteq> V\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> Z \\<in> V'", "using *(1,4)"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> Z = \\<Union> U\n  U \\<subseteq> \\<R>\\<^sub>\\<beta>\n  Z \\<subseteq> Approx\\<^sub>\\<beta> Z\n  Approx\\<^sub>\\<beta> Z = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n\n  \\<Union> U \\<subseteq> V\n  Approx\\<^sub>\\<beta> Z = \\<Union> U\n  Approx\\<^sub>\\<beta> Z = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> Z \\<in> V'", "unfolding V'_def"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> Z = \\<Union> U\n  U \\<subseteq> \\<R>\\<^sub>\\<beta>\n  Z \\<subseteq> Approx\\<^sub>\\<beta> Z\n  Approx\\<^sub>\\<beta> Z = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n\n  \\<Union> U \\<subseteq> V\n  Approx\\<^sub>\\<beta> Z = \\<Union> U\n  Approx\\<^sub>\\<beta> Z = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> Z\n    \\<in> {Z. Z \\<subseteq> V \\<and>\n              (\\<exists>M. Z = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n)}", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> Z \\<in> V'\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>A New Zone Semantics Abstracting with \\<open>Approx\\<^sub>\\<beta>\\<close>\\<close>"], ["", "lemma step_z_V':\n  assumes \"A \\<turnstile> \\<langle>l,Z\\<rangle> \\<leadsto> \\<langle>l',Z'\\<rangle>\" \"valid_abstraction A X k\" \"\\<forall>c\\<in>clk_set A. v c \\<le> n\" \"Z \\<in> V'\"\n  shows \"Z' \\<in> V'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z' \\<in> V'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Z' \\<in> V'", "from assms(3) clock_numbering"], ["proof (chain)\npicking this:\n  \\<forall>c\\<in>clk_set A. v c \\<le> n\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n", "have numbering: \"global_clock_numbering A v n\""], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>clk_set A. v c \\<le> n\n  \\<forall>c.\n     0 < v c \\<and>\n     (\\<forall>x y.\n         v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n         x = y)\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c\\<in>X. v c = k)\n  \\<forall>c\\<in>X. v c \\<le> n\n\ngoal (1 subgoal):\n 1. (\\<forall>c.\n        0 < v c \\<and>\n        (\\<forall>x y.\n            v x \\<le> n \\<and>\n            v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n            x = y)) \\<and>\n    (\\<forall>c\\<in>clk_set A. v c \\<le> n) \\<and>\n    (\\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k))", "by metis"], ["proof (state)\nthis:\n  (\\<forall>c.\n      0 < v c \\<and>\n      (\\<forall>x y.\n          v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n          x = y)) \\<and>\n  (\\<forall>c\\<in>clk_set A. v c \\<le> n) \\<and>\n  (\\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k))\n\ngoal (1 subgoal):\n 1. Z' \\<in> V'", "from assms(4)"], ["proof (chain)\npicking this:\n  Z \\<in> V'", "obtain M where M:\n    \"Z \\<subseteq> V\" \"Z = [M]\\<^bsub>v,n\\<^esub>\" \"dbm_int M n\""], ["proof (prove)\nusing this:\n  Z \\<in> V'\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>Z \\<subseteq> V; Z = [M]\\<^bsub>v,n\\<^esub>;\n         dbm_int M n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding V'_def"], ["proof (prove)\nusing this:\n  Z \\<in> {Z. Z \\<subseteq> V \\<and>\n              (\\<exists>M. Z = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n)}\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<lbrakk>Z \\<subseteq> V; Z = [M]\\<^bsub>v,n\\<^esub>;\n         dbm_int M n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Z \\<subseteq> V\n  Z = [M]\\<^bsub>v,n\\<^esub>\n  dbm_int M n\n\ngoal (1 subgoal):\n 1. Z' \\<in> V'", "from alpha_interp.step_z_V[OF assms(1) M(1)] M(2) assms(1) step_z_dbm_DBM[OF _ numbering]\n       step_z_dbm_preserves_int[OF _ numbering assms(2) M(3)]"], ["proof (chain)\npicking this:\n  Z' \\<subseteq> V\n  Z = [M]\\<^bsub>v,n\\<^esub>\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>\n  \\<lbrakk>A \\<turnstile> \\<langle>?l, [?D]\\<^bsub>v,n\\<^esub>\\<rangle> \\<leadsto> \\<langle>?l', ?Z\\<rangle>;\n   \\<And>D'.\n      \\<lbrakk>A \\<turnstile> \\<langle>?l, ?D\\<rangle> \\<leadsto>\\<^bsub>v,n\\<^esub> \\<langle>?l', D'\\<rangle>;\n       ?Z = [D']\\<^bsub>v,n\\<^esub>\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  A \\<turnstile> \\<langle>?l, M\\<rangle> \\<leadsto>\\<^bsub>v,n\\<^esub> \\<langle>?l', ?D'\\<rangle> \\<Longrightarrow>\n  dbm_int ?D' n", "obtain M' where M': \"Z' \\<subseteq> V\" \"Z' = [M']\\<^bsub>v,n\\<^esub>\" \"dbm_int M' n\""], ["proof (prove)\nusing this:\n  Z' \\<subseteq> V\n  Z = [M]\\<^bsub>v,n\\<^esub>\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>\n  \\<lbrakk>A \\<turnstile> \\<langle>?l, [?D]\\<^bsub>v,n\\<^esub>\\<rangle> \\<leadsto> \\<langle>?l', ?Z\\<rangle>;\n   \\<And>D'.\n      \\<lbrakk>A \\<turnstile> \\<langle>?l, ?D\\<rangle> \\<leadsto>\\<^bsub>v,n\\<^esub> \\<langle>?l', D'\\<rangle>;\n       ?Z = [D']\\<^bsub>v,n\\<^esub>\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  A \\<turnstile> \\<langle>?l, M\\<rangle> \\<leadsto>\\<^bsub>v,n\\<^esub> \\<langle>?l', ?D'\\<rangle> \\<Longrightarrow>\n  dbm_int ?D' n\n\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        \\<lbrakk>Z' \\<subseteq> V; Z' = [M']\\<^bsub>v,n\\<^esub>;\n         dbm_int M' n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  Z' \\<subseteq> V\n  Z' = [M']\\<^bsub>v,n\\<^esub>\n  dbm_int M' n\n\ngoal (1 subgoal):\n 1. Z' \\<in> V'", "then"], ["proof (chain)\npicking this:\n  Z' \\<subseteq> V\n  Z' = [M']\\<^bsub>v,n\\<^esub>\n  dbm_int M' n", "show ?thesis"], ["proof (prove)\nusing this:\n  Z' \\<subseteq> V\n  Z' = [M']\\<^bsub>v,n\\<^esub>\n  dbm_int M' n\n\ngoal (1 subgoal):\n 1. Z' \\<in> V'", "unfolding V'_def"], ["proof (prove)\nusing this:\n  Z' \\<subseteq> V\n  Z' = [M']\\<^bsub>v,n\\<^esub>\n  dbm_int M' n\n\ngoal (1 subgoal):\n 1. Z' \\<in> {Z. Z \\<subseteq> V \\<and>\n                 (\\<exists>M.\n                     Z = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n)}", "by blast"], ["proof (state)\nthis:\n  Z' \\<in> V'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma steps_z_V':\n  \"A \\<turnstile> \\<langle>l,Z\\<rangle> \\<leadsto>* \\<langle>l',Z'\\<rangle> \\<Longrightarrow> valid_abstraction A X k \\<Longrightarrow> \\<forall>c\\<in>clk_set A. v c \\<le> n \\<Longrightarrow> Z \\<in> V' \\<Longrightarrow> Z' \\<in> V'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l', Z'\\<rangle>;\n     valid_abstraction A X (\\<lambda>x. real (k x));\n     \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n    \\<Longrightarrow> Z' \\<in> V'", "by (induction rule: steps_z.induct) (auto intro: step_z_V')"], ["", "subsection \\<open>Single Step\\<close>"], ["", "inductive step_z_beta ::\n  \"('a, 'c, t, 's) ta \\<Rightarrow> 's \\<Rightarrow> ('c, t) zone \\<Rightarrow> 's \\<Rightarrow> ('c, t) zone \\<Rightarrow> bool\"\n(\"_ \\<turnstile> \\<langle>_, _\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>_, _\\<rangle>\" [61,61,61] 61)\nwhere\n  step_beta: \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle> \\<Longrightarrow> A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Approx\\<^sub>\\<beta> Z'\\<rangle>\""], ["", "inductive_cases[elim!]: \"A \\<turnstile> \\<langle>l, u\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l',u'\\<rangle>\""], ["", "declare step_z_beta.intros[intro]"], ["", "lemma step_z_alpha_sound:\n  \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l',Z'\\<rangle> \\<Longrightarrow> valid_abstraction A X k \\<Longrightarrow> \\<forall>c\\<in>clk_set A. v c \\<le> n \\<Longrightarrow> Z \\<in> V' \\<Longrightarrow> Z' \\<noteq> {}\n  \\<Longrightarrow> \\<exists> Z''. A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l',Z''\\<rangle> \\<and> Z'' \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z'\\<rangle>;\n     valid_abstraction A X (\\<lambda>x. real (k x));\n     \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V';\n     Z' \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Z''.\n                         A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z''\\<rangle> \\<and>\n                         Z'' \\<noteq> {}", "apply (induction rule: step_z_beta.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z'.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V';\n        Approx\\<^sub>\\<beta> Z' \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z''\\<rangle> \\<and>\n                            Z'' \\<noteq> {}", "apply (frule step_z_V')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>A l Z l' Z'.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V';\n        Approx\\<^sub>\\<beta> Z' \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> valid_abstraction A X (\\<lambda>x. real (k x))\n 2. \\<And>A l Z l' Z'.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V';\n        Approx\\<^sub>\\<beta> Z' \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>clk_set A. v c \\<le> n\n 3. \\<And>A l Z l' Z'.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V';\n        Approx\\<^sub>\\<beta> Z' \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Z \\<in> V'\n 4. \\<And>A l Z l' Z'.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V';\n        Approx\\<^sub>\\<beta> Z' \\<noteq> {}; Z' \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z''\\<rangle> \\<and>\n                            Z'' \\<noteq> {}", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z'.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V';\n        Approx\\<^sub>\\<beta> Z' \\<noteq> {}; Z' \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z''\\<rangle> \\<and>\n                            Z'' \\<noteq> {}", "apply (rotate_tac 4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z'.\n       \\<lbrakk>Approx\\<^sub>\\<beta> Z' \\<noteq> {}; Z' \\<in> V';\n        A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z''\\<rangle> \\<and>\n                            Z'' \\<noteq> {}", "apply (drule apx_empty_iff')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z'.\n       \\<lbrakk>Approx\\<^sub>\\<beta> Z' \\<noteq> {};\n        A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V';\n        (Z' = {}) = (Approx\\<^sub>\\<beta> Z' = {})\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z''\\<rangle> \\<and>\n                            Z'' \\<noteq> {}", "by blast"], ["", "lemma step_z_alpha_complete:\n  \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l',Z'\\<rangle> \\<Longrightarrow> valid_abstraction A X k \\<Longrightarrow> \\<forall>c\\<in>clk_set A. v c \\<le> n \\<Longrightarrow> Z \\<in> V' \\<Longrightarrow> Z' \\<noteq> {}\n  \\<Longrightarrow> \\<exists> Z''. A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z''\\<rangle> \\<and> Z'' \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n     valid_abstraction A X (\\<lambda>x. real (k x));\n     \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V';\n     Z' \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Z''.\n                         A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z''\\<rangle> \\<and>\n                         Z'' \\<noteq> {}", "apply (frule step_z_V')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n     valid_abstraction A X (\\<lambda>x. real (k x));\n     \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V';\n     Z' \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> valid_abstraction A X (\\<lambda>x. real (k x))\n 2. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n     valid_abstraction A X (\\<lambda>x. real (k x));\n     \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V';\n     Z' \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>c\\<in>clk_set A. v c \\<le> n\n 3. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n     valid_abstraction A X (\\<lambda>x. real (k x));\n     \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V';\n     Z' \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Z \\<in> V'\n 4. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n     valid_abstraction A X (\\<lambda>x. real (k x));\n     \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'; Z' \\<noteq> {};\n     Z' \\<in> V'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Z''.\n                         A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z''\\<rangle> \\<and>\n                         Z'' \\<noteq> {}", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n     valid_abstraction A X (\\<lambda>x. real (k x));\n     \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'; Z' \\<noteq> {};\n     Z' \\<in> V'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Z''.\n                         A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z''\\<rangle> \\<and>\n                         Z'' \\<noteq> {}", "apply (rotate_tac 4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Z' \\<noteq> {}; Z' \\<in> V';\n     A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n     valid_abstraction A X (\\<lambda>x. real (k x));\n     \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Z''.\n                         A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z''\\<rangle> \\<and>\n                         Z'' \\<noteq> {}", "apply (drule apx_empty_iff')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Z' \\<noteq> {};\n     A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n     valid_abstraction A X (\\<lambda>x. real (k x));\n     \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V';\n     (Z' = {}) = (Approx\\<^sub>\\<beta> Z' = {})\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Z''.\n                         A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z''\\<rangle> \\<and>\n                         Z'' \\<noteq> {}", "by blast"], ["", "subsection \\<open>Multi step\\<close>"], ["", "inductive\n  steps_z_beta :: \"('a, 'c, t, 's) ta \\<Rightarrow> 's \\<Rightarrow> ('c, t) zone \\<Rightarrow> 's \\<Rightarrow> ('c, t) zone \\<Rightarrow> bool\"\n(\"_ \\<turnstile> \\<langle>_, _\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>_, _\\<rangle>\" [61,61,61] 61)\nwhere\n  refl: \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l, Z\\<rangle>\" |\n  step: \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle> \\<Longrightarrow> A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle> \\<Longrightarrow> A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''\\<rangle>\""], ["", "declare steps_z_beta.intros[intro]"], ["", "lemma V'_V: \"Z \\<in> V' \\<Longrightarrow> Z \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<in> V' \\<Longrightarrow> Z \\<subseteq> V", "unfolding V'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Z \\<in> {Z. Z \\<subseteq> V \\<and>\n                (\\<exists>M.\n                    Z = [M]\\<^bsub>v,n\\<^esub> \\<and>\n                    dbm_int M n)} \\<Longrightarrow>\n    Z \\<subseteq> V", "by auto"], ["", "lemma steps_z_beta_V':\n  \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle> \\<Longrightarrow> valid_abstraction A X k \\<Longrightarrow>\\<forall>c\\<in>clk_set A. v c \\<le> n \\<Longrightarrow> Z \\<in> V' \\<Longrightarrow> Z' \\<in> V'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n     valid_abstraction A X (\\<lambda>x. real (k x));\n     \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n    \\<Longrightarrow> Z' \\<in> V'", "proof (induction rule: steps_z_beta.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A l Z.\n       \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> Z \\<in> V'\n 2. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n         \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n        \\<Longrightarrow> Z' \\<in> V';\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> Z'' \\<in> V'", "case refl"], ["proof (state)\nthis:\n  valid_abstraction A_ X (\\<lambda>x. real (k x))\n  \\<forall>c\\<in>clk_set A_. v c \\<le> n\n  Z_ \\<in> V'\n\ngoal (2 subgoals):\n 1. \\<And>A l Z.\n       \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> Z \\<in> V'\n 2. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n         \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n        \\<Longrightarrow> Z' \\<in> V';\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> Z'' \\<in> V'", "then"], ["proof (chain)\npicking this:\n  valid_abstraction A_ X (\\<lambda>x. real (k x))\n  \\<forall>c\\<in>clk_set A_. v c \\<le> n\n  Z_ \\<in> V'", "show ?case"], ["proof (prove)\nusing this:\n  valid_abstraction A_ X (\\<lambda>x. real (k x))\n  \\<forall>c\\<in>clk_set A_. v c \\<le> n\n  Z_ \\<in> V'\n\ngoal (1 subgoal):\n 1. Z_ \\<in> V'", "by fast"], ["proof (state)\nthis:\n  Z_ \\<in> V'\n\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n         \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n        \\<Longrightarrow> Z' \\<in> V';\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> Z'' \\<in> V'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n         \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n        \\<Longrightarrow> Z' \\<in> V';\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> Z'' \\<in> V'", "case (step A l Z l' Z' l'' Z'')"], ["proof (state)\nthis:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>\n  A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>\n  \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n   \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n  \\<Longrightarrow> Z' \\<in> V'\n  valid_abstraction A X (\\<lambda>x. real (k x))\n  \\<forall>c\\<in>clk_set A. v c \\<le> n\n  Z \\<in> V'\n\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n         \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n        \\<Longrightarrow> Z' \\<in> V';\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> Z'' \\<in> V'", "from this(2)"], ["proof (chain)\npicking this:\n  A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>", "obtain Z''' where Z''': \"A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto> \\<langle>l'',Z'''\\<rangle>\" \"Z'' = Approx\\<^sub>\\<beta> Z'''\""], ["proof (prove)\nusing this:\n  A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>Z'''.\n        \\<lbrakk>A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto> \\<langle>l'', Z'''\\<rangle>;\n         Z'' = Approx\\<^sub>\\<beta> Z'''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto> \\<langle>l'', Z'''\\<rangle>\n  Z'' = Approx\\<^sub>\\<beta> Z'''\n\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n         \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n        \\<Longrightarrow> Z' \\<in> V';\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> Z'' \\<in> V'", "from step_z_V'[OF this(1)] step"], ["proof (chain)\npicking this:\n  \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n   \\<forall>c\\<in>clk_set A. v c \\<le> n; Z' \\<in> V'\\<rbrakk>\n  \\<Longrightarrow> Z''' \\<in> V'\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>\n  A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>\n  \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n   \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n  \\<Longrightarrow> Z' \\<in> V'\n  valid_abstraction A X (\\<lambda>x. real (k x))\n  \\<forall>c\\<in>clk_set A. v c \\<le> n\n  Z \\<in> V'", "have \"Z''' \\<in> V'\""], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n   \\<forall>c\\<in>clk_set A. v c \\<le> n; Z' \\<in> V'\\<rbrakk>\n  \\<Longrightarrow> Z''' \\<in> V'\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>\n  A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>\n  \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n   \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n  \\<Longrightarrow> Z' \\<in> V'\n  valid_abstraction A X (\\<lambda>x. real (k x))\n  \\<forall>c\\<in>clk_set A. v c \\<le> n\n  Z \\<in> V'\n\ngoal (1 subgoal):\n 1. Z''' \\<in> V'", "by auto"], ["proof (state)\nthis:\n  Z''' \\<in> V'\n\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n         \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n        \\<Longrightarrow> Z' \\<in> V';\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> Z'' \\<in> V'", "from apx_V'[OF V'_V, OF this] Z'''(2)"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> Z''' \\<in> V'\n  Z'' = Approx\\<^sub>\\<beta> Z'''", "show ?case"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> Z''' \\<in> V'\n  Z'' = Approx\\<^sub>\\<beta> Z'''\n\ngoal (1 subgoal):\n 1. Z'' \\<in> V'", "by auto"], ["proof (state)\nthis:\n  Z'' \\<in> V'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alpha_beta_step:\n  \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z'\\<rangle> \\<Longrightarrow> valid_abstraction A X k \\<Longrightarrow> \\<forall>c\\<in>clk_set A. v c \\<le> n \\<Longrightarrow> Z \\<in> V'\n  \\<Longrightarrow> \\<exists> Z''. A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha> \\<langle>l', Z''\\<rangle> \\<and> Z' \\<subseteq> Z''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z'\\<rangle>;\n     valid_abstraction A X (\\<lambda>x. real (k x));\n     \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Z''.\n                         A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha> \\<langle>l', Z''\\<rangle> \\<and>\n                         Z' \\<subseteq> Z''", "apply (induction rule: step_z_beta.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z'.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha> \\<langle>l', Z''\\<rangle> \\<and>\n                            Approx\\<^sub>\\<beta> Z' \\<subseteq> Z''", "apply (frule step_z_V')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>A l Z l' Z'.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> valid_abstraction A X (\\<lambda>x. real (k x))\n 2. \\<And>A l Z l' Z'.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>c\\<in>clk_set A. v c \\<le> n\n 3. \\<And>A l Z l' Z'.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> Z \\<in> V'\n 4. \\<And>A l Z l' Z'.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V';\n        Z' \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha> \\<langle>l', Z''\\<rangle> \\<and>\n                            Approx\\<^sub>\\<beta> Z' \\<subseteq> Z''", "apply assumption+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z'.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V';\n        Z' \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha> \\<langle>l', Z''\\<rangle> \\<and>\n                            Approx\\<^sub>\\<beta> Z' \\<subseteq> Z''", "apply (rotate_tac 4)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z'.\n       \\<lbrakk>Z' \\<in> V';\n        A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha> \\<langle>l', Z''\\<rangle> \\<and>\n                            Approx\\<^sub>\\<beta> Z' \\<subseteq> Z''", "apply (drule approx_\\<beta>_closure_\\<alpha>')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z'.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V';\n        Approx\\<^sub>\\<beta> Z'\n        \\<subseteq> Closure\\<^sub>\\<alpha> Z'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha> \\<langle>l', Z''\\<rangle> \\<and>\n                            Approx\\<^sub>\\<beta> Z' \\<subseteq> Z''", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Soundness\\<close>"], ["", "lemma alpha_beta_step':\n  \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z'\\<rangle> \\<Longrightarrow> valid_abstraction A X k \\<Longrightarrow> \\<forall>c\\<in>clk_set A. v c \\<le> n \\<Longrightarrow> Z \\<in> V' \\<Longrightarrow> W \\<subseteq> V\n  \\<Longrightarrow> Z \\<subseteq> W \\<Longrightarrow> \\<exists> W'. A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<alpha> \\<langle>l', W'\\<rangle> \\<and> Z' \\<subseteq> W'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z'\\<rangle>;\n     valid_abstraction A X (\\<lambda>x. real (k x));\n     \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'; W \\<subseteq> V;\n     Z \\<subseteq> W\\<rbrakk>\n    \\<Longrightarrow> \\<exists>W'.\n                         A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<alpha> \\<langle>l', W'\\<rangle> \\<and>\n                         Z' \\<subseteq> W'", "proof (induction rule: step_z_beta.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z'.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'; W \\<subseteq> V;\n        Z \\<subseteq> W\\<rbrakk>\n       \\<Longrightarrow> \\<exists>W'.\n                            A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<alpha> \\<langle>l', W'\\<rangle> \\<and>\n                            Approx\\<^sub>\\<beta> Z' \\<subseteq> W'", "case (step_beta A l Z l' Z')"], ["proof (state)\nthis:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>\n  valid_abstraction A X (\\<lambda>x. real (k x))\n  \\<forall>c\\<in>clk_set A. v c \\<le> n\n  Z \\<in> V'\n  W \\<subseteq> V\n  Z \\<subseteq> W\n\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z'.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'; W \\<subseteq> V;\n        Z \\<subseteq> W\\<rbrakk>\n       \\<Longrightarrow> \\<exists>W'.\n                            A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<alpha> \\<langle>l', W'\\<rangle> \\<and>\n                            Approx\\<^sub>\\<beta> Z' \\<subseteq> W'", "from alpha_interp.step_z_mono[OF step_beta(1,6)]"], ["proof (chain)\npicking this:\n  \\<exists>W'.\n     A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto> \\<langle>l', W'\\<rangle> \\<and>\n     Z' \\<subseteq> W'", "obtain W' where W':\n    \"A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto> \\<langle>l',W'\\<rangle>\" \"Z' \\<subseteq> W'\""], ["proof (prove)\nusing this:\n  \\<exists>W'.\n     A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto> \\<langle>l', W'\\<rangle> \\<and>\n     Z' \\<subseteq> W'\n\ngoal (1 subgoal):\n 1. (\\<And>W'.\n        \\<lbrakk>A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto> \\<langle>l', W'\\<rangle>;\n         Z' \\<subseteq> W'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto> \\<langle>l', W'\\<rangle>\n  Z' \\<subseteq> W'\n\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z'.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'; W \\<subseteq> V;\n        Z \\<subseteq> W\\<rbrakk>\n       \\<Longrightarrow> \\<exists>W'.\n                            A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<alpha> \\<langle>l', W'\\<rangle> \\<and>\n                            Approx\\<^sub>\\<beta> Z' \\<subseteq> W'", "from approx_\\<beta>_closure_\\<alpha>'[OF step_z_V'[OF step_beta(1-4)]]\n       alpha_interp.cla_mono[OF this(2)] this(1)"], ["proof (chain)\npicking this:\n  Approx\\<^sub>\\<beta> Z' \\<subseteq> Closure\\<^sub>\\<alpha> Z'\n  Closure\\<^sub>\\<alpha> Z' \\<subseteq> Closure\\<^sub>\\<alpha> W'\n  A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto> \\<langle>l', W'\\<rangle>", "show ?case"], ["proof (prove)\nusing this:\n  Approx\\<^sub>\\<beta> Z' \\<subseteq> Closure\\<^sub>\\<alpha> Z'\n  Closure\\<^sub>\\<alpha> Z' \\<subseteq> Closure\\<^sub>\\<alpha> W'\n  A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto> \\<langle>l', W'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>W'.\n       A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<alpha> \\<langle>l', W'\\<rangle> \\<and>\n       Approx\\<^sub>\\<beta> Z' \\<subseteq> W'", "by auto"], ["proof (state)\nthis:\n  \\<exists>W'.\n     A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<alpha> \\<langle>l', W'\\<rangle> \\<and>\n     Approx\\<^sub>\\<beta> Z' \\<subseteq> W'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alpha_beta_steps:\n  \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle> \\<Longrightarrow> valid_abstraction A X k \\<Longrightarrow> \\<forall>c\\<in>clk_set A. v c \\<le> n \\<Longrightarrow> Z \\<in> V'\n  \\<Longrightarrow> \\<exists> Z''. A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l', Z''\\<rangle> \\<and> Z' \\<subseteq> Z''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n     valid_abstraction A X (\\<lambda>x. real (k x));\n     \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Z''.\n                         A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l', Z''\\<rangle> \\<and>\n                         Z' \\<subseteq> Z''", "proof (induction rule: steps_z_beta.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A l Z.\n       \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l, Z''\\<rangle> \\<and>\n                            Z \\<subseteq> Z''\n 2. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n         \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Z''.\n                             A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l', Z''\\<rangle> \\<and>\n                             Z' \\<subseteq> Z'';\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''a.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                            Z'' \\<subseteq> Z''a", "case refl"], ["proof (state)\nthis:\n  valid_abstraction A_ X (\\<lambda>x. real (k x))\n  \\<forall>c\\<in>clk_set A_. v c \\<le> n\n  Z_ \\<in> V'\n\ngoal (2 subgoals):\n 1. \\<And>A l Z.\n       \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l, Z''\\<rangle> \\<and>\n                            Z \\<subseteq> Z''\n 2. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n         \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Z''.\n                             A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l', Z''\\<rangle> \\<and>\n                             Z' \\<subseteq> Z'';\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''a.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                            Z'' \\<subseteq> Z''a", "then"], ["proof (chain)\npicking this:\n  valid_abstraction A_ X (\\<lambda>x. real (k x))\n  \\<forall>c\\<in>clk_set A_. v c \\<le> n\n  Z_ \\<in> V'", "show ?case"], ["proof (prove)\nusing this:\n  valid_abstraction A_ X (\\<lambda>x. real (k x))\n  \\<forall>c\\<in>clk_set A_. v c \\<le> n\n  Z_ \\<in> V'\n\ngoal (1 subgoal):\n 1. \\<exists>Z''.\n       A_ \\<turnstile> \\<langle>l_, Z_\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l_, Z''\\<rangle> \\<and>\n       Z_ \\<subseteq> Z''", "by auto"], ["proof (state)\nthis:\n  \\<exists>Z''.\n     A_ \\<turnstile> \\<langle>l_, Z_\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l_, Z''\\<rangle> \\<and>\n     Z_ \\<subseteq> Z''\n\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n         \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Z''.\n                             A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l', Z''\\<rangle> \\<and>\n                             Z' \\<subseteq> Z'';\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''a.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                            Z'' \\<subseteq> Z''a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n         \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Z''.\n                             A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l', Z''\\<rangle> \\<and>\n                             Z' \\<subseteq> Z'';\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''a.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                            Z'' \\<subseteq> Z''a", "case (step A l Z l' Z' l'' Z'')"], ["proof (state)\nthis:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>\n  A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>\n  \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n   \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Z''.\n                       A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l', Z''\\<rangle> \\<and>\n                       Z' \\<subseteq> Z''\n  valid_abstraction A X (\\<lambda>x. real (k x))\n  \\<forall>c\\<in>clk_set A. v c \\<le> n\n  Z \\<in> V'\n\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n         \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Z''.\n                             A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l', Z''\\<rangle> \\<and>\n                             Z' \\<subseteq> Z'';\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''a.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                            Z'' \\<subseteq> Z''a", "then"], ["proof (chain)\npicking this:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>\n  A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>\n  \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n   \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Z''.\n                       A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l', Z''\\<rangle> \\<and>\n                       Z' \\<subseteq> Z''\n  valid_abstraction A X (\\<lambda>x. real (k x))\n  \\<forall>c\\<in>clk_set A. v c \\<le> n\n  Z \\<in> V'", "obtain Z''' where *: \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l',Z'''\\<rangle>\" \"Z' \\<subseteq> Z'''\""], ["proof (prove)\nusing this:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>\n  A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>\n  \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n   \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Z''.\n                       A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l', Z''\\<rangle> \\<and>\n                       Z' \\<subseteq> Z''\n  valid_abstraction A X (\\<lambda>x. real (k x))\n  \\<forall>c\\<in>clk_set A. v c \\<le> n\n  Z \\<in> V'\n\ngoal (1 subgoal):\n 1. (\\<And>Z'''.\n        \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l', Z'''\\<rangle>;\n         Z' \\<subseteq> Z'''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l', Z'''\\<rangle>\n  Z' \\<subseteq> Z'''\n\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n         \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Z''.\n                             A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l', Z''\\<rangle> \\<and>\n                             Z' \\<subseteq> Z'';\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''a.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                            Z'' \\<subseteq> Z''a", "from alpha_beta_step'[OF step.hyps(2) step.prems(1,2) steps_z_beta_V'[OF step.hyps(1) step.prems]\n                        alpha_interp.steps_z_alpha_V[OF this(1) V'_V] this(2)] step.prems"], ["proof (chain)\npicking this:\n  Z \\<in> V' \\<Longrightarrow>\n  \\<exists>W'.\n     A \\<turnstile> \\<langle>l', Z'''\\<rangle> \\<leadsto>\\<^sub>\\<alpha> \\<langle>l'', W'\\<rangle> \\<and>\n     Z'' \\<subseteq> W'\n  valid_abstraction A X (\\<lambda>x. real (k x))\n  \\<forall>c\\<in>clk_set A. v c \\<le> n\n  Z \\<in> V'", "obtain W' where \"A \\<turnstile> \\<langle>l', Z'''\\<rangle> \\<leadsto>\\<^sub>\\<alpha> \\<langle>l'',W'\\<rangle>\" \"Z'' \\<subseteq> W'\""], ["proof (prove)\nusing this:\n  Z \\<in> V' \\<Longrightarrow>\n  \\<exists>W'.\n     A \\<turnstile> \\<langle>l', Z'''\\<rangle> \\<leadsto>\\<^sub>\\<alpha> \\<langle>l'', W'\\<rangle> \\<and>\n     Z'' \\<subseteq> W'\n  valid_abstraction A X (\\<lambda>x. real (k x))\n  \\<forall>c\\<in>clk_set A. v c \\<le> n\n  Z \\<in> V'\n\ngoal (1 subgoal):\n 1. (\\<And>W'.\n        \\<lbrakk>A \\<turnstile> \\<langle>l', Z'''\\<rangle> \\<leadsto>\\<^sub>\\<alpha> \\<langle>l'', W'\\<rangle>;\n         Z'' \\<subseteq> W'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A \\<turnstile> \\<langle>l', Z'''\\<rangle> \\<leadsto>\\<^sub>\\<alpha> \\<langle>l'', W'\\<rangle>\n  Z'' \\<subseteq> W'\n\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n         \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Z''.\n                             A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l', Z''\\<rangle> \\<and>\n                             Z' \\<subseteq> Z'';\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        \\<forall>c\\<in>clk_set A. v c \\<le> n; Z \\<in> V'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''a.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                            Z'' \\<subseteq> Z''a", "with *"], ["proof (chain)\npicking this:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l', Z'''\\<rangle>\n  Z' \\<subseteq> Z'''\n  A \\<turnstile> \\<langle>l', Z'''\\<rangle> \\<leadsto>\\<^sub>\\<alpha> \\<langle>l'', W'\\<rangle>\n  Z'' \\<subseteq> W'", "show ?case"], ["proof (prove)\nusing this:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l', Z'''\\<rangle>\n  Z' \\<subseteq> Z'''\n  A \\<turnstile> \\<langle>l', Z'''\\<rangle> \\<leadsto>\\<^sub>\\<alpha> \\<langle>l'', W'\\<rangle>\n  Z'' \\<subseteq> W'\n\ngoal (1 subgoal):\n 1. \\<exists>Z''a.\n       A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l'', Z''a\\<rangle> \\<and>\n       Z'' \\<subseteq> Z''a", "by auto"], ["proof (state)\nthis:\n  \\<exists>Z''a.\n     A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l'', Z''a\\<rangle> \\<and>\n     Z'' \\<subseteq> Z''a\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary steps_z_beta_sound:\n  \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle> \\<Longrightarrow> \\<forall>c\\<in>clk_set A. v c \\<le> n \\<Longrightarrow> valid_abstraction A X k \\<Longrightarrow> Z \\<in> V' \\<Longrightarrow> Z' \\<noteq> {}\n  \\<Longrightarrow> \\<exists> Z''. A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l', Z''\\<rangle> \\<and> Z'' \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n     \\<forall>c\\<in>clk_set A. v c \\<le> n;\n     valid_abstraction A X (\\<lambda>x. real (k x)); Z \\<in> V';\n     Z' \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Z''.\n                         A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l', Z''\\<rangle> \\<and>\n                         Z'' \\<noteq> {}", "proof (goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n     \\<forall>c\\<in>clk_set A. v c \\<le> n;\n     valid_abstraction A X (\\<lambda>x. real (k x)); Z \\<in> V';\n     Z' \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Z''.\n                         A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l', Z''\\<rangle> \\<and>\n                         Z'' \\<noteq> {}", "case 1"], ["proof (state)\nthis:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>\n  \\<forall>c\\<in>clk_set A. v c \\<le> n\n  valid_abstraction A X (\\<lambda>x. real (k x))\n  Z \\<in> V'\n  Z' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n     \\<forall>c\\<in>clk_set A. v c \\<le> n;\n     valid_abstraction A X (\\<lambda>x. real (k x)); Z \\<in> V';\n     Z' \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Z''.\n                         A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l', Z''\\<rangle> \\<and>\n                         Z'' \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>\n  \\<forall>c\\<in>clk_set A. v c \\<le> n\n  valid_abstraction A X (\\<lambda>x. real (k x))\n  Z \\<in> V'\n  Z' \\<noteq> {}", "have \"Z \\<subseteq> V\""], ["proof (prove)\nusing this:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>\n  \\<forall>c\\<in>clk_set A. v c \\<le> n\n  valid_abstraction A X (\\<lambda>x. real (k x))\n  Z \\<in> V'\n  Z' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Z \\<subseteq> V", "unfolding V'_def"], ["proof (prove)\nusing this:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>\n  \\<forall>c\\<in>clk_set A. v c \\<le> n\n  valid_abstraction A X (\\<lambda>x. real (k x))\n  Z \\<in> {Z. Z \\<subseteq> V \\<and>\n              (\\<exists>M. Z = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n)}\n  Z' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Z \\<subseteq> V", "by auto"], ["proof (state)\nthis:\n  Z \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n     \\<forall>c\\<in>clk_set A. v c \\<le> n;\n     valid_abstraction A X (\\<lambda>x. real (k x)); Z \\<in> V';\n     Z' \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Z''.\n                         A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l', Z''\\<rangle> \\<and>\n                         Z'' \\<noteq> {}", "from alpha_beta_steps[OF 1(1,3,2,4)]"], ["proof (chain)\npicking this:\n  \\<exists>Z''.\n     A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l', Z''\\<rangle> \\<and>\n     Z' \\<subseteq> Z''", "obtain Z''' where *:\n    \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l',Z'''\\<rangle>\" \"Z' \\<subseteq> Z'''\""], ["proof (prove)\nusing this:\n  \\<exists>Z''.\n     A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l', Z''\\<rangle> \\<and>\n     Z' \\<subseteq> Z''\n\ngoal (1 subgoal):\n 1. (\\<And>Z'''.\n        \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l', Z'''\\<rangle>;\n         Z' \\<subseteq> Z'''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<alpha>* \\<langle>l', Z'''\\<rangle>\n  Z' \\<subseteq> Z'''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n     \\<forall>c\\<in>clk_set A. v c \\<le> n;\n     valid_abstraction A X (\\<lambda>x. real (k x)); Z \\<in> V';\n     Z' \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Z''.\n                         A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l', Z''\\<rangle> \\<and>\n                         Z'' \\<noteq> {}", "from alpha_interp.steps_z_alpha_closure_involutive[OF *(1) 1(3) \\<open>Z \\<subseteq> V\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>Z''.\n     A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l', Z''\\<rangle> \\<and>\n     Closure\\<^sub>\\<alpha> Z'''\n     \\<subseteq> Closure\\<^sub>\\<alpha> Z'' \\<and>\n     Z'' \\<subseteq> Z'''", "obtain Z'' where\n    Z'': \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l',Z''\\<rangle>\" \"Closure\\<^sub>\\<alpha> Z''' \\<subseteq> Closure\\<^sub>\\<alpha> Z''\" \"Z'' \\<subseteq> Z'''\""], ["proof (prove)\nusing this:\n  \\<exists>Z''.\n     A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l', Z''\\<rangle> \\<and>\n     Closure\\<^sub>\\<alpha> Z'''\n     \\<subseteq> Closure\\<^sub>\\<alpha> Z'' \\<and>\n     Z'' \\<subseteq> Z'''\n\ngoal (1 subgoal):\n 1. (\\<And>Z''.\n        \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l', Z''\\<rangle>;\n         Closure\\<^sub>\\<alpha> Z''' \\<subseteq> Closure\\<^sub>\\<alpha> Z'';\n         Z'' \\<subseteq> Z'''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l', Z''\\<rangle>\n  Closure\\<^sub>\\<alpha> Z''' \\<subseteq> Closure\\<^sub>\\<alpha> Z''\n  Z'' \\<subseteq> Z'''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n     \\<forall>c\\<in>clk_set A. v c \\<le> n;\n     valid_abstraction A X (\\<lambda>x. real (k x)); Z \\<in> V';\n     Z' \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Z''.\n                         A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l', Z''\\<rangle> \\<and>\n                         Z'' \\<noteq> {}", "with alpha_interp.closure_subs[OF alpha_interp.steps_z_alpha_V[OF *(1) \\<open>Z \\<subseteq> V\\<close>]] 1(5)\n    alpha_interp.cla_empty_iff[OF alpha_interp.steps_z_V, OF this(1) \\<open>Z \\<subseteq> V\\<close>] *(2)"], ["proof (chain)\npicking this:\n  Z''' \\<subseteq> Closure\\<^sub>\\<alpha> Z'''\n  Z' \\<noteq> {}\n  (Z'' = {}) = (Closure\\<^sub>\\<alpha> Z'' = {})\n  Z' \\<subseteq> Z'''\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l', Z''\\<rangle>\n  Closure\\<^sub>\\<alpha> Z''' \\<subseteq> Closure\\<^sub>\\<alpha> Z''\n  Z'' \\<subseteq> Z'''", "have \"Z'' \\<noteq> {}\""], ["proof (prove)\nusing this:\n  Z''' \\<subseteq> Closure\\<^sub>\\<alpha> Z'''\n  Z' \\<noteq> {}\n  (Z'' = {}) = (Closure\\<^sub>\\<alpha> Z'' = {})\n  Z' \\<subseteq> Z'''\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l', Z''\\<rangle>\n  Closure\\<^sub>\\<alpha> Z''' \\<subseteq> Closure\\<^sub>\\<alpha> Z''\n  Z'' \\<subseteq> Z'''\n\ngoal (1 subgoal):\n 1. Z'' \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  Z'' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n     \\<forall>c\\<in>clk_set A. v c \\<le> n;\n     valid_abstraction A X (\\<lambda>x. real (k x)); Z \\<in> V';\n     Z' \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Z''.\n                         A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l', Z''\\<rangle> \\<and>\n                         Z'' \\<noteq> {}", "with Z''"], ["proof (chain)\npicking this:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l', Z''\\<rangle>\n  Closure\\<^sub>\\<alpha> Z''' \\<subseteq> Closure\\<^sub>\\<alpha> Z''\n  Z'' \\<subseteq> Z'''\n  Z'' \\<noteq> {}", "show ?thesis"], ["proof (prove)\nusing this:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l', Z''\\<rangle>\n  Closure\\<^sub>\\<alpha> Z''' \\<subseteq> Closure\\<^sub>\\<alpha> Z''\n  Z'' \\<subseteq> Z'''\n  Z'' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>Z''.\n       A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l', Z''\\<rangle> \\<and>\n       Z'' \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  \\<exists>Z''.\n     A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l', Z''\\<rangle> \\<and>\n     Z'' \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Completeness\\<close>"], ["", "lemma apx_mono:\n  \"Z' \\<subseteq> V \\<Longrightarrow> Z \\<subseteq> Z' \\<Longrightarrow> Approx\\<^sub>\\<beta> Z \\<subseteq> Approx\\<^sub>\\<beta> Z'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Z' \\<subseteq> V; Z \\<subseteq> Z'\\<rbrakk>\n    \\<Longrightarrow> Approx\\<^sub>\\<beta> Z\n                      \\<subseteq> Approx\\<^sub>\\<beta> Z'", "proof (goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Z' \\<subseteq> V; Z \\<subseteq> Z'\\<rbrakk>\n    \\<Longrightarrow> Approx\\<^sub>\\<beta> Z\n                      \\<subseteq> Approx\\<^sub>\\<beta> Z'", "case 1"], ["proof (state)\nthis:\n  Z' \\<subseteq> V\n  Z \\<subseteq> Z'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Z' \\<subseteq> V; Z \\<subseteq> Z'\\<rbrakk>\n    \\<Longrightarrow> Approx\\<^sub>\\<beta> Z\n                      \\<subseteq> Approx\\<^sub>\\<beta> Z'", "with beta_interp.apx_in"], ["proof (chain)\npicking this:\n  ?Z \\<subseteq> V \\<Longrightarrow>\n  Approx\\<^sub>\\<beta> ?Z\n  \\<in> {S. \\<exists>U M.\n               S = \\<Union> U \\<and>\n               U \\<subseteq> \\<R>\\<^sub>\\<beta> \\<and>\n               ?Z \\<subseteq> S \\<and>\n               (S = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n) \\<and>\n               beta_interp.normalized M}\n  Z' \\<subseteq> V\n  Z \\<subseteq> Z'", "have\n    \"Approx\\<^sub>\\<beta> Z' \\<in> {S. \\<exists>U M. S = \\<Union>U \\<and> U \\<subseteq> \\<R>\\<^sub>\\<beta> \\<and> Z' \\<subseteq> S \\<and> beta_interp.vabstr S M\n                      \\<and> beta_interp.normalized M}\""], ["proof (prove)\nusing this:\n  ?Z \\<subseteq> V \\<Longrightarrow>\n  Approx\\<^sub>\\<beta> ?Z\n  \\<in> {S. \\<exists>U M.\n               S = \\<Union> U \\<and>\n               U \\<subseteq> \\<R>\\<^sub>\\<beta> \\<and>\n               ?Z \\<subseteq> S \\<and>\n               (S = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n) \\<and>\n               beta_interp.normalized M}\n  Z' \\<subseteq> V\n  Z \\<subseteq> Z'\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> Z'\n    \\<in> {S. \\<exists>U M.\n                 S = \\<Union> U \\<and>\n                 U \\<subseteq> \\<R>\\<^sub>\\<beta> \\<and>\n                 Z' \\<subseteq> S \\<and>\n                 (S = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n) \\<and>\n                 beta_interp.normalized M}", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> Z'\n  \\<in> {S. \\<exists>U M.\n               S = \\<Union> U \\<and>\n               U \\<subseteq> \\<R>\\<^sub>\\<beta> \\<and>\n               Z' \\<subseteq> S \\<and>\n               (S = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n) \\<and>\n               beta_interp.normalized M}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Z' \\<subseteq> V; Z \\<subseteq> Z'\\<rbrakk>\n    \\<Longrightarrow> Approx\\<^sub>\\<beta> Z\n                      \\<subseteq> Approx\\<^sub>\\<beta> Z'", "with 1"], ["proof (chain)\npicking this:\n  Z' \\<subseteq> V\n  Z \\<subseteq> Z'\n  Approx\\<^sub>\\<beta> Z'\n  \\<in> {S. \\<exists>U M.\n               S = \\<Union> U \\<and>\n               U \\<subseteq> \\<R>\\<^sub>\\<beta> \\<and>\n               Z' \\<subseteq> S \\<and>\n               (S = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n) \\<and>\n               beta_interp.normalized M}", "obtain U M where\n    \"Approx\\<^sub>\\<beta> Z' = \\<Union>U\" \"U \\<subseteq> \\<R>\\<^sub>\\<beta>\" \"Z \\<subseteq> Approx\\<^sub>\\<beta> Z'\" \"beta_interp.vabstr (Approx\\<^sub>\\<beta> Z') M\"\n    \"beta_interp.normalized M\""], ["proof (prove)\nusing this:\n  Z' \\<subseteq> V\n  Z \\<subseteq> Z'\n  Approx\\<^sub>\\<beta> Z'\n  \\<in> {S. \\<exists>U M.\n               S = \\<Union> U \\<and>\n               U \\<subseteq> \\<R>\\<^sub>\\<beta> \\<and>\n               Z' \\<subseteq> S \\<and>\n               (S = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n) \\<and>\n               beta_interp.normalized M}\n\ngoal (1 subgoal):\n 1. (\\<And>U M.\n        \\<lbrakk>Approx\\<^sub>\\<beta> Z' = \\<Union> U;\n         U \\<subseteq> \\<R>\\<^sub>\\<beta>;\n         Z \\<subseteq> Approx\\<^sub>\\<beta> Z';\n         Approx\\<^sub>\\<beta> Z' = [M]\\<^bsub>v,n\\<^esub> \\<and>\n         dbm_int M n;\n         beta_interp.normalized M\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> Z' = \\<Union> U\n  U \\<subseteq> \\<R>\\<^sub>\\<beta>\n  Z \\<subseteq> Approx\\<^sub>\\<beta> Z'\n  Approx\\<^sub>\\<beta> Z' = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n\n  beta_interp.normalized M\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Z' \\<subseteq> V; Z \\<subseteq> Z'\\<rbrakk>\n    \\<Longrightarrow> Approx\\<^sub>\\<beta> Z\n                      \\<subseteq> Approx\\<^sub>\\<beta> Z'", "with beta_interp.apx_min"], ["proof (chain)\npicking this:\n  \\<lbrakk>?S = \\<Union> ?U; ?U \\<subseteq> \\<R>\\<^sub>\\<beta>;\n   ?S = [?M]\\<^bsub>v,n\\<^esub>; dbm_int ?M n; beta_interp.normalized ?M;\n   ?Z \\<subseteq> ?S\\<rbrakk>\n  \\<Longrightarrow> Approx\\<^sub>\\<beta> ?Z \\<subseteq> ?S\n  Approx\\<^sub>\\<beta> Z' = \\<Union> U\n  U \\<subseteq> \\<R>\\<^sub>\\<beta>\n  Z \\<subseteq> Approx\\<^sub>\\<beta> Z'\n  Approx\\<^sub>\\<beta> Z' = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n\n  beta_interp.normalized M", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?S = \\<Union> ?U; ?U \\<subseteq> \\<R>\\<^sub>\\<beta>;\n   ?S = [?M]\\<^bsub>v,n\\<^esub>; dbm_int ?M n; beta_interp.normalized ?M;\n   ?Z \\<subseteq> ?S\\<rbrakk>\n  \\<Longrightarrow> Approx\\<^sub>\\<beta> ?Z \\<subseteq> ?S\n  Approx\\<^sub>\\<beta> Z' = \\<Union> U\n  U \\<subseteq> \\<R>\\<^sub>\\<beta>\n  Z \\<subseteq> Approx\\<^sub>\\<beta> Z'\n  Approx\\<^sub>\\<beta> Z' = [M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int M n\n  beta_interp.normalized M\n\ngoal (1 subgoal):\n 1. Approx\\<^sub>\\<beta> Z \\<subseteq> Approx\\<^sub>\\<beta> Z'", "by auto"], ["proof (state)\nthis:\n  Approx\\<^sub>\\<beta> Z \\<subseteq> Approx\\<^sub>\\<beta> Z'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step_z_beta_mono:\n  \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z'\\<rangle> \\<Longrightarrow> Z \\<subseteq> W \\<Longrightarrow> W \\<subseteq> V \\<Longrightarrow> \\<exists> W'. A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', W'\\<rangle> \\<and> Z' \\<subseteq> W'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z'\\<rangle>;\n     Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> \\<exists>W'.\n                         A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', W'\\<rangle> \\<and>\n                         Z' \\<subseteq> W'", "proof (goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z'\\<rangle>;\n     Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> \\<exists>W'.\n                         A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', W'\\<rangle> \\<and>\n                         Z' \\<subseteq> W'", "case 1"], ["proof (state)\nthis:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z'\\<rangle>\n  Z \\<subseteq> W\n  W \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z'\\<rangle>;\n     Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> \\<exists>W'.\n                         A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', W'\\<rangle> \\<and>\n                         Z' \\<subseteq> W'", "then"], ["proof (chain)\npicking this:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z'\\<rangle>\n  Z \\<subseteq> W\n  W \\<subseteq> V", "obtain Z'' where *: \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l',Z''\\<rangle>\" \"Z' = Approx\\<^sub>\\<beta> Z''\""], ["proof (prove)\nusing this:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z'\\<rangle>\n  Z \\<subseteq> W\n  W \\<subseteq> V\n\ngoal (1 subgoal):\n 1. (\\<And>Z''.\n        \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z''\\<rangle>;\n         Z' = Approx\\<^sub>\\<beta> Z''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z''\\<rangle>\n  Z' = Approx\\<^sub>\\<beta> Z''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z'\\<rangle>;\n     Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> \\<exists>W'.\n                         A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', W'\\<rangle> \\<and>\n                         Z' \\<subseteq> W'", "from alpha_interp.step_z_mono[OF this(1) 1(2)]"], ["proof (chain)\npicking this:\n  \\<exists>W'.\n     A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto> \\<langle>l', W'\\<rangle> \\<and>\n     Z'' \\<subseteq> W'", "obtain W' where\n    \"A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto> \\<langle>l',W'\\<rangle>\" \"Z'' \\<subseteq> W'\""], ["proof (prove)\nusing this:\n  \\<exists>W'.\n     A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto> \\<langle>l', W'\\<rangle> \\<and>\n     Z'' \\<subseteq> W'\n\ngoal (1 subgoal):\n 1. (\\<And>W'.\n        \\<lbrakk>A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto> \\<langle>l', W'\\<rangle>;\n         Z'' \\<subseteq> W'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto> \\<langle>l', W'\\<rangle>\n  Z'' \\<subseteq> W'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z'\\<rangle>;\n     Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> \\<exists>W'.\n                         A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', W'\\<rangle> \\<and>\n                         Z' \\<subseteq> W'", "moreover"], ["proof (state)\nthis:\n  A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto> \\<langle>l', W'\\<rangle>\n  Z'' \\<subseteq> W'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z'\\<rangle>;\n     Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> \\<exists>W'.\n                         A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', W'\\<rangle> \\<and>\n                         Z' \\<subseteq> W'", "with *(2) apx_mono[OF alpha_interp.step_z_V] \\<open>W \\<subseteq> V\\<close>"], ["proof (chain)\npicking this:\n  Z' = Approx\\<^sub>\\<beta> Z''\n  \\<lbrakk>?A1 \\<turnstile> \\<langle>?l1, ?Z1\\<rangle> \\<leadsto> \\<langle>?l'1, ?Z'\\<rangle>;\n   ?Z1 \\<subseteq> V; ?Z \\<subseteq> ?Z'\\<rbrakk>\n  \\<Longrightarrow> Approx\\<^sub>\\<beta> ?Z\n                    \\<subseteq> Approx\\<^sub>\\<beta> ?Z'\n  W \\<subseteq> V\n  A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto> \\<langle>l', W'\\<rangle>\n  Z'' \\<subseteq> W'", "have\n    \"Z' \\<subseteq> Approx\\<^sub>\\<beta> W'\""], ["proof (prove)\nusing this:\n  Z' = Approx\\<^sub>\\<beta> Z''\n  \\<lbrakk>?A1 \\<turnstile> \\<langle>?l1, ?Z1\\<rangle> \\<leadsto> \\<langle>?l'1, ?Z'\\<rangle>;\n   ?Z1 \\<subseteq> V; ?Z \\<subseteq> ?Z'\\<rbrakk>\n  \\<Longrightarrow> Approx\\<^sub>\\<beta> ?Z\n                    \\<subseteq> Approx\\<^sub>\\<beta> ?Z'\n  W \\<subseteq> V\n  A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto> \\<langle>l', W'\\<rangle>\n  Z'' \\<subseteq> W'\n\ngoal (1 subgoal):\n 1. Z' \\<subseteq> Approx\\<^sub>\\<beta> W'", "by metis"], ["proof (state)\nthis:\n  Z' \\<subseteq> Approx\\<^sub>\\<beta> W'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z'\\<rangle>;\n     Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> \\<exists>W'.\n                         A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', W'\\<rangle> \\<and>\n                         Z' \\<subseteq> W'", "ultimately"], ["proof (chain)\npicking this:\n  A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto> \\<langle>l', W'\\<rangle>\n  Z'' \\<subseteq> W'\n  Z' \\<subseteq> Approx\\<^sub>\\<beta> W'", "show ?case"], ["proof (prove)\nusing this:\n  A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto> \\<langle>l', W'\\<rangle>\n  Z'' \\<subseteq> W'\n  Z' \\<subseteq> Approx\\<^sub>\\<beta> W'\n\ngoal (1 subgoal):\n 1. \\<exists>W'.\n       A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', W'\\<rangle> \\<and>\n       Z' \\<subseteq> W'", "by blast"], ["proof (state)\nthis:\n  \\<exists>W'.\n     A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', W'\\<rangle> \\<and>\n     Z' \\<subseteq> W'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma steps_z_beta_V: \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle> \\<Longrightarrow> Z \\<subseteq> V \\<Longrightarrow> Z' \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n     Z \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> Z' \\<subseteq> V", "proof (induction rule: steps_z_beta.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A l Z. Z \\<subseteq> V \\<Longrightarrow> Z \\<subseteq> V\n 2. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        Z \\<subseteq> V \\<Longrightarrow> Z' \\<subseteq> V;\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        Z \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> Z'' \\<subseteq> V", "case refl"], ["proof (state)\nthis:\n  Z_ \\<subseteq> V\n\ngoal (2 subgoals):\n 1. \\<And>A l Z. Z \\<subseteq> V \\<Longrightarrow> Z \\<subseteq> V\n 2. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        Z \\<subseteq> V \\<Longrightarrow> Z' \\<subseteq> V;\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        Z \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> Z'' \\<subseteq> V", "then"], ["proof (chain)\npicking this:\n  Z_ \\<subseteq> V", "show ?case"], ["proof (prove)\nusing this:\n  Z_ \\<subseteq> V\n\ngoal (1 subgoal):\n 1. Z_ \\<subseteq> V", "by blast"], ["proof (state)\nthis:\n  Z_ \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        Z \\<subseteq> V \\<Longrightarrow> Z' \\<subseteq> V;\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        Z \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> Z'' \\<subseteq> V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        Z \\<subseteq> V \\<Longrightarrow> Z' \\<subseteq> V;\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        Z \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> Z'' \\<subseteq> V", "case (step A l Z l' Z' l'' Z'')"], ["proof (state)\nthis:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>\n  A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>\n  Z \\<subseteq> V \\<Longrightarrow> Z' \\<subseteq> V\n  Z \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        Z \\<subseteq> V \\<Longrightarrow> Z' \\<subseteq> V;\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        Z \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> Z'' \\<subseteq> V", "then"], ["proof (chain)\npicking this:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>\n  A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>\n  Z \\<subseteq> V \\<Longrightarrow> Z' \\<subseteq> V\n  Z \\<subseteq> V", "obtain Z''' where \"A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto> \\<langle>l'',Z'''\\<rangle>\" \"Z'' = Approx\\<^sub>\\<beta> Z'''\""], ["proof (prove)\nusing this:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>\n  A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>\n  Z \\<subseteq> V \\<Longrightarrow> Z' \\<subseteq> V\n  Z \\<subseteq> V\n\ngoal (1 subgoal):\n 1. (\\<And>Z'''.\n        \\<lbrakk>A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto> \\<langle>l'', Z'''\\<rangle>;\n         Z'' = Approx\\<^sub>\\<beta> Z'''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto> \\<langle>l'', Z'''\\<rangle>\n  Z'' = Approx\\<^sub>\\<beta> Z'''\n\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        Z \\<subseteq> V \\<Longrightarrow> Z' \\<subseteq> V;\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        Z \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> Z'' \\<subseteq> V", "with alpha_interp.step_z_V[OF this(1)] apx_V step(3,4)"], ["proof (chain)\npicking this:\n  Z' \\<subseteq> V \\<Longrightarrow> Z''' \\<subseteq> V\n  ?Z \\<subseteq> V \\<Longrightarrow> Approx\\<^sub>\\<beta> ?Z \\<subseteq> V\n  Z \\<subseteq> V \\<Longrightarrow> Z' \\<subseteq> V\n  Z \\<subseteq> V\n  A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto> \\<langle>l'', Z'''\\<rangle>\n  Z'' = Approx\\<^sub>\\<beta> Z'''", "show \"Z'' \\<subseteq> V\""], ["proof (prove)\nusing this:\n  Z' \\<subseteq> V \\<Longrightarrow> Z''' \\<subseteq> V\n  ?Z \\<subseteq> V \\<Longrightarrow> Approx\\<^sub>\\<beta> ?Z \\<subseteq> V\n  Z \\<subseteq> V \\<Longrightarrow> Z' \\<subseteq> V\n  Z \\<subseteq> V\n  A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto> \\<langle>l'', Z'''\\<rangle>\n  Z'' = Approx\\<^sub>\\<beta> Z'''\n\ngoal (1 subgoal):\n 1. Z'' \\<subseteq> V", "by auto"], ["proof (state)\nthis:\n  Z'' \\<subseteq> V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma steps_z_beta_mono:\n  \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle> \\<Longrightarrow> Z \\<subseteq> W \\<Longrightarrow> W \\<subseteq> V \\<Longrightarrow> \\<exists> W'. A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', W'\\<rangle> \\<and> Z' \\<subseteq> W'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n     Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> \\<exists>W'.\n                         A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', W'\\<rangle> \\<and>\n                         Z' \\<subseteq> W'", "proof (induction rule: steps_z_beta.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A l Z.\n       \\<lbrakk>Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>W'.\n                            A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l, W'\\<rangle> \\<and>\n                            Z \\<subseteq> W'\n 2. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        \\<lbrakk>Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n        \\<Longrightarrow> \\<exists>W'.\n                             A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', W'\\<rangle> \\<and>\n                             Z' \\<subseteq> W';\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>W'.\n                            A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', W'\\<rangle> \\<and>\n                            Z'' \\<subseteq> W'", "case refl"], ["proof (state)\nthis:\n  Z_ \\<subseteq> W\n  W \\<subseteq> V\n\ngoal (2 subgoals):\n 1. \\<And>A l Z.\n       \\<lbrakk>Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>W'.\n                            A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l, W'\\<rangle> \\<and>\n                            Z \\<subseteq> W'\n 2. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        \\<lbrakk>Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n        \\<Longrightarrow> \\<exists>W'.\n                             A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', W'\\<rangle> \\<and>\n                             Z' \\<subseteq> W';\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>W'.\n                            A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', W'\\<rangle> \\<and>\n                            Z'' \\<subseteq> W'", "then"], ["proof (chain)\npicking this:\n  Z_ \\<subseteq> W\n  W \\<subseteq> V", "show ?case"], ["proof (prove)\nusing this:\n  Z_ \\<subseteq> W\n  W \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<exists>W'.\n       A_ \\<turnstile> \\<langle>l_, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l_, W'\\<rangle> \\<and>\n       Z_ \\<subseteq> W'", "by auto"], ["proof (state)\nthis:\n  \\<exists>W'.\n     A_ \\<turnstile> \\<langle>l_, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l_, W'\\<rangle> \\<and>\n     Z_ \\<subseteq> W'\n\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        \\<lbrakk>Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n        \\<Longrightarrow> \\<exists>W'.\n                             A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', W'\\<rangle> \\<and>\n                             Z' \\<subseteq> W';\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>W'.\n                            A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', W'\\<rangle> \\<and>\n                            Z'' \\<subseteq> W'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        \\<lbrakk>Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n        \\<Longrightarrow> \\<exists>W'.\n                             A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', W'\\<rangle> \\<and>\n                             Z' \\<subseteq> W';\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>W'.\n                            A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', W'\\<rangle> \\<and>\n                            Z'' \\<subseteq> W'", "case (step A l Z l' Z' l'' Z'')"], ["proof (state)\nthis:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>\n  A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>\n  \\<lbrakk>Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n  \\<Longrightarrow> \\<exists>W'.\n                       A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', W'\\<rangle> \\<and>\n                       Z' \\<subseteq> W'\n  Z \\<subseteq> W\n  W \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        \\<lbrakk>Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n        \\<Longrightarrow> \\<exists>W'.\n                             A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', W'\\<rangle> \\<and>\n                             Z' \\<subseteq> W';\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>W'.\n                            A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', W'\\<rangle> \\<and>\n                            Z'' \\<subseteq> W'", "then"], ["proof (chain)\npicking this:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>\n  A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>\n  \\<lbrakk>Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n  \\<Longrightarrow> \\<exists>W'.\n                       A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', W'\\<rangle> \\<and>\n                       Z' \\<subseteq> W'\n  Z \\<subseteq> W\n  W \\<subseteq> V", "obtain W' where \"A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l',W'\\<rangle>\" \"Z' \\<subseteq> W'\""], ["proof (prove)\nusing this:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>\n  A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>\n  \\<lbrakk>Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n  \\<Longrightarrow> \\<exists>W'.\n                       A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', W'\\<rangle> \\<and>\n                       Z' \\<subseteq> W'\n  Z \\<subseteq> W\n  W \\<subseteq> V\n\ngoal (1 subgoal):\n 1. (\\<And>W'.\n        \\<lbrakk>A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', W'\\<rangle>;\n         Z' \\<subseteq> W'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', W'\\<rangle>\n  Z' \\<subseteq> W'\n\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z'\\<rangle>;\n        \\<lbrakk>Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n        \\<Longrightarrow> \\<exists>W'.\n                             A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', W'\\<rangle> \\<and>\n                             Z' \\<subseteq> W';\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', Z''\\<rangle>;\n        Z \\<subseteq> W; W \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>W'.\n                            A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', W'\\<rangle> \\<and>\n                            Z'' \\<subseteq> W'", "with step_z_beta_mono[OF step(2) this(2) steps_z_beta_V[OF this(1) step(5)]]"], ["proof (chain)\npicking this:\n  \\<exists>W'a.\n     A \\<turnstile> \\<langle>l', W'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', W'a\\<rangle> \\<and>\n     Z'' \\<subseteq> W'a\n  A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', W'\\<rangle>\n  Z' \\<subseteq> W'", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>W'a.\n     A \\<turnstile> \\<langle>l', W'\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l'', W'a\\<rangle> \\<and>\n     Z'' \\<subseteq> W'a\n  A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', W'\\<rangle>\n  Z' \\<subseteq> W'\n\ngoal (1 subgoal):\n 1. \\<exists>W'.\n       A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', W'\\<rangle> \\<and>\n       Z'' \\<subseteq> W'", "by blast"], ["proof (state)\nthis:\n  \\<exists>W'.\n     A \\<turnstile> \\<langle>l, W\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', W'\\<rangle> \\<and>\n     Z'' \\<subseteq> W'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma steps_z_beta_alt:\n  \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z'\\<rangle> \\<Longrightarrow> A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''\\<rangle> \\<Longrightarrow> A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta> \\<langle>l', Z'\\<rangle>;\n     A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''\\<rangle>", "by (rotate_tac, induction rule: steps_z_beta.induct) blast+"], ["", "lemma steps_z_beta_complete:\n  \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l', Z'\\<rangle> \\<Longrightarrow> valid_abstraction A X k \\<Longrightarrow> Z \\<subseteq> V\n  \\<Longrightarrow> \\<exists> Z''. A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l',Z''\\<rangle> \\<and> Z' \\<subseteq> Z''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l', Z'\\<rangle>;\n     valid_abstraction A X (\\<lambda>x. real (k x));\n     Z \\<subseteq> V\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Z''.\n                         A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z''\\<rangle> \\<and>\n                         Z' \\<subseteq> Z''", "proof (induction rule: steps_z.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A l Z.\n       \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n        Z \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l, Z''\\<rangle> \\<and>\n                            Z \\<subseteq> Z''\n 2. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>* \\<langle>l'', Z''\\<rangle>;\n        \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n         Z' \\<subseteq> V\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Z''a.\n                             A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                             Z'' \\<subseteq> Z''a;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        Z \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''a.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                            Z'' \\<subseteq> Z''a", "case refl"], ["proof (state)\nthis:\n  valid_abstraction A_ X (\\<lambda>x. real (k x))\n  Z_ \\<subseteq> V\n\ngoal (2 subgoals):\n 1. \\<And>A l Z.\n       \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n        Z \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l, Z''\\<rangle> \\<and>\n                            Z \\<subseteq> Z''\n 2. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>* \\<langle>l'', Z''\\<rangle>;\n        \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n         Z' \\<subseteq> V\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Z''a.\n                             A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                             Z'' \\<subseteq> Z''a;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        Z \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''a.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                            Z'' \\<subseteq> Z''a", "with apx_empty_iff"], ["proof (chain)\npicking this:\n  \\<lbrakk>?Z \\<subseteq> V;\n   ?Z = [?M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int ?M n\\<rbrakk>\n  \\<Longrightarrow> (?Z = {}) = (Approx\\<^sub>\\<beta> ?Z = {})\n  valid_abstraction A_ X (\\<lambda>x. real (k x))\n  Z_ \\<subseteq> V", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?Z \\<subseteq> V;\n   ?Z = [?M]\\<^bsub>v,n\\<^esub> \\<and> dbm_int ?M n\\<rbrakk>\n  \\<Longrightarrow> (?Z = {}) = (Approx\\<^sub>\\<beta> ?Z = {})\n  valid_abstraction A_ X (\\<lambda>x. real (k x))\n  Z_ \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<exists>Z''.\n       A_ \\<turnstile> \\<langle>l_, Z_\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l_, Z''\\<rangle> \\<and>\n       Z_ \\<subseteq> Z''", "by blast"], ["proof (state)\nthis:\n  \\<exists>Z''.\n     A_ \\<turnstile> \\<langle>l_, Z_\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l_, Z''\\<rangle> \\<and>\n     Z_ \\<subseteq> Z''\n\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>* \\<langle>l'', Z''\\<rangle>;\n        \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n         Z' \\<subseteq> V\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Z''a.\n                             A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                             Z'' \\<subseteq> Z''a;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        Z \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''a.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                            Z'' \\<subseteq> Z''a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>* \\<langle>l'', Z''\\<rangle>;\n        \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n         Z' \\<subseteq> V\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Z''a.\n                             A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                             Z'' \\<subseteq> Z''a;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        Z \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''a.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                            Z'' \\<subseteq> Z''a", "case (step A l Z l' Z' l'' Z'')"], ["proof (state)\nthis:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>\n  A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>* \\<langle>l'', Z''\\<rangle>\n  \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n   Z' \\<subseteq> V\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Z''a.\n                       A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                       Z'' \\<subseteq> Z''a\n  valid_abstraction A X (\\<lambda>x. real (k x))\n  Z \\<subseteq> V\n\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>* \\<langle>l'', Z''\\<rangle>;\n        \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n         Z' \\<subseteq> V\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Z''a.\n                             A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                             Z'' \\<subseteq> Z''a;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        Z \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''a.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                            Z'' \\<subseteq> Z''a", "with alpha_interp.step_z_V[OF this(1,5)]"], ["proof (chain)\npicking this:\n  Z' \\<subseteq> V\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>\n  A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>* \\<langle>l'', Z''\\<rangle>\n  \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n   Z' \\<subseteq> V\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Z''a.\n                       A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                       Z'' \\<subseteq> Z''a\n  valid_abstraction A X (\\<lambda>x. real (k x))\n  Z \\<subseteq> V", "obtain Z''' where\n    \"A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'',Z'''\\<rangle>\" \"Z'' \\<subseteq> Z'''\""], ["proof (prove)\nusing this:\n  Z' \\<subseteq> V\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>\n  A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>* \\<langle>l'', Z''\\<rangle>\n  \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n   Z' \\<subseteq> V\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Z''a.\n                       A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                       Z'' \\<subseteq> Z''a\n  valid_abstraction A X (\\<lambda>x. real (k x))\n  Z \\<subseteq> V\n\ngoal (1 subgoal):\n 1. (\\<And>Z'''.\n        \\<lbrakk>A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z'''\\<rangle>;\n         Z'' \\<subseteq> Z'''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z'''\\<rangle>\n  Z'' \\<subseteq> Z'''\n\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>* \\<langle>l'', Z''\\<rangle>;\n        \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n         Z' \\<subseteq> V\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Z''a.\n                             A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                             Z'' \\<subseteq> Z''a;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        Z \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''a.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                            Z'' \\<subseteq> Z''a", "with steps_z_beta_mono[OF this(1) beta_interp.apx_subset apx_V[OF alpha_interp.step_z_V[OF step(1,5)]]]"], ["proof (chain)\npicking this:\n  \\<exists>W'.\n     A \\<turnstile> \\<langle>l', Approx\\<^sub>\\<beta>\n                                  Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', W'\\<rangle> \\<and>\n     Z''' \\<subseteq> W'\n  A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z'''\\<rangle>\n  Z'' \\<subseteq> Z'''", "obtain W' where \"A \\<turnstile> \\<langle>l', Approx\\<^sub>\\<beta> Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', W'\\<rangle>\" \" Z'' \\<subseteq> W'\""], ["proof (prove)\nusing this:\n  \\<exists>W'.\n     A \\<turnstile> \\<langle>l', Approx\\<^sub>\\<beta>\n                                  Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', W'\\<rangle> \\<and>\n     Z''' \\<subseteq> W'\n  A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z'''\\<rangle>\n  Z'' \\<subseteq> Z'''\n\ngoal (1 subgoal):\n 1. (\\<And>W'.\n        \\<lbrakk>A \\<turnstile> \\<langle>l', Approx\\<^sub>\\<beta>\n        Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', W'\\<rangle>;\n         Z'' \\<subseteq> W'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  A \\<turnstile> \\<langle>l', Approx\\<^sub>\\<beta>\n                               Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', W'\\<rangle>\n  Z'' \\<subseteq> W'\n\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>* \\<langle>l'', Z''\\<rangle>;\n        \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n         Z' \\<subseteq> V\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Z''a.\n                             A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                             Z'' \\<subseteq> Z''a;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        Z \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''a.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                            Z'' \\<subseteq> Z''a", "moreover"], ["proof (state)\nthis:\n  A \\<turnstile> \\<langle>l', Approx\\<^sub>\\<beta>\n                               Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', W'\\<rangle>\n  Z'' \\<subseteq> W'\n\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>* \\<langle>l'', Z''\\<rangle>;\n        \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n         Z' \\<subseteq> V\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Z''a.\n                             A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                             Z'' \\<subseteq> Z''a;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        Z \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''a.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                            Z'' \\<subseteq> Z''a", "with step(1)"], ["proof (chain)\npicking this:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>\n  A \\<turnstile> \\<langle>l', Approx\\<^sub>\\<beta>\n                               Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', W'\\<rangle>\n  Z'' \\<subseteq> W'", "have \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'',W'\\<rangle>\""], ["proof (prove)\nusing this:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>\n  A \\<turnstile> \\<langle>l', Approx\\<^sub>\\<beta>\n                               Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', W'\\<rangle>\n  Z'' \\<subseteq> W'\n\ngoal (1 subgoal):\n 1. A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', W'\\<rangle>", "by (auto intro: steps_z_beta_alt)"], ["proof (state)\nthis:\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', W'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>A l Z l' Z' l'' Z''.\n       \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto> \\<langle>l', Z'\\<rangle>;\n        A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>* \\<langle>l'', Z''\\<rangle>;\n        \\<lbrakk>valid_abstraction A X (\\<lambda>x. real (k x));\n         Z' \\<subseteq> V\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Z''a.\n                             A \\<turnstile> \\<langle>l', Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                             Z'' \\<subseteq> Z''a;\n        valid_abstraction A X (\\<lambda>x. real (k x));\n        Z \\<subseteq> V\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Z''a.\n                            A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''a\\<rangle> \\<and>\n                            Z'' \\<subseteq> Z''a", "ultimately"], ["proof (chain)\npicking this:\n  A \\<turnstile> \\<langle>l', Approx\\<^sub>\\<beta>\n                               Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', W'\\<rangle>\n  Z'' \\<subseteq> W'\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', W'\\<rangle>", "show ?case"], ["proof (prove)\nusing this:\n  A \\<turnstile> \\<langle>l', Approx\\<^sub>\\<beta>\n                               Z'\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', W'\\<rangle>\n  Z'' \\<subseteq> W'\n  A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', W'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>Z''a.\n       A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''a\\<rangle> \\<and>\n       Z'' \\<subseteq> Z''a", "by auto"], ["proof (state)\nthis:\n  \\<exists>Z''a.\n     A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l'', Z''a\\<rangle> \\<and>\n     Z'' \\<subseteq> Z''a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma steps_z_beta_complete':\n  \"A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l',Z'\\<rangle> \\<Longrightarrow> valid_abstraction A X k \\<Longrightarrow> Z \\<subseteq> V \\<Longrightarrow> Z' \\<noteq> {}\n  \\<Longrightarrow> \\<exists> Z''. A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l',Z''\\<rangle> \\<and> Z'' \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l', Z'\\<rangle>;\n     valid_abstraction A X (\\<lambda>x. real (k x)); Z \\<subseteq> V;\n     Z' \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Z''.\n                         A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z''\\<rangle> \\<and>\n                         Z'' \\<noteq> {}", "using steps_z_beta_complete"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<turnstile> \\<langle>?l, ?Z\\<rangle> \\<leadsto>* \\<langle>?l', ?Z'\\<rangle>;\n   valid_abstraction ?A X (\\<lambda>x. real (k x));\n   ?Z \\<subseteq> V\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Z''.\n                       ?A \\<turnstile> \\<langle>?l, ?Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>?l', Z''\\<rangle> \\<and>\n                       ?Z' \\<subseteq> Z''\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>* \\<langle>l', Z'\\<rangle>;\n     valid_abstraction A X (\\<lambda>x. real (k x)); Z \\<subseteq> V;\n     Z' \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>Z''.\n                         A \\<turnstile> \\<langle>l, Z\\<rangle> \\<leadsto>\\<^sub>\\<beta>* \\<langle>l', Z''\\<rangle> \\<and>\n                         Z'' \\<noteq> {}", "by fast"], ["", "end"], ["", "end"]]}