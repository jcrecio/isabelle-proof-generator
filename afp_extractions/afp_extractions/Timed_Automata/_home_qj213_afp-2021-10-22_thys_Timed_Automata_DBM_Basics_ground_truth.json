{"file_name": "/home/qj213/afp-2021-10-22/thys/Timed_Automata/DBM_Basics.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Timed_Automata", "problem_names": ["lemma upd_1:\nassumes \"j \\<le> n\"\nshows \"DBM_upd M1 f (Suc m) n N (Suc m) j = DBM_upd M1 f (Suc m) j N (Suc m) j\"", "lemma upd_2:\nassumes \"i \\<le> m\"\nshows \"DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f (Suc m) 0 N i j\"", "lemma upd_3:\nassumes \"m \\<le> N\" \"n \\<le> N\" \"j \\<le> n\" \"i \\<le> m\"\nshows \"(DBM_upd M1 f m n N) i j = (DBM_upd M1 f i j N) i j\"", "lemma upd_id:\n  assumes \"m \\<le> N\" \"n \\<le> N\" \"i \\<le> m\" \"j \\<le> n\"\n  shows \"(DBM_upd M1 f m n N) i j = f i j\"", "lemma dbm_entry_val_mono_1:\n  \"dbm_entry_val u (Some c) (Some c') b \\<Longrightarrow> b \\<preceq> b' \\<Longrightarrow> dbm_entry_val u (Some c) (Some c') b'\"", "lemma dbm_entry_val_mono_2:\n  \"dbm_entry_val u None (Some c) b \\<Longrightarrow> b \\<preceq> b' \\<Longrightarrow> dbm_entry_val u None (Some c) b'\"", "lemma dbm_entry_val_mono_3:\n  \"dbm_entry_val u (Some c) None b \\<Longrightarrow> b \\<preceq> b' \\<Longrightarrow> dbm_entry_val u (Some c) None b'\"", "lemma DBM_le_subset:\n  \"\\<forall> i j. i \\<le> n \\<longrightarrow> j \\<le> n \\<longrightarrow> M i j \\<preceq> M' i j \\<Longrightarrow> u \\<in> [M]\\<^bsub>v,n\\<^esub> \\<Longrightarrow> u \\<in> [M']\\<^bsub>v,n\\<^esub>\"", "lemmas (in linordered_ab_monoid_add) comm = add.commute", "lemma sum_gt_neutral_dest':\n  \"(a :: (('a :: time) DBMEntry)) \\<ge> \\<one> \\<Longrightarrow> a + b > \\<one> \\<Longrightarrow> \\<exists> d. Le d \\<le> a \\<and> Le (-d) \\<le> b \\<and> d \\<ge> 0\"", "lemma sum_gt_neutral_dest:\n  \"(a :: (('a :: time) DBMEntry)) + b > \\<one> \\<Longrightarrow> \\<exists> d. Le d \\<le> a \\<and> Le (-d) \\<le> b\"", "lemma DBM_val_bounded_neg_cycle1:\nfixes i xs assumes\n  bounded: \"DBM_val_bounded v u M n\" and A:\"i \\<le> n\" \"set xs \\<subseteq> {0..n}\" \"len M i i xs < \\<one>\" and\n  surj_on: \"\\<forall> k \\<le> n. k > 0 \\<longrightarrow> (\\<exists> c. v c = k)\" and at_most: \"i \\<noteq> 0\" \"cnt 0 xs \\<le> 1\"\nshows False", "lemma cnt_0_I:\n  \"x \\<notin> set xs \\<Longrightarrow> cnt x xs = 0\"", "lemma distinct_cnt: \"distinct xs \\<Longrightarrow> cnt x xs \\<le> 1\"", "lemma DBM_val_bounded_neg_cycle:\nfixes i xs assumes\n  bounded: \"DBM_val_bounded v u M n\" and A:\"i \\<le> n\" \"set xs \\<subseteq> {0..n}\" \"len M i i xs < \\<one>\" and\n  surj_on: \"\\<forall> k \\<le> n. k > 0 \\<longrightarrow> (\\<exists> c. v c = k)\"\nshows False", "lemma D_dest: \"x = D m i j k \\<Longrightarrow>\n  x \\<in> {len m i j xs |xs. set xs \\<subseteq> {0..k} \\<and> i \\<notin> set xs \\<and> j \\<notin> set xs \\<and> distinct xs}\"", "lemma FW_zone_equiv:\n  \"\\<forall> k \\<le> n. k > 0 \\<longrightarrow> (\\<exists> c. v c = k) \\<Longrightarrow> [M]\\<^bsub>v,n\\<^esub> = [FW M n]\\<^bsub>v,n\\<^esub>\"", "lemma new_negative_cycle_aux':\n  fixes M :: \"('a :: time) DBM\"\n  fixes i j d\n  defines \"M' \\<equiv> \\<lambda> i' j'. if (i' = i \\<and> j' = j) then Le d\n                       else if (i' = j \\<and> j' = i) then Le (-d)\n                       else M i' j'\"\n  assumes \"i \\<le> n\" \"j \\<le> n\" \"set xs \\<subseteq> {0..n}\" \"cycle_free M n\" \"length xs = m\"\n  assumes \"len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\"\n  assumes \"i \\<noteq> j\"\n  shows \"\\<exists>xs. set xs \\<subseteq> {0..n} \\<and> j \\<notin> set xs \\<and> i \\<notin> set xs\n              \\<and> (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\"", "lemma new_negative_cycle_aux:\n  fixes M :: \"('a :: time) DBM\"\n  fixes i d\n  defines \"M' \\<equiv> \\<lambda> i' j'. if (i' = i \\<and> j' = 0) then Le d\n                       else if (i' = 0 \\<and> j' = i) then Le (-d)\n                       else M i' j'\"\n  assumes \"i \\<le> n\" \"set xs \\<subseteq> {0..n}\" \"cycle_free M n\" \"length xs = m\"\n  assumes \"len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>\"\n  assumes \"i \\<noteq> 0\"\n  shows \"\\<exists>xs. set xs \\<subseteq> {0..n} \\<and> 0 \\<notin> set xs \\<and> i \\<notin> set xs\n              \\<and> (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\"", "theorem fix_index':\n  fixes M :: \"(('a :: time) DBMEntry) mat\"\n  assumes \"Le r \\<le> M i j\" \"Le (-r) \\<le> M j i\" \"cycle_free M n\" \"canonical M n\" \"i \\<le> n\" \"j \\<le> n\" \"i \\<noteq> j\"\n  defines \"M' \\<equiv> \\<lambda> i' j'. if (i' = i \\<and> j' = j) then Le r\n                       else if (i' = j \\<and> j' = i) then Le (-r)\n                       else M i' j'\"\n  shows \"(\\<forall> u. DBM_val_bounded v u M' n \\<longrightarrow> DBM_val_bounded v u M n) \\<and> cycle_free M' n\"", "lemma fix_index:\n  fixes M :: \"(('a :: time) DBMEntry) mat\"\n  assumes \"M 0 i + M i 0 > \\<one>\" \"cycle_free M n\" \"canonical M n\" \"i \\<le> n\" \"i \\<noteq> 0\"\n  shows\n  \"\\<exists> (M' :: ('a DBMEntry) mat). ((\\<exists> u. DBM_val_bounded v u M' n) \\<longrightarrow> (\\<exists> u. DBM_val_bounded v u M n))\n     \\<and> M' 0 i + M' i 0 = \\<one> \\<and> cycle_free M' n\n     \\<and> (\\<forall> j. i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow> M' 0 j + M' j 0 = \\<one>)\n     \\<and> (\\<forall> j. i \\<noteq> j \\<and> M 0 j + M j 0 > \\<one> \\<longrightarrow> M' 0 j + M' j 0 > \\<one>)\"", "lemma FW_not_empty:\n  \"DBM_val_bounded v u (FW M' n) n \\<Longrightarrow> DBM_val_bounded v u M' n\"", "lemma fix_indices:\n  fixes M :: \"(('a :: time) DBMEntry) mat\"\n  assumes \"set xs \\<subseteq> {0..n}\" \"distinct xs\"\n  assumes \"cyc_free M n\" \"canonical M n\"\n  shows \n  \"\\<exists> (M' :: ('a DBMEntry) mat). ((\\<exists> u. DBM_val_bounded v u M' n) \\<longrightarrow> (\\<exists> u. DBM_val_bounded v u M n))\n     \\<and> (\\<forall> i \\<in> set xs. i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and> cyc_free M' n\n     \\<and> (\\<forall> i\\<le>n. i \\<notin> set xs \\<and> M 0 i + M i 0 = \\<one> \\<longrightarrow> M' 0 i + M' i 0 = \\<one>)\"", "lemma cyc_free_obtains_valuation:\n  \"cyc_free M n \\<Longrightarrow> \\<forall> c. v c \\<le> n \\<longrightarrow> v c > 0 \\<Longrightarrow> \\<exists> u. DBM_val_bounded v u M n\"", "theorem FW_detects_empty_zone:\n  \"\\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k) \\<Longrightarrow> \\<forall> c. v c \\<le> n \\<longrightarrow> v c > 0\n  \\<Longrightarrow> [FW M n]\\<^bsub>v,n\\<^esub> = {} \\<longleftrightarrow> (\\<exists> i\\<le>n. (FW M n) i i < Le 0)\"", "lemma cyc_free_not_empty:\n  assumes \"cyc_free M n\" \"\\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\"\n  shows \"[(M :: ('a :: time) DBM)]\\<^bsub>v,n\\<^esub> \\<noteq> {}\"", "lemma empty_not_cyc_free:\n  assumes \"\\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\" \"[(M :: ('a :: time) DBM)]\\<^bsub>v,n\\<^esub> = {}\"\n  shows \"\\<not> cyc_free M n\"", "lemma not_empty_cyc_free:\n  assumes \"\\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists> c. v c = k)\" \"[(M :: ('a :: time) DBM)]\\<^bsub>v,n\\<^esub> \\<noteq> {}\"\n  shows \"cyc_free M n\"", "lemma neg_cycle_empty:\n  assumes \"\\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists> c. v c = k)\" \"set xs \\<subseteq> {0..n}\" \"i \\<le> n\" \"len M i i xs < \\<one>\"\n  shows \"[(M :: ('a :: time) DBM)]\\<^bsub>v,n\\<^esub> = {}\"", "lemma non_empty_dbm_diag_set:\n  \"clock_numbering' v n \\<Longrightarrow> [M]\\<^bsub>v,n\\<^esub> \\<noteq> {} \\<Longrightarrow> [M]\\<^bsub>v,n\\<^esub> = [(\\<lambda> i j. if i = j then \\<one> else M i j)]\\<^bsub>v,n\\<^esub>\"", "lemma non_empty_cycle_free:\n  assumes \"[M]\\<^bsub>v,n\\<^esub> \\<noteq> {}\"\n    and \"\\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\"\n  shows \"cycle_free M n\"", "lemma neg_diag_empty:\n  assumes \"\\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\" \"i \\<le> n\" \"M i i < \\<one>\"\n  shows \"[M]\\<^bsub>v,n\\<^esub> = {}\"", "lemma canonical_empty_zone:\n  assumes \"\\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\" \"\\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\"\n    and \"canonical M n\"\n  shows \"[M]\\<^bsub>v,n\\<^esub> = {} \\<longleftrightarrow> (\\<exists>i\\<le>n. M i i < \\<one>)\""], "translations": [["", "lemma upd_1:\nassumes \"j \\<le> n\"\nshows \"DBM_upd M1 f (Suc m) n N (Suc m) j = DBM_upd M1 f (Suc m) j N (Suc m) j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DBM_upd M1 f (Suc m) n N (Suc m) j = DBM_upd M1 f (Suc m) j N (Suc m) j", "using assms"], ["proof (prove)\nusing this:\n  j \\<le> n\n\ngoal (1 subgoal):\n 1. DBM_upd M1 f (Suc m) n N (Suc m) j = DBM_upd M1 f (Suc m) j N (Suc m) j", "by (induction n) auto"], ["", "lemma upd_2:\nassumes \"i \\<le> m\"\nshows \"DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f (Suc m) 0 N i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f (Suc m) 0 N i j", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> m\n\ngoal (1 subgoal):\n 1. DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f (Suc m) 0 N i j", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<le> m \\<Longrightarrow>\n    DBM_upd M1 f (Suc m) 0 N i j = DBM_upd M1 f (Suc m) 0 N i j\n 2. \\<And>n.\n       \\<lbrakk>i \\<le> m \\<Longrightarrow>\n                DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f (Suc m) 0 N i j;\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> DBM_upd M1 f (Suc m) (Suc n) N i j =\n                         DBM_upd M1 f (Suc m) 0 N i j", "case 0"], ["proof (state)\nthis:\n  i \\<le> m\n\ngoal (2 subgoals):\n 1. i \\<le> m \\<Longrightarrow>\n    DBM_upd M1 f (Suc m) 0 N i j = DBM_upd M1 f (Suc m) 0 N i j\n 2. \\<And>n.\n       \\<lbrakk>i \\<le> m \\<Longrightarrow>\n                DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f (Suc m) 0 N i j;\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> DBM_upd M1 f (Suc m) (Suc n) N i j =\n                         DBM_upd M1 f (Suc m) 0 N i j", "thus ?case"], ["proof (prove)\nusing this:\n  i \\<le> m\n\ngoal (1 subgoal):\n 1. DBM_upd M1 f (Suc m) 0 N i j = DBM_upd M1 f (Suc m) 0 N i j", "by blast"], ["proof (state)\nthis:\n  DBM_upd M1 f (Suc m) 0 N i j = DBM_upd M1 f (Suc m) 0 N i j\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>i \\<le> m \\<Longrightarrow>\n                DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f (Suc m) 0 N i j;\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> DBM_upd M1 f (Suc m) (Suc n) N i j =\n                         DBM_upd M1 f (Suc m) 0 N i j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>i \\<le> m \\<Longrightarrow>\n                DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f (Suc m) 0 N i j;\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> DBM_upd M1 f (Suc m) (Suc n) N i j =\n                         DBM_upd M1 f (Suc m) 0 N i j", "case (Suc n)"], ["proof (state)\nthis:\n  i \\<le> m \\<Longrightarrow>\n  DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f (Suc m) 0 N i j\n  i \\<le> m\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>i \\<le> m \\<Longrightarrow>\n                DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f (Suc m) 0 N i j;\n        i \\<le> m\\<rbrakk>\n       \\<Longrightarrow> DBM_upd M1 f (Suc m) (Suc n) N i j =\n                         DBM_upd M1 f (Suc m) 0 N i j", "thus ?case"], ["proof (prove)\nusing this:\n  i \\<le> m \\<Longrightarrow>\n  DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f (Suc m) 0 N i j\n  i \\<le> m\n\ngoal (1 subgoal):\n 1. DBM_upd M1 f (Suc m) (Suc n) N i j = DBM_upd M1 f (Suc m) 0 N i j", "by simp"], ["proof (state)\nthis:\n  DBM_upd M1 f (Suc m) (Suc n) N i j = DBM_upd M1 f (Suc m) 0 N i j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upd_3:\nassumes \"m \\<le> N\" \"n \\<le> N\" \"j \\<le> n\" \"i \\<le> m\"\nshows \"(DBM_upd M1 f m n N) i j = (DBM_upd M1 f i j N) i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DBM_upd M1 f m n N i j = DBM_upd M1 f i j N i j", "using assms"], ["proof (prove)\nusing this:\n  m \\<le> N\n  n \\<le> N\n  j \\<le> n\n  i \\<le> m\n\ngoal (1 subgoal):\n 1. DBM_upd M1 f m n N i j = DBM_upd M1 f i j N i j", "proof (induction m arbitrary: n i j, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n i j.\n       \\<lbrakk>0 \\<le> N; n \\<le> N; j \\<le> n; i \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> DBM_upd M1 f 0 n N i j = DBM_upd M1 f i j N i j\n 2. \\<And>m n i j.\n       \\<lbrakk>\\<And>n i j.\n                   \\<lbrakk>m \\<le> N; n \\<le> N; j \\<le> n;\n                    i \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> DBM_upd M1 f m n N i j =\n                                     DBM_upd M1 f i j N i j;\n        Suc m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> Suc m\\<rbrakk>\n       \\<Longrightarrow> DBM_upd M1 f (Suc m) n N i j =\n                         DBM_upd M1 f i j N i j", "case (1 n)"], ["proof (state)\nthis:\n  0 \\<le> N\n  n \\<le> N\n  j_ \\<le> n\n  i_ \\<le> 0\n\ngoal (2 subgoals):\n 1. \\<And>n i j.\n       \\<lbrakk>0 \\<le> N; n \\<le> N; j \\<le> n; i \\<le> 0\\<rbrakk>\n       \\<Longrightarrow> DBM_upd M1 f 0 n N i j = DBM_upd M1 f i j N i j\n 2. \\<And>m n i j.\n       \\<lbrakk>\\<And>n i j.\n                   \\<lbrakk>m \\<le> N; n \\<le> N; j \\<le> n;\n                    i \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> DBM_upd M1 f m n N i j =\n                                     DBM_upd M1 f i j N i j;\n        Suc m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> Suc m\\<rbrakk>\n       \\<Longrightarrow> DBM_upd M1 f (Suc m) n N i j =\n                         DBM_upd M1 f i j N i j", "thus ?case"], ["proof (prove)\nusing this:\n  0 \\<le> N\n  n \\<le> N\n  j_ \\<le> n\n  i_ \\<le> 0\n\ngoal (1 subgoal):\n 1. DBM_upd M1 f 0 n N i_ j_ = DBM_upd M1 f i_ j_ N i_ j_", "by (induction n) auto"], ["proof (state)\nthis:\n  DBM_upd M1 f 0 n N i_ j_ = DBM_upd M1 f i_ j_ N i_ j_\n\ngoal (1 subgoal):\n 1. \\<And>m n i j.\n       \\<lbrakk>\\<And>n i j.\n                   \\<lbrakk>m \\<le> N; n \\<le> N; j \\<le> n;\n                    i \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> DBM_upd M1 f m n N i j =\n                                     DBM_upd M1 f i j N i j;\n        Suc m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> Suc m\\<rbrakk>\n       \\<Longrightarrow> DBM_upd M1 f (Suc m) n N i j =\n                         DBM_upd M1 f i j N i j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m n i j.\n       \\<lbrakk>\\<And>n i j.\n                   \\<lbrakk>m \\<le> N; n \\<le> N; j \\<le> n;\n                    i \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> DBM_upd M1 f m n N i j =\n                                     DBM_upd M1 f i j N i j;\n        Suc m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> Suc m\\<rbrakk>\n       \\<Longrightarrow> DBM_upd M1 f (Suc m) n N i j =\n                         DBM_upd M1 f i j N i j", "case (2 m n i j)"], ["proof (state)\nthis:\n  \\<lbrakk>m \\<le> N; ?n \\<le> N; ?j \\<le> ?n; ?i \\<le> m\\<rbrakk>\n  \\<Longrightarrow> DBM_upd M1 f m ?n N ?i ?j = DBM_upd M1 f ?i ?j N ?i ?j\n  Suc m \\<le> N\n  n \\<le> N\n  j \\<le> n\n  i \\<le> Suc m\n\ngoal (1 subgoal):\n 1. \\<And>m n i j.\n       \\<lbrakk>\\<And>n i j.\n                   \\<lbrakk>m \\<le> N; n \\<le> N; j \\<le> n;\n                    i \\<le> m\\<rbrakk>\n                   \\<Longrightarrow> DBM_upd M1 f m n N i j =\n                                     DBM_upd M1 f i j N i j;\n        Suc m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> Suc m\\<rbrakk>\n       \\<Longrightarrow> DBM_upd M1 f (Suc m) n N i j =\n                         DBM_upd M1 f i j N i j", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>m \\<le> N; ?n \\<le> N; ?j \\<le> ?n; ?i \\<le> m\\<rbrakk>\n  \\<Longrightarrow> DBM_upd M1 f m ?n N ?i ?j = DBM_upd M1 f ?i ?j N ?i ?j\n  Suc m \\<le> N\n  n \\<le> N\n  j \\<le> n\n  i \\<le> Suc m\n\ngoal (1 subgoal):\n 1. DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f i j N i j", "proof (cases \"i = Suc m\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>n j i.\n                \\<lbrakk>m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> m\\<rbrakk>\n                \\<Longrightarrow> DBM_upd M1 f m n N i j =\n                                  DBM_upd M1 f i j N i j;\n     Suc m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> Suc m; i = Suc m\\<rbrakk>\n    \\<Longrightarrow> DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f i j N i j\n 2. \\<lbrakk>\\<And>n j i.\n                \\<lbrakk>m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> m\\<rbrakk>\n                \\<Longrightarrow> DBM_upd M1 f m n N i j =\n                                  DBM_upd M1 f i j N i j;\n     Suc m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> Suc m;\n     i \\<noteq> Suc m\\<rbrakk>\n    \\<Longrightarrow> DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f i j N i j", "case True"], ["proof (state)\nthis:\n  i = Suc m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>n j i.\n                \\<lbrakk>m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> m\\<rbrakk>\n                \\<Longrightarrow> DBM_upd M1 f m n N i j =\n                                  DBM_upd M1 f i j N i j;\n     Suc m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> Suc m; i = Suc m\\<rbrakk>\n    \\<Longrightarrow> DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f i j N i j\n 2. \\<lbrakk>\\<And>n j i.\n                \\<lbrakk>m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> m\\<rbrakk>\n                \\<Longrightarrow> DBM_upd M1 f m n N i j =\n                                  DBM_upd M1 f i j N i j;\n     Suc m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> Suc m;\n     i \\<noteq> Suc m\\<rbrakk>\n    \\<Longrightarrow> DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f i j N i j", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = Suc m\n\ngoal (1 subgoal):\n 1. DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f i j N i j", "using upd_1[OF \\<open>j \\<le> n\\<close>]"], ["proof (prove)\nusing this:\n  i = Suc m\n  DBM_upd ?M1.0 ?f (Suc ?m) n ?N (Suc ?m) j =\n  DBM_upd ?M1.0 ?f (Suc ?m) j ?N (Suc ?m) j\n\ngoal (1 subgoal):\n 1. DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f i j N i j", "by blast"], ["proof (state)\nthis:\n  DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f i j N i j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n j i.\n                \\<lbrakk>m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> m\\<rbrakk>\n                \\<Longrightarrow> DBM_upd M1 f m n N i j =\n                                  DBM_upd M1 f i j N i j;\n     Suc m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> Suc m;\n     i \\<noteq> Suc m\\<rbrakk>\n    \\<Longrightarrow> DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f i j N i j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n j i.\n                \\<lbrakk>m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> m\\<rbrakk>\n                \\<Longrightarrow> DBM_upd M1 f m n N i j =\n                                  DBM_upd M1 f i j N i j;\n     Suc m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> Suc m;\n     i \\<noteq> Suc m\\<rbrakk>\n    \\<Longrightarrow> DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f i j N i j", "case False"], ["proof (state)\nthis:\n  i \\<noteq> Suc m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n j i.\n                \\<lbrakk>m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> m\\<rbrakk>\n                \\<Longrightarrow> DBM_upd M1 f m n N i j =\n                                  DBM_upd M1 f i j N i j;\n     Suc m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> Suc m;\n     i \\<noteq> Suc m\\<rbrakk>\n    \\<Longrightarrow> DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f i j N i j", "with \\<open>i \\<le> Suc m\\<close>"], ["proof (chain)\npicking this:\n  i \\<le> Suc m\n  i \\<noteq> Suc m", "have \"i \\<le> m\""], ["proof (prove)\nusing this:\n  i \\<le> Suc m\n  i \\<noteq> Suc m\n\ngoal (1 subgoal):\n 1. i \\<le> m", "by auto"], ["proof (state)\nthis:\n  i \\<le> m\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n j i.\n                \\<lbrakk>m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> m\\<rbrakk>\n                \\<Longrightarrow> DBM_upd M1 f m n N i j =\n                                  DBM_upd M1 f i j N i j;\n     Suc m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> Suc m;\n     i \\<noteq> Suc m\\<rbrakk>\n    \\<Longrightarrow> DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f i j N i j", "with upd_2[OF this]"], ["proof (chain)\npicking this:\n  DBM_upd ?M1.0 ?f (Suc m) ?n ?N i ?j = DBM_upd ?M1.0 ?f (Suc m) 0 ?N i ?j\n  i \\<le> m", "have \"DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f m N N i j\""], ["proof (prove)\nusing this:\n  DBM_upd ?M1.0 ?f (Suc m) ?n ?N i ?j = DBM_upd ?M1.0 ?f (Suc m) 0 ?N i ?j\n  i \\<le> m\n\ngoal (1 subgoal):\n 1. DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f m N N i j", "by force"], ["proof (state)\nthis:\n  DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f m N N i j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n j i.\n                \\<lbrakk>m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> m\\<rbrakk>\n                \\<Longrightarrow> DBM_upd M1 f m n N i j =\n                                  DBM_upd M1 f i j N i j;\n     Suc m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> Suc m;\n     i \\<noteq> Suc m\\<rbrakk>\n    \\<Longrightarrow> DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f i j N i j", "also"], ["proof (state)\nthis:\n  DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f m N N i j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n j i.\n                \\<lbrakk>m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> m\\<rbrakk>\n                \\<Longrightarrow> DBM_upd M1 f m n N i j =\n                                  DBM_upd M1 f i j N i j;\n     Suc m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> Suc m;\n     i \\<noteq> Suc m\\<rbrakk>\n    \\<Longrightarrow> DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f i j N i j", "have \"\\<dots> = DBM_upd M1 f i j N i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DBM_upd M1 f m N N i j = DBM_upd M1 f i j N i j", "using False 2"], ["proof (prove)\nusing this:\n  i \\<noteq> Suc m\n  \\<lbrakk>m \\<le> N; ?n \\<le> N; ?j \\<le> ?n; ?i \\<le> m\\<rbrakk>\n  \\<Longrightarrow> DBM_upd M1 f m ?n N ?i ?j = DBM_upd M1 f ?i ?j N ?i ?j\n  Suc m \\<le> N\n  n \\<le> N\n  j \\<le> n\n  i \\<le> Suc m\n\ngoal (1 subgoal):\n 1. DBM_upd M1 f m N N i j = DBM_upd M1 f i j N i j", "by force"], ["proof (state)\nthis:\n  DBM_upd M1 f m N N i j = DBM_upd M1 f i j N i j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n j i.\n                \\<lbrakk>m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> m\\<rbrakk>\n                \\<Longrightarrow> DBM_upd M1 f m n N i j =\n                                  DBM_upd M1 f i j N i j;\n     Suc m \\<le> N; n \\<le> N; j \\<le> n; i \\<le> Suc m;\n     i \\<noteq> Suc m\\<rbrakk>\n    \\<Longrightarrow> DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f i j N i j", "finally"], ["proof (chain)\npicking this:\n  DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f i j N i j", "show ?thesis"], ["proof (prove)\nusing this:\n  DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f i j N i j\n\ngoal (1 subgoal):\n 1. DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f i j N i j", "."], ["proof (state)\nthis:\n  DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f i j N i j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  DBM_upd M1 f (Suc m) n N i j = DBM_upd M1 f i j N i j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma upd_id:\n  assumes \"m \\<le> N\" \"n \\<le> N\" \"i \\<le> m\" \"j \\<le> n\"\n  shows \"(DBM_upd M1 f m n N) i j = f i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DBM_upd M1 f m n N i j = f i j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. DBM_upd M1 f m n N i j = f i j", "from assms upd_3"], ["proof (chain)\npicking this:\n  m \\<le> N\n  n \\<le> N\n  i \\<le> m\n  j \\<le> n\n  \\<lbrakk>?m \\<le> ?N; ?n \\<le> ?N; ?j \\<le> ?n; ?i \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> DBM_upd ?M1.0 ?f ?m ?n ?N ?i ?j =\n                    DBM_upd ?M1.0 ?f ?i ?j ?N ?i ?j", "have \"DBM_upd M1 f m n N i j = DBM_upd M1 f i j N i j\""], ["proof (prove)\nusing this:\n  m \\<le> N\n  n \\<le> N\n  i \\<le> m\n  j \\<le> n\n  \\<lbrakk>?m \\<le> ?N; ?n \\<le> ?N; ?j \\<le> ?n; ?i \\<le> ?m\\<rbrakk>\n  \\<Longrightarrow> DBM_upd ?M1.0 ?f ?m ?n ?N ?i ?j =\n                    DBM_upd ?M1.0 ?f ?i ?j ?N ?i ?j\n\ngoal (1 subgoal):\n 1. DBM_upd M1 f m n N i j = DBM_upd M1 f i j N i j", "by blast"], ["proof (state)\nthis:\n  DBM_upd M1 f m n N i j = DBM_upd M1 f i j N i j\n\ngoal (1 subgoal):\n 1. DBM_upd M1 f m n N i j = f i j", "also"], ["proof (state)\nthis:\n  DBM_upd M1 f m n N i j = DBM_upd M1 f i j N i j\n\ngoal (1 subgoal):\n 1. DBM_upd M1 f m n N i j = f i j", "have \"\\<dots> = f i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DBM_upd M1 f i j N i j = f i j", "by (cases i; cases j; fastforce)"], ["proof (state)\nthis:\n  DBM_upd M1 f i j N i j = f i j\n\ngoal (1 subgoal):\n 1. DBM_upd M1 f m n N i j = f i j", "finally"], ["proof (chain)\npicking this:\n  DBM_upd M1 f m n N i j = f i j", "show ?thesis"], ["proof (prove)\nusing this:\n  DBM_upd M1 f m n N i j = f i j\n\ngoal (1 subgoal):\n 1. DBM_upd M1 f m n N i j = f i j", "."], ["proof (state)\nthis:\n  DBM_upd M1 f m n N i j = f i j\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Zones and DBMs\\<close>"], ["", "definition DBM_zone_repr :: \"('t::time) DBM \\<Rightarrow> ('c \\<Rightarrow> nat) \\<Rightarrow> nat \\<Rightarrow> ('c, 't :: time) zone\"\n(\"[_]\\<^bsub>_,_\\<^esub>\" [72,72,72] 72)\nwhere\n  \"[M]\\<^bsub>v,n\\<^esub> = {u . DBM_val_bounded v u M n}\""], ["", "lemma dbm_entry_val_mono_1:\n  \"dbm_entry_val u (Some c) (Some c') b \\<Longrightarrow> b \\<preceq> b' \\<Longrightarrow> dbm_entry_val u (Some c) (Some c') b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dbm_entry_val u (Some c) (Some c') b; b \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c) (Some c') b'", "proof (induction b, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dbm_entry_val u (Some c) (Some c') (Le x);\n        Le x \\<preceq> b'\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c) (Some c') b'\n 2. \\<And>x.\n       \\<lbrakk>dbm_entry_val u (Some c) (Some c') (Lt x);\n        Lt x \\<preceq> b'\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c) (Some c') b'\n 3. \\<lbrakk>dbm_entry_val u (Some c) (Some c') \\<infinity>;\n     \\<infinity> \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c) (Some c') b'", "case 1"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c) (Some c') (Le x_)\n  Le x_ \\<preceq> b'\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dbm_entry_val u (Some c) (Some c') (Le x);\n        Le x \\<preceq> b'\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c) (Some c') b'\n 2. \\<And>x.\n       \\<lbrakk>dbm_entry_val u (Some c) (Some c') (Lt x);\n        Lt x \\<preceq> b'\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c) (Some c') b'\n 3. \\<lbrakk>dbm_entry_val u (Some c) (Some c') \\<infinity>;\n     \\<infinity> \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c) (Some c') b'", "thus ?case"], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some c) (Some c') (Le x_)\n  Le x_ \\<preceq> b'\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) (Some c') b'", "using le_dbm_le le_dbm_lt"], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some c) (Some c') (Le x_)\n  Le x_ \\<preceq> b'\n  Le ?a \\<preceq> Le ?b \\<Longrightarrow> ?a \\<le> ?b\n  Le ?a \\<preceq> Lt ?b \\<Longrightarrow> ?a < ?b\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) (Some c') b'", "by (induction b'; fastforce)"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c) (Some c') b'\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dbm_entry_val u (Some c) (Some c') (Lt x);\n        Lt x \\<preceq> b'\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c) (Some c') b'\n 2. \\<lbrakk>dbm_entry_val u (Some c) (Some c') \\<infinity>;\n     \\<infinity> \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c) (Some c') b'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dbm_entry_val u (Some c) (Some c') (Lt x);\n        Lt x \\<preceq> b'\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c) (Some c') b'\n 2. \\<lbrakk>dbm_entry_val u (Some c) (Some c') \\<infinity>;\n     \\<infinity> \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c) (Some c') b'", "case 2"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c) (Some c') (Lt x_)\n  Lt x_ \\<preceq> b'\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dbm_entry_val u (Some c) (Some c') (Lt x);\n        Lt x \\<preceq> b'\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c) (Some c') b'\n 2. \\<lbrakk>dbm_entry_val u (Some c) (Some c') \\<infinity>;\n     \\<infinity> \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c) (Some c') b'", "thus ?case"], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some c) (Some c') (Lt x_)\n  Lt x_ \\<preceq> b'\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) (Some c') b'", "using lt_dbm_le lt_dbm_lt"], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some c) (Some c') (Lt x_)\n  Lt x_ \\<preceq> b'\n  Lt ?a \\<preceq> Le ?b \\<Longrightarrow> ?a \\<le> ?b\n  Lt ?a \\<preceq> Lt ?b \\<Longrightarrow> ?a \\<le> ?b\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) (Some c') b'", "by (induction b'; fastforce)"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c) (Some c') b'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>dbm_entry_val u (Some c) (Some c') \\<infinity>;\n     \\<infinity> \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c) (Some c') b'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>dbm_entry_val u (Some c) (Some c') \\<infinity>;\n     \\<infinity> \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c) (Some c') b'", "case 3"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c) (Some c') \\<infinity>\n  \\<infinity> \\<preceq> b'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>dbm_entry_val u (Some c) (Some c') \\<infinity>;\n     \\<infinity> \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c) (Some c') b'", "thus ?case"], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some c) (Some c') \\<infinity>\n  \\<infinity> \\<preceq> b'\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) (Some c') b'", "unfolding dbm_le_def"], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some c) (Some c') \\<infinity>\n  \\<infinity> \\<prec> b' \\<or> \\<infinity> = b'\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) (Some c') b'", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c) (Some c') b'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dbm_entry_val_mono_2:\n  \"dbm_entry_val u None (Some c) b \\<Longrightarrow> b \\<preceq> b' \\<Longrightarrow> dbm_entry_val u None (Some c) b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dbm_entry_val u None (Some c) b; b \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u None (Some c) b'", "proof (induction b, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dbm_entry_val u None (Some c) (Le x);\n        Le x \\<preceq> b'\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u None (Some c) b'\n 2. \\<And>x.\n       \\<lbrakk>dbm_entry_val u None (Some c) (Lt x);\n        Lt x \\<preceq> b'\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u None (Some c) b'\n 3. \\<lbrakk>dbm_entry_val u None (Some c) \\<infinity>;\n     \\<infinity> \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u None (Some c) b'", "case 1"], ["proof (state)\nthis:\n  dbm_entry_val u None (Some c) (Le x_)\n  Le x_ \\<preceq> b'\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dbm_entry_val u None (Some c) (Le x);\n        Le x \\<preceq> b'\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u None (Some c) b'\n 2. \\<And>x.\n       \\<lbrakk>dbm_entry_val u None (Some c) (Lt x);\n        Lt x \\<preceq> b'\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u None (Some c) b'\n 3. \\<lbrakk>dbm_entry_val u None (Some c) \\<infinity>;\n     \\<infinity> \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u None (Some c) b'", "thus ?case"], ["proof (prove)\nusing this:\n  dbm_entry_val u None (Some c) (Le x_)\n  Le x_ \\<preceq> b'\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c) b'", "using le_dbm_le le_dbm_lt"], ["proof (prove)\nusing this:\n  dbm_entry_val u None (Some c) (Le x_)\n  Le x_ \\<preceq> b'\n  Le ?a \\<preceq> Le ?b \\<Longrightarrow> ?a \\<le> ?b\n  Le ?a \\<preceq> Lt ?b \\<Longrightarrow> ?a < ?b\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c) b'", "by (induction b'; fastforce)"], ["proof (state)\nthis:\n  dbm_entry_val u None (Some c) b'\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dbm_entry_val u None (Some c) (Lt x);\n        Lt x \\<preceq> b'\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u None (Some c) b'\n 2. \\<lbrakk>dbm_entry_val u None (Some c) \\<infinity>;\n     \\<infinity> \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u None (Some c) b'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dbm_entry_val u None (Some c) (Lt x);\n        Lt x \\<preceq> b'\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u None (Some c) b'\n 2. \\<lbrakk>dbm_entry_val u None (Some c) \\<infinity>;\n     \\<infinity> \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u None (Some c) b'", "case 2"], ["proof (state)\nthis:\n  dbm_entry_val u None (Some c) (Lt x_)\n  Lt x_ \\<preceq> b'\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dbm_entry_val u None (Some c) (Lt x);\n        Lt x \\<preceq> b'\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u None (Some c) b'\n 2. \\<lbrakk>dbm_entry_val u None (Some c) \\<infinity>;\n     \\<infinity> \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u None (Some c) b'", "thus ?case"], ["proof (prove)\nusing this:\n  dbm_entry_val u None (Some c) (Lt x_)\n  Lt x_ \\<preceq> b'\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c) b'", "using lt_dbm_le lt_dbm_lt"], ["proof (prove)\nusing this:\n  dbm_entry_val u None (Some c) (Lt x_)\n  Lt x_ \\<preceq> b'\n  Lt ?a \\<preceq> Le ?b \\<Longrightarrow> ?a \\<le> ?b\n  Lt ?a \\<preceq> Lt ?b \\<Longrightarrow> ?a \\<le> ?b\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c) b'", "by (induction b'; fastforce)"], ["proof (state)\nthis:\n  dbm_entry_val u None (Some c) b'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>dbm_entry_val u None (Some c) \\<infinity>;\n     \\<infinity> \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u None (Some c) b'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>dbm_entry_val u None (Some c) \\<infinity>;\n     \\<infinity> \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u None (Some c) b'", "case 3"], ["proof (state)\nthis:\n  dbm_entry_val u None (Some c) \\<infinity>\n  \\<infinity> \\<preceq> b'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>dbm_entry_val u None (Some c) \\<infinity>;\n     \\<infinity> \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u None (Some c) b'", "thus ?case"], ["proof (prove)\nusing this:\n  dbm_entry_val u None (Some c) \\<infinity>\n  \\<infinity> \\<preceq> b'\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c) b'", "unfolding dbm_le_def"], ["proof (prove)\nusing this:\n  dbm_entry_val u None (Some c) \\<infinity>\n  \\<infinity> \\<prec> b' \\<or> \\<infinity> = b'\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c) b'", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u None (Some c) b'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dbm_entry_val_mono_3:\n  \"dbm_entry_val u (Some c) None b \\<Longrightarrow> b \\<preceq> b' \\<Longrightarrow> dbm_entry_val u (Some c) None b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dbm_entry_val u (Some c) None b; b \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c) None b'", "proof (induction b, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dbm_entry_val u (Some c) None (Le x);\n        Le x \\<preceq> b'\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c) None b'\n 2. \\<And>x.\n       \\<lbrakk>dbm_entry_val u (Some c) None (Lt x);\n        Lt x \\<preceq> b'\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c) None b'\n 3. \\<lbrakk>dbm_entry_val u (Some c) None \\<infinity>;\n     \\<infinity> \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c) None b'", "case 1"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c) None (Le x_)\n  Le x_ \\<preceq> b'\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dbm_entry_val u (Some c) None (Le x);\n        Le x \\<preceq> b'\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c) None b'\n 2. \\<And>x.\n       \\<lbrakk>dbm_entry_val u (Some c) None (Lt x);\n        Lt x \\<preceq> b'\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c) None b'\n 3. \\<lbrakk>dbm_entry_val u (Some c) None \\<infinity>;\n     \\<infinity> \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c) None b'", "thus ?case"], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some c) None (Le x_)\n  Le x_ \\<preceq> b'\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) None b'", "using le_dbm_le le_dbm_lt"], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some c) None (Le x_)\n  Le x_ \\<preceq> b'\n  Le ?a \\<preceq> Le ?b \\<Longrightarrow> ?a \\<le> ?b\n  Le ?a \\<preceq> Lt ?b \\<Longrightarrow> ?a < ?b\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) None b'", "by (induction b'; fastforce)"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c) None b'\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dbm_entry_val u (Some c) None (Lt x);\n        Lt x \\<preceq> b'\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c) None b'\n 2. \\<lbrakk>dbm_entry_val u (Some c) None \\<infinity>;\n     \\<infinity> \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c) None b'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dbm_entry_val u (Some c) None (Lt x);\n        Lt x \\<preceq> b'\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c) None b'\n 2. \\<lbrakk>dbm_entry_val u (Some c) None \\<infinity>;\n     \\<infinity> \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c) None b'", "case 2"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c) None (Lt x_)\n  Lt x_ \\<preceq> b'\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dbm_entry_val u (Some c) None (Lt x);\n        Lt x \\<preceq> b'\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c) None b'\n 2. \\<lbrakk>dbm_entry_val u (Some c) None \\<infinity>;\n     \\<infinity> \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c) None b'", "thus ?case"], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some c) None (Lt x_)\n  Lt x_ \\<preceq> b'\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) None b'", "using lt_dbm_le lt_dbm_lt"], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some c) None (Lt x_)\n  Lt x_ \\<preceq> b'\n  Lt ?a \\<preceq> Le ?b \\<Longrightarrow> ?a \\<le> ?b\n  Lt ?a \\<preceq> Lt ?b \\<Longrightarrow> ?a \\<le> ?b\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) None b'", "by (induction b'; fastforce)"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c) None b'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>dbm_entry_val u (Some c) None \\<infinity>;\n     \\<infinity> \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c) None b'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>dbm_entry_val u (Some c) None \\<infinity>;\n     \\<infinity> \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c) None b'", "case 3"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c) None \\<infinity>\n  \\<infinity> \\<preceq> b'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>dbm_entry_val u (Some c) None \\<infinity>;\n     \\<infinity> \\<preceq> b'\\<rbrakk>\n    \\<Longrightarrow> dbm_entry_val u (Some c) None b'", "thus ?case"], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some c) None \\<infinity>\n  \\<infinity> \\<preceq> b'\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) None b'", "unfolding dbm_le_def"], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some c) None \\<infinity>\n  \\<infinity> \\<prec> b' \\<or> \\<infinity> = b'\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) None b'", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c) None b'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma DBM_le_subset:\n  \"\\<forall> i j. i \\<le> n \\<longrightarrow> j \\<le> n \\<longrightarrow> M i j \\<preceq> M' i j \\<Longrightarrow> u \\<in> [M]\\<^bsub>v,n\\<^esub> \\<Longrightarrow> u \\<in> [M']\\<^bsub>v,n\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i j.\n                i \\<le> n \\<longrightarrow>\n                j \\<le> n \\<longrightarrow> M i j \\<preceq> M' i j;\n     u \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> u \\<in> [M']\\<^bsub>v,n\\<^esub>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i j.\n                i \\<le> n \\<longrightarrow>\n                j \\<le> n \\<longrightarrow> M i j \\<preceq> M' i j;\n     u \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> u \\<in> [M']\\<^bsub>v,n\\<^esub>", "assume A: \"\\<forall>i j. i \\<le> n \\<longrightarrow> j \\<le> n \\<longrightarrow> M i j \\<preceq> M' i j\" \"u \\<in> [M]\\<^bsub>v,n\\<^esub>\""], ["proof (state)\nthis:\n  \\<forall>i j.\n     i \\<le> n \\<longrightarrow>\n     j \\<le> n \\<longrightarrow> M i j \\<preceq> M' i j\n  u \\<in> [M]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i j.\n                i \\<le> n \\<longrightarrow>\n                j \\<le> n \\<longrightarrow> M i j \\<preceq> M' i j;\n     u \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> u \\<in> [M']\\<^bsub>v,n\\<^esub>", "hence \"DBM_val_bounded v u M n\""], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     i \\<le> n \\<longrightarrow>\n     j \\<le> n \\<longrightarrow> M i j \\<preceq> M' i j\n  u \\<in> [M]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "by (simp add: DBM_zone_repr_def)"], ["proof (state)\nthis:\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> M\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i j.\n                i \\<le> n \\<longrightarrow>\n                j \\<le> n \\<longrightarrow> M i j \\<preceq> M' i j;\n     u \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> u \\<in> [M']\\<^bsub>v,n\\<^esub>", "with A(1)"], ["proof (chain)\npicking this:\n  \\<forall>i j.\n     i \\<le> n \\<longrightarrow>\n     j \\<le> n \\<longrightarrow> M i j \\<preceq> M' i j\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "have \"DBM_val_bounded v u M' n\""], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     i \\<le> n \\<longrightarrow>\n     j \\<le> n \\<longrightarrow> M i j \\<preceq> M' i j\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> M\n\ngoal (1 subgoal):\n 1. u \\<turnstile>\\<^bsub>v,n\\<^esub> M'", "unfolding DBM_val_bounded_def"], ["proof (prove)\nusing this:\n  \\<forall>i j.\n     i \\<le> n \\<longrightarrow>\n     j \\<le> n \\<longrightarrow> M i j \\<preceq> M' i j\n  Le (0::'a) \\<preceq> M 0 0 \\<and>\n  (\\<forall>c.\n      v c \\<le> n \\<longrightarrow>\n      dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n      dbm_entry_val u (Some c) None (M (v c) 0)) \\<and>\n  (\\<forall>c1 c2.\n      v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n      dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2)))\n\ngoal (1 subgoal):\n 1. Le (0::'a) \\<preceq> M' 0 0 \\<and>\n    (\\<forall>c.\n        v c \\<le> n \\<longrightarrow>\n        dbm_entry_val u None (Some c) (M' 0 (v c)) \\<and>\n        dbm_entry_val u (Some c) None (M' (v c) 0)) \\<and>\n    (\\<forall>c1 c2.\n        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n        dbm_entry_val u (Some c1) (Some c2) (M' (v c1) (v c2)))", "proof (auto, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n     Le (0::'a) \\<preceq> M 0 0;\n     \\<forall>c.\n        v c \\<le> n \\<longrightarrow>\n        dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n        dbm_entry_val u (Some c) None (M (v c) 0);\n     \\<forall>c1 c2.\n        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n        dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2))\\<rbrakk>\n    \\<Longrightarrow> Le (0::'a) \\<preceq> M' 0 0\n 2. \\<And>c.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u None (Some c) (M' 0 (v c))\n 3. \\<And>c.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c) None (M' (v c) 0)\n 4. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (M' (v c1) (v c2))", "case 1"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j\n  Le (0::'a) \\<preceq> M 0 0\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n     dbm_entry_val u (Some c) None (M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2))\n\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n     Le (0::'a) \\<preceq> M 0 0;\n     \\<forall>c.\n        v c \\<le> n \\<longrightarrow>\n        dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n        dbm_entry_val u (Some c) None (M (v c) 0);\n     \\<forall>c1 c2.\n        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n        dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2))\\<rbrakk>\n    \\<Longrightarrow> Le (0::'a) \\<preceq> M' 0 0\n 2. \\<And>c.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u None (Some c) (M' 0 (v c))\n 3. \\<And>c.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c) None (M' (v c) 0)\n 4. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (M' (v c1) (v c2))", "from this(1,2)"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j\n  Le (0::'a) \\<preceq> M 0 0", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j\n  Le (0::'a) \\<preceq> M 0 0\n\ngoal (1 subgoal):\n 1. Le (0::'a) \\<preceq> M' 0 0", "unfolding less_eq[symmetric]"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<le> M' i j\n  Le (0::'a) \\<le> M 0 0\n\ngoal (1 subgoal):\n 1. Le (0::'a) \\<le> M' 0 0", "by fastforce"], ["proof (state)\nthis:\n  Le (0::'a) \\<preceq> M' 0 0\n\ngoal (3 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u None (Some c) (M' 0 (v c))\n 2. \\<And>c.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c) None (M' (v c) 0)\n 3. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (M' (v c1) (v c2))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u None (Some c) (M' 0 (v c))\n 2. \\<And>c.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c) None (M' (v c) 0)\n 3. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (M' (v c1) (v c2))", "case (2 c)"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j\n  Le (0::'a) \\<preceq> M 0 0\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n     dbm_entry_val u (Some c) None (M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2))\n  v c \\<le> n\n\ngoal (3 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u None (Some c) (M' 0 (v c))\n 2. \\<And>c.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c) None (M' (v c) 0)\n 3. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (M' (v c1) (v c2))", "hence \"dbm_entry_val u None (Some c) (M 0 (v c))\" \"M 0 (v c) \\<preceq> M' 0 (v c)\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j\n  Le (0::'a) \\<preceq> M 0 0\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n     dbm_entry_val u (Some c) None (M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2))\n  v c \\<le> n\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c) (M 0 (v c)) &&&\n    M 0 (v c) \\<preceq> M' 0 (v c)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u None (Some c) (M 0 (v c))\n  M 0 (v c) \\<preceq> M' 0 (v c)\n\ngoal (3 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u None (Some c) (M' 0 (v c))\n 2. \\<And>c.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c) None (M' (v c) 0)\n 3. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (M' (v c1) (v c2))", "thus ?case"], ["proof (prove)\nusing this:\n  dbm_entry_val u None (Some c) (M 0 (v c))\n  M 0 (v c) \\<preceq> M' 0 (v c)\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c) (M' 0 (v c))", "using dbm_entry_val_mono_2"], ["proof (prove)\nusing this:\n  dbm_entry_val u None (Some c) (M 0 (v c))\n  M 0 (v c) \\<preceq> M' 0 (v c)\n  \\<lbrakk>dbm_entry_val ?u None (Some ?c) ?b; ?b \\<preceq> ?b'\\<rbrakk>\n  \\<Longrightarrow> dbm_entry_val ?u None (Some ?c) ?b'\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c) (M' 0 (v c))", "by fast"], ["proof (state)\nthis:\n  dbm_entry_val u None (Some c) (M' 0 (v c))\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c) None (M' (v c) 0)\n 2. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (M' (v c1) (v c2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c) None (M' (v c) 0)\n 2. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (M' (v c1) (v c2))", "case (3 c)"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j\n  Le (0::'a) \\<preceq> M 0 0\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n     dbm_entry_val u (Some c) None (M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2))\n  v c \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c) None (M' (v c) 0)\n 2. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (M' (v c1) (v c2))", "hence \"dbm_entry_val u (Some c) None (M (v c) 0)\" \"M (v c) 0 \\<preceq> M' (v c) 0\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j\n  Le (0::'a) \\<preceq> M 0 0\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n     dbm_entry_val u (Some c) None (M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2))\n  v c \\<le> n\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) None (M (v c) 0) &&&\n    M (v c) 0 \\<preceq> M' (v c) 0", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c) None (M (v c) 0)\n  M (v c) 0 \\<preceq> M' (v c) 0\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c) None (M' (v c) 0)\n 2. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (M' (v c1) (v c2))", "thus ?case"], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some c) None (M (v c) 0)\n  M (v c) 0 \\<preceq> M' (v c) 0\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) None (M' (v c) 0)", "using dbm_entry_val_mono_3"], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some c) None (M (v c) 0)\n  M (v c) 0 \\<preceq> M' (v c) 0\n  \\<lbrakk>dbm_entry_val ?u (Some ?c) None ?b; ?b \\<preceq> ?b'\\<rbrakk>\n  \\<Longrightarrow> dbm_entry_val ?u (Some ?c) None ?b'\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) None (M' (v c) 0)", "by fast"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c) None (M' (v c) 0)\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (M' (v c1) (v c2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (M' (v c1) (v c2))", "case (4 c1 c2)"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j\n  Le (0::'a) \\<preceq> M 0 0\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n     dbm_entry_val u (Some c) None (M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2))\n  v c1 \\<le> n\n  v c2 \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (M' (v c1) (v c2))", "hence \"dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2))\" \"M (v c1) (v c2) \\<preceq> M' (v c1) (v c2)\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j\n  Le (0::'a) \\<preceq> M 0 0\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n     dbm_entry_val u (Some c) None (M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2))\n  v c1 \\<le> n\n  v c2 \\<le> n\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2)) &&&\n    M (v c1) (v c2) \\<preceq> M' (v c1) (v c2)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2))\n  M (v c1) (v c2) \\<preceq> M' (v c1) (v c2)\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>i\\<le>n. \\<forall>j\\<le>n. M i j \\<preceq> M' i j;\n        Le (0::'a) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val u (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2));\n        v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (M' (v c1) (v c2))", "thus ?case"], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2))\n  M (v c1) (v c2) \\<preceq> M' (v c1) (v c2)\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) (Some c2) (M' (v c1) (v c2))", "using dbm_entry_val_mono_1"], ["proof (prove)\nusing this:\n  dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2))\n  M (v c1) (v c2) \\<preceq> M' (v c1) (v c2)\n  \\<lbrakk>dbm_entry_val ?u (Some ?c) (Some ?c') ?b;\n   ?b \\<preceq> ?b'\\<rbrakk>\n  \\<Longrightarrow> dbm_entry_val ?u (Some ?c) (Some ?c') ?b'\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) (Some c2) (M' (v c1) (v c2))", "by fast"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c1) (Some c2) (M' (v c1) (v c2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> M'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i j.\n                i \\<le> n \\<longrightarrow>\n                j \\<le> n \\<longrightarrow> M i j \\<preceq> M' i j;\n     u \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n    \\<Longrightarrow> u \\<in> [M']\\<^bsub>v,n\\<^esub>", "thus \"u \\<in> [M']\\<^bsub>v,n\\<^esub>\""], ["proof (prove)\nusing this:\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> M'\n\ngoal (1 subgoal):\n 1. u \\<in> [M']\\<^bsub>v,n\\<^esub>", "by (simp add: DBM_zone_repr_def)"], ["proof (state)\nthis:\n  u \\<in> [M']\\<^bsub>v,n\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>DBMs Without Negative Cycles are Non-Empty\\<close>"], ["", "text \\<open>\n  We need all of these assumptions for the proof that matrices without negative cycles\n  represent non-negative zones:\n    * Abelian (linearly ordered) monoid\n    * Time is non-trivial\n    * Time is dense\n\\<close>"], ["", "lemmas (in linordered_ab_monoid_add) comm = add.commute"], ["", "lemma sum_gt_neutral_dest':\n  \"(a :: (('a :: time) DBMEntry)) \\<ge> \\<one> \\<Longrightarrow> a + b > \\<one> \\<Longrightarrow> \\<exists> d. Le d \\<le> a \\<and> Le (-d) \\<le> b \\<and> d \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<one> \\<le> a; \\<one> < a + b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> a \\<and>\n                         Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<one> \\<le> a; \\<one> < a + b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> a \\<and>\n                         Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "assume \"a + b > \\<one>\" \"a \\<ge> \\<one>\""], ["proof (state)\nthis:\n  \\<one> < a + b\n  \\<one> \\<le> a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<one> \\<le> a; \\<one> < a + b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> a \\<and>\n                         Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "proof (cases \"b \\<ge> \\<one>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<one> \\<le> b \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b \\<and> (0::'a) \\<le> d\n 2. \\<not> \\<one> \\<le> b \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "case True"], ["proof (state)\nthis:\n  \\<one> \\<le> b\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> b \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b \\<and> (0::'a) \\<le> d\n 2. \\<not> \\<one> \\<le> b \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "with \\<open>a \\<ge> \\<one>\\<close>"], ["proof (chain)\npicking this:\n  \\<one> \\<le> a\n  \\<one> \\<le> b", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<one> \\<le> a\n  \\<one> \\<le> b\n\ngoal (1 subgoal):\n 1. \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "by (auto simp: neutral)"], ["proof (state)\nthis:\n  \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b \\<and> (0::'a) \\<le> d\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> b \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> b \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "case False"], ["proof (state)\nthis:\n  \\<not> \\<one> \\<le> b\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> b \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "hence \"b < Le 0\""], ["proof (prove)\nusing this:\n  \\<not> \\<one> \\<le> b\n\ngoal (1 subgoal):\n 1. b < Le (0::'a)", "by (auto simp: neutral)"], ["proof (state)\nthis:\n  b < Le (0::'a)\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> b \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "with \\<open>a \\<ge> \\<one>\\<close> \\<open>a + b > \\<one>\\<close>"], ["proof (chain)\npicking this:\n  \\<one> \\<le> a\n  \\<one> < a + b\n  b < Le (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<one> \\<le> a\n  \\<one> < a + b\n  b < Le (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "proof (cases a, cases b, auto simp: neutral, goal_cases)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>x1 x1a.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + Le x1a;\n        Le x1a < Le (0::'a); a = Le x1; b = Le x1a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> Le x1a \\<and> (0::'a) \\<le> d\n 2. \\<And>x1 x2.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + Lt x2;\n        Lt x2 < Le (0::'a); a = Le x1; b = Lt x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d\n 3. \\<And>x1.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + \\<infinity>;\n        \\<infinity> < Le (0::'a); a = Le x1; b = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> \\<infinity> \\<and>\n                            (0::'a) \\<le> d\n 4. \\<And>x2.\n       \\<lbrakk>Le (0::'a) \\<le> Lt x2; Le (0::'a) < Lt x2 + b; a = Lt x2;\n        b < Le (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt x2 \\<and>\n                            Le (- d) \\<le> b \\<and> (0::'a) \\<le> d\n 5. \\<lbrakk>Le (0::'a) \\<le> \\<infinity>; Le (0::'a) < \\<infinity> + b;\n     a = \\<infinity>; b < Le (0::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> \\<infinity> \\<and>\n                         Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "case (1 a' b')"], ["proof (state)\nthis:\n  Le (0::'a) \\<le> Le a'\n  Le (0::'a) < Le a' + Le b'\n  Le b' < Le (0::'a)\n  a = Le a'\n  b = Le b'\n\ngoal (5 subgoals):\n 1. \\<And>x1 x1a.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + Le x1a;\n        Le x1a < Le (0::'a); a = Le x1; b = Le x1a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> Le x1a \\<and> (0::'a) \\<le> d\n 2. \\<And>x1 x2.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + Lt x2;\n        Lt x2 < Le (0::'a); a = Le x1; b = Lt x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d\n 3. \\<And>x1.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + \\<infinity>;\n        \\<infinity> < Le (0::'a); a = Le x1; b = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> \\<infinity> \\<and>\n                            (0::'a) \\<le> d\n 4. \\<And>x2.\n       \\<lbrakk>Le (0::'a) \\<le> Lt x2; Le (0::'a) < Lt x2 + b; a = Lt x2;\n        b < Le (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt x2 \\<and>\n                            Le (- d) \\<le> b \\<and> (0::'a) \\<le> d\n 5. \\<lbrakk>Le (0::'a) \\<le> \\<infinity>; Le (0::'a) < \\<infinity> + b;\n     a = \\<infinity>; b < Le (0::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> \\<infinity> \\<and>\n                         Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "from 1(2)"], ["proof (chain)\npicking this:\n  Le (0::'a) < Le a' + Le b'", "have \"a' + b' > 0\""], ["proof (prove)\nusing this:\n  Le (0::'a) < Le a' + Le b'\n\ngoal (1 subgoal):\n 1. (0::'a) < a' + b'", "by (auto elim: dbm_lt.cases simp: less mult)"], ["proof (state)\nthis:\n  (0::'a) < a' + b'\n\ngoal (5 subgoals):\n 1. \\<And>x1 x1a.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + Le x1a;\n        Le x1a < Le (0::'a); a = Le x1; b = Le x1a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> Le x1a \\<and> (0::'a) \\<le> d\n 2. \\<And>x1 x2.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + Lt x2;\n        Lt x2 < Le (0::'a); a = Le x1; b = Lt x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d\n 3. \\<And>x1.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + \\<infinity>;\n        \\<infinity> < Le (0::'a); a = Le x1; b = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> \\<infinity> \\<and>\n                            (0::'a) \\<le> d\n 4. \\<And>x2.\n       \\<lbrakk>Le (0::'a) \\<le> Lt x2; Le (0::'a) < Lt x2 + b; a = Lt x2;\n        b < Le (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt x2 \\<and>\n                            Le (- d) \\<le> b \\<and> (0::'a) \\<le> d\n 5. \\<lbrakk>Le (0::'a) \\<le> \\<infinity>; Le (0::'a) < \\<infinity> + b;\n     a = \\<infinity>; b < Le (0::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> \\<infinity> \\<and>\n                         Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "hence \"b' > -a'\""], ["proof (prove)\nusing this:\n  (0::'a) < a' + b'\n\ngoal (1 subgoal):\n 1. - a' < b'", "by (metis add.commute diff_0 diff_less_eq)"], ["proof (state)\nthis:\n  - a' < b'\n\ngoal (5 subgoals):\n 1. \\<And>x1 x1a.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + Le x1a;\n        Le x1a < Le (0::'a); a = Le x1; b = Le x1a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> Le x1a \\<and> (0::'a) \\<le> d\n 2. \\<And>x1 x2.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + Lt x2;\n        Lt x2 < Le (0::'a); a = Le x1; b = Lt x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d\n 3. \\<And>x1.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + \\<infinity>;\n        \\<infinity> < Le (0::'a); a = Le x1; b = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> \\<infinity> \\<and>\n                            (0::'a) \\<le> d\n 4. \\<And>x2.\n       \\<lbrakk>Le (0::'a) \\<le> Lt x2; Le (0::'a) < Lt x2 + b; a = Lt x2;\n        b < Le (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt x2 \\<and>\n                            Le (- d) \\<le> b \\<and> (0::'a) \\<le> d\n 5. \\<lbrakk>Le (0::'a) \\<le> \\<infinity>; Le (0::'a) < \\<infinity> + b;\n     a = \\<infinity>; b < Le (0::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> \\<infinity> \\<and>\n                         Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "with \\<open>Le 0 \\<le> Le a'\\<close>"], ["proof (chain)\npicking this:\n  Le (0::'a) \\<le> Le a'\n  - a' < b'", "show ?case"], ["proof (prove)\nusing this:\n  Le (0::'a) \\<le> Le a'\n  - a' < b'\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       Le d \\<le> Le a' \\<and> Le (- d) \\<le> Le b' \\<and> (0::'a) \\<le> d", "by (auto simp: dbm_le_def less_eq le_dbm_le)"], ["proof (state)\nthis:\n  \\<exists>d.\n     Le d \\<le> Le a' \\<and> Le (- d) \\<le> Le b' \\<and> (0::'a) \\<le> d\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + Lt x2;\n        Lt x2 < Le (0::'a); a = Le x1; b = Lt x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d\n 2. \\<And>x1.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + \\<infinity>;\n        \\<infinity> < Le (0::'a); a = Le x1; b = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> \\<infinity> \\<and>\n                            (0::'a) \\<le> d\n 3. \\<And>x2.\n       \\<lbrakk>Le (0::'a) \\<le> Lt x2; Le (0::'a) < Lt x2 + b; a = Lt x2;\n        b < Le (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt x2 \\<and>\n                            Le (- d) \\<le> b \\<and> (0::'a) \\<le> d\n 4. \\<lbrakk>Le (0::'a) \\<le> \\<infinity>; Le (0::'a) < \\<infinity> + b;\n     a = \\<infinity>; b < Le (0::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> \\<infinity> \\<and>\n                         Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + Lt x2;\n        Lt x2 < Le (0::'a); a = Le x1; b = Lt x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d\n 2. \\<And>x1.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + \\<infinity>;\n        \\<infinity> < Le (0::'a); a = Le x1; b = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> \\<infinity> \\<and>\n                            (0::'a) \\<le> d\n 3. \\<And>x2.\n       \\<lbrakk>Le (0::'a) \\<le> Lt x2; Le (0::'a) < Lt x2 + b; a = Lt x2;\n        b < Le (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt x2 \\<and>\n                            Le (- d) \\<le> b \\<and> (0::'a) \\<le> d\n 4. \\<lbrakk>Le (0::'a) \\<le> \\<infinity>; Le (0::'a) < \\<infinity> + b;\n     a = \\<infinity>; b < Le (0::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> \\<infinity> \\<and>\n                         Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "case (2 a' b')"], ["proof (state)\nthis:\n  Le (0::'a) \\<le> Le a'\n  Le (0::'a) < Le a' + Lt b'\n  Lt b' < Le (0::'a)\n  a = Le a'\n  b = Lt b'\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + Lt x2;\n        Lt x2 < Le (0::'a); a = Le x1; b = Lt x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d\n 2. \\<And>x1.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + \\<infinity>;\n        \\<infinity> < Le (0::'a); a = Le x1; b = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> \\<infinity> \\<and>\n                            (0::'a) \\<le> d\n 3. \\<And>x2.\n       \\<lbrakk>Le (0::'a) \\<le> Lt x2; Le (0::'a) < Lt x2 + b; a = Lt x2;\n        b < Le (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt x2 \\<and>\n                            Le (- d) \\<le> b \\<and> (0::'a) \\<le> d\n 4. \\<lbrakk>Le (0::'a) \\<le> \\<infinity>; Le (0::'a) < \\<infinity> + b;\n     a = \\<infinity>; b < Le (0::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> \\<infinity> \\<and>\n                         Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "from this(2)"], ["proof (chain)\npicking this:\n  Le (0::'a) < Le a' + Lt b'", "have \"a' + b' > 0\""], ["proof (prove)\nusing this:\n  Le (0::'a) < Le a' + Lt b'\n\ngoal (1 subgoal):\n 1. (0::'a) < a' + b'", "by (auto elim: dbm_lt.cases simp: less mult)"], ["proof (state)\nthis:\n  (0::'a) < a' + b'\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + Lt x2;\n        Lt x2 < Le (0::'a); a = Le x1; b = Lt x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d\n 2. \\<And>x1.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + \\<infinity>;\n        \\<infinity> < Le (0::'a); a = Le x1; b = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> \\<infinity> \\<and>\n                            (0::'a) \\<le> d\n 3. \\<And>x2.\n       \\<lbrakk>Le (0::'a) \\<le> Lt x2; Le (0::'a) < Lt x2 + b; a = Lt x2;\n        b < Le (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt x2 \\<and>\n                            Le (- d) \\<le> b \\<and> (0::'a) \\<le> d\n 4. \\<lbrakk>Le (0::'a) \\<le> \\<infinity>; Le (0::'a) < \\<infinity> + b;\n     a = \\<infinity>; b < Le (0::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> \\<infinity> \\<and>\n                         Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "hence \"b' > -a'\""], ["proof (prove)\nusing this:\n  (0::'a) < a' + b'\n\ngoal (1 subgoal):\n 1. - a' < b'", "by (metis add.commute diff_0 diff_less_eq)"], ["proof (state)\nthis:\n  - a' < b'\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + Lt x2;\n        Lt x2 < Le (0::'a); a = Le x1; b = Lt x2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d\n 2. \\<And>x1.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + \\<infinity>;\n        \\<infinity> < Le (0::'a); a = Le x1; b = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> \\<infinity> \\<and>\n                            (0::'a) \\<le> d\n 3. \\<And>x2.\n       \\<lbrakk>Le (0::'a) \\<le> Lt x2; Le (0::'a) < Lt x2 + b; a = Lt x2;\n        b < Le (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt x2 \\<and>\n                            Le (- d) \\<le> b \\<and> (0::'a) \\<le> d\n 4. \\<lbrakk>Le (0::'a) \\<le> \\<infinity>; Le (0::'a) < \\<infinity> + b;\n     a = \\<infinity>; b < Le (0::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> \\<infinity> \\<and>\n                         Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "with \\<open>Le 0 \\<le> Le a'\\<close>"], ["proof (chain)\npicking this:\n  Le (0::'a) \\<le> Le a'\n  - a' < b'", "show ?case"], ["proof (prove)\nusing this:\n  Le (0::'a) \\<le> Le a'\n  - a' < b'\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       Le d \\<le> Le a' \\<and> Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d", "by (auto simp: dbm_le_def less_eq le_dbm_le)"], ["proof (state)\nthis:\n  \\<exists>d.\n     Le d \\<le> Le a' \\<and> Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + \\<infinity>;\n        \\<infinity> < Le (0::'a); a = Le x1; b = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> \\<infinity> \\<and>\n                            (0::'a) \\<le> d\n 2. \\<And>x2.\n       \\<lbrakk>Le (0::'a) \\<le> Lt x2; Le (0::'a) < Lt x2 + b; a = Lt x2;\n        b < Le (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt x2 \\<and>\n                            Le (- d) \\<le> b \\<and> (0::'a) \\<le> d\n 3. \\<lbrakk>Le (0::'a) \\<le> \\<infinity>; Le (0::'a) < \\<infinity> + b;\n     a = \\<infinity>; b < Le (0::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> \\<infinity> \\<and>\n                         Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + \\<infinity>;\n        \\<infinity> < Le (0::'a); a = Le x1; b = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> \\<infinity> \\<and>\n                            (0::'a) \\<le> d\n 2. \\<And>x2.\n       \\<lbrakk>Le (0::'a) \\<le> Lt x2; Le (0::'a) < Lt x2 + b; a = Lt x2;\n        b < Le (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt x2 \\<and>\n                            Le (- d) \\<le> b \\<and> (0::'a) \\<le> d\n 3. \\<lbrakk>Le (0::'a) \\<le> \\<infinity>; Le (0::'a) < \\<infinity> + b;\n     a = \\<infinity>; b < Le (0::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> \\<infinity> \\<and>\n                         Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "case (3 a')"], ["proof (state)\nthis:\n  Le (0::'a) \\<le> Le a'\n  Le (0::'a) < Le a' + \\<infinity>\n  \\<infinity> < Le (0::'a)\n  a = Le a'\n  b = \\<infinity>\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Le (0::'a) \\<le> Le x1; Le (0::'a) < Le x1 + \\<infinity>;\n        \\<infinity> < Le (0::'a); a = Le x1; b = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Le x1 \\<and>\n                            Le (- d) \\<le> \\<infinity> \\<and>\n                            (0::'a) \\<le> d\n 2. \\<And>x2.\n       \\<lbrakk>Le (0::'a) \\<le> Lt x2; Le (0::'a) < Lt x2 + b; a = Lt x2;\n        b < Le (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt x2 \\<and>\n                            Le (- d) \\<le> b \\<and> (0::'a) \\<le> d\n 3. \\<lbrakk>Le (0::'a) \\<le> \\<infinity>; Le (0::'a) < \\<infinity> + b;\n     a = \\<infinity>; b < Le (0::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> \\<infinity> \\<and>\n                         Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "thus ?case"], ["proof (prove)\nusing this:\n  Le (0::'a) \\<le> Le a'\n  Le (0::'a) < Le a' + \\<infinity>\n  \\<infinity> < Le (0::'a)\n  a = Le a'\n  b = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       Le d \\<le> Le a' \\<and>\n       Le (- d) \\<le> \\<infinity> \\<and> (0::'a) \\<le> d", "by (auto simp: dbm_le_def less_eq)"], ["proof (state)\nthis:\n  \\<exists>d.\n     Le d \\<le> Le a' \\<and>\n     Le (- d) \\<le> \\<infinity> \\<and> (0::'a) \\<le> d\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>Le (0::'a) \\<le> Lt x2; Le (0::'a) < Lt x2 + b; a = Lt x2;\n        b < Le (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt x2 \\<and>\n                            Le (- d) \\<le> b \\<and> (0::'a) \\<le> d\n 2. \\<lbrakk>Le (0::'a) \\<le> \\<infinity>; Le (0::'a) < \\<infinity> + b;\n     a = \\<infinity>; b < Le (0::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> \\<infinity> \\<and>\n                         Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>Le (0::'a) \\<le> Lt x2; Le (0::'a) < Lt x2 + b; a = Lt x2;\n        b < Le (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt x2 \\<and>\n                            Le (- d) \\<le> b \\<and> (0::'a) \\<le> d\n 2. \\<lbrakk>Le (0::'a) \\<le> \\<infinity>; Le (0::'a) < \\<infinity> + b;\n     a = \\<infinity>; b < Le (0::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> \\<infinity> \\<and>\n                         Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "case (4 a')"], ["proof (state)\nthis:\n  Le (0::'a) \\<le> Lt a'\n  Le (0::'a) < Lt a' + b\n  a = Lt a'\n  b < Le (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>Le (0::'a) \\<le> Lt x2; Le (0::'a) < Lt x2 + b; a = Lt x2;\n        b < Le (0::'a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt x2 \\<and>\n                            Le (- d) \\<le> b \\<and> (0::'a) \\<le> d\n 2. \\<lbrakk>Le (0::'a) \\<le> \\<infinity>; Le (0::'a) < \\<infinity> + b;\n     a = \\<infinity>; b < Le (0::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> \\<infinity> \\<and>\n                         Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "thus ?case"], ["proof (prove)\nusing this:\n  Le (0::'a) \\<le> Lt a'\n  Le (0::'a) < Lt a' + b\n  a = Lt a'\n  b < Le (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       Le d \\<le> Lt a' \\<and> Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "proof (cases b, auto, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Le (0::'a) < Lt a' + Le x1; Le x1 < Le (0::'a); b = Le x1;\n        Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt a' \\<and>\n                            Le (- d) \\<le> Le x1 \\<and> (0::'a) \\<le> d\n 2. \\<And>x2.\n       \\<lbrakk>Le (0::'a) < Lt a' + Lt x2; Lt x2 < Le (0::'a); b = Lt x2;\n        Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt a' \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d\n 3. \\<lbrakk>Le (0::'a) < Lt a' + \\<infinity>; \\<infinity> < Le (0::'a);\n     b = \\<infinity>; Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> Lt a' \\<and>\n                         Le (- d) \\<le> \\<infinity> \\<and> (0::'a) \\<le> d", "case (1 b')"], ["proof (state)\nthis:\n  Le (0::'a) < Lt a' + Le b'\n  Le b' < Le (0::'a)\n  b = Le b'\n  Le (0::'a) \\<le> Lt a'\n  a = Lt a'\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Le (0::'a) < Lt a' + Le x1; Le x1 < Le (0::'a); b = Le x1;\n        Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt a' \\<and>\n                            Le (- d) \\<le> Le x1 \\<and> (0::'a) \\<le> d\n 2. \\<And>x2.\n       \\<lbrakk>Le (0::'a) < Lt a' + Lt x2; Lt x2 < Le (0::'a); b = Lt x2;\n        Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt a' \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d\n 3. \\<lbrakk>Le (0::'a) < Lt a' + \\<infinity>; \\<infinity> < Le (0::'a);\n     b = \\<infinity>; Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> Lt a' \\<and>\n                         Le (- d) \\<le> \\<infinity> \\<and> (0::'a) \\<le> d", "have \"b' < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b' < (0::'a)", "using 1(2)"], ["proof (prove)\nusing this:\n  Le b' < Le (0::'a)\n\ngoal (1 subgoal):\n 1. b' < (0::'a)", "by (metis dbm_lt.intros(3) less less_asym neqE)"], ["proof (state)\nthis:\n  b' < (0::'a)\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Le (0::'a) < Lt a' + Le x1; Le x1 < Le (0::'a); b = Le x1;\n        Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt a' \\<and>\n                            Le (- d) \\<le> Le x1 \\<and> (0::'a) \\<le> d\n 2. \\<And>x2.\n       \\<lbrakk>Le (0::'a) < Lt a' + Lt x2; Lt x2 < Le (0::'a); b = Lt x2;\n        Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt a' \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d\n 3. \\<lbrakk>Le (0::'a) < Lt a' + \\<infinity>; \\<infinity> < Le (0::'a);\n     b = \\<infinity>; Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> Lt a' \\<and>\n                         Le (- d) \\<le> \\<infinity> \\<and> (0::'a) \\<le> d", "from 1"], ["proof (chain)\npicking this:\n  Le (0::'a) < Lt a' + Le b'\n  Le b' < Le (0::'a)\n  b = Le b'\n  Le (0::'a) \\<le> Lt a'\n  a = Lt a'", "have \"a' + b' > 0\""], ["proof (prove)\nusing this:\n  Le (0::'a) < Lt a' + Le b'\n  Le b' < Le (0::'a)\n  b = Le b'\n  Le (0::'a) \\<le> Lt a'\n  a = Lt a'\n\ngoal (1 subgoal):\n 1. (0::'a) < a' + b'", "by (auto elim: dbm_lt.cases simp: less mult)"], ["proof (state)\nthis:\n  (0::'a) < a' + b'\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Le (0::'a) < Lt a' + Le x1; Le x1 < Le (0::'a); b = Le x1;\n        Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt a' \\<and>\n                            Le (- d) \\<le> Le x1 \\<and> (0::'a) \\<le> d\n 2. \\<And>x2.\n       \\<lbrakk>Le (0::'a) < Lt a' + Lt x2; Lt x2 < Le (0::'a); b = Lt x2;\n        Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt a' \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d\n 3. \\<lbrakk>Le (0::'a) < Lt a' + \\<infinity>; \\<infinity> < Le (0::'a);\n     b = \\<infinity>; Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> Lt a' \\<and>\n                         Le (- d) \\<le> \\<infinity> \\<and> (0::'a) \\<le> d", "then"], ["proof (chain)\npicking this:\n  (0::'a) < a' + b'", "have \"-b' < a'\""], ["proof (prove)\nusing this:\n  (0::'a) < a' + b'\n\ngoal (1 subgoal):\n 1. - b' < a'", "by (metis diff_0 diff_less_eq)"], ["proof (state)\nthis:\n  - b' < a'\n\ngoal (3 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Le (0::'a) < Lt a' + Le x1; Le x1 < Le (0::'a); b = Le x1;\n        Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt a' \\<and>\n                            Le (- d) \\<le> Le x1 \\<and> (0::'a) \\<le> d\n 2. \\<And>x2.\n       \\<lbrakk>Le (0::'a) < Lt a' + Lt x2; Lt x2 < Le (0::'a); b = Lt x2;\n        Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt a' \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d\n 3. \\<lbrakk>Le (0::'a) < Lt a' + \\<infinity>; \\<infinity> < Le (0::'a);\n     b = \\<infinity>; Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> Lt a' \\<and>\n                         Le (- d) \\<le> \\<infinity> \\<and> (0::'a) \\<le> d", "with \\<open>b' < 0\\<close>"], ["proof (chain)\npicking this:\n  b' < (0::'a)\n  - b' < a'", "show ?case"], ["proof (prove)\nusing this:\n  b' < (0::'a)\n  - b' < a'\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       Le d \\<le> Lt a' \\<and> Le (- d) \\<le> Le b' \\<and> (0::'a) \\<le> d", "by (auto simp: dbm_le_def less_eq)"], ["proof (state)\nthis:\n  \\<exists>d.\n     Le d \\<le> Lt a' \\<and> Le (- d) \\<le> Le b' \\<and> (0::'a) \\<le> d\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>Le (0::'a) < Lt a' + Lt x2; Lt x2 < Le (0::'a); b = Lt x2;\n        Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt a' \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d\n 2. \\<lbrakk>Le (0::'a) < Lt a' + \\<infinity>; \\<infinity> < Le (0::'a);\n     b = \\<infinity>; Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> Lt a' \\<and>\n                         Le (- d) \\<le> \\<infinity> \\<and> (0::'a) \\<le> d", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>Le (0::'a) < Lt a' + Lt x2; Lt x2 < Le (0::'a); b = Lt x2;\n        Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt a' \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d\n 2. \\<lbrakk>Le (0::'a) < Lt a' + \\<infinity>; \\<infinity> < Le (0::'a);\n     b = \\<infinity>; Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> Lt a' \\<and>\n                         Le (- d) \\<le> \\<infinity> \\<and> (0::'a) \\<le> d", "case (2 b')"], ["proof (state)\nthis:\n  Le (0::'a) < Lt a' + Lt b'\n  Lt b' < Le (0::'a)\n  b = Lt b'\n  Le (0::'a) \\<le> Lt a'\n  a = Lt a'\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>Le (0::'a) < Lt a' + Lt x2; Lt x2 < Le (0::'a); b = Lt x2;\n        Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt a' \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d\n 2. \\<lbrakk>Le (0::'a) < Lt a' + \\<infinity>; \\<infinity> < Le (0::'a);\n     b = \\<infinity>; Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> Lt a' \\<and>\n                         Le (- d) \\<le> \\<infinity> \\<and> (0::'a) \\<le> d", "then"], ["proof (chain)\npicking this:\n  Le (0::'a) < Lt a' + Lt b'\n  Lt b' < Le (0::'a)\n  b = Lt b'\n  Le (0::'a) \\<le> Lt a'\n  a = Lt a'", "have A: \"b' \\<le> 0\" \"a' > 0\""], ["proof (prove)\nusing this:\n  Le (0::'a) < Lt a' + Lt b'\n  Lt b' < Le (0::'a)\n  b = Lt b'\n  Le (0::'a) \\<le> Lt a'\n  a = Lt a'\n\ngoal (1 subgoal):\n 1. b' \\<le> (0::'a) &&& (0::'a) < a'", "by (auto elim: dbm_lt.cases simp: less less_eq dbm_le_def)"], ["proof (state)\nthis:\n  b' \\<le> (0::'a)\n  (0::'a) < a'\n\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>Le (0::'a) < Lt a' + Lt x2; Lt x2 < Le (0::'a); b = Lt x2;\n        Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> Lt a' \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d\n 2. \\<lbrakk>Le (0::'a) < Lt a' + \\<infinity>; \\<infinity> < Le (0::'a);\n     b = \\<infinity>; Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> Lt a' \\<and>\n                         Le (- d) \\<le> \\<infinity> \\<and> (0::'a) \\<le> d", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d.\n       Le d \\<le> Lt a' \\<and> Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d", "proof (cases \"b' = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b' = (0::'a) \\<Longrightarrow>\n    \\<exists>d.\n       Le d \\<le> Lt a' \\<and> Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d\n 2. b' \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>d.\n       Le d \\<le> Lt a' \\<and> Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d", "case True"], ["proof (state)\nthis:\n  b' = (0::'a)\n\ngoal (2 subgoals):\n 1. b' = (0::'a) \\<Longrightarrow>\n    \\<exists>d.\n       Le d \\<le> Lt a' \\<and> Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d\n 2. b' \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>d.\n       Le d \\<le> Lt a' \\<and> Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d", "from dense[OF A(2)]"], ["proof (chain)\npicking this:\n  \\<exists>z>0::'a. z < a'", "obtain d where d: \"d > 0\" \"d < a'\""], ["proof (prove)\nusing this:\n  \\<exists>z>0::'a. z < a'\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>(0::'a) < d; d < a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (0::'a) < d\n  d < a'\n\ngoal (2 subgoals):\n 1. b' = (0::'a) \\<Longrightarrow>\n    \\<exists>d.\n       Le d \\<le> Lt a' \\<and> Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d\n 2. b' \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>d.\n       Le d \\<le> Lt a' \\<and> Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d", "then"], ["proof (chain)\npicking this:\n  (0::'a) < d\n  d < a'", "have \"Le (-d) < Lt b'\" \"Le d < Lt a'\""], ["proof (prove)\nusing this:\n  (0::'a) < d\n  d < a'\n\ngoal (1 subgoal):\n 1. Le (- d) < Lt b' &&& Le d < Lt a'", "unfolding less"], ["proof (prove)\nusing this:\n  (0::'a) < d\n  d < a'\n\ngoal (1 subgoal):\n 1. Le (- d) \\<prec> Lt b' &&& Le d \\<prec> Lt a'", "using True"], ["proof (prove)\nusing this:\n  (0::'a) < d\n  d < a'\n  b' = (0::'a)\n\ngoal (1 subgoal):\n 1. Le (- d) \\<prec> Lt b' &&& Le d \\<prec> Lt a'", "by auto"], ["proof (state)\nthis:\n  Le (- d) < Lt b'\n  Le d < Lt a'\n\ngoal (2 subgoals):\n 1. b' = (0::'a) \\<Longrightarrow>\n    \\<exists>d.\n       Le d \\<le> Lt a' \\<and> Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d\n 2. b' \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>d.\n       Le d \\<le> Lt a' \\<and> Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d", "with d(1)"], ["proof (chain)\npicking this:\n  (0::'a) < d\n  Le (- d) < Lt b'\n  Le d < Lt a'", "show ?thesis"], ["proof (prove)\nusing this:\n  (0::'a) < d\n  Le (- d) < Lt b'\n  Le d < Lt a'\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       Le d \\<le> Lt a' \\<and> Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d", "by - (rule exI[where x = \"d\"], auto)"], ["proof (state)\nthis:\n  \\<exists>d.\n     Le d \\<le> Lt a' \\<and> Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d\n\ngoal (1 subgoal):\n 1. b' \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>d.\n       Le d \\<le> Lt a' \\<and> Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b' \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>d.\n       Le d \\<le> Lt a' \\<and> Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d", "case False"], ["proof (state)\nthis:\n  b' \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. b' \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>d.\n       Le d \\<le> Lt a' \\<and> Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d", "with A(1)"], ["proof (chain)\npicking this:\n  b' \\<le> (0::'a)\n  b' \\<noteq> (0::'a)", "have *: \"- b' > 0\""], ["proof (prove)\nusing this:\n  b' \\<le> (0::'a)\n  b' \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) < - b'", "by simp"], ["proof (state)\nthis:\n  (0::'a) < - b'\n\ngoal (1 subgoal):\n 1. b' \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>d.\n       Le d \\<le> Lt a' \\<and> Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d", "from 2"], ["proof (chain)\npicking this:\n  Le (0::'a) < Lt a' + Lt b'\n  Lt b' < Le (0::'a)\n  b = Lt b'\n  Le (0::'a) \\<le> Lt a'\n  a = Lt a'", "have \"a' + b' > 0\""], ["proof (prove)\nusing this:\n  Le (0::'a) < Lt a' + Lt b'\n  Lt b' < Le (0::'a)\n  b = Lt b'\n  Le (0::'a) \\<le> Lt a'\n  a = Lt a'\n\ngoal (1 subgoal):\n 1. (0::'a) < a' + b'", "by (auto elim: dbm_lt.cases simp: less mult)"], ["proof (state)\nthis:\n  (0::'a) < a' + b'\n\ngoal (1 subgoal):\n 1. b' \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>d.\n       Le d \\<le> Lt a' \\<and> Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d", "then"], ["proof (chain)\npicking this:\n  (0::'a) < a' + b'", "have \"-b' < a'\""], ["proof (prove)\nusing this:\n  (0::'a) < a' + b'\n\ngoal (1 subgoal):\n 1. - b' < a'", "by (metis less_add_same_cancel1 minus_add_cancel minus_less_iff)"], ["proof (state)\nthis:\n  - b' < a'\n\ngoal (1 subgoal):\n 1. b' \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>d.\n       Le d \\<le> Lt a' \\<and> Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d", "from dense[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>z>- b'. z < a'", "obtain d where d:\n            \"d > -b'\" \"-d < b'\" \"d < a'\""], ["proof (prove)\nusing this:\n  \\<exists>z>- b'. z < a'\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>- b' < d; - d < b'; d < a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: minus_less_iff)"], ["proof (state)\nthis:\n  - b' < d\n  - d < b'\n  d < a'\n\ngoal (1 subgoal):\n 1. b' \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>d.\n       Le d \\<le> Lt a' \\<and> Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d", "then"], ["proof (chain)\npicking this:\n  - b' < d\n  - d < b'\n  d < a'", "have \"Le (-d) < Lt b'\" \"Le d < Lt a'\""], ["proof (prove)\nusing this:\n  - b' < d\n  - d < b'\n  d < a'\n\ngoal (1 subgoal):\n 1. Le (- d) < Lt b' &&& Le d < Lt a'", "unfolding less"], ["proof (prove)\nusing this:\n  - b' < d\n  - d < b'\n  d < a'\n\ngoal (1 subgoal):\n 1. Le (- d) \\<prec> Lt b' &&& Le d \\<prec> Lt a'", "by auto"], ["proof (state)\nthis:\n  Le (- d) < Lt b'\n  Le d < Lt a'\n\ngoal (1 subgoal):\n 1. b' \\<noteq> (0::'a) \\<Longrightarrow>\n    \\<exists>d.\n       Le d \\<le> Lt a' \\<and> Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d", "with d(1) *"], ["proof (chain)\npicking this:\n  - b' < d\n  (0::'a) < - b'\n  Le (- d) < Lt b'\n  Le d < Lt a'", "show ?thesis"], ["proof (prove)\nusing this:\n  - b' < d\n  (0::'a) < - b'\n  Le (- d) < Lt b'\n  Le d < Lt a'\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       Le d \\<le> Lt a' \\<and> Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d", "by - (rule exI[where x = \"d\"], auto,\n                meson d(2) dual_order.order_iff_strict less_trans neg_le_0_iff_le)"], ["proof (state)\nthis:\n  \\<exists>d.\n     Le d \\<le> Lt a' \\<and> Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d.\n     Le d \\<le> Lt a' \\<and> Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Le (0::'a) < Lt a' + \\<infinity>; \\<infinity> < Le (0::'a);\n     b = \\<infinity>; Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> Lt a' \\<and>\n                         Le (- d) \\<le> \\<infinity> \\<and> (0::'a) \\<le> d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Le (0::'a) < Lt a' + \\<infinity>; \\<infinity> < Le (0::'a);\n     b = \\<infinity>; Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> Lt a' \\<and>\n                         Le (- d) \\<le> \\<infinity> \\<and> (0::'a) \\<le> d", "case 3"], ["proof (state)\nthis:\n  Le (0::'a) < Lt a' + \\<infinity>\n  \\<infinity> < Le (0::'a)\n  b = \\<infinity>\n  Le (0::'a) \\<le> Lt a'\n  a = Lt a'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Le (0::'a) < Lt a' + \\<infinity>; \\<infinity> < Le (0::'a);\n     b = \\<infinity>; Le (0::'a) \\<le> Lt a'; a = Lt a'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> Lt a' \\<and>\n                         Le (- d) \\<le> \\<infinity> \\<and> (0::'a) \\<le> d", "thus ?case"], ["proof (prove)\nusing this:\n  Le (0::'a) < Lt a' + \\<infinity>\n  \\<infinity> < Le (0::'a)\n  b = \\<infinity>\n  Le (0::'a) \\<le> Lt a'\n  a = Lt a'\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       Le d \\<le> Lt a' \\<and>\n       Le (- d) \\<le> \\<infinity> \\<and> (0::'a) \\<le> d", "by (auto simp: dbm_le_def less_eq)"], ["proof (state)\nthis:\n  \\<exists>d.\n     Le d \\<le> Lt a' \\<and>\n     Le (- d) \\<le> \\<infinity> \\<and> (0::'a) \\<le> d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d.\n     Le d \\<le> Lt a' \\<and> Le (- d) \\<le> b \\<and> (0::'a) \\<le> d\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Le (0::'a) \\<le> \\<infinity>; Le (0::'a) < \\<infinity> + b;\n     a = \\<infinity>; b < Le (0::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> \\<infinity> \\<and>\n                         Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>Le (0::'a) \\<le> \\<infinity>; Le (0::'a) < \\<infinity> + b;\n     a = \\<infinity>; b < Le (0::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> \\<infinity> \\<and>\n                         Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "case 5"], ["proof (state)\nthis:\n  Le (0::'a) \\<le> \\<infinity>\n  Le (0::'a) < \\<infinity> + b\n  a = \\<infinity>\n  b < Le (0::'a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>Le (0::'a) \\<le> \\<infinity>; Le (0::'a) < \\<infinity> + b;\n     a = \\<infinity>; b < Le (0::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         Le d \\<le> \\<infinity> \\<and>\n                         Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "thus ?case"], ["proof (prove)\nusing this:\n  Le (0::'a) \\<le> \\<infinity>\n  Le (0::'a) < \\<infinity> + b\n  a = \\<infinity>\n  b < Le (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       Le d \\<le> \\<infinity> \\<and> Le (- d) \\<le> b \\<and> (0::'a) \\<le> d", "proof (cases b, auto, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Le (0::'a) < \\<infinity> + Le x1; Le x1 < Le (0::'a);\n        b = Le x1; Le (0::'a) \\<le> \\<infinity>; a = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> \\<infinity> \\<and>\n                            Le (- d) \\<le> Le x1 \\<and> (0::'a) \\<le> d\n 2. \\<And>x2.\n       \\<lbrakk>Le (0::'a) < \\<infinity> + Lt x2; Lt x2 < Le (0::'a);\n        b = Lt x2; Le (0::'a) \\<le> \\<infinity>; a = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> \\<infinity> \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d", "case (1 b')"], ["proof (state)\nthis:\n  Le (0::'a) < \\<infinity> + Le b'\n  Le b' < Le (0::'a)\n  b = Le b'\n  Le (0::'a) \\<le> \\<infinity>\n  a = \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Le (0::'a) < \\<infinity> + Le x1; Le x1 < Le (0::'a);\n        b = Le x1; Le (0::'a) \\<le> \\<infinity>; a = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> \\<infinity> \\<and>\n                            Le (- d) \\<le> Le x1 \\<and> (0::'a) \\<le> d\n 2. \\<And>x2.\n       \\<lbrakk>Le (0::'a) < \\<infinity> + Lt x2; Lt x2 < Le (0::'a);\n        b = Lt x2; Le (0::'a) \\<le> \\<infinity>; a = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> \\<infinity> \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d", "from this(2)"], ["proof (chain)\npicking this:\n  Le b' < Le (0::'a)", "have \"-b' \\<ge> 0\""], ["proof (prove)\nusing this:\n  Le b' < Le (0::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> - b'", "by (metis dbm_lt.intros(3) leI less less_asym neg_less_0_iff_less)"], ["proof (state)\nthis:\n  (0::'a) \\<le> - b'\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Le (0::'a) < \\<infinity> + Le x1; Le x1 < Le (0::'a);\n        b = Le x1; Le (0::'a) \\<le> \\<infinity>; a = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> \\<infinity> \\<and>\n                            Le (- d) \\<le> Le x1 \\<and> (0::'a) \\<le> d\n 2. \\<And>x2.\n       \\<lbrakk>Le (0::'a) < \\<infinity> + Lt x2; Lt x2 < Le (0::'a);\n        b = Lt x2; Le (0::'a) \\<le> \\<infinity>; a = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> \\<infinity> \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d", "let ?d = \"- b'\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Le (0::'a) < \\<infinity> + Le x1; Le x1 < Le (0::'a);\n        b = Le x1; Le (0::'a) \\<le> \\<infinity>; a = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> \\<infinity> \\<and>\n                            Le (- d) \\<le> Le x1 \\<and> (0::'a) \\<le> d\n 2. \\<And>x2.\n       \\<lbrakk>Le (0::'a) < \\<infinity> + Lt x2; Lt x2 < Le (0::'a);\n        b = Lt x2; Le (0::'a) \\<le> \\<infinity>; a = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> \\<infinity> \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d", "have \"Le ?d \\<le> \\<infinity>\" \"Le (- ?d) \\<le> Le b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Le (- b') \\<le> \\<infinity> &&& Le (- (- b')) \\<le> Le b'", "by (auto simp: any_le_inf)"], ["proof (state)\nthis:\n  Le (- b') \\<le> \\<infinity>\n  Le (- (- b')) \\<le> Le b'\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Le (0::'a) < \\<infinity> + Le x1; Le x1 < Le (0::'a);\n        b = Le x1; Le (0::'a) \\<le> \\<infinity>; a = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> \\<infinity> \\<and>\n                            Le (- d) \\<le> Le x1 \\<and> (0::'a) \\<le> d\n 2. \\<And>x2.\n       \\<lbrakk>Le (0::'a) < \\<infinity> + Lt x2; Lt x2 < Le (0::'a);\n        b = Lt x2; Le (0::'a) \\<le> \\<infinity>; a = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> \\<infinity> \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d", "with \\<open>-b' \\<ge> 0\\<close>"], ["proof (chain)\npicking this:\n  (0::'a) \\<le> - b'\n  Le (- b') \\<le> \\<infinity>\n  Le (- (- b')) \\<le> Le b'", "show ?case"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> - b'\n  Le (- b') \\<le> \\<infinity>\n  Le (- (- b')) \\<le> Le b'\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       Le d \\<le> \\<infinity> \\<and>\n       Le (- d) \\<le> Le b' \\<and> (0::'a) \\<le> d", "by auto"], ["proof (state)\nthis:\n  \\<exists>d.\n     Le d \\<le> \\<infinity> \\<and>\n     Le (- d) \\<le> Le b' \\<and> (0::'a) \\<le> d\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>Le (0::'a) < \\<infinity> + Lt x2; Lt x2 < Le (0::'a);\n        b = Lt x2; Le (0::'a) \\<le> \\<infinity>; a = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> \\<infinity> \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>Le (0::'a) < \\<infinity> + Lt x2; Lt x2 < Le (0::'a);\n        b = Lt x2; Le (0::'a) \\<le> \\<infinity>; a = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> \\<infinity> \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d", "case (2 b')"], ["proof (state)\nthis:\n  Le (0::'a) < \\<infinity> + Lt b'\n  Lt b' < Le (0::'a)\n  b = Lt b'\n  Le (0::'a) \\<le> \\<infinity>\n  a = \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>Le (0::'a) < \\<infinity> + Lt x2; Lt x2 < Le (0::'a);\n        b = Lt x2; Le (0::'a) \\<le> \\<infinity>; a = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> \\<infinity> \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d", "then"], ["proof (chain)\npicking this:\n  Le (0::'a) < \\<infinity> + Lt b'\n  Lt b' < Le (0::'a)\n  b = Lt b'\n  Le (0::'a) \\<le> \\<infinity>\n  a = \\<infinity>", "have \"b' \\<le> 0\""], ["proof (prove)\nusing this:\n  Le (0::'a) < \\<infinity> + Lt b'\n  Lt b' < Le (0::'a)\n  b = Lt b'\n  Le (0::'a) \\<le> \\<infinity>\n  a = \\<infinity>\n\ngoal (1 subgoal):\n 1. b' \\<le> (0::'a)", "by (auto elim: dbm_lt.cases simp: less)"], ["proof (state)\nthis:\n  b' \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>Le (0::'a) < \\<infinity> + Lt x2; Lt x2 < Le (0::'a);\n        b = Lt x2; Le (0::'a) \\<le> \\<infinity>; a = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> \\<infinity> \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d", "from non_trivial_neg"], ["proof (chain)\npicking this:\n  \\<exists>x. x < (0::?'a)", "obtain e :: 'a where e:\"e < 0\""], ["proof (prove)\nusing this:\n  \\<exists>x. x < (0::?'a)\n\ngoal (1 subgoal):\n 1. (\\<And>e. e < (0::'a) \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  e < (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>Le (0::'a) < \\<infinity> + Lt x2; Lt x2 < Le (0::'a);\n        b = Lt x2; Le (0::'a) \\<le> \\<infinity>; a = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> \\<infinity> \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d", "let ?d = \"- (b' + e)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>Le (0::'a) < \\<infinity> + Lt x2; Lt x2 < Le (0::'a);\n        b = Lt x2; Le (0::'a) \\<le> \\<infinity>; a = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> \\<infinity> \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d", "from e \\<open>b' \\<le> 0\\<close>"], ["proof (chain)\npicking this:\n  e < (0::'a)\n  b' \\<le> (0::'a)", "have \"Le ?d \\<le> \\<infinity>\" \"Le (- ?d) \\<le> Lt b'\" \"b' + e < 0\""], ["proof (prove)\nusing this:\n  e < (0::'a)\n  b' \\<le> (0::'a)\n\ngoal (1 subgoal):\n 1. Le (- (b' + e)) \\<le> \\<infinity> &&&\n    Le (- (- (b' + e))) \\<le> Lt b' &&& b' + e < (0::'a)", "by (auto simp: dbm_lt.intros(4) less less_imp_le any_le_inf add_nonpos_neg)"], ["proof (state)\nthis:\n  Le (- (b' + e)) \\<le> \\<infinity>\n  Le (- (- (b' + e))) \\<le> Lt b'\n  b' + e < (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>Le (0::'a) < \\<infinity> + Lt x2; Lt x2 < Le (0::'a);\n        b = Lt x2; Le (0::'a) \\<le> \\<infinity>; a = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> \\<infinity> \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d", "then"], ["proof (chain)\npicking this:\n  Le (- (b' + e)) \\<le> \\<infinity>\n  Le (- (- (b' + e))) \\<le> Lt b'\n  b' + e < (0::'a)", "have \"Le ?d \\<le> \\<infinity>\" \"Le (- ?d) \\<le> Lt b'\" \"?d \\<ge> 0\""], ["proof (prove)\nusing this:\n  Le (- (b' + e)) \\<le> \\<infinity>\n  Le (- (- (b' + e))) \\<le> Lt b'\n  b' + e < (0::'a)\n\ngoal (1 subgoal):\n 1. Le (- (b' + e)) \\<le> \\<infinity> &&&\n    Le (- (- (b' + e))) \\<le> Lt b' &&& (0::'a) \\<le> - (b' + e)", "using less_imp_le neg_0_le_iff_le"], ["proof (prove)\nusing this:\n  Le (- (b' + e)) \\<le> \\<infinity>\n  Le (- (- (b' + e))) \\<le> Lt b'\n  b' + e < (0::'a)\n  ?x < ?y \\<Longrightarrow> ?x \\<le> ?y\n  ((0::?'a) \\<le> - ?a) = (?a \\<le> (0::?'a))\n\ngoal (1 subgoal):\n 1. Le (- (b' + e)) \\<le> \\<infinity> &&&\n    Le (- (- (b' + e))) \\<le> Lt b' &&& (0::'a) \\<le> - (b' + e)", "by blast+"], ["proof (state)\nthis:\n  Le (- (b' + e)) \\<le> \\<infinity>\n  Le (- (- (b' + e))) \\<le> Lt b'\n  (0::'a) \\<le> - (b' + e)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>Le (0::'a) < \\<infinity> + Lt x2; Lt x2 < Le (0::'a);\n        b = Lt x2; Le (0::'a) \\<le> \\<infinity>; a = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            Le d \\<le> \\<infinity> \\<and>\n                            Le (- d) \\<le> Lt x2 \\<and> (0::'a) \\<le> d", "thus ?case"], ["proof (prove)\nusing this:\n  Le (- (b' + e)) \\<le> \\<infinity>\n  Le (- (- (b' + e))) \\<le> Lt b'\n  (0::'a) \\<le> - (b' + e)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       Le d \\<le> \\<infinity> \\<and>\n       Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d", "by auto"], ["proof (state)\nthis:\n  \\<exists>d.\n     Le d \\<le> \\<infinity> \\<and>\n     Le (- d) \\<le> Lt b' \\<and> (0::'a) \\<le> d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d.\n     Le d \\<le> \\<infinity> \\<and> Le (- d) \\<le> b \\<and> (0::'a) \\<le> d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b \\<and> (0::'a) \\<le> d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b \\<and> (0::'a) \\<le> d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_gt_neutral_dest:\n  \"(a :: (('a :: time) DBMEntry)) + b > \\<one> \\<Longrightarrow> \\<exists> d. Le d \\<le> a \\<and> Le (-d) \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<one> < a + b \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<one> < a + b \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b", "assume A: \"a + b > \\<one>\""], ["proof (state)\nthis:\n  \\<one> < a + b\n\ngoal (1 subgoal):\n 1. \\<one> < a + b \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b", "then"], ["proof (chain)\npicking this:\n  \\<one> < a + b", "have A': \"b + a > \\<one>\""], ["proof (prove)\nusing this:\n  \\<one> < a + b\n\ngoal (1 subgoal):\n 1. \\<one> < b + a", "by (simp add: comm)"], ["proof (state)\nthis:\n  \\<one> < b + a\n\ngoal (1 subgoal):\n 1. \\<one> < a + b \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b", "proof (cases \"a \\<ge> \\<one>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<one> \\<le> a \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b\n 2. \\<not> \\<one> \\<le> a \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b", "case True"], ["proof (state)\nthis:\n  \\<one> \\<le> a\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> a \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b\n 2. \\<not> \\<one> \\<le> a \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b", "with A sum_gt_neutral_dest'"], ["proof (chain)\npicking this:\n  \\<one> < a + b\n  \\<lbrakk>\\<one> \\<le> ?a; \\<one> < ?a + ?b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>d.\n                       Le d \\<le> ?a \\<and>\n                       Le (- d) \\<le> ?b \\<and> (0::?'a) \\<le> d\n  \\<one> \\<le> a", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<one> < a + b\n  \\<lbrakk>\\<one> \\<le> ?a; \\<one> < ?a + ?b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>d.\n                       Le d \\<le> ?a \\<and>\n                       Le (- d) \\<le> ?b \\<and> (0::?'a) \\<le> d\n  \\<one> \\<le> a\n\ngoal (1 subgoal):\n 1. \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b", "by auto"], ["proof (state)\nthis:\n  \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> a \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> a \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b", "case False"], ["proof (state)\nthis:\n  \\<not> \\<one> \\<le> a\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> a \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b", "{"], ["proof (state)\nthis:\n  \\<not> \\<one> \\<le> a\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> a \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b", "assume \"b \\<le> \\<one>\""], ["proof (state)\nthis:\n  b \\<le> \\<one>\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> a \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b", "with False"], ["proof (chain)\npicking this:\n  \\<not> \\<one> \\<le> a\n  b \\<le> \\<one>", "have \"a \\<le> \\<one>\" \"b \\<le> \\<one>\""], ["proof (prove)\nusing this:\n  \\<not> \\<one> \\<le> a\n  b \\<le> \\<one>\n\ngoal (1 subgoal):\n 1. a \\<le> \\<one> &&& b \\<le> \\<one>", "by auto"], ["proof (state)\nthis:\n  a \\<le> \\<one>\n  b \\<le> \\<one>\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> a \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b", "from add_mono[OF this]"], ["proof (chain)\npicking this:\n  a + b \\<le> \\<one> + \\<one>", "have \"a + b \\<le> \\<one>\""], ["proof (prove)\nusing this:\n  a + b \\<le> \\<one> + \\<one>\n\ngoal (1 subgoal):\n 1. a + b \\<le> \\<one>", "by auto"], ["proof (state)\nthis:\n  a + b \\<le> \\<one>\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> a \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b", "with A"], ["proof (chain)\npicking this:\n  \\<one> < a + b\n  a + b \\<le> \\<one>", "have False"], ["proof (prove)\nusing this:\n  \\<one> < a + b\n  a + b \\<le> \\<one>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> a \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b", "}"], ["proof (state)\nthis:\n  b \\<le> \\<one> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> a \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b", "then"], ["proof (chain)\npicking this:\n  b \\<le> \\<one> \\<Longrightarrow> False", "have \"b \\<ge> \\<one>\""], ["proof (prove)\nusing this:\n  b \\<le> \\<one> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<one> \\<le> b", "by fastforce"], ["proof (state)\nthis:\n  \\<one> \\<le> b\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> a \\<Longrightarrow>\n    \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b", "with sum_gt_neutral_dest'[OF this A']"], ["proof (chain)\npicking this:\n  \\<exists>d. Le d \\<le> b \\<and> Le (- d) \\<le> a \\<and> (0::'a) \\<le> d\n  \\<one> \\<le> b", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>d. Le d \\<le> b \\<and> Le (- d) \\<le> a \\<and> (0::'a) \\<le> d\n  \\<one> \\<le> b\n\ngoal (1 subgoal):\n 1. \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b", "by auto"], ["proof (state)\nthis:\n  \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d. Le d \\<le> a \\<and> Le (- d) \\<le> b\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>\n  Negative Cycles in DBMs\n\\<close>"], ["", "lemma DBM_val_bounded_neg_cycle1:\nfixes i xs assumes\n  bounded: \"DBM_val_bounded v u M n\" and A:\"i \\<le> n\" \"set xs \\<subseteq> {0..n}\" \"len M i i xs < \\<one>\" and\n  surj_on: \"\\<forall> k \\<le> n. k > 0 \\<longrightarrow> (\\<exists> c. v c = k)\" and at_most: \"i \\<noteq> 0\" \"cnt 0 xs \\<le> 1\"\nshows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from A(1) surj_on at_most"], ["proof (chain)\npicking this:\n  i \\<le> n\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\n  i \\<noteq> 0\n  cnt 0 xs \\<le> 1", "obtain c where c: \"v c = i\""], ["proof (prove)\nusing this:\n  i \\<le> n\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\n  i \\<noteq> 0\n  cnt 0 xs \\<le> 1\n\ngoal (1 subgoal):\n 1. (\\<And>c. v c = i \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  v c = i\n\ngoal (1 subgoal):\n 1. False", "with DBM_val_bounded_len'3[OF bounded at_most(2), of c c] A(1,2) surj_on"], ["proof (chain)\npicking this:\n  \\<lbrakk>v c \\<le> n; v c \\<le> n;\n   \\<forall>k\\<in>set xs.\n      0 < k \\<longrightarrow>\n      k \\<le> n \\<and> (\\<exists>c. v c = k)\\<rbrakk>\n  \\<Longrightarrow> dbm_entry_val u (Some c) (Some c) (len M (v c) (v c) xs)\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\n  v c = i", "have bounded:\"dbm_entry_val u (Some c) (Some c) (len M i i xs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>v c \\<le> n; v c \\<le> n;\n   \\<forall>k\\<in>set xs.\n      0 < k \\<longrightarrow>\n      k \\<le> n \\<and> (\\<exists>c. v c = k)\\<rbrakk>\n  \\<Longrightarrow> dbm_entry_val u (Some c) (Some c) (len M (v c) (v c) xs)\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\n  v c = i\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) (Some c) (len M i i xs)", "by force"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c) (Some c) (len M i i xs)\n\ngoal (1 subgoal):\n 1. False", "from A(3)"], ["proof (chain)\npicking this:\n  len M i i xs < \\<one>", "have \"len M i i xs \\<prec> Le 0\""], ["proof (prove)\nusing this:\n  len M i i xs < \\<one>\n\ngoal (1 subgoal):\n 1. len M i i xs \\<prec> Le (0::'b)", "by (simp add: neutral less)"], ["proof (state)\nthis:\n  len M i i xs \\<prec> Le (0::'b)\n\ngoal (1 subgoal):\n 1. False", "then"], ["proof (chain)\npicking this:\n  len M i i xs \\<prec> Le (0::'b)", "show False"], ["proof (prove)\nusing this:\n  len M i i xs \\<prec> Le (0::'b)\n\ngoal (1 subgoal):\n 1. False", "using bounded"], ["proof (prove)\nusing this:\n  len M i i xs \\<prec> Le (0::'b)\n  dbm_entry_val u (Some c) (Some c) (len M i i xs)\n\ngoal (1 subgoal):\n 1. False", "by (cases rule: dbm_lt.cases) (auto elim: dbm_entry_val.cases)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cnt_0_I:\n  \"x \\<notin> set xs \\<Longrightarrow> cnt x xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> set xs \\<Longrightarrow> cnt x xs = 0", "by (induction xs) auto"], ["", "lemma distinct_cnt: \"distinct xs \\<Longrightarrow> cnt x xs \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct xs \\<Longrightarrow> cnt x xs \\<le> 1", "apply (induction xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. distinct [] \\<Longrightarrow> cnt x [] \\<le> 1\n 2. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow> cnt x xs \\<le> 1;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> cnt x (a # xs) \\<le> 1", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow> cnt x xs \\<le> 1;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> cnt x (a # xs) \\<le> 1", "apply (rename_tac a xs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow> cnt x xs \\<le> 1;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> cnt x (a # xs) \\<le> 1", "apply (case_tac \"x = a\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow> cnt x xs \\<le> 1;\n        distinct (a # xs); x = a\\<rbrakk>\n       \\<Longrightarrow> cnt x (a # xs) \\<le> 1\n 2. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow> cnt x xs \\<le> 1;\n        distinct (a # xs); x \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> cnt x (a # xs) \\<le> 1", "using cnt_0_I"], ["proof (prove)\nusing this:\n  ?x \\<notin> set ?xs \\<Longrightarrow> cnt ?x ?xs = 0\n\ngoal (2 subgoals):\n 1. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow> cnt x xs \\<le> 1;\n        distinct (a # xs); x = a\\<rbrakk>\n       \\<Longrightarrow> cnt x (a # xs) \\<le> 1\n 2. \\<And>a xs.\n       \\<lbrakk>distinct xs \\<Longrightarrow> cnt x xs \\<le> 1;\n        distinct (a # xs); x \\<noteq> a\\<rbrakk>\n       \\<Longrightarrow> cnt x (a # xs) \\<le> 1", "by fastforce+"], ["", "lemma DBM_val_bounded_neg_cycle:\nfixes i xs assumes\n  bounded: \"DBM_val_bounded v u M n\" and A:\"i \\<le> n\" \"set xs \\<subseteq> {0..n}\" \"len M i i xs < \\<one>\" and\n  surj_on: \"\\<forall> k \\<le> n. k > 0 \\<longrightarrow> (\\<exists> c. v c = k)\"\nshows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "from negative_len_shortest[OF _ A(3)]"], ["proof (chain)\npicking this:\n  length xs = ?n \\<Longrightarrow>\n  \\<exists>j ys.\n     distinct (j # ys) \\<and>\n     len M j j ys < \\<one> \\<and>\n     j \\<in> set (i # xs) \\<and> set ys \\<subseteq> set xs", "obtain j ys where ys:\n    \"distinct (j # ys)\" \"len M j j ys < \\<one>\" \"j \\<in> set (i # xs)\" \"set ys \\<subseteq> set xs\""], ["proof (prove)\nusing this:\n  length xs = ?n \\<Longrightarrow>\n  \\<exists>j ys.\n     distinct (j # ys) \\<and>\n     len M j j ys < \\<one> \\<and>\n     j \\<in> set (i # xs) \\<and> set ys \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>j ys.\n        \\<lbrakk>distinct (j # ys); len M j j ys < \\<one>;\n         j \\<in> set (i # xs); set ys \\<subseteq> set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  distinct (j # ys)\n  len M j j ys < \\<one>\n  j \\<in> set (i # xs)\n  set ys \\<subseteq> set xs\n\ngoal (1 subgoal):\n 1. False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"ys = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow> False\n 2. ys \\<noteq> [] \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  ys = []\n\ngoal (2 subgoals):\n 1. ys = [] \\<Longrightarrow> False\n 2. ys \\<noteq> [] \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"j = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow> False\n 2. j \\<noteq> 0 \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  j = 0\n\ngoal (2 subgoals):\n 1. j = 0 \\<Longrightarrow> False\n 2. j \\<noteq> 0 \\<Longrightarrow> False", "with \\<open>ys = []\\<close> ys bounded"], ["proof (chain)\npicking this:\n  ys = []\n  distinct (j # ys)\n  len M j j ys < \\<one>\n  j \\<in> set (i # xs)\n  set ys \\<subseteq> set xs\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> M\n  j = 0", "show False"], ["proof (prove)\nusing this:\n  ys = []\n  distinct (j # ys)\n  len M j j ys < \\<one>\n  j \\<in> set (i # xs)\n  set ys \\<subseteq> set xs\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> M\n  j = 0\n\ngoal (1 subgoal):\n 1. False", "unfolding DBM_val_bounded_def neutral less_eq[symmetric]"], ["proof (prove)\nusing this:\n  ys = []\n  distinct (j # ys)\n  len M j j ys < Le (0::'b)\n  j \\<in> set (i # xs)\n  set ys \\<subseteq> set xs\n  Le (0::'b) \\<le> M 0 0 \\<and>\n  (\\<forall>c.\n      v c \\<le> n \\<longrightarrow>\n      dbm_entry_val u None (Some c) (M 0 (v c)) \\<and>\n      dbm_entry_val u (Some c) None (M (v c) 0)) \\<and>\n  (\\<forall>c1 c2.\n      v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n      dbm_entry_val u (Some c1) (Some c2) (M (v c1) (v c2)))\n  j = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. j \\<noteq> 0 \\<Longrightarrow> False", "with \\<open>ys = []\\<close> DBM_val_bounded_neg_cycle1[OF bounded _ _ ys(2) surj_on] ys(3) A(1,2)"], ["proof (chain)\npicking this:\n  ys = []\n  \\<lbrakk>j \\<le> n; set ys \\<subseteq> {0..n}; j \\<noteq> 0;\n   cnt 0 ys \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> False\n  j \\<in> set (i # xs)\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  j \\<noteq> 0", "show False"], ["proof (prove)\nusing this:\n  ys = []\n  \\<lbrakk>j \\<le> n; set ys \\<subseteq> {0..n}; j \\<noteq> 0;\n   cnt 0 ys \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> False\n  j \\<in> set (i # xs)\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [] \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ys \\<noteq> [] \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [] \\<Longrightarrow> False", "from distinct_arcs_ex[OF _ _ this, of j 0 j] ys(1)"], ["proof (chain)\npicking this:\n  \\<lbrakk>distinct ys; j \\<notin> set ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a b.\n                       a \\<noteq> 0 \\<and> (a, b) \\<in> set (arcs j j ys)\n  distinct (j # ys)", "obtain a b where arc:\n      \"a \\<noteq> 0\" \"(a, b) \\<in> set (arcs j j ys)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct ys; j \\<notin> set ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a b.\n                       a \\<noteq> 0 \\<and> (a, b) \\<in> set (arcs j j ys)\n  distinct (j # ys)\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>a \\<noteq> 0; (a, b) \\<in> set (arcs j j ys)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> 0\n  (a, b) \\<in> set (arcs j j ys)\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [] \\<Longrightarrow> False", "from cycle_rotate_2'[OF False this(2)]"], ["proof (chain)\npicking this:\n  \\<exists>ysa.\n     len ?M j j ys = len ?M a a (b # ysa) \\<and>\n     set (a # b # ysa) = set (j # ys) \\<and>\n     1 + length ysa = length ys \\<and>\n     set (arcs j j ys) = set (arcs a a (b # ysa))", "obtain zs where zs:\n      \"len M j j ys = len M a a (b # zs)\" \"set (a # b # zs) = set (j # ys)\"\n      \"1 + length zs = length ys\" \"set (arcs j j ys) = set (arcs a a (b # zs))\""], ["proof (prove)\nusing this:\n  \\<exists>ysa.\n     len ?M j j ys = len ?M a a (b # ysa) \\<and>\n     set (a # b # ysa) = set (j # ys) \\<and>\n     1 + length ysa = length ys \\<and>\n     set (arcs j j ys) = set (arcs a a (b # ysa))\n\ngoal (1 subgoal):\n 1. (\\<And>zs.\n        \\<lbrakk>len M j j ys = len M a a (b # zs);\n         set (a # b # zs) = set (j # ys); 1 + length zs = length ys;\n         set (arcs j j ys) = set (arcs a a (b # zs))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  len M j j ys = len M a a (b # zs)\n  set (a # b # zs) = set (j # ys)\n  1 + length zs = length ys\n  set (arcs j j ys) = set (arcs a a (b # zs))\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [] \\<Longrightarrow> False", "with distinct_card[OF ys(1)]"], ["proof (chain)\npicking this:\n  card (set (j # ys)) = length (j # ys)\n  len M j j ys = len M a a (b # zs)\n  set (a # b # zs) = set (j # ys)\n  1 + length zs = length ys\n  set (arcs j j ys) = set (arcs a a (b # zs))", "have \"distinct (a # b # zs)\""], ["proof (prove)\nusing this:\n  card (set (j # ys)) = length (j # ys)\n  len M j j ys = len M a a (b # zs)\n  set (a # b # zs) = set (j # ys)\n  1 + length zs = length ys\n  set (arcs j j ys) = set (arcs a a (b # zs))\n\ngoal (1 subgoal):\n 1. distinct (a # b # zs)", "by (intro card_distinct) auto"], ["proof (state)\nthis:\n  distinct (a # b # zs)\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [] \\<Longrightarrow> False", "with distinct_cnt[of \"b # zs\"]"], ["proof (chain)\npicking this:\n  distinct (b # zs) \\<Longrightarrow> cnt ?x (b # zs) \\<le> 1\n  distinct (a # b # zs)", "have *: \"cnt 0 (b # zs) \\<le> 1\""], ["proof (prove)\nusing this:\n  distinct (b # zs) \\<Longrightarrow> cnt ?x (b # zs) \\<le> 1\n  distinct (a # b # zs)\n\ngoal (1 subgoal):\n 1. cnt 0 (b # zs) \\<le> 1", "by fastforce"], ["proof (state)\nthis:\n  cnt 0 (b # zs) \\<le> 1\n\ngoal (1 subgoal):\n 1. ys \\<noteq> [] \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "apply (rule DBM_val_bounded_neg_cycle1[OF bounded _ _ _ surj_on \\<open>a \\<noteq> 0\\<close> *])"], ["proof (prove)\ngoal (3 subgoals):\n 1. a \\<le> n\n 2. set (b # zs) \\<subseteq> {0..n}\n 3. len M a a (b # zs) < \\<one>", "using zs(2) ys(3,4) A(1,2)"], ["proof (prove)\nusing this:\n  set (a # b # zs) = set (j # ys)\n  j \\<in> set (i # xs)\n  set ys \\<subseteq> set xs\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n\ngoal (3 subgoals):\n 1. a \\<le> n\n 2. set (b # zs) \\<subseteq> {0..n}\n 3. len M a a (b # zs) < \\<one>", "apply fastforce+"], ["proof (prove)\ngoal (1 subgoal):\n 1. len M a a (b # zs) < \\<one>", "using zs(1) ys(2)"], ["proof (prove)\nusing this:\n  len M j j ys = len M a a (b # zs)\n  len M j j ys < \\<one>\n\ngoal (1 subgoal):\n 1. len M a a (b # zs) < \\<one>", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Floyd-Warshall Algorithm Preservers Zones\\<close>"], ["", "lemma D_dest: \"x = D m i j k \\<Longrightarrow>\n  x \\<in> {len m i j xs |xs. set xs \\<subseteq> {0..k} \\<and> i \\<notin> set xs \\<and> j \\<notin> set xs \\<and> distinct xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = D m i j k \\<Longrightarrow>\n    x \\<in> {len m i j xs |xs.\n             set xs \\<subseteq> {0..k} \\<and>\n             i \\<notin> set xs \\<and> j \\<notin> set xs \\<and> distinct xs}", "using Min_elem_dest[OF D_base_finite'' D_base_not_empty]"], ["proof (prove)\nusing this:\n  ?x =\n  Min {len ?m1 ?i1 ?j1 xs |xs.\n       set xs \\<subseteq> {0..?k1} \\<and>\n       ?i1 \\<notin> set xs \\<and>\n       ?j1 \\<notin> set xs \\<and> distinct xs} \\<Longrightarrow>\n  ?x \\<in> {len ?m1 ?i1 ?j1 xs |xs.\n            set xs \\<subseteq> {0..?k1} \\<and>\n            ?i1 \\<notin> set xs \\<and>\n            ?j1 \\<notin> set xs \\<and> distinct xs}\n\ngoal (1 subgoal):\n 1. x = D m i j k \\<Longrightarrow>\n    x \\<in> {len m i j xs |xs.\n             set xs \\<subseteq> {0..k} \\<and>\n             i \\<notin> set xs \\<and> j \\<notin> set xs \\<and> distinct xs}", "by (fastforce simp add: D_def)"], ["", "lemma FW_zone_equiv:\n  \"\\<forall> k \\<le> n. k > 0 \\<longrightarrow> (\\<exists> c. v c = k) \\<Longrightarrow> [M]\\<^bsub>v,n\\<^esub> = [FW M n]\\<^bsub>v,n\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k\\<le>n.\n       0 < k \\<longrightarrow> (\\<exists>c. v c = k) \\<Longrightarrow>\n    [M]\\<^bsub>v,n\\<^esub> = [FW M n]\\<^bsub>v,n\\<^esub>", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [M]\\<^bsub>v,n\\<^esub>", "fix u"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [M]\\<^bsub>v,n\\<^esub>", "assume A: \"u \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\""], ["proof (state)\nthis:\n  u \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [M]\\<^bsub>v,n\\<^esub>", "{"], ["proof (state)\nthis:\n  u \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [M]\\<^bsub>v,n\\<^esub>", "fix i j"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [M]\\<^bsub>v,n\\<^esub>", "assume \"i \\<le> n\" \"j \\<le> n\""], ["proof (state)\nthis:\n  i \\<le> n\n  j \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [M]\\<^bsub>v,n\\<^esub>", "hence \"FW M n i j \\<le> M i j\""], ["proof (prove)\nusing this:\n  i \\<le> n\n  j \\<le> n\n\ngoal (1 subgoal):\n 1. FW M n i j \\<le> M i j", "using fw_mono[of n n n i j M n]"], ["proof (prove)\nusing this:\n  i \\<le> n\n  j \\<le> n\n  \\<lbrakk>n \\<le> n; n \\<le> n; i \\<le> n; j \\<le> n\\<rbrakk>\n  \\<Longrightarrow> FW M n i j \\<le> M i j\n\ngoal (1 subgoal):\n 1. FW M n i j \\<le> M i j", "by simp"], ["proof (state)\nthis:\n  FW M n i j \\<le> M i j\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [M]\\<^bsub>v,n\\<^esub>", "hence \"FW M n i j \\<preceq> M i j\""], ["proof (prove)\nusing this:\n  FW M n i j \\<le> M i j\n\ngoal (1 subgoal):\n 1. FW M n i j \\<preceq> M i j", "by (simp add: less_eq)"], ["proof (state)\nthis:\n  FW M n i j \\<preceq> M i j\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [M]\\<^bsub>v,n\\<^esub>", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?i2 \\<le> n; ?j2 \\<le> n\\<rbrakk>\n  \\<Longrightarrow> FW M n ?i2 ?j2 \\<preceq> M ?i2 ?j2\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [M]\\<^bsub>v,n\\<^esub>", "with DBM_le_subset[of n \"FW M n\" M] A"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>i j.\n              i \\<le> n \\<longrightarrow>\n              j \\<le> n \\<longrightarrow> FW M n i j \\<preceq> M i j;\n   ?u \\<in> [FW M n]\\<^bsub>?v,n\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> ?u \\<in> [M]\\<^bsub>?v,n\\<^esub>\n  u \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\n  \\<lbrakk>?i2 \\<le> n; ?j2 \\<le> n\\<rbrakk>\n  \\<Longrightarrow> FW M n ?i2 ?j2 \\<preceq> M ?i2 ?j2", "show \"u \\<in> [M]\\<^bsub>v,n\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>i j.\n              i \\<le> n \\<longrightarrow>\n              j \\<le> n \\<longrightarrow> FW M n i j \\<preceq> M i j;\n   ?u \\<in> [FW M n]\\<^bsub>?v,n\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> ?u \\<in> [M]\\<^bsub>?v,n\\<^esub>\n  u \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\n  \\<lbrakk>?i2 \\<le> n; ?j2 \\<le> n\\<rbrakk>\n  \\<Longrightarrow> FW M n ?i2 ?j2 \\<preceq> M ?i2 ?j2\n\ngoal (1 subgoal):\n 1. u \\<in> [M]\\<^bsub>v,n\\<^esub>", "by auto"], ["proof (state)\nthis:\n  u \\<in> [M]\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>", "assume u:\"u \\<in> [M]\\<^bsub>v,n\\<^esub>\" and surj_on: \"\\<forall> k \\<le> n. k > 0 \\<longrightarrow> (\\<exists> c. v c = k)\""], ["proof (state)\nthis:\n  u \\<in> [M]\\<^bsub>v,n\\<^esub>\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>", "hence *:\"DBM_val_bounded v u M n\""], ["proof (prove)\nusing this:\n  u \\<in> [M]\\<^bsub>v,n\\<^esub>\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\n\ngoal (1 subgoal):\n 1. u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "by (simp add: DBM_zone_repr_def)"], ["proof (state)\nthis:\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> M\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>", "note ** = DBM_val_bounded_neg_cycle[OF this _ _ _ surj_on]"], ["proof (state)\nthis:\n  \\<lbrakk>?i \\<le> n; set ?xs \\<subseteq> {0..n};\n   len M ?i ?i ?xs < \\<one>\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>", "have cyc_free: \"cyc_free M n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i xs.\n       i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n       \\<one> \\<le> len M i i xs", "using **"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<le> n; set ?xs \\<subseteq> {0..n};\n   len M ?i ?i ?xs < \\<one>\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<forall>i xs.\n       i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n       \\<one> \\<le> len M i i xs", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>", "with cycle_free_diag_equiv"], ["proof (chain)\npicking this:\n  (\\<forall>i xs.\n      i \\<le> ?n \\<and> set xs \\<subseteq> {0..?n} \\<longrightarrow>\n      \\<one> \\<le> len ?M i i xs) =\n  cycle_free ?M ?n\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs", "have cycle_free: \"cycle_free M n\""], ["proof (prove)\nusing this:\n  (\\<forall>i xs.\n      i \\<le> ?n \\<and> set xs \\<subseteq> {0..?n} \\<longrightarrow>\n      \\<one> \\<le> len ?M i i xs) =\n  cycle_free ?M ?n\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs\n\ngoal (1 subgoal):\n 1. cycle_free M n", "by auto"], ["proof (state)\nthis:\n  cycle_free M n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>", "from cycle_free_diag[OF this]"], ["proof (chain)\npicking this:\n  ?i \\<le> n \\<Longrightarrow> \\<one> \\<le> M ?i ?i", "have diag_ge_zero: \"\\<forall>k\\<le>n. M k k \\<ge> Le 0\""], ["proof (prove)\nusing this:\n  ?i \\<le> n \\<Longrightarrow> \\<one> \\<le> M ?i ?i\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<le>n. Le (0::'b) \\<le> M k k", "unfolding neutral"], ["proof (prove)\nusing this:\n  ?i \\<le> n \\<Longrightarrow> Le (0::'b) \\<le> M ?i ?i\n\ngoal (1 subgoal):\n 1. \\<forall>k\\<le>n. Le (0::'b) \\<le> M k k", "by auto"], ["proof (state)\nthis:\n  \\<forall>k\\<le>n. Le (0::'b) \\<le> M k k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>", "have \"DBM_val_bounded v u (FW M n) n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M n", "unfolding DBM_val_bounded_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Le (0::'b) \\<preceq> FW M n 0 0 \\<and>\n    (\\<forall>c.\n        v c \\<le> n \\<longrightarrow>\n        dbm_entry_val u None (Some c) (FW M n 0 (v c)) \\<and>\n        dbm_entry_val u (Some c) None (FW M n (v c) 0)) \\<and>\n    (\\<forall>c1 c2.\n        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n        dbm_entry_val u (Some c1) (Some c2) (FW M n (v c1) (v c2)))", "proof (auto, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. Le (0::'b) \\<preceq> FW M n 0 0\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u None (Some c) (FW M n 0 (v c))\n 3. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None (FW M n (v c) 0)\n 4. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (FW M n (v c1) (v c2))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. Le (0::'b) \\<preceq> FW M n 0 0\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u None (Some c) (FW M n 0 (v c))\n 3. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None (FW M n (v c) 0)\n 4. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (FW M n (v c1) (v c2))", "from fw_shortest_path[OF cycle_free, of 0 n 0 n n]"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> n; 0 \\<le> n; n \\<le> n; n \\<le> n; n \\<le> n\\<rbrakk>\n  \\<Longrightarrow> D M 0 0 n = FW M n 0 0", "have **:\n      \"D M 0 0 n = FW M n 0 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> n; 0 \\<le> n; n \\<le> n; n \\<le> n; n \\<le> n\\<rbrakk>\n  \\<Longrightarrow> D M 0 0 n = FW M n 0 0\n\ngoal (1 subgoal):\n 1. D M 0 0 n = FW M n 0 0", "by (simp add: neutral)"], ["proof (state)\nthis:\n  D M 0 0 n = FW M n 0 0\n\ngoal (4 subgoals):\n 1. Le (0::'b) \\<preceq> FW M n 0 0\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u None (Some c) (FW M n 0 (v c))\n 3. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None (FW M n (v c) 0)\n 4. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (FW M n (v c1) (v c2))", "from D_dest[OF **[symmetric]]"], ["proof (chain)\npicking this:\n  FW M n 0 0\n  \\<in> {len M 0 0 xs |xs.\n         set xs \\<subseteq> {0..n} \\<and>\n         0 \\<notin> set xs \\<and> 0 \\<notin> set xs \\<and> distinct xs}", "obtain xs where xs:\n        \"FW M n 0 0 = len M 0 0 xs\" \"set xs \\<subseteq> {0..n}\"\n        \"0 \\<notin> set xs\" \"distinct xs\""], ["proof (prove)\nusing this:\n  FW M n 0 0\n  \\<in> {len M 0 0 xs |xs.\n         set xs \\<subseteq> {0..n} \\<and>\n         0 \\<notin> set xs \\<and> 0 \\<notin> set xs \\<and> distinct xs}\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>FW M n 0 0 = len M 0 0 xs; set xs \\<subseteq> {0..n};\n         0 \\<notin> set xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  FW M n 0 0 = len M 0 0 xs\n  set xs \\<subseteq> {0..n}\n  0 \\<notin> set xs\n  distinct xs\n\ngoal (4 subgoals):\n 1. Le (0::'b) \\<preceq> FW M n 0 0\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u None (Some c) (FW M n 0 (v c))\n 3. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None (FW M n (v c) 0)\n 4. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (FW M n (v c1) (v c2))", "with cyc_free"], ["proof (chain)\npicking this:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs\n  FW M n 0 0 = len M 0 0 xs\n  set xs \\<subseteq> {0..n}\n  0 \\<notin> set xs\n  distinct xs", "have \"FW M n 0 0 \\<ge> \\<one>\""], ["proof (prove)\nusing this:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs\n  FW M n 0 0 = len M 0 0 xs\n  set xs \\<subseteq> {0..n}\n  0 \\<notin> set xs\n  distinct xs\n\ngoal (1 subgoal):\n 1. \\<one> \\<le> FW M n 0 0", "by auto"], ["proof (state)\nthis:\n  \\<one> \\<le> FW M n 0 0\n\ngoal (4 subgoals):\n 1. Le (0::'b) \\<preceq> FW M n 0 0\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u None (Some c) (FW M n 0 (v c))\n 3. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None (FW M n (v c) 0)\n 4. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (FW M n (v c1) (v c2))", "then"], ["proof (chain)\npicking this:\n  \\<one> \\<le> FW M n 0 0", "show ?case"], ["proof (prove)\nusing this:\n  \\<one> \\<le> FW M n 0 0\n\ngoal (1 subgoal):\n 1. Le (0::'b) \\<preceq> FW M n 0 0", "unfolding neutral less_eq"], ["proof (prove)\nusing this:\n  Le (0::'b) \\<preceq> FW M n 0 0\n\ngoal (1 subgoal):\n 1. Le (0::'b) \\<preceq> FW M n 0 0", "by simp"], ["proof (state)\nthis:\n  Le (0::'b) \\<preceq> FW M n 0 0\n\ngoal (3 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u None (Some c) (FW M n 0 (v c))\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None (FW M n (v c) 0)\n 3. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (FW M n (v c1) (v c2))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u None (Some c) (FW M n 0 (v c))\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None (FW M n (v c) 0)\n 3. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (FW M n (v c1) (v c2))", "case (2 c)"], ["proof (state)\nthis:\n  v c \\<le> n\n\ngoal (3 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u None (Some c) (FW M n 0 (v c))\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None (FW M n (v c) 0)\n 3. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (FW M n (v c1) (v c2))", "with fw_shortest_path[OF cycle_free, of 0 n \"v c\" n n]"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 \\<le> n; v c \\<le> n; n \\<le> n; n \\<le> n; n \\<le> n\\<rbrakk>\n  \\<Longrightarrow> D M 0 (v c) n = FW M n 0 (v c)\n  v c \\<le> n", "have **:\n      \"D M 0 (v c) n = FW M n 0 (v c)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> n; v c \\<le> n; n \\<le> n; n \\<le> n; n \\<le> n\\<rbrakk>\n  \\<Longrightarrow> D M 0 (v c) n = FW M n 0 (v c)\n  v c \\<le> n\n\ngoal (1 subgoal):\n 1. D M 0 (v c) n = FW M n 0 (v c)", "by (simp add: neutral)"], ["proof (state)\nthis:\n  D M 0 (v c) n = FW M n 0 (v c)\n\ngoal (3 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u None (Some c) (FW M n 0 (v c))\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None (FW M n (v c) 0)\n 3. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (FW M n (v c1) (v c2))", "from D_dest[OF **[symmetric]]"], ["proof (chain)\npicking this:\n  FW M n 0 (v c)\n  \\<in> {len M 0 (v c) xs |xs.\n         set xs \\<subseteq> {0..n} \\<and>\n         0 \\<notin> set xs \\<and> v c \\<notin> set xs \\<and> distinct xs}", "obtain xs where xs:\n        \"FW M n 0 (v c) = len M 0 (v c) xs\" \"set xs \\<subseteq> {0..n}\"\n        \"0 \\<notin> set xs\" \"v c \\<notin> set xs\" \"distinct xs\""], ["proof (prove)\nusing this:\n  FW M n 0 (v c)\n  \\<in> {len M 0 (v c) xs |xs.\n         set xs \\<subseteq> {0..n} \\<and>\n         0 \\<notin> set xs \\<and> v c \\<notin> set xs \\<and> distinct xs}\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>FW M n 0 (v c) = len M 0 (v c) xs;\n         set xs \\<subseteq> {0..n}; 0 \\<notin> set xs; v c \\<notin> set xs;\n         distinct xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  FW M n 0 (v c) = len M 0 (v c) xs\n  set xs \\<subseteq> {0..n}\n  0 \\<notin> set xs\n  v c \\<notin> set xs\n  distinct xs\n\ngoal (3 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u None (Some c) (FW M n 0 (v c))\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None (FW M n (v c) 0)\n 3. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (FW M n (v c1) (v c2))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c) (FW M n 0 (v c))", "unfolding xs(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c) (len M 0 (v c) xs)", "using xs surj_on \\<open>v c \\<le> n\\<close>"], ["proof (prove)\nusing this:\n  FW M n 0 (v c) = len M 0 (v c) xs\n  set xs \\<subseteq> {0..n}\n  0 \\<notin> set xs\n  v c \\<notin> set xs\n  distinct xs\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\n  v c \\<le> n\n\ngoal (1 subgoal):\n 1. dbm_entry_val u None (Some c) (len M 0 (v c) xs)", "by - (rule DBM_val_bounded_len'2[OF * xs(3)]; auto)"], ["proof (state)\nthis:\n  dbm_entry_val u None (Some c) (FW M n 0 (v c))\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None (FW M n (v c) 0)\n 2. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (FW M n (v c1) (v c2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None (FW M n (v c) 0)\n 2. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (FW M n (v c1) (v c2))", "case (3 c)"], ["proof (state)\nthis:\n  v c \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None (FW M n (v c) 0)\n 2. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (FW M n (v c1) (v c2))", "with fw_shortest_path[OF cycle_free, of \"v c\" n 0 n n]"], ["proof (chain)\npicking this:\n  \\<lbrakk>v c \\<le> n; 0 \\<le> n; n \\<le> n; n \\<le> n; n \\<le> n\\<rbrakk>\n  \\<Longrightarrow> D M (v c) 0 n = FW M n (v c) 0\n  v c \\<le> n", "have **:\n      \"D M (v c) 0 n = FW M n (v c) 0\""], ["proof (prove)\nusing this:\n  \\<lbrakk>v c \\<le> n; 0 \\<le> n; n \\<le> n; n \\<le> n; n \\<le> n\\<rbrakk>\n  \\<Longrightarrow> D M (v c) 0 n = FW M n (v c) 0\n  v c \\<le> n\n\ngoal (1 subgoal):\n 1. D M (v c) 0 n = FW M n (v c) 0", "by (simp add: neutral)"], ["proof (state)\nthis:\n  D M (v c) 0 n = FW M n (v c) 0\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None (FW M n (v c) 0)\n 2. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (FW M n (v c1) (v c2))", "with D_dest[OF **[symmetric]]"], ["proof (chain)\npicking this:\n  FW M n (v c) 0\n  \\<in> {len M (v c) 0 xs |xs.\n         set xs \\<subseteq> {0..n} \\<and>\n         v c \\<notin> set xs \\<and> 0 \\<notin> set xs \\<and> distinct xs}\n  D M (v c) 0 n = FW M n (v c) 0", "obtain xs where xs:\n      \"FW M n (v c) 0 = len M (v c) 0 xs\" \"set xs \\<subseteq> {0..n}\"\n      \"0 \\<notin> set xs\" \"v c \\<notin> set xs\" \"distinct xs\""], ["proof (prove)\nusing this:\n  FW M n (v c) 0\n  \\<in> {len M (v c) 0 xs |xs.\n         set xs \\<subseteq> {0..n} \\<and>\n         v c \\<notin> set xs \\<and> 0 \\<notin> set xs \\<and> distinct xs}\n  D M (v c) 0 n = FW M n (v c) 0\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>FW M n (v c) 0 = len M (v c) 0 xs;\n         set xs \\<subseteq> {0..n}; 0 \\<notin> set xs; v c \\<notin> set xs;\n         distinct xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  FW M n (v c) 0 = len M (v c) 0 xs\n  set xs \\<subseteq> {0..n}\n  0 \\<notin> set xs\n  v c \\<notin> set xs\n  distinct xs\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val u (Some c) None (FW M n (v c) 0)\n 2. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (FW M n (v c1) (v c2))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) None (FW M n (v c) 0)", "unfolding xs(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) None (len M (v c) 0 xs)", "using xs surj_on \\<open>v c \\<le> n\\<close>"], ["proof (prove)\nusing this:\n  FW M n (v c) 0 = len M (v c) 0 xs\n  set xs \\<subseteq> {0..n}\n  0 \\<notin> set xs\n  v c \\<notin> set xs\n  distinct xs\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\n  v c \\<le> n\n\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c) None (len M (v c) 0 xs)", "by - (rule DBM_val_bounded_len'1[OF * xs(3)]; auto)"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c) None (FW M n (v c) 0)\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (FW M n (v c1) (v c2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (FW M n (v c1) (v c2))", "case (4 c1 c2)"], ["proof (state)\nthis:\n  v c1 \\<le> n\n  v c2 \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (FW M n (v c1) (v c2))", "with fw_shortest_path[OF cycle_free, of \"v c1\" n \"v c2\" n n]"], ["proof (chain)\npicking this:\n  \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n; n \\<le> n; n \\<le> n;\n   n \\<le> n\\<rbrakk>\n  \\<Longrightarrow> D M (v c1) (v c2) n = FW M n (v c1) (v c2)\n  v c1 \\<le> n\n  v c2 \\<le> n", "have \"D M (v c1) (v c2) n = FW M n (v c1) (v c2)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n; n \\<le> n; n \\<le> n;\n   n \\<le> n\\<rbrakk>\n  \\<Longrightarrow> D M (v c1) (v c2) n = FW M n (v c1) (v c2)\n  v c1 \\<le> n\n  v c2 \\<le> n\n\ngoal (1 subgoal):\n 1. D M (v c1) (v c2) n = FW M n (v c1) (v c2)", "by (simp add: neutral)"], ["proof (state)\nthis:\n  D M (v c1) (v c2) n = FW M n (v c1) (v c2)\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (FW M n (v c1) (v c2))", "from D_dest[OF this[symmetric]]"], ["proof (chain)\npicking this:\n  FW M n (v c1) (v c2)\n  \\<in> {len M (v c1) (v c2) xs |xs.\n         set xs \\<subseteq> {0..n} \\<and>\n         v c1 \\<notin> set xs \\<and>\n         v c2 \\<notin> set xs \\<and> distinct xs}", "obtain xs where xs:\n      \"FW M n (v c1) (v c2) = len M (v c1) (v c2) xs\" \"set xs \\<subseteq> {0..n}\"\n      \"v c1 \\<notin> set xs\" \"v c2 \\<notin> set xs\" \"distinct xs\""], ["proof (prove)\nusing this:\n  FW M n (v c1) (v c2)\n  \\<in> {len M (v c1) (v c2) xs |xs.\n         set xs \\<subseteq> {0..n} \\<and>\n         v c1 \\<notin> set xs \\<and>\n         v c2 \\<notin> set xs \\<and> distinct xs}\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>FW M n (v c1) (v c2) = len M (v c1) (v c2) xs;\n         set xs \\<subseteq> {0..n}; v c1 \\<notin> set xs;\n         v c2 \\<notin> set xs; distinct xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  FW M n (v c1) (v c2) = len M (v c1) (v c2) xs\n  set xs \\<subseteq> {0..n}\n  v c1 \\<notin> set xs\n  v c2 \\<notin> set xs\n  distinct xs\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val u (Some c1) (Some c2)\n                          (FW M n (v c1) (v c2))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) (Some c2) (FW M n (v c1) (v c2))", "unfolding xs(1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dbm_entry_val u (Some c1) (Some c2) (len M (v c1) (v c2) xs)", "apply (rule DBM_val_bounded_len'3[OF *])"], ["proof (prove)\ngoal (4 subgoals):\n 1. cnt 0 xs \\<le> 1\n 2. v c1 \\<le> n\n 3. v c2 \\<le> n\n 4. \\<forall>k\\<in>set xs.\n       0 < k \\<longrightarrow> k \\<le> n \\<and> (\\<exists>c. v c = k)", "using xs surj_on \\<open>v c1 \\<le> n\\<close> \\<open>v c2 \\<le> n\\<close>"], ["proof (prove)\nusing this:\n  FW M n (v c1) (v c2) = len M (v c1) (v c2) xs\n  set xs \\<subseteq> {0..n}\n  v c1 \\<notin> set xs\n  v c2 \\<notin> set xs\n  distinct xs\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\n  v c1 \\<le> n\n  v c2 \\<le> n\n\ngoal (4 subgoals):\n 1. cnt 0 xs \\<le> 1\n 2. v c1 \\<le> n\n 3. v c2 \\<le> n\n 4. \\<forall>k\\<in>set xs.\n       0 < k \\<longrightarrow> k \\<le> n \\<and> (\\<exists>c. v c = k)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>FW M n (v c1) (v c2) = len M (v c1) (v c2) xs;\n     set xs \\<subseteq> {0..n}; v c1 \\<notin> set xs; v c2 \\<notin> set xs;\n     distinct xs;\n     \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n     v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n    \\<Longrightarrow> length (filter (\\<lambda>y. y = 0) xs) \\<le> Suc 0", "apply (drule distinct_cnt[of _ 0])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>FW M n (v c1) (v c2) = len M (v c1) (v c2) xs;\n     set xs \\<subseteq> {0..n}; v c1 \\<notin> set xs; v c2 \\<notin> set xs;\n     \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n     v c1 \\<le> n; v c2 \\<le> n; cnt 0 xs \\<le> 1\\<rbrakk>\n    \\<Longrightarrow> length (filter (\\<lambda>y. y = 0) xs) \\<le> Suc 0", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val u (Some c1) (Some c2) (FW M n (v c1) (v c2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M n\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>k\\<le>n.\n                   0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n        x \\<in> [M]\\<^bsub>v,n\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> x \\<in> [FW M n]\\<^bsub>v,n\\<^esub>", "then"], ["proof (chain)\npicking this:\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M n", "show \"u \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\""], ["proof (prove)\nusing this:\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M n\n\ngoal (1 subgoal):\n 1. u \\<in> [FW M n]\\<^bsub>v,n\\<^esub>", "unfolding DBM_zone_repr_def"], ["proof (prove)\nusing this:\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M n\n\ngoal (1 subgoal):\n 1. u \\<in> {u. u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M n}", "by simp"], ["proof (state)\nthis:\n  u \\<in> [FW M n]\\<^bsub>v,n\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma new_negative_cycle_aux':\n  fixes M :: \"('a :: time) DBM\"\n  fixes i j d\n  defines \"M' \\<equiv> \\<lambda> i' j'. if (i' = i \\<and> j' = j) then Le d\n                       else if (i' = j \\<and> j' = i) then Le (-d)\n                       else M i' j'\"\n  assumes \"i \\<le> n\" \"j \\<le> n\" \"set xs \\<subseteq> {0..n}\" \"cycle_free M n\" \"length xs = m\"\n  assumes \"len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\"\n  assumes \"i \\<noteq> j\"\n  shows \"\\<exists>xs. set xs \\<subseteq> {0..n} \\<and> j \\<notin> set xs \\<and> i \\<notin> set xs\n              \\<and> (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "using assms"], ["proof (prove)\nusing this:\n  M' \\<equiv>\n  \\<lambda>i' j'.\n     if i' = i \\<and> j' = j then Le d\n     else if i' = j \\<and> j' = i then Le (- d) else M i' j'\n  i \\<le> n\n  j \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = m\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "proof (induction _ m arbitrary: xs rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "case (less x)"], ["proof (state)\nthis:\n  \\<lbrakk>?y < x;\n   M' =\n   (\\<lambda>i' j'.\n       if i' = i \\<and> j' = j then Le d\n       else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n   i \\<le> n; j \\<le> n; set ?xs \\<subseteq> {0..n}; cycle_free M n;\n   length ?xs = ?y;\n   len M' i i (j # ?xs) < \\<one> \\<or> len M' j j (i # ?xs) < \\<one>;\n   i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n  M' =\n  (\\<lambda>i' j'.\n      if i' = i \\<and> j' = j then Le d\n      else if i' = j \\<and> j' = i then Le (- d) else M i' j')\n  i \\<le> n\n  j \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?y < x;\n   M' =\n   (\\<lambda>i' j'.\n       if i' = i \\<and> j' = j then Le d\n       else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n   i \\<le> n; j \\<le> n; set ?xs \\<subseteq> {0..n}; cycle_free M n;\n   length ?xs = ?y;\n   len M' i i (j # ?xs) < \\<one> \\<or> len M' j j (i # ?xs) < \\<one>;\n   i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n  M' =\n  (\\<lambda>i' j'.\n      if i' = i \\<and> j' = j then Le d\n      else if i' = j \\<and> j' = i then Le (- d) else M i' j')\n  i \\<le> n\n  j \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "fix b a xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "assume A: \"(i, j) \\<notin> set (arcs b a xs)\" \"(j, i) \\<notin> set (arcs b a xs)\""], ["proof (state)\nthis:\n  (i, j) \\<notin> set (arcs b a xs)\n  (j, i) \\<notin> set (arcs b a xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "with \\<open>i \\<noteq> j\\<close>"], ["proof (chain)\npicking this:\n  i \\<noteq> j\n  (i, j) \\<notin> set (arcs b a xs)\n  (j, i) \\<notin> set (arcs b a xs)", "have \"len M' b a xs = len M b a xs\""], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  (i, j) \\<notin> set (arcs b a xs)\n  (j, i) \\<notin> set (arcs b a xs)\n\ngoal (1 subgoal):\n 1. len M' b a xs = len M b a xs", "unfolding M'_def"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  (i, j) \\<notin> set (arcs b a xs)\n  (j, i) \\<notin> set (arcs b a xs)\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j')\n     b a xs =\n    len M b a xs", "by (induction xs arbitrary: b) auto"], ["proof (state)\nthis:\n  len M' b a xs = len M b a xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(i, j) \\<notin> set (arcs ?b2 ?a2 ?xsb2);\n   (j, i) \\<notin> set (arcs ?b2 ?a2 ?xsb2)\\<rbrakk>\n  \\<Longrightarrow> len M' ?b2 ?a2 ?xsb2 = len M ?b2 ?a2 ?xsb2\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "note * = this"], ["proof (state)\nthis:\n  \\<lbrakk>(i, j) \\<notin> set (arcs ?b2 ?a2 ?xsb2);\n   (j, i) \\<notin> set (arcs ?b2 ?a2 ?xsb2)\\<rbrakk>\n  \\<Longrightarrow> len M' ?b2 ?a2 ?xsb2 = len M ?b2 ?a2 ?xsb2\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(i, j) \\<notin> set (arcs ?b2 ?a2 ?xsb2);\n   (j, i) \\<notin> set (arcs ?b2 ?a2 ?xsb2)\\<rbrakk>\n  \\<Longrightarrow> len M' ?b2 ?a2 ?xsb2 = len M ?b2 ?a2 ?xsb2\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "fix a xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "assume A:\"(i, j) \\<notin> set (arcs a a xs)\" \"(j, i) \\<notin> set (arcs a a xs)\""], ["proof (state)\nthis:\n  (i, j) \\<notin> set (arcs a a xs)\n  (j, i) \\<notin> set (arcs a a xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "assume a: \"a \\<le> n\" and xs: \"set xs \\<subseteq> {0..n}\" and cycle: \"\\<not> len M' a a xs \\<ge> \\<one>\""], ["proof (state)\nthis:\n  a \\<le> n\n  set xs \\<subseteq> {0..n}\n  \\<not> \\<one> \\<le> len M' a a xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "from *[OF A]"], ["proof (chain)\npicking this:\n  len M' a a xs = len M a a xs", "have \"len M' a a xs = len M a a xs\""], ["proof (prove)\nusing this:\n  len M' a a xs = len M a a xs\n\ngoal (1 subgoal):\n 1. len M' a a xs = len M a a xs", "."], ["proof (state)\nthis:\n  len M' a a xs = len M a a xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "with \\<open>cycle_free M n\\<close> \\<open>i \\<le> n\\<close> cycle xs a"], ["proof (chain)\npicking this:\n  cycle_free M n\n  i \\<le> n\n  \\<not> \\<one> \\<le> len M' a a xs\n  set xs \\<subseteq> {0..n}\n  a \\<le> n\n  len M' a a xs = len M a a xs", "have False"], ["proof (prove)\nusing this:\n  cycle_free M n\n  i \\<le> n\n  \\<not> \\<one> \\<le> len M' a a xs\n  set xs \\<subseteq> {0..n}\n  a \\<le> n\n  len M' a a xs = len M a a xs\n\ngoal (1 subgoal):\n 1. False", "unfolding cycle_free_def"], ["proof (prove)\nusing this:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     (\\<forall>j\\<le>n.\n         len M i j (rem_cycles i j xs) \\<le> len M i j xs) \\<and>\n     \\<one> \\<le> len M i i xs\n  i \\<le> n\n  \\<not> \\<one> \\<le> len M' a a xs\n  set xs \\<subseteq> {0..n}\n  a \\<le> n\n  len M' a a xs = len M a a xs\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(i, j) \\<notin> set (arcs ?a2 ?a2 ?xsb2);\n   (j, i) \\<notin> set (arcs ?a2 ?a2 ?xsb2); ?a2 \\<le> n;\n   set ?xsb2 \\<subseteq> {0..n};\n   \\<not> \\<one> \\<le> len M' ?a2 ?a2 ?xsb2\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "note ** = this"], ["proof (state)\nthis:\n  \\<lbrakk>(i, j) \\<notin> set (arcs ?a2 ?a2 ?xsb2);\n   (j, i) \\<notin> set (arcs ?a2 ?a2 ?xsb2); ?a2 \\<le> n;\n   set ?xsb2 \\<subseteq> {0..n};\n   \\<not> \\<one> \\<le> len M' ?a2 ?a2 ?xsb2\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(i, j) \\<notin> set (arcs ?a2 ?a2 ?xsb2);\n   (j, i) \\<notin> set (arcs ?a2 ?a2 ?xsb2); ?a2 \\<le> n;\n   set ?xsb2 \\<subseteq> {0..n};\n   \\<not> \\<one> \\<le> len M' ?a2 ?a2 ?xsb2\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "fix a :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "fix ys :: \"nat list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "assume A: \"ys \\<noteq> []\" \"length ys \\<le> length xs\" \"set ys \\<subseteq> set xs\" \"a \\<le> n\""], ["proof (state)\nthis:\n  ys \\<noteq> []\n  length ys \\<le> length xs\n  set ys \\<subseteq> set xs\n  a \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "assume cycle: \"len M' a a ys < \\<one>\""], ["proof (state)\nthis:\n  len M' a a ys < \\<one>\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "assume arcs: \"(i, j) \\<in> set (arcs a a ys) \\<or> (j, i) \\<in> set (arcs a a ys)\""], ["proof (state)\nthis:\n  (i, j) \\<in> set (arcs a a ys) \\<or> (j, i) \\<in> set (arcs a a ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "from arcs"], ["proof (chain)\npicking this:\n  (i, j) \\<in> set (arcs a a ys) \\<or> (j, i) \\<in> set (arcs a a ys)", "have ?thesis"], ["proof (prove)\nusing this:\n  (i, j) \\<in> set (arcs a a ys) \\<or> (j, i) \\<in> set (arcs a a ys)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (i, j) \\<in> set (arcs a a ys) \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. (j, i) \\<in> set (arcs a a ys) \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "assume \"(i, j) \\<in> set (arcs a a ys)\""], ["proof (state)\nthis:\n  (i, j) \\<in> set (arcs a a ys)\n\ngoal (2 subgoals):\n 1. (i, j) \\<in> set (arcs a a ys) \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. (j, i) \\<in> set (arcs a a ys) \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "from cycle_rotate_2[OF \\<open>ys \\<noteq> []\\<close> this, of M']"], ["proof (chain)\npicking this:\n  \\<exists>ysa.\n     len M' a a ys = len M' i i (j # ysa) \\<and>\n     set ysa \\<subseteq> set (a # ys) \\<and> length ysa < length ys", "obtain ws where ws: \"len M' a a ys = len M' i i (j # ws)\" \"set ws \\<subseteq> set (a # ys)\"\n        \"length ws < length ys\""], ["proof (prove)\nusing this:\n  \\<exists>ysa.\n     len M' a a ys = len M' i i (j # ysa) \\<and>\n     set ysa \\<subseteq> set (a # ys) \\<and> length ysa < length ys\n\ngoal (1 subgoal):\n 1. (\\<And>ws.\n        \\<lbrakk>len M' a a ys = len M' i i (j # ws);\n         set ws \\<subseteq> set (a # ys); length ws < length ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  len M' a a ys = len M' i i (j # ws)\n  set ws \\<subseteq> set (a # ys)\n  length ws < length ys\n\ngoal (2 subgoals):\n 1. (i, j) \\<in> set (arcs a a ys) \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. (j, i) \\<in> set (arcs a a ys) \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "with cycle less.hyps(1)[OF _ less.hyps(2) , of \"length ws\" ws] less.prems A"], ["proof (chain)\npicking this:\n  len M' a a ys < \\<one>\n  \\<lbrakk>length ws < x; i \\<le> n; j \\<le> n; set ws \\<subseteq> {0..n};\n   cycle_free M n; length ws = length ws;\n   len M' i i (j # ws) < \\<one> \\<or> len M' j j (i # ws) < \\<one>;\n   i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n  i \\<le> n\n  j \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\n  i \\<noteq> j\n  ys \\<noteq> []\n  length ys \\<le> length xs\n  set ys \\<subseteq> set xs\n  a \\<le> n\n  len M' a a ys = len M' i i (j # ws)\n  set ws \\<subseteq> set (a # ys)\n  length ws < length ys", "show ?thesis"], ["proof (prove)\nusing this:\n  len M' a a ys < \\<one>\n  \\<lbrakk>length ws < x; i \\<le> n; j \\<le> n; set ws \\<subseteq> {0..n};\n   cycle_free M n; length ws = length ws;\n   len M' i i (j # ws) < \\<one> \\<or> len M' j j (i # ws) < \\<one>;\n   i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n  i \\<le> n\n  j \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\n  i \\<noteq> j\n  ys \\<noteq> []\n  length ys \\<le> length xs\n  set ys \\<subseteq> set xs\n  a \\<le> n\n  len M' a a ys = len M' i i (j # ws)\n  set ws \\<subseteq> set (a # ys)\n  length ws < length ys\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. (j, i) \\<in> set (arcs a a ys) \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (j, i) \\<in> set (arcs a a ys) \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "assume \"(j, i) \\<in> set (arcs a a ys)\""], ["proof (state)\nthis:\n  (j, i) \\<in> set (arcs a a ys)\n\ngoal (1 subgoal):\n 1. (j, i) \\<in> set (arcs a a ys) \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "from cycle_rotate_2[OF \\<open>ys \\<noteq> []\\<close> this, of M']"], ["proof (chain)\npicking this:\n  \\<exists>ysa.\n     len M' a a ys = len M' j j (i # ysa) \\<and>\n     set ysa \\<subseteq> set (a # ys) \\<and> length ysa < length ys", "obtain ws where ws: \"len M' a a ys = len M' j j (i # ws)\" \"set ws \\<subseteq> set (a # ys)\"\n        \"length ws < length ys\""], ["proof (prove)\nusing this:\n  \\<exists>ysa.\n     len M' a a ys = len M' j j (i # ysa) \\<and>\n     set ysa \\<subseteq> set (a # ys) \\<and> length ysa < length ys\n\ngoal (1 subgoal):\n 1. (\\<And>ws.\n        \\<lbrakk>len M' a a ys = len M' j j (i # ws);\n         set ws \\<subseteq> set (a # ys); length ws < length ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  len M' a a ys = len M' j j (i # ws)\n  set ws \\<subseteq> set (a # ys)\n  length ws < length ys\n\ngoal (1 subgoal):\n 1. (j, i) \\<in> set (arcs a a ys) \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "with cycle less.hyps(1)[OF _ less.hyps(2) , of \"length ws\" ws] less.prems A"], ["proof (chain)\npicking this:\n  len M' a a ys < \\<one>\n  \\<lbrakk>length ws < x; i \\<le> n; j \\<le> n; set ws \\<subseteq> {0..n};\n   cycle_free M n; length ws = length ws;\n   len M' i i (j # ws) < \\<one> \\<or> len M' j j (i # ws) < \\<one>;\n   i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n  i \\<le> n\n  j \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\n  i \\<noteq> j\n  ys \\<noteq> []\n  length ys \\<le> length xs\n  set ys \\<subseteq> set xs\n  a \\<le> n\n  len M' a a ys = len M' j j (i # ws)\n  set ws \\<subseteq> set (a # ys)\n  length ws < length ys", "show ?thesis"], ["proof (prove)\nusing this:\n  len M' a a ys < \\<one>\n  \\<lbrakk>length ws < x; i \\<le> n; j \\<le> n; set ws \\<subseteq> {0..n};\n   cycle_free M n; length ws = length ws;\n   len M' i i (j # ws) < \\<one> \\<or> len M' j j (i # ws) < \\<one>;\n   i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n  i \\<le> n\n  j \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\n  i \\<noteq> j\n  ys \\<noteq> []\n  length ys \\<le> length xs\n  set ys \\<subseteq> set xs\n  a \\<le> n\n  len M' a a ys = len M' j j (i # ws)\n  set ws \\<subseteq> set (a # ys)\n  length ws < length ys\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ys2 \\<noteq> []; length ?ys2 \\<le> length xs;\n   set ?ys2 \\<subseteq> set xs; ?a2 \\<le> n; len M' ?a2 ?a2 ?ys2 < \\<one>;\n   (i, j) \\<in> set (arcs ?a2 ?a2 ?ys2) \\<or>\n   (j, i) \\<in> set (arcs ?a2 ?a2 ?ys2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "note *** = this"], ["proof (state)\nthis:\n  \\<lbrakk>?ys2 \\<noteq> []; length ?ys2 \\<le> length xs;\n   set ?ys2 \\<subseteq> set xs; ?a2 \\<le> n; len M' ?a2 ?a2 ?ys2 < \\<one>;\n   (i, j) \\<in> set (arcs ?a2 ?a2 ?ys2) \\<or>\n   (j, i) \\<in> set (arcs ?a2 ?a2 ?ys2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?ys2 \\<noteq> []; length ?ys2 \\<le> length xs;\n   set ?ys2 \\<subseteq> set xs; ?a2 \\<le> n; len M' ?a2 ?a2 ?ys2 < \\<one>;\n   (i, j) \\<in> set (arcs ?a2 ?a2 ?ys2) \\<or>\n   (j, i) \\<in> set (arcs ?a2 ?a2 ?ys2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "fix a :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "fix ys :: \"nat list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "assume A: \"ys \\<noteq> []\" \"length ys \\<le> length xs\" \"set ys \\<subseteq> set xs\" \"a \\<le> n\""], ["proof (state)\nthis:\n  ys \\<noteq> []\n  length ys \\<le> length xs\n  set ys \\<subseteq> set xs\n  a \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "assume cycle: \"\\<not> len M' a a ys \\<ge> \\<one>\""], ["proof (state)\nthis:\n  \\<not> \\<one> \\<le> len M' a a ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "with A **[of a ys] less.prems"], ["proof (chain)\npicking this:\n  ys \\<noteq> []\n  length ys \\<le> length xs\n  set ys \\<subseteq> set xs\n  a \\<le> n\n  \\<lbrakk>(i, j) \\<notin> set (arcs a a ys);\n   (j, i) \\<notin> set (arcs a a ys); a \\<le> n; set ys \\<subseteq> {0..n};\n   \\<not> \\<one> \\<le> len M' a a ys\\<rbrakk>\n  \\<Longrightarrow> False\n  i \\<le> n\n  j \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\n  i \\<noteq> j\n  \\<not> \\<one> \\<le> len M' a a ys", "have \"(i, j) \\<in> set (arcs a a ys) \\<or> (j, i) \\<in> set (arcs a a ys)\""], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n  length ys \\<le> length xs\n  set ys \\<subseteq> set xs\n  a \\<le> n\n  \\<lbrakk>(i, j) \\<notin> set (arcs a a ys);\n   (j, i) \\<notin> set (arcs a a ys); a \\<le> n; set ys \\<subseteq> {0..n};\n   \\<not> \\<one> \\<le> len M' a a ys\\<rbrakk>\n  \\<Longrightarrow> False\n  i \\<le> n\n  j \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\n  i \\<noteq> j\n  \\<not> \\<one> \\<le> len M' a a ys\n\ngoal (1 subgoal):\n 1. (i, j) \\<in> set (arcs a a ys) \\<or> (j, i) \\<in> set (arcs a a ys)", "by auto"], ["proof (state)\nthis:\n  (i, j) \\<in> set (arcs a a ys) \\<or> (j, i) \\<in> set (arcs a a ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "with ***[OF A] cycle"], ["proof (chain)\npicking this:\n  \\<lbrakk>len M' a a ys < \\<one>;\n   (i, j) \\<in> set (arcs a a ys) \\<or>\n   (j, i) \\<in> set (arcs a a ys)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n  \\<not> \\<one> \\<le> len M' a a ys\n  (i, j) \\<in> set (arcs a a ys) \\<or> (j, i) \\<in> set (arcs a a ys)", "have ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>len M' a a ys < \\<one>;\n   (i, j) \\<in> set (arcs a a ys) \\<or>\n   (j, i) \\<in> set (arcs a a ys)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n  \\<not> \\<one> \\<le> len M' a a ys\n  (i, j) \\<in> set (arcs a a ys) \\<or> (j, i) \\<in> set (arcs a a ys)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ys2 \\<noteq> []; length ?ys2 \\<le> length xs;\n   set ?ys2 \\<subseteq> set xs; ?a2 \\<le> n;\n   \\<not> \\<one> \\<le> len M' ?a2 ?a2 ?ys2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "note neg_cycle_IH = this"], ["proof (state)\nthis:\n  \\<lbrakk>?ys2 \\<noteq> []; length ?ys2 \\<le> length xs;\n   set ?ys2 \\<subseteq> set xs; ?a2 \\<le> n;\n   \\<not> \\<one> \\<le> len M' ?a2 ?a2 ?ys2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "from cycle_free_diag[OF \\<open>cycle_free M n\\<close>]"], ["proof (chain)\npicking this:\n  ?i \\<le> n \\<Longrightarrow> \\<one> \\<le> M ?i ?i", "have \"\\<forall>i. i \\<le> n \\<longrightarrow> Le 0 \\<le> M i i\""], ["proof (prove)\nusing this:\n  ?i \\<le> n \\<Longrightarrow> \\<one> \\<le> M ?i ?i\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>n. Le (0::'a) \\<le> M i i", "unfolding neutral"], ["proof (prove)\nusing this:\n  ?i \\<le> n \\<Longrightarrow> Le (0::'a) \\<le> M ?i ?i\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>n. Le (0::'a) \\<le> M i i", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M i i\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "then"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M i i", "have M'_diag: \"\\<forall>i. i \\<le> n \\<longrightarrow> Le 0 \\<le> M' i i\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M i i\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>n. Le (0::'a) \\<le> M' i i", "unfolding M'_def"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M i i\n\ngoal (1 subgoal):\n 1. \\<forall>ia\\<le>n.\n       Le (0::'a)\n       \\<le> (if ia = i \\<and> ia = j then Le d\n              else if ia = j \\<and> ia = i then Le (- d) else M ia ia)", "using \\<open>i \\<noteq> j\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M i i\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<forall>ia\\<le>n.\n       Le (0::'a)\n       \\<le> (if ia = i \\<and> ia = j then Le d\n              else if ia = j \\<and> ia = i then Le (- d) else M ia ia)", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M' i i\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le d\n                        else if i' = j \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n};\n                    cycle_free M n; length xs = y;\n                    len M' i i (j # xs) < \\<one> \\<or>\n                    len M' j j (i # xs) < \\<one>;\n                    i \\<noteq> j\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  j \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le d\n            else if i' = j \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; j \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n        length xs = x;\n        len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>;\n        i \\<noteq> j\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            j \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' i i (j # xs) < \\<one> \\<or>\n                             len M' j j (i # xs) < \\<one>)", "from less(8)"], ["proof (chain)\npicking this:\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>", "show ?thesis"], ["proof (prove)\nusing this:\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "proof standard"], ["proof (state)\ngoal (2 subgoals):\n 1. len M' i i (j # xs) < \\<one> \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. len M' j j (i # xs) < \\<one> \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "assume cycle:\"len M' i i (j # xs) < \\<one>\""], ["proof (state)\nthis:\n  len M' i i (j # xs) < \\<one>\n\ngoal (2 subgoals):\n 1. len M' i i (j # xs) < \\<one> \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. len M' j j (i # xs) < \\<one> \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "proof (cases \"i \\<in> set xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. i \\<notin> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "case False"], ["proof (state)\nthis:\n  i \\<notin> set xs\n\ngoal (2 subgoals):\n 1. i \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. i \\<notin> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "then"], ["proof (chain)\npicking this:\n  i \\<notin> set xs", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<notin> set xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "proof (cases \"j \\<in> set xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<notin> set xs; j \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         j \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' i i (j # xs) < \\<one> \\<or>\n                          len M' j j (i # xs) < \\<one>)\n 2. \\<lbrakk>i \\<notin> set xs; j \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         j \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' i i (j # xs) < \\<one> \\<or>\n                          len M' j j (i # xs) < \\<one>)", "case False"], ["proof (state)\nthis:\n  j \\<notin> set xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<notin> set xs; j \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         j \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' i i (j # xs) < \\<one> \\<or>\n                          len M' j j (i # xs) < \\<one>)\n 2. \\<lbrakk>i \\<notin> set xs; j \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         j \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' i i (j # xs) < \\<one> \\<or>\n                          len M' j j (i # xs) < \\<one>)", "with \\<open>i \\<notin> set xs\\<close>"], ["proof (chain)\npicking this:\n  i \\<notin> set xs\n  j \\<notin> set xs", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<notin> set xs\n  j \\<notin> set xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "using less.prems(3,6)"], ["proof (prove)\nusing this:\n  i \\<notin> set xs\n  j \\<notin> set xs\n  set xs \\<subseteq> {0..n}\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> set xs; j \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         j \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' i i (j # xs) < \\<one> \\<or>\n                          len M' j j (i # xs) < \\<one>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> set xs; j \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         j \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' i i (j # xs) < \\<one> \\<or>\n                          len M' j j (i # xs) < \\<one>)", "case True"], ["proof (state)\nthis:\n  j \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> set xs; j \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         j \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' i i (j # xs) < \\<one> \\<or>\n                          len M' j j (i # xs) < \\<one>)", "then"], ["proof (chain)\npicking this:\n  j \\<in> set xs", "obtain ys zs where ys_zs: \"xs = ys @ j # zs\""], ["proof (prove)\nusing this:\n  j \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        xs = ys @ j # zs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list)"], ["proof (state)\nthis:\n  xs = ys @ j # zs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> set xs; j \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         j \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' i i (j # xs) < \\<one> \\<or>\n                          len M' j j (i # xs) < \\<one>)", "with len_decomp[of \"j # xs\" \"j # ys\" j zs M' i i]"], ["proof (chain)\npicking this:\n  j # xs = (j # ys) @ j # zs \\<Longrightarrow>\n  len M' i i (j # xs) = len M' i j (j # ys) + len M' j i zs\n  xs = ys @ j # zs", "have len: \"len M' i i (j # xs) = M' i j + len M' j j ys + len M' j i zs\""], ["proof (prove)\nusing this:\n  j # xs = (j # ys) @ j # zs \\<Longrightarrow>\n  len M' i i (j # xs) = len M' i j (j # ys) + len M' j i zs\n  xs = ys @ j # zs\n\ngoal (1 subgoal):\n 1. len M' i i (j # xs) = M' i j + len M' j j ys + len M' j i zs", "by auto"], ["proof (state)\nthis:\n  len M' i i (j # xs) = M' i j + len M' j j ys + len M' j i zs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> set xs; j \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         j \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' i i (j # xs) < \\<one> \\<or>\n                          len M' j j (i # xs) < \\<one>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "proof (cases \"len M' j j ys \\<ge> \\<one>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' j j ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' j j ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "case True"], ["proof (state)\nthis:\n  \\<one> \\<le> len M' j j ys\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' j j ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' j j ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "have \"len M' i i (j # zs) = M' i j + len M' j i zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len M' i i (j # zs) = M' i j + len M' j i zs", "by simp"], ["proof (state)\nthis:\n  len M' i i (j # zs) = M' i j + len M' j i zs\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' j j ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' j j ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "also"], ["proof (state)\nthis:\n  len M' i i (j # zs) = M' i j + len M' j i zs\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' j j ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' j j ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "from len True"], ["proof (chain)\npicking this:\n  len M' i i (j # xs) = M' i j + len M' j j ys + len M' j i zs\n  \\<one> \\<le> len M' j j ys", "have \"M' i j + len M' j i zs \\<le> len M' i i (j # xs)\""], ["proof (prove)\nusing this:\n  len M' i i (j # xs) = M' i j + len M' j j ys + len M' j i zs\n  \\<one> \\<le> len M' j j ys\n\ngoal (1 subgoal):\n 1. M' i j + len M' j i zs \\<le> len M' i i (j # xs)", "by (metis add_le_impl add_lt_neutral comm not_le)"], ["proof (state)\nthis:\n  M' i j + len M' j i zs \\<le> len M' i i (j # xs)\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' j j ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' j j ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "finally"], ["proof (chain)\npicking this:\n  len M' i i (j # zs) \\<le> len M' i i (j # xs)", "have cycle': \"len M' i i (j # zs) < \\<one>\""], ["proof (prove)\nusing this:\n  len M' i i (j # zs) \\<le> len M' i i (j # xs)\n\ngoal (1 subgoal):\n 1. len M' i i (j # zs) < \\<one>", "using cycle"], ["proof (prove)\nusing this:\n  len M' i i (j # zs) \\<le> len M' i i (j # xs)\n  len M' i i (j # xs) < \\<one>\n\ngoal (1 subgoal):\n 1. len M' i i (j # zs) < \\<one>", "by auto"], ["proof (state)\nthis:\n  len M' i i (j # zs) < \\<one>\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' j j ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' j j ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "from ys_zs less.prems(5)"], ["proof (chain)\npicking this:\n  xs = ys @ j # zs\n  length xs = x", "have \"x > length zs\""], ["proof (prove)\nusing this:\n  xs = ys @ j # zs\n  length xs = x\n\ngoal (1 subgoal):\n 1. length zs < x", "by auto"], ["proof (state)\nthis:\n  length zs < x\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' j j ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' j j ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "from cycle' less.prems ys_zs less.hyps(1)[OF this less.hyps(2) , of zs]"], ["proof (chain)\npicking this:\n  len M' i i (j # zs) < \\<one>\n  i \\<le> n\n  j \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\n  i \\<noteq> j\n  xs = ys @ j # zs\n  \\<lbrakk>i \\<le> n; j \\<le> n; set zs \\<subseteq> {0..n}; cycle_free M n;\n   length zs = length zs;\n   len M' i i (j # zs) < \\<one> \\<or> len M' j j (i # zs) < \\<one>;\n   i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)", "show ?thesis"], ["proof (prove)\nusing this:\n  len M' i i (j # zs) < \\<one>\n  i \\<le> n\n  j \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\n  i \\<noteq> j\n  xs = ys @ j # zs\n  \\<lbrakk>i \\<le> n; j \\<le> n; set zs \\<subseteq> {0..n}; cycle_free M n;\n   length zs = length zs;\n   len M' i i (j # zs) < \\<one> \\<or> len M' j j (i # zs) < \\<one>;\n   i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' j j ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' j j ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "case False"], ["proof (state)\nthis:\n  \\<not> \\<one> \\<le> len M' j j ys\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' j j ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "with M'_diag less.prems"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M' i i\n  i \\<le> n\n  j \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\n  i \\<noteq> j\n  \\<not> \\<one> \\<le> len M' j j ys", "have \"ys \\<noteq> []\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M' i i\n  i \\<le> n\n  j \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\n  i \\<noteq> j\n  \\<not> \\<one> \\<le> len M' j j ys\n\ngoal (1 subgoal):\n 1. ys \\<noteq> []", "by (auto simp: neutral)"], ["proof (state)\nthis:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' j j ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "from neg_cycle_IH[OF this] ys_zs False less.prems(1,2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ys \\<le> length xs; set ys \\<subseteq> set xs;\n   ?a2 \\<le> n; \\<not> \\<one> \\<le> len M' ?a2 ?a2 ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n  xs = ys @ j # zs\n  \\<not> \\<one> \\<le> len M' j j ys\n  i \\<le> n\n  j \\<le> n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ys \\<le> length xs; set ys \\<subseteq> set xs;\n   ?a2 \\<le> n; \\<not> \\<one> \\<le> len M' ?a2 ?a2 ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n  xs = ys @ j # zs\n  \\<not> \\<one> \\<le> len M' j j ys\n  i \\<le> n\n  j \\<le> n\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. i \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "case True"], ["proof (state)\nthis:\n  i \\<in> set xs\n\ngoal (1 subgoal):\n 1. i \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "then"], ["proof (chain)\npicking this:\n  i \\<in> set xs", "obtain ys zs where ys_zs: \"xs = ys @ i # zs\""], ["proof (prove)\nusing this:\n  i \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        xs = ys @ i # zs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list)"], ["proof (state)\nthis:\n  xs = ys @ i # zs\n\ngoal (1 subgoal):\n 1. i \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "with len_decomp[of \"j # xs\" \"j # ys\" i zs M' i i]"], ["proof (chain)\npicking this:\n  j # xs = (j # ys) @ i # zs \\<Longrightarrow>\n  len M' i i (j # xs) = len M' i i (j # ys) + len M' i i zs\n  xs = ys @ i # zs", "have len: \"len M' i i (j # xs) = M' i j + len M' j i ys + len M' i i zs\""], ["proof (prove)\nusing this:\n  j # xs = (j # ys) @ i # zs \\<Longrightarrow>\n  len M' i i (j # xs) = len M' i i (j # ys) + len M' i i zs\n  xs = ys @ i # zs\n\ngoal (1 subgoal):\n 1. len M' i i (j # xs) = M' i j + len M' j i ys + len M' i i zs", "by auto"], ["proof (state)\nthis:\n  len M' i i (j # xs) = M' i j + len M' j i ys + len M' i i zs\n\ngoal (1 subgoal):\n 1. i \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "proof (cases \"len M' i i zs \\<ge> \\<one>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "case True"], ["proof (state)\nthis:\n  \\<one> \\<le> len M' i i zs\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "have \"len M' i i (j # ys) = M' i j + len M' j i ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len M' i i (j # ys) = M' i j + len M' j i ys", "by simp"], ["proof (state)\nthis:\n  len M' i i (j # ys) = M' i j + len M' j i ys\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "also"], ["proof (state)\nthis:\n  len M' i i (j # ys) = M' i j + len M' j i ys\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "from len True"], ["proof (chain)\npicking this:\n  len M' i i (j # xs) = M' i j + len M' j i ys + len M' i i zs\n  \\<one> \\<le> len M' i i zs", "have \"M' i j + len M' j i ys \\<le> len M' i i (j # xs)\""], ["proof (prove)\nusing this:\n  len M' i i (j # xs) = M' i j + len M' j i ys + len M' i i zs\n  \\<one> \\<le> len M' i i zs\n\ngoal (1 subgoal):\n 1. M' i j + len M' j i ys \\<le> len M' i i (j # xs)", "by (metis add_lt_neutral comm not_le)"], ["proof (state)\nthis:\n  M' i j + len M' j i ys \\<le> len M' i i (j # xs)\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "finally"], ["proof (chain)\npicking this:\n  len M' i i (j # ys) \\<le> len M' i i (j # xs)", "have cycle': \"len M' i i (j # ys) < \\<one>\""], ["proof (prove)\nusing this:\n  len M' i i (j # ys) \\<le> len M' i i (j # xs)\n\ngoal (1 subgoal):\n 1. len M' i i (j # ys) < \\<one>", "using cycle"], ["proof (prove)\nusing this:\n  len M' i i (j # ys) \\<le> len M' i i (j # xs)\n  len M' i i (j # xs) < \\<one>\n\ngoal (1 subgoal):\n 1. len M' i i (j # ys) < \\<one>", "by auto"], ["proof (state)\nthis:\n  len M' i i (j # ys) < \\<one>\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "from ys_zs less.prems(5)"], ["proof (chain)\npicking this:\n  xs = ys @ i # zs\n  length xs = x", "have \"x > length ys\""], ["proof (prove)\nusing this:\n  xs = ys @ i # zs\n  length xs = x\n\ngoal (1 subgoal):\n 1. length ys < x", "by auto"], ["proof (state)\nthis:\n  length ys < x\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "from cycle' less.prems ys_zs less.hyps(1)[OF this less.hyps(2) , of ys]"], ["proof (chain)\npicking this:\n  len M' i i (j # ys) < \\<one>\n  i \\<le> n\n  j \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\n  i \\<noteq> j\n  xs = ys @ i # zs\n  \\<lbrakk>i \\<le> n; j \\<le> n; set ys \\<subseteq> {0..n}; cycle_free M n;\n   length ys = length ys;\n   len M' i i (j # ys) < \\<one> \\<or> len M' j j (i # ys) < \\<one>;\n   i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)", "show ?thesis"], ["proof (prove)\nusing this:\n  len M' i i (j # ys) < \\<one>\n  i \\<le> n\n  j \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\n  i \\<noteq> j\n  xs = ys @ i # zs\n  \\<lbrakk>i \\<le> n; j \\<le> n; set ys \\<subseteq> {0..n}; cycle_free M n;\n   length ys = length ys;\n   len M' i i (j # ys) < \\<one> \\<or> len M' j j (i # ys) < \\<one>;\n   i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "case False"], ["proof (state)\nthis:\n  \\<not> \\<one> \\<le> len M' i i zs\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "with less.prems(1,7) M'_diag"], ["proof (chain)\npicking this:\n  i \\<le> n\n  i \\<noteq> j\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M' i i\n  \\<not> \\<one> \\<le> len M' i i zs", "have \"zs \\<noteq> []\""], ["proof (prove)\nusing this:\n  i \\<le> n\n  i \\<noteq> j\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M' i i\n  \\<not> \\<one> \\<le> len M' i i zs\n\ngoal (1 subgoal):\n 1. zs \\<noteq> []", "by (auto simp: neutral)"], ["proof (state)\nthis:\n  zs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "from neg_cycle_IH[OF this] ys_zs False less.prems(1,2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>length zs \\<le> length xs; set zs \\<subseteq> set xs;\n   ?a2 \\<le> n; \\<not> \\<one> \\<le> len M' ?a2 ?a2 zs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n  xs = ys @ i # zs\n  \\<not> \\<one> \\<le> len M' i i zs\n  i \\<le> n\n  j \\<le> n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length zs \\<le> length xs; set zs \\<subseteq> set xs;\n   ?a2 \\<le> n; \\<not> \\<one> \\<le> len M' ?a2 ?a2 zs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n  xs = ys @ i # zs\n  \\<not> \\<one> \\<le> len M' i i zs\n  i \\<le> n\n  j \\<le> n\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. len M' j j (i # xs) < \\<one> \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. len M' j j (i # xs) < \\<one> \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "assume cycle:\"len M' j j (i # xs) < \\<one>\""], ["proof (state)\nthis:\n  len M' j j (i # xs) < \\<one>\n\ngoal (1 subgoal):\n 1. len M' j j (i # xs) < \\<one> \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "proof (cases \"j \\<in> set xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. j \\<notin> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "case False"], ["proof (state)\nthis:\n  j \\<notin> set xs\n\ngoal (2 subgoals):\n 1. j \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. j \\<notin> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "then"], ["proof (chain)\npicking this:\n  j \\<notin> set xs", "show ?thesis"], ["proof (prove)\nusing this:\n  j \\<notin> set xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "proof (cases \"i \\<in> set xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>j \\<notin> set xs; i \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         j \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' i i (j # xs) < \\<one> \\<or>\n                          len M' j j (i # xs) < \\<one>)\n 2. \\<lbrakk>j \\<notin> set xs; i \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         j \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' i i (j # xs) < \\<one> \\<or>\n                          len M' j j (i # xs) < \\<one>)", "case False"], ["proof (state)\nthis:\n  i \\<notin> set xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j \\<notin> set xs; i \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         j \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' i i (j # xs) < \\<one> \\<or>\n                          len M' j j (i # xs) < \\<one>)\n 2. \\<lbrakk>j \\<notin> set xs; i \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         j \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' i i (j # xs) < \\<one> \\<or>\n                          len M' j j (i # xs) < \\<one>)", "with \\<open>j \\<notin> set xs\\<close>"], ["proof (chain)\npicking this:\n  j \\<notin> set xs\n  i \\<notin> set xs", "show ?thesis"], ["proof (prove)\nusing this:\n  j \\<notin> set xs\n  i \\<notin> set xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "using less.prems(3,6)"], ["proof (prove)\nusing this:\n  j \\<notin> set xs\n  i \\<notin> set xs\n  set xs \\<subseteq> {0..n}\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<notin> set xs; i \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         j \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' i i (j # xs) < \\<one> \\<or>\n                          len M' j j (i # xs) < \\<one>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<notin> set xs; i \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         j \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' i i (j # xs) < \\<one> \\<or>\n                          len M' j j (i # xs) < \\<one>)", "case True"], ["proof (state)\nthis:\n  i \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<notin> set xs; i \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         j \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' i i (j # xs) < \\<one> \\<or>\n                          len M' j j (i # xs) < \\<one>)", "then"], ["proof (chain)\npicking this:\n  i \\<in> set xs", "obtain ys zs where ys_zs: \"xs = ys @ i # zs\""], ["proof (prove)\nusing this:\n  i \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        xs = ys @ i # zs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list)"], ["proof (state)\nthis:\n  xs = ys @ i # zs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<notin> set xs; i \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         j \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' i i (j # xs) < \\<one> \\<or>\n                          len M' j j (i # xs) < \\<one>)", "with len_decomp[of \"i # xs\" \"i # ys\" i zs M' j j]"], ["proof (chain)\npicking this:\n  i # xs = (i # ys) @ i # zs \\<Longrightarrow>\n  len M' j j (i # xs) = len M' j i (i # ys) + len M' i j zs\n  xs = ys @ i # zs", "have len: \"len M' j j (i # xs) = M' j i + len M' i i ys + len M' i j zs\""], ["proof (prove)\nusing this:\n  i # xs = (i # ys) @ i # zs \\<Longrightarrow>\n  len M' j j (i # xs) = len M' j i (i # ys) + len M' i j zs\n  xs = ys @ i # zs\n\ngoal (1 subgoal):\n 1. len M' j j (i # xs) = M' j i + len M' i i ys + len M' i j zs", "by auto"], ["proof (state)\nthis:\n  len M' j j (i # xs) = M' j i + len M' i i ys + len M' i j zs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j \\<notin> set xs; i \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         j \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' i i (j # xs) < \\<one> \\<or>\n                          len M' j j (i # xs) < \\<one>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "proof (cases \"len M' i i ys \\<ge> \\<one>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "case True"], ["proof (state)\nthis:\n  \\<one> \\<le> len M' i i ys\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "have \"len M' j j (i # zs) = M' j i + len M' i j zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len M' j j (i # zs) = M' j i + len M' i j zs", "by simp"], ["proof (state)\nthis:\n  len M' j j (i # zs) = M' j i + len M' i j zs\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "also"], ["proof (state)\nthis:\n  len M' j j (i # zs) = M' j i + len M' i j zs\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "from len True"], ["proof (chain)\npicking this:\n  len M' j j (i # xs) = M' j i + len M' i i ys + len M' i j zs\n  \\<one> \\<le> len M' i i ys", "have \"M' j i + len M' i j zs \\<le> len M' j j (i # xs)\""], ["proof (prove)\nusing this:\n  len M' j j (i # xs) = M' j i + len M' i i ys + len M' i j zs\n  \\<one> \\<le> len M' i i ys\n\ngoal (1 subgoal):\n 1. M' j i + len M' i j zs \\<le> len M' j j (i # xs)", "by (metis add_le_impl add_lt_neutral comm not_le)"], ["proof (state)\nthis:\n  M' j i + len M' i j zs \\<le> len M' j j (i # xs)\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "finally"], ["proof (chain)\npicking this:\n  len M' j j (i # zs) \\<le> len M' j j (i # xs)", "have cycle': \"len M' j j (i # zs) < \\<one>\""], ["proof (prove)\nusing this:\n  len M' j j (i # zs) \\<le> len M' j j (i # xs)\n\ngoal (1 subgoal):\n 1. len M' j j (i # zs) < \\<one>", "using cycle"], ["proof (prove)\nusing this:\n  len M' j j (i # zs) \\<le> len M' j j (i # xs)\n  len M' j j (i # xs) < \\<one>\n\ngoal (1 subgoal):\n 1. len M' j j (i # zs) < \\<one>", "by auto"], ["proof (state)\nthis:\n  len M' j j (i # zs) < \\<one>\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "from ys_zs less.prems(5)"], ["proof (chain)\npicking this:\n  xs = ys @ i # zs\n  length xs = x", "have \"x > length zs\""], ["proof (prove)\nusing this:\n  xs = ys @ i # zs\n  length xs = x\n\ngoal (1 subgoal):\n 1. length zs < x", "by auto"], ["proof (state)\nthis:\n  length zs < x\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "from cycle' less.prems ys_zs less.hyps(1)[OF this less.hyps(2) , of zs]"], ["proof (chain)\npicking this:\n  len M' j j (i # zs) < \\<one>\n  i \\<le> n\n  j \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\n  i \\<noteq> j\n  xs = ys @ i # zs\n  \\<lbrakk>i \\<le> n; j \\<le> n; set zs \\<subseteq> {0..n}; cycle_free M n;\n   length zs = length zs;\n   len M' i i (j # zs) < \\<one> \\<or> len M' j j (i # zs) < \\<one>;\n   i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)", "show ?thesis"], ["proof (prove)\nusing this:\n  len M' j j (i # zs) < \\<one>\n  i \\<le> n\n  j \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\n  i \\<noteq> j\n  xs = ys @ i # zs\n  \\<lbrakk>i \\<le> n; j \\<le> n; set zs \\<subseteq> {0..n}; cycle_free M n;\n   length zs = length zs;\n   len M' i i (j # zs) < \\<one> \\<or> len M' j j (i # zs) < \\<one>;\n   i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "case False"], ["proof (state)\nthis:\n  \\<not> \\<one> \\<le> len M' i i ys\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "with less.prems M'_diag"], ["proof (chain)\npicking this:\n  i \\<le> n\n  j \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\n  i \\<noteq> j\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M' i i\n  \\<not> \\<one> \\<le> len M' i i ys", "have \"ys \\<noteq> []\""], ["proof (prove)\nusing this:\n  i \\<le> n\n  j \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\n  i \\<noteq> j\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M' i i\n  \\<not> \\<one> \\<le> len M' i i ys\n\ngoal (1 subgoal):\n 1. ys \\<noteq> []", "by (auto simp: neutral)"], ["proof (state)\nthis:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "from neg_cycle_IH[OF this] ys_zs False less.prems(1,2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ys \\<le> length xs; set ys \\<subseteq> set xs;\n   ?a2 \\<le> n; \\<not> \\<one> \\<le> len M' ?a2 ?a2 ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n  xs = ys @ i # zs\n  \\<not> \\<one> \\<le> len M' i i ys\n  i \\<le> n\n  j \\<le> n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ys \\<le> length xs; set ys \\<subseteq> set xs;\n   ?a2 \\<le> n; \\<not> \\<one> \\<le> len M' ?a2 ?a2 ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n  xs = ys @ i # zs\n  \\<not> \\<one> \\<le> len M' i i ys\n  i \\<le> n\n  j \\<le> n\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. j \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "case True"], ["proof (state)\nthis:\n  j \\<in> set xs\n\ngoal (1 subgoal):\n 1. j \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "then"], ["proof (chain)\npicking this:\n  j \\<in> set xs", "obtain ys zs where ys_zs: \"xs = ys @ j # zs\""], ["proof (prove)\nusing this:\n  j \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        xs = ys @ j # zs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list)"], ["proof (state)\nthis:\n  xs = ys @ j # zs\n\ngoal (1 subgoal):\n 1. j \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "with len_decomp[of \"i # xs\" \"i # ys\" j zs M' j j]"], ["proof (chain)\npicking this:\n  i # xs = (i # ys) @ j # zs \\<Longrightarrow>\n  len M' j j (i # xs) = len M' j j (i # ys) + len M' j j zs\n  xs = ys @ j # zs", "have len: \"len M' j j (i # xs) = M' j i + len M' i j ys + len M' j j zs\""], ["proof (prove)\nusing this:\n  i # xs = (i # ys) @ j # zs \\<Longrightarrow>\n  len M' j j (i # xs) = len M' j j (i # ys) + len M' j j zs\n  xs = ys @ j # zs\n\ngoal (1 subgoal):\n 1. len M' j j (i # xs) = M' j i + len M' i j ys + len M' j j zs", "by auto"], ["proof (state)\nthis:\n  len M' j j (i # xs) = M' j i + len M' i j ys + len M' j j zs\n\ngoal (1 subgoal):\n 1. j \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "proof (cases \"len M' j j zs \\<ge> \\<one>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' j j zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' j j zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "case True"], ["proof (state)\nthis:\n  \\<one> \\<le> len M' j j zs\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' j j zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' j j zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "have \"len M' j j (i # ys) = M' j i + len M' i j ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len M' j j (i # ys) = M' j i + len M' i j ys", "by simp"], ["proof (state)\nthis:\n  len M' j j (i # ys) = M' j i + len M' i j ys\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' j j zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' j j zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "also"], ["proof (state)\nthis:\n  len M' j j (i # ys) = M' j i + len M' i j ys\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' j j zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' j j zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "from len True"], ["proof (chain)\npicking this:\n  len M' j j (i # xs) = M' j i + len M' i j ys + len M' j j zs\n  \\<one> \\<le> len M' j j zs", "have \"M' j i + len M' i j ys \\<le> len M' j j (i # xs)\""], ["proof (prove)\nusing this:\n  len M' j j (i # xs) = M' j i + len M' i j ys + len M' j j zs\n  \\<one> \\<le> len M' j j zs\n\ngoal (1 subgoal):\n 1. M' j i + len M' i j ys \\<le> len M' j j (i # xs)", "by (metis add_lt_neutral comm not_le)"], ["proof (state)\nthis:\n  M' j i + len M' i j ys \\<le> len M' j j (i # xs)\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' j j zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' j j zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "finally"], ["proof (chain)\npicking this:\n  len M' j j (i # ys) \\<le> len M' j j (i # xs)", "have cycle': \"len M' j j (i # ys) < \\<one>\""], ["proof (prove)\nusing this:\n  len M' j j (i # ys) \\<le> len M' j j (i # xs)\n\ngoal (1 subgoal):\n 1. len M' j j (i # ys) < \\<one>", "using cycle"], ["proof (prove)\nusing this:\n  len M' j j (i # ys) \\<le> len M' j j (i # xs)\n  len M' j j (i # xs) < \\<one>\n\ngoal (1 subgoal):\n 1. len M' j j (i # ys) < \\<one>", "by auto"], ["proof (state)\nthis:\n  len M' j j (i # ys) < \\<one>\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' j j zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' j j zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "from ys_zs less.prems(5)"], ["proof (chain)\npicking this:\n  xs = ys @ j # zs\n  length xs = x", "have \"x > length ys\""], ["proof (prove)\nusing this:\n  xs = ys @ j # zs\n  length xs = x\n\ngoal (1 subgoal):\n 1. length ys < x", "by auto"], ["proof (state)\nthis:\n  length ys < x\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' j j zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' j j zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "from cycle' less.prems ys_zs less.hyps(1)[OF this less.hyps(2) , of ys]"], ["proof (chain)\npicking this:\n  len M' j j (i # ys) < \\<one>\n  i \\<le> n\n  j \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\n  i \\<noteq> j\n  xs = ys @ j # zs\n  \\<lbrakk>i \\<le> n; j \\<le> n; set ys \\<subseteq> {0..n}; cycle_free M n;\n   length ys = length ys;\n   len M' i i (j # ys) < \\<one> \\<or> len M' j j (i # ys) < \\<one>;\n   i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)", "show ?thesis"], ["proof (prove)\nusing this:\n  len M' j j (i # ys) < \\<one>\n  i \\<le> n\n  j \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>\n  i \\<noteq> j\n  xs = ys @ j # zs\n  \\<lbrakk>i \\<le> n; j \\<le> n; set ys \\<subseteq> {0..n}; cycle_free M n;\n   length ys = length ys;\n   len M' i i (j # ys) < \\<one> \\<or> len M' j j (i # ys) < \\<one>;\n   i \\<noteq> j\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' j j zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' j j zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "case False"], ["proof (state)\nthis:\n  \\<not> \\<one> \\<le> len M' j j zs\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' j j zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "with less.prems(2,7) M'_diag"], ["proof (chain)\npicking this:\n  j \\<le> n\n  i \\<noteq> j\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M' i i\n  \\<not> \\<one> \\<le> len M' j j zs", "have \"zs \\<noteq> []\""], ["proof (prove)\nusing this:\n  j \\<le> n\n  i \\<noteq> j\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M' i i\n  \\<not> \\<one> \\<le> len M' j j zs\n\ngoal (1 subgoal):\n 1. zs \\<noteq> []", "by (auto simp: neutral)"], ["proof (state)\nthis:\n  zs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' j j zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "from neg_cycle_IH[OF this] ys_zs False less.prems(1,2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>length zs \\<le> length xs; set zs \\<subseteq> set xs;\n   ?a2 \\<le> n; \\<not> \\<one> \\<le> len M' ?a2 ?a2 zs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n  xs = ys @ j # zs\n  \\<not> \\<one> \\<le> len M' j j zs\n  i \\<le> n\n  j \\<le> n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length zs \\<le> length xs; set zs \\<subseteq> set xs;\n   ?a2 \\<le> n; \\<not> \\<one> \\<le> len M' ?a2 ?a2 zs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       j \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' i i (j # xs) < \\<one> \\<or>\n                        len M' j j (i # xs) < \\<one>)\n  xs = ys @ j # zs\n  \\<not> \\<one> \\<le> len M' j j zs\n  i \\<le> n\n  j \\<le> n\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       j \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' i i (j # xs) < \\<one> \\<or> len M' j j (i # xs) < \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma new_negative_cycle_aux:\n  fixes M :: \"('a :: time) DBM\"\n  fixes i d\n  defines \"M' \\<equiv> \\<lambda> i' j'. if (i' = i \\<and> j' = 0) then Le d\n                       else if (i' = 0 \\<and> j' = i) then Le (-d)\n                       else M i' j'\"\n  assumes \"i \\<le> n\" \"set xs \\<subseteq> {0..n}\" \"cycle_free M n\" \"length xs = m\"\n  assumes \"len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>\"\n  assumes \"i \\<noteq> 0\"\n  shows \"\\<exists>xs. set xs \\<subseteq> {0..n} \\<and> 0 \\<notin> set xs \\<and> i \\<notin> set xs\n              \\<and> (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "using assms"], ["proof (prove)\nusing this:\n  M' \\<equiv>\n  \\<lambda>i' j'.\n     if i' = i \\<and> j' = 0 then Le d\n     else if i' = 0 \\<and> j' = i then Le (- d) else M i' j'\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = m\n  len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "proof (induction _ m arbitrary: xs rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "case (less x)"], ["proof (state)\nthis:\n  \\<lbrakk>?y < x;\n   M' =\n   (\\<lambda>i' j'.\n       if i' = i \\<and> j' = 0 then Le d\n       else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n   i \\<le> n; set ?xs \\<subseteq> {0..n}; cycle_free M n; length ?xs = ?y;\n   len M' 0 0 (i # ?xs) < \\<one> \\<or> len M' i i (0 # ?xs) < \\<one>;\n   i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n  M' =\n  (\\<lambda>i' j'.\n      if i' = i \\<and> j' = 0 then Le d\n      else if i' = 0 \\<and> j' = i then Le (- d) else M i' j')\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?y < x;\n   M' =\n   (\\<lambda>i' j'.\n       if i' = i \\<and> j' = 0 then Le d\n       else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n   i \\<le> n; set ?xs \\<subseteq> {0..n}; cycle_free M n; length ?xs = ?y;\n   len M' 0 0 (i # ?xs) < \\<one> \\<or> len M' i i (0 # ?xs) < \\<one>;\n   i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n  M' =\n  (\\<lambda>i' j'.\n      if i' = i \\<and> j' = 0 then Le d\n      else if i' = 0 \\<and> j' = i then Le (- d) else M i' j')\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "fix b a xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "assume A: \"(0, i) \\<notin> set (arcs b a xs)\" \"(i, 0) \\<notin> set (arcs b a xs)\""], ["proof (state)\nthis:\n  (0, i) \\<notin> set (arcs b a xs)\n  (i, 0) \\<notin> set (arcs b a xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "then"], ["proof (chain)\npicking this:\n  (0, i) \\<notin> set (arcs b a xs)\n  (i, 0) \\<notin> set (arcs b a xs)", "have \"len M' b a xs = len M b a xs\""], ["proof (prove)\nusing this:\n  (0, i) \\<notin> set (arcs b a xs)\n  (i, 0) \\<notin> set (arcs b a xs)\n\ngoal (1 subgoal):\n 1. len M' b a xs = len M b a xs", "unfolding M'_def"], ["proof (prove)\nusing this:\n  (0, i) \\<notin> set (arcs b a xs)\n  (i, 0) \\<notin> set (arcs b a xs)\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j')\n     b a xs =\n    len M b a xs", "by (induction xs arbitrary: b) auto"], ["proof (state)\nthis:\n  len M' b a xs = len M b a xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(0, i) \\<notin> set (arcs ?b2 ?a2 ?xsb2);\n   (i, 0) \\<notin> set (arcs ?b2 ?a2 ?xsb2)\\<rbrakk>\n  \\<Longrightarrow> len M' ?b2 ?a2 ?xsb2 = len M ?b2 ?a2 ?xsb2\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "note * = this"], ["proof (state)\nthis:\n  \\<lbrakk>(0, i) \\<notin> set (arcs ?b2 ?a2 ?xsb2);\n   (i, 0) \\<notin> set (arcs ?b2 ?a2 ?xsb2)\\<rbrakk>\n  \\<Longrightarrow> len M' ?b2 ?a2 ?xsb2 = len M ?b2 ?a2 ?xsb2\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(0, i) \\<notin> set (arcs ?b2 ?a2 ?xsb2);\n   (i, 0) \\<notin> set (arcs ?b2 ?a2 ?xsb2)\\<rbrakk>\n  \\<Longrightarrow> len M' ?b2 ?a2 ?xsb2 = len M ?b2 ?a2 ?xsb2\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "fix a xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "assume A:\"(0, i) \\<notin> set (arcs a a xs)\" \"(i, 0) \\<notin> set (arcs a a xs)\""], ["proof (state)\nthis:\n  (0, i) \\<notin> set (arcs a a xs)\n  (i, 0) \\<notin> set (arcs a a xs)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "assume a: \"a \\<le> n\" and xs: \"set xs \\<subseteq> {0..n}\" and cycle: \"\\<not> len M' a a xs \\<ge> \\<one>\""], ["proof (state)\nthis:\n  a \\<le> n\n  set xs \\<subseteq> {0..n}\n  \\<not> \\<one> \\<le> len M' a a xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "from *[OF A]"], ["proof (chain)\npicking this:\n  len M' a a xs = len M a a xs", "have \"len M' a a xs = len M a a xs\""], ["proof (prove)\nusing this:\n  len M' a a xs = len M a a xs\n\ngoal (1 subgoal):\n 1. len M' a a xs = len M a a xs", "."], ["proof (state)\nthis:\n  len M' a a xs = len M a a xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "with \\<open>cycle_free M n\\<close> \\<open>i \\<le> n\\<close> cycle xs a"], ["proof (chain)\npicking this:\n  cycle_free M n\n  i \\<le> n\n  \\<not> \\<one> \\<le> len M' a a xs\n  set xs \\<subseteq> {0..n}\n  a \\<le> n\n  len M' a a xs = len M a a xs", "have False"], ["proof (prove)\nusing this:\n  cycle_free M n\n  i \\<le> n\n  \\<not> \\<one> \\<le> len M' a a xs\n  set xs \\<subseteq> {0..n}\n  a \\<le> n\n  len M' a a xs = len M a a xs\n\ngoal (1 subgoal):\n 1. False", "unfolding cycle_free_def"], ["proof (prove)\nusing this:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     (\\<forall>j\\<le>n.\n         len M i j (rem_cycles i j xs) \\<le> len M i j xs) \\<and>\n     \\<one> \\<le> len M i i xs\n  i \\<le> n\n  \\<not> \\<one> \\<le> len M' a a xs\n  set xs \\<subseteq> {0..n}\n  a \\<le> n\n  len M' a a xs = len M a a xs\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(0, i) \\<notin> set (arcs ?a2 ?a2 ?xsb2);\n   (i, 0) \\<notin> set (arcs ?a2 ?a2 ?xsb2); ?a2 \\<le> n;\n   set ?xsb2 \\<subseteq> {0..n};\n   \\<not> \\<one> \\<le> len M' ?a2 ?a2 ?xsb2\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "note ** = this"], ["proof (state)\nthis:\n  \\<lbrakk>(0, i) \\<notin> set (arcs ?a2 ?a2 ?xsb2);\n   (i, 0) \\<notin> set (arcs ?a2 ?a2 ?xsb2); ?a2 \\<le> n;\n   set ?xsb2 \\<subseteq> {0..n};\n   \\<not> \\<one> \\<le> len M' ?a2 ?a2 ?xsb2\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(0, i) \\<notin> set (arcs ?a2 ?a2 ?xsb2);\n   (i, 0) \\<notin> set (arcs ?a2 ?a2 ?xsb2); ?a2 \\<le> n;\n   set ?xsb2 \\<subseteq> {0..n};\n   \\<not> \\<one> \\<le> len M' ?a2 ?a2 ?xsb2\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "fix a :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "fix ys :: \"nat list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "assume A: \"ys \\<noteq> []\" \"length ys \\<le> length xs\" \"set ys \\<subseteq> set xs\" \"a \\<le> n\""], ["proof (state)\nthis:\n  ys \\<noteq> []\n  length ys \\<le> length xs\n  set ys \\<subseteq> set xs\n  a \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "assume cycle: \"len M' a a ys < \\<one>\""], ["proof (state)\nthis:\n  len M' a a ys < \\<one>\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "assume arcs: \"(0, i) \\<in> set (arcs a a ys) \\<or> (i, 0) \\<in> set (arcs a a ys)\""], ["proof (state)\nthis:\n  (0, i) \\<in> set (arcs a a ys) \\<or> (i, 0) \\<in> set (arcs a a ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "from arcs"], ["proof (chain)\npicking this:\n  (0, i) \\<in> set (arcs a a ys) \\<or> (i, 0) \\<in> set (arcs a a ys)", "have ?thesis"], ["proof (prove)\nusing this:\n  (0, i) \\<in> set (arcs a a ys) \\<or> (i, 0) \\<in> set (arcs a a ys)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (0, i) \\<in> set (arcs a a ys) \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. (i, 0) \\<in> set (arcs a a ys) \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "assume \"(0, i) \\<in> set (arcs a a ys)\""], ["proof (state)\nthis:\n  (0, i) \\<in> set (arcs a a ys)\n\ngoal (2 subgoals):\n 1. (0, i) \\<in> set (arcs a a ys) \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. (i, 0) \\<in> set (arcs a a ys) \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "from cycle_rotate_2[OF \\<open>ys \\<noteq> []\\<close> this, of M']"], ["proof (chain)\npicking this:\n  \\<exists>ysa.\n     len M' a a ys = len M' 0 0 (i # ysa) \\<and>\n     set ysa \\<subseteq> set (a # ys) \\<and> length ysa < length ys", "obtain ws where ws: \"len M' a a ys = len M' 0 0 (i # ws)\" \"set ws \\<subseteq> set (a # ys)\"\n        \"length ws < length ys\""], ["proof (prove)\nusing this:\n  \\<exists>ysa.\n     len M' a a ys = len M' 0 0 (i # ysa) \\<and>\n     set ysa \\<subseteq> set (a # ys) \\<and> length ysa < length ys\n\ngoal (1 subgoal):\n 1. (\\<And>ws.\n        \\<lbrakk>len M' a a ys = len M' 0 0 (i # ws);\n         set ws \\<subseteq> set (a # ys); length ws < length ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  len M' a a ys = len M' 0 0 (i # ws)\n  set ws \\<subseteq> set (a # ys)\n  length ws < length ys\n\ngoal (2 subgoals):\n 1. (0, i) \\<in> set (arcs a a ys) \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. (i, 0) \\<in> set (arcs a a ys) \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "with cycle less.hyps(1)[OF _ less.hyps(2) , of \"length ws\" ws] less.prems A"], ["proof (chain)\npicking this:\n  len M' a a ys < \\<one>\n  \\<lbrakk>length ws < x; i \\<le> n; set ws \\<subseteq> {0..n};\n   cycle_free M n; length ws = length ws;\n   len M' 0 0 (i # ws) < \\<one> \\<or> len M' i i (0 # ws) < \\<one>;\n   i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>\n  i \\<noteq> 0\n  ys \\<noteq> []\n  length ys \\<le> length xs\n  set ys \\<subseteq> set xs\n  a \\<le> n\n  len M' a a ys = len M' 0 0 (i # ws)\n  set ws \\<subseteq> set (a # ys)\n  length ws < length ys", "show ?thesis"], ["proof (prove)\nusing this:\n  len M' a a ys < \\<one>\n  \\<lbrakk>length ws < x; i \\<le> n; set ws \\<subseteq> {0..n};\n   cycle_free M n; length ws = length ws;\n   len M' 0 0 (i # ws) < \\<one> \\<or> len M' i i (0 # ws) < \\<one>;\n   i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>\n  i \\<noteq> 0\n  ys \\<noteq> []\n  length ys \\<le> length xs\n  set ys \\<subseteq> set xs\n  a \\<le> n\n  len M' a a ys = len M' 0 0 (i # ws)\n  set ws \\<subseteq> set (a # ys)\n  length ws < length ys\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     0 \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. (i, 0) \\<in> set (arcs a a ys) \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (i, 0) \\<in> set (arcs a a ys) \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "assume \"(i, 0) \\<in> set (arcs a a ys)\""], ["proof (state)\nthis:\n  (i, 0) \\<in> set (arcs a a ys)\n\ngoal (1 subgoal):\n 1. (i, 0) \\<in> set (arcs a a ys) \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "from cycle_rotate_2[OF \\<open>ys \\<noteq> []\\<close> this, of M']"], ["proof (chain)\npicking this:\n  \\<exists>ysa.\n     len M' a a ys = len M' i i (0 # ysa) \\<and>\n     set ysa \\<subseteq> set (a # ys) \\<and> length ysa < length ys", "obtain ws where ws: \"len M' a a ys = len M' i i (0 # ws)\" \"set ws \\<subseteq> set (a # ys)\"\n        \"length ws < length ys\""], ["proof (prove)\nusing this:\n  \\<exists>ysa.\n     len M' a a ys = len M' i i (0 # ysa) \\<and>\n     set ysa \\<subseteq> set (a # ys) \\<and> length ysa < length ys\n\ngoal (1 subgoal):\n 1. (\\<And>ws.\n        \\<lbrakk>len M' a a ys = len M' i i (0 # ws);\n         set ws \\<subseteq> set (a # ys); length ws < length ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  len M' a a ys = len M' i i (0 # ws)\n  set ws \\<subseteq> set (a # ys)\n  length ws < length ys\n\ngoal (1 subgoal):\n 1. (i, 0) \\<in> set (arcs a a ys) \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "with cycle less.hyps(1)[OF _ less.hyps(2) , of \"length ws\" ws] less.prems A"], ["proof (chain)\npicking this:\n  len M' a a ys < \\<one>\n  \\<lbrakk>length ws < x; i \\<le> n; set ws \\<subseteq> {0..n};\n   cycle_free M n; length ws = length ws;\n   len M' 0 0 (i # ws) < \\<one> \\<or> len M' i i (0 # ws) < \\<one>;\n   i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>\n  i \\<noteq> 0\n  ys \\<noteq> []\n  length ys \\<le> length xs\n  set ys \\<subseteq> set xs\n  a \\<le> n\n  len M' a a ys = len M' i i (0 # ws)\n  set ws \\<subseteq> set (a # ys)\n  length ws < length ys", "show ?thesis"], ["proof (prove)\nusing this:\n  len M' a a ys < \\<one>\n  \\<lbrakk>length ws < x; i \\<le> n; set ws \\<subseteq> {0..n};\n   cycle_free M n; length ws = length ws;\n   len M' 0 0 (i # ws) < \\<one> \\<or> len M' i i (0 # ws) < \\<one>;\n   i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>\n  i \\<noteq> 0\n  ys \\<noteq> []\n  length ys \\<le> length xs\n  set ys \\<subseteq> set xs\n  a \\<le> n\n  len M' a a ys = len M' i i (0 # ws)\n  set ws \\<subseteq> set (a # ys)\n  length ws < length ys\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     0 \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     0 \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ys2 \\<noteq> []; length ?ys2 \\<le> length xs;\n   set ?ys2 \\<subseteq> set xs; ?a2 \\<le> n; len M' ?a2 ?a2 ?ys2 < \\<one>;\n   (0, i) \\<in> set (arcs ?a2 ?a2 ?ys2) \\<or>\n   (i, 0) \\<in> set (arcs ?a2 ?a2 ?ys2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "note *** = this"], ["proof (state)\nthis:\n  \\<lbrakk>?ys2 \\<noteq> []; length ?ys2 \\<le> length xs;\n   set ?ys2 \\<subseteq> set xs; ?a2 \\<le> n; len M' ?a2 ?a2 ?ys2 < \\<one>;\n   (0, i) \\<in> set (arcs ?a2 ?a2 ?ys2) \\<or>\n   (i, 0) \\<in> set (arcs ?a2 ?a2 ?ys2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>?ys2 \\<noteq> []; length ?ys2 \\<le> length xs;\n   set ?ys2 \\<subseteq> set xs; ?a2 \\<le> n; len M' ?a2 ?a2 ?ys2 < \\<one>;\n   (0, i) \\<in> set (arcs ?a2 ?a2 ?ys2) \\<or>\n   (i, 0) \\<in> set (arcs ?a2 ?a2 ?ys2)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "fix a :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "fix ys :: \"nat list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "assume A: \"ys \\<noteq> []\" \"length ys \\<le> length xs\" \"set ys \\<subseteq> set xs\" \"a \\<le> n\""], ["proof (state)\nthis:\n  ys \\<noteq> []\n  length ys \\<le> length xs\n  set ys \\<subseteq> set xs\n  a \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "assume cycle: \"\\<not> len M' a a ys \\<ge> \\<one>\""], ["proof (state)\nthis:\n  \\<not> \\<one> \\<le> len M' a a ys\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "with A **[of a ys]  less.prems(2)"], ["proof (chain)\npicking this:\n  ys \\<noteq> []\n  length ys \\<le> length xs\n  set ys \\<subseteq> set xs\n  a \\<le> n\n  \\<lbrakk>(0, i) \\<notin> set (arcs a a ys);\n   (i, 0) \\<notin> set (arcs a a ys); a \\<le> n; set ys \\<subseteq> {0..n};\n   \\<not> \\<one> \\<le> len M' a a ys\\<rbrakk>\n  \\<Longrightarrow> False\n  set xs \\<subseteq> {0..n}\n  \\<not> \\<one> \\<le> len M' a a ys", "have \"(0, i) \\<in> set (arcs a a ys) \\<or> (i, 0) \\<in> set (arcs a a ys)\""], ["proof (prove)\nusing this:\n  ys \\<noteq> []\n  length ys \\<le> length xs\n  set ys \\<subseteq> set xs\n  a \\<le> n\n  \\<lbrakk>(0, i) \\<notin> set (arcs a a ys);\n   (i, 0) \\<notin> set (arcs a a ys); a \\<le> n; set ys \\<subseteq> {0..n};\n   \\<not> \\<one> \\<le> len M' a a ys\\<rbrakk>\n  \\<Longrightarrow> False\n  set xs \\<subseteq> {0..n}\n  \\<not> \\<one> \\<le> len M' a a ys\n\ngoal (1 subgoal):\n 1. (0, i) \\<in> set (arcs a a ys) \\<or> (i, 0) \\<in> set (arcs a a ys)", "by auto"], ["proof (state)\nthis:\n  (0, i) \\<in> set (arcs a a ys) \\<or> (i, 0) \\<in> set (arcs a a ys)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "with ***[OF A] cycle"], ["proof (chain)\npicking this:\n  \\<lbrakk>len M' a a ys < \\<one>;\n   (0, i) \\<in> set (arcs a a ys) \\<or>\n   (i, 0) \\<in> set (arcs a a ys)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n  \\<not> \\<one> \\<le> len M' a a ys\n  (0, i) \\<in> set (arcs a a ys) \\<or> (i, 0) \\<in> set (arcs a a ys)", "have ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>len M' a a ys < \\<one>;\n   (0, i) \\<in> set (arcs a a ys) \\<or>\n   (i, 0) \\<in> set (arcs a a ys)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n  \\<not> \\<one> \\<le> len M' a a ys\n  (0, i) \\<in> set (arcs a a ys) \\<or> (i, 0) \\<in> set (arcs a a ys)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     0 \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?ys2 \\<noteq> []; length ?ys2 \\<le> length xs;\n   set ?ys2 \\<subseteq> set xs; ?a2 \\<le> n;\n   \\<not> \\<one> \\<le> len M' ?a2 ?a2 ?ys2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "note neg_cycle_IH = this"], ["proof (state)\nthis:\n  \\<lbrakk>?ys2 \\<noteq> []; length ?ys2 \\<le> length xs;\n   set ?ys2 \\<subseteq> set xs; ?a2 \\<le> n;\n   \\<not> \\<one> \\<le> len M' ?a2 ?a2 ?ys2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "from cycle_free_diag[OF \\<open>cycle_free M n\\<close>]"], ["proof (chain)\npicking this:\n  ?i \\<le> n \\<Longrightarrow> \\<one> \\<le> M ?i ?i", "have \"\\<forall>i. i \\<le> n \\<longrightarrow> Le 0 \\<le> M i i\""], ["proof (prove)\nusing this:\n  ?i \\<le> n \\<Longrightarrow> \\<one> \\<le> M ?i ?i\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>n. Le (0::'a) \\<le> M i i", "unfolding neutral"], ["proof (prove)\nusing this:\n  ?i \\<le> n \\<Longrightarrow> Le (0::'a) \\<le> M ?i ?i\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>n. Le (0::'a) \\<le> M i i", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M i i\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "then"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M i i", "have M'_diag: \"\\<forall>i. i \\<le> n \\<longrightarrow> Le 0 \\<le> M' i i\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M i i\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>n. Le (0::'a) \\<le> M' i i", "unfolding M'_def"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M i i\n\ngoal (1 subgoal):\n 1. \\<forall>ia\\<le>n.\n       Le (0::'a)\n       \\<le> (if ia = i \\<and> ia = 0 then Le d\n              else if ia = 0 \\<and> ia = i then Le (- d) else M ia ia)", "using \\<open>i \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M i i\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>ia\\<le>n.\n       Le (0::'a)\n       \\<le> (if ia = i \\<and> ia = 0 then Le d\n              else if ia = 0 \\<and> ia = i then Le (- d) else M ia ia)", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M' i i\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>y xs.\n                   \\<lbrakk>y < x;\n                    M' =\n                    (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = 0 then Le d\n                        else if i' = 0 \\<and> j' = i then Le (- d)\n                             else M i' j');\n                    i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n;\n                    length xs = y;\n                    len M' 0 0 (i # xs) < \\<one> \\<or>\n                    len M' i i (0 # xs) < \\<one>;\n                    i \\<noteq> 0\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>xs.\n  set xs \\<subseteq> {0..n} \\<and>\n  0 \\<notin> set xs \\<and>\n  i \\<notin> set xs \\<and>\n  (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>);\n        M' =\n        (\\<lambda>i' j'.\n            if i' = i \\<and> j' = 0 then Le d\n            else if i' = 0 \\<and> j' = i then Le (- d) else M i' j');\n        i \\<le> n; set xs \\<subseteq> {0..n}; cycle_free M n; length xs = x;\n        len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>;\n        i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> {0..n} \\<and>\n                            0 \\<notin> set xs \\<and>\n                            i \\<notin> set xs \\<and>\n                            (len M' 0 0 (i # xs) < \\<one> \\<or>\n                             len M' i i (0 # xs) < \\<one>)", "from less(7)"], ["proof (chain)\npicking this:\n  len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>", "show ?thesis"], ["proof (prove)\nusing this:\n  len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "proof standard"], ["proof (state)\ngoal (2 subgoals):\n 1. len M' 0 0 (i # xs) < \\<one> \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. len M' i i (0 # xs) < \\<one> \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "assume cycle:\"len M' 0 0 (i # xs) < \\<one>\""], ["proof (state)\nthis:\n  len M' 0 0 (i # xs) < \\<one>\n\ngoal (2 subgoals):\n 1. len M' 0 0 (i # xs) < \\<one> \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. len M' i i (0 # xs) < \\<one> \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "proof (cases \"0 \\<in> set xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. 0 \\<notin> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "case False"], ["proof (state)\nthis:\n  0 \\<notin> set xs\n\ngoal (2 subgoals):\n 1. 0 \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. 0 \\<notin> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 \\<notin> set xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "proof (cases \"i \\<in> set xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<notin> set xs; i \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         0 \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' 0 0 (i # xs) < \\<one> \\<or>\n                          len M' i i (0 # xs) < \\<one>)\n 2. \\<lbrakk>0 \\<notin> set xs; i \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         0 \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' 0 0 (i # xs) < \\<one> \\<or>\n                          len M' i i (0 # xs) < \\<one>)", "case False"], ["proof (state)\nthis:\n  i \\<notin> set xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<notin> set xs; i \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         0 \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' 0 0 (i # xs) < \\<one> \\<or>\n                          len M' i i (0 # xs) < \\<one>)\n 2. \\<lbrakk>0 \\<notin> set xs; i \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         0 \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' 0 0 (i # xs) < \\<one> \\<or>\n                          len M' i i (0 # xs) < \\<one>)", "with \\<open>0 \\<notin> set xs\\<close>"], ["proof (chain)\npicking this:\n  0 \\<notin> set xs\n  i \\<notin> set xs", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<notin> set xs\n  i \\<notin> set xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "using less.prems"], ["proof (prove)\nusing this:\n  0 \\<notin> set xs\n  i \\<notin> set xs\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     0 \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<notin> set xs; i \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         0 \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' 0 0 (i # xs) < \\<one> \\<or>\n                          len M' i i (0 # xs) < \\<one>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<notin> set xs; i \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         0 \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' 0 0 (i # xs) < \\<one> \\<or>\n                          len M' i i (0 # xs) < \\<one>)", "case True"], ["proof (state)\nthis:\n  i \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<notin> set xs; i \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         0 \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' 0 0 (i # xs) < \\<one> \\<or>\n                          len M' i i (0 # xs) < \\<one>)", "then"], ["proof (chain)\npicking this:\n  i \\<in> set xs", "obtain ys zs where ys_zs: \"xs = ys @ i # zs\""], ["proof (prove)\nusing this:\n  i \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        xs = ys @ i # zs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list)"], ["proof (state)\nthis:\n  xs = ys @ i # zs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<notin> set xs; i \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         0 \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' 0 0 (i # xs) < \\<one> \\<or>\n                          len M' i i (0 # xs) < \\<one>)", "with len_decomp[of \"i # xs\" \"i # ys\" i zs M' 0 0]"], ["proof (chain)\npicking this:\n  i # xs = (i # ys) @ i # zs \\<Longrightarrow>\n  len M' 0 0 (i # xs) = len M' 0 i (i # ys) + len M' i 0 zs\n  xs = ys @ i # zs", "have len: \"len M' 0 0 (i # xs) = M' 0 i + len M' i i ys + len M' i 0 zs\""], ["proof (prove)\nusing this:\n  i # xs = (i # ys) @ i # zs \\<Longrightarrow>\n  len M' 0 0 (i # xs) = len M' 0 i (i # ys) + len M' i 0 zs\n  xs = ys @ i # zs\n\ngoal (1 subgoal):\n 1. len M' 0 0 (i # xs) = M' 0 i + len M' i i ys + len M' i 0 zs", "by auto"], ["proof (state)\nthis:\n  len M' 0 0 (i # xs) = M' 0 i + len M' i i ys + len M' i 0 zs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<notin> set xs; i \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         0 \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' 0 0 (i # xs) < \\<one> \\<or>\n                          len M' i i (0 # xs) < \\<one>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "proof (cases \"len M' i i ys \\<ge> \\<one>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "case True"], ["proof (state)\nthis:\n  \\<one> \\<le> len M' i i ys\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "have \"len M' 0 0 (i # zs) = M' 0 i + len M' i 0 zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len M' 0 0 (i # zs) = M' 0 i + len M' i 0 zs", "by simp"], ["proof (state)\nthis:\n  len M' 0 0 (i # zs) = M' 0 i + len M' i 0 zs\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "also"], ["proof (state)\nthis:\n  len M' 0 0 (i # zs) = M' 0 i + len M' i 0 zs\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "from len True"], ["proof (chain)\npicking this:\n  len M' 0 0 (i # xs) = M' 0 i + len M' i i ys + len M' i 0 zs\n  \\<one> \\<le> len M' i i ys", "have \"M' 0 i + len M' i 0 zs \\<le> len M' 0 0 (i # xs)\""], ["proof (prove)\nusing this:\n  len M' 0 0 (i # xs) = M' 0 i + len M' i i ys + len M' i 0 zs\n  \\<one> \\<le> len M' i i ys\n\ngoal (1 subgoal):\n 1. M' 0 i + len M' i 0 zs \\<le> len M' 0 0 (i # xs)", "by (metis add_le_impl add_lt_neutral comm not_le)"], ["proof (state)\nthis:\n  M' 0 i + len M' i 0 zs \\<le> len M' 0 0 (i # xs)\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "finally"], ["proof (chain)\npicking this:\n  len M' 0 0 (i # zs) \\<le> len M' 0 0 (i # xs)", "have cycle': \"len M' 0 0 (i # zs) < \\<one>\""], ["proof (prove)\nusing this:\n  len M' 0 0 (i # zs) \\<le> len M' 0 0 (i # xs)\n\ngoal (1 subgoal):\n 1. len M' 0 0 (i # zs) < \\<one>", "using cycle"], ["proof (prove)\nusing this:\n  len M' 0 0 (i # zs) \\<le> len M' 0 0 (i # xs)\n  len M' 0 0 (i # xs) < \\<one>\n\ngoal (1 subgoal):\n 1. len M' 0 0 (i # zs) < \\<one>", "by auto"], ["proof (state)\nthis:\n  len M' 0 0 (i # zs) < \\<one>\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "from ys_zs less.prems(4)"], ["proof (chain)\npicking this:\n  xs = ys @ i # zs\n  length xs = x", "have \"x > length zs\""], ["proof (prove)\nusing this:\n  xs = ys @ i # zs\n  length xs = x\n\ngoal (1 subgoal):\n 1. length zs < x", "by auto"], ["proof (state)\nthis:\n  length zs < x\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "from cycle' less.prems ys_zs less.hyps(1)[OF this less.hyps(2) , of zs]"], ["proof (chain)\npicking this:\n  len M' 0 0 (i # zs) < \\<one>\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>\n  i \\<noteq> 0\n  xs = ys @ i # zs\n  \\<lbrakk>i \\<le> n; set zs \\<subseteq> {0..n}; cycle_free M n;\n   length zs = length zs;\n   len M' 0 0 (i # zs) < \\<one> \\<or> len M' i i (0 # zs) < \\<one>;\n   i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)", "show ?thesis"], ["proof (prove)\nusing this:\n  len M' 0 0 (i # zs) < \\<one>\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>\n  i \\<noteq> 0\n  xs = ys @ i # zs\n  \\<lbrakk>i \\<le> n; set zs \\<subseteq> {0..n}; cycle_free M n;\n   length zs = length zs;\n   len M' 0 0 (i # zs) < \\<one> \\<or> len M' i i (0 # zs) < \\<one>;\n   i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     0 \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "case False"], ["proof (state)\nthis:\n  \\<not> \\<one> \\<le> len M' i i ys\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "with less.prems(1,6) M'_diag"], ["proof (chain)\npicking this:\n  i \\<le> n\n  i \\<noteq> 0\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M' i i\n  \\<not> \\<one> \\<le> len M' i i ys", "have \"ys \\<noteq> []\""], ["proof (prove)\nusing this:\n  i \\<le> n\n  i \\<noteq> 0\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M' i i\n  \\<not> \\<one> \\<le> len M' i i ys\n\ngoal (1 subgoal):\n 1. ys \\<noteq> []", "by (auto simp: neutral)"], ["proof (state)\nthis:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' i i ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "from neg_cycle_IH[OF this] ys_zs False less.prems(1,2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ys \\<le> length xs; set ys \\<subseteq> set xs;\n   ?a2 \\<le> n; \\<not> \\<one> \\<le> len M' ?a2 ?a2 ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n  xs = ys @ i # zs\n  \\<not> \\<one> \\<le> len M' i i ys\n  i \\<le> n\n  set xs \\<subseteq> {0..n}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ys \\<le> length xs; set ys \\<subseteq> set xs;\n   ?a2 \\<le> n; \\<not> \\<one> \\<le> len M' ?a2 ?a2 ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n  xs = ys @ i # zs\n  \\<not> \\<one> \\<le> len M' i i ys\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     0 \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     0 \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     0 \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. 0 \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "case True"], ["proof (state)\nthis:\n  0 \\<in> set xs\n\ngoal (1 subgoal):\n 1. 0 \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "then"], ["proof (chain)\npicking this:\n  0 \\<in> set xs", "obtain ys zs where ys_zs: \"xs = ys @ 0 # zs\""], ["proof (prove)\nusing this:\n  0 \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        xs = ys @ 0 # zs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list)"], ["proof (state)\nthis:\n  xs = ys @ 0 # zs\n\ngoal (1 subgoal):\n 1. 0 \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "with len_decomp[of \"i # xs\" \"i # ys\" 0 zs M' 0 0]"], ["proof (chain)\npicking this:\n  i # xs = (i # ys) @ 0 # zs \\<Longrightarrow>\n  len M' 0 0 (i # xs) = len M' 0 0 (i # ys) + len M' 0 0 zs\n  xs = ys @ 0 # zs", "have len: \"len M' 0 0 (i # xs) = M' 0 i + len M' i 0 ys + len M' 0 0 zs\""], ["proof (prove)\nusing this:\n  i # xs = (i # ys) @ 0 # zs \\<Longrightarrow>\n  len M' 0 0 (i # xs) = len M' 0 0 (i # ys) + len M' 0 0 zs\n  xs = ys @ 0 # zs\n\ngoal (1 subgoal):\n 1. len M' 0 0 (i # xs) = M' 0 i + len M' i 0 ys + len M' 0 0 zs", "by auto"], ["proof (state)\nthis:\n  len M' 0 0 (i # xs) = M' 0 i + len M' i 0 ys + len M' 0 0 zs\n\ngoal (1 subgoal):\n 1. 0 \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "proof (cases \"len M' 0 0 zs \\<ge> \\<one>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' 0 0 zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' 0 0 zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "case True"], ["proof (state)\nthis:\n  \\<one> \\<le> len M' 0 0 zs\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' 0 0 zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' 0 0 zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "have \"len M' 0 0 (i # ys) = M' 0 i + len M' i 0 ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len M' 0 0 (i # ys) = M' 0 i + len M' i 0 ys", "by simp"], ["proof (state)\nthis:\n  len M' 0 0 (i # ys) = M' 0 i + len M' i 0 ys\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' 0 0 zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' 0 0 zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "also"], ["proof (state)\nthis:\n  len M' 0 0 (i # ys) = M' 0 i + len M' i 0 ys\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' 0 0 zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' 0 0 zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "from len True"], ["proof (chain)\npicking this:\n  len M' 0 0 (i # xs) = M' 0 i + len M' i 0 ys + len M' 0 0 zs\n  \\<one> \\<le> len M' 0 0 zs", "have \"M' 0 i + len M' i 0 ys \\<le> len M' 0 0 (i # xs)\""], ["proof (prove)\nusing this:\n  len M' 0 0 (i # xs) = M' 0 i + len M' i 0 ys + len M' 0 0 zs\n  \\<one> \\<le> len M' 0 0 zs\n\ngoal (1 subgoal):\n 1. M' 0 i + len M' i 0 ys \\<le> len M' 0 0 (i # xs)", "by (metis add_lt_neutral comm not_le)"], ["proof (state)\nthis:\n  M' 0 i + len M' i 0 ys \\<le> len M' 0 0 (i # xs)\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' 0 0 zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' 0 0 zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "finally"], ["proof (chain)\npicking this:\n  len M' 0 0 (i # ys) \\<le> len M' 0 0 (i # xs)", "have cycle': \"len M' 0 0 (i # ys) < \\<one>\""], ["proof (prove)\nusing this:\n  len M' 0 0 (i # ys) \\<le> len M' 0 0 (i # xs)\n\ngoal (1 subgoal):\n 1. len M' 0 0 (i # ys) < \\<one>", "using cycle"], ["proof (prove)\nusing this:\n  len M' 0 0 (i # ys) \\<le> len M' 0 0 (i # xs)\n  len M' 0 0 (i # xs) < \\<one>\n\ngoal (1 subgoal):\n 1. len M' 0 0 (i # ys) < \\<one>", "by auto"], ["proof (state)\nthis:\n  len M' 0 0 (i # ys) < \\<one>\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' 0 0 zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' 0 0 zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "from ys_zs less.prems(4)"], ["proof (chain)\npicking this:\n  xs = ys @ 0 # zs\n  length xs = x", "have \"x > length ys\""], ["proof (prove)\nusing this:\n  xs = ys @ 0 # zs\n  length xs = x\n\ngoal (1 subgoal):\n 1. length ys < x", "by auto"], ["proof (state)\nthis:\n  length ys < x\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' 0 0 zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' 0 0 zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "from cycle' less.prems ys_zs less.hyps(1)[OF this less.hyps(2) , of ys]"], ["proof (chain)\npicking this:\n  len M' 0 0 (i # ys) < \\<one>\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>\n  i \\<noteq> 0\n  xs = ys @ 0 # zs\n  \\<lbrakk>i \\<le> n; set ys \\<subseteq> {0..n}; cycle_free M n;\n   length ys = length ys;\n   len M' 0 0 (i # ys) < \\<one> \\<or> len M' i i (0 # ys) < \\<one>;\n   i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)", "show ?thesis"], ["proof (prove)\nusing this:\n  len M' 0 0 (i # ys) < \\<one>\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>\n  i \\<noteq> 0\n  xs = ys @ 0 # zs\n  \\<lbrakk>i \\<le> n; set ys \\<subseteq> {0..n}; cycle_free M n;\n   length ys = length ys;\n   len M' 0 0 (i # ys) < \\<one> \\<or> len M' i i (0 # ys) < \\<one>;\n   i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     0 \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' 0 0 zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' 0 0 zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "case False"], ["proof (state)\nthis:\n  \\<not> \\<one> \\<le> len M' 0 0 zs\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' 0 0 zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "with less.prems(1,6) M'_diag"], ["proof (chain)\npicking this:\n  i \\<le> n\n  i \\<noteq> 0\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M' i i\n  \\<not> \\<one> \\<le> len M' 0 0 zs", "have \"zs \\<noteq> []\""], ["proof (prove)\nusing this:\n  i \\<le> n\n  i \\<noteq> 0\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M' i i\n  \\<not> \\<one> \\<le> len M' 0 0 zs\n\ngoal (1 subgoal):\n 1. zs \\<noteq> []", "by (auto simp: neutral)"], ["proof (state)\nthis:\n  zs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' 0 0 zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "from neg_cycle_IH[OF this] ys_zs False less.prems(1,2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>length zs \\<le> length xs; set zs \\<subseteq> set xs;\n   ?a2 \\<le> n; \\<not> \\<one> \\<le> len M' ?a2 ?a2 zs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n  xs = ys @ 0 # zs\n  \\<not> \\<one> \\<le> len M' 0 0 zs\n  i \\<le> n\n  set xs \\<subseteq> {0..n}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length zs \\<le> length xs; set zs \\<subseteq> set xs;\n   ?a2 \\<le> n; \\<not> \\<one> \\<le> len M' ?a2 ?a2 zs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n  xs = ys @ 0 # zs\n  \\<not> \\<one> \\<le> len M' 0 0 zs\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     0 \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     0 \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     0 \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. len M' i i (0 # xs) < \\<one> \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. len M' i i (0 # xs) < \\<one> \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "assume cycle: \"len M' i i (0 # xs) < \\<one>\""], ["proof (state)\nthis:\n  len M' i i (0 # xs) < \\<one>\n\ngoal (1 subgoal):\n 1. len M' i i (0 # xs) < \\<one> \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "proof (cases \"i \\<in> set xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. i \\<notin> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "case False"], ["proof (state)\nthis:\n  i \\<notin> set xs\n\ngoal (2 subgoals):\n 1. i \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. i \\<notin> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  i \\<notin> set xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "proof (cases \"0 \\<in> set xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<notin> set xs; 0 \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         0 \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' 0 0 (i # xs) < \\<one> \\<or>\n                          len M' i i (0 # xs) < \\<one>)\n 2. \\<lbrakk>i \\<notin> set xs; 0 \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         0 \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' 0 0 (i # xs) < \\<one> \\<or>\n                          len M' i i (0 # xs) < \\<one>)", "case False"], ["proof (state)\nthis:\n  0 \\<notin> set xs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<notin> set xs; 0 \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         0 \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' 0 0 (i # xs) < \\<one> \\<or>\n                          len M' i i (0 # xs) < \\<one>)\n 2. \\<lbrakk>i \\<notin> set xs; 0 \\<notin> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         0 \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' 0 0 (i # xs) < \\<one> \\<or>\n                          len M' i i (0 # xs) < \\<one>)", "with \\<open>i \\<notin> set xs\\<close>"], ["proof (chain)\npicking this:\n  i \\<notin> set xs\n  0 \\<notin> set xs", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<notin> set xs\n  0 \\<notin> set xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "using less.prems"], ["proof (prove)\nusing this:\n  i \\<notin> set xs\n  0 \\<notin> set xs\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     0 \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> set xs; 0 \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         0 \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' 0 0 (i # xs) < \\<one> \\<or>\n                          len M' i i (0 # xs) < \\<one>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> set xs; 0 \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         0 \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' 0 0 (i # xs) < \\<one> \\<or>\n                          len M' i i (0 # xs) < \\<one>)", "case True"], ["proof (state)\nthis:\n  0 \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> set xs; 0 \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         0 \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' 0 0 (i # xs) < \\<one> \\<or>\n                          len M' i i (0 # xs) < \\<one>)", "then"], ["proof (chain)\npicking this:\n  0 \\<in> set xs", "obtain ys zs where ys_zs: \"xs = ys @ 0 # zs\""], ["proof (prove)\nusing this:\n  0 \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        xs = ys @ 0 # zs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list)"], ["proof (state)\nthis:\n  xs = ys @ 0 # zs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> set xs; 0 \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         0 \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' 0 0 (i # xs) < \\<one> \\<or>\n                          len M' i i (0 # xs) < \\<one>)", "with len_decomp[of \"0 # xs\" \"0 # ys\" 0 zs M' i i]"], ["proof (chain)\npicking this:\n  0 # xs = (0 # ys) @ 0 # zs \\<Longrightarrow>\n  len M' i i (0 # xs) = len M' i 0 (0 # ys) + len M' 0 i zs\n  xs = ys @ 0 # zs", "have len: \"len M' i i (0 # xs) = M' i 0 + len M' 0 0 ys + len M' 0 i zs\""], ["proof (prove)\nusing this:\n  0 # xs = (0 # ys) @ 0 # zs \\<Longrightarrow>\n  len M' i i (0 # xs) = len M' i 0 (0 # ys) + len M' 0 i zs\n  xs = ys @ 0 # zs\n\ngoal (1 subgoal):\n 1. len M' i i (0 # xs) = M' i 0 + len M' 0 0 ys + len M' 0 i zs", "by auto"], ["proof (state)\nthis:\n  len M' i i (0 # xs) = M' i 0 + len M' 0 0 ys + len M' 0 i zs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<notin> set xs; 0 \\<in> set xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>xs.\n                         set xs \\<subseteq> {0..n} \\<and>\n                         0 \\<notin> set xs \\<and>\n                         i \\<notin> set xs \\<and>\n                         (len M' 0 0 (i # xs) < \\<one> \\<or>\n                          len M' i i (0 # xs) < \\<one>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "proof (cases \"len M' 0 0 ys \\<ge> \\<one>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' 0 0 ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' 0 0 ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "case True"], ["proof (state)\nthis:\n  \\<one> \\<le> len M' 0 0 ys\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' 0 0 ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' 0 0 ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "have \"len M' i i (0 # zs) = M' i 0 + len M' 0 i zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len M' i i (0 # zs) = M' i 0 + len M' 0 i zs", "by simp"], ["proof (state)\nthis:\n  len M' i i (0 # zs) = M' i 0 + len M' 0 i zs\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' 0 0 ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' 0 0 ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "also"], ["proof (state)\nthis:\n  len M' i i (0 # zs) = M' i 0 + len M' 0 i zs\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' 0 0 ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' 0 0 ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "from len True"], ["proof (chain)\npicking this:\n  len M' i i (0 # xs) = M' i 0 + len M' 0 0 ys + len M' 0 i zs\n  \\<one> \\<le> len M' 0 0 ys", "have \"M' i 0 + len M' 0 i zs \\<le> len M' i i (0 # xs)\""], ["proof (prove)\nusing this:\n  len M' i i (0 # xs) = M' i 0 + len M' 0 0 ys + len M' 0 i zs\n  \\<one> \\<le> len M' 0 0 ys\n\ngoal (1 subgoal):\n 1. M' i 0 + len M' 0 i zs \\<le> len M' i i (0 # xs)", "by (metis add_le_impl add_lt_neutral comm not_le)"], ["proof (state)\nthis:\n  M' i 0 + len M' 0 i zs \\<le> len M' i i (0 # xs)\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' 0 0 ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' 0 0 ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "finally"], ["proof (chain)\npicking this:\n  len M' i i (0 # zs) \\<le> len M' i i (0 # xs)", "have cycle': \"len M' i i (0 # zs) < \\<one>\""], ["proof (prove)\nusing this:\n  len M' i i (0 # zs) \\<le> len M' i i (0 # xs)\n\ngoal (1 subgoal):\n 1. len M' i i (0 # zs) < \\<one>", "using cycle"], ["proof (prove)\nusing this:\n  len M' i i (0 # zs) \\<le> len M' i i (0 # xs)\n  len M' i i (0 # xs) < \\<one>\n\ngoal (1 subgoal):\n 1. len M' i i (0 # zs) < \\<one>", "by auto"], ["proof (state)\nthis:\n  len M' i i (0 # zs) < \\<one>\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' 0 0 ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' 0 0 ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "from ys_zs less.prems(4)"], ["proof (chain)\npicking this:\n  xs = ys @ 0 # zs\n  length xs = x", "have \"x > length zs\""], ["proof (prove)\nusing this:\n  xs = ys @ 0 # zs\n  length xs = x\n\ngoal (1 subgoal):\n 1. length zs < x", "by auto"], ["proof (state)\nthis:\n  length zs < x\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' 0 0 ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' 0 0 ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "from cycle' less.prems ys_zs less.hyps(1)[OF this less.hyps(2) , of zs]"], ["proof (chain)\npicking this:\n  len M' i i (0 # zs) < \\<one>\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>\n  i \\<noteq> 0\n  xs = ys @ 0 # zs\n  \\<lbrakk>i \\<le> n; set zs \\<subseteq> {0..n}; cycle_free M n;\n   length zs = length zs;\n   len M' 0 0 (i # zs) < \\<one> \\<or> len M' i i (0 # zs) < \\<one>;\n   i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)", "show ?thesis"], ["proof (prove)\nusing this:\n  len M' i i (0 # zs) < \\<one>\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>\n  i \\<noteq> 0\n  xs = ys @ 0 # zs\n  \\<lbrakk>i \\<le> n; set zs \\<subseteq> {0..n}; cycle_free M n;\n   length zs = length zs;\n   len M' 0 0 (i # zs) < \\<one> \\<or> len M' i i (0 # zs) < \\<one>;\n   i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     0 \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' 0 0 ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' 0 0 ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "case False"], ["proof (state)\nthis:\n  \\<not> \\<one> \\<le> len M' 0 0 ys\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' 0 0 ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "with less.prems(1,6) M'_diag"], ["proof (chain)\npicking this:\n  i \\<le> n\n  i \\<noteq> 0\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M' i i\n  \\<not> \\<one> \\<le> len M' 0 0 ys", "have \"ys \\<noteq> []\""], ["proof (prove)\nusing this:\n  i \\<le> n\n  i \\<noteq> 0\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M' i i\n  \\<not> \\<one> \\<le> len M' 0 0 ys\n\ngoal (1 subgoal):\n 1. ys \\<noteq> []", "by (auto simp: neutral)"], ["proof (state)\nthis:\n  ys \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' 0 0 ys \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "from neg_cycle_IH[OF this] ys_zs False less.prems(1,2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ys \\<le> length xs; set ys \\<subseteq> set xs;\n   ?a2 \\<le> n; \\<not> \\<one> \\<le> len M' ?a2 ?a2 ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n  xs = ys @ 0 # zs\n  \\<not> \\<one> \\<le> len M' 0 0 ys\n  i \\<le> n\n  set xs \\<subseteq> {0..n}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ys \\<le> length xs; set ys \\<subseteq> set xs;\n   ?a2 \\<le> n; \\<not> \\<one> \\<le> len M' ?a2 ?a2 ys\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n  xs = ys @ 0 # zs\n  \\<not> \\<one> \\<le> len M' 0 0 ys\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     0 \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     0 \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     0 \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. i \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "case True"], ["proof (state)\nthis:\n  i \\<in> set xs\n\ngoal (1 subgoal):\n 1. i \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "then"], ["proof (chain)\npicking this:\n  i \\<in> set xs", "obtain ys zs where ys_zs: \"xs = ys @ i # zs\""], ["proof (prove)\nusing this:\n  i \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>ys zs.\n        xs = ys @ i # zs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson split_list)"], ["proof (state)\nthis:\n  xs = ys @ i # zs\n\ngoal (1 subgoal):\n 1. i \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "with len_decomp[of \"0 # xs\" \"0 # ys\" i zs M' i i]"], ["proof (chain)\npicking this:\n  0 # xs = (0 # ys) @ i # zs \\<Longrightarrow>\n  len M' i i (0 # xs) = len M' i i (0 # ys) + len M' i i zs\n  xs = ys @ i # zs", "have len: \"len M' i i (0 # xs) = M' i 0 + len M' 0 i ys + len M' i i zs\""], ["proof (prove)\nusing this:\n  0 # xs = (0 # ys) @ i # zs \\<Longrightarrow>\n  len M' i i (0 # xs) = len M' i i (0 # ys) + len M' i i zs\n  xs = ys @ i # zs\n\ngoal (1 subgoal):\n 1. len M' i i (0 # xs) = M' i 0 + len M' 0 i ys + len M' i i zs", "by auto"], ["proof (state)\nthis:\n  len M' i i (0 # xs) = M' i 0 + len M' 0 i ys + len M' i i zs\n\ngoal (1 subgoal):\n 1. i \\<in> set xs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "proof (cases \"len M' i i zs \\<ge> \\<one>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "case True"], ["proof (state)\nthis:\n  \\<one> \\<le> len M' i i zs\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "have \"len M' i i (0 # ys) = M' i 0 + len M' 0 i ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len M' i i (0 # ys) = M' i 0 + len M' 0 i ys", "by simp"], ["proof (state)\nthis:\n  len M' i i (0 # ys) = M' i 0 + len M' 0 i ys\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "also"], ["proof (state)\nthis:\n  len M' i i (0 # ys) = M' i 0 + len M' 0 i ys\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "from len True"], ["proof (chain)\npicking this:\n  len M' i i (0 # xs) = M' i 0 + len M' 0 i ys + len M' i i zs\n  \\<one> \\<le> len M' i i zs", "have \"M' i 0 + len M' 0 i ys \\<le> len M' i i (0 # xs)\""], ["proof (prove)\nusing this:\n  len M' i i (0 # xs) = M' i 0 + len M' 0 i ys + len M' i i zs\n  \\<one> \\<le> len M' i i zs\n\ngoal (1 subgoal):\n 1. M' i 0 + len M' 0 i ys \\<le> len M' i i (0 # xs)", "by (metis add_lt_neutral comm not_le)"], ["proof (state)\nthis:\n  M' i 0 + len M' 0 i ys \\<le> len M' i i (0 # xs)\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "finally"], ["proof (chain)\npicking this:\n  len M' i i (0 # ys) \\<le> len M' i i (0 # xs)", "have cycle': \"len M' i i (0 # ys) < \\<one>\""], ["proof (prove)\nusing this:\n  len M' i i (0 # ys) \\<le> len M' i i (0 # xs)\n\ngoal (1 subgoal):\n 1. len M' i i (0 # ys) < \\<one>", "using cycle"], ["proof (prove)\nusing this:\n  len M' i i (0 # ys) \\<le> len M' i i (0 # xs)\n  len M' i i (0 # xs) < \\<one>\n\ngoal (1 subgoal):\n 1. len M' i i (0 # ys) < \\<one>", "by auto"], ["proof (state)\nthis:\n  len M' i i (0 # ys) < \\<one>\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "from ys_zs less.prems(4)"], ["proof (chain)\npicking this:\n  xs = ys @ i # zs\n  length xs = x", "have \"x > length ys\""], ["proof (prove)\nusing this:\n  xs = ys @ i # zs\n  length xs = x\n\ngoal (1 subgoal):\n 1. length ys < x", "by auto"], ["proof (state)\nthis:\n  length ys < x\n\ngoal (2 subgoals):\n 1. \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n 2. \\<not> \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "from cycle' less.prems ys_zs less.hyps(1)[OF this less.hyps(2) , of ys]"], ["proof (chain)\npicking this:\n  len M' i i (0 # ys) < \\<one>\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>\n  i \\<noteq> 0\n  xs = ys @ i # zs\n  \\<lbrakk>i \\<le> n; set ys \\<subseteq> {0..n}; cycle_free M n;\n   length ys = length ys;\n   len M' 0 0 (i # ys) < \\<one> \\<or> len M' i i (0 # ys) < \\<one>;\n   i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)", "show ?thesis"], ["proof (prove)\nusing this:\n  len M' i i (0 # ys) < \\<one>\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n  cycle_free M n\n  length xs = x\n  len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>\n  i \\<noteq> 0\n  xs = ys @ i # zs\n  \\<lbrakk>i \\<le> n; set ys \\<subseteq> {0..n}; cycle_free M n;\n   length ys = length ys;\n   len M' 0 0 (i # ys) < \\<one> \\<or> len M' i i (0 # ys) < \\<one>;\n   i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     0 \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "case False"], ["proof (state)\nthis:\n  \\<not> \\<one> \\<le> len M' i i zs\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "with less.prems(1,6) M'_diag"], ["proof (chain)\npicking this:\n  i \\<le> n\n  i \\<noteq> 0\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M' i i\n  \\<not> \\<one> \\<le> len M' i i zs", "have \"zs \\<noteq> []\""], ["proof (prove)\nusing this:\n  i \\<le> n\n  i \\<noteq> 0\n  \\<forall>i\\<le>n. Le (0::'a) \\<le> M' i i\n  \\<not> \\<one> \\<le> len M' i i zs\n\ngoal (1 subgoal):\n 1. zs \\<noteq> []", "by (auto simp: neutral)"], ["proof (state)\nthis:\n  zs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> \\<one> \\<le> len M' i i zs \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "from neg_cycle_IH[OF this] ys_zs False less.prems(1,2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>length zs \\<le> length xs; set zs \\<subseteq> set xs;\n   ?a2 \\<le> n; \\<not> \\<one> \\<le> len M' ?a2 ?a2 zs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n  xs = ys @ i # zs\n  \\<not> \\<one> \\<le> len M' i i zs\n  i \\<le> n\n  set xs \\<subseteq> {0..n}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length zs \\<le> length xs; set zs \\<subseteq> set xs;\n   ?a2 \\<le> n; \\<not> \\<one> \\<le> len M' ?a2 ?a2 zs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>xs.\n                       set xs \\<subseteq> {0..n} \\<and>\n                       0 \\<notin> set xs \\<and>\n                       i \\<notin> set xs \\<and>\n                       (len M' 0 0 (i # xs) < \\<one> \\<or>\n                        len M' i i (0 # xs) < \\<one>)\n  xs = ys @ i # zs\n  \\<not> \\<one> \\<le> len M' i i zs\n  i \\<le> n\n  set xs \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> {0..n} \\<and>\n       0 \\<notin> set xs \\<and>\n       i \\<notin> set xs \\<and>\n       (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     0 \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     0 \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     0 \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     0 \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len M' 0 0 (i # xs) < \\<one> \\<or> len M' i i (0 # xs) < \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>The Characteristic Property of Canonical DBMs\\<close>"], ["", "theorem fix_index':\n  fixes M :: \"(('a :: time) DBMEntry) mat\"\n  assumes \"Le r \\<le> M i j\" \"Le (-r) \\<le> M j i\" \"cycle_free M n\" \"canonical M n\" \"i \\<le> n\" \"j \\<le> n\" \"i \\<noteq> j\"\n  defines \"M' \\<equiv> \\<lambda> i' j'. if (i' = i \\<and> j' = j) then Le r\n                       else if (i' = j \\<and> j' = i) then Le (-r)\n                       else M i' j'\"\n  shows \"(\\<forall> u. DBM_val_bounded v u M' n \\<longrightarrow> DBM_val_bounded v u M n) \\<and> cycle_free M' n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "note A = assms"], ["proof (state)\nthis:\n  Le r \\<le> M i j\n  Le (- r) \\<le> M j i\n  cycle_free M n\n  canonical M n\n  i \\<le> n\n  j \\<le> n\n  i \\<noteq> j\n  M' \\<equiv>\n  \\<lambda>i' j'.\n     if i' = i \\<and> j' = j then Le r\n     else if i' = j \\<and> j' = i then Le (- r) else M i' j'\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "note r = assms(1,2)"], ["proof (state)\nthis:\n  Le r \\<le> M i j\n  Le (- r) \\<le> M j i\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "from \\<open>cycle_free M n\\<close>"], ["proof (chain)\npicking this:\n  cycle_free M n", "have diag_cycles: \"\\<forall>i xs. i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow> Le 0 \\<le> len M i i xs\""], ["proof (prove)\nusing this:\n  cycle_free M n\n\ngoal (1 subgoal):\n 1. \\<forall>i xs.\n       i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n       Le (0::'a) \\<le> len M i i xs", "unfolding cycle_free_def neutral"], ["proof (prove)\nusing this:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     (\\<forall>j\\<le>n.\n         len M i j (rem_cycles i j xs) \\<le> len M i j xs) \\<and>\n     Le (0::'a) \\<le> len M i i xs\n\ngoal (1 subgoal):\n 1. \\<forall>i xs.\n       i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n       Le (0::'a) \\<le> len M i i xs", "by auto"], ["proof (state)\nthis:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     Le (0::'a) \\<le> len M i i xs\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "let ?M' = \"\\<lambda> i' j'. if (i' = i \\<and> j' = j) then Le r\n                       else if (i' = j \\<and> j' = i) then Le (-r)\n                       else M i' j'\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "have \"?M' i' j' \\<le> M i' j'\" when \"i' \\<le> n\" \"j' \\<le> n\" for i' j'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if i' = i \\<and> j' = j then Le r\n     else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n    \\<le> M i' j'", "using assms"], ["proof (prove)\nusing this:\n  Le r \\<le> M i j\n  Le (- r) \\<le> M j i\n  cycle_free M n\n  canonical M n\n  i \\<le> n\n  j \\<le> n\n  i \\<noteq> j\n  M' \\<equiv>\n  \\<lambda>i' j'.\n     if i' = i \\<and> j' = j then Le r\n     else if i' = j \\<and> j' = i then Le (- r) else M i' j'\n\ngoal (1 subgoal):\n 1. (if i' = i \\<and> j' = j then Le r\n     else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n    \\<le> M i' j'", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?i' \\<le> n; ?j' \\<le> n\\<rbrakk>\n  \\<Longrightarrow> (if ?i' = i \\<and> ?j' = j then Le r\n                     else if ?i' = j \\<and> ?j' = i then Le (- r)\n                          else M ?i' ?j')\n                    \\<le> M ?i' ?j'\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "with DBM_le_subset[folded less_eq, of n ?M' M]"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>ia ja.\n              ia \\<le> n \\<longrightarrow>\n              ja \\<le> n \\<longrightarrow>\n              (if ia = i \\<and> ja = j then Le r\n               else if ia = j \\<and> ja = i then Le (- r) else M ia ja)\n              \\<le> M ia ja;\n   ?u \\<in> [(\\<lambda>i' j'.\n                 if i' = i \\<and> j' = j then Le r\n                 else if i' = j \\<and> j' = i then Le (- r)\n                      else M i' j')]\\<^bsub>?v,n\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> ?u \\<in> [M]\\<^bsub>?v,n\\<^esub>\n  \\<lbrakk>?i' \\<le> n; ?j' \\<le> n\\<rbrakk>\n  \\<Longrightarrow> (if ?i' = i \\<and> ?j' = j then Le r\n                     else if ?i' = j \\<and> ?j' = i then Le (- r)\n                          else M ?i' ?j')\n                    \\<le> M ?i' ?j'", "have \"DBM_val_bounded v u M n\"\n  if \"DBM_val_bounded v u ?M' n\" for u"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>ia ja.\n              ia \\<le> n \\<longrightarrow>\n              ja \\<le> n \\<longrightarrow>\n              (if ia = i \\<and> ja = j then Le r\n               else if ia = j \\<and> ja = i then Le (- r) else M ia ja)\n              \\<le> M ia ja;\n   ?u \\<in> [(\\<lambda>i' j'.\n                 if i' = i \\<and> j' = j then Le r\n                 else if i' = j \\<and> j' = i then Le (- r)\n                      else M i' j')]\\<^bsub>?v,n\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> ?u \\<in> [M]\\<^bsub>?v,n\\<^esub>\n  \\<lbrakk>?i' \\<le> n; ?j' \\<le> n\\<rbrakk>\n  \\<Longrightarrow> (if ?i' = i \\<and> ?j' = j then Le r\n                     else if ?i' = j \\<and> ?j' = i then Le (- r)\n                          else M ?i' ?j')\n                    \\<le> M ?i' ?j'\n\ngoal (1 subgoal):\n 1. u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "unfolding DBM_zone_repr_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>ia ja.\n              ia \\<le> n \\<longrightarrow>\n              ja \\<le> n \\<longrightarrow>\n              (if ia = i \\<and> ja = j then Le r\n               else if ia = j \\<and> ja = i then Le (- r) else M ia ja)\n              \\<le> M ia ja;\n   ?u \\<in> {u. u \\<turnstile>\\<^bsub>?v,n\\<^esub> \\<lambda>i' j'.\n                if i' = i \\<and> j' = j then Le r\n                else if i' = j \\<and> j' = i then Le (- r)\n                     else M i' j'}\\<rbrakk>\n  \\<Longrightarrow> ?u \\<in> {u. u \\<turnstile>\\<^bsub>?v,n\\<^esub> M}\n  \\<lbrakk>?i' \\<le> n; ?j' \\<le> n\\<rbrakk>\n  \\<Longrightarrow> (if ?i' = i \\<and> ?j' = j then Le r\n                     else if ?i' = j \\<and> ?j' = i then Le (- r)\n                          else M ?i' ?j')\n                    \\<le> M ?i' ?j'\n\ngoal (1 subgoal):\n 1. u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>ia ja.\n              ia \\<le> n \\<longrightarrow>\n              ja \\<le> n \\<longrightarrow>\n              (if ia = i \\<and> ja = j then Le r\n               else if ia = j \\<and> ja = i then Le (- r) else M ia ja)\n              \\<le> M ia ja;\n   ?u \\<in> {u. u \\<turnstile>\\<^bsub>?v,n\\<^esub> \\<lambda>i' j'.\n                if i' = i \\<and> j' = j then Le r\n                else if i' = j \\<and> j' = i then Le (- r)\n                     else M i' j'}\\<rbrakk>\n  \\<Longrightarrow> ?u \\<in> {u. u \\<turnstile>\\<^bsub>?v,n\\<^esub> M}\n  \\<lbrakk>?i' \\<le> n; ?j' \\<le> n\\<rbrakk>\n  \\<Longrightarrow> (if ?i' = i \\<and> ?j' = j then Le r\n                     else if ?i' = j \\<and> ?j' = i then Le (- r)\n                          else M ?i' ?j')\n                    \\<le> M ?i' ?j'\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i' j'.\n if i' = i \\<and> j' = j then Le r\n else if i' = j \\<and> j' = i then Le (- r) else M i' j'\n\ngoal (1 subgoal):\n 1. u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "by auto"], ["proof (state)\nthis:\n  ?u \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i' j'.\n  if i' = i \\<and> j' = j then Le r\n  else if i' = j \\<and> j' = i then Le (- r) else M i' j' \\<Longrightarrow>\n  ?u \\<turnstile>\\<^bsub>v,n\\<^esub> M\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "then"], ["proof (chain)\npicking this:\n  ?u \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i' j'.\n  if i' = i \\<and> j' = j then Le r\n  else if i' = j \\<and> j' = i then Le (- r) else M i' j' \\<Longrightarrow>\n  ?u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "have not_empty:\"\\<forall> u. DBM_val_bounded v u ?M' n \\<longrightarrow> DBM_val_bounded v u M n\""], ["proof (prove)\nusing this:\n  ?u \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i' j'.\n  if i' = i \\<and> j' = j then Le r\n  else if i' = j \\<and> j' = i then Le (- r) else M i' j' \\<Longrightarrow>\n  ?u \\<turnstile>\\<^bsub>v,n\\<^esub> M\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       u \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i' j'.\n      if i' = i \\<and> j' = j then Le r\n      else if i' = j \\<and> j' = i then Le (- r)\n           else M i' j' \\<longrightarrow>\n       u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "by auto"], ["proof (state)\nthis:\n  \\<forall>u.\n     u \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i' j'.\n    if i' = i \\<and> j' = j then Le r\n    else if i' = j \\<and> j' = i then Le (- r)\n         else M i' j' \\<longrightarrow>\n     u \\<turnstile>\\<^bsub>v,n\\<^esub> M\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "{"], ["proof (state)\nthis:\n  \\<forall>u.\n     u \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i' j'.\n    if i' = i \\<and> j' = j then Le r\n    else if i' = j \\<and> j' = i then Le (- r)\n         else M i' j' \\<longrightarrow>\n     u \\<turnstile>\\<^bsub>v,n\\<^esub> M\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "fix a xs"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "assume prems: \"a \\<le> n\" \"set xs \\<subseteq> {0..n}\" and cycle: \"\\<not> len ?M' a a xs \\<ge> \\<one>\""], ["proof (state)\nthis:\n  a \\<le> n\n  set xs \\<subseteq> {0..n}\n  \\<not> \\<one>\n         \\<le> len (\\<lambda>i' j'.\n                       if i' = i \\<and> j' = j then Le r\n                       else if i' = j \\<and> j' = i then Le (- r)\n                            else M i' j')\n                a a xs\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "{"], ["proof (state)\nthis:\n  a \\<le> n\n  set xs \\<subseteq> {0..n}\n  \\<not> \\<one>\n         \\<le> len (\\<lambda>i' j'.\n                       if i' = i \\<and> j' = j then Le r\n                       else if i' = j \\<and> j' = i then Le (- r)\n                            else M i' j')\n                a a xs\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "assume A: \"(i, j) \\<notin> set (arcs b a xs)\" \"(j, i) \\<notin> set (arcs b a xs)\""], ["proof (state)\nthis:\n  (i, j) \\<notin> set (arcs b a xs)\n  (j, i) \\<notin> set (arcs b a xs)\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "with \\<open>i \\<noteq> j\\<close>"], ["proof (chain)\npicking this:\n  i \\<noteq> j\n  (i, j) \\<notin> set (arcs b a xs)\n  (j, i) \\<notin> set (arcs b a xs)", "have \"len ?M' b a xs = len M b a xs\""], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  (i, j) \\<notin> set (arcs b a xs)\n  (j, i) \\<notin> set (arcs b a xs)\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le r\n            else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     b a xs =\n    len M b a xs", "by (induction xs arbitrary: b) auto"], ["proof (state)\nthis:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   b a xs =\n  len M b a xs\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(i, j) \\<notin> set (arcs ?b2 a xs);\n   (j, i) \\<notin> set (arcs ?b2 a xs)\\<rbrakk>\n  \\<Longrightarrow> len (\\<lambda>i' j'.\n                            if i' = i \\<and> j' = j then Le r\n                            else if i' = j \\<and> j' = i then Le (- r)\n                                 else M i' j')\n                     ?b2 a xs =\n                    len M ?b2 a xs\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "note * = this"], ["proof (state)\nthis:\n  \\<lbrakk>(i, j) \\<notin> set (arcs ?b2 a xs);\n   (j, i) \\<notin> set (arcs ?b2 a xs)\\<rbrakk>\n  \\<Longrightarrow> len (\\<lambda>i' j'.\n                            if i' = i \\<and> j' = j then Le r\n                            else if i' = j \\<and> j' = i then Le (- r)\n                                 else M i' j')\n                     ?b2 a xs =\n                    len M ?b2 a xs\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "{"], ["proof (state)\nthis:\n  \\<lbrakk>(i, j) \\<notin> set (arcs ?b2 a xs);\n   (j, i) \\<notin> set (arcs ?b2 a xs)\\<rbrakk>\n  \\<Longrightarrow> len (\\<lambda>i' j'.\n                            if i' = i \\<and> j' = j then Le r\n                            else if i' = j \\<and> j' = i then Le (- r)\n                                 else M i' j')\n                     ?b2 a xs =\n                    len M ?b2 a xs\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "fix a b xs"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "assume A: \"i \\<notin> set (a # xs)\" \"j \\<notin> set (a # xs)\""], ["proof (state)\nthis:\n  i \\<notin> set (a # xs)\n  j \\<notin> set (a # xs)\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "then"], ["proof (chain)\npicking this:\n  i \\<notin> set (a # xs)\n  j \\<notin> set (a # xs)", "have \"len ?M' a b xs = len M a b xs\""], ["proof (prove)\nusing this:\n  i \\<notin> set (a # xs)\n  j \\<notin> set (a # xs)\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le r\n            else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     a b xs =\n    len M a b xs", "by (induction xs arbitrary: a, auto)"], ["proof (state)\nthis:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   a b xs =\n  len M a b xs\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "}"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<notin> set (?aa2 # ?xsa2);\n   j \\<notin> set (?aa2 # ?xsa2)\\<rbrakk>\n  \\<Longrightarrow> len (\\<lambda>i' j'.\n                            if i' = i \\<and> j' = j then Le r\n                            else if i' = j \\<and> j' = i then Le (- r)\n                                 else M i' j')\n                     ?aa2 ?b2 ?xsa2 =\n                    len M ?aa2 ?b2 ?xsa2\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "note ** = this"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<notin> set (?aa2 # ?xsa2);\n   j \\<notin> set (?aa2 # ?xsa2)\\<rbrakk>\n  \\<Longrightarrow> len (\\<lambda>i' j'.\n                            if i' = i \\<and> j' = j then Le r\n                            else if i' = j \\<and> j' = i then Le (- r)\n                                 else M i' j')\n                     ?aa2 ?b2 ?xsa2 =\n                    len M ?aa2 ?b2 ?xsa2\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "{"], ["proof (state)\nthis:\n  \\<lbrakk>i \\<notin> set (?aa2 # ?xsa2);\n   j \\<notin> set (?aa2 # ?xsa2)\\<rbrakk>\n  \\<Longrightarrow> len (\\<lambda>i' j'.\n                            if i' = i \\<and> j' = j then Le r\n                            else if i' = j \\<and> j' = i then Le (- r)\n                                 else M i' j')\n                     ?aa2 ?b2 ?xsa2 =\n                    len M ?aa2 ?b2 ?xsa2\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "assume A:\"(i, j) \\<notin> set (arcs a a xs)\" \"(j, i) \\<notin> set (arcs a a xs)\""], ["proof (state)\nthis:\n  (i, j) \\<notin> set (arcs a a xs)\n  (j, i) \\<notin> set (arcs a a xs)\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "from *[OF this]"], ["proof (chain)\npicking this:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   a a xs =\n  len M a a xs", "have \"len ?M' a a xs = len M a a xs\""], ["proof (prove)\nusing this:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   a a xs =\n  len M a a xs\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le r\n            else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     a a xs =\n    len M a a xs", "."], ["proof (state)\nthis:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   a a xs =\n  len M a a xs\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "with \\<open>cycle_free M n\\<close> prems cycle"], ["proof (chain)\npicking this:\n  cycle_free M n\n  a \\<le> n\n  set xs \\<subseteq> {0..n}\n  \\<not> \\<one>\n         \\<le> len (\\<lambda>i' j'.\n                       if i' = i \\<and> j' = j then Le r\n                       else if i' = j \\<and> j' = i then Le (- r)\n                            else M i' j')\n                a a xs\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   a a xs =\n  len M a a xs", "have False"], ["proof (prove)\nusing this:\n  cycle_free M n\n  a \\<le> n\n  set xs \\<subseteq> {0..n}\n  \\<not> \\<one>\n         \\<le> len (\\<lambda>i' j'.\n                       if i' = i \\<and> j' = j then Le r\n                       else if i' = j \\<and> j' = i then Le (- r)\n                            else M i' j')\n                a a xs\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   a a xs =\n  len M a a xs\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: cycle_free_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "}"], ["proof (state)\nthis:\n  \\<lbrakk>(i, j) \\<notin> set (arcs a a xs);\n   (j, i) \\<notin> set (arcs a a xs)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>(i, j) \\<notin> set (arcs a a xs);\n   (j, i) \\<notin> set (arcs a a xs)\\<rbrakk>\n  \\<Longrightarrow> False", "have arcs:\"(i, j) \\<in> set (arcs a a xs) \\<or> (j, i) \\<in> set (arcs a a xs)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(i, j) \\<notin> set (arcs a a xs);\n   (j, i) \\<notin> set (arcs a a xs)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (i, j) \\<in> set (arcs a a xs) \\<or> (j, i) \\<in> set (arcs a a xs)", "by auto"], ["proof (state)\nthis:\n  (i, j) \\<in> set (arcs a a xs) \\<or> (j, i) \\<in> set (arcs a a xs)\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "with \\<open>i \\<noteq> j\\<close>"], ["proof (chain)\npicking this:\n  i \\<noteq> j\n  (i, j) \\<in> set (arcs a a xs) \\<or> (j, i) \\<in> set (arcs a a xs)", "have \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  (i, j) \\<in> set (arcs a a xs) \\<or> (j, i) \\<in> set (arcs a a xs)\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "from arcs"], ["proof (chain)\npicking this:\n  (i, j) \\<in> set (arcs a a xs) \\<or> (j, i) \\<in> set (arcs a a xs)", "obtain xs where xs: \"set xs \\<subseteq> {0..n}\"\n      \"len ?M' i i (j # xs) < \\<one> \\<or> len ?M' j j (i # xs) < \\<one>\""], ["proof (prove)\nusing this:\n  (i, j) \\<in> set (arcs a a xs) \\<or> (j, i) \\<in> set (arcs a a xs)\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>set xs \\<subseteq> {0..n};\n         len (\\<lambda>i' j'.\n                 if i' = i \\<and> j' = j then Le r\n                 else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n          i i (j # xs)\n         < \\<one> \\<or>\n         len (\\<lambda>i' j'.\n                 if i' = i \\<and> j' = j then Le r\n                 else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n          j j (i # xs)\n         < \\<one>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (standard, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>set xs \\<subseteq> {0..n};\n                 len (\\<lambda>i' j'.\n                         if i' = i \\<and> j' = j then Le r\n                         else if i' = j \\<and> j' = i then Le (- r)\n                              else M i' j')\n                  i i (j # xs)\n                 < \\<one> \\<or>\n                 len (\\<lambda>i' j'.\n                         if i' = i \\<and> j' = j then Le r\n                         else if i' = j \\<and> j' = i then Le (- r)\n                              else M i' j')\n                  j j (i # xs)\n                 < \\<one>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (i, j) \\<in> set (arcs a a xs)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>set xs \\<subseteq> {0..n};\n                 len (\\<lambda>i' j'.\n                         if i' = i \\<and> j' = j then Le r\n                         else if i' = j \\<and> j' = i then Le (- r)\n                              else M i' j')\n                  i i (j # xs)\n                 < \\<one> \\<or>\n                 len (\\<lambda>i' j'.\n                         if i' = i \\<and> j' = j then Le r\n                         else if i' = j \\<and> j' = i then Le (- r)\n                              else M i' j')\n                  j j (i # xs)\n                 < \\<one>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (j, i) \\<in> set (arcs a a xs)\\<rbrakk>\n    \\<Longrightarrow> thesis", "case 1"], ["proof (state)\nthis:\n  \\<lbrakk>set ?xs \\<subseteq> {0..n};\n   len (\\<lambda>i' j'.\n           if i' = i \\<and> j' = j then Le r\n           else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n    i i (j # ?xs)\n   < \\<one> \\<or>\n   len (\\<lambda>i' j'.\n           if i' = i \\<and> j' = j then Le r\n           else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n    j j (i # ?xs)\n   < \\<one>\\<rbrakk>\n  \\<Longrightarrow> thesis\n  (i, j) \\<in> set (arcs a a xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>set xs \\<subseteq> {0..n};\n                 len (\\<lambda>i' j'.\n                         if i' = i \\<and> j' = j then Le r\n                         else if i' = j \\<and> j' = i then Le (- r)\n                              else M i' j')\n                  i i (j # xs)\n                 < \\<one> \\<or>\n                 len (\\<lambda>i' j'.\n                         if i' = i \\<and> j' = j then Le r\n                         else if i' = j \\<and> j' = i then Le (- r)\n                              else M i' j')\n                  j j (i # xs)\n                 < \\<one>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (i, j) \\<in> set (arcs a a xs)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>set xs \\<subseteq> {0..n};\n                 len (\\<lambda>i' j'.\n                         if i' = i \\<and> j' = j then Le r\n                         else if i' = j \\<and> j' = i then Le (- r)\n                              else M i' j')\n                  i i (j # xs)\n                 < \\<one> \\<or>\n                 len (\\<lambda>i' j'.\n                         if i' = i \\<and> j' = j then Le r\n                         else if i' = j \\<and> j' = i then Le (- r)\n                              else M i' j')\n                  j j (i # xs)\n                 < \\<one>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (j, i) \\<in> set (arcs a a xs)\\<rbrakk>\n    \\<Longrightarrow> thesis", "from cycle_rotate_2'[OF \\<open>xs \\<noteq> []\\<close> this(2), of ?M'] prems"], ["proof (chain)\npicking this:\n  \\<exists>ys.\n     len (\\<lambda>i' j'.\n             if i' = i \\<and> j' = j then Le r\n             else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n      a a xs =\n     len (\\<lambda>i' j'.\n             if i' = i \\<and> j' = j then Le r\n             else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n      i i (j # ys) \\<and>\n     set (i # j # ys) = set (a # xs) \\<and>\n     1 + length ys = length xs \\<and>\n     set (arcs a a xs) = set (arcs i i (j # ys))\n  a \\<le> n\n  set xs \\<subseteq> {0..n}", "obtain ys where\n        \"len ?M' i i (j # ys) = len ?M' a a xs\" \"set ys \\<subseteq> {0..n}\""], ["proof (prove)\nusing this:\n  \\<exists>ys.\n     len (\\<lambda>i' j'.\n             if i' = i \\<and> j' = j then Le r\n             else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n      a a xs =\n     len (\\<lambda>i' j'.\n             if i' = i \\<and> j' = j then Le r\n             else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n      i i (j # ys) \\<and>\n     set (i # j # ys) = set (a # xs) \\<and>\n     1 + length ys = length xs \\<and>\n     set (arcs a a xs) = set (arcs i i (j # ys))\n  a \\<le> n\n  set xs \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>len (\\<lambda>i' j'.\n                         if i' = i \\<and> j' = j then Le r\n                         else if i' = j \\<and> j' = i then Le (- r)\n                              else M i' j')\n                  i i (j # ys) =\n                 len (\\<lambda>i' j'.\n                         if i' = i \\<and> j' = j then Le r\n                         else if i' = j \\<and> j' = i then Le (- r)\n                              else M i' j')\n                  a a xs;\n         set ys \\<subseteq> {0..n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   i i (j # ys) =\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   a a xs\n  set ys \\<subseteq> {0..n}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>set xs \\<subseteq> {0..n};\n                 len (\\<lambda>i' j'.\n                         if i' = i \\<and> j' = j then Le r\n                         else if i' = j \\<and> j' = i then Le (- r)\n                              else M i' j')\n                  i i (j # xs)\n                 < \\<one> \\<or>\n                 len (\\<lambda>i' j'.\n                         if i' = i \\<and> j' = j then Le r\n                         else if i' = j \\<and> j' = i then Le (- r)\n                              else M i' j')\n                  j j (i # xs)\n                 < \\<one>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (i, j) \\<in> set (arcs a a xs)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>set xs \\<subseteq> {0..n};\n                 len (\\<lambda>i' j'.\n                         if i' = i \\<and> j' = j then Le r\n                         else if i' = j \\<and> j' = i then Le (- r)\n                              else M i' j')\n                  i i (j # xs)\n                 < \\<one> \\<or>\n                 len (\\<lambda>i' j'.\n                         if i' = i \\<and> j' = j then Le r\n                         else if i' = j \\<and> j' = i then Le (- r)\n                              else M i' j')\n                  j j (i # xs)\n                 < \\<one>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (j, i) \\<in> set (arcs a a xs)\\<rbrakk>\n    \\<Longrightarrow> thesis", "with 1 cycle"], ["proof (chain)\npicking this:\n  \\<lbrakk>set ?xs \\<subseteq> {0..n};\n   len (\\<lambda>i' j'.\n           if i' = i \\<and> j' = j then Le r\n           else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n    i i (j # ?xs)\n   < \\<one> \\<or>\n   len (\\<lambda>i' j'.\n           if i' = i \\<and> j' = j then Le r\n           else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n    j j (i # ?xs)\n   < \\<one>\\<rbrakk>\n  \\<Longrightarrow> thesis\n  (i, j) \\<in> set (arcs a a xs)\n  \\<not> \\<one>\n         \\<le> len (\\<lambda>i' j'.\n                       if i' = i \\<and> j' = j then Le r\n                       else if i' = j \\<and> j' = i then Le (- r)\n                            else M i' j')\n                a a xs\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   i i (j # ys) =\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   a a xs\n  set ys \\<subseteq> {0..n}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?xs \\<subseteq> {0..n};\n   len (\\<lambda>i' j'.\n           if i' = i \\<and> j' = j then Le r\n           else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n    i i (j # ?xs)\n   < \\<one> \\<or>\n   len (\\<lambda>i' j'.\n           if i' = i \\<and> j' = j then Le r\n           else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n    j j (i # ?xs)\n   < \\<one>\\<rbrakk>\n  \\<Longrightarrow> thesis\n  (i, j) \\<in> set (arcs a a xs)\n  \\<not> \\<one>\n         \\<le> len (\\<lambda>i' j'.\n                       if i' = i \\<and> j' = j then Le r\n                       else if i' = j \\<and> j' = i then Le (- r)\n                            else M i' j')\n                a a xs\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   i i (j # ys) =\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   a a xs\n  set ys \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. thesis", "by fastforce"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>set xs \\<subseteq> {0..n};\n                 len (\\<lambda>i' j'.\n                         if i' = i \\<and> j' = j then Le r\n                         else if i' = j \\<and> j' = i then Le (- r)\n                              else M i' j')\n                  i i (j # xs)\n                 < \\<one> \\<or>\n                 len (\\<lambda>i' j'.\n                         if i' = i \\<and> j' = j then Le r\n                         else if i' = j \\<and> j' = i then Le (- r)\n                              else M i' j')\n                  j j (i # xs)\n                 < \\<one>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (j, i) \\<in> set (arcs a a xs)\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>set xs \\<subseteq> {0..n};\n                 len (\\<lambda>i' j'.\n                         if i' = i \\<and> j' = j then Le r\n                         else if i' = j \\<and> j' = i then Le (- r)\n                              else M i' j')\n                  i i (j # xs)\n                 < \\<one> \\<or>\n                 len (\\<lambda>i' j'.\n                         if i' = i \\<and> j' = j then Le r\n                         else if i' = j \\<and> j' = i then Le (- r)\n                              else M i' j')\n                  j j (i # xs)\n                 < \\<one>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (j, i) \\<in> set (arcs a a xs)\\<rbrakk>\n    \\<Longrightarrow> thesis", "case 2"], ["proof (state)\nthis:\n  \\<lbrakk>set ?xs \\<subseteq> {0..n};\n   len (\\<lambda>i' j'.\n           if i' = i \\<and> j' = j then Le r\n           else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n    i i (j # ?xs)\n   < \\<one> \\<or>\n   len (\\<lambda>i' j'.\n           if i' = i \\<and> j' = j then Le r\n           else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n    j j (i # ?xs)\n   < \\<one>\\<rbrakk>\n  \\<Longrightarrow> thesis\n  (j, i) \\<in> set (arcs a a xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>set xs \\<subseteq> {0..n};\n                 len (\\<lambda>i' j'.\n                         if i' = i \\<and> j' = j then Le r\n                         else if i' = j \\<and> j' = i then Le (- r)\n                              else M i' j')\n                  i i (j # xs)\n                 < \\<one> \\<or>\n                 len (\\<lambda>i' j'.\n                         if i' = i \\<and> j' = j then Le r\n                         else if i' = j \\<and> j' = i then Le (- r)\n                              else M i' j')\n                  j j (i # xs)\n                 < \\<one>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (j, i) \\<in> set (arcs a a xs)\\<rbrakk>\n    \\<Longrightarrow> thesis", "from cycle_rotate_2'[OF \\<open>xs \\<noteq> []\\<close> this(2), of ?M'] prems"], ["proof (chain)\npicking this:\n  \\<exists>ys.\n     len (\\<lambda>i' j'.\n             if i' = i \\<and> j' = j then Le r\n             else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n      a a xs =\n     len (\\<lambda>i' j'.\n             if i' = i \\<and> j' = j then Le r\n             else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n      j j (i # ys) \\<and>\n     set (j # i # ys) = set (a # xs) \\<and>\n     1 + length ys = length xs \\<and>\n     set (arcs a a xs) = set (arcs j j (i # ys))\n  a \\<le> n\n  set xs \\<subseteq> {0..n}", "obtain ys where\n        \"len ?M' j j (i # ys) = len ?M' a a xs\" \"set ys \\<subseteq> {0..n}\""], ["proof (prove)\nusing this:\n  \\<exists>ys.\n     len (\\<lambda>i' j'.\n             if i' = i \\<and> j' = j then Le r\n             else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n      a a xs =\n     len (\\<lambda>i' j'.\n             if i' = i \\<and> j' = j then Le r\n             else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n      j j (i # ys) \\<and>\n     set (j # i # ys) = set (a # xs) \\<and>\n     1 + length ys = length xs \\<and>\n     set (arcs a a xs) = set (arcs j j (i # ys))\n  a \\<le> n\n  set xs \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. (\\<And>ys.\n        \\<lbrakk>len (\\<lambda>i' j'.\n                         if i' = i \\<and> j' = j then Le r\n                         else if i' = j \\<and> j' = i then Le (- r)\n                              else M i' j')\n                  j j (i # ys) =\n                 len (\\<lambda>i' j'.\n                         if i' = i \\<and> j' = j then Le r\n                         else if i' = j \\<and> j' = i then Le (- r)\n                              else M i' j')\n                  a a xs;\n         set ys \\<subseteq> {0..n}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   j j (i # ys) =\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   a a xs\n  set ys \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>xs.\n                \\<lbrakk>set xs \\<subseteq> {0..n};\n                 len (\\<lambda>i' j'.\n                         if i' = i \\<and> j' = j then Le r\n                         else if i' = j \\<and> j' = i then Le (- r)\n                              else M i' j')\n                  i i (j # xs)\n                 < \\<one> \\<or>\n                 len (\\<lambda>i' j'.\n                         if i' = i \\<and> j' = j then Le r\n                         else if i' = j \\<and> j' = i then Le (- r)\n                              else M i' j')\n                  j j (i # xs)\n                 < \\<one>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (j, i) \\<in> set (arcs a a xs)\\<rbrakk>\n    \\<Longrightarrow> thesis", "with 2 cycle"], ["proof (chain)\npicking this:\n  \\<lbrakk>set ?xs \\<subseteq> {0..n};\n   len (\\<lambda>i' j'.\n           if i' = i \\<and> j' = j then Le r\n           else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n    i i (j # ?xs)\n   < \\<one> \\<or>\n   len (\\<lambda>i' j'.\n           if i' = i \\<and> j' = j then Le r\n           else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n    j j (i # ?xs)\n   < \\<one>\\<rbrakk>\n  \\<Longrightarrow> thesis\n  (j, i) \\<in> set (arcs a a xs)\n  \\<not> \\<one>\n         \\<le> len (\\<lambda>i' j'.\n                       if i' = i \\<and> j' = j then Le r\n                       else if i' = j \\<and> j' = i then Le (- r)\n                            else M i' j')\n                a a xs\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   j j (i # ys) =\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   a a xs\n  set ys \\<subseteq> {0..n}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>set ?xs \\<subseteq> {0..n};\n   len (\\<lambda>i' j'.\n           if i' = i \\<and> j' = j then Le r\n           else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n    i i (j # ?xs)\n   < \\<one> \\<or>\n   len (\\<lambda>i' j'.\n           if i' = i \\<and> j' = j then Le r\n           else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n    j j (i # ?xs)\n   < \\<one>\\<rbrakk>\n  \\<Longrightarrow> thesis\n  (j, i) \\<in> set (arcs a a xs)\n  \\<not> \\<one>\n         \\<le> len (\\<lambda>i' j'.\n                       if i' = i \\<and> j' = j then Le r\n                       else if i' = j \\<and> j' = i then Le (- r)\n                            else M i' j')\n                a a xs\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   j j (i # ys) =\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   a a xs\n  set ys \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. thesis", "by fastforce"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set xs \\<subseteq> {0..n}\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   i i (j # xs)\n  < \\<one> \\<or>\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   j j (i # xs)\n  < \\<one>\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "from new_negative_cycle_aux'[OF \\<open>i \\<le> n\\<close> \\<open>j \\<le> n\\<close> this(1) \\<open>cycle_free M n\\<close> _ this(2) \\<open>i \\<noteq> j\\<close>]"], ["proof (chain)\npicking this:\n  length xs = ?m \\<Longrightarrow>\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len (\\<lambda>i' j'.\n              if i' = i \\<and> j' = j then Le r\n              else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n       i i (j # xs)\n      < \\<one> \\<or>\n      len (\\<lambda>i' j'.\n              if i' = i \\<and> j' = j then Le r\n              else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n       j j (i # xs)\n      < \\<one>)", "obtain xs where xs:\n      \"set xs \\<subseteq> {0..n}\" \"i \\<notin> set xs\" \"j \\<notin> set xs\"\n      \"len ?M' i i (j # xs) < \\<one> \\<or> len ?M' j j (i # xs) < \\<one>\""], ["proof (prove)\nusing this:\n  length xs = ?m \\<Longrightarrow>\n  \\<exists>xs.\n     set xs \\<subseteq> {0..n} \\<and>\n     j \\<notin> set xs \\<and>\n     i \\<notin> set xs \\<and>\n     (len (\\<lambda>i' j'.\n              if i' = i \\<and> j' = j then Le r\n              else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n       i i (j # xs)\n      < \\<one> \\<or>\n      len (\\<lambda>i' j'.\n              if i' = i \\<and> j' = j then Le r\n              else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n       j j (i # xs)\n      < \\<one>)\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>set xs \\<subseteq> {0..n}; i \\<notin> set xs;\n         j \\<notin> set xs;\n         len (\\<lambda>i' j'.\n                 if i' = i \\<and> j' = j then Le r\n                 else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n          i i (j # xs)\n         < \\<one> \\<or>\n         len (\\<lambda>i' j'.\n                 if i' = i \\<and> j' = j then Le r\n                 else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n          j j (i # xs)\n         < \\<one>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  set xs \\<subseteq> {0..n}\n  i \\<notin> set xs\n  j \\<notin> set xs\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   i i (j # xs)\n  < \\<one> \\<or>\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   j j (i # xs)\n  < \\<one>\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "from this(4)"], ["proof (chain)\npicking this:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   i i (j # xs)\n  < \\<one> \\<or>\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   j j (i # xs)\n  < \\<one>", "have False"], ["proof (prove)\nusing this:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   i i (j # xs)\n  < \\<one> \\<or>\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   j j (i # xs)\n  < \\<one>\n\ngoal (1 subgoal):\n 1. False", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. len (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le r\n            else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     i i (j # xs)\n    < \\<one> \\<Longrightarrow>\n    False\n 2. len (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le r\n            else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     j j (i # xs)\n    < \\<one> \\<Longrightarrow>\n    False", "assume A: \"len ?M' j j (i # xs) < \\<one>\""], ["proof (state)\nthis:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   j j (i # xs)\n  < \\<one>\n\ngoal (2 subgoals):\n 1. len (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le r\n            else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     i i (j # xs)\n    < \\<one> \\<Longrightarrow>\n    False\n 2. len (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le r\n            else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     j j (i # xs)\n    < \\<one> \\<Longrightarrow>\n    False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> False\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> False", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> False\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> False", "with \\<open>i \\<noteq> j\\<close>"], ["proof (chain)\npicking this:\n  i \\<noteq> j\n  xs = []", "have *:\"?M' j i = Le (-r)\" \"?M' i j = Le r\""], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  xs = []\n\ngoal (1 subgoal):\n 1. (if j = i \\<and> i = j then Le r else DBM_update M j i (Le (- r)) j i) =\n    Le (- r) &&&\n    (if i = i \\<and> j = j then Le r\n     else if i = j \\<and> j = i then Le (- r) else M i j) =\n    Le r", "by simp+"], ["proof (state)\nthis:\n  (if j = i \\<and> i = j then Le r else DBM_update M j i (Le (- r)) j i) =\n  Le (- r)\n  (if i = i \\<and> j = j then Le r\n   else if i = j \\<and> j = i then Le (- r) else M i j) =\n  Le r\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> False\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> False", "from Nil"], ["proof (chain)\npicking this:\n  xs = []", "have \"len ?M' j j (i # xs) = ?M' j i + ?M' i j\""], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le r\n            else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     j j (i # xs) =\n    (if j = i \\<and> i = j then Le r else DBM_update M j i (Le (- r)) j i) +\n    (if i = i \\<and> j = j then Le r\n     else if i = j \\<and> j = i then Le (- r) else M i j)", "by simp"], ["proof (state)\nthis:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   j j (i # xs) =\n  (if j = i \\<and> i = j then Le r else DBM_update M j i (Le (- r)) j i) +\n  (if i = i \\<and> j = j then Le r\n   else if i = j \\<and> j = i then Le (- r) else M i j)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> False\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> False", "with *"], ["proof (chain)\npicking this:\n  (if j = i \\<and> i = j then Le r else DBM_update M j i (Le (- r)) j i) =\n  Le (- r)\n  (if i = i \\<and> j = j then Le r\n   else if i = j \\<and> j = i then Le (- r) else M i j) =\n  Le r\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   j j (i # xs) =\n  (if j = i \\<and> i = j then Le r else DBM_update M j i (Le (- r)) j i) +\n  (if i = i \\<and> j = j then Le r\n   else if i = j \\<and> j = i then Le (- r) else M i j)", "have \"len ?M' j j (i # xs) = Le 0\""], ["proof (prove)\nusing this:\n  (if j = i \\<and> i = j then Le r else DBM_update M j i (Le (- r)) j i) =\n  Le (- r)\n  (if i = i \\<and> j = j then Le r\n   else if i = j \\<and> j = i then Le (- r) else M i j) =\n  Le r\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   j j (i # xs) =\n  (if j = i \\<and> i = j then Le r else DBM_update M j i (Le (- r)) j i) +\n  (if i = i \\<and> j = j then Le r\n   else if i = j \\<and> j = i then Le (- r) else M i j)\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le r\n            else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     j j (i # xs) =\n    Le (0::'a)", "by (simp add: mult)"], ["proof (state)\nthis:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   j j (i # xs) =\n  Le (0::'a)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> False\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   j j (i # xs) =\n  Le (0::'a)", "show False"], ["proof (prove)\nusing this:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   j j (i # xs) =\n  Le (0::'a)\n\ngoal (1 subgoal):\n 1. False", "using A"], ["proof (prove)\nusing this:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   j j (i # xs) =\n  Le (0::'a)\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   j j (i # xs)\n  < \\<one>\n\ngoal (1 subgoal):\n 1. False", "by (simp add: neutral)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "case (Cons y ys)"], ["proof (state)\nthis:\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "have *:\"M i y + M y j \\<ge> M i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M i j \\<le> M i y + M y j", "using \\<open>canonical M n\\<close> Cons xs \\<open>i \\<le> n\\<close> \\<open>j \\<le> n\\<close>"], ["proof (prove)\nusing this:\n  canonical M n\n  xs = y # ys\n  set xs \\<subseteq> {0..n}\n  i \\<notin> set xs\n  j \\<notin> set xs\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   i i (j # xs)\n  < \\<one> \\<or>\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   j j (i # xs)\n  < \\<one>\n  i \\<le> n\n  j \\<le> n\n\ngoal (1 subgoal):\n 1. M i j \\<le> M i y + M y j", "by (simp add: mult less_eq)"], ["proof (state)\nthis:\n  M i j \\<le> M i y + M y j\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "have \"Le 0 = Le (-r) + Le r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Le (0::'a) = Le (- r) + Le r", "by (simp add: mult)"], ["proof (state)\nthis:\n  Le (0::'a) = Le (- r) + Le r\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  Le (0::'a) = Le (- r) + Le r\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "have \"\\<dots> \\<le> Le (-r) + M i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Le (- r) + Le r \\<le> Le (- r) + M i j", "using r"], ["proof (prove)\nusing this:\n  Le r \\<le> M i j\n  Le (- r) \\<le> M j i\n\ngoal (1 subgoal):\n 1. Le (- r) + Le r \\<le> Le (- r) + M i j", "by (simp add: add_mono)"], ["proof (state)\nthis:\n  Le (- r) + Le r \\<le> Le (- r) + M i j\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  Le (- r) + Le r \\<le> Le (- r) + M i j\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "have \"\\<dots> \\<le> Le (-r) + M i y + M y j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Le (- r) + M i j \\<le> Le (- r) + M i y + M y j", "using *"], ["proof (prove)\nusing this:\n  M i j \\<le> M i y + M y j\n\ngoal (1 subgoal):\n 1. Le (- r) + M i j \\<le> Le (- r) + M i y + M y j", "by (simp add: add_mono assoc)"], ["proof (state)\nthis:\n  Le (- r) + M i j \\<le> Le (- r) + M i y + M y j\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  Le (- r) + M i j \\<le> Le (- r) + M i y + M y j\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "have \"\\<dots> \\<le> Le (-r) + ?M' i y + len M y j ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Le (- r) + M i y + M y j\n    \\<le> Le (- r) +\n          (if i = i \\<and> y = j then Le r\n           else if i = j \\<and> y = i then Le (- r) else M i y) +\n          len M y j ys", "using canonical_len[OF \\<open>canonical M n\\<close>] xs(1-3) \\<open>i \\<le> n\\<close> \\<open>j \\<le> n\\<close> Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<le> n; ?j \\<le> n; set ?xs \\<subseteq> {0..n}\\<rbrakk>\n  \\<Longrightarrow> M ?i ?j \\<le> len M ?i ?j ?xs\n  set xs \\<subseteq> {0..n}\n  i \\<notin> set xs\n  j \\<notin> set xs\n  i \\<le> n\n  j \\<le> n\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. Le (- r) + M i y + M y j\n    \\<le> Le (- r) +\n          (if i = i \\<and> y = j then Le r\n           else if i = j \\<and> y = i then Le (- r) else M i y) +\n          len M y j ys", "by (simp add: add_mono)"], ["proof (state)\nthis:\n  Le (- r) + M i y + M y j\n  \\<le> Le (- r) +\n        (if i = i \\<and> y = j then Le r\n         else if i = j \\<and> y = i then Le (- r) else M i y) +\n        len M y j ys\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  Le (- r) + M i y + M y j\n  \\<le> Le (- r) +\n        (if i = i \\<and> y = j then Le r\n         else if i = j \\<and> y = i then Le (- r) else M i y) +\n        len M y j ys\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "have \"\\<dots> = len ?M' j j (i # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Le (- r) +\n    (if i = i \\<and> y = j then Le r\n     else if i = j \\<and> y = i then Le (- r) else M i y) +\n    len M y j ys =\n    len (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le r\n            else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     j j (i # xs)", "using Cons \\<open>i \\<noteq> j\\<close> ** xs(1-3)"], ["proof (prove)\nusing this:\n  xs = y # ys\n  i \\<noteq> j\n  \\<lbrakk>i \\<notin> set (?aa2 # ?xsa2);\n   j \\<notin> set (?aa2 # ?xsa2)\\<rbrakk>\n  \\<Longrightarrow> len (\\<lambda>i' j'.\n                            if i' = i \\<and> j' = j then Le r\n                            else if i' = j \\<and> j' = i then Le (- r)\n                                 else M i' j')\n                     ?aa2 ?b2 ?xsa2 =\n                    len M ?aa2 ?b2 ?xsa2\n  set xs \\<subseteq> {0..n}\n  i \\<notin> set xs\n  j \\<notin> set xs\n\ngoal (1 subgoal):\n 1. Le (- r) +\n    (if i = i \\<and> y = j then Le r\n     else if i = j \\<and> y = i then Le (- r) else M i y) +\n    len M y j ys =\n    len (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le r\n            else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     j j (i # xs)", "by (simp add: assoc)"], ["proof (state)\nthis:\n  Le (- r) +\n  (if i = i \\<and> y = j then Le r\n   else if i = j \\<and> y = i then Le (- r) else M i y) +\n  len M y j ys =\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   j j (i # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  Le (- r) +\n  (if i = i \\<and> y = j then Le r\n   else if i = j \\<and> y = i then Le (- r) else M i y) +\n  len M y j ys =\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   j j (i # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "have \"\\<dots> < Le 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le r\n            else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     j j (i # xs)\n    < Le (0::'a)", "using A"], ["proof (prove)\nusing this:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   j j (i # xs)\n  < \\<one>\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le r\n            else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     j j (i # xs)\n    < Le (0::'a)", "by (simp add: neutral)"], ["proof (state)\nthis:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   j j (i # xs)\n  < Le (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  Le (0::'a) < Le (0::'a)", "show False"], ["proof (prove)\nusing this:\n  Le (0::'a) < Le (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le r\n            else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     i i (j # xs)\n    < \\<one> \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. len (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le r\n            else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     i i (j # xs)\n    < \\<one> \\<Longrightarrow>\n    False", "assume A: \"len ?M' i i (j # xs) < \\<one>\""], ["proof (state)\nthis:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   i i (j # xs)\n  < \\<one>\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le r\n            else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     i i (j # xs)\n    < \\<one> \\<Longrightarrow>\n    False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> False\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> False", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> False\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> False", "with \\<open>i \\<noteq> j\\<close>"], ["proof (chain)\npicking this:\n  i \\<noteq> j\n  xs = []", "have *:\"?M' j i = Le (-r)\" \"?M' i j = Le r\""], ["proof (prove)\nusing this:\n  i \\<noteq> j\n  xs = []\n\ngoal (1 subgoal):\n 1. (if j = i \\<and> i = j then Le r else DBM_update M j i (Le (- r)) j i) =\n    Le (- r) &&&\n    (if i = i \\<and> j = j then Le r\n     else if i = j \\<and> j = i then Le (- r) else M i j) =\n    Le r", "by simp+"], ["proof (state)\nthis:\n  (if j = i \\<and> i = j then Le r else DBM_update M j i (Le (- r)) j i) =\n  Le (- r)\n  (if i = i \\<and> j = j then Le r\n   else if i = j \\<and> j = i then Le (- r) else M i j) =\n  Le r\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> False\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> False", "from Nil"], ["proof (chain)\npicking this:\n  xs = []", "have \"len ?M' i i (j # xs) = ?M' i j + ?M' j i\""], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le r\n            else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     i i (j # xs) =\n    (if i = i \\<and> j = j then Le r\n     else if i = j \\<and> j = i then Le (- r) else M i j) +\n    (if j = i \\<and> i = j then Le r else DBM_update M j i (Le (- r)) j i)", "by simp"], ["proof (state)\nthis:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   i i (j # xs) =\n  (if i = i \\<and> j = j then Le r\n   else if i = j \\<and> j = i then Le (- r) else M i j) +\n  (if j = i \\<and> i = j then Le r else DBM_update M j i (Le (- r)) j i)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> False\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> False", "with *"], ["proof (chain)\npicking this:\n  (if j = i \\<and> i = j then Le r else DBM_update M j i (Le (- r)) j i) =\n  Le (- r)\n  (if i = i \\<and> j = j then Le r\n   else if i = j \\<and> j = i then Le (- r) else M i j) =\n  Le r\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   i i (j # xs) =\n  (if i = i \\<and> j = j then Le r\n   else if i = j \\<and> j = i then Le (- r) else M i j) +\n  (if j = i \\<and> i = j then Le r else DBM_update M j i (Le (- r)) j i)", "have \"len ?M' i i (j # xs) = Le 0\""], ["proof (prove)\nusing this:\n  (if j = i \\<and> i = j then Le r else DBM_update M j i (Le (- r)) j i) =\n  Le (- r)\n  (if i = i \\<and> j = j then Le r\n   else if i = j \\<and> j = i then Le (- r) else M i j) =\n  Le r\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   i i (j # xs) =\n  (if i = i \\<and> j = j then Le r\n   else if i = j \\<and> j = i then Le (- r) else M i j) +\n  (if j = i \\<and> i = j then Le r else DBM_update M j i (Le (- r)) j i)\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le r\n            else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     i i (j # xs) =\n    Le (0::'a)", "by (simp add: mult)"], ["proof (state)\nthis:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   i i (j # xs) =\n  Le (0::'a)\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> False\n 2. \\<And>a list. xs = a # list \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   i i (j # xs) =\n  Le (0::'a)", "show False"], ["proof (prove)\nusing this:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   i i (j # xs) =\n  Le (0::'a)\n\ngoal (1 subgoal):\n 1. False", "using A"], ["proof (prove)\nusing this:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   i i (j # xs) =\n  Le (0::'a)\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   i i (j # xs)\n  < \\<one>\n\ngoal (1 subgoal):\n 1. False", "by (simp add: neutral)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "case (Cons y ys)"], ["proof (state)\nthis:\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "have *:\"M j y + M y i \\<ge> M j i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M j i \\<le> M j y + M y i", "using \\<open>canonical M n\\<close> Cons xs \\<open>i \\<le> n\\<close> \\<open>j \\<le> n\\<close>"], ["proof (prove)\nusing this:\n  canonical M n\n  xs = y # ys\n  set xs \\<subseteq> {0..n}\n  i \\<notin> set xs\n  j \\<notin> set xs\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   i i (j # xs)\n  < \\<one> \\<or>\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   j j (i # xs)\n  < \\<one>\n  i \\<le> n\n  j \\<le> n\n\ngoal (1 subgoal):\n 1. M j i \\<le> M j y + M y i", "by (simp add: mult less_eq)"], ["proof (state)\nthis:\n  M j i \\<le> M j y + M y i\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "have \"Le 0 = Le r + Le (-r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Le (0::'a) = Le r + Le (- r)", "by (simp add: mult)"], ["proof (state)\nthis:\n  Le (0::'a) = Le r + Le (- r)\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  Le (0::'a) = Le r + Le (- r)\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "have \"\\<dots> \\<le> Le r + M j i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Le r + Le (- r) \\<le> Le r + M j i", "using r"], ["proof (prove)\nusing this:\n  Le r \\<le> M i j\n  Le (- r) \\<le> M j i\n\ngoal (1 subgoal):\n 1. Le r + Le (- r) \\<le> Le r + M j i", "by (simp add: add_mono)"], ["proof (state)\nthis:\n  Le r + Le (- r) \\<le> Le r + M j i\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  Le r + Le (- r) \\<le> Le r + M j i\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "have \"\\<dots> \\<le> Le r + M j y + M y i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Le r + M j i \\<le> Le r + M j y + M y i", "using *"], ["proof (prove)\nusing this:\n  M j i \\<le> M j y + M y i\n\ngoal (1 subgoal):\n 1. Le r + M j i \\<le> Le r + M j y + M y i", "by (simp add: add_mono assoc)"], ["proof (state)\nthis:\n  Le r + M j i \\<le> Le r + M j y + M y i\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  Le r + M j i \\<le> Le r + M j y + M y i\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "have \"\\<dots> \\<le> Le r + ?M' j y + len M y i ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Le r + M j y + M y i\n    \\<le> Le r +\n          (if j = i \\<and> y = j then Le r\n           else if j = j \\<and> y = i then Le (- r) else M j y) +\n          len M y i ys", "using canonical_len[OF \\<open>canonical M n\\<close>] xs(1-3) \\<open>i \\<le> n\\<close> \\<open>j \\<le> n\\<close> Cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<le> n; ?j \\<le> n; set ?xs \\<subseteq> {0..n}\\<rbrakk>\n  \\<Longrightarrow> M ?i ?j \\<le> len M ?i ?j ?xs\n  set xs \\<subseteq> {0..n}\n  i \\<notin> set xs\n  j \\<notin> set xs\n  i \\<le> n\n  j \\<le> n\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. Le r + M j y + M y i\n    \\<le> Le r +\n          (if j = i \\<and> y = j then Le r\n           else if j = j \\<and> y = i then Le (- r) else M j y) +\n          len M y i ys", "by (simp add: add_mono)"], ["proof (state)\nthis:\n  Le r + M j y + M y i\n  \\<le> Le r +\n        (if j = i \\<and> y = j then Le r\n         else if j = j \\<and> y = i then Le (- r) else M j y) +\n        len M y i ys\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  Le r + M j y + M y i\n  \\<le> Le r +\n        (if j = i \\<and> y = j then Le r\n         else if j = j \\<and> y = i then Le (- r) else M j y) +\n        len M y i ys\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "have \"\\<dots> = len ?M' i i (j # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Le r +\n    (if j = i \\<and> y = j then Le r\n     else if j = j \\<and> y = i then Le (- r) else M j y) +\n    len M y i ys =\n    len (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le r\n            else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     i i (j # xs)", "using Cons \\<open>i \\<noteq> j\\<close> ** xs(1-3)"], ["proof (prove)\nusing this:\n  xs = y # ys\n  i \\<noteq> j\n  \\<lbrakk>i \\<notin> set (?aa2 # ?xsa2);\n   j \\<notin> set (?aa2 # ?xsa2)\\<rbrakk>\n  \\<Longrightarrow> len (\\<lambda>i' j'.\n                            if i' = i \\<and> j' = j then Le r\n                            else if i' = j \\<and> j' = i then Le (- r)\n                                 else M i' j')\n                     ?aa2 ?b2 ?xsa2 =\n                    len M ?aa2 ?b2 ?xsa2\n  set xs \\<subseteq> {0..n}\n  i \\<notin> set xs\n  j \\<notin> set xs\n\ngoal (1 subgoal):\n 1. Le r +\n    (if j = i \\<and> y = j then Le r\n     else if j = j \\<and> y = i then Le (- r) else M j y) +\n    len M y i ys =\n    len (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le r\n            else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     i i (j # xs)", "by (simp add: assoc)"], ["proof (state)\nthis:\n  Le r +\n  (if j = i \\<and> y = j then Le r\n   else if j = j \\<and> y = i then Le (- r) else M j y) +\n  len M y i ys =\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   i i (j # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  Le r +\n  (if j = i \\<and> y = j then Le r\n   else if j = j \\<and> y = i then Le (- r) else M j y) +\n  len M y i ys =\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   i i (j # xs)\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "have \"\\<dots> < Le 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. len (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le r\n            else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     i i (j # xs)\n    < Le (0::'a)", "using A"], ["proof (prove)\nusing this:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   i i (j # xs)\n  < \\<one>\n\ngoal (1 subgoal):\n 1. len (\\<lambda>i' j'.\n            if i' = i \\<and> j' = j then Le r\n            else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     i i (j # xs)\n    < Le (0::'a)", "by (simp add: neutral)"], ["proof (state)\nthis:\n  len (\\<lambda>i' j'.\n          if i' = i \\<and> j' = j then Le r\n          else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   i i (j # xs)\n  < Le (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a list. xs = a # list \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  Le (0::'a) < Le (0::'a)", "show False"], ["proof (prove)\nusing this:\n  Le (0::'a) < Le (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?a2 \\<le> n; set ?xs2 \\<subseteq> {0..n};\n   \\<not> \\<one>\n          \\<le> len (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le r\n                        else if i' = j \\<and> j' = i then Le (- r)\n                             else M i' j')\n                 ?a2 ?a2 ?xs2\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "note * = this"], ["proof (state)\nthis:\n  \\<lbrakk>?a2 \\<le> n; set ?xs2 \\<subseteq> {0..n};\n   \\<not> \\<one>\n          \\<le> len (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le r\n                        else if i' = j \\<and> j' = i then Le (- r)\n                             else M i' j')\n                 ?a2 ?a2 ?xs2\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "have \"cycle_free ?M' n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle_free\n     (\\<lambda>i' j'.\n         if i' = i \\<and> j' = j then Le r\n         else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     n", "using negative_cycle_dest_diag *"], ["proof (prove)\nusing this:\n  \\<not> cycle_free ?M ?n \\<Longrightarrow>\n  \\<exists>i xs.\n     i \\<le> ?n \\<and>\n     set xs \\<subseteq> {0..?n} \\<and> len ?M i i xs < \\<one>\n  \\<lbrakk>?a2 \\<le> n; set ?xs2 \\<subseteq> {0..n};\n   \\<not> \\<one>\n          \\<le> len (\\<lambda>i' j'.\n                        if i' = i \\<and> j' = j then Le r\n                        else if i' = j \\<and> j' = i then Le (- r)\n                             else M i' j')\n                 ?a2 ?a2 ?xs2\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. cycle_free\n     (\\<lambda>i' j'.\n         if i' = i \\<and> j' = j then Le r\n         else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     n", "by fastforce"], ["proof (state)\nthis:\n  cycle_free\n   (\\<lambda>i' j'.\n       if i' = i \\<and> j' = j then Le r\n       else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   n\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "then"], ["proof (chain)\npicking this:\n  cycle_free\n   (\\<lambda>i' j'.\n       if i' = i \\<and> j' = j then Le r\n       else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   n", "show ?thesis"], ["proof (prove)\nusing this:\n  cycle_free\n   (\\<lambda>i' j'.\n       if i' = i \\<and> j' = j then Le r\n       else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   n\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "using not_empty \\<open>i \\<noteq> j\\<close> r"], ["proof (prove)\nusing this:\n  cycle_free\n   (\\<lambda>i' j'.\n       if i' = i \\<and> j' = j then Le r\n       else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   n\n  \\<forall>u.\n     u \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i' j'.\n    if i' = i \\<and> j' = j then Le r\n    else if i' = j \\<and> j' = i then Le (- r)\n         else M i' j' \\<longrightarrow>\n     u \\<turnstile>\\<^bsub>v,n\\<^esub> M\n  i \\<noteq> j\n  Le r \\<le> M i j\n  Le (- r) \\<le> M j i\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free M' n", "unfolding M'_def"], ["proof (prove)\nusing this:\n  cycle_free\n   (\\<lambda>i' j'.\n       if i' = i \\<and> j' = j then Le r\n       else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n   n\n  \\<forall>u.\n     u \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i' j'.\n    if i' = i \\<and> j' = j then Le r\n    else if i' = j \\<and> j' = i then Le (- r)\n         else M i' j' \\<longrightarrow>\n     u \\<turnstile>\\<^bsub>v,n\\<^esub> M\n  i \\<noteq> j\n  Le r \\<le> M i j\n  Le (- r) \\<le> M j i\n\ngoal (1 subgoal):\n 1. (\\<forall>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i' j'.\n       if i' = i \\<and> j' = j then Le r\n       else if i' = j \\<and> j' = i then Le (- r)\n            else M i' j' \\<longrightarrow>\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n    cycle_free\n     (\\<lambda>i' j'.\n         if i' = i \\<and> j' = j then Le r\n         else if i' = j \\<and> j' = i then Le (- r) else M i' j')\n     n", "by auto"], ["proof (state)\nthis:\n  (\\<forall>u.\n      u \\<turnstile>\\<^bsub>v,n\\<^esub> M' \\<longrightarrow>\n      u \\<turnstile>\\<^bsub>v,n\\<^esub> M) \\<and>\n  cycle_free M' n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fix_index:\n  fixes M :: \"(('a :: time) DBMEntry) mat\"\n  assumes \"M 0 i + M i 0 > \\<one>\" \"cycle_free M n\" \"canonical M n\" \"i \\<le> n\" \"i \\<noteq> 0\"\n  shows\n  \"\\<exists> (M' :: ('a DBMEntry) mat). ((\\<exists> u. DBM_val_bounded v u M' n) \\<longrightarrow> (\\<exists> u. DBM_val_bounded v u M n))\n     \\<and> M' 0 i + M' i 0 = \\<one> \\<and> cycle_free M' n\n     \\<and> (\\<forall> j. i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow> M' 0 j + M' j 0 = \\<one>)\n     \\<and> (\\<forall> j. i \\<noteq> j \\<and> M 0 j + M j 0 > \\<one> \\<longrightarrow> M' 0 j + M' j 0 > \\<one>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       M' 0 i + M' i 0 = \\<one> \\<and>\n       cycle_free M' n \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n           M' 0 j + M' j 0 = \\<one>) \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n           \\<one> < M' 0 j + M' j 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       M' 0 i + M' i 0 = \\<one> \\<and>\n       cycle_free M' n \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n           M' 0 j + M' j 0 = \\<one>) \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n           \\<one> < M' 0 j + M' j 0)", "note A = assms"], ["proof (state)\nthis:\n  \\<one> < M 0 i + M i 0\n  cycle_free M n\n  canonical M n\n  i \\<le> n\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       M' 0 i + M' i 0 = \\<one> \\<and>\n       cycle_free M' n \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n           M' 0 j + M' j 0 = \\<one>) \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n           \\<one> < M' 0 j + M' j 0)", "from sum_gt_neutral_dest[OF assms(1)]"], ["proof (chain)\npicking this:\n  \\<exists>d. Le d \\<le> M 0 i \\<and> Le (- d) \\<le> M i 0", "obtain d where d: \"Le d \\<le> M i 0\" \"Le (-d) \\<le> M 0 i\""], ["proof (prove)\nusing this:\n  \\<exists>d. Le d \\<le> M 0 i \\<and> Le (- d) \\<le> M i 0\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>Le d \\<le> M i 0; Le (- d) \\<le> M 0 i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Le d \\<le> M i 0\n  Le (- d) \\<le> M 0 i\n\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       M' 0 i + M' i 0 = \\<one> \\<and>\n       cycle_free M' n \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n           M' 0 j + M' j 0 = \\<one>) \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n           \\<one> < M' 0 j + M' j 0)", "have \"i \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> 0", "using A"], ["proof (prove)\nusing this:\n  \\<one> < M 0 i + M i 0\n  cycle_free M n\n  canonical M n\n  i \\<le> n\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i \\<noteq> 0", "by - (rule ccontr; simp)"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       M' 0 i + M' i 0 = \\<one> \\<and>\n       cycle_free M' n \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n           M' 0 j + M' j 0 = \\<one>) \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n           \\<one> < M' 0 j + M' j 0)", "let ?M' = \"\\<lambda>i' j'. if i' = i \\<and> j' = 0 then Le d else if i' = 0 \\<and> j' = i then Le (-d) else M i' j'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       M' 0 i + M' i 0 = \\<one> \\<and>\n       cycle_free M' n \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n           M' 0 j + M' j 0 = \\<one>) \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n           \\<one> < M' 0 j + M' j 0)", "from fix_index'[OF d(1,2) A(2,3,4) _ \\<open>i \\<noteq> 0\\<close>]"], ["proof (chain)\npicking this:\n  0 \\<le> n \\<Longrightarrow>\n  (\\<forall>u.\n      u \\<turnstile>\\<^bsub>?v,n\\<^esub> \\<lambda>i' j'.\n      if i' = i \\<and> j' = 0 then Le d\n      else if i' = 0 \\<and> j' = i then Le (- d)\n           else M i' j' \\<longrightarrow>\n      u \\<turnstile>\\<^bsub>?v,n\\<^esub> M) \\<and>\n  cycle_free\n   (\\<lambda>i' j'.\n       if i' = i \\<and> j' = 0 then Le d\n       else if i' = 0 \\<and> j' = i then Le (- d) else M i' j')\n   n", "have M':\n    \"\\<forall>u. DBM_val_bounded v u ?M' n \\<longrightarrow> DBM_val_bounded v u M n\" \"cycle_free ?M' n\""], ["proof (prove)\nusing this:\n  0 \\<le> n \\<Longrightarrow>\n  (\\<forall>u.\n      u \\<turnstile>\\<^bsub>?v,n\\<^esub> \\<lambda>i' j'.\n      if i' = i \\<and> j' = 0 then Le d\n      else if i' = 0 \\<and> j' = i then Le (- d)\n           else M i' j' \\<longrightarrow>\n      u \\<turnstile>\\<^bsub>?v,n\\<^esub> M) \\<and>\n  cycle_free\n   (\\<lambda>i' j'.\n       if i' = i \\<and> j' = 0 then Le d\n       else if i' = 0 \\<and> j' = i then Le (- d) else M i' j')\n   n\n\ngoal (1 subgoal):\n 1. \\<forall>u.\n       u \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i' j'.\n      if i' = i \\<and> j' = 0 then Le d\n      else if i' = 0 \\<and> j' = i then Le (- d)\n           else M i' j' \\<longrightarrow>\n       u \\<turnstile>\\<^bsub>v,n\\<^esub> M &&&\n    cycle_free\n     (\\<lambda>i' j'.\n         if i' = i \\<and> j' = 0 then Le d\n         else if i' = 0 \\<and> j' = i then Le (- d) else M i' j')\n     n", "by auto"], ["proof (state)\nthis:\n  \\<forall>u.\n     u \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i' j'.\n    if i' = i \\<and> j' = 0 then Le d\n    else if i' = 0 \\<and> j' = i then Le (- d)\n         else M i' j' \\<longrightarrow>\n     u \\<turnstile>\\<^bsub>v,n\\<^esub> M\n  cycle_free\n   (\\<lambda>i' j'.\n       if i' = i \\<and> j' = 0 then Le d\n       else if i' = 0 \\<and> j' = i then Le (- d) else M i' j')\n   n\n\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       M' 0 i + M' i 0 = \\<one> \\<and>\n       cycle_free M' n \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n           M' 0 j + M' j 0 = \\<one>) \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n           \\<one> < M' 0 j + M' j 0)", "moreover"], ["proof (state)\nthis:\n  \\<forall>u.\n     u \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i' j'.\n    if i' = i \\<and> j' = 0 then Le d\n    else if i' = 0 \\<and> j' = i then Le (- d)\n         else M i' j' \\<longrightarrow>\n     u \\<turnstile>\\<^bsub>v,n\\<^esub> M\n  cycle_free\n   (\\<lambda>i' j'.\n       if i' = i \\<and> j' = 0 then Le d\n       else if i' = 0 \\<and> j' = i then Le (- d) else M i' j')\n   n\n\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       M' 0 i + M' i 0 = \\<one> \\<and>\n       cycle_free M' n \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n           M' 0 j + M' j 0 = \\<one>) \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n           \\<one> < M' 0 j + M' j 0)", "from \\<open>i \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  i \\<noteq> 0", "have \"\\<forall> j. i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow> ?M' 0 j + ?M' j 0 = \\<one>\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>j.\n       i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n       (if 0 = i \\<and> j = 0 then Le d\n        else if 0 = 0 \\<and> j = i then Le (- d) else M 0 j) +\n       (if j = i \\<and> 0 = 0 then Le d\n        else if j = 0 \\<and> 0 = i then Le (- d) else M j 0) =\n       \\<one>", "by auto"], ["proof (state)\nthis:\n  \\<forall>j.\n     i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n     (if 0 = i \\<and> j = 0 then Le d\n      else if 0 = 0 \\<and> j = i then Le (- d) else M 0 j) +\n     (if j = i \\<and> 0 = 0 then Le d\n      else if j = 0 \\<and> 0 = i then Le (- d) else M j 0) =\n     \\<one>\n\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       M' 0 i + M' i 0 = \\<one> \\<and>\n       cycle_free M' n \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n           M' 0 j + M' j 0 = \\<one>) \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n           \\<one> < M' 0 j + M' j 0)", "moreover"], ["proof (state)\nthis:\n  \\<forall>j.\n     i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n     (if 0 = i \\<and> j = 0 then Le d\n      else if 0 = 0 \\<and> j = i then Le (- d) else M 0 j) +\n     (if j = i \\<and> 0 = 0 then Le d\n      else if j = 0 \\<and> 0 = i then Le (- d) else M j 0) =\n     \\<one>\n\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       M' 0 i + M' i 0 = \\<one> \\<and>\n       cycle_free M' n \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n           M' 0 j + M' j 0 = \\<one>) \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n           \\<one> < M' 0 j + M' j 0)", "from \\<open>i \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  i \\<noteq> 0", "have \"\\<forall> j. i \\<noteq> j \\<and> M 0 j + M j 0 > \\<one> \\<longrightarrow> ?M' 0 j + ?M' j 0 > \\<one>\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>j.\n       i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n       \\<one>\n       < (if 0 = i \\<and> j = 0 then Le d\n          else if 0 = 0 \\<and> j = i then Le (- d) else M 0 j) +\n         (if j = i \\<and> 0 = 0 then Le d\n          else if j = 0 \\<and> 0 = i then Le (- d) else M j 0)", "by auto"], ["proof (state)\nthis:\n  \\<forall>j.\n     i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n     \\<one>\n     < (if 0 = i \\<and> j = 0 then Le d\n        else if 0 = 0 \\<and> j = i then Le (- d) else M 0 j) +\n       (if j = i \\<and> 0 = 0 then Le d\n        else if j = 0 \\<and> 0 = i then Le (- d) else M j 0)\n\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       M' 0 i + M' i 0 = \\<one> \\<and>\n       cycle_free M' n \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n           M' 0 j + M' j 0 = \\<one>) \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n           \\<one> < M' 0 j + M' j 0)", "moreover"], ["proof (state)\nthis:\n  \\<forall>j.\n     i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n     \\<one>\n     < (if 0 = i \\<and> j = 0 then Le d\n        else if 0 = 0 \\<and> j = i then Le (- d) else M 0 j) +\n       (if j = i \\<and> 0 = 0 then Le d\n        else if j = 0 \\<and> 0 = i then Le (- d) else M j 0)\n\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       M' 0 i + M' i 0 = \\<one> \\<and>\n       cycle_free M' n \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n           M' 0 j + M' j 0 = \\<one>) \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n           \\<one> < M' 0 j + M' j 0)", "from \\<open>i \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  i \\<noteq> 0", "have \"?M' 0 i + ?M' i 0 = \\<one>\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if 0 = i \\<and> i = 0 then Le d else DBM_update M 0 i (Le (- d)) 0 i) +\n    (if i = i \\<and> 0 = 0 then Le d\n     else if i = 0 \\<and> 0 = i then Le (- d) else M i 0) =\n    \\<one>", "unfolding neutral mult"], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. dbm_add\n     (if 0 = i \\<and> i = 0 then Le d else DBM_update M 0 i (Le (- d)) 0 i)\n     (if i = i \\<and> 0 = 0 then Le d\n      else if i = 0 \\<and> 0 = i then Le (- d) else M i 0) =\n    Le (0::'a)", "by auto"], ["proof (state)\nthis:\n  (if 0 = i \\<and> i = 0 then Le d else DBM_update M 0 i (Le (- d)) 0 i) +\n  (if i = i \\<and> 0 = 0 then Le d\n   else if i = 0 \\<and> 0 = i then Le (- d) else M i 0) =\n  \\<one>\n\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       M' 0 i + M' i 0 = \\<one> \\<and>\n       cycle_free M' n \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n           M' 0 j + M' j 0 = \\<one>) \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n           \\<one> < M' 0 j + M' j 0)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>u.\n     u \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i' j'.\n    if i' = i \\<and> j' = 0 then Le d\n    else if i' = 0 \\<and> j' = i then Le (- d)\n         else M i' j' \\<longrightarrow>\n     u \\<turnstile>\\<^bsub>v,n\\<^esub> M\n  cycle_free\n   (\\<lambda>i' j'.\n       if i' = i \\<and> j' = 0 then Le d\n       else if i' = 0 \\<and> j' = i then Le (- d) else M i' j')\n   n\n  \\<forall>j.\n     i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n     (if 0 = i \\<and> j = 0 then Le d\n      else if 0 = 0 \\<and> j = i then Le (- d) else M 0 j) +\n     (if j = i \\<and> 0 = 0 then Le d\n      else if j = 0 \\<and> 0 = i then Le (- d) else M j 0) =\n     \\<one>\n  \\<forall>j.\n     i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n     \\<one>\n     < (if 0 = i \\<and> j = 0 then Le d\n        else if 0 = 0 \\<and> j = i then Le (- d) else M 0 j) +\n       (if j = i \\<and> 0 = 0 then Le d\n        else if j = 0 \\<and> 0 = i then Le (- d) else M j 0)\n  (if 0 = i \\<and> i = 0 then Le d else DBM_update M 0 i (Le (- d)) 0 i) +\n  (if i = i \\<and> 0 = 0 then Le d\n   else if i = 0 \\<and> 0 = i then Le (- d) else M i 0) =\n  \\<one>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>u.\n     u \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i' j'.\n    if i' = i \\<and> j' = 0 then Le d\n    else if i' = 0 \\<and> j' = i then Le (- d)\n         else M i' j' \\<longrightarrow>\n     u \\<turnstile>\\<^bsub>v,n\\<^esub> M\n  cycle_free\n   (\\<lambda>i' j'.\n       if i' = i \\<and> j' = 0 then Le d\n       else if i' = 0 \\<and> j' = i then Le (- d) else M i' j')\n   n\n  \\<forall>j.\n     i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n     (if 0 = i \\<and> j = 0 then Le d\n      else if 0 = 0 \\<and> j = i then Le (- d) else M 0 j) +\n     (if j = i \\<and> 0 = 0 then Le d\n      else if j = 0 \\<and> 0 = i then Le (- d) else M j 0) =\n     \\<one>\n  \\<forall>j.\n     i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n     \\<one>\n     < (if 0 = i \\<and> j = 0 then Le d\n        else if 0 = 0 \\<and> j = i then Le (- d) else M 0 j) +\n       (if j = i \\<and> 0 = 0 then Le d\n        else if j = 0 \\<and> 0 = i then Le (- d) else M j 0)\n  (if 0 = i \\<and> i = 0 then Le d else DBM_update M 0 i (Le (- d)) 0 i) +\n  (if i = i \\<and> 0 = 0 then Le d\n   else if i = 0 \\<and> 0 = i then Le (- d) else M i 0) =\n  \\<one>\n\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       M' 0 i + M' i 0 = \\<one> \\<and>\n       cycle_free M' n \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n           M' 0 j + M' j 0 = \\<one>) \\<and>\n       (\\<forall>j.\n           i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n           \\<one> < M' 0 j + M' j 0)", "by blast"], ["proof (state)\nthis:\n  \\<exists>M'.\n     ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n      (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n     M' 0 i + M' i 0 = \\<one> \\<and>\n     cycle_free M' n \\<and>\n     (\\<forall>j.\n         i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n         M' 0 j + M' j 0 = \\<one>) \\<and>\n     (\\<forall>j.\n         i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n         \\<one> < M' 0 j + M' j 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>\n  Putting it together\n\\<close>"], ["", "lemma FW_not_empty:\n  \"DBM_val_bounded v u (FW M' n) n \\<Longrightarrow> DBM_val_bounded v u M' n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M' n \\<Longrightarrow>\n    u \\<turnstile>\\<^bsub>v,n\\<^esub> M'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M' n \\<Longrightarrow>\n    u \\<turnstile>\\<^bsub>v,n\\<^esub> M'", "assume A: \"DBM_val_bounded v u (FW M' n) n\""], ["proof (state)\nthis:\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M' n\n\ngoal (1 subgoal):\n 1. u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M' n \\<Longrightarrow>\n    u \\<turnstile>\\<^bsub>v,n\\<^esub> M'", "have \"\\<forall>i j. i \\<le> n \\<longrightarrow> j \\<le> n \\<longrightarrow> FW M' n i j \\<le> M' i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i \\<le> n \\<longrightarrow>\n       j \\<le> n \\<longrightarrow> FW M' n i j \\<le> M' i j", "using fw_mono"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<le> ?n; ?j \\<le> ?n; ?i' \\<le> ?n; ?j' \\<le> ?n\\<rbrakk>\n  \\<Longrightarrow> fw ?m ?n ?k ?i ?j ?i' ?j' \\<le> ?m ?i' ?j'\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       i \\<le> n \\<longrightarrow>\n       j \\<le> n \\<longrightarrow> FW M' n i j \\<le> M' i j", "by blast"], ["proof (state)\nthis:\n  \\<forall>i j.\n     i \\<le> n \\<longrightarrow>\n     j \\<le> n \\<longrightarrow> FW M' n i j \\<le> M' i j\n\ngoal (1 subgoal):\n 1. u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M' n \\<Longrightarrow>\n    u \\<turnstile>\\<^bsub>v,n\\<^esub> M'", "from DBM_le_subset[of n \"FW M' n\" M' _ v, OF this[unfolded less_eq]]"], ["proof (chain)\npicking this:\n  ?u \\<in> [FW M' n]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u \\<in> [M']\\<^bsub>v,n\\<^esub>", "show \"DBM_val_bounded v u M' n\""], ["proof (prove)\nusing this:\n  ?u \\<in> [FW M' n]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u \\<in> [M']\\<^bsub>v,n\\<^esub>\n\ngoal (1 subgoal):\n 1. u \\<turnstile>\\<^bsub>v,n\\<^esub> M'", "using A"], ["proof (prove)\nusing this:\n  ?u \\<in> [FW M' n]\\<^bsub>v,n\\<^esub> \\<Longrightarrow>\n  ?u \\<in> [M']\\<^bsub>v,n\\<^esub>\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M' n\n\ngoal (1 subgoal):\n 1. u \\<turnstile>\\<^bsub>v,n\\<^esub> M'", "by (auto simp: DBM_zone_repr_def)"], ["proof (state)\nthis:\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> M'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fix_indices:\n  fixes M :: \"(('a :: time) DBMEntry) mat\"\n  assumes \"set xs \\<subseteq> {0..n}\" \"distinct xs\"\n  assumes \"cyc_free M n\" \"canonical M n\"\n  shows \n  \"\\<exists> (M' :: ('a DBMEntry) mat). ((\\<exists> u. DBM_val_bounded v u M' n) \\<longrightarrow> (\\<exists> u. DBM_val_bounded v u M n))\n     \\<and> (\\<forall> i \\<in> set xs. i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and> cyc_free M' n\n     \\<and> (\\<forall> i\\<le>n. i \\<notin> set xs \\<and> M 0 i + M i 0 = \\<one> \\<longrightarrow> M' 0 i + M' i 0 = \\<one>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set xs.\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>i\\<le>n.\n           i \\<notin> set xs \\<and> M 0 i + M i 0 = \\<one> \\<longrightarrow>\n           M' 0 i + M' i 0 = \\<one>)", "using assms"], ["proof (prove)\nusing this:\n  set xs \\<subseteq> {0..n}\n  distinct xs\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs\n  canonical M n\n\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set xs.\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>i\\<le>n.\n           i \\<notin> set xs \\<and> M 0 i + M i 0 = \\<one> \\<longrightarrow>\n           M' 0 i + M' i 0 = \\<one>)", "proof (induction xs arbitrary: M)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>set [] \\<subseteq> {0..n}; distinct [];\n        \\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M i i xs;\n        canonical M n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M'.\n                            ((\\<exists>u.\n                                 u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n                             (\\<exists>u.\n                                 u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n                            (\\<forall>i\\<in>set [].\n                                i \\<noteq> 0 \\<longrightarrow>\n                                M' 0 i + M' i 0 = \\<one>) \\<and>\n                            (\\<forall>i xs.\n                                i \\<le> n \\<and>\n                                set xs \\<subseteq> {0..n} \\<longrightarrow>\n                                \\<one> \\<le> len M' i i xs) \\<and>\n                            (\\<forall>i\\<le>n.\n                                i \\<notin> set [] \\<and>\n                                M 0 i + M i 0 = \\<one> \\<longrightarrow>\n                                M' 0 i + M' i 0 = \\<one>)\n 2. \\<And>a xs M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>set xs \\<subseteq> {0..n}; distinct xs;\n                    \\<forall>i xs.\n                       i \\<le> n \\<and>\n                       set xs \\<subseteq> {0..n} \\<longrightarrow>\n                       \\<one> \\<le> len M i i xs;\n                    canonical M n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>M'.\n  ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n   (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n  (\\<forall>i\\<in>set xs.\n      i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n  (\\<forall>i xs.\n      i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n      \\<one> \\<le> len M' i i xs) \\<and>\n  (\\<forall>i\\<le>n.\n      i \\<notin> set xs \\<and> M 0 i + M i 0 = \\<one> \\<longrightarrow>\n      M' 0 i + M' i 0 = \\<one>);\n        set (a # xs) \\<subseteq> {0..n}; distinct (a # xs);\n        \\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M i i xs;\n        canonical M n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M'.\n                            ((\\<exists>u.\n                                 u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n                             (\\<exists>u.\n                                 u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n                            (\\<forall>i\\<in>set (a # xs).\n                                i \\<noteq> 0 \\<longrightarrow>\n                                M' 0 i + M' i 0 = \\<one>) \\<and>\n                            (\\<forall>i xs.\n                                i \\<le> n \\<and>\n                                set xs \\<subseteq> {0..n} \\<longrightarrow>\n                                \\<one> \\<le> len M' i i xs) \\<and>\n                            (\\<forall>i\\<le>n.\n                                i \\<notin> set (a # xs) \\<and>\n                                M 0 i + M i 0 = \\<one> \\<longrightarrow>\n                                M' 0 i + M' i 0 = \\<one>)", "case Nil"], ["proof (state)\nthis:\n  set [] \\<subseteq> {0..n}\n  distinct []\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs\n  canonical M n\n\ngoal (2 subgoals):\n 1. \\<And>M.\n       \\<lbrakk>set [] \\<subseteq> {0..n}; distinct [];\n        \\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M i i xs;\n        canonical M n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M'.\n                            ((\\<exists>u.\n                                 u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n                             (\\<exists>u.\n                                 u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n                            (\\<forall>i\\<in>set [].\n                                i \\<noteq> 0 \\<longrightarrow>\n                                M' 0 i + M' i 0 = \\<one>) \\<and>\n                            (\\<forall>i xs.\n                                i \\<le> n \\<and>\n                                set xs \\<subseteq> {0..n} \\<longrightarrow>\n                                \\<one> \\<le> len M' i i xs) \\<and>\n                            (\\<forall>i\\<le>n.\n                                i \\<notin> set [] \\<and>\n                                M 0 i + M i 0 = \\<one> \\<longrightarrow>\n                                M' 0 i + M' i 0 = \\<one>)\n 2. \\<And>a xs M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>set xs \\<subseteq> {0..n}; distinct xs;\n                    \\<forall>i xs.\n                       i \\<le> n \\<and>\n                       set xs \\<subseteq> {0..n} \\<longrightarrow>\n                       \\<one> \\<le> len M i i xs;\n                    canonical M n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>M'.\n  ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n   (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n  (\\<forall>i\\<in>set xs.\n      i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n  (\\<forall>i xs.\n      i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n      \\<one> \\<le> len M' i i xs) \\<and>\n  (\\<forall>i\\<le>n.\n      i \\<notin> set xs \\<and> M 0 i + M i 0 = \\<one> \\<longrightarrow>\n      M' 0 i + M' i 0 = \\<one>);\n        set (a # xs) \\<subseteq> {0..n}; distinct (a # xs);\n        \\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M i i xs;\n        canonical M n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M'.\n                            ((\\<exists>u.\n                                 u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n                             (\\<exists>u.\n                                 u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n                            (\\<forall>i\\<in>set (a # xs).\n                                i \\<noteq> 0 \\<longrightarrow>\n                                M' 0 i + M' i 0 = \\<one>) \\<and>\n                            (\\<forall>i xs.\n                                i \\<le> n \\<and>\n                                set xs \\<subseteq> {0..n} \\<longrightarrow>\n                                \\<one> \\<le> len M' i i xs) \\<and>\n                            (\\<forall>i\\<le>n.\n                                i \\<notin> set (a # xs) \\<and>\n                                M 0 i + M i 0 = \\<one> \\<longrightarrow>\n                                M' 0 i + M' i 0 = \\<one>)", "then"], ["proof (chain)\npicking this:\n  set [] \\<subseteq> {0..n}\n  distinct []\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs\n  canonical M n", "show ?case"], ["proof (prove)\nusing this:\n  set [] \\<subseteq> {0..n}\n  distinct []\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs\n  canonical M n\n\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set [].\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>i\\<le>n.\n           i \\<notin> set [] \\<and> M 0 i + M i 0 = \\<one> \\<longrightarrow>\n           M' 0 i + M' i 0 = \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>M'.\n     ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n      (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n     (\\<forall>i\\<in>set [].\n         i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n     (\\<forall>i xs.\n         i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n         \\<one> \\<le> len M' i i xs) \\<and>\n     (\\<forall>i\\<le>n.\n         i \\<notin> set [] \\<and> M 0 i + M i 0 = \\<one> \\<longrightarrow>\n         M' 0 i + M' i 0 = \\<one>)\n\ngoal (1 subgoal):\n 1. \\<And>a xs M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>set xs \\<subseteq> {0..n}; distinct xs;\n                    \\<forall>i xs.\n                       i \\<le> n \\<and>\n                       set xs \\<subseteq> {0..n} \\<longrightarrow>\n                       \\<one> \\<le> len M i i xs;\n                    canonical M n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>M'.\n  ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n   (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n  (\\<forall>i\\<in>set xs.\n      i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n  (\\<forall>i xs.\n      i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n      \\<one> \\<le> len M' i i xs) \\<and>\n  (\\<forall>i\\<le>n.\n      i \\<notin> set xs \\<and> M 0 i + M i 0 = \\<one> \\<longrightarrow>\n      M' 0 i + M' i 0 = \\<one>);\n        set (a # xs) \\<subseteq> {0..n}; distinct (a # xs);\n        \\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M i i xs;\n        canonical M n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M'.\n                            ((\\<exists>u.\n                                 u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n                             (\\<exists>u.\n                                 u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n                            (\\<forall>i\\<in>set (a # xs).\n                                i \\<noteq> 0 \\<longrightarrow>\n                                M' 0 i + M' i 0 = \\<one>) \\<and>\n                            (\\<forall>i xs.\n                                i \\<le> n \\<and>\n                                set xs \\<subseteq> {0..n} \\<longrightarrow>\n                                \\<one> \\<le> len M' i i xs) \\<and>\n                            (\\<forall>i\\<le>n.\n                                i \\<notin> set (a # xs) \\<and>\n                                M 0 i + M i 0 = \\<one> \\<longrightarrow>\n                                M' 0 i + M' i 0 = \\<one>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>set xs \\<subseteq> {0..n}; distinct xs;\n                    \\<forall>i xs.\n                       i \\<le> n \\<and>\n                       set xs \\<subseteq> {0..n} \\<longrightarrow>\n                       \\<one> \\<le> len M i i xs;\n                    canonical M n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>M'.\n  ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n   (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n  (\\<forall>i\\<in>set xs.\n      i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n  (\\<forall>i xs.\n      i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n      \\<one> \\<le> len M' i i xs) \\<and>\n  (\\<forall>i\\<le>n.\n      i \\<notin> set xs \\<and> M 0 i + M i 0 = \\<one> \\<longrightarrow>\n      M' 0 i + M' i 0 = \\<one>);\n        set (a # xs) \\<subseteq> {0..n}; distinct (a # xs);\n        \\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M i i xs;\n        canonical M n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M'.\n                            ((\\<exists>u.\n                                 u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n                             (\\<exists>u.\n                                 u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n                            (\\<forall>i\\<in>set (a # xs).\n                                i \\<noteq> 0 \\<longrightarrow>\n                                M' 0 i + M' i 0 = \\<one>) \\<and>\n                            (\\<forall>i xs.\n                                i \\<le> n \\<and>\n                                set xs \\<subseteq> {0..n} \\<longrightarrow>\n                                \\<one> \\<le> len M' i i xs) \\<and>\n                            (\\<forall>i\\<le>n.\n                                i \\<notin> set (a # xs) \\<and>\n                                M 0 i + M i 0 = \\<one> \\<longrightarrow>\n                                M' 0 i + M' i 0 = \\<one>)", "case (Cons i xs)"], ["proof (state)\nthis:\n  \\<lbrakk>set xs \\<subseteq> {0..n}; distinct xs;\n   \\<forall>i xs.\n      i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n      \\<one> \\<le> len ?M i i xs;\n   canonical ?M n\\<rbrakk>\n  \\<Longrightarrow> \\<exists>M'.\n                       ((\\<exists>u.\n                            u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n                        (\\<exists>u.\n                            u \\<turnstile>\\<^bsub>v,n\\<^esub> ?M)) \\<and>\n                       (\\<forall>i\\<in>set xs.\n                           i \\<noteq> 0 \\<longrightarrow>\n                           M' 0 i + M' i 0 = \\<one>) \\<and>\n                       (\\<forall>i xs.\n                           i \\<le> n \\<and>\n                           set xs \\<subseteq> {0..n} \\<longrightarrow>\n                           \\<one> \\<le> len M' i i xs) \\<and>\n                       (\\<forall>i\\<le>n.\n                           i \\<notin> set xs \\<and>\n                           ?M 0 i + ?M i 0 = \\<one> \\<longrightarrow>\n                           M' 0 i + M' i 0 = \\<one>)\n  set (i # xs) \\<subseteq> {0..n}\n  distinct (i # xs)\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs\n  canonical M n\n\ngoal (1 subgoal):\n 1. \\<And>a xs M.\n       \\<lbrakk>\\<And>M.\n                   \\<lbrakk>set xs \\<subseteq> {0..n}; distinct xs;\n                    \\<forall>i xs.\n                       i \\<le> n \\<and>\n                       set xs \\<subseteq> {0..n} \\<longrightarrow>\n                       \\<one> \\<le> len M i i xs;\n                    canonical M n\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>M'.\n  ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n   (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n  (\\<forall>i\\<in>set xs.\n      i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n  (\\<forall>i xs.\n      i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n      \\<one> \\<le> len M' i i xs) \\<and>\n  (\\<forall>i\\<le>n.\n      i \\<notin> set xs \\<and> M 0 i + M i 0 = \\<one> \\<longrightarrow>\n      M' 0 i + M' i 0 = \\<one>);\n        set (a # xs) \\<subseteq> {0..n}; distinct (a # xs);\n        \\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M i i xs;\n        canonical M n\\<rbrakk>\n       \\<Longrightarrow> \\<exists>M'.\n                            ((\\<exists>u.\n                                 u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n                             (\\<exists>u.\n                                 u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n                            (\\<forall>i\\<in>set (a # xs).\n                                i \\<noteq> 0 \\<longrightarrow>\n                                M' 0 i + M' i 0 = \\<one>) \\<and>\n                            (\\<forall>i xs.\n                                i \\<le> n \\<and>\n                                set xs \\<subseteq> {0..n} \\<longrightarrow>\n                                \\<one> \\<le> len M' i i xs) \\<and>\n                            (\\<forall>i\\<le>n.\n                                i \\<notin> set (a # xs) \\<and>\n                                M 0 i + M i 0 = \\<one> \\<longrightarrow>\n                                M' 0 i + M' i 0 = \\<one>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "proof (cases \"M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0 \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)\n 2. \\<not> (M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0) \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "case True"], ["proof (state)\nthis:\n  M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0\n\ngoal (2 subgoals):\n 1. M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0 \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)\n 2. \\<not> (M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0) \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "note T = this"], ["proof (state)\nthis:\n  M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0\n\ngoal (2 subgoals):\n 1. M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0 \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)\n 2. \\<not> (M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0) \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "proof (cases \"i = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "case False"], ["proof (state)\nthis:\n  i \\<noteq> 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "from Cons.prems"], ["proof (chain)\npicking this:\n  set (i # xs) \\<subseteq> {0..n}\n  distinct (i # xs)\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs\n  canonical M n", "have \"0 \\<le> n\" \"set [i] \\<subseteq> {0..n}\""], ["proof (prove)\nusing this:\n  set (i # xs) \\<subseteq> {0..n}\n  distinct (i # xs)\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs\n  canonical M n\n\ngoal (1 subgoal):\n 1. 0 \\<le> n &&& set [i] \\<subseteq> {0..n}", "by auto"], ["proof (state)\nthis:\n  0 \\<le> n\n  set [i] \\<subseteq> {0..n}\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "with Cons.prems(3) False T"], ["proof (chain)\npicking this:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs\n  i \\<noteq> 0\n  M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0\n  0 \\<le> n\n  set [i] \\<subseteq> {0..n}", "have \"M 0 i + M i 0 = \\<one>\""], ["proof (prove)\nusing this:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs\n  i \\<noteq> 0\n  M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0\n  0 \\<le> n\n  set [i] \\<subseteq> {0..n}\n\ngoal (1 subgoal):\n 1. M 0 i + M i 0 = \\<one>", "by fastforce"], ["proof (state)\nthis:\n  M 0 i + M i 0 = \\<one>\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)\n 2. i \\<noteq> 0 \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "with Cons.IH[OF _ _ Cons.prems(3,4)] Cons.prems(1,2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>set xs \\<subseteq> {0..n}; distinct xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>M'.\n                       ((\\<exists>u.\n                            u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n                        (\\<exists>u.\n                            u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n                       (\\<forall>i\\<in>set xs.\n                           i \\<noteq> 0 \\<longrightarrow>\n                           M' 0 i + M' i 0 = \\<one>) \\<and>\n                       (\\<forall>i xs.\n                           i \\<le> n \\<and>\n                           set xs \\<subseteq> {0..n} \\<longrightarrow>\n                           \\<one> \\<le> len M' i i xs) \\<and>\n                       (\\<forall>i\\<le>n.\n                           i \\<notin> set xs \\<and>\n                           M 0 i + M i 0 = \\<one> \\<longrightarrow>\n                           M' 0 i + M' i 0 = \\<one>)\n  set (i # xs) \\<subseteq> {0..n}\n  distinct (i # xs)\n  M 0 i + M i 0 = \\<one>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>set xs \\<subseteq> {0..n}; distinct xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>M'.\n                       ((\\<exists>u.\n                            u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n                        (\\<exists>u.\n                            u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n                       (\\<forall>i\\<in>set xs.\n                           i \\<noteq> 0 \\<longrightarrow>\n                           M' 0 i + M' i 0 = \\<one>) \\<and>\n                       (\\<forall>i xs.\n                           i \\<le> n \\<and>\n                           set xs \\<subseteq> {0..n} \\<longrightarrow>\n                           \\<one> \\<le> len M' i i xs) \\<and>\n                       (\\<forall>i\\<le>n.\n                           i \\<notin> set xs \\<and>\n                           M 0 i + M i 0 = \\<one> \\<longrightarrow>\n                           M' 0 i + M' i 0 = \\<one>)\n  set (i # xs) \\<subseteq> {0..n}\n  distinct (i # xs)\n  M 0 i + M i 0 = \\<one>\n\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>M'.\n     ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n      (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n     (\\<forall>i\\<in>set (i # xs).\n         i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n     (\\<forall>i xs.\n         i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n         \\<one> \\<le> len M' i i xs) \\<and>\n     (\\<forall>ia\\<le>n.\n         ia \\<notin> set (i # xs) \\<and>\n         M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n         M' 0 ia + M' ia 0 = \\<one>)\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "case True"], ["proof (state)\nthis:\n  i = 0\n\ngoal (1 subgoal):\n 1. i = 0 \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "with Cons.IH[OF _ _ Cons.prems(3,4)] Cons.prems(1,2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>set xs \\<subseteq> {0..n}; distinct xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>M'.\n                       ((\\<exists>u.\n                            u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n                        (\\<exists>u.\n                            u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n                       (\\<forall>i\\<in>set xs.\n                           i \\<noteq> 0 \\<longrightarrow>\n                           M' 0 i + M' i 0 = \\<one>) \\<and>\n                       (\\<forall>i xs.\n                           i \\<le> n \\<and>\n                           set xs \\<subseteq> {0..n} \\<longrightarrow>\n                           \\<one> \\<le> len M' i i xs) \\<and>\n                       (\\<forall>i\\<le>n.\n                           i \\<notin> set xs \\<and>\n                           M 0 i + M i 0 = \\<one> \\<longrightarrow>\n                           M' 0 i + M' i 0 = \\<one>)\n  set (i # xs) \\<subseteq> {0..n}\n  distinct (i # xs)\n  i = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>set xs \\<subseteq> {0..n}; distinct xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>M'.\n                       ((\\<exists>u.\n                            u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n                        (\\<exists>u.\n                            u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n                       (\\<forall>i\\<in>set xs.\n                           i \\<noteq> 0 \\<longrightarrow>\n                           M' 0 i + M' i 0 = \\<one>) \\<and>\n                       (\\<forall>i xs.\n                           i \\<le> n \\<and>\n                           set xs \\<subseteq> {0..n} \\<longrightarrow>\n                           \\<one> \\<le> len M' i i xs) \\<and>\n                       (\\<forall>i\\<le>n.\n                           i \\<notin> set xs \\<and>\n                           M 0 i + M i 0 = \\<one> \\<longrightarrow>\n                           M' 0 i + M' i 0 = \\<one>)\n  set (i # xs) \\<subseteq> {0..n}\n  distinct (i # xs)\n  i = 0\n\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>M'.\n     ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n      (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n     (\\<forall>i\\<in>set (i # xs).\n         i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n     (\\<forall>i xs.\n         i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n         \\<one> \\<le> len M' i i xs) \\<and>\n     (\\<forall>ia\\<le>n.\n         ia \\<notin> set (i # xs) \\<and>\n         M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n         M' 0 ia + M' ia 0 = \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>M'.\n     ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n      (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n     (\\<forall>i\\<in>set (i # xs).\n         i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n     (\\<forall>i xs.\n         i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n         \\<one> \\<le> len M' i i xs) \\<and>\n     (\\<forall>ia\\<le>n.\n         ia \\<notin> set (i # xs) \\<and>\n         M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n         M' 0 ia + M' ia 0 = \\<one>)\n\ngoal (1 subgoal):\n 1. \\<not> (M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0) \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0) \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "case False"], ["proof (state)\nthis:\n  \\<not> (M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0) \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "with Cons.prems"], ["proof (chain)\npicking this:\n  set (i # xs) \\<subseteq> {0..n}\n  distinct (i # xs)\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs\n  canonical M n\n  \\<not> (M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0)", "have \"\\<one> < M 0 i + M i 0\" \"i \\<le> n\" \"i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  set (i # xs) \\<subseteq> {0..n}\n  distinct (i # xs)\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs\n  canonical M n\n  \\<not> (M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0)\n\ngoal (1 subgoal):\n 1. \\<one> < M 0 i + M i 0 &&& i \\<le> n &&& i \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<one> < M 0 i + M i 0\n  i \\<le> n\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0) \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "with fix_index[OF this(1) cycle_free_diag_intro[OF Cons.prems(3)] Cons.prems(4) this(2,3), of v]"], ["proof (chain)\npicking this:\n  \\<exists>M'.\n     ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n      (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n     M' 0 i + M' i 0 = \\<one> \\<and>\n     cycle_free M' n \\<and>\n     (\\<forall>j.\n         i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n         M' 0 j + M' j 0 = \\<one>) \\<and>\n     (\\<forall>j.\n         i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n         \\<one> < M' 0 j + M' j 0)\n  \\<one> < M 0 i + M i 0\n  i \\<le> n\n  i \\<noteq> 0", "obtain M' :: \"('a DBMEntry) mat\" where M':\n      \"((\\<exists>u. DBM_val_bounded v u M' n) \\<longrightarrow> (\\<exists>u. DBM_val_bounded v u M n))\" \"(M' 0 i + M' i 0 = \\<one>)\"\n      \"cyc_free M' n\" \"\\<forall>j\\<le>n. i \\<noteq> j \\<and> M 0 j + M j 0 > \\<one> \\<longrightarrow> M' 0 j + M' j 0 > \\<one>\"\n      \"\\<forall>j. i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow> M' 0 j + M' j 0 = \\<one>\""], ["proof (prove)\nusing this:\n  \\<exists>M'.\n     ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n      (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n     M' 0 i + M' i 0 = \\<one> \\<and>\n     cycle_free M' n \\<and>\n     (\\<forall>j.\n         i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n         M' 0 j + M' j 0 = \\<one>) \\<and>\n     (\\<forall>j.\n         i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n         \\<one> < M' 0 j + M' j 0)\n  \\<one> < M 0 i + M i 0\n  i \\<le> n\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        \\<lbrakk>(\\<exists>u.\n                     u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n                 (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M);\n         M' 0 i + M' i 0 = \\<one>;\n         \\<forall>i xs.\n            i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n            \\<one> \\<le> len M' i i xs;\n         \\<forall>j\\<le>n.\n            i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n            \\<one> < M' 0 j + M' j 0;\n         \\<forall>j.\n            i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n            M' 0 j + M' j 0 = \\<one>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using cycle_free_diag_equiv"], ["proof (prove)\nusing this:\n  \\<exists>M'.\n     ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n      (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n     M' 0 i + M' i 0 = \\<one> \\<and>\n     cycle_free M' n \\<and>\n     (\\<forall>j.\n         i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n         M' 0 j + M' j 0 = \\<one>) \\<and>\n     (\\<forall>j.\n         i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n         \\<one> < M' 0 j + M' j 0)\n  \\<one> < M 0 i + M i 0\n  i \\<le> n\n  i \\<noteq> 0\n  (\\<forall>i xs.\n      i \\<le> ?n \\<and> set xs \\<subseteq> {0..?n} \\<longrightarrow>\n      \\<one> \\<le> len ?M i i xs) =\n  cycle_free ?M ?n\n\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        \\<lbrakk>(\\<exists>u.\n                     u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n                 (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M);\n         M' 0 i + M' i 0 = \\<one>;\n         \\<forall>i xs.\n            i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n            \\<one> \\<le> len M' i i xs;\n         \\<forall>j\\<le>n.\n            i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n            \\<one> < M' 0 j + M' j 0;\n         \\<forall>j.\n            i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n            M' 0 j + M' j 0 = \\<one>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)\n  M' 0 i + M' i 0 = \\<one>\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M' i i xs\n  \\<forall>j\\<le>n.\n     i \\<noteq> j \\<and> \\<one> < M 0 j + M j 0 \\<longrightarrow>\n     \\<one> < M' 0 j + M' j 0\n  \\<forall>j.\n     i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n     M' 0 j + M' j 0 = \\<one>\n\ngoal (1 subgoal):\n 1. \\<not> (M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0) \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "let ?M' = \"FW M' n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0) \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "from fw_canonical[of M' n] cycle_free_diag_equiv \\<open>cyc_free M' n\\<close>"], ["proof (chain)\npicking this:\n  cycle_free M' n \\<Longrightarrow> canonical (FW M' n) n\n  (\\<forall>i xs.\n      i \\<le> ?n \\<and> set xs \\<subseteq> {0..?n} \\<longrightarrow>\n      \\<one> \\<le> len ?M i i xs) =\n  cycle_free ?M ?n\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M' i i xs", "have \"canonical ?M' n\""], ["proof (prove)\nusing this:\n  cycle_free M' n \\<Longrightarrow> canonical (FW M' n) n\n  (\\<forall>i xs.\n      i \\<le> ?n \\<and> set xs \\<subseteq> {0..?n} \\<longrightarrow>\n      \\<one> \\<le> len ?M i i xs) =\n  cycle_free ?M ?n\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M' i i xs\n\ngoal (1 subgoal):\n 1. canonical (FW M' n) n", "by auto"], ["proof (state)\nthis:\n  canonical (FW M' n) n\n\ngoal (1 subgoal):\n 1. \\<not> (M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0) \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "from FW_cyc_free_preservation[OF \\<open>cyc_free M' n\\<close>]"], ["proof (chain)\npicking this:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len (FW M' n) i i xs", "have \"cyc_free ?M' n\""], ["proof (prove)\nusing this:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len (FW M' n) i i xs\n\ngoal (1 subgoal):\n 1. \\<forall>i xs.\n       i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n       \\<one> \\<le> len (FW M' n) i i xs", "by auto"], ["proof (state)\nthis:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len (FW M' n) i i xs\n\ngoal (1 subgoal):\n 1. \\<not> (M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0) \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "from FW_fixed_preservation[OF \\<open>i \\<le> n\\<close> M'(2) \\<open>canonical ?M' n\\<close> \\<open>cyc_free ?M' n\\<close>]"], ["proof (chain)\npicking this:\n  FW M' n 0 i + FW M' n i 0 = \\<one>", "have fixed:\"?M' 0 i + ?M' i 0 = \\<one>\""], ["proof (prove)\nusing this:\n  FW M' n 0 i + FW M' n i 0 = \\<one>\n\ngoal (1 subgoal):\n 1. FW M' n 0 i + FW M' n i 0 = \\<one>", "by (auto simp: add_mono)"], ["proof (state)\nthis:\n  FW M' n 0 i + FW M' n i 0 = \\<one>\n\ngoal (1 subgoal):\n 1. \\<not> (M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0) \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "from Cons.IH[OF _ _ \\<open>cyc_free ?M' n\\<close> \\<open>canonical ?M' n\\<close>] Cons.prems(1,2,3)"], ["proof (chain)\npicking this:\n  \\<lbrakk>set xs \\<subseteq> {0..n}; distinct xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>M'a.\n                       ((\\<exists>u.\n                            u \\<turnstile>\\<^bsub>v,n\\<^esub> M'a) \\<longrightarrow>\n                        (\\<exists>u.\n                            u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M'\n                         n)) \\<and>\n                       (\\<forall>i\\<in>set xs.\n                           i \\<noteq> 0 \\<longrightarrow>\n                           M'a 0 i + M'a i 0 = \\<one>) \\<and>\n                       (\\<forall>i xs.\n                           i \\<le> n \\<and>\n                           set xs \\<subseteq> {0..n} \\<longrightarrow>\n                           \\<one> \\<le> len M'a i i xs) \\<and>\n                       (\\<forall>i\\<le>n.\n                           i \\<notin> set xs \\<and>\n                           FW M' n 0 i + FW M' n i 0 =\n                           \\<one> \\<longrightarrow>\n                           M'a 0 i + M'a i 0 = \\<one>)\n  set (i # xs) \\<subseteq> {0..n}\n  distinct (i # xs)\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs", "obtain M'' :: \"('a DBMEntry) mat\"\n    where M'': \"((\\<exists>u. DBM_val_bounded v u M'' n) \\<longrightarrow> (\\<exists>u. DBM_val_bounded v u ?M' n))\"\n      \"(\\<forall>i\\<in>set xs. i \\<noteq> 0 \\<longrightarrow> M'' 0 i + M'' i 0 = \\<one>)\" \"cyc_free M'' n\"\n      \"(\\<forall>i\\<le>n. i \\<notin> set xs \\<and> ?M' 0 i + ?M' i 0 = \\<one> \\<longrightarrow> M'' 0 i + M'' i 0 = \\<one>)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>set xs \\<subseteq> {0..n}; distinct xs\\<rbrakk>\n  \\<Longrightarrow> \\<exists>M'a.\n                       ((\\<exists>u.\n                            u \\<turnstile>\\<^bsub>v,n\\<^esub> M'a) \\<longrightarrow>\n                        (\\<exists>u.\n                            u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M'\n                         n)) \\<and>\n                       (\\<forall>i\\<in>set xs.\n                           i \\<noteq> 0 \\<longrightarrow>\n                           M'a 0 i + M'a i 0 = \\<one>) \\<and>\n                       (\\<forall>i xs.\n                           i \\<le> n \\<and>\n                           set xs \\<subseteq> {0..n} \\<longrightarrow>\n                           \\<one> \\<le> len M'a i i xs) \\<and>\n                       (\\<forall>i\\<le>n.\n                           i \\<notin> set xs \\<and>\n                           FW M' n 0 i + FW M' n i 0 =\n                           \\<one> \\<longrightarrow>\n                           M'a 0 i + M'a i 0 = \\<one>)\n  set (i # xs) \\<subseteq> {0..n}\n  distinct (i # xs)\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs\n\ngoal (1 subgoal):\n 1. (\\<And>M''.\n        \\<lbrakk>(\\<exists>u.\n                     u \\<turnstile>\\<^bsub>v,n\\<^esub> M'') \\<longrightarrow>\n                 (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M' n);\n         \\<forall>i\\<in>set xs.\n            i \\<noteq> 0 \\<longrightarrow> M'' 0 i + M'' i 0 = \\<one>;\n         \\<forall>i xs.\n            i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n            \\<one> \\<le> len M'' i i xs;\n         \\<forall>i\\<le>n.\n            i \\<notin> set xs \\<and>\n            FW M' n 0 i + FW M' n i 0 = \\<one> \\<longrightarrow>\n            M'' 0 i + M'' i 0 = \\<one>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M'') \\<longrightarrow>\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M' n)\n  \\<forall>i\\<in>set xs.\n     i \\<noteq> 0 \\<longrightarrow> M'' 0 i + M'' i 0 = \\<one>\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M'' i i xs\n  \\<forall>i\\<le>n.\n     i \\<notin> set xs \\<and>\n     FW M' n 0 i + FW M' n i 0 = \\<one> \\<longrightarrow>\n     M'' 0 i + M'' i 0 = \\<one>\n\ngoal (1 subgoal):\n 1. \\<not> (M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0) \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "from FW_fixed_preservation[OF _ _ \\<open>canonical ?M' n\\<close> \\<open>cyc_free ?M' n\\<close>] M'(5)"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i \\<le> n; M' 0 ?i + M' ?i 0 = \\<one>\\<rbrakk>\n  \\<Longrightarrow> FW M' n 0 ?i + FW M' n ?i 0 = \\<one>\n  \\<forall>j.\n     i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n     M' 0 j + M' j 0 = \\<one>", "have \"\\<forall>j\\<le>n. i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow> ?M' 0 j + ?M' j 0 = \\<one>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<le> n; M' 0 ?i + M' ?i 0 = \\<one>\\<rbrakk>\n  \\<Longrightarrow> FW M' n 0 ?i + FW M' n ?i 0 = \\<one>\n  \\<forall>j.\n     i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n     M' 0 j + M' j 0 = \\<one>\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<le>n.\n       i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n       FW M' n 0 j + FW M' n j 0 = \\<one>", "by auto"], ["proof (state)\nthis:\n  \\<forall>j\\<le>n.\n     i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n     FW M' n 0 j + FW M' n j 0 = \\<one>\n\ngoal (1 subgoal):\n 1. \\<not> (M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0) \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "with M''(4)"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>n.\n     i \\<notin> set xs \\<and>\n     FW M' n 0 i + FW M' n i 0 = \\<one> \\<longrightarrow>\n     M'' 0 i + M'' i 0 = \\<one>\n  \\<forall>j\\<le>n.\n     i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n     FW M' n 0 j + FW M' n j 0 = \\<one>", "have \"\\<forall>j\\<le>n. j \\<notin> set (i # xs) \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow> M'' 0 j + M'' j 0 = \\<one>\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n.\n     i \\<notin> set xs \\<and>\n     FW M' n 0 i + FW M' n i 0 = \\<one> \\<longrightarrow>\n     M'' 0 i + M'' i 0 = \\<one>\n  \\<forall>j\\<le>n.\n     i \\<noteq> j \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n     FW M' n 0 j + FW M' n j 0 = \\<one>\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<le>n.\n       j \\<notin> set (i # xs) \\<and>\n       M 0 j + M j 0 = \\<one> \\<longrightarrow>\n       M'' 0 j + M'' j 0 = \\<one>", "by auto"], ["proof (state)\nthis:\n  \\<forall>j\\<le>n.\n     j \\<notin> set (i # xs) \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n     M'' 0 j + M'' j 0 = \\<one>\n\ngoal (1 subgoal):\n 1. \\<not> (M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0) \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "moreover"], ["proof (state)\nthis:\n  \\<forall>j\\<le>n.\n     j \\<notin> set (i # xs) \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n     M'' 0 j + M'' j 0 = \\<one>\n\ngoal (1 subgoal):\n 1. \\<not> (M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0) \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "from M''(2) M''(4) fixed Cons.prems(2) \\<open>i \\<le> n\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>set xs.\n     i \\<noteq> 0 \\<longrightarrow> M'' 0 i + M'' i 0 = \\<one>\n  \\<forall>i\\<le>n.\n     i \\<notin> set xs \\<and>\n     FW M' n 0 i + FW M' n i 0 = \\<one> \\<longrightarrow>\n     M'' 0 i + M'' i 0 = \\<one>\n  FW M' n 0 i + FW M' n i 0 = \\<one>\n  distinct (i # xs)\n  i \\<le> n", "have \"(\\<forall>i\\<in>set (i#xs). i \\<noteq> 0 \\<longrightarrow> M'' 0 i + M'' i 0 = \\<one>)\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>set xs.\n     i \\<noteq> 0 \\<longrightarrow> M'' 0 i + M'' i 0 = \\<one>\n  \\<forall>i\\<le>n.\n     i \\<notin> set xs \\<and>\n     FW M' n 0 i + FW M' n i 0 = \\<one> \\<longrightarrow>\n     M'' 0 i + M'' i 0 = \\<one>\n  FW M' n 0 i + FW M' n i 0 = \\<one>\n  distinct (i # xs)\n  i \\<le> n\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>set (i # xs).\n       i \\<noteq> 0 \\<longrightarrow> M'' 0 i + M'' i 0 = \\<one>", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (i # xs).\n     i \\<noteq> 0 \\<longrightarrow> M'' 0 i + M'' i 0 = \\<one>\n\ngoal (1 subgoal):\n 1. \\<not> (M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0) \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "moreover"], ["proof (state)\nthis:\n  \\<forall>i\\<in>set (i # xs).\n     i \\<noteq> 0 \\<longrightarrow> M'' 0 i + M'' i 0 = \\<one>\n\ngoal (1 subgoal):\n 1. \\<not> (M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0) \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "from M''(1) M'(1) FW_not_empty[of v _ M' n]"], ["proof (chain)\npicking this:\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M'') \\<longrightarrow>\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M' n)\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)\n  ?u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M' n \\<Longrightarrow>\n  ?u \\<turnstile>\\<^bsub>v,n\\<^esub> M'", "have \"(\\<exists>u. DBM_val_bounded v u M'' n) \\<longrightarrow> (\\<exists>u. DBM_val_bounded v u M n)\""], ["proof (prove)\nusing this:\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M'') \\<longrightarrow>\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M' n)\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)\n  ?u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M' n \\<Longrightarrow>\n  ?u \\<turnstile>\\<^bsub>v,n\\<^esub> M'\n\ngoal (1 subgoal):\n 1. (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M'') \\<longrightarrow>\n    (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M'') \\<longrightarrow>\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)\n\ngoal (1 subgoal):\n 1. \\<not> (M 0 i + M i 0 \\<le> \\<one> \\<or> i = 0) \\<Longrightarrow>\n    \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>j\\<le>n.\n     j \\<notin> set (i # xs) \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n     M'' 0 j + M'' j 0 = \\<one>\n  \\<forall>i\\<in>set (i # xs).\n     i \\<noteq> 0 \\<longrightarrow> M'' 0 i + M'' i 0 = \\<one>\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M'') \\<longrightarrow>\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>j\\<le>n.\n     j \\<notin> set (i # xs) \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n     M'' 0 j + M'' j 0 = \\<one>\n  \\<forall>i\\<in>set (i # xs).\n     i \\<noteq> 0 \\<longrightarrow> M'' 0 i + M'' i 0 = \\<one>\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M'') \\<longrightarrow>\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)\n\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "using \\<open>cyc_free M'' n\\<close> M''(4)"], ["proof (prove)\nusing this:\n  \\<forall>j\\<le>n.\n     j \\<notin> set (i # xs) \\<and> M 0 j + M j 0 = \\<one> \\<longrightarrow>\n     M'' 0 j + M'' j 0 = \\<one>\n  \\<forall>i\\<in>set (i # xs).\n     i \\<noteq> 0 \\<longrightarrow> M'' 0 i + M'' i 0 = \\<one>\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M'') \\<longrightarrow>\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M'' i i xs\n  \\<forall>i\\<le>n.\n     i \\<notin> set xs \\<and>\n     FW M' n 0 i + FW M' n i 0 = \\<one> \\<longrightarrow>\n     M'' 0 i + M'' i 0 = \\<one>\n\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n        (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n       (\\<forall>i\\<in>set (i # xs).\n           i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n       (\\<forall>i xs.\n           i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n           \\<one> \\<le> len M' i i xs) \\<and>\n       (\\<forall>ia\\<le>n.\n           ia \\<notin> set (i # xs) \\<and>\n           M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n           M' 0 ia + M' ia 0 = \\<one>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>M'.\n     ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n      (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n     (\\<forall>i\\<in>set (i # xs).\n         i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n     (\\<forall>i xs.\n         i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n         \\<one> \\<le> len M' i i xs) \\<and>\n     (\\<forall>ia\\<le>n.\n         ia \\<notin> set (i # xs) \\<and>\n         M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n         M' 0 ia + M' ia 0 = \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>M'.\n     ((\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n      (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M)) \\<and>\n     (\\<forall>i\\<in>set (i # xs).\n         i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n     (\\<forall>i xs.\n         i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n         \\<one> \\<le> len M' i i xs) \\<and>\n     (\\<forall>ia\\<le>n.\n         ia \\<notin> set (i # xs) \\<and>\n         M 0 ia + M ia 0 = \\<one> \\<longrightarrow>\n         M' 0 ia + M' ia 0 = \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cyc_free_obtains_valuation:\n  \"cyc_free M n \\<Longrightarrow> \\<forall> c. v c \\<le> n \\<longrightarrow> v c > 0 \\<Longrightarrow> \\<exists> u. DBM_val_bounded v u M n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i xs.\n                i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n                \\<one> \\<le> len M i i xs;\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i xs.\n                i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n                \\<one> \\<le> len M i i xs;\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "assume A: \"cyc_free M n\" \"\\<forall> c. v c \\<le> n \\<longrightarrow> v c > 0\""], ["proof (state)\nthis:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs\n  \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i xs.\n                i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n                \\<one> \\<le> len M i i xs;\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "let ?M = \"FW M n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i xs.\n                i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n                \\<one> \\<le> len M i i xs;\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "from fw_canonical[of M n] cycle_free_diag_equiv A"], ["proof (chain)\npicking this:\n  cycle_free M n \\<Longrightarrow> canonical (FW M n) n\n  (\\<forall>i xs.\n      i \\<le> ?n \\<and> set xs \\<subseteq> {0..?n} \\<longrightarrow>\n      \\<one> \\<le> len ?M i i xs) =\n  cycle_free ?M ?n\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs\n  \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c", "have \"canonical ?M n\""], ["proof (prove)\nusing this:\n  cycle_free M n \\<Longrightarrow> canonical (FW M n) n\n  (\\<forall>i xs.\n      i \\<le> ?n \\<and> set xs \\<subseteq> {0..?n} \\<longrightarrow>\n      \\<one> \\<le> len ?M i i xs) =\n  cycle_free ?M ?n\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs\n  \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\n\ngoal (1 subgoal):\n 1. canonical (FW M n) n", "by auto"], ["proof (state)\nthis:\n  canonical (FW M n) n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i xs.\n                i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n                \\<one> \\<le> len M i i xs;\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "from FW_cyc_free_preservation[OF A(1) ]"], ["proof (chain)\npicking this:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len (FW M n) i i xs", "have \"cyc_free ?M n\""], ["proof (prove)\nusing this:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len (FW M n) i i xs\n\ngoal (1 subgoal):\n 1. \\<forall>i xs.\n       i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n       \\<one> \\<le> len (FW M n) i i xs", "."], ["proof (state)\nthis:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len (FW M n) i i xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i xs.\n                i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n                \\<one> \\<le> len M i i xs;\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "have \"set [0..<n+1] \\<subseteq> {0..n}\" \"distinct [0..<n+1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set [0..<n + 1] \\<subseteq> {0..n} &&& distinct [0..<n + 1]", "by auto"], ["proof (state)\nthis:\n  set [0..<n + 1] \\<subseteq> {0..n}\n  distinct [0..<n + 1]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i xs.\n                i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n                \\<one> \\<le> len M i i xs;\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "from fix_indices[OF this \\<open>cyc_free ?M n\\<close> \\<open>canonical ?M n\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>M'.\n     ((\\<exists>u. u \\<turnstile>\\<^bsub>?v,n\\<^esub> M') \\<longrightarrow>\n      (\\<exists>u. u \\<turnstile>\\<^bsub>?v,n\\<^esub> FW M n)) \\<and>\n     (\\<forall>i\\<in>set [0..<n + 1].\n         i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n     (\\<forall>i xs.\n         i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n         \\<one> \\<le> len M' i i xs) \\<and>\n     (\\<forall>i\\<le>n.\n         i \\<notin> set [0..<n + 1] \\<and>\n         FW M n 0 i + FW M n i 0 = \\<one> \\<longrightarrow>\n         M' 0 i + M' i 0 = \\<one>)", "obtain M' :: \"('a DBMEntry) mat\" where M':\n    \"(\\<exists>u. DBM_val_bounded v u M' n) \\<longrightarrow> (\\<exists>u. DBM_val_bounded v u (FW M n) n)\"\n    \"\\<forall>i\\<in>set [0..<n + 1]. i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>\" \"cyc_free M' n\""], ["proof (prove)\nusing this:\n  \\<exists>M'.\n     ((\\<exists>u. u \\<turnstile>\\<^bsub>?v,n\\<^esub> M') \\<longrightarrow>\n      (\\<exists>u. u \\<turnstile>\\<^bsub>?v,n\\<^esub> FW M n)) \\<and>\n     (\\<forall>i\\<in>set [0..<n + 1].\n         i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>) \\<and>\n     (\\<forall>i xs.\n         i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n         \\<one> \\<le> len M' i i xs) \\<and>\n     (\\<forall>i\\<le>n.\n         i \\<notin> set [0..<n + 1] \\<and>\n         FW M n 0 i + FW M n i 0 = \\<one> \\<longrightarrow>\n         M' 0 i + M' i 0 = \\<one>)\n\ngoal (1 subgoal):\n 1. (\\<And>M'.\n        \\<lbrakk>(\\<exists>u.\n                     u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n                 (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M n);\n         \\<forall>i\\<in>set [0..<n + 1].\n            i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>;\n         \\<forall>i xs.\n            i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n            \\<one> \\<le> len M' i i xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M n)\n  \\<forall>i\\<in>set [0..<n + 1].\n     i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M' i i xs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i xs.\n                i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n                \\<one> \\<le> len M i i xs;\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "let ?M' = \"FW M' n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i xs.\n                i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n                \\<one> \\<le> len M i i xs;\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "have \"\\<And> i. i \\<le> n \\<Longrightarrow> i \\<in> set [0..<n + 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<le> n \\<Longrightarrow> i \\<in> set [0..<n + 1]", "by auto"], ["proof (state)\nthis:\n  ?i \\<le> n \\<Longrightarrow> ?i \\<in> set [0..<n + 1]\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i xs.\n                i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n                \\<one> \\<le> len M i i xs;\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "with M'(2)"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>set [0..<n + 1].\n     i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>\n  ?i \\<le> n \\<Longrightarrow> ?i \\<in> set [0..<n + 1]", "have M'_fixed: \"\\<forall>i\\<le>n. i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>set [0..<n + 1].\n     i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>\n  ?i \\<le> n \\<Longrightarrow> ?i \\<in> set [0..<n + 1]\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>n.\n       i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n. i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i xs.\n                i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n                \\<one> \\<le> len M i i xs;\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "from fw_canonical[of M' n] cycle_free_diag_equiv M'(3)"], ["proof (chain)\npicking this:\n  cycle_free M' n \\<Longrightarrow> canonical (FW M' n) n\n  (\\<forall>i xs.\n      i \\<le> ?n \\<and> set xs \\<subseteq> {0..?n} \\<longrightarrow>\n      \\<one> \\<le> len ?M i i xs) =\n  cycle_free ?M ?n\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M' i i xs", "have \"canonical ?M' n\""], ["proof (prove)\nusing this:\n  cycle_free M' n \\<Longrightarrow> canonical (FW M' n) n\n  (\\<forall>i xs.\n      i \\<le> ?n \\<and> set xs \\<subseteq> {0..?n} \\<longrightarrow>\n      \\<one> \\<le> len ?M i i xs) =\n  cycle_free ?M ?n\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M' i i xs\n\ngoal (1 subgoal):\n 1. canonical (FW M' n) n", "by blast"], ["proof (state)\nthis:\n  canonical (FW M' n) n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i xs.\n                i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n                \\<one> \\<le> len M i i xs;\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "from FW_fixed_preservation[OF _ _ this FW_cyc_free_preservation[OF M'(3)]] M'_fixed"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i \\<le> n; M' 0 ?i + M' ?i 0 = \\<one>\\<rbrakk>\n  \\<Longrightarrow> FW M' n 0 ?i + FW M' n ?i 0 = \\<one>\n  \\<forall>i\\<le>n. i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>", "have fixed: \"\\<forall>i\\<le>n. i \\<noteq> 0 \\<longrightarrow> ?M' 0 i + ?M' i 0 = \\<one>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<le> n; M' 0 ?i + M' ?i 0 = \\<one>\\<rbrakk>\n  \\<Longrightarrow> FW M' n 0 ?i + FW M' n ?i 0 = \\<one>\n  \\<forall>i\\<le>n. i \\<noteq> 0 \\<longrightarrow> M' 0 i + M' i 0 = \\<one>\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>n.\n       i \\<noteq> 0 \\<longrightarrow> FW M' n 0 i + FW M' n i 0 = \\<one>", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n.\n     i \\<noteq> 0 \\<longrightarrow> FW M' n 0 i + FW M' n i 0 = \\<one>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i xs.\n                i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n                \\<one> \\<le> len M i i xs;\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "have *: \"\\<And>i. i \\<le> n \\<Longrightarrow> i \\<noteq> 0 \\<Longrightarrow> \\<exists> d. ?M' 0 i = Le (-d) \\<and> ?M' i 0 = Le d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n; i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            FW M' n 0 i = Le (- d) \\<and> FW M' n i 0 = Le d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n; i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            FW M' n 0 i = Le (- d) \\<and> FW M' n i 0 = Le d", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n; i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            FW M' n 0 i = Le (- d) \\<and> FW M' n i 0 = Le d", "assume i: \"i \\<le> n\" \"i \\<noteq> 0\""], ["proof (state)\nthis:\n  i \\<le> n\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n; i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            FW M' n 0 i = Le (- d) \\<and> FW M' n i 0 = Le d", "from i fixed"], ["proof (chain)\npicking this:\n  i \\<le> n\n  i \\<noteq> 0\n  \\<forall>i\\<le>n.\n     i \\<noteq> 0 \\<longrightarrow> FW M' n 0 i + FW M' n i 0 = \\<one>", "have *:\"dbm_add (?M' 0 i) (?M' i 0) = Le 0\""], ["proof (prove)\nusing this:\n  i \\<le> n\n  i \\<noteq> 0\n  \\<forall>i\\<le>n.\n     i \\<noteq> 0 \\<longrightarrow> FW M' n 0 i + FW M' n i 0 = \\<one>\n\ngoal (1 subgoal):\n 1. dbm_add (FW M' n 0 i) (FW M' n i 0) = Le (0::'a)", "by (auto simp add: mult neutral)"], ["proof (state)\nthis:\n  dbm_add (FW M' n 0 i) (FW M' n i 0) = Le (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n; i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            FW M' n 0 i = Le (- d) \\<and> FW M' n i 0 = Le d", "moreover"], ["proof (state)\nthis:\n  dbm_add (FW M' n 0 i) (FW M' n i 0) = Le (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n; i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            FW M' n 0 i = Le (- d) \\<and> FW M' n i 0 = Le d", "{"], ["proof (state)\nthis:\n  dbm_add (FW M' n 0 i) (FW M' n i 0) = Le (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n; i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            FW M' n 0 i = Le (- d) \\<and> FW M' n i 0 = Le d", "fix a b :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n; i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            FW M' n 0 i = Le (- d) \\<and> FW M' n i 0 = Le d", "assume \"a + b = 0\""], ["proof (state)\nthis:\n  a + b = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n; i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            FW M' n 0 i = Le (- d) \\<and> FW M' n i 0 = Le d", "then"], ["proof (chain)\npicking this:\n  a + b = (0::'a)", "have \"a = -b\""], ["proof (prove)\nusing this:\n  a + b = (0::'a)\n\ngoal (1 subgoal):\n 1. a = - b", "by (simp add: eq_neg_iff_add_eq_0)"], ["proof (state)\nthis:\n  a = - b\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n; i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            FW M' n 0 i = Le (- d) \\<and> FW M' n i 0 = Le d", "}"], ["proof (state)\nthis:\n  ?a2 + ?b2 = (0::'a) \\<Longrightarrow> ?a2 = - ?b2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> n; i \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            FW M' n 0 i = Le (- d) \\<and> FW M' n i 0 = Le d", "ultimately"], ["proof (chain)\npicking this:\n  dbm_add (FW M' n 0 i) (FW M' n i 0) = Le (0::'a)\n  ?a2 + ?b2 = (0::'a) \\<Longrightarrow> ?a2 = - ?b2", "show \"\\<exists>d. ?M' 0 i = Le (-d) \\<and> ?M' i 0 = Le d\""], ["proof (prove)\nusing this:\n  dbm_add (FW M' n 0 i) (FW M' n i 0) = Le (0::'a)\n  ?a2 + ?b2 = (0::'a) \\<Longrightarrow> ?a2 = - ?b2\n\ngoal (1 subgoal):\n 1. \\<exists>d. FW M' n 0 i = Le (- d) \\<and> FW M' n i 0 = Le d", "by (cases \"?M' 0 i\"; cases \"?M' i 0\"; simp)"], ["proof (state)\nthis:\n  \\<exists>d. FW M' n 0 i = Le (- d) \\<and> FW M' n i 0 = Le d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i \\<le> n; ?i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>d.\n                       FW M' n 0 ?i = Le (- d) \\<and> FW M' n ?i 0 = Le d\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i xs.\n                i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n                \\<one> \\<le> len M i i xs;\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?i \\<le> n; ?i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>d.\n                       FW M' n 0 ?i = Le (- d) \\<and> FW M' n ?i 0 = Le d", "obtain f where f: \"\\<forall> i\\<le>n. i \\<noteq> 0 \\<longrightarrow> Le (f i) = ?M' i 0 \\<and> Le (- f i) = ?M' 0 i\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?i \\<le> n; ?i \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<exists>d.\n                       FW M' n 0 ?i = Le (- d) \\<and> FW M' n ?i 0 = Le d\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<forall>i\\<le>n.\n           i \\<noteq> 0 \\<longrightarrow>\n           Le (f i) = FW M' n i 0 \\<and>\n           Le (- f i) = FW M' n 0 i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n.\n     i \\<noteq> 0 \\<longrightarrow>\n     Le (f i) = FW M' n i 0 \\<and> Le (- f i) = FW M' n 0 i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i xs.\n                i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n                \\<one> \\<le> len M i i xs;\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "let ?u = \"\\<lambda> c. f (v c)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i xs.\n                i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n                \\<one> \\<le> len M i i xs;\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "have \"DBM_val_bounded v ?u ?M' n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>c. f (v c) \\<turnstile>\\<^bsub>v,n\\<^esub> FW M' n", "proof (auto simp add: DBM_val_bounded_def, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. Le (0::'a) \\<preceq> FW M' n 0 0\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) None (Some c) (FW M' n 0 (v c))\n 3. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) (Some c) None (FW M' n (v c) 0)\n 4. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. Le (0::'a) \\<preceq> FW M' n 0 0\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) None (Some c) (FW M' n 0 (v c))\n 3. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) (Some c) None (FW M' n (v c) 0)\n 4. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "from cyc_free_diag_dest'[OF FW_cyc_free_preservation[OF M'(3)]]"], ["proof (chain)\npicking this:\n  ?i \\<le> n \\<Longrightarrow> \\<one> \\<le> FW M' n ?i ?i", "show ?case"], ["proof (prove)\nusing this:\n  ?i \\<le> n \\<Longrightarrow> \\<one> \\<le> FW M' n ?i ?i\n\ngoal (1 subgoal):\n 1. Le (0::'a) \\<preceq> FW M' n 0 0", "unfolding neutral less_eq"], ["proof (prove)\nusing this:\n  ?i \\<le> n \\<Longrightarrow> Le (0::'a) \\<preceq> FW M' n ?i ?i\n\ngoal (1 subgoal):\n 1. Le (0::'a) \\<preceq> FW M' n 0 0", "by fast"], ["proof (state)\nthis:\n  Le (0::'a) \\<preceq> FW M' n 0 0\n\ngoal (3 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) None (Some c) (FW M' n 0 (v c))\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) (Some c) None (FW M' n (v c) 0)\n 3. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) None (Some c) (FW M' n 0 (v c))\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) (Some c) None (FW M' n (v c) 0)\n 3. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "case (2 c)"], ["proof (state)\nthis:\n  v c \\<le> n\n\ngoal (3 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) None (Some c) (FW M' n 0 (v c))\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) (Some c) None (FW M' n (v c) 0)\n 3. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "with A(2)"], ["proof (chain)\npicking this:\n  \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\n  v c \\<le> n", "have **: \"v c > 0\""], ["proof (prove)\nusing this:\n  \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\n  v c \\<le> n\n\ngoal (1 subgoal):\n 1. 0 < v c", "by auto"], ["proof (state)\nthis:\n  0 < v c\n\ngoal (3 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) None (Some c) (FW M' n 0 (v c))\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) (Some c) None (FW M' n (v c) 0)\n 3. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "with *[OF 2]"], ["proof (chain)\npicking this:\n  v c \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>d. FW M' n 0 (v c) = Le (- d) \\<and> FW M' n (v c) 0 = Le d\n  0 < v c", "obtain d where d: \"Le (-d) = ?M' 0 (v c)\""], ["proof (prove)\nusing this:\n  v c \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>d. FW M' n 0 (v c) = Le (- d) \\<and> FW M' n (v c) 0 = Le d\n  0 < v c\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        Le (- d) = FW M' n 0 (v c) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Le (- d) = FW M' n 0 (v c)\n\ngoal (3 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) None (Some c) (FW M' n 0 (v c))\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) (Some c) None (FW M' n (v c) 0)\n 3. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "with f 2 **"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>n.\n     i \\<noteq> 0 \\<longrightarrow>\n     Le (f i) = FW M' n i 0 \\<and> Le (- f i) = FW M' n 0 i\n  v c \\<le> n\n  0 < v c\n  Le (- d) = FW M' n 0 (v c)", "have \"Le (- f (v c)) = Le (- d)\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n.\n     i \\<noteq> 0 \\<longrightarrow>\n     Le (f i) = FW M' n i 0 \\<and> Le (- f i) = FW M' n 0 i\n  v c \\<le> n\n  0 < v c\n  Le (- d) = FW M' n 0 (v c)\n\ngoal (1 subgoal):\n 1. Le (- f (v c)) = Le (- d)", "by simp"], ["proof (state)\nthis:\n  Le (- f (v c)) = Le (- d)\n\ngoal (3 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) None (Some c) (FW M' n 0 (v c))\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) (Some c) None (FW M' n (v c) 0)\n 3. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "then"], ["proof (chain)\npicking this:\n  Le (- f (v c)) = Le (- d)", "have \"- f (v c) \\<le> - d\""], ["proof (prove)\nusing this:\n  Le (- f (v c)) = Le (- d)\n\ngoal (1 subgoal):\n 1. - f (v c) \\<le> - d", "by auto"], ["proof (state)\nthis:\n  - f (v c) \\<le> - d\n\ngoal (3 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) None (Some c) (FW M' n 0 (v c))\n 2. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) (Some c) None (FW M' n (v c) 0)\n 3. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "from dbm_entry_val.intros(2)[of ?u , OF this] d"], ["proof (chain)\npicking this:\n  dbm_entry_val (\\<lambda>c. f (v c)) None (Some c) (Le (- d))\n  Le (- d) = FW M' n 0 (v c)", "show ?case"], ["proof (prove)\nusing this:\n  dbm_entry_val (\\<lambda>c. f (v c)) None (Some c) (Le (- d))\n  Le (- d) = FW M' n 0 (v c)\n\ngoal (1 subgoal):\n 1. dbm_entry_val (\\<lambda>c. f (v c)) None (Some c) (FW M' n 0 (v c))", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val (\\<lambda>c. f (v c)) None (Some c) (FW M' n 0 (v c))\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) (Some c) None (FW M' n (v c) 0)\n 2. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) (Some c) None (FW M' n (v c) 0)\n 2. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "case (3 c)"], ["proof (state)\nthis:\n  v c \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) (Some c) None (FW M' n (v c) 0)\n 2. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "with A(2)"], ["proof (chain)\npicking this:\n  \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\n  v c \\<le> n", "have **: \"v c > 0\""], ["proof (prove)\nusing this:\n  \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\n  v c \\<le> n\n\ngoal (1 subgoal):\n 1. 0 < v c", "by auto"], ["proof (state)\nthis:\n  0 < v c\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) (Some c) None (FW M' n (v c) 0)\n 2. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "with *[OF 3]"], ["proof (chain)\npicking this:\n  v c \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>d. FW M' n 0 (v c) = Le (- d) \\<and> FW M' n (v c) 0 = Le d\n  0 < v c", "obtain d where d: \"Le d = ?M' (v c) 0\""], ["proof (prove)\nusing this:\n  v c \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>d. FW M' n 0 (v c) = Le (- d) \\<and> FW M' n (v c) 0 = Le d\n  0 < v c\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        Le d = FW M' n (v c) 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Le d = FW M' n (v c) 0\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) (Some c) None (FW M' n (v c) 0)\n 2. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "with f 3 **"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>n.\n     i \\<noteq> 0 \\<longrightarrow>\n     Le (f i) = FW M' n i 0 \\<and> Le (- f i) = FW M' n 0 i\n  v c \\<le> n\n  0 < v c\n  Le d = FW M' n (v c) 0", "have \"Le (f (v c)) = Le d\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n.\n     i \\<noteq> 0 \\<longrightarrow>\n     Le (f i) = FW M' n i 0 \\<and> Le (- f i) = FW M' n 0 i\n  v c \\<le> n\n  0 < v c\n  Le d = FW M' n (v c) 0\n\ngoal (1 subgoal):\n 1. Le (f (v c)) = Le d", "by simp"], ["proof (state)\nthis:\n  Le (f (v c)) = Le d\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) (Some c) None (FW M' n (v c) 0)\n 2. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "then"], ["proof (chain)\npicking this:\n  Le (f (v c)) = Le d", "have \"f (v c) \\<le> d\""], ["proof (prove)\nusing this:\n  Le (f (v c)) = Le d\n\ngoal (1 subgoal):\n 1. f (v c) \\<le> d", "by auto"], ["proof (state)\nthis:\n  f (v c) \\<le> d\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       v c \\<le> n \\<Longrightarrow>\n       dbm_entry_val (\\<lambda>c. f (v c)) (Some c) None (FW M' n (v c) 0)\n 2. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "from dbm_entry_val.intros(1)[of ?u, OF this] d"], ["proof (chain)\npicking this:\n  dbm_entry_val (\\<lambda>c. f (v c)) (Some c) None (Le d)\n  Le d = FW M' n (v c) 0", "show ?case"], ["proof (prove)\nusing this:\n  dbm_entry_val (\\<lambda>c. f (v c)) (Some c) None (Le d)\n  Le d = FW M' n (v c) 0\n\ngoal (1 subgoal):\n 1. dbm_entry_val (\\<lambda>c. f (v c)) (Some c) None (FW M' n (v c) 0)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val (\\<lambda>c. f (v c)) (Some c) None (FW M' n (v c) 0)\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "case (4 c1 c2)"], ["proof (state)\nthis:\n  v c1 \\<le> n\n  v c2 \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "with A(2)"], ["proof (chain)\npicking this:\n  \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\n  v c1 \\<le> n\n  v c2 \\<le> n", "have **: \"v c1 > 0\" \"v c2 > 0\""], ["proof (prove)\nusing this:\n  \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\n  v c1 \\<le> n\n  v c2 \\<le> n\n\ngoal (1 subgoal):\n 1. 0 < v c1 &&& 0 < v c2", "by auto"], ["proof (state)\nthis:\n  0 < v c1\n  0 < v c2\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "with *[OF 4(1)]"], ["proof (chain)\npicking this:\n  v c1 \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>d. FW M' n 0 (v c1) = Le (- d) \\<and> FW M' n (v c1) 0 = Le d\n  0 < v c1\n  0 < v c2", "obtain d1 where d1: \"Le d1 = ?M' (v c1) 0\""], ["proof (prove)\nusing this:\n  v c1 \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>d. FW M' n 0 (v c1) = Le (- d) \\<and> FW M' n (v c1) 0 = Le d\n  0 < v c1\n  0 < v c2\n\ngoal (1 subgoal):\n 1. (\\<And>d1.\n        Le d1 = FW M' n (v c1) 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Le d1 = FW M' n (v c1) 0\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "with f 4 **"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>n.\n     i \\<noteq> 0 \\<longrightarrow>\n     Le (f i) = FW M' n i 0 \\<and> Le (- f i) = FW M' n 0 i\n  v c1 \\<le> n\n  v c2 \\<le> n\n  0 < v c1\n  0 < v c2\n  Le d1 = FW M' n (v c1) 0", "have \"Le (f (v c1)) = Le d1\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n.\n     i \\<noteq> 0 \\<longrightarrow>\n     Le (f i) = FW M' n i 0 \\<and> Le (- f i) = FW M' n 0 i\n  v c1 \\<le> n\n  v c2 \\<le> n\n  0 < v c1\n  0 < v c2\n  Le d1 = FW M' n (v c1) 0\n\ngoal (1 subgoal):\n 1. Le (f (v c1)) = Le d1", "by simp"], ["proof (state)\nthis:\n  Le (f (v c1)) = Le d1\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "then"], ["proof (chain)\npicking this:\n  Le (f (v c1)) = Le d1", "have d1': \"f (v c1) = d1\""], ["proof (prove)\nusing this:\n  Le (f (v c1)) = Le d1\n\ngoal (1 subgoal):\n 1. f (v c1) = d1", "by auto"], ["proof (state)\nthis:\n  f (v c1) = d1\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "from *[OF 4(2)] **"], ["proof (chain)\npicking this:\n  v c2 \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>d. FW M' n 0 (v c2) = Le (- d) \\<and> FW M' n (v c2) 0 = Le d\n  0 < v c1\n  0 < v c2", "obtain d2 where d2: \"Le d2 = ?M' (v c2) 0\""], ["proof (prove)\nusing this:\n  v c2 \\<noteq> 0 \\<Longrightarrow>\n  \\<exists>d. FW M' n 0 (v c2) = Le (- d) \\<and> FW M' n (v c2) 0 = Le d\n  0 < v c1\n  0 < v c2\n\ngoal (1 subgoal):\n 1. (\\<And>d2.\n        Le d2 = FW M' n (v c2) 0 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Le d2 = FW M' n (v c2) 0\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "with f 4 **"], ["proof (chain)\npicking this:\n  \\<forall>i\\<le>n.\n     i \\<noteq> 0 \\<longrightarrow>\n     Le (f i) = FW M' n i 0 \\<and> Le (- f i) = FW M' n 0 i\n  v c1 \\<le> n\n  v c2 \\<le> n\n  0 < v c1\n  0 < v c2\n  Le d2 = FW M' n (v c2) 0", "have \"Le (f (v c2)) = Le d2\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<le>n.\n     i \\<noteq> 0 \\<longrightarrow>\n     Le (f i) = FW M' n i 0 \\<and> Le (- f i) = FW M' n 0 i\n  v c1 \\<le> n\n  v c2 \\<le> n\n  0 < v c1\n  0 < v c2\n  Le d2 = FW M' n (v c2) 0\n\ngoal (1 subgoal):\n 1. Le (f (v c2)) = Le d2", "by simp"], ["proof (state)\nthis:\n  Le (f (v c2)) = Le d2\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "then"], ["proof (chain)\npicking this:\n  Le (f (v c2)) = Le d2", "have d2': \"f (v c2) = d2\""], ["proof (prove)\nusing this:\n  Le (f (v c2)) = Le d2\n\ngoal (1 subgoal):\n 1. f (v c2) = d2", "by auto"], ["proof (state)\nthis:\n  f (v c2) = d2\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "have \"Le d1 \\<le> ?M' (v c1) (v c2) + Le d2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Le d1 \\<le> FW M' n (v c1) (v c2) + Le d2", "using \\<open>canonical ?M' n\\<close> 4 d1 d2"], ["proof (prove)\nusing this:\n  canonical (FW M' n) n\n  v c1 \\<le> n\n  v c2 \\<le> n\n  Le d1 = FW M' n (v c1) 0\n  Le d2 = FW M' n (v c2) 0\n\ngoal (1 subgoal):\n 1. Le d1 \\<le> FW M' n (v c1) (v c2) + Le d2", "by (auto simp add: less_eq mult)"], ["proof (state)\nthis:\n  Le d1 \\<le> FW M' n (v c1) (v c2) + Le d2\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (FW M' n (v c1) (v c2))", "then"], ["proof (chain)\npicking this:\n  Le d1 \\<le> FW M' n (v c1) (v c2) + Le d2", "show ?case"], ["proof (prove)\nusing this:\n  Le d1 \\<le> FW M' n (v c1) (v c2) + Le d2\n\ngoal (1 subgoal):\n 1. dbm_entry_val (\\<lambda>c. f (v c)) (Some c1) (Some c2)\n     (FW M' n (v c1) (v c2))", "proof (cases \"?M' (v c1) (v c2)\", auto, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Le d1 \\<le> Le x1 + Le d2;\n        FW M' n (v c1) (v c2) = Le x1\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (Le x1)\n 2. \\<And>x2.\n       \\<lbrakk>Le d1 \\<le> Lt x2 + Le d2;\n        FW M' n (v c1) (v c2) = Lt x2\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (Lt x2)", "case (1 d)"], ["proof (state)\nthis:\n  Le d1 \\<le> Le d + Le d2\n  FW M' n (v c1) (v c2) = Le d\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Le d1 \\<le> Le x1 + Le d2;\n        FW M' n (v c1) (v c2) = Le x1\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (Le x1)\n 2. \\<And>x2.\n       \\<lbrakk>Le d1 \\<le> Lt x2 + Le d2;\n        FW M' n (v c1) (v c2) = Lt x2\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (Lt x2)", "from this(1)"], ["proof (chain)\npicking this:\n  Le d1 \\<le> Le d + Le d2", "have \"d1 \\<le> d + d2\""], ["proof (prove)\nusing this:\n  Le d1 \\<le> Le d + Le d2\n\ngoal (1 subgoal):\n 1. d1 \\<le> d + d2", "by (auto simp: mult less_eq le_dbm_le)"], ["proof (state)\nthis:\n  d1 \\<le> d + d2\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Le d1 \\<le> Le x1 + Le d2;\n        FW M' n (v c1) (v c2) = Le x1\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (Le x1)\n 2. \\<And>x2.\n       \\<lbrakk>Le d1 \\<le> Lt x2 + Le d2;\n        FW M' n (v c1) (v c2) = Lt x2\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (Lt x2)", "then"], ["proof (chain)\npicking this:\n  d1 \\<le> d + d2", "have \"d1 - d2 \\<le> d\""], ["proof (prove)\nusing this:\n  d1 \\<le> d + d2\n\ngoal (1 subgoal):\n 1. d1 - d2 \\<le> d", "by (simp add: diff_le_eq)"], ["proof (state)\nthis:\n  d1 - d2 \\<le> d\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>Le d1 \\<le> Le x1 + Le d2;\n        FW M' n (v c1) (v c2) = Le x1\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (Le x1)\n 2. \\<And>x2.\n       \\<lbrakk>Le d1 \\<le> Lt x2 + Le d2;\n        FW M' n (v c1) (v c2) = Lt x2\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (Lt x2)", "then"], ["proof (chain)\npicking this:\n  d1 - d2 \\<le> d", "show ?case"], ["proof (prove)\nusing this:\n  d1 - d2 \\<le> d\n\ngoal (1 subgoal):\n 1. dbm_entry_val (\\<lambda>c. f (v c)) (Some c1) (Some c2) (Le d)", "using d1' d2'"], ["proof (prove)\nusing this:\n  d1 - d2 \\<le> d\n  f (v c1) = d1\n  f (v c2) = d2\n\ngoal (1 subgoal):\n 1. dbm_entry_val (\\<lambda>c. f (v c)) (Some c1) (Some c2) (Le d)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val (\\<lambda>c. f (v c)) (Some c1) (Some c2) (Le d)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>Le d1 \\<le> Lt x2 + Le d2;\n        FW M' n (v c1) (v c2) = Lt x2\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (Lt x2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>Le d1 \\<le> Lt x2 + Le d2;\n        FW M' n (v c1) (v c2) = Lt x2\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (Lt x2)", "case (2 d)"], ["proof (state)\nthis:\n  Le d1 \\<le> Lt d + Le d2\n  FW M' n (v c1) (v c2) = Lt d\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>Le d1 \\<le> Lt x2 + Le d2;\n        FW M' n (v c1) (v c2) = Lt x2\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (Lt x2)", "from this(1)"], ["proof (chain)\npicking this:\n  Le d1 \\<le> Lt d + Le d2", "have \"d1 < d + d2\""], ["proof (prove)\nusing this:\n  Le d1 \\<le> Lt d + Le d2\n\ngoal (1 subgoal):\n 1. d1 < d + d2", "by (auto simp: mult less_eq dbm_le_def elim: dbm_lt.cases)"], ["proof (state)\nthis:\n  d1 < d + d2\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>Le d1 \\<le> Lt x2 + Le d2;\n        FW M' n (v c1) (v c2) = Lt x2\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (Lt x2)", "then"], ["proof (chain)\npicking this:\n  d1 < d + d2", "have \"d1 - d2 < d\""], ["proof (prove)\nusing this:\n  d1 < d + d2\n\ngoal (1 subgoal):\n 1. d1 - d2 < d", "using diff_less_eq"], ["proof (prove)\nusing this:\n  d1 < d + d2\n  (?a - ?b < ?c) = (?a < ?c + ?b)\n\ngoal (1 subgoal):\n 1. d1 - d2 < d", "by blast"], ["proof (state)\nthis:\n  d1 - d2 < d\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<lbrakk>Le d1 \\<le> Lt x2 + Le d2;\n        FW M' n (v c1) (v c2) = Lt x2\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val (\\<lambda>c. f (v c)) (Some c1)\n                          (Some c2) (Lt x2)", "then"], ["proof (chain)\npicking this:\n  d1 - d2 < d", "show ?case"], ["proof (prove)\nusing this:\n  d1 - d2 < d\n\ngoal (1 subgoal):\n 1. dbm_entry_val (\\<lambda>c. f (v c)) (Some c1) (Some c2) (Lt d)", "using d1' d2'"], ["proof (prove)\nusing this:\n  d1 - d2 < d\n  f (v c1) = d1\n  f (v c2) = d2\n\ngoal (1 subgoal):\n 1. dbm_entry_val (\\<lambda>c. f (v c)) (Some c1) (Some c2) (Lt d)", "by auto"], ["proof (state)\nthis:\n  dbm_entry_val (\\<lambda>c. f (v c)) (Some c1) (Some c2) (Lt d)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dbm_entry_val (\\<lambda>c. f (v c)) (Some c1) (Some c2)\n   (FW M' n (v c1) (v c2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lambda>c. f (v c) \\<turnstile>\\<^bsub>v,n\\<^esub> FW M' n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i xs.\n                i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n                \\<one> \\<le> len M i i xs;\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "from M'(1) FW_not_empty[OF this]"], ["proof (chain)\npicking this:\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M n)\n  \\<lambda>c. f (v c) \\<turnstile>\\<^bsub>v,n\\<^esub> M'", "obtain u where \"DBM_val_bounded v u ?M n\""], ["proof (prove)\nusing this:\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M') \\<longrightarrow>\n  (\\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M n)\n  \\<lambda>c. f (v c) \\<turnstile>\\<^bsub>v,n\\<^esub> M'\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M n\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>i xs.\n                i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n                \\<one> \\<le> len M i i xs;\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "from FW_not_empty[OF this]"], ["proof (chain)\npicking this:\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "show ?thesis"], ["proof (prove)\nusing this:\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> M\n\ngoal (1 subgoal):\n 1. \\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M", "by auto"], ["proof (state)\nthis:\n  \\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Floyd-Warshall and Empty DBMs\\<close>"], ["", "theorem FW_detects_empty_zone:\n  \"\\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k) \\<Longrightarrow> \\<forall> c. v c \\<le> n \\<longrightarrow> v c > 0\n  \\<Longrightarrow> [FW M n]\\<^bsub>v,n\\<^esub> = {} \\<longleftrightarrow> (\\<exists> i\\<le>n. (FW M n) i i < Le 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>k\\<le>n.\n                0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\\<rbrakk>\n    \\<Longrightarrow> ([FW M n]\\<^bsub>v,n\\<^esub> = {}) =\n                      (\\<exists>i\\<le>n. FW M n i i < Le (0::'b))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>k\\<le>n.\n                0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c;\n     [FW M n]\\<^bsub>v,n\\<^esub> = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i\\<le>n. FW M n i i < Le (0::'b)\n 2. \\<lbrakk>\\<forall>k\\<le>n.\n                0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c;\n     \\<exists>i\\<le>n. FW M n i i < Le (0::'b)\\<rbrakk>\n    \\<Longrightarrow> [FW M n]\\<^bsub>v,n\\<^esub> = {}", "assume surj_on:\"\\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\" and \"\\<exists>i\\<le>n. (FW M n) i i < Le 0\""], ["proof (state)\nthis:\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\n  \\<exists>i\\<le>n. FW M n i i < Le (0::'b)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>k\\<le>n.\n                0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c;\n     [FW M n]\\<^bsub>v,n\\<^esub> = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i\\<le>n. FW M n i i < Le (0::'b)\n 2. \\<lbrakk>\\<forall>k\\<le>n.\n                0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c;\n     \\<exists>i\\<le>n. FW M n i i < Le (0::'b)\\<rbrakk>\n    \\<Longrightarrow> [FW M n]\\<^bsub>v,n\\<^esub> = {}", "then"], ["proof (chain)\npicking this:\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\n  \\<exists>i\\<le>n. FW M n i i < Le (0::'b)", "obtain i where *: \"len (FW M n) i i [] < \\<one>\" \"i \\<le>n\""], ["proof (prove)\nusing this:\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\n  \\<exists>i\\<le>n. FW M n i i < Le (0::'b)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>len (FW M n) i i [] < \\<one>; i \\<le> n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: neutral)"], ["proof (state)\nthis:\n  len (FW M n) i i [] < \\<one>\n  i \\<le> n\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>k\\<le>n.\n                0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c;\n     [FW M n]\\<^bsub>v,n\\<^esub> = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i\\<le>n. FW M n i i < Le (0::'b)\n 2. \\<lbrakk>\\<forall>k\\<le>n.\n                0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c;\n     \\<exists>i\\<le>n. FW M n i i < Le (0::'b)\\<rbrakk>\n    \\<Longrightarrow> [FW M n]\\<^bsub>v,n\\<^esub> = {}", "show \"[FW M n]\\<^bsub>v,n\\<^esub> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [FW M n]\\<^bsub>v,n\\<^esub> = {}", "proof (rule ccontr, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. [FW M n]\\<^bsub>v,n\\<^esub> \\<noteq> {} \\<Longrightarrow> False", "case 1"], ["proof (state)\nthis:\n  [FW M n]\\<^bsub>v,n\\<^esub> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. [FW M n]\\<^bsub>v,n\\<^esub> \\<noteq> {} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  [FW M n]\\<^bsub>v,n\\<^esub> \\<noteq> {}", "obtain u where \"DBM_val_bounded v u (FW M n) n\""], ["proof (prove)\nusing this:\n  [FW M n]\\<^bsub>v,n\\<^esub> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding DBM_zone_repr_def"], ["proof (prove)\nusing this:\n  {u. u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M n} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M n\n\ngoal (1 subgoal):\n 1. [FW M n]\\<^bsub>v,n\\<^esub> \\<noteq> {} \\<Longrightarrow> False", "from DBM_val_bounded_neg_cycle[OF this *(2) _ *(1) surj_on]"], ["proof (chain)\npicking this:\n  set [] \\<subseteq> {0..n} \\<Longrightarrow> False", "show ?case"], ["proof (prove)\nusing this:\n  set [] \\<subseteq> {0..n} \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [FW M n]\\<^bsub>v,n\\<^esub> = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>k\\<le>n.\n                0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c;\n     [FW M n]\\<^bsub>v,n\\<^esub> = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i\\<le>n. FW M n i i < Le (0::'b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>k\\<le>n.\n                0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c;\n     [FW M n]\\<^bsub>v,n\\<^esub> = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i\\<le>n. FW M n i i < Le (0::'b)", "assume surj_on: \"\\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\" and empty: \"[FW M n]\\<^bsub>v,n\\<^esub> = {}\"\n  and    cn: \"\\<forall> c. v c \\<le> n \\<longrightarrow> v c > 0\""], ["proof (state)\nthis:\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\n  [FW M n]\\<^bsub>v,n\\<^esub> = {}\n  \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>k\\<le>n.\n                0 < k \\<longrightarrow> (\\<exists>c. v c = k);\n     \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c;\n     [FW M n]\\<^bsub>v,n\\<^esub> = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>i\\<le>n. FW M n i i < Le (0::'b)", "show \"\\<exists> i\\<le>n. (FW M n) i i < Le 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i\\<le>n. FW M n i i < Le (0::'b)", "proof (rule ccontr, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<le>n. FW M n i i < Le (0::'b)) \\<Longrightarrow>\n    False", "case 1"], ["proof (state)\nthis:\n  \\<not> (\\<exists>i\\<le>n. FW M n i i < Le (0::'b))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<le>n. FW M n i i < Le (0::'b)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>i\\<le>n. FW M n i i < Le (0::'b))", "have *:\"\\<forall>i\\<le>n. FW M n i i \\<ge> \\<one>\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>i\\<le>n. FW M n i i < Le (0::'b))\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<le>n. \\<one> \\<le> FW M n i i", "by (auto simp add: neutral)"], ["proof (state)\nthis:\n  \\<forall>i\\<le>n. \\<one> \\<le> FW M n i i\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<le>n. FW M n i i < Le (0::'b)) \\<Longrightarrow>\n    False", "have \"cyc_free M n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i xs.\n       i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n       \\<one> \\<le> len M i i xs", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i xs.\n               i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n               \\<one> \\<le> len M i i xs) \\<Longrightarrow>\n    False", "assume \"\\<not> cyc_free M n\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>i xs.\n             i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n             \\<one> \\<le> len M i i xs)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i xs.\n               i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n               \\<one> \\<le> len M i i xs) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>i xs.\n             i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n             \\<one> \\<le> len M i i xs)", "have A: \"\\<not> cycle_free M n\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i xs.\n             i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n             \\<one> \\<le> len M i i xs)\n\ngoal (1 subgoal):\n 1. \\<not> cycle_free M n", "using cycle_free_diag_equiv"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i xs.\n             i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n             \\<one> \\<le> len M i i xs)\n  (\\<forall>i xs.\n      i \\<le> ?n \\<and> set xs \\<subseteq> {0..?n} \\<longrightarrow>\n      \\<one> \\<le> len ?M i i xs) =\n  cycle_free ?M ?n\n\ngoal (1 subgoal):\n 1. \\<not> cycle_free M n", "by auto"], ["proof (state)\nthis:\n  \\<not> cycle_free M n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i xs.\n               i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n               \\<one> \\<le> len M i i xs) \\<Longrightarrow>\n    False", "from FW_neg_cycle_detect[OF A] *"], ["proof (chain)\npicking this:\n  \\<exists>i\\<le>n. FW M n i i < \\<one>\n  \\<forall>i\\<le>n. \\<one> \\<le> FW M n i i", "show False"], ["proof (prove)\nusing this:\n  \\<exists>i\\<le>n. FW M n i i < \\<one>\n  \\<forall>i\\<le>n. \\<one> \\<le> FW M n i i\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len M i i xs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<le>n. FW M n i i < Le (0::'b)) \\<Longrightarrow>\n    False", "from FW_cyc_free_preservation[OF this]"], ["proof (chain)\npicking this:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len (FW M n) i i xs", "have \"cyc_free (FW M n) n\""], ["proof (prove)\nusing this:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len (FW M n) i i xs\n\ngoal (1 subgoal):\n 1. \\<forall>i xs.\n       i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n       \\<one> \\<le> len (FW M n) i i xs", "."], ["proof (state)\nthis:\n  \\<forall>i xs.\n     i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n     \\<one> \\<le> len (FW M n) i i xs\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<le>n. FW M n i i < Le (0::'b)) \\<Longrightarrow>\n    False", "from cyc_free_obtains_valuation[OF \\<open>cyc_free (FW M n) n\\<close> cn] empty"], ["proof (chain)\npicking this:\n  \\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M n\n  [FW M n]\\<^bsub>v,n\\<^esub> = {}", "obtain u where \"DBM_val_bounded v u (FW M n) n\""], ["proof (prove)\nusing this:\n  \\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M n\n  [FW M n]\\<^bsub>v,n\\<^esub> = {}\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M n\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>i\\<le>n. FW M n i i < Le (0::'b)) \\<Longrightarrow>\n    False", "with empty"], ["proof (chain)\npicking this:\n  [FW M n]\\<^bsub>v,n\\<^esub> = {}\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M n", "show ?case"], ["proof (prove)\nusing this:\n  [FW M n]\\<^bsub>v,n\\<^esub> = {}\n  u \\<turnstile>\\<^bsub>v,n\\<^esub> FW M n\n\ngoal (1 subgoal):\n 1. False", "by (auto simp add: DBM_zone_repr_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i\\<le>n. FW M n i i < Le (0::'b)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* This definition is \"internal\" to the theorems for the correctness of the Floyd-Warshall algorithm\n   and we want to reuse this as a variable name, so we hide it away *)"], ["", "hide_const D"], ["", "subsection \\<open>Mixed Corollaries\\<close>"], ["", "lemma cyc_free_not_empty:\n  assumes \"cyc_free M n\" \"\\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\"\n  shows \"[(M :: ('a :: time) DBM)]\\<^bsub>v,n\\<^esub> \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<noteq> {}", "using cyc_free_obtains_valuation[OF assms(1,2)]"], ["proof (prove)\nusing this:\n  \\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> \\<noteq> {}", "unfolding DBM_zone_repr_def"], ["proof (prove)\nusing this:\n  \\<exists>u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M\n\ngoal (1 subgoal):\n 1. {u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M} \\<noteq> {}", "by auto"], ["", "lemma empty_not_cyc_free:\n  assumes \"\\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\" \"[(M :: ('a :: time) DBM)]\\<^bsub>v,n\\<^esub> = {}\"\n  shows \"\\<not> cyc_free M n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i xs.\n               i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n               \\<one> \\<le> len M i i xs)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\n  [M]\\<^bsub>v,n\\<^esub> = {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i xs.\n               i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n               \\<one> \\<le> len M i i xs)", "by (meson cyc_free_not_empty)"], ["", "lemma not_empty_cyc_free:\n  assumes \"\\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists> c. v c = k)\" \"[(M :: ('a :: time) DBM)]\\<^bsub>v,n\\<^esub> \\<noteq> {}\"\n  shows \"cyc_free M n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i xs.\n       i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n       \\<one> \\<le> len M i i xs", "using DBM_val_bounded_neg_cycle[OF _ _ _ _ assms(1)] assms(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<turnstile>\\<^bsub>v,n\\<^esub> ?M; ?i \\<le> n;\n   set ?xs \\<subseteq> {0..n}; len ?M ?i ?i ?xs < \\<one>\\<rbrakk>\n  \\<Longrightarrow> False\n  [M]\\<^bsub>v,n\\<^esub> \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>i xs.\n       i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n       \\<one> \\<le> len M i i xs", "unfolding DBM_zone_repr_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<turnstile>\\<^bsub>v,n\\<^esub> ?M; ?i \\<le> n;\n   set ?xs \\<subseteq> {0..n}; len ?M ?i ?i ?xs < \\<one>\\<rbrakk>\n  \\<Longrightarrow> False\n  {u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>i xs.\n       i \\<le> n \\<and> set xs \\<subseteq> {0..n} \\<longrightarrow>\n       \\<one> \\<le> len M i i xs", "by fastforce"], ["", "lemma neg_cycle_empty:\n  assumes \"\\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists> c. v c = k)\" \"set xs \\<subseteq> {0..n}\" \"i \\<le> n\" \"len M i i xs < \\<one>\"\n  shows \"[(M :: ('a :: time) DBM)]\\<^bsub>v,n\\<^esub> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> = {}", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\n  set xs \\<subseteq> {0..n}\n  i \\<le> n\n  len M i i xs < \\<one>\n\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> = {}", "by (metis leD not_empty_cyc_free)"], ["", "abbreviation clock_numbering' :: \"('c \\<Rightarrow> nat) \\<Rightarrow> nat \\<Rightarrow> bool\"\nwhere\n  \"clock_numbering' v n \\<equiv> \\<forall> c. v c > 0 \\<and> (\\<forall>x. \\<forall>y. v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y)\""], ["", "lemma non_empty_dbm_diag_set:\n  \"clock_numbering' v n \\<Longrightarrow> [M]\\<^bsub>v,n\\<^esub> \\<noteq> {} \\<Longrightarrow> [M]\\<^bsub>v,n\\<^esub> = [(\\<lambda> i j. if i = j then \\<one> else M i j)]\\<^bsub>v,n\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c.\n                0 < v c \\<and>\n                (\\<forall>x y.\n                    v x \\<le> n \\<and>\n                    v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n                    x = y);\n     [M]\\<^bsub>v,n\\<^esub> \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> [M]\\<^bsub>v,n\\<^esub> =\n                      [(\\<lambda>i j.\n                           if i = j then \\<one>\n                           else M i j)]\\<^bsub>v,n\\<^esub>", "proof (auto simp: DBM_zone_repr_def, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> M\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n                         if i = j then \\<one> else M i j\n 2. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "case 1"], ["proof (state)\nthis:\n  x_ \\<turnstile>\\<^bsub>v,n\\<^esub> M\n  \\<forall>c. 0 < v c\n  \\<forall>x y.\n     v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y\n  xa_ \\<turnstile>\\<^bsub>v,n\\<^esub> M\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> M\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n                         if i = j then \\<one> else M i j\n 2. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "{"], ["proof (state)\nthis:\n  x_ \\<turnstile>\\<^bsub>v,n\\<^esub> M\n  \\<forall>c. 0 < v c\n  \\<forall>x y.\n     v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y\n  xa_ \\<turnstile>\\<^bsub>v,n\\<^esub> M\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> M\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n                         if i = j then \\<one> else M i j\n 2. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "fix c"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> M\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n                         if i = j then \\<one> else M i j\n 2. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "assume A: \"v c = 0\""], ["proof (state)\nthis:\n  v c = 0\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> M\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n                         if i = j then \\<one> else M i j\n 2. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "from 1"], ["proof (chain)\npicking this:\n  x_ \\<turnstile>\\<^bsub>v,n\\<^esub> M\n  \\<forall>c. 0 < v c\n  \\<forall>x y.\n     v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y\n  xa_ \\<turnstile>\\<^bsub>v,n\\<^esub> M", "have \"v c > 0\""], ["proof (prove)\nusing this:\n  x_ \\<turnstile>\\<^bsub>v,n\\<^esub> M\n  \\<forall>c. 0 < v c\n  \\<forall>x y.\n     v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y\n  xa_ \\<turnstile>\\<^bsub>v,n\\<^esub> M\n\ngoal (1 subgoal):\n 1. 0 < v c", "by auto"], ["proof (state)\nthis:\n  0 < v c\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> M\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n                         if i = j then \\<one> else M i j\n 2. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "with A"], ["proof (chain)\npicking this:\n  v c = 0\n  0 < v c", "have False"], ["proof (prove)\nusing this:\n  v c = 0\n  0 < v c\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> M\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n                         if i = j then \\<one> else M i j\n 2. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "}"], ["proof (state)\nthis:\n  v ?c2 = 0 \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> M\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n                         if i = j then \\<one> else M i j\n 2. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "note * = this"], ["proof (state)\nthis:\n  v ?c2 = 0 \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> M\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n                         if i = j then \\<one> else M i j\n 2. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "from 1(1)"], ["proof (chain)\npicking this:\n  x_ \\<turnstile>\\<^bsub>v,n\\<^esub> M", "have [simp]: \"Le 0 \\<preceq> M 0 0\""], ["proof (prove)\nusing this:\n  x_ \\<turnstile>\\<^bsub>v,n\\<^esub> M\n\ngoal (1 subgoal):\n 1. Le (0::'b) \\<preceq> M 0 0", "by (auto simp: DBM_val_bounded_def)"], ["proof (state)\nthis:\n  Le (0::'b) \\<preceq> M 0 0\n\ngoal (2 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> M\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n                         if i = j then \\<one> else M i j\n 2. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "from 1"], ["proof (chain)\npicking this:\n  x_ \\<turnstile>\\<^bsub>v,n\\<^esub> M\n  \\<forall>c. 0 < v c\n  \\<forall>x y.\n     v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y\n  xa_ \\<turnstile>\\<^bsub>v,n\\<^esub> M", "show ?case"], ["proof (prove)\nusing this:\n  x_ \\<turnstile>\\<^bsub>v,n\\<^esub> M\n  \\<forall>c. 0 < v c\n  \\<forall>x y.\n     v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y\n  xa_ \\<turnstile>\\<^bsub>v,n\\<^esub> M\n\ngoal (1 subgoal):\n 1. xa_ \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n     if i = j then \\<one> else M i j", "apply (auto simp add: DBM_val_bounded_def neutral)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val xa_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ (Some c1) (Some c2) (M (v c1) (v c2));\n        v c = 0\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa_ None (Some c) (Le (0::'b))\n 2. \\<And>c.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val xa_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ (Some c1) (Some c2) (M (v c1) (v c2));\n        v c = 0\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa_ (Some c) None (Le (0::'b))\n 3. \\<And>c.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val xa_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ (Some c1) (Some c2) (M (v c1) (v c2));\n        v c = 0\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa_ None (Some c) (Le (0::'b))\n 4. \\<And>c.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val xa_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ (Some c1) (Some c2) (M (v c1) (v c2));\n        v c = 0\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa_ None (Some c) (Le (0::'b))\n 5. \\<And>c.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val xa_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ (Some c1) (Some c2) (M (v c1) (v c2));\n        v c = 0\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa_ (Some c) None (Le (0::'b))\n 6. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val xa_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ (Some c1) (Some c2) (M (v c1) (v c2));\n        v c1 = v c2; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa_ (Some c1) (Some c2) (Le (0::'b))", "using *"], ["proof (prove)\nusing this:\n  v ?c2 = 0 \\<Longrightarrow> False\n\ngoal (6 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val xa_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ (Some c1) (Some c2) (M (v c1) (v c2));\n        v c = 0\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa_ None (Some c) (Le (0::'b))\n 2. \\<And>c.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val xa_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ (Some c1) (Some c2) (M (v c1) (v c2));\n        v c = 0\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa_ (Some c) None (Le (0::'b))\n 3. \\<And>c.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val xa_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ (Some c1) (Some c2) (M (v c1) (v c2));\n        v c = 0\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa_ None (Some c) (Le (0::'b))\n 4. \\<And>c.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val xa_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ (Some c1) (Some c2) (M (v c1) (v c2));\n        v c = 0\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa_ None (Some c) (Le (0::'b))\n 5. \\<And>c.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val xa_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ (Some c1) (Some c2) (M (v c1) (v c2));\n        v c = 0\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa_ (Some c) None (Le (0::'b))\n 6. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val xa_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ (Some c1) (Some c2) (M (v c1) (v c2));\n        v c1 = v c2; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa_ (Some c1) (Some c2) (Le (0::'b))", "apply meson+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val xa_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ (Some c1) (Some c2) (M (v c1) (v c2));\n        v c1 = v c2; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa_ (Some c1) (Some c2) (Le (0::'b))", "apply (rename_tac c1 c2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val xa_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ (Some c1) (Some c2) (M (v c1) (v c2));\n        v c1 = v c2; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa_ (Some c1) (Some c2) (Le (0::'b))", "apply (case_tac \"c1 = c2\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val xa_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ (Some c1) (Some c2) (M (v c1) (v c2));\n        v c1 = v c2; v c2 \\<le> n; c1 = c2\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa_ (Some c1) (Some c2) (Le (0::'b))\n 2. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x_ (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val xa_ (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa_ (Some c1) (Some c2) (M (v c1) (v c2));\n        v c1 = v c2; v c2 \\<le> n; c1 \\<noteq> c2\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa_ (Some c1) (Some c2) (Le (0::'b))", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  xa_ \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n   if i = j then \\<one> else M i j\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "case (2 x xa)"], ["proof (state)\nthis:\n  x \\<turnstile>\\<^bsub>v,n\\<^esub> M\n  \\<forall>c. 0 < v c\n  \\<forall>x y.\n     v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y\n  xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n  if i = j then \\<one> else M i j\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "note G = this"], ["proof (state)\nthis:\n  x \\<turnstile>\\<^bsub>v,n\\<^esub> M\n  \\<forall>c. 0 < v c\n  \\<forall>x y.\n     v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y\n  xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n  if i = j then \\<one> else M i j\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "{"], ["proof (state)\nthis:\n  x \\<turnstile>\\<^bsub>v,n\\<^esub> M\n  \\<forall>c. 0 < v c\n  \\<forall>x y.\n     v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y\n  xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n  if i = j then \\<one> else M i j\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "assume A: \"v c = 0\""], ["proof (state)\nthis:\n  v c = 0\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "from 2"], ["proof (chain)\npicking this:\n  x \\<turnstile>\\<^bsub>v,n\\<^esub> M\n  \\<forall>c. 0 < v c\n  \\<forall>x y.\n     v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y\n  xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n  if i = j then \\<one> else M i j", "have \"v c > 0\""], ["proof (prove)\nusing this:\n  x \\<turnstile>\\<^bsub>v,n\\<^esub> M\n  \\<forall>c. 0 < v c\n  \\<forall>x y.\n     v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y\n  xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n  if i = j then \\<one> else M i j\n\ngoal (1 subgoal):\n 1. 0 < v c", "by auto"], ["proof (state)\nthis:\n  0 < v c\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "with A"], ["proof (chain)\npicking this:\n  v c = 0\n  0 < v c", "have False"], ["proof (prove)\nusing this:\n  v c = 0\n  0 < v c\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "}"], ["proof (state)\nthis:\n  v ?c2 = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "note * = this"], ["proof (state)\nthis:\n  v ?c2 = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "{"], ["proof (state)\nthis:\n  v ?c2 = 0 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "assume A: \"v c \\<le> n\" \"M (v c) (v c) < \\<one>\""], ["proof (state)\nthis:\n  v c \\<le> n\n  M (v c) (v c) < \\<one>\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "with 2(1)"], ["proof (chain)\npicking this:\n  x \\<turnstile>\\<^bsub>v,n\\<^esub> M\n  v c \\<le> n\n  M (v c) (v c) < \\<one>", "have False"], ["proof (prove)\nusing this:\n  x \\<turnstile>\\<^bsub>v,n\\<^esub> M\n  v c \\<le> n\n  M (v c) (v c) < \\<one>\n\ngoal (1 subgoal):\n 1. False", "apply (auto simp: neutral DBM_val_bounded_def less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v c \\<le> n; M (v c) (v c) \\<prec> Le (0::'b);\n     Le (0::'b) \\<preceq> M 0 0;\n     \\<forall>c.\n        v c \\<le> n \\<longrightarrow>\n        dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n        dbm_entry_val x (Some c) None (M (v c) 0);\n     \\<forall>c1 c2.\n        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n        dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2))\\<rbrakk>\n    \\<Longrightarrow> False", "apply (cases rule: dbm_lt.cases)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>v c \\<le> n; M (v c) (v c) \\<prec> Le (0::'b);\n     Le (0::'b) \\<preceq> M 0 0;\n     \\<forall>c.\n        v c \\<le> n \\<longrightarrow>\n        dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n        dbm_entry_val x (Some c) None (M (v c) 0);\n     \\<forall>c1 c2.\n        v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n        dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2))\\<rbrakk>\n    \\<Longrightarrow> ?a1.5 \\<prec> ?a2.5\n 2. \\<And>uu_.\n       \\<lbrakk>v c \\<le> n; M (v c) (v c) \\<prec> Le (0::'b);\n        Le (0::'b) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2));\n        ?a1.5 = Lt uu_; ?a2.5 = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>uv_.\n       \\<lbrakk>v c \\<le> n; M (v c) (v c) \\<prec> Le (0::'b);\n        Le (0::'b) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2));\n        ?a1.5 = Le uv_; ?a2.5 = \\<infinity>\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a b.\n       \\<lbrakk>v c \\<le> n; M (v c) (v c) \\<prec> Le (0::'b);\n        Le (0::'b) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2));\n        ?a1.5 = Le a; ?a2.5 = Le b; a < b\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a b.\n       \\<lbrakk>v c \\<le> n; M (v c) (v c) \\<prec> Le (0::'b);\n        Le (0::'b) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2));\n        ?a1.5 = Le a; ?a2.5 = Lt b; a < b\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a b.\n       \\<lbrakk>v c \\<le> n; M (v c) (v c) \\<prec> Le (0::'b);\n        Le (0::'b) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2));\n        ?a1.5 = Lt a; ?a2.5 = Le b; a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a b.\n       \\<lbrakk>v c \\<le> n; M (v c) (v c) \\<prec> Le (0::'b);\n        Le (0::'b) \\<preceq> M 0 0;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2));\n        ?a1.5 = Lt a; ?a2.5 = Lt b; a < b\\<rbrakk>\n       \\<Longrightarrow> False", "by fastforce+"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "}"], ["proof (state)\nthis:\n  \\<lbrakk>v ?c2 \\<le> n; M (v ?c2) (v ?c2) < \\<one>\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "note ** = this"], ["proof (state)\nthis:\n  \\<lbrakk>v ?c2 \\<le> n; M (v ?c2) (v ?c2) < \\<one>\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "from 2(1)"], ["proof (chain)\npicking this:\n  x \\<turnstile>\\<^bsub>v,n\\<^esub> M", "have [simp]: \"Le 0 \\<preceq> M 0 0\""], ["proof (prove)\nusing this:\n  x \\<turnstile>\\<^bsub>v,n\\<^esub> M\n\ngoal (1 subgoal):\n 1. Le (0::'b) \\<preceq> M 0 0", "by (auto simp: DBM_val_bounded_def)"], ["proof (state)\nthis:\n  Le (0::'b) \\<preceq> M 0 0\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>x \\<turnstile>\\<^bsub>v,n\\<^esub> M; \\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n        if i = j then \\<one> else M i j\\<rbrakk>\n       \\<Longrightarrow> xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "from 2"], ["proof (chain)\npicking this:\n  x \\<turnstile>\\<^bsub>v,n\\<^esub> M\n  \\<forall>c. 0 < v c\n  \\<forall>x y.\n     v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y\n  xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n  if i = j then \\<one> else M i j", "show ?case"], ["proof (prove)\nusing this:\n  x \\<turnstile>\\<^bsub>v,n\\<^esub> M\n  \\<forall>c. 0 < v c\n  \\<forall>x y.\n     v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y\n  xa \\<turnstile>\\<^bsub>v,n\\<^esub> \\<lambda>i j.\n  if i = j then \\<one> else M i j\n\ngoal (1 subgoal):\n 1. xa \\<turnstile>\\<^bsub>v,n\\<^esub> M", "proof (auto simp add: DBM_val_bounded_def neutral, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa None (Some c)\n            (if v c = 0 then \\<one> else M 0 (v c)) \\<and>\n           dbm_entry_val xa (Some c) None\n            (if v c = 0 then \\<one> else M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa (Some c1) (Some c2)\n            (if v c1 = v c2 then \\<one> else M (v c1) (v c2));\n        v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa None (Some c) (M 0 (v c))\n 2. \\<And>c.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa None (Some c)\n            (if v c = 0 then \\<one> else M 0 (v c)) \\<and>\n           dbm_entry_val xa (Some c) None\n            (if v c = 0 then \\<one> else M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa (Some c1) (Some c2)\n            (if v c1 = v c2 then \\<one> else M (v c1) (v c2));\n        v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa (Some c) None (M (v c) 0)\n 3. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa None (Some c)\n            (if v c = 0 then \\<one> else M 0 (v c)) \\<and>\n           dbm_entry_val xa (Some c) None\n            (if v c = 0 then \\<one> else M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa (Some c1) (Some c2)\n            (if v c1 = v c2 then \\<one> else M (v c1) (v c2));\n        v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa (Some c1) (Some c2)\n                          (M (v c1) (v c2))", "case 1"], ["proof (state)\nthis:\n  \\<forall>c. 0 < v c\n  \\<forall>x y.\n     v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n     dbm_entry_val x (Some c) None (M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2))\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val xa None (Some c)\n      (if v c = 0 then \\<one> else M 0 (v c)) \\<and>\n     dbm_entry_val xa (Some c) None (if v c = 0 then \\<one> else M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val xa (Some c1) (Some c2)\n      (if v c1 = v c2 then \\<one> else M (v c1) (v c2))\n  v c_ \\<le> n\n\ngoal (3 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa None (Some c)\n            (if v c = 0 then \\<one> else M 0 (v c)) \\<and>\n           dbm_entry_val xa (Some c) None\n            (if v c = 0 then \\<one> else M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa (Some c1) (Some c2)\n            (if v c1 = v c2 then \\<one> else M (v c1) (v c2));\n        v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa None (Some c) (M 0 (v c))\n 2. \\<And>c.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa None (Some c)\n            (if v c = 0 then \\<one> else M 0 (v c)) \\<and>\n           dbm_entry_val xa (Some c) None\n            (if v c = 0 then \\<one> else M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa (Some c1) (Some c2)\n            (if v c1 = v c2 then \\<one> else M (v c1) (v c2));\n        v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa (Some c) None (M (v c) 0)\n 3. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa None (Some c)\n            (if v c = 0 then \\<one> else M 0 (v c)) \\<and>\n           dbm_entry_val xa (Some c) None\n            (if v c = 0 then \\<one> else M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa (Some c1) (Some c2)\n            (if v c1 = v c2 then \\<one> else M (v c1) (v c2));\n        v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa (Some c1) (Some c2)\n                          (M (v c1) (v c2))", "with *"], ["proof (chain)\npicking this:\n  v ?c2 = 0 \\<Longrightarrow> False\n  \\<forall>c. 0 < v c\n  \\<forall>x y.\n     v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n     dbm_entry_val x (Some c) None (M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2))\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val xa None (Some c)\n      (if v c = 0 then \\<one> else M 0 (v c)) \\<and>\n     dbm_entry_val xa (Some c) None (if v c = 0 then \\<one> else M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val xa (Some c1) (Some c2)\n      (if v c1 = v c2 then \\<one> else M (v c1) (v c2))\n  v c_ \\<le> n", "show ?case"], ["proof (prove)\nusing this:\n  v ?c2 = 0 \\<Longrightarrow> False\n  \\<forall>c. 0 < v c\n  \\<forall>x y.\n     v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n     dbm_entry_val x (Some c) None (M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2))\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val xa None (Some c)\n      (if v c = 0 then \\<one> else M 0 (v c)) \\<and>\n     dbm_entry_val xa (Some c) None (if v c = 0 then \\<one> else M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val xa (Some c1) (Some c2)\n      (if v c1 = v c2 then \\<one> else M (v c1) (v c2))\n  v c_ \\<le> n\n\ngoal (1 subgoal):\n 1. dbm_entry_val xa None (Some c_) (M 0 (v c_))", "by presburger"], ["proof (state)\nthis:\n  dbm_entry_val xa None (Some c_) (M 0 (v c_))\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa None (Some c)\n            (if v c = 0 then \\<one> else M 0 (v c)) \\<and>\n           dbm_entry_val xa (Some c) None\n            (if v c = 0 then \\<one> else M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa (Some c1) (Some c2)\n            (if v c1 = v c2 then \\<one> else M (v c1) (v c2));\n        v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa (Some c) None (M (v c) 0)\n 2. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa None (Some c)\n            (if v c = 0 then \\<one> else M 0 (v c)) \\<and>\n           dbm_entry_val xa (Some c) None\n            (if v c = 0 then \\<one> else M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa (Some c1) (Some c2)\n            (if v c1 = v c2 then \\<one> else M (v c1) (v c2));\n        v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa (Some c1) (Some c2)\n                          (M (v c1) (v c2))", "case 2"], ["proof (state)\nthis:\n  \\<forall>c. 0 < v c\n  \\<forall>x y.\n     v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n     dbm_entry_val x (Some c) None (M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2))\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val xa None (Some c)\n      (if v c = 0 then \\<one> else M 0 (v c)) \\<and>\n     dbm_entry_val xa (Some c) None (if v c = 0 then \\<one> else M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val xa (Some c1) (Some c2)\n      (if v c1 = v c2 then \\<one> else M (v c1) (v c2))\n  v c_ \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa None (Some c)\n            (if v c = 0 then \\<one> else M 0 (v c)) \\<and>\n           dbm_entry_val xa (Some c) None\n            (if v c = 0 then \\<one> else M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa (Some c1) (Some c2)\n            (if v c1 = v c2 then \\<one> else M (v c1) (v c2));\n        v c \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa (Some c) None (M (v c) 0)\n 2. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa None (Some c)\n            (if v c = 0 then \\<one> else M 0 (v c)) \\<and>\n           dbm_entry_val xa (Some c) None\n            (if v c = 0 then \\<one> else M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa (Some c1) (Some c2)\n            (if v c1 = v c2 then \\<one> else M (v c1) (v c2));\n        v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa (Some c1) (Some c2)\n                          (M (v c1) (v c2))", "with *"], ["proof (chain)\npicking this:\n  v ?c2 = 0 \\<Longrightarrow> False\n  \\<forall>c. 0 < v c\n  \\<forall>x y.\n     v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n     dbm_entry_val x (Some c) None (M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2))\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val xa None (Some c)\n      (if v c = 0 then \\<one> else M 0 (v c)) \\<and>\n     dbm_entry_val xa (Some c) None (if v c = 0 then \\<one> else M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val xa (Some c1) (Some c2)\n      (if v c1 = v c2 then \\<one> else M (v c1) (v c2))\n  v c_ \\<le> n", "show ?case"], ["proof (prove)\nusing this:\n  v ?c2 = 0 \\<Longrightarrow> False\n  \\<forall>c. 0 < v c\n  \\<forall>x y.\n     v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n     dbm_entry_val x (Some c) None (M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2))\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val xa None (Some c)\n      (if v c = 0 then \\<one> else M 0 (v c)) \\<and>\n     dbm_entry_val xa (Some c) None (if v c = 0 then \\<one> else M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val xa (Some c1) (Some c2)\n      (if v c1 = v c2 then \\<one> else M (v c1) (v c2))\n  v c_ \\<le> n\n\ngoal (1 subgoal):\n 1. dbm_entry_val xa (Some c_) None (M (v c_) 0)", "by presburger"], ["proof (state)\nthis:\n  dbm_entry_val xa (Some c_) None (M (v c_) 0)\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa None (Some c)\n            (if v c = 0 then \\<one> else M 0 (v c)) \\<and>\n           dbm_entry_val xa (Some c) None\n            (if v c = 0 then \\<one> else M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa (Some c1) (Some c2)\n            (if v c1 = v c2 then \\<one> else M (v c1) (v c2));\n        v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa (Some c1) (Some c2)\n                          (M (v c1) (v c2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa None (Some c)\n            (if v c = 0 then \\<one> else M 0 (v c)) \\<and>\n           dbm_entry_val xa (Some c) None\n            (if v c = 0 then \\<one> else M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa (Some c1) (Some c2)\n            (if v c1 = v c2 then \\<one> else M (v c1) (v c2));\n        v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa (Some c1) (Some c2)\n                          (M (v c1) (v c2))", "case (3 c1 c2)"], ["proof (state)\nthis:\n  \\<forall>c. 0 < v c\n  \\<forall>x y.\n     v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n     dbm_entry_val x (Some c) None (M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2))\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val xa None (Some c)\n      (if v c = 0 then \\<one> else M 0 (v c)) \\<and>\n     dbm_entry_val xa (Some c) None (if v c = 0 then \\<one> else M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val xa (Some c1) (Some c2)\n      (if v c1 = v c2 then \\<one> else M (v c1) (v c2))\n  v c1 \\<le> n\n  v c2 \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>c1 c2.\n       \\<lbrakk>\\<forall>c. 0 < v c;\n        \\<forall>x y.\n           v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow>\n           x = y;\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n           dbm_entry_val x (Some c) None (M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2));\n        \\<forall>c.\n           v c \\<le> n \\<longrightarrow>\n           dbm_entry_val xa None (Some c)\n            (if v c = 0 then \\<one> else M 0 (v c)) \\<and>\n           dbm_entry_val xa (Some c) None\n            (if v c = 0 then \\<one> else M (v c) 0);\n        \\<forall>c1 c2.\n           v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n           dbm_entry_val xa (Some c1) (Some c2)\n            (if v c1 = v c2 then \\<one> else M (v c1) (v c2));\n        v c1 \\<le> n; v c2 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> dbm_entry_val xa (Some c1) (Some c2)\n                          (M (v c1) (v c2))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. dbm_entry_val xa (Some c1) (Some c2) (M (v c1) (v c2))", "proof (cases \"v c1 = v c2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. v c1 = v c2 \\<Longrightarrow>\n    dbm_entry_val xa (Some c1) (Some c2) (M (v c1) (v c2))\n 2. v c1 \\<noteq> v c2 \\<Longrightarrow>\n    dbm_entry_val xa (Some c1) (Some c2) (M (v c1) (v c2))", "case True"], ["proof (state)\nthis:\n  v c1 = v c2\n\ngoal (2 subgoals):\n 1. v c1 = v c2 \\<Longrightarrow>\n    dbm_entry_val xa (Some c1) (Some c2) (M (v c1) (v c2))\n 2. v c1 \\<noteq> v c2 \\<Longrightarrow>\n    dbm_entry_val xa (Some c1) (Some c2) (M (v c1) (v c2))", "with 3"], ["proof (chain)\npicking this:\n  \\<forall>c. 0 < v c\n  \\<forall>x y.\n     v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n     dbm_entry_val x (Some c) None (M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2))\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val xa None (Some c)\n      (if v c = 0 then \\<one> else M 0 (v c)) \\<and>\n     dbm_entry_val xa (Some c) None (if v c = 0 then \\<one> else M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val xa (Some c1) (Some c2)\n      (if v c1 = v c2 then \\<one> else M (v c1) (v c2))\n  v c1 \\<le> n\n  v c2 \\<le> n\n  v c1 = v c2", "have \"c1 = c2\""], ["proof (prove)\nusing this:\n  \\<forall>c. 0 < v c\n  \\<forall>x y.\n     v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n     dbm_entry_val x (Some c) None (M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2))\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val xa None (Some c)\n      (if v c = 0 then \\<one> else M 0 (v c)) \\<and>\n     dbm_entry_val xa (Some c) None (if v c = 0 then \\<one> else M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val xa (Some c1) (Some c2)\n      (if v c1 = v c2 then \\<one> else M (v c1) (v c2))\n  v c1 \\<le> n\n  v c2 \\<le> n\n  v c1 = v c2\n\ngoal (1 subgoal):\n 1. c1 = c2", "by auto"], ["proof (state)\nthis:\n  c1 = c2\n\ngoal (2 subgoals):\n 1. v c1 = v c2 \\<Longrightarrow>\n    dbm_entry_val xa (Some c1) (Some c2) (M (v c1) (v c2))\n 2. v c1 \\<noteq> v c2 \\<Longrightarrow>\n    dbm_entry_val xa (Some c1) (Some c2) (M (v c1) (v c2))", "moreover"], ["proof (state)\nthis:\n  c1 = c2\n\ngoal (2 subgoals):\n 1. v c1 = v c2 \\<Longrightarrow>\n    dbm_entry_val xa (Some c1) (Some c2) (M (v c1) (v c2))\n 2. v c1 \\<noteq> v c2 \\<Longrightarrow>\n    dbm_entry_val xa (Some c1) (Some c2) (M (v c1) (v c2))", "with **[OF 3(8)] not_less"], ["proof (chain)\npicking this:\n  M (v c2) (v c2) < \\<one> \\<Longrightarrow> False\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n  c1 = c2", "have \"M (v c2) (v c2) \\<ge> \\<one>\""], ["proof (prove)\nusing this:\n  M (v c2) (v c2) < \\<one> \\<Longrightarrow> False\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n  c1 = c2\n\ngoal (1 subgoal):\n 1. \\<one> \\<le> M (v c2) (v c2)", "by auto"], ["proof (state)\nthis:\n  \\<one> \\<le> M (v c2) (v c2)\n\ngoal (2 subgoals):\n 1. v c1 = v c2 \\<Longrightarrow>\n    dbm_entry_val xa (Some c1) (Some c2) (M (v c1) (v c2))\n 2. v c1 \\<noteq> v c2 \\<Longrightarrow>\n    dbm_entry_val xa (Some c1) (Some c2) (M (v c1) (v c2))", "ultimately"], ["proof (chain)\npicking this:\n  c1 = c2\n  \\<one> \\<le> M (v c2) (v c2)", "show \"dbm_entry_val xa (Some c1) (Some c2) (M (v c1) (v c2))\""], ["proof (prove)\nusing this:\n  c1 = c2\n  \\<one> \\<le> M (v c2) (v c2)\n\ngoal (1 subgoal):\n 1. dbm_entry_val xa (Some c1) (Some c2) (M (v c1) (v c2))", "unfolding neutral"], ["proof (prove)\nusing this:\n  c1 = c2\n  Le (0::'b) \\<le> M (v c2) (v c2)\n\ngoal (1 subgoal):\n 1. dbm_entry_val xa (Some c1) (Some c2) (M (v c1) (v c2))", "by (cases \"M (v c1) (v c2)\") (auto simp add: less_eq dbm_le_def, fastforce+)"], ["proof (state)\nthis:\n  dbm_entry_val xa (Some c1) (Some c2) (M (v c1) (v c2))\n\ngoal (1 subgoal):\n 1. v c1 \\<noteq> v c2 \\<Longrightarrow>\n    dbm_entry_val xa (Some c1) (Some c2) (M (v c1) (v c2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v c1 \\<noteq> v c2 \\<Longrightarrow>\n    dbm_entry_val xa (Some c1) (Some c2) (M (v c1) (v c2))", "case False"], ["proof (state)\nthis:\n  v c1 \\<noteq> v c2\n\ngoal (1 subgoal):\n 1. v c1 \\<noteq> v c2 \\<Longrightarrow>\n    dbm_entry_val xa (Some c1) (Some c2) (M (v c1) (v c2))", "with 3"], ["proof (chain)\npicking this:\n  \\<forall>c. 0 < v c\n  \\<forall>x y.\n     v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n     dbm_entry_val x (Some c) None (M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2))\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val xa None (Some c)\n      (if v c = 0 then \\<one> else M 0 (v c)) \\<and>\n     dbm_entry_val xa (Some c) None (if v c = 0 then \\<one> else M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val xa (Some c1) (Some c2)\n      (if v c1 = v c2 then \\<one> else M (v c1) (v c2))\n  v c1 \\<le> n\n  v c2 \\<le> n\n  v c1 \\<noteq> v c2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>c. 0 < v c\n  \\<forall>x y.\n     v x \\<le> n \\<and> v y \\<le> n \\<and> v x = v y \\<longrightarrow> x = y\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val x None (Some c) (M 0 (v c)) \\<and>\n     dbm_entry_val x (Some c) None (M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val x (Some c1) (Some c2) (M (v c1) (v c2))\n  \\<forall>c.\n     v c \\<le> n \\<longrightarrow>\n     dbm_entry_val xa None (Some c)\n      (if v c = 0 then \\<one> else M 0 (v c)) \\<and>\n     dbm_entry_val xa (Some c) None (if v c = 0 then \\<one> else M (v c) 0)\n  \\<forall>c1 c2.\n     v c1 \\<le> n \\<and> v c2 \\<le> n \\<longrightarrow>\n     dbm_entry_val xa (Some c1) (Some c2)\n      (if v c1 = v c2 then \\<one> else M (v c1) (v c2))\n  v c1 \\<le> n\n  v c2 \\<le> n\n  v c1 \\<noteq> v c2\n\ngoal (1 subgoal):\n 1. dbm_entry_val xa (Some c1) (Some c2) (M (v c1) (v c2))", "by presburger"], ["proof (state)\nthis:\n  dbm_entry_val xa (Some c1) (Some c2) (M (v c1) (v c2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dbm_entry_val xa (Some c1) (Some c2) (M (v c1) (v c2))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  xa \\<turnstile>\\<^bsub>v,n\\<^esub> M\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_empty_cycle_free:\n  assumes \"[M]\\<^bsub>v,n\\<^esub> \\<noteq> {}\"\n    and \"\\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\"\n  shows \"cycle_free M n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cycle_free M n", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> cycle_free M n \\<Longrightarrow> False", "apply (drule negative_cycle_dest_diag)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i xs.\n       i \\<le> n \\<and>\n       set xs \\<subseteq> {0..n} \\<and>\n       len M i i xs < \\<one> \\<Longrightarrow>\n    False", "using DBM_val_bounded_neg_cycle assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<turnstile>\\<^bsub>?v,?n\\<^esub> ?M; ?i \\<le> ?n;\n   set ?xs \\<subseteq> {0..?n}; len ?M ?i ?i ?xs < \\<one>;\n   \\<forall>k\\<le>?n.\n      0 < k \\<longrightarrow> (\\<exists>c. ?v c = k)\\<rbrakk>\n  \\<Longrightarrow> False\n  [M]\\<^bsub>v,n\\<^esub> \\<noteq> {}\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\n\ngoal (1 subgoal):\n 1. \\<exists>i xs.\n       i \\<le> n \\<and>\n       set xs \\<subseteq> {0..n} \\<and>\n       len M i i xs < \\<one> \\<Longrightarrow>\n    False", "unfolding DBM_zone_repr_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<turnstile>\\<^bsub>?v,?n\\<^esub> ?M; ?i \\<le> ?n;\n   set ?xs \\<subseteq> {0..?n}; len ?M ?i ?i ?xs < \\<one>;\n   \\<forall>k\\<le>?n.\n      0 < k \\<longrightarrow> (\\<exists>c. ?v c = k)\\<rbrakk>\n  \\<Longrightarrow> False\n  {u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M} \\<noteq> {}\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\n\ngoal (1 subgoal):\n 1. \\<exists>i xs.\n       i \\<le> n \\<and>\n       set xs \\<subseteq> {0..n} \\<and>\n       len M i i xs < \\<one> \\<Longrightarrow>\n    False", "by blast"], ["", "lemma neg_diag_empty:\n  assumes \"\\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\" \"i \\<le> n\" \"M i i < \\<one>\"\n  shows \"[M]\\<^bsub>v,n\\<^esub> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [M]\\<^bsub>v,n\\<^esub> = {}", "unfolding DBM_zone_repr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M} = {}", "using DBM_val_bounded_neg_cycle[of v _ M n i \"[]\"] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?u \\<turnstile>\\<^bsub>v,n\\<^esub> M; i \\<le> n;\n   set [] \\<subseteq> {0..n}; len M i i [] < \\<one>;\n   \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\n  i \\<le> n\n  M i i < \\<one>\n\ngoal (1 subgoal):\n 1. {u. u \\<turnstile>\\<^bsub>v,n\\<^esub> M} = {}", "by auto"], ["", "lemma canonical_empty_zone:\n  assumes \"\\<forall>k\\<le>n. 0 < k \\<longrightarrow> (\\<exists>c. v c = k)\" \"\\<forall>c. v c \\<le> n \\<longrightarrow> 0 < v c\"\n    and \"canonical M n\"\n  shows \"[M]\\<^bsub>v,n\\<^esub> = {} \\<longleftrightarrow> (\\<exists>i\\<le>n. M i i < \\<one>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ([M]\\<^bsub>v,n\\<^esub> = {}) = (\\<exists>i\\<le>n. M i i < \\<one>)", "using FW_detects_empty_zone[OF assms(1,2), of M] FW_canonical_id[OF assms(3)]"], ["proof (prove)\nusing this:\n  ([FW M n]\\<^bsub>v,n\\<^esub> = {}) =\n  (\\<exists>i\\<le>n. FW M n i i < Le (0::'b))\n  FW M n = M\n\ngoal (1 subgoal):\n 1. ([M]\\<^bsub>v,n\\<^esub> = {}) = (\\<exists>i\\<le>n. M i i < \\<one>)", "unfolding neutral"], ["proof (prove)\nusing this:\n  ([FW M n]\\<^bsub>v,n\\<^esub> = {}) =\n  (\\<exists>i\\<le>n. FW M n i i < Le (0::'b))\n  FW M n = M\n\ngoal (1 subgoal):\n 1. ([M]\\<^bsub>v,n\\<^esub> = {}) = (\\<exists>i\\<le>n. M i i < Le (0::'b))", "by simp"], ["", "end"]]}