{"file_name": "/home/qj213/afp-2021-10-22/thys/Core_DOM/common/monads/NodeMonad.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Core_DOM", "problem_names": ["lemmas node_ptr_kinds_M_defs = a_ptr_kinds_M_def", "lemma node_ptr_kinds_M_eq:\n  assumes \"|h \\<turnstile> object_ptr_kinds_M|\\<^sub>r = |h' \\<turnstile> object_ptr_kinds_M|\\<^sub>r\"\n  shows \"|h \\<turnstile> node_ptr_kinds_M|\\<^sub>r = |h' \\<turnstile> node_ptr_kinds_M|\\<^sub>r\"", "lemma get_M_is_l_get_M: \"l_get_M get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e type_wf node_ptr_kinds\"", "lemmas get_M_defs = get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def[unfolded l_get_M.a_get_M_def[OF get_M_is_l_get_M]]", "lemmas get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_ok = get_M_ok[folded get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def]", "lemma node_ptr_kinds_M_reads: \n  \"reads (\\<Union>object_ptr. {preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing)}) node_ptr_kinds_M h h'\"", "lemmas put_M_defs = a_put_M_def", "lemmas put_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_ok = put_M_ok[folded put_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def]", "lemma get_M_Object_preserved1 [simp]: \n  \"(\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr setter v \\<rightarrow>\\<^sub>h h' \n    \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\"", "lemma get_M_Object_preserved2 [simp]: \n  \"cast node_ptr \\<noteq> object_ptr \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr setter v \\<rightarrow>\\<^sub>h h' \n    \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\"", "lemma get_M_Object_preserved3 [simp]: \n  \"h \\<turnstile> put_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> (\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \n    \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\"", "lemma get_M_Object_preserved4 [simp]: \n  \"cast node_ptr \\<noteq> object_ptr \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr setter v \\<rightarrow>\\<^sub>h h' \n      \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr getter) h h'\"", "lemma get_node_ptr_simp [simp]: \n  \"get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) = (if ptr = cast node_ptr then cast obj else get node_ptr h)\"", "lemma node_ptr_kinds_simp [simp]: \n  \"node_ptr_kinds (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) \n                = node_ptr_kinds h |\\<union>| (if is_node_ptr_kind ptr then {|the (cast ptr)|} else {||})\"", "lemma type_wf_put_I:\n  assumes \"type_wf h\"\n  assumes \"ObjectClass.type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"is_node_ptr_kind ptr \\<Longrightarrow> is_node_kind obj\"\n  shows \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"", "lemma type_wf_put_ptr_not_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<notin>| object_ptr_kinds h\"\n  shows \"type_wf h\"", "lemma type_wf_put_ptr_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<in>| object_ptr_kinds h\"\n  assumes \"ObjectClass.type_wf h\"\n  assumes \"is_node_ptr_kind ptr \\<Longrightarrow> is_node_kind (the (get ptr h))\"\n  shows \"type_wf h\"", "lemma node_ptr_kinds_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  shows \"node_ptr_kinds h = node_ptr_kinds h'\"", "lemma node_ptr_kinds_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h'. \\<forall>w \\<in> SW. h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n            \\<longrightarrow> (\\<forall>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h')\"\n  shows \"node_ptr_kinds h = node_ptr_kinds h'\"", "lemma type_wf_preserved_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  assumes \"\\<And>node_ptr. preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr RNode.nothing) h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma type_wf_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n           \\<Longrightarrow> \\<forall>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n           \\<Longrightarrow> \\<forall>node_ptr. preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr RNode.nothing) h h'\"\n  shows \"type_wf h = type_wf h'\""], "translations": [["", "lemmas node_ptr_kinds_M_defs = a_ptr_kinds_M_def"], ["", "lemma node_ptr_kinds_M_eq:\n  assumes \"|h \\<turnstile> object_ptr_kinds_M|\\<^sub>r = |h' \\<turnstile> object_ptr_kinds_M|\\<^sub>r\"\n  shows \"|h \\<turnstile> node_ptr_kinds_M|\\<^sub>r = |h' \\<turnstile> node_ptr_kinds_M|\\<^sub>r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |h \\<turnstile> node_ptr_kinds_M|\\<^sub>r =\n    |h' \\<turnstile> node_ptr_kinds_M|\\<^sub>r", "using assms"], ["proof (prove)\nusing this:\n  |h \\<turnstile> object_ptr_kinds_M|\\<^sub>r =\n  |h' \\<turnstile> object_ptr_kinds_M|\\<^sub>r\n\ngoal (1 subgoal):\n 1. |h \\<turnstile> node_ptr_kinds_M|\\<^sub>r =\n    |h' \\<turnstile> node_ptr_kinds_M|\\<^sub>r", "by(auto simp add: node_ptr_kinds_M_defs object_ptr_kinds_M_defs node_ptr_kinds_def)"], ["", "global_interpretation l_dummy defines get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e = \"l_get_M.a_get_M get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma get_M_is_l_get_M: \"l_get_M get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e type_wf node_ptr_kinds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M get NodeClass.type_wf node_ptr_kinds", "apply(simp add: get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_type_wf l_get_M_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ptr h.\n       (\\<exists>y. get ptr h = Some y) \\<longrightarrow>\n       ptr |\\<in>| node_ptr_kinds h", "by (metis ObjectClass.a_type_wf_def ObjectClass.get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf bind_eq_None_conv get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def \n      node_ptr_kinds_commutes option.simps(3))"], ["", "lemmas get_M_defs = get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def[unfolded l_get_M.a_get_M_def[OF get_M_is_l_get_M]]"], ["", "adhoc_overloading get_M get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e"], ["", "locale l_get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_lemmas = l_type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\nbegin"], ["", "sublocale l_get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_lemmas"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_lemmas type_wf", "by unfold_locales"], ["", "interpretation l_get_M get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e type_wf node_ptr_kinds"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M get type_wf node_ptr_kinds", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h ptr.\n       \\<lbrakk>type_wf h; ptr |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> get ptr h \\<noteq> None\n 2. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| node_ptr_kinds h", "apply (simp add: get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_type_wf local.type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| node_ptr_kinds h", "by (meson NodeMonad.get_M_is_l_get_M l_get_M_def)"], ["", "lemmas get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_ok = get_M_ok[folded get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def]"], ["", "end"], ["", "global_interpretation l_get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_lemmas type_wf"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_lemmas NodeClass.type_wf", "by unfold_locales"], ["", "lemma node_ptr_kinds_M_reads: \n  \"reads (\\<Union>object_ptr. {preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing)}) node_ptr_kinds_M h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reads\n     (\\<Union>object_ptr. {preserved (get_M object_ptr RObject.nothing)})\n     node_ptr_kinds_M h h'", "using object_ptr_kinds_M_reads"], ["proof (prove)\nusing this:\n  reads (\\<Union>object_ptr. {preserved (get_M object_ptr RObject.nothing)})\n   object_ptr_kinds_M ?h ?h'\n\ngoal (1 subgoal):\n 1. reads\n     (\\<Union>object_ptr. {preserved (get_M object_ptr RObject.nothing)})\n     node_ptr_kinds_M h h'", "apply (simp add: reads_def node_ptr_kinds_M_defs node_ptr_kinds_def\n      object_ptr_kinds_M_reads preserved_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h h'.\n        (\\<forall>y.\n            h \\<turnstile> get_M y RObject.nothing\n            \\<rightarrow>\\<^sub>r () =\n            h' \\<turnstile> get_M y RObject.nothing\n            \\<rightarrow>\\<^sub>r ()) \\<longrightarrow>\n        (\\<forall>x.\n            (x = sorted_list_of_set (fset (object_ptr_kinds h))) =\n            (x =\n             sorted_list_of_set\n              (fset (object_ptr_kinds h'))))) \\<Longrightarrow>\n    (\\<forall>y.\n        h \\<turnstile> get_M y RObject.nothing \\<rightarrow>\\<^sub>r () =\n        h' \\<turnstile> get_M y RObject.nothing\n        \\<rightarrow>\\<^sub>r ()) \\<longrightarrow>\n    (\\<forall>x.\n        (sorted_list_of_set\n          ((\\<lambda>x. the (cast x)) `\n           (Collect is_node_ptr_kind \\<inter> fset (object_ptr_kinds h))) =\n         x) =\n        (sorted_list_of_set\n          ((\\<lambda>x. the (cast x)) `\n           (Collect is_node_ptr_kind \\<inter> fset (object_ptr_kinds h'))) =\n         x))", "by (smt object_ptr_kinds_preserved_small preserved_def unit_all_impI)"], ["", "global_interpretation l_put_M type_wf node_ptr_kinds get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e \n  rewrites \"a_get_M = get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\" \n  defines put_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e = a_put_M"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M NodeClass.type_wf node_ptr_kinds get &&&\n    l_get_M.a_get_M get = get_M", "apply (simp add: get_M_is_l_get_M l_put_M_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M.a_get_M get = get_M", "by (simp add: get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def)"], ["", "lemmas put_M_defs = a_put_M_def"], ["", "adhoc_overloading put_M put_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e"], ["", "locale l_put_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_lemmas = l_type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\nbegin"], ["", "sublocale l_put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_lemmas"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_lemmas type_wf", "by unfold_locales"], ["", "interpretation l_put_M type_wf node_ptr_kinds get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M type_wf node_ptr_kinds get", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h ptr.\n       \\<lbrakk>type_wf h; ptr |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> get ptr h \\<noteq> None\n 2. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| node_ptr_kinds h", "apply (simp add: get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_type_wf local.type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| node_ptr_kinds h", "by (meson NodeMonad.get_M_is_l_get_M l_get_M_def)"], ["", "lemmas put_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_ok = put_M_ok[folded put_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def]"], ["", "end"], ["", "global_interpretation l_put_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_lemmas type_wf"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_lemmas NodeClass.type_wf", "by unfold_locales"], ["", "lemma get_M_Object_preserved1 [simp]: \n  \"(\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr setter v \\<rightarrow>\\<^sub>h h' \n    \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     h \\<turnstile> put_M node_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "apply(cases \"cast node_ptr = object_ptr\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     h \\<turnstile> put_M node_ptr setter v \\<rightarrow>\\<^sub>h h';\n     cast node_ptr = object_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'\n 2. \\<lbrakk>\\<And>x.\n                getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     h \\<turnstile> put_M node_ptr setter v \\<rightarrow>\\<^sub>h h';\n     cast node_ptr \\<noteq> object_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs ObjectMonad.get_M_defs get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def preserved_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def \n      bind_eq_Some_conv \n      split: option.splits)"], ["", "lemma get_M_Object_preserved2 [simp]: \n  \"cast node_ptr \\<noteq> object_ptr \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr setter v \\<rightarrow>\\<^sub>h h' \n    \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cast node_ptr \\<noteq> object_ptr;\n     h \\<turnstile> put_M node_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def ObjectMonad.get_M_defs preserved_def \n      split: option.splits dest: get_heap_E)"], ["", "lemma get_M_Object_preserved3 [simp]: \n  \"h \\<turnstile> put_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> (\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \n    \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> put_M node_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x.\n        getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "apply(cases \"cast node_ptr \\<noteq> object_ptr\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h \\<turnstile> put_M node_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     cast node_ptr \\<noteq> object_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'\n 2. \\<lbrakk>h \\<turnstile> put_M node_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     \\<not> cast node_ptr \\<noteq> object_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def ObjectMonad.get_M_defs preserved_def \n      split: option.splits bind_splits dest: get_heap_E)"], ["", "lemma get_M_Object_preserved4 [simp]: \n  \"cast node_ptr \\<noteq> object_ptr \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr setter v \\<rightarrow>\\<^sub>h h' \n      \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cast node_ptr \\<noteq> object_ptr;\n     h \\<turnstile> put_M object_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M node_ptr getter) h h'", "by(auto simp add: ObjectMonad.put_M_defs get_M_defs get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def ObjectMonad.get_M_defs preserved_def \n      split: option.splits dest: get_heap_E)"], ["", "subsection\\<open>Modified Heaps\\<close>"], ["", "lemma get_node_ptr_simp [simp]: \n  \"get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) = (if ptr = cast node_ptr then cast obj else get node_ptr h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get node_ptr (put ptr obj h) =\n    (if ptr = cast node_ptr then cast obj else get node_ptr h)", "by(auto simp add: get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def)"], ["", "lemma node_ptr_kinds_simp [simp]: \n  \"node_ptr_kinds (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) \n                = node_ptr_kinds h |\\<union>| (if is_node_ptr_kind ptr then {|the (cast ptr)|} else {||})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. node_ptr_kinds (put ptr obj h) =\n    node_ptr_kinds h |\\<union>|\n    (if is_node_ptr_kind ptr then {|the (cast ptr)|} else {||})", "by(auto simp add: node_ptr_kinds_def)"], ["", "lemma type_wf_put_I:\n  assumes \"type_wf h\"\n  assumes \"ObjectClass.type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"is_node_ptr_kind ptr \\<Longrightarrow> is_node_kind obj\"\n  shows \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NodeClass.type_wf (put ptr obj h)", "using assms"], ["proof (prove)\nusing this:\n  NodeClass.type_wf h\n  ObjectClass.type_wf (put ptr obj h)\n  is_node_ptr_kind ptr \\<Longrightarrow> is_node_kind obj\n\ngoal (1 subgoal):\n 1. NodeClass.type_wf (put ptr obj h)", "apply(auto simp add: type_wf_defs split: option.splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>ObjectClass.type_wf (put ptr obj h); is_node_kind obj;\n     ObjectClass.type_wf h;\n     \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n        \\<exists>y. get node_ptr h = Some y;\n     is_node_ptr_kind ptr\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y. cast y = obj\n 2. \\<And>node_ptr.\n       \\<lbrakk>ObjectClass.type_wf (put (cast node_ptr) obj h);\n        is_node_kind obj; ObjectClass.type_wf h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y. get node_ptr h = Some y;\n        node_ptr |\\<in>| node_ptr_kinds h; ptr = cast node_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = obj", "using cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_none is_node_kind_def"], ["proof (prove)\nusing this:\n  (cast ?obj = None) = (\\<nexists>node. cast node = ?obj)\n  is_node_kind ?ptr = (cast ?ptr \\<noteq> None)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ObjectClass.type_wf (put ptr obj h); is_node_kind obj;\n     ObjectClass.type_wf h;\n     \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n        \\<exists>y. get node_ptr h = Some y;\n     is_node_ptr_kind ptr\\<rbrakk>\n    \\<Longrightarrow> \\<exists>y. cast y = obj\n 2. \\<And>node_ptr.\n       \\<lbrakk>ObjectClass.type_wf (put (cast node_ptr) obj h);\n        is_node_kind obj; ObjectClass.type_wf h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y. get node_ptr h = Some y;\n        node_ptr |\\<in>| node_ptr_kinds h; ptr = cast node_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = obj", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>node_ptr.\n       \\<lbrakk>ObjectClass.type_wf (put (cast node_ptr) obj h);\n        is_node_kind obj; ObjectClass.type_wf h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y. get node_ptr h = Some y;\n        node_ptr |\\<in>| node_ptr_kinds h; ptr = cast node_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = obj", "using cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_none is_node_kind_def"], ["proof (prove)\nusing this:\n  (cast ?obj = None) = (\\<nexists>node. cast node = ?obj)\n  is_node_kind ?ptr = (cast ?ptr \\<noteq> None)\n\ngoal (1 subgoal):\n 1. \\<And>node_ptr.\n       \\<lbrakk>ObjectClass.type_wf (put (cast node_ptr) obj h);\n        is_node_kind obj; ObjectClass.type_wf h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y. get node_ptr h = Some y;\n        node_ptr |\\<in>| node_ptr_kinds h; ptr = cast node_ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = obj", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma type_wf_put_ptr_not_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<notin>| object_ptr_kinds h\"\n  shows \"type_wf h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NodeClass.type_wf h", "using assms"], ["proof (prove)\nusing this:\n  NodeClass.type_wf (put ptr obj h)\n  ptr |\\<notin>| object_ptr_kinds h\n\ngoal (1 subgoal):\n 1. NodeClass.type_wf h", "by(auto simp add: type_wf_defs elim!: ObjectMonad.type_wf_put_ptr_not_in_heap_E  \n      split: option.splits if_splits)"], ["", "lemma type_wf_put_ptr_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<in>| object_ptr_kinds h\"\n  assumes \"ObjectClass.type_wf h\"\n  assumes \"is_node_ptr_kind ptr \\<Longrightarrow> is_node_kind (the (get ptr h))\"\n  shows \"type_wf h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NodeClass.type_wf h", "using assms"], ["proof (prove)\nusing this:\n  NodeClass.type_wf (put ptr obj h)\n  ptr |\\<in>| object_ptr_kinds h\n  ObjectClass.type_wf h\n  is_node_ptr_kind ptr \\<Longrightarrow> is_node_kind (the (get ptr h))\n\ngoal (1 subgoal):\n 1. NodeClass.type_wf h", "apply(auto simp add: type_wf_defs split: option.splits if_splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y node_ptr.\n       \\<lbrakk>ptr |\\<in>| object_ptr_kinds h; ObjectClass.type_wf h;\n        is_node_kind (the (get ptr h)); is_node_ptr_kind ptr;\n        ObjectClass.type_wf (put ptr (cast y) h);\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           ptr = cast node_ptr \\<or> (\\<exists>y. get node_ptr h = Some y);\n        obj = cast y; node_ptr |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get node_ptr h = Some y", "by (metis ObjectClass.get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf bind.bind_lunit finite_set_in get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def is_node_kind_def option.exhaust_sel)"], ["", "subsection\\<open>Preserving Types\\<close>"], ["", "lemma node_ptr_kinds_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  shows \"node_ptr_kinds h = node_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. node_ptr_kinds h = node_ptr_kinds h'", "by(simp add: node_ptr_kinds_def preserved_def object_ptr_kinds_preserved_small[OF assms])"], ["", "lemma node_ptr_kinds_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h'. \\<forall>w \\<in> SW. h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n            \\<longrightarrow> (\\<forall>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h')\"\n  shows \"node_ptr_kinds h = node_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. node_ptr_kinds h = node_ptr_kinds h'", "using writes_small_big[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>reflp\n            (\\<lambda>h h'.\n                \\<forall>w\\<in>SW.\n                   ?h4 h h' \\<turnstile> w\n                   \\<rightarrow>\\<^sub>h ?h'5 h h' \\<longrightarrow>\n                   (\\<forall>object_ptr.\n                       preserved (get_M object_ptr RObject.nothing)\n                        (?h4 h h') (?h'5 h h')));\n   transp\n    (\\<lambda>h h'.\n        \\<forall>w\\<in>SW.\n           ?h4 h h' \\<turnstile> w\n           \\<rightarrow>\\<^sub>h ?h'5 h h' \\<longrightarrow>\n           (\\<forall>object_ptr.\n               preserved (get_M object_ptr RObject.nothing) (?h4 h h')\n                (?h'5 h h')))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>w\\<in>SW.\n                       ?h4 h h' \\<turnstile> w\n                       \\<rightarrow>\\<^sub>h ?h'5 h h' \\<longrightarrow>\n                       (\\<forall>object_ptr.\n                           preserved (get_M object_ptr RObject.nothing)\n                            (?h4 h h') (?h'5 h h'))\n\ngoal (1 subgoal):\n 1. node_ptr_kinds h = node_ptr_kinds h'", "apply(simp add: reflp_def transp_def preserved_def node_ptr_kinds_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ha h'a.\n        \\<lbrakk>\\<forall>x.\n                    (\\<exists>w\\<in>SW.\n                        ha x x \\<turnstile> w\n                        \\<rightarrow>\\<^sub>h h'a x x) \\<longrightarrow>\n                    (\\<forall>object_ptr.\n                        ha x x \\<turnstile> get_M object_ptr RObject.nothing\n                        \\<rightarrow>\\<^sub>r () =\n                        h'a x x\n                        \\<turnstile> get_M object_ptr RObject.nothing\n                        \\<rightarrow>\\<^sub>r ());\n         \\<forall>x y.\n            ((\\<exists>w\\<in>SW.\n                 ha x y \\<turnstile> w\n                 \\<rightarrow>\\<^sub>h h'a x y) \\<longrightarrow>\n             (\\<forall>object_ptr.\n                 ha x y \\<turnstile> get_M object_ptr RObject.nothing\n                 \\<rightarrow>\\<^sub>r () =\n                 h'a x y \\<turnstile> get_M object_ptr RObject.nothing\n                 \\<rightarrow>\\<^sub>r ())) \\<longrightarrow>\n            (\\<forall>z.\n                ((\\<exists>w\\<in>SW.\n                     ha y z \\<turnstile> w\n                     \\<rightarrow>\\<^sub>h h'a y z) \\<longrightarrow>\n                 (\\<forall>object_ptr.\n                     ha y z \\<turnstile> get_M object_ptr RObject.nothing\n                     \\<rightarrow>\\<^sub>r () =\n                     h'a y z \\<turnstile> get_M object_ptr RObject.nothing\n                     \\<rightarrow>\\<^sub>r ())) \\<longrightarrow>\n                (\\<exists>w\\<in>SW.\n                    ha x z \\<turnstile> w\n                    \\<rightarrow>\\<^sub>h h'a x z) \\<longrightarrow>\n                (\\<forall>object_ptr.\n                    ha x z \\<turnstile> get_M object_ptr RObject.nothing\n                    \\<rightarrow>\\<^sub>r () =\n                    h'a x z \\<turnstile> get_M object_ptr RObject.nothing\n                    \\<rightarrow>\\<^sub>r ()))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>w\\<in>SW.\n                              ha h h' \\<turnstile> w\n                              \\<rightarrow>\\<^sub>h h'a h\n               h') \\<longrightarrow>\n                          (\\<forall>object_ptr.\n                              ha h h'\n                              \\<turnstile> get_M object_ptr RObject.nothing\n                              \\<rightarrow>\\<^sub>r () =\n                              h'a h h'\n                              \\<turnstile> get_M object_ptr RObject.nothing\n                              \\<rightarrow>\\<^sub>r ())) \\<Longrightarrow>\n    (the \\<circ> cast) |`| ffilter is_node_ptr_kind (object_ptr_kinds h) =\n    (the \\<circ> cast) |`| ffilter is_node_ptr_kind (object_ptr_kinds h')", "by (metis assms object_ptr_kinds_preserved)"], ["", "lemma type_wf_preserved_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  assumes \"\\<And>node_ptr. preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr RNode.nothing) h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NodeClass.type_wf h = NodeClass.type_wf h'", "using type_wf_preserved allI[OF assms(2), of id, simplified]"], ["proof (prove)\nusing this:\n  ObjectClass.type_wf ?h = ObjectClass.type_wf ?h'\n  \\<forall>x. preserved (get_M x RNode.nothing) h h'\n\ngoal (1 subgoal):\n 1. NodeClass.type_wf h = NodeClass.type_wf h'", "apply(auto simp add: type_wf_defs)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>node_ptr.\n       \\<lbrakk>\\<And>h h'. ObjectClass.type_wf h = ObjectClass.type_wf h';\n        \\<forall>x. preserved (get_M x RNode.nothing) h h';\n        ObjectClass.type_wf h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           \\<exists>y. get node_ptr h = Some y;\n        node_ptr |\\<in>| node_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get node_ptr h' = Some y\n 2. \\<And>node_ptr.\n       \\<lbrakk>\\<And>h h'. ObjectClass.type_wf h = ObjectClass.type_wf h';\n        \\<forall>x. preserved (get_M x RNode.nothing) h h';\n        ObjectClass.type_wf h';\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h').\n           \\<exists>y. get node_ptr h' = Some y;\n        node_ptr |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get node_ptr h = Some y", "apply(auto simp add: preserved_def get_M_defs node_ptr_kinds_small[OF assms(1)]\n      split: option.splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>node_ptr.\n       \\<lbrakk>\\<forall>x.\n                   ((\\<exists>y. get x h = Some y) \\<or>\n                    get x h' = None) \\<and>\n                   (get x h = None \\<or> (\\<exists>y. get x h' = Some y));\n        ObjectClass.type_wf h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h').\n           \\<exists>y. get node_ptr h = Some y;\n        node_ptr |\\<in>| node_ptr_kinds h';\n        \\<And>h h'. ObjectClass.type_wf h = ObjectClass.type_wf h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get node_ptr h' = Some y\n 2. \\<And>node_ptr.\n       \\<lbrakk>\\<And>h h'. ObjectClass.type_wf h = ObjectClass.type_wf h';\n        \\<forall>x. preserved (get_M x RNode.nothing) h h';\n        ObjectClass.type_wf h';\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h').\n           \\<exists>y. get node_ptr h' = Some y;\n        node_ptr |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get node_ptr h = Some y", "apply (metis notin_fset option.simps(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>node_ptr.\n       \\<lbrakk>\\<And>h h'. ObjectClass.type_wf h = ObjectClass.type_wf h';\n        \\<forall>x. preserved (get_M x RNode.nothing) h h';\n        ObjectClass.type_wf h';\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h').\n           \\<exists>y. get node_ptr h' = Some y;\n        node_ptr |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get node_ptr h = Some y", "by(auto simp add: preserved_def get_M_defs node_ptr_kinds_small[OF assms(1)]\n      split: option.splits, force)[1]"], ["", "lemma type_wf_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n           \\<Longrightarrow> \\<forall>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n           \\<Longrightarrow> \\<forall>node_ptr. preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr RNode.nothing) h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NodeClass.type_wf h = NodeClass.type_wf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. NodeClass.type_wf h = NodeClass.type_wf h'", "have \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h = NodeClass.type_wf h'", "using assms type_wf_preserved_small"], ["proof (prove)\nusing this:\n  writes SW setter h h'\n  h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>object_ptr.\n                       preserved (get_M object_ptr RObject.nothing) ?h ?h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>node_ptr.\n                       preserved (get_M node_ptr RNode.nothing) ?h ?h'\n  \\<lbrakk>\\<And>object_ptr.\n              preserved (get_M object_ptr RObject.nothing) ?h ?h';\n   \\<And>node_ptr. preserved (get_M node_ptr RNode.nothing) ?h ?h'\\<rbrakk>\n  \\<Longrightarrow> NodeClass.type_wf ?h = NodeClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> NodeClass.type_wf h = NodeClass.type_wf h'", "by fast"], ["proof (state)\nthis:\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> NodeClass.type_wf ?h = NodeClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. NodeClass.type_wf h = NodeClass.type_wf h'", "with assms(1) assms(2)"], ["proof (chain)\npicking this:\n  writes SW setter h h'\n  h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> NodeClass.type_wf ?h = NodeClass.type_wf ?h'", "show ?thesis"], ["proof (prove)\nusing this:\n  writes SW setter h h'\n  h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> NodeClass.type_wf ?h = NodeClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. NodeClass.type_wf h = NodeClass.type_wf h'", "apply(rule writes_small_big)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> ?w1 h h' w \\<in> SW\n 2. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> h \\<turnstile> ?w1 h h' w \\<rightarrow>\\<^sub>h h'\n 3. reflp (\\<lambda>h h'. NodeClass.type_wf h = NodeClass.type_wf h')\n 4. transp (\\<lambda>h h'. NodeClass.type_wf h = NodeClass.type_wf h')", "by(auto simp add: reflp_def transp_def)"], ["proof (state)\nthis:\n  NodeClass.type_wf h = NodeClass.type_wf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}