{"file_name": "/home/qj213/afp-2021-10-22/thys/Core_DOM/common/preliminaries/Heap_Error_Monad.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Core_DOM", "problem_names": ["lemma returns_result_eq [elim]: \"h \\<turnstile> f \\<rightarrow>\\<^sub>r y \\<Longrightarrow> h \\<turnstile> f \\<rightarrow>\\<^sub>r y' \\<Longrightarrow> y = y'\"", "lemma returns_heap_eq [elim]: \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> f \\<rightarrow>\\<^sub>h h'' \\<Longrightarrow> h' = h''\"", "lemma return_result_heap_code [code]:\n  \"returns_result_heap h p r h' \\<longleftrightarrow> (case h \\<turnstile> p of Inr (r', h'') \\<Rightarrow> r = r' \\<and> h' = h'' | Inl _ \\<Rightarrow> False)\"", "lemma is_OK_returns_result_I [intro]: \"h \\<turnstile> f \\<rightarrow>\\<^sub>r y \\<Longrightarrow> h \\<turnstile> ok f\"", "lemma is_OK_returns_result_E [elim]:\n  assumes \"h \\<turnstile> ok f\"\n  obtains x where \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\"", "lemma is_OK_returns_heap_I [intro]: \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> ok f\"", "lemma is_OK_returns_heap_E [elim]:\n  assumes \"h \\<turnstile> ok f\"\n  obtains h' where \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\"", "lemma select_result_I:\n  assumes \"h \\<turnstile> ok f\"\n    and \"\\<And>x. h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<Longrightarrow> P x\"\n  shows \"P |h \\<turnstile> f|\\<^sub>r\"", "lemma select_result_I2 [simp]:\n  assumes \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\"\n  shows \"|h \\<turnstile> f|\\<^sub>r = x\"", "lemma returns_result_select_result [simp]:\n  assumes \"h \\<turnstile> ok f\"\n  shows \"h \\<turnstile> f \\<rightarrow>\\<^sub>r |h \\<turnstile> f|\\<^sub>r\"", "lemma select_result_E:\n  assumes \"P |h \\<turnstile> f|\\<^sub>r\" and \"h \\<turnstile> ok f\" \n  obtains x where \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"P x\"", "lemma select_result_eq: \"(\\<And>x .h \\<turnstile> f \\<rightarrow>\\<^sub>r x = h' \\<turnstile> f \\<rightarrow>\\<^sub>r x) \\<Longrightarrow> |h \\<turnstile> f|\\<^sub>r = |h' \\<turnstile> f|\\<^sub>r\"", "lemma error_bind [iff]: \"(error e \\<bind> g) = error e\"", "lemma error_returns_result [simp]: \"\\<not> (h \\<turnstile> error e \\<rightarrow>\\<^sub>r y)\"", "lemma error_returns_heap [simp]: \"\\<not> (h \\<turnstile> error e \\<rightarrow>\\<^sub>h h')\"", "lemma error_returns_error [simp]: \"h \\<turnstile> error e \\<rightarrow>\\<^sub>e e\"", "lemma return_ok [simp]: \"h \\<turnstile> ok (return x)\"", "lemma return_bind [iff]: \"(return x \\<bind> g) = g x\"", "lemma return_id [simp]: \"f \\<bind> return = f\"", "lemma return_returns_result [iff]: \"(h \\<turnstile> return x \\<rightarrow>\\<^sub>r y) = (x = y)\"", "lemma return_returns_heap [iff]: \"(h \\<turnstile> return x \\<rightarrow>\\<^sub>h h') = (h = h')\"", "lemma return_returns_error [iff]: \"\\<not> h \\<turnstile> return x \\<rightarrow>\\<^sub>e e\"", "lemma noop_returns_heap [simp]: \"h \\<turnstile> noop \\<rightarrow>\\<^sub>h h' \\<longleftrightarrow> h = h'\"", "lemma get_heap_ok [simp]: \"h \\<turnstile> ok (get_heap)\"", "lemma get_heap_returns_result [simp]: \"(h \\<turnstile> get_heap \\<bind> (\\<lambda>h'. f h') \\<rightarrow>\\<^sub>r x) = (h \\<turnstile> f h \\<rightarrow>\\<^sub>r x)\"", "lemma get_heap_returns_heap [simp]: \"(h \\<turnstile> get_heap \\<bind> (\\<lambda>h'. f h') \\<rightarrow>\\<^sub>h h'') = (h \\<turnstile> f h \\<rightarrow>\\<^sub>h h'')\"", "lemma get_heap_is_OK [simp]: \"(h \\<turnstile> ok (get_heap \\<bind> (\\<lambda>h'. f h'))) = (h \\<turnstile> ok (f h))\"", "lemma get_heap_E [elim]: \"(h \\<turnstile> get_heap \\<rightarrow>\\<^sub>r x) \\<Longrightarrow> x = h\"", "lemma return_heap_E [iff]: \"(h \\<turnstile> return_heap h' \\<rightarrow>\\<^sub>h h'') = (h'' = h')\"", "lemma return_heap_returns_result [simp]: \"h \\<turnstile> return_heap h' \\<rightarrow>\\<^sub>r ()\"", "lemma return_pure [simp]: \"pure (return x) h\"", "lemma error_pure [simp]: \"pure (error e) h\"", "lemma noop_pure [simp]: \"pure (noop) h\"", "lemma get_pure [simp]: \"pure get_heap h\"", "lemma pure_returns_heap_eq:\n  \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> pure f h \\<Longrightarrow> h = h'\"", "lemma pure_eq_iff:     \n  \"(\\<forall>h' x. h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<longrightarrow> h \\<turnstile> f \\<rightarrow>\\<^sub>h h' \\<longrightarrow> h = h') \\<longleftrightarrow> pure f h\"", "lemma bind_assoc [simp]:\n  \"((bind f g) \\<bind> h) = (f \\<bind> (\\<lambda>x. (g x \\<bind> h)))\"", "lemma bind_returns_result_E:\n  assumes \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y\"\n  obtains x h' where \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\" and \"h' \\<turnstile> g x \\<rightarrow>\\<^sub>r y\"", "lemma bind_returns_result_E2:\n  assumes \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y\" and \"pure f h\"\n  obtains x where \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h \\<turnstile> g x \\<rightarrow>\\<^sub>r y\"", "lemma bind_returns_result_E3:\n  assumes \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"pure f h\"\n  shows \"h \\<turnstile> g x \\<rightarrow>\\<^sub>r y\"", "lemma bind_returns_result_E4:\n  assumes \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" \n  obtains h' where \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\" and \"h' \\<turnstile> g x \\<rightarrow>\\<^sub>r y\"", "lemma bind_returns_heap_E:\n  assumes \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>h h''\"\n  obtains x h' where \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\" and \"h' \\<turnstile> g x \\<rightarrow>\\<^sub>h h''\"", "lemma bind_returns_heap_E2 [elim]:\n  assumes \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>h h'\" and \"pure f h\"\n  obtains x where \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h \\<turnstile> g x \\<rightarrow>\\<^sub>h h'\"", "lemma bind_returns_heap_E3 [elim]:\n  assumes \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>h h'\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"pure f h\" \n  shows \"h \\<turnstile> g x \\<rightarrow>\\<^sub>h h'\"", "lemma bind_returns_heap_E4:\n  assumes \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>h h''\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\"\n  obtains x where \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h' \\<turnstile> g x \\<rightarrow>\\<^sub>h h''\"", "lemma bind_returns_error_I [intro]:\n  assumes \"h \\<turnstile> f \\<rightarrow>\\<^sub>e e\"\n  shows \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>e e\"", "lemma bind_returns_error_I3:\n  assumes \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\" and \"h' \\<turnstile> g x \\<rightarrow>\\<^sub>e e\"\n  shows \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>e e\"", "lemma bind_returns_error_I2 [intro]:\n  assumes \"pure f h\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h \\<turnstile> g x \\<rightarrow>\\<^sub>e e\"\n  shows \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>e e\"", "lemma bind_is_OK_E [elim]:\n  assumes \"h \\<turnstile> ok (f \\<bind> g)\"\n  obtains x h' where \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\" and \"h' \\<turnstile> ok (g x)\"", "lemma bind_is_OK_E2:\n  assumes \"h \\<turnstile> ok (f \\<bind> g)\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\"\n  obtains h' where \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\" and \"h' \\<turnstile> ok (g x)\"", "lemma bind_returns_result_I [intro]:\n  assumes \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\" and \"h' \\<turnstile> g x \\<rightarrow>\\<^sub>r y\"\n  shows \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y\"", "lemma bind_pure_returns_result_I [intro]:\n  assumes \"pure f h\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h \\<turnstile> g x \\<rightarrow>\\<^sub>r y\"\n  shows \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y\"", "lemma bind_pure_returns_result_I2 [intro]:\n  assumes \"pure f h\" and \"h \\<turnstile> ok f\" and \"\\<And>x. h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<Longrightarrow> h \\<turnstile> g x \\<rightarrow>\\<^sub>r y\"\n  shows \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y\"", "lemma bind_returns_heap_I [intro]:\n  assumes \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\" and \"h' \\<turnstile> g x \\<rightarrow>\\<^sub>h h''\"\n  shows \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>h h''\"", "lemma bind_returns_heap_I2 [intro]:\n  assumes \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\" and \"\\<And>x. h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<Longrightarrow> h' \\<turnstile> g x \\<rightarrow>\\<^sub>h h''\"\n  shows \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>h h''\"", "lemma bind_is_OK_I [intro]:\n  assumes \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\" and \"h' \\<turnstile> ok (g x)\"\n  shows \"h \\<turnstile> ok (f \\<bind> g)\"", "lemma bind_is_OK_I2 [intro]:\n  assumes \"h \\<turnstile> ok f\" and \"\\<And>x h'. h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<Longrightarrow> h \\<turnstile> f \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h' \\<turnstile> ok (g x)\"\n  shows \"h \\<turnstile> ok (f \\<bind> g)\"", "lemma bind_is_OK_pure_I [intro]:\n  assumes \"pure f h\" and \"h \\<turnstile> ok f\" and \"\\<And>x. h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<Longrightarrow> h \\<turnstile> ok (g x)\"\n  shows \"h \\<turnstile> ok (f \\<bind> g)\"", "lemma bind_pure_I:\n  assumes \"pure f h\" and \"\\<And>x. h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<Longrightarrow> pure (g x) h\"\n  shows \"pure (f \\<bind> g) h\"", "lemma pure_pure:\n  assumes \"h \\<turnstile> ok f\" and \"pure f h\"\n  shows \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h\"", "lemma bind_returns_error_eq: \n  assumes \"h \\<turnstile> f \\<rightarrow>\\<^sub>e e\"\n    and \"h \\<turnstile> g \\<rightarrow>\\<^sub>e e\"\n  shows \"h \\<turnstile> f = h \\<turnstile> g\"", "lemma map_M_ok_I [intro]: \n  \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> h \\<turnstile> ok (f x)) \\<Longrightarrow> (\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (f x) h) \\<Longrightarrow> h \\<turnstile> ok (map_M f xs)\"", "lemma map_M_pure_I : \"\\<And>h. (\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (f x) h) \\<Longrightarrow> pure (map_M f xs) h\"", "lemma map_M_pure_E :\n  assumes \"h \\<turnstile> map_M g xs \\<rightarrow>\\<^sub>r ys\" and \"x \\<in> set xs\" and \"\\<And>x h. x \\<in> set xs \\<Longrightarrow> pure (g x) h\"\n  obtains y where \"h \\<turnstile> g x \\<rightarrow>\\<^sub>r y\" and \"y \\<in> set ys\"", "lemma map_M_pure_E2:\n  assumes \"h \\<turnstile> map_M g xs \\<rightarrow>\\<^sub>r ys\" and \"y \\<in> set ys\" and \"\\<And>x h. x \\<in> set xs \\<Longrightarrow> pure (g x) h\"\n  obtains x where \"h \\<turnstile> g x \\<rightarrow>\\<^sub>r y\" and \"x \\<in> set xs\"", "lemma pure_forall_M_I: \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h) \\<Longrightarrow> pure (forall_M P xs) h\"", "lemma fold_M_pure_I : \"(\\<And>d x. pure (f d x) h) \\<Longrightarrow> (\\<And>d. pure (fold_M f d xs) h)\"", "lemma filter_M_pure_I [intro]: \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h) \\<Longrightarrow> pure (filter_M P xs)h\"", "lemma filter_M_is_OK_I [intro]:\n  \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> h \\<turnstile> ok (P x)) \\<Longrightarrow> (\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h) \\<Longrightarrow> h \\<turnstile> ok (filter_M P xs)\"", "lemma filter_M_not_more_elements:\n  assumes \"h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys\" and \"\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h\" and \"x \\<in> set ys\"\n  shows \"x \\<in> set xs\"", "lemma filter_M_in_result_if_ok:\n  assumes \"h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys\" and \"\\<And>h x. x \\<in> set xs \\<Longrightarrow> pure (P x) h\" and \"x \\<in> set xs\" and\n    \"h \\<turnstile> P x \\<rightarrow>\\<^sub>r True\"\n  shows \"x \\<in> set ys\"", "lemma filter_M_holds_for_result:\n  assumes \"h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys\" and \"x \\<in> set ys\" and \"\\<And>x h. x \\<in> set xs \\<Longrightarrow> pure (P x) h\"\n  shows \"h \\<turnstile> P x \\<rightarrow>\\<^sub>r True\"", "lemma filter_M_empty_I:\n  assumes \"\\<And>x. pure (P x) h\"\n    and \"\\<forall>x \\<in> set xs. h \\<turnstile> P x \\<rightarrow>\\<^sub>r False\"\n  shows \"h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r []\"", "lemma filter_M_subset_2: \"h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys \\<Longrightarrow> h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys' \n                          \\<Longrightarrow> (\\<And>x. pure (P x) h) \\<Longrightarrow> (\\<And>x. pure (P x) h') \n                          \\<Longrightarrow> (\\<forall>b. \\<forall>x \\<in> set xs. h \\<turnstile> P x \\<rightarrow>\\<^sub>r True \\<longrightarrow> h' \\<turnstile> P x \\<rightarrow>\\<^sub>r b \\<longrightarrow> b) \n                          \\<Longrightarrow> set ys \\<subseteq> set ys'\"", "lemma filter_M_subset: \"h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys \\<Longrightarrow> set ys \\<subseteq> set xs\"", "lemma filter_M_distinct: \"h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys \\<Longrightarrow> distinct xs \\<Longrightarrow> distinct ys\"", "lemma filter_M_filter: \"h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys \\<Longrightarrow> (\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h) \n                       \\<Longrightarrow> (\\<forall>x \\<in> set xs. h \\<turnstile> ok P x) \\<and> ys = filter (\\<lambda>x. |h \\<turnstile> P x|\\<^sub>r) xs\"", "lemma filter_M_filter2: \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h \\<and>  h \\<turnstile> ok P x) \n                       \\<Longrightarrow> filter (\\<lambda>x. |h \\<turnstile> P x|\\<^sub>r) xs = ys \\<Longrightarrow> h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys\"", "lemma filter_ex1: \"\\<exists>!x \\<in> set xs. P x \\<Longrightarrow> P x \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow> distinct xs \n                  \\<Longrightarrow> filter P xs = [x]\"", "lemma filter_M_ex1:\n  assumes \"h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys\"\n    and \"x \\<in> set xs\"\n    and \"\\<exists>!x \\<in> set xs. h \\<turnstile> P x \\<rightarrow>\\<^sub>r True\"\n    and \"\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h\"\n    and \"distinct xs\"\n    and \"h \\<turnstile> P x \\<rightarrow>\\<^sub>r True\"\n  shows \"ys = [x]\"", "lemma filter_M_eq:\n  assumes \"\\<And>x. pure (P x) h\" and \"\\<And>x. pure (P x) h'\"\n    and \"\\<And>b x. x \\<in> set xs \\<Longrightarrow> h \\<turnstile> P x \\<rightarrow>\\<^sub>r b = h' \\<turnstile> P x \\<rightarrow>\\<^sub>r b\"\n  shows \"h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys \\<longleftrightarrow> h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys\"", "lemma map_filter_M_pure: \"(\\<And>x h. x \\<in> set xs \\<Longrightarrow> pure (f x) h) \\<Longrightarrow> pure (map_filter_M f xs) h\"", "lemma map_filter_M_pure_E:\n  assumes \"h \\<turnstile> (map_filter_M::('x \\<Rightarrow> ('heap, 'e, 'y option) prog) \\<Rightarrow> 'x list\n  \\<Rightarrow> ('heap, 'e, 'y list) prog) f xs \\<rightarrow>\\<^sub>r ys\" and \"y \\<in> set ys\" and \"\\<And>x h. x \\<in> set xs \\<Longrightarrow> pure (f x) h\"\n  obtains x where \"h \\<turnstile> f x \\<rightarrow>\\<^sub>r Some y\" and \"x \\<in> set xs\"", "lemma iterate_M_concat:\n  assumes \"h \\<turnstile> iterate_M xs \\<rightarrow>\\<^sub>h h'\"\n    and \"h' \\<turnstile> iterate_M ys \\<rightarrow>\\<^sub>h h''\"\n  shows \"h \\<turnstile> iterate_M (xs @ ys) \\<rightarrow>\\<^sub>h h''\"", "lemma execute_bind_simp:\n  assumes \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\"\n  shows \"h \\<turnstile> f \\<bind> g = h' \\<turnstile> g x\"", "lemma bind_cong [fundef_cong]:\n  fixes f1 f2 :: \"('heap, 'e, 'result) prog\"\n    and g1 g2 :: \"'result \\<Rightarrow> ('heap, 'e, 'result2) prog\"\n  assumes \"h \\<turnstile> f1 = h \\<turnstile> f2\"\n    and \"\\<And>y h'. h \\<turnstile> f1 \\<rightarrow>\\<^sub>r y \\<Longrightarrow> h \\<turnstile> f1 \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h' \\<turnstile> g1 y = h' \\<turnstile> g2 y\"\n  shows \"h \\<turnstile> (f1 \\<bind> g1) = h \\<turnstile> (f2 \\<bind> g2)\"", "lemma bind_cong_2:\n  assumes \"pure f h\" and \"pure f h'\"\n    and \"\\<And>x. h \\<turnstile> f \\<rightarrow>\\<^sub>r x = h' \\<turnstile> f \\<rightarrow>\\<^sub>r x\"\n    and \"\\<And>x. h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<Longrightarrow> h \\<turnstile> g x \\<rightarrow>\\<^sub>r y = h' \\<turnstile> g x \\<rightarrow>\\<^sub>r y'\"\n  shows \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y = h' \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y'\"", "lemma bind_case_cong [fundef_cong]:\n  assumes \"x = x'\" and \"\\<And>a. x = Some a \\<Longrightarrow> f a h = f' a h\"\n  shows \"(case x of Some a \\<Rightarrow> f a | None \\<Rightarrow> g) h = (case x' of Some a \\<Rightarrow> f' a | None \\<Rightarrow> g) h\"", "lemma preserved_code [code]:\n  \"preserved f h h' = (((h \\<turnstile> ok f) \\<and> (h' \\<turnstile> ok f) \\<and> |h \\<turnstile> f|\\<^sub>r = |h' \\<turnstile> f|\\<^sub>r) \\<or> ((\\<not>h \\<turnstile> ok f) \\<and> (\\<not>h' \\<turnstile> ok f)))\"", "lemma reflp_preserved_f [simp]: \"reflp (preserved f)\"", "lemma transp_preserved_f [simp]: \"transp (preserved f)\"", "lemma reads_singleton [simp]: \"reads {preserved f} f h h'\"", "lemma reads_bind_pure:\n  assumes \"pure f h\" and \"pure f h'\"\n    and \"reads S f h h'\"\n    and \"\\<And>x. h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<Longrightarrow> reads S (g x) h h'\"\n  shows \"reads S (f \\<bind> g) h h'\"", "lemma reads_insert_writes_set_left:\n  \"\\<forall>P \\<in> S. reflp P \\<and> transp P \\<Longrightarrow> reads {getter} f h h' \\<Longrightarrow> reads (insert getter S) f h h'\"", "lemma reads_insert_writes_set_right:\n  \"reflp getter \\<Longrightarrow> transp getter \\<Longrightarrow> reads S f h h' \\<Longrightarrow> reads (insert getter S) f h h'\"", "lemma reads_subset:\n  \"reads S f h h' \\<Longrightarrow> \\<forall>P \\<in> S' - S. reflp P \\<and> transp P \\<Longrightarrow> S \\<subseteq> S' \\<Longrightarrow> reads S' f h h'\"", "lemma return_reads [simp]: \"reads {} (return x) h h'\"", "lemma error_reads [simp]: \"reads {} (error e) h h'\"", "lemma noop_reads [simp]: \"reads {} noop h h'\"", "lemma filter_M_reads:\n  assumes \"\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h\" and \"\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h'\"\n    and \"\\<And>x. x \\<in> set xs \\<Longrightarrow> reads S (P x) h h'\"\n    and \"\\<forall>P \\<in> S. reflp P \\<and> transp P\"\n  shows \"reads S (filter_M P xs) h h'\"", "lemma writes_singleton [simp]: \"writes (all_args f) (f a) h h'\"", "lemma writes_singleton2 [simp]: \"writes {f} f h h'\"", "lemma writes_union_left_I:\n  assumes \"writes S f h h'\"\n  shows \"writes (S \\<union> S') f h h'\"", "lemma writes_union_right_I:\n  assumes \"writes S' f h h'\"\n  shows \"writes (S \\<union> S') f h h'\"", "lemma writes_union_minus_split:\n  assumes \"writes (S - S2) f h h'\"\n    and \"writes (S' - S2) f h h'\"\n  shows \"writes ((S \\<union> S') - S2) f h h'\"", "lemma writes_subset: \"writes S f h h' \\<Longrightarrow> S \\<subseteq> S' \\<Longrightarrow> writes S' f h h'\"", "lemma writes_error [simp]: \"writes S (error e) h h'\"", "lemma writes_not_ok [simp]: \"\\<not>h \\<turnstile> ok f \\<Longrightarrow> writes S f h h'\"", "lemma writes_pure [simp]:\n  assumes \"pure f h\"\n  shows \"writes S f h h'\"", "lemma writes_bind:\n  assumes \"\\<And>h2. writes S f h h2\" \n  assumes \"\\<And>x h2. h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<Longrightarrow> h \\<turnstile> f \\<rightarrow>\\<^sub>h h2 \\<Longrightarrow> writes S (g x) h2 h'\"\n  shows \"writes S (f \\<bind> g) h h'\"", "lemma writes_bind_pure:\n  assumes \"pure f h\"\n  assumes \"\\<And>x. h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<Longrightarrow> writes S (g x) h h'\"\n  shows \"writes S (f \\<bind> g) h h'\"", "lemma writes_small_big:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow>  h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> P h h'\"\n  assumes \"reflp P\"\n  assumes \"transp P\"\n  shows \"P h h'\"", "lemma reads_writes_preserved:\n  assumes \"reads SR getter h h'\"\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h'. \\<forall>w \\<in> SW. h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<longrightarrow> (\\<forall>r \\<in> SR. r h h')\"\n  shows \"h \\<turnstile> getter \\<rightarrow>\\<^sub>r x \\<longleftrightarrow> h' \\<turnstile> getter \\<rightarrow>\\<^sub>r x\"", "lemma reads_writes_separate_forwards:\n  assumes \"reads SR getter h h'\"\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> getter \\<rightarrow>\\<^sub>r x\"\n  assumes \"\\<And>h h'. \\<forall>w \\<in> SW. h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<longrightarrow> (\\<forall>r \\<in> SR. r h h')\"\n  shows \"h' \\<turnstile> getter \\<rightarrow>\\<^sub>r x\"", "lemma reads_writes_separate_backwards:\n  assumes \"reads SR getter h h'\"\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h' \\<turnstile> getter \\<rightarrow>\\<^sub>r x\"\n  assumes \"\\<And>h h'. \\<forall>w \\<in> SW. h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<longrightarrow> (\\<forall>r \\<in> SR. r h h')\"\n  shows \"h \\<turnstile> getter \\<rightarrow>\\<^sub>r x\""], "translations": [["", "lemma returns_result_eq [elim]: \"h \\<turnstile> f \\<rightarrow>\\<^sub>r y \\<Longrightarrow> h \\<turnstile> f \\<rightarrow>\\<^sub>r y' \\<Longrightarrow> y = y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> f \\<rightarrow>\\<^sub>r y;\n     h \\<turnstile> f \\<rightarrow>\\<^sub>r y'\\<rbrakk>\n    \\<Longrightarrow> y = y'", "by(auto simp add: returns_result_def split: sum.splits)"], ["", "definition \n  returns_heap :: \"'heap \\<Rightarrow> ('heap, 'e, 'result) prog \\<Rightarrow> 'heap \\<Rightarrow> bool\" \n  (\"((_)/ \\<turnstile> (_)/ \\<rightarrow>\\<^sub>h (_))\" [60, 35, 61] 65)\n  where\n    \"returns_heap h p h' \\<longleftrightarrow> (case h \\<turnstile> p of Inr (_ , h'') \\<Rightarrow> h' = h'' | Inl _ \\<Rightarrow> False)\""], ["", "fun select_heap (\"|(_)|\\<^sub>h\")\n  where\n    \"select_heap (Inr ( _, h)) = h\"\n  | \"select_heap (Inl _) = undefined\""], ["", "lemma returns_heap_eq [elim]: \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> f \\<rightarrow>\\<^sub>h h'' \\<Longrightarrow> h' = h''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> f \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> f \\<rightarrow>\\<^sub>h h''\\<rbrakk>\n    \\<Longrightarrow> h' = h''", "by(auto simp add: returns_heap_def split: sum.splits)"], ["", "definition \n  returns_result_heap :: \"'heap \\<Rightarrow> ('heap, 'e, 'result) prog \\<Rightarrow> 'result \\<Rightarrow> 'heap \\<Rightarrow> bool\" \n  (\"((_)/ \\<turnstile> (_)/ \\<rightarrow>\\<^sub>r (_) \\<rightarrow>\\<^sub>h (_))\" [60, 35, 61, 62] 65)\n  where\n    \"returns_result_heap h p r h' \\<longleftrightarrow> h \\<turnstile> p \\<rightarrow>\\<^sub>r r \\<and> h \\<turnstile> p \\<rightarrow>\\<^sub>h h'\""], ["", "lemma return_result_heap_code [code]:\n  \"returns_result_heap h p r h' \\<longleftrightarrow> (case h \\<turnstile> p of Inr (r', h'') \\<Rightarrow> r = r' \\<and> h' = h'' | Inl _ \\<Rightarrow> False)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> p \\<rightarrow>\\<^sub>r r \\<rightarrow>\\<^sub>h h' =\n    (case h \\<turnstile> p of Inl x \\<Rightarrow> False\n     | Inr (r', h'') \\<Rightarrow> r = r' \\<and> h' = h'')", "by(auto simp add: returns_result_heap_def returns_result_def returns_heap_def split: sum.splits)"], ["", "fun select_result_heap (\"|(_)|\\<^sub>r\\<^sub>h\")\n  where\n    \"select_result_heap (Inr (r, h)) = (r, h)\"\n  | \"select_result_heap (Inl _) = undefined\""], ["", "definition \n  returns_error :: \"'heap \\<Rightarrow> ('heap, 'e, 'result) prog \\<Rightarrow> 'e \\<Rightarrow> bool\" \n  (\"((_)/ \\<turnstile> (_)/ \\<rightarrow>\\<^sub>e (_))\" [60, 35, 61] 65)\n  where\n    \"returns_error h p e = (case h \\<turnstile> p of Inr _ \\<Rightarrow> False | Inl e' \\<Rightarrow> e = e')\""], ["", "definition is_OK :: \"'heap \\<Rightarrow> ('heap, 'e, 'result) prog \\<Rightarrow> bool\" (\"((_)/ \\<turnstile> ok (_))\" [75, 75])\n  where\n    \"is_OK h p = (case h \\<turnstile> p of Inr _ \\<Rightarrow> True | Inl _ \\<Rightarrow> False)\""], ["", "lemma is_OK_returns_result_I [intro]: \"h \\<turnstile> f \\<rightarrow>\\<^sub>r y \\<Longrightarrow> h \\<turnstile> ok f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<rightarrow>\\<^sub>r y \\<Longrightarrow>\n    h \\<turnstile> ok f", "by(auto simp add: is_OK_def returns_result_def split: sum.splits)"], ["", "lemma is_OK_returns_result_E [elim]:\n  assumes \"h \\<turnstile> ok f\"\n  obtains x where \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> ok f\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: is_OK_def returns_result_def split: sum.splits)"], ["", "lemma is_OK_returns_heap_I [intro]: \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> ok f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    h \\<turnstile> ok f", "by(auto simp add: is_OK_def returns_heap_def split: sum.splits)"], ["", "lemma is_OK_returns_heap_E [elim]:\n  assumes \"h \\<turnstile> ok f\"\n  obtains h' where \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h'.\n        h \\<turnstile> f \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> ok f\n\ngoal (1 subgoal):\n 1. (\\<And>h'.\n        h \\<turnstile> f \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: is_OK_def returns_heap_def split: sum.splits)"], ["", "lemma select_result_I:\n  assumes \"h \\<turnstile> ok f\"\n    and \"\\<And>x. h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<Longrightarrow> P x\"\n  shows \"P |h \\<turnstile> f|\\<^sub>r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P |h \\<turnstile> f|\\<^sub>r", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> ok f\n  h \\<turnstile> f \\<rightarrow>\\<^sub>r ?x \\<Longrightarrow> P ?x\n\ngoal (1 subgoal):\n 1. P |h \\<turnstile> f|\\<^sub>r", "by(auto simp add: is_OK_def returns_result_def split: sum.splits)"], ["", "lemma select_result_I2 [simp]:\n  assumes \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\"\n  shows \"|h \\<turnstile> f|\\<^sub>r = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |h \\<turnstile> f|\\<^sub>r = x", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> f \\<rightarrow>\\<^sub>r x\n\ngoal (1 subgoal):\n 1. |h \\<turnstile> f|\\<^sub>r = x", "by(auto simp add: is_OK_def returns_result_def split: sum.splits)"], ["", "lemma returns_result_select_result [simp]:\n  assumes \"h \\<turnstile> ok f\"\n  shows \"h \\<turnstile> f \\<rightarrow>\\<^sub>r |h \\<turnstile> f|\\<^sub>r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<rightarrow>\\<^sub>r |h \\<turnstile> f|\\<^sub>r", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> ok f\n\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<rightarrow>\\<^sub>r |h \\<turnstile> f|\\<^sub>r", "by (simp add: select_result_I)"], ["", "lemma select_result_E:\n  assumes \"P |h \\<turnstile> f|\\<^sub>r\" and \"h \\<turnstile> ok f\" \n  obtains x where \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>h \\<turnstile> f \\<rightarrow>\\<^sub>r x; P x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  P |h \\<turnstile> f|\\<^sub>r\n  h \\<turnstile> ok f\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>h \\<turnstile> f \\<rightarrow>\\<^sub>r x; P x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: is_OK_def returns_result_def split: sum.splits)"], ["", "lemma select_result_eq: \"(\\<And>x .h \\<turnstile> f \\<rightarrow>\\<^sub>r x = h' \\<turnstile> f \\<rightarrow>\\<^sub>r x) \\<Longrightarrow> |h \\<turnstile> f|\\<^sub>r = |h' \\<turnstile> f|\\<^sub>r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        h \\<turnstile> f \\<rightarrow>\\<^sub>r x =\n        h' \\<turnstile> f \\<rightarrow>\\<^sub>r x) \\<Longrightarrow>\n    |h \\<turnstile> f|\\<^sub>r = |h' \\<turnstile> f|\\<^sub>r", "by (metis (no_types, lifting) is_OK_def old.sum.simps(6) select_result.elims \n      select_result_I select_result_I2)"], ["", "definition error :: \"'e \\<Rightarrow> ('heap, 'e, 'result) prog\"\n  where\n    \"error exception = Prog (\\<lambda>h. Inl exception)\""], ["", "lemma error_bind [iff]: \"(error e \\<bind> g) = error e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. error e \\<bind> g = error e", "unfolding error_def bind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Prog\n     (\\<lambda>h.\n         case the_prog (Prog (\\<lambda>h. Inl e)) h of\n         Inl x \\<Rightarrow> Inl x\n         | Inr (xa, xb) \\<Rightarrow> the_prog (g xa) xb) =\n    Prog (\\<lambda>h. Inl e)", "by auto"], ["", "lemma error_returns_result [simp]: \"\\<not> (h \\<turnstile> error e \\<rightarrow>\\<^sub>r y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> h \\<turnstile> error e \\<rightarrow>\\<^sub>r y", "unfolding returns_result_def error_def execute_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (case the_prog (Prog (\\<lambda>h. Inl e)) h of\n            Inl x \\<Rightarrow> False | Inr (r', xa) \\<Rightarrow> y = r')", "by auto"], ["", "lemma error_returns_heap [simp]: \"\\<not> (h \\<turnstile> error e \\<rightarrow>\\<^sub>h h')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> h \\<turnstile> error e \\<rightarrow>\\<^sub>h h'", "unfolding returns_heap_def error_def execute_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (case the_prog (Prog (\\<lambda>h. Inl e)) h of\n            Inl x \\<Rightarrow> False | Inr (xa, xb) \\<Rightarrow> h' = xb)", "by auto"], ["", "lemma error_returns_error [simp]: \"h \\<turnstile> error e \\<rightarrow>\\<^sub>e e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> error e \\<rightarrow>\\<^sub>e e", "unfolding returns_error_def error_def execute_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. case the_prog (Prog (\\<lambda>h. Inl e)) h of Inl x \\<Rightarrow> e = x\n    | Inr x \\<Rightarrow> False", "by auto"], ["", "definition return :: \"'result \\<Rightarrow> ('heap, 'e, 'result) prog\"\n  where\n    \"return result = Prog (\\<lambda>h. Inr (result, h))\""], ["", "lemma return_ok [simp]: \"h \\<turnstile> ok (return x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> ok return x", "by(simp add: return_def is_OK_def execute_def)"], ["", "lemma return_bind [iff]: \"(return x \\<bind> g) = g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return x \\<bind> g = g x", "unfolding return_def bind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Prog\n     (\\<lambda>h.\n         case the_prog (Prog (\\<lambda>h. Inr (x, h))) h of\n         Inl x \\<Rightarrow> Inl x\n         | Inr (xa, xb) \\<Rightarrow> the_prog (g xa) xb) =\n    g x", "by auto"], ["", "lemma return_id [simp]: \"f \\<bind> return = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<bind> return = f", "by (induct f) (auto simp add: return_def bind_def split: sum.splits prod.splits)"], ["", "lemma return_returns_result [iff]: \"(h \\<turnstile> return x \\<rightarrow>\\<^sub>r y) = (x = y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> return x \\<rightarrow>\\<^sub>r y = (x = y)", "unfolding returns_result_def return_def execute_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case the_prog (Prog (\\<lambda>h. Inr (x, h))) h of\n     Inl x \\<Rightarrow> False | Inr (r', xa) \\<Rightarrow> y = r') =\n    (x = y)", "by auto"], ["", "lemma return_returns_heap [iff]: \"(h \\<turnstile> return x \\<rightarrow>\\<^sub>h h') = (h = h')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> return x \\<rightarrow>\\<^sub>h h' = (h = h')", "unfolding returns_heap_def return_def execute_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case the_prog (Prog (\\<lambda>h. Inr (x, h))) h of\n     Inl x \\<Rightarrow> False | Inr (xa, xb) \\<Rightarrow> h' = xb) =\n    (h = h')", "by auto"], ["", "lemma return_returns_error [iff]: \"\\<not> h \\<turnstile> return x \\<rightarrow>\\<^sub>e e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> h \\<turnstile> return x \\<rightarrow>\\<^sub>e e", "unfolding returns_error_def execute_def return_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (case the_prog (Prog (\\<lambda>h. Inr (x, h))) h of\n            Inl x \\<Rightarrow> e = x | Inr x \\<Rightarrow> False)", "by auto"], ["", "definition noop :: \"('heap, 'e, unit) prog\"\n  where\n    \"noop = return ()\""], ["", "lemma noop_returns_heap [simp]: \"h \\<turnstile> noop \\<rightarrow>\\<^sub>h h' \\<longleftrightarrow> h = h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> noop \\<rightarrow>\\<^sub>h h' = (h = h')", "by(simp add: noop_def)"], ["", "definition get_heap :: \"('heap, 'e, 'heap) prog\"\n  where\n    \"get_heap = Prog (\\<lambda>h. h \\<turnstile> return h)\""], ["", "lemma get_heap_ok [simp]: \"h \\<turnstile> ok (get_heap)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> ok get_heap", "by (simp add: get_heap_def execute_def is_OK_def return_def)"], ["", "lemma get_heap_returns_result [simp]: \"(h \\<turnstile> get_heap \\<bind> (\\<lambda>h'. f h') \\<rightarrow>\\<^sub>r x) = (h \\<turnstile> f h \\<rightarrow>\\<^sub>r x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> get_heap \\<bind> f \\<rightarrow>\\<^sub>r x =\n    h \\<turnstile> f h \\<rightarrow>\\<^sub>r x", "by(simp add: get_heap_def returns_result_def bind_def return_def execute_def)"], ["", "lemma get_heap_returns_heap [simp]: \"(h \\<turnstile> get_heap \\<bind> (\\<lambda>h'. f h') \\<rightarrow>\\<^sub>h h'') = (h \\<turnstile> f h \\<rightarrow>\\<^sub>h h'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> get_heap \\<bind> f \\<rightarrow>\\<^sub>h h'' =\n    h \\<turnstile> f h \\<rightarrow>\\<^sub>h h''", "by(simp add: get_heap_def returns_heap_def bind_def return_def execute_def)"], ["", "lemma get_heap_is_OK [simp]: \"(h \\<turnstile> ok (get_heap \\<bind> (\\<lambda>h'. f h'))) = (h \\<turnstile> ok (f h))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> ok (get_heap \\<bind> f) = h \\<turnstile> ok f h", "by(auto simp add: get_heap_def is_OK_def bind_def return_def execute_def)"], ["", "lemma get_heap_E [elim]: \"(h \\<turnstile> get_heap \\<rightarrow>\\<^sub>r x) \\<Longrightarrow> x = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> get_heap \\<rightarrow>\\<^sub>r x \\<Longrightarrow> x = h", "by(simp add: get_heap_def returns_result_def return_def execute_def)"], ["", "definition return_heap :: \"'heap \\<Rightarrow> ('heap, 'e, unit) prog\"\n  where\n    \"return_heap h = Prog (\\<lambda>_. h \\<turnstile> return ())\""], ["", "lemma return_heap_E [iff]: \"(h \\<turnstile> return_heap h' \\<rightarrow>\\<^sub>h h'') = (h'' = h')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> return_heap h' \\<rightarrow>\\<^sub>h h'' = (h'' = h')", "by(simp add: return_heap_def returns_heap_def return_def execute_def)"], ["", "lemma return_heap_returns_result [simp]: \"h \\<turnstile> return_heap h' \\<rightarrow>\\<^sub>r ()\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> return_heap h' \\<rightarrow>\\<^sub>r ()", "by(simp add: return_heap_def execute_def returns_result_def return_def)"], ["", "subsection \\<open>Pure Heaps\\<close>"], ["", "definition pure :: \"('heap, 'e, 'result) prog \\<Rightarrow> 'heap \\<Rightarrow> bool\"\n  where \"pure f h \\<longleftrightarrow> h \\<turnstile> ok f \\<longrightarrow> h \\<turnstile> f \\<rightarrow>\\<^sub>h h\""], ["", "lemma return_pure [simp]: \"pure (return x) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (return x) h", "by(simp add: pure_def return_def is_OK_def returns_heap_def execute_def)"], ["", "lemma error_pure [simp]: \"pure (error e) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (error e) h", "by(simp add: pure_def error_def is_OK_def returns_heap_def execute_def)"], ["", "lemma noop_pure [simp]: \"pure (noop) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure noop h", "by (simp add: noop_def)"], ["", "lemma get_pure [simp]: \"pure get_heap h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure get_heap h", "by(simp add: pure_def get_heap_def is_OK_def returns_heap_def return_def execute_def)"], ["", "lemma pure_returns_heap_eq:\n  \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> pure f h \\<Longrightarrow> h = h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> f \\<rightarrow>\\<^sub>h h'; pure f h\\<rbrakk>\n    \\<Longrightarrow> h = h'", "by (meson pure_def is_OK_returns_heap_I returns_heap_eq)"], ["", "lemma pure_eq_iff:     \n  \"(\\<forall>h' x. h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<longrightarrow> h \\<turnstile> f \\<rightarrow>\\<^sub>h h' \\<longrightarrow> h = h') \\<longleftrightarrow> pure f h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>h' x.\n        h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<longrightarrow>\n        h \\<turnstile> f \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n        h = h') =\n    pure f h", "by(auto simp add: pure_def)"], ["", "subsection \\<open>Bind\\<close>"], ["", "lemma bind_assoc [simp]:\n  \"((bind f g) \\<bind> h) = (f \\<bind> (\\<lambda>x. (g x \\<bind> h)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<bind> g \\<bind> h = f \\<bind> (\\<lambda>x. g x \\<bind> h)", "by(auto simp add: bind_def split: sum.splits)"], ["", "lemma bind_returns_result_E:\n  assumes \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y\"\n  obtains x h' where \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\" and \"h' \\<turnstile> g x \\<rightarrow>\\<^sub>r y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x h'.\n        \\<lbrakk>h \\<turnstile> f \\<rightarrow>\\<^sub>r x;\n         h \\<turnstile> f \\<rightarrow>\\<^sub>h h';\n         h' \\<turnstile> g x \\<rightarrow>\\<^sub>r y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y\n\ngoal (1 subgoal):\n 1. (\\<And>x h'.\n        \\<lbrakk>h \\<turnstile> f \\<rightarrow>\\<^sub>r x;\n         h \\<turnstile> f \\<rightarrow>\\<^sub>h h';\n         h' \\<turnstile> g x \\<rightarrow>\\<^sub>r y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: bind_def returns_result_def returns_heap_def execute_def \n      split: sum.splits)"], ["", "lemma bind_returns_result_E2:\n  assumes \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y\" and \"pure f h\"\n  obtains x where \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h \\<turnstile> g x \\<rightarrow>\\<^sub>r y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>h \\<turnstile> f \\<rightarrow>\\<^sub>r x;\n         h \\<turnstile> g x \\<rightarrow>\\<^sub>r y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms pure_returns_heap_eq bind_returns_result_E"], ["proof (prove)\nusing this:\n  h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y\n  pure f h\n  \\<lbrakk>?h \\<turnstile> ?f \\<rightarrow>\\<^sub>h ?h'; pure ?f ?h\\<rbrakk>\n  \\<Longrightarrow> ?h = ?h'\n  \\<lbrakk>?h \\<turnstile> ?f \\<bind> ?g \\<rightarrow>\\<^sub>r ?y;\n   \\<And>x h'.\n      \\<lbrakk>?h \\<turnstile> ?f \\<rightarrow>\\<^sub>r x;\n       ?h \\<turnstile> ?f \\<rightarrow>\\<^sub>h h';\n       h' \\<turnstile> ?g x \\<rightarrow>\\<^sub>r ?y\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>h \\<turnstile> f \\<rightarrow>\\<^sub>r x;\n         h \\<turnstile> g x \\<rightarrow>\\<^sub>r y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["", "lemma bind_returns_result_E3:\n  assumes \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"pure f h\"\n  shows \"h \\<turnstile> g x \\<rightarrow>\\<^sub>r y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> g x \\<rightarrow>\\<^sub>r y", "using assms returns_result_eq bind_returns_result_E2"], ["proof (prove)\nusing this:\n  h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y\n  h \\<turnstile> f \\<rightarrow>\\<^sub>r x\n  pure f h\n  \\<lbrakk>?h \\<turnstile> ?f \\<rightarrow>\\<^sub>r ?y;\n   ?h \\<turnstile> ?f \\<rightarrow>\\<^sub>r ?y'\\<rbrakk>\n  \\<Longrightarrow> ?y = ?y'\n  \\<lbrakk>?h \\<turnstile> ?f \\<bind> ?g \\<rightarrow>\\<^sub>r ?y;\n   pure ?f ?h;\n   \\<And>x.\n      \\<lbrakk>?h \\<turnstile> ?f \\<rightarrow>\\<^sub>r x;\n       ?h \\<turnstile> ?g x \\<rightarrow>\\<^sub>r ?y\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. h \\<turnstile> g x \\<rightarrow>\\<^sub>r y", "by metis"], ["", "lemma bind_returns_result_E4:\n  assumes \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" \n  obtains h' where \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\" and \"h' \\<turnstile> g x \\<rightarrow>\\<^sub>r y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h'.\n        \\<lbrakk>h \\<turnstile> f \\<rightarrow>\\<^sub>h h';\n         h' \\<turnstile> g x \\<rightarrow>\\<^sub>r y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms returns_result_eq bind_returns_result_E"], ["proof (prove)\nusing this:\n  h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y\n  h \\<turnstile> f \\<rightarrow>\\<^sub>r x\n  \\<lbrakk>?h \\<turnstile> ?f \\<rightarrow>\\<^sub>r ?y;\n   ?h \\<turnstile> ?f \\<rightarrow>\\<^sub>r ?y'\\<rbrakk>\n  \\<Longrightarrow> ?y = ?y'\n  \\<lbrakk>?h \\<turnstile> ?f \\<bind> ?g \\<rightarrow>\\<^sub>r ?y;\n   \\<And>x h'.\n      \\<lbrakk>?h \\<turnstile> ?f \\<rightarrow>\\<^sub>r x;\n       ?h \\<turnstile> ?f \\<rightarrow>\\<^sub>h h';\n       h' \\<turnstile> ?g x \\<rightarrow>\\<^sub>r ?y\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>h'.\n        \\<lbrakk>h \\<turnstile> f \\<rightarrow>\\<^sub>h h';\n         h' \\<turnstile> g x \\<rightarrow>\\<^sub>r y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["", "lemma bind_returns_heap_E:\n  assumes \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>h h''\"\n  obtains x h' where \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\" and \"h' \\<turnstile> g x \\<rightarrow>\\<^sub>h h''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x h'.\n        \\<lbrakk>h \\<turnstile> f \\<rightarrow>\\<^sub>r x;\n         h \\<turnstile> f \\<rightarrow>\\<^sub>h h';\n         h' \\<turnstile> g x \\<rightarrow>\\<^sub>h h''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>h h''\n\ngoal (1 subgoal):\n 1. (\\<And>x h'.\n        \\<lbrakk>h \\<turnstile> f \\<rightarrow>\\<^sub>r x;\n         h \\<turnstile> f \\<rightarrow>\\<^sub>h h';\n         h' \\<turnstile> g x \\<rightarrow>\\<^sub>h h''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: bind_def returns_result_def returns_heap_def execute_def \n      split: sum.splits)"], ["", "lemma bind_returns_heap_E2 [elim]:\n  assumes \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>h h'\" and \"pure f h\"\n  obtains x where \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h \\<turnstile> g x \\<rightarrow>\\<^sub>h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>h \\<turnstile> f \\<rightarrow>\\<^sub>r x;\n         h \\<turnstile> g x \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms pure_returns_heap_eq"], ["proof (prove)\nusing this:\n  h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>h h'\n  pure f h\n  \\<lbrakk>?h \\<turnstile> ?f \\<rightarrow>\\<^sub>h ?h'; pure ?f ?h\\<rbrakk>\n  \\<Longrightarrow> ?h = ?h'\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>h \\<turnstile> f \\<rightarrow>\\<^sub>r x;\n         h \\<turnstile> g x \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (fastforce elim: bind_returns_heap_E)"], ["", "lemma bind_returns_heap_E3 [elim]:\n  assumes \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>h h'\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"pure f h\" \n  shows \"h \\<turnstile> g x \\<rightarrow>\\<^sub>h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> g x \\<rightarrow>\\<^sub>h h'", "using assms pure_returns_heap_eq returns_result_eq"], ["proof (prove)\nusing this:\n  h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> f \\<rightarrow>\\<^sub>r x\n  pure f h\n  \\<lbrakk>?h \\<turnstile> ?f \\<rightarrow>\\<^sub>h ?h'; pure ?f ?h\\<rbrakk>\n  \\<Longrightarrow> ?h = ?h'\n  \\<lbrakk>?h \\<turnstile> ?f \\<rightarrow>\\<^sub>r ?y;\n   ?h \\<turnstile> ?f \\<rightarrow>\\<^sub>r ?y'\\<rbrakk>\n  \\<Longrightarrow> ?y = ?y'\n\ngoal (1 subgoal):\n 1. h \\<turnstile> g x \\<rightarrow>\\<^sub>h h'", "by (fastforce elim: bind_returns_heap_E)"], ["", "lemma bind_returns_heap_E4:\n  assumes \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>h h''\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\"\n  obtains x where \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h' \\<turnstile> g x \\<rightarrow>\\<^sub>h h''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>h \\<turnstile> f \\<rightarrow>\\<^sub>r x;\n         h' \\<turnstile> g x \\<rightarrow>\\<^sub>h h''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>h h''\n  h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>h \\<turnstile> f \\<rightarrow>\\<^sub>r x;\n         h' \\<turnstile> g x \\<rightarrow>\\<^sub>h h''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis bind_returns_heap_E returns_heap_eq)"], ["", "lemma bind_returns_error_I [intro]:\n  assumes \"h \\<turnstile> f \\<rightarrow>\\<^sub>e e\"\n  shows \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>e e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>e e", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> f \\<rightarrow>\\<^sub>e e\n\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>e e", "by(auto simp add: returns_error_def bind_def execute_def split: sum.splits)"], ["", "lemma bind_returns_error_I3:\n  assumes \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\" and \"h' \\<turnstile> g x \\<rightarrow>\\<^sub>e e\"\n  shows \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>e e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>e e", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> f \\<rightarrow>\\<^sub>r x\n  h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\n  h' \\<turnstile> g x \\<rightarrow>\\<^sub>e e\n\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>e e", "by(auto simp add: returns_error_def bind_def execute_def returns_heap_def returns_result_def \n      split: sum.splits)"], ["", "lemma bind_returns_error_I2 [intro]:\n  assumes \"pure f h\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h \\<turnstile> g x \\<rightarrow>\\<^sub>e e\"\n  shows \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>e e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>e e", "using assms"], ["proof (prove)\nusing this:\n  pure f h\n  h \\<turnstile> f \\<rightarrow>\\<^sub>r x\n  h \\<turnstile> g x \\<rightarrow>\\<^sub>e e\n\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>e e", "by (meson bind_returns_error_I3 is_OK_returns_result_I pure_def)"], ["", "lemma bind_is_OK_E [elim]:\n  assumes \"h \\<turnstile> ok (f \\<bind> g)\"\n  obtains x h' where \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\" and \"h' \\<turnstile> ok (g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x h'.\n        \\<lbrakk>h \\<turnstile> f \\<rightarrow>\\<^sub>r x;\n         h \\<turnstile> f \\<rightarrow>\\<^sub>h h';\n         h' \\<turnstile> ok g x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> ok (f \\<bind> g)\n\ngoal (1 subgoal):\n 1. (\\<And>x h'.\n        \\<lbrakk>h \\<turnstile> f \\<rightarrow>\\<^sub>r x;\n         h \\<turnstile> f \\<rightarrow>\\<^sub>h h';\n         h' \\<turnstile> ok g x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: bind_def returns_result_def returns_heap_def is_OK_def execute_def \n      split: sum.splits)"], ["", "lemma bind_is_OK_E2:\n  assumes \"h \\<turnstile> ok (f \\<bind> g)\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\"\n  obtains h' where \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\" and \"h' \\<turnstile> ok (g x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h'.\n        \\<lbrakk>h \\<turnstile> f \\<rightarrow>\\<^sub>h h';\n         h' \\<turnstile> ok g x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> ok (f \\<bind> g)\n  h \\<turnstile> f \\<rightarrow>\\<^sub>r x\n\ngoal (1 subgoal):\n 1. (\\<And>h'.\n        \\<lbrakk>h \\<turnstile> f \\<rightarrow>\\<^sub>h h';\n         h' \\<turnstile> ok g x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: bind_def returns_result_def returns_heap_def is_OK_def execute_def \n      split: sum.splits)"], ["", "lemma bind_returns_result_I [intro]:\n  assumes \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\" and \"h' \\<turnstile> g x \\<rightarrow>\\<^sub>r y\"\n  shows \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> f \\<rightarrow>\\<^sub>r x\n  h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\n  h' \\<turnstile> g x \\<rightarrow>\\<^sub>r y\n\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y", "by(auto simp add: bind_def returns_result_def returns_heap_def execute_def \n      split: sum.splits)"], ["", "lemma bind_pure_returns_result_I [intro]:\n  assumes \"pure f h\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h \\<turnstile> g x \\<rightarrow>\\<^sub>r y\"\n  shows \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y", "using assms"], ["proof (prove)\nusing this:\n  pure f h\n  h \\<turnstile> f \\<rightarrow>\\<^sub>r x\n  h \\<turnstile> g x \\<rightarrow>\\<^sub>r y\n\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y", "by (meson bind_returns_result_I pure_def is_OK_returns_result_I)"], ["", "lemma bind_pure_returns_result_I2 [intro]:\n  assumes \"pure f h\" and \"h \\<turnstile> ok f\" and \"\\<And>x. h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<Longrightarrow> h \\<turnstile> g x \\<rightarrow>\\<^sub>r y\"\n  shows \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y", "using assms"], ["proof (prove)\nusing this:\n  pure f h\n  h \\<turnstile> ok f\n  h \\<turnstile> f \\<rightarrow>\\<^sub>r ?x \\<Longrightarrow>\n  h \\<turnstile> g ?x \\<rightarrow>\\<^sub>r y\n\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y", "by auto"], ["", "lemma bind_returns_heap_I [intro]:\n  assumes \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\" and \"h' \\<turnstile> g x \\<rightarrow>\\<^sub>h h''\"\n  shows \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>h h''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>h h''", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> f \\<rightarrow>\\<^sub>r x\n  h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\n  h' \\<turnstile> g x \\<rightarrow>\\<^sub>h h''\n\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>h h''", "by(auto simp add: bind_def returns_result_def returns_heap_def execute_def \n      split: sum.splits)"], ["", "lemma bind_returns_heap_I2 [intro]:\n  assumes \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\" and \"\\<And>x. h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<Longrightarrow> h' \\<turnstile> g x \\<rightarrow>\\<^sub>h h''\"\n  shows \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>h h''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>h h''", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> f \\<rightarrow>\\<^sub>r ?x \\<Longrightarrow>\n  h' \\<turnstile> g ?x \\<rightarrow>\\<^sub>h h''\n\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>h h''", "by (meson bind_returns_heap_I is_OK_returns_heap_I is_OK_returns_result_E)"], ["", "lemma bind_is_OK_I [intro]:\n  assumes \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\" and \"h' \\<turnstile> ok (g x)\"\n  shows \"h \\<turnstile> ok (f \\<bind> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> ok (f \\<bind> g)", "by (meson assms(1) assms(2) assms(3) bind_returns_heap_I is_OK_returns_heap_E \n      is_OK_returns_heap_I)"], ["", "lemma bind_is_OK_I2 [intro]:\n  assumes \"h \\<turnstile> ok f\" and \"\\<And>x h'. h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<Longrightarrow> h \\<turnstile> f \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h' \\<turnstile> ok (g x)\"\n  shows \"h \\<turnstile> ok (f \\<bind> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> ok (f \\<bind> g)", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> ok f\n  \\<lbrakk>h \\<turnstile> f \\<rightarrow>\\<^sub>r ?x;\n   h \\<turnstile> f \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> ?h' \\<turnstile> ok g ?x\n\ngoal (1 subgoal):\n 1. h \\<turnstile> ok (f \\<bind> g)", "by blast"], ["", "lemma bind_is_OK_pure_I [intro]:\n  assumes \"pure f h\" and \"h \\<turnstile> ok f\" and \"\\<And>x. h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<Longrightarrow> h \\<turnstile> ok (g x)\"\n  shows \"h \\<turnstile> ok (f \\<bind> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> ok (f \\<bind> g)", "using assms"], ["proof (prove)\nusing this:\n  pure f h\n  h \\<turnstile> ok f\n  h \\<turnstile> f \\<rightarrow>\\<^sub>r ?x \\<Longrightarrow>\n  h \\<turnstile> ok g ?x\n\ngoal (1 subgoal):\n 1. h \\<turnstile> ok (f \\<bind> g)", "by blast"], ["", "lemma bind_pure_I:\n  assumes \"pure f h\" and \"\\<And>x. h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<Longrightarrow> pure (g x) h\"\n  shows \"pure (f \\<bind> g) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (f \\<bind> g) h", "using assms"], ["proof (prove)\nusing this:\n  pure f h\n  h \\<turnstile> f \\<rightarrow>\\<^sub>r ?x \\<Longrightarrow> pure (g ?x) h\n\ngoal (1 subgoal):\n 1. pure (f \\<bind> g) h", "by (metis bind_returns_heap_E2 pure_def pure_returns_heap_eq is_OK_returns_heap_E)"], ["", "lemma pure_pure:\n  assumes \"h \\<turnstile> ok f\" and \"pure f h\"\n  shows \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<rightarrow>\\<^sub>h h", "using assms returns_heap_eq"], ["proof (prove)\nusing this:\n  h \\<turnstile> ok f\n  pure f h\n  \\<lbrakk>?h \\<turnstile> ?f \\<rightarrow>\\<^sub>h ?h';\n   ?h \\<turnstile> ?f \\<rightarrow>\\<^sub>h ?h''\\<rbrakk>\n  \\<Longrightarrow> ?h' = ?h''\n\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<rightarrow>\\<^sub>h h", "unfolding pure_def"], ["proof (prove)\nusing this:\n  h \\<turnstile> ok f\n  h \\<turnstile> ok f \\<longrightarrow>\n  h \\<turnstile> f \\<rightarrow>\\<^sub>h h\n  \\<lbrakk>?h \\<turnstile> ?f \\<rightarrow>\\<^sub>h ?h';\n   ?h \\<turnstile> ?f \\<rightarrow>\\<^sub>h ?h''\\<rbrakk>\n  \\<Longrightarrow> ?h' = ?h''\n\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<rightarrow>\\<^sub>h h", "by auto"], ["", "lemma bind_returns_error_eq: \n  assumes \"h \\<turnstile> f \\<rightarrow>\\<^sub>e e\"\n    and \"h \\<turnstile> g \\<rightarrow>\\<^sub>e e\"\n  shows \"h \\<turnstile> f = h \\<turnstile> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> f = h \\<turnstile> g", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> f \\<rightarrow>\\<^sub>e e\n  h \\<turnstile> g \\<rightarrow>\\<^sub>e e\n\ngoal (1 subgoal):\n 1. h \\<turnstile> f = h \\<turnstile> g", "by(auto simp add: returns_error_def split: sum.splits)"], ["", "subsection \\<open>Map\\<close>"], ["", "fun map_M :: \"('x \\<Rightarrow> ('heap, 'e, 'result) prog) \\<Rightarrow> 'x list \\<Rightarrow> ('heap, 'e, 'result list) prog\"\n  where\n    \"map_M f [] = return []\"\n  | \"map_M f (x#xs) = do {\n      y \\<leftarrow> f x;\n      ys \\<leftarrow> map_M f xs;\n      return (y # ys)\n    }\""], ["", "lemma map_M_ok_I [intro]: \n  \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> h \\<turnstile> ok (f x)) \\<Longrightarrow> (\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (f x) h) \\<Longrightarrow> h \\<turnstile> ok (map_M f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                x \\<in> set xs \\<Longrightarrow> h \\<turnstile> ok f x;\n     \\<And>x. x \\<in> set xs \\<Longrightarrow> pure (f x) h\\<rbrakk>\n    \\<Longrightarrow> h \\<turnstile> ok map_M f xs", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                x \\<in> set [] \\<Longrightarrow> h \\<turnstile> ok f x;\n     \\<And>x. x \\<in> set [] \\<Longrightarrow> pure (f x) h\\<rbrakk>\n    \\<Longrightarrow> h \\<turnstile> ok map_M f []\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> set xs \\<Longrightarrow>\n                            h \\<turnstile> ok f x;\n                 \\<And>x.\n                    x \\<in> set xs \\<Longrightarrow> pure (f x) h\\<rbrakk>\n                \\<Longrightarrow> h \\<turnstile> ok map_M f xs;\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow> h \\<turnstile> ok f x;\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow> pure (f x) h\\<rbrakk>\n       \\<Longrightarrow> h \\<turnstile> ok map_M f (a # xs)", "by (simp_all add: bind_is_OK_I2 bind_is_OK_pure_I)"], ["", "lemma map_M_pure_I : \"\\<And>h. (\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (f x) h) \\<Longrightarrow> pure (map_M f xs) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       (\\<And>x.\n           x \\<in> set xs \\<Longrightarrow> pure (f x) h) \\<Longrightarrow>\n       pure (map_M f xs) h", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h.\n       (\\<And>x.\n           x \\<in> set [] \\<Longrightarrow> pure (f x) h) \\<Longrightarrow>\n       pure (map_M f []) h\n 2. \\<And>a xs h.\n       \\<lbrakk>\\<And>h.\n                   (\\<And>x.\n                       x \\<in> set xs \\<Longrightarrow>\n                       pure (f x) h) \\<Longrightarrow>\n                   pure (map_M f xs) h;\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow> pure (f x) h\\<rbrakk>\n       \\<Longrightarrow> pure (map_M f (a # xs)) h", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs h.\n       \\<lbrakk>\\<And>h.\n                   (\\<And>x.\n                       x \\<in> set xs \\<Longrightarrow>\n                       pure (f x) h) \\<Longrightarrow>\n                   pure (map_M f xs) h;\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow> pure (f x) h\\<rbrakk>\n       \\<Longrightarrow> pure (map_M f (a # xs)) h", "by(auto intro!: bind_pure_I)"], ["", "lemma map_M_pure_E :\n  assumes \"h \\<turnstile> map_M g xs \\<rightarrow>\\<^sub>r ys\" and \"x \\<in> set xs\" and \"\\<And>x h. x \\<in> set xs \\<Longrightarrow> pure (g x) h\"\n  obtains y where \"h \\<turnstile> g x \\<rightarrow>\\<^sub>r y\" and \"y \\<in> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>h \\<turnstile> g x \\<rightarrow>\\<^sub>r y;\n         y \\<in> set ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(insert assms, induct xs arbitrary: ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>h \\<turnstile> g x \\<rightarrow>\\<^sub>r y;\n                    y \\<in> set ys\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        h \\<turnstile> map_M g [] \\<rightarrow>\\<^sub>r ys; x \\<in> set [];\n        \\<And>x xa. x \\<in> set [] \\<Longrightarrow> pure (g x) xa\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>\\<And>y.\n                               \\<lbrakk>h \\<turnstile> g x\n  \\<rightarrow>\\<^sub>r y;\n                                y \\<in> set ys\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    h \\<turnstile> map_M g xs \\<rightarrow>\\<^sub>r ys;\n                    x \\<in> set xs;\n                    \\<And>x xa.\n                       x \\<in> set xs \\<Longrightarrow>\n                       pure (g x) xa\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>y.\n           \\<lbrakk>h \\<turnstile> g x \\<rightarrow>\\<^sub>r y;\n            y \\<in> set ys\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        h \\<turnstile> map_M g (a # xs) \\<rightarrow>\\<^sub>r ys;\n        x \\<in> set (a # xs);\n        \\<And>x xa.\n           x \\<in> set (a # xs) \\<Longrightarrow> pure (g x) xa\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>\\<And>y.\n                               \\<lbrakk>h \\<turnstile> g x\n  \\<rightarrow>\\<^sub>r y;\n                                y \\<in> set ys\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    h \\<turnstile> map_M g xs \\<rightarrow>\\<^sub>r ys;\n                    x \\<in> set xs;\n                    \\<And>x xa.\n                       x \\<in> set xs \\<Longrightarrow>\n                       pure (g x) xa\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>y.\n           \\<lbrakk>h \\<turnstile> g x \\<rightarrow>\\<^sub>r y;\n            y \\<in> set ys\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        h \\<turnstile> map_M g (a # xs) \\<rightarrow>\\<^sub>r ys;\n        x \\<in> set (a # xs);\n        \\<And>x xa.\n           x \\<in> set (a # xs) \\<Longrightarrow> pure (g x) xa\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto elim!: bind_returns_result_E)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs xa h' xaa h'a.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>\\<And>y.\n                               \\<lbrakk>h \\<turnstile> g x\n  \\<rightarrow>\\<^sub>r y;\n                                y \\<in> set ys\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    h \\<turnstile> map_M g xs\n                    \\<rightarrow>\\<^sub>r ys\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>y.\n           \\<lbrakk>h \\<turnstile> g x \\<rightarrow>\\<^sub>r y;\n            y = xa \\<or> y \\<in> set xaa\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>x xa.\n           x = a \\<or> x \\<in> set xs \\<Longrightarrow> pure (g x) xa;\n        h \\<turnstile> g a \\<rightarrow>\\<^sub>r xa;\n        h \\<turnstile> g a \\<rightarrow>\\<^sub>h h';\n        h' \\<turnstile> map_M g xs \\<rightarrow>\\<^sub>r xaa;\n        h' \\<turnstile> map_M g xs \\<rightarrow>\\<^sub>h h'a;\n        x \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (metis (full_types) pure_returns_heap_eq)"], ["", "lemma map_M_pure_E2:\n  assumes \"h \\<turnstile> map_M g xs \\<rightarrow>\\<^sub>r ys\" and \"y \\<in> set ys\" and \"\\<And>x h. x \\<in> set xs \\<Longrightarrow> pure (g x) h\"\n  obtains x where \"h \\<turnstile> g x \\<rightarrow>\\<^sub>r y\" and \"x \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>h \\<turnstile> g x \\<rightarrow>\\<^sub>r y;\n         x \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(insert assms, induct xs arbitrary: ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>h \\<turnstile> g x \\<rightarrow>\\<^sub>r y;\n                    x \\<in> set []\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        h \\<turnstile> map_M g [] \\<rightarrow>\\<^sub>r ys; y \\<in> set ys;\n        \\<And>x xa. x \\<in> set [] \\<Longrightarrow> pure (g x) xa\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>\\<And>x.\n                               \\<lbrakk>h \\<turnstile> g x\n  \\<rightarrow>\\<^sub>r y;\n                                x \\<in> set xs\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    h \\<turnstile> map_M g xs \\<rightarrow>\\<^sub>r ys;\n                    y \\<in> set ys;\n                    \\<And>x xa.\n                       x \\<in> set xs \\<Longrightarrow>\n                       pure (g x) xa\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>x.\n           \\<lbrakk>h \\<turnstile> g x \\<rightarrow>\\<^sub>r y;\n            x \\<in> set (a # xs)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        h \\<turnstile> map_M g (a # xs) \\<rightarrow>\\<^sub>r ys;\n        y \\<in> set ys;\n        \\<And>x xa.\n           x \\<in> set (a # xs) \\<Longrightarrow> pure (g x) xa\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>\\<And>x.\n                               \\<lbrakk>h \\<turnstile> g x\n  \\<rightarrow>\\<^sub>r y;\n                                x \\<in> set xs\\<rbrakk>\n                               \\<Longrightarrow> thesis;\n                    h \\<turnstile> map_M g xs \\<rightarrow>\\<^sub>r ys;\n                    y \\<in> set ys;\n                    \\<And>x xa.\n                       x \\<in> set xs \\<Longrightarrow>\n                       pure (g x) xa\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>x.\n           \\<lbrakk>h \\<turnstile> g x \\<rightarrow>\\<^sub>r y;\n            x \\<in> set (a # xs)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        h \\<turnstile> map_M g (a # xs) \\<rightarrow>\\<^sub>r ys;\n        y \\<in> set ys;\n        \\<And>x xa.\n           x \\<in> set (a # xs) \\<Longrightarrow> pure (g x) xa\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto elim!: bind_returns_result_E)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs x h' xa h'a.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>h \\<turnstile> map_M g xs\n                            \\<rightarrow>\\<^sub>r ys;\n                    y \\<in> set ys\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>x.\n           \\<lbrakk>h \\<turnstile> g x \\<rightarrow>\\<^sub>r y;\n            x = a \\<or> x \\<in> set xs\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>x xa.\n           x = a \\<or> x \\<in> set xs \\<Longrightarrow> pure (g x) xa;\n        h \\<turnstile> g a \\<rightarrow>\\<^sub>r x;\n        h \\<turnstile> g a \\<rightarrow>\\<^sub>h h';\n        h' \\<turnstile> map_M g xs \\<rightarrow>\\<^sub>r xa;\n        h' \\<turnstile> map_M g xs \\<rightarrow>\\<^sub>h h'a;\n        y \\<in> set xa\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (metis (full_types) pure_returns_heap_eq)"], ["", "subsection \\<open>Forall\\<close>"], ["", "fun forall_M :: \"('y \\<Rightarrow> ('heap, 'e, 'result) prog) \\<Rightarrow> 'y list \\<Rightarrow> ('heap, 'e, unit) prog\"\n  where\n    \"forall_M P [] = return ()\"\n  | \"forall_M P (x # xs) = do {\n      P x;\n      forall_M P xs\n    }\""], ["", "lemma pure_forall_M_I: \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h) \\<Longrightarrow> pure (forall_M P xs) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set xs \\<Longrightarrow> pure (P x) h) \\<Longrightarrow>\n    pure (forall_M P xs) h", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set [] \\<Longrightarrow> pure (P x) h) \\<Longrightarrow>\n    pure (forall_M P []) h\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    pure (P x) h) \\<Longrightarrow>\n                pure (forall_M P xs) h;\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow> pure (P x) h\\<rbrakk>\n       \\<Longrightarrow> pure (forall_M P (a # xs)) h", "by(auto intro!: bind_pure_I)"], ["", "subsection \\<open>Fold\\<close>"], ["", "fun fold_M :: \"('result \\<Rightarrow> 'y \\<Rightarrow> ('heap, 'e, 'result) prog) \\<Rightarrow> 'result \\<Rightarrow> 'y list\n  \\<Rightarrow> ('heap, 'e, 'result) prog\"\n  where \n    \"fold_M f d [] = return d\" |\n    \"fold_M f d (x # xs) = do { y \\<leftarrow> f d x; fold_M f y xs }\""], ["", "lemma fold_M_pure_I : \"(\\<And>d x. pure (f d x) h) \\<Longrightarrow> (\\<And>d. pure (fold_M f d xs) h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d x. pure (f d x) h) \\<Longrightarrow>\n    (\\<And>d. pure (fold_M f d xs) h)", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>d.\n       (\\<And>d x. pure (f d x) h) \\<Longrightarrow> pure (fold_M f d []) h\n 2. \\<And>a xs d.\n       \\<lbrakk>\\<And>d.\n                   (\\<And>d x. pure (f d x) h) \\<Longrightarrow>\n                   pure (fold_M f d xs) h;\n        \\<And>d x. pure (f d x) h\\<rbrakk>\n       \\<Longrightarrow> pure (fold_M f d (a # xs)) h", "by(auto intro: bind_pure_I)"], ["", "subsection \\<open>Filter\\<close>"], ["", "fun filter_M :: \"('x \\<Rightarrow> ('heap, 'e, bool) prog) \\<Rightarrow> 'x list \\<Rightarrow> ('heap, 'e, 'x list) prog\"\n  where\n    \"filter_M P [] = return []\"\n  | \"filter_M P (x#xs) = do {\n      p \\<leftarrow> P x;\n      ys \\<leftarrow> filter_M P xs;\n      return (if p then x # ys else ys)\n    }\""], ["", "lemma filter_M_pure_I [intro]: \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h) \\<Longrightarrow> pure (filter_M P xs)h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set xs \\<Longrightarrow> pure (P x) h) \\<Longrightarrow>\n    pure (filter_M P xs) h", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>x.\n        x \\<in> set [] \\<Longrightarrow> pure (P x) h) \\<Longrightarrow>\n    pure (filter_M P []) h\n 2. \\<And>a xs.\n       \\<lbrakk>(\\<And>x.\n                    x \\<in> set xs \\<Longrightarrow>\n                    pure (P x) h) \\<Longrightarrow>\n                pure (filter_M P xs) h;\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow> pure (P x) h\\<rbrakk>\n       \\<Longrightarrow> pure (filter_M P (a # xs)) h", "by(auto intro!: bind_pure_I)"], ["", "lemma filter_M_is_OK_I [intro]:\n  \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> h \\<turnstile> ok (P x)) \\<Longrightarrow> (\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h) \\<Longrightarrow> h \\<turnstile> ok (filter_M P xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                x \\<in> set xs \\<Longrightarrow> h \\<turnstile> ok P x;\n     \\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h\\<rbrakk>\n    \\<Longrightarrow> h \\<turnstile> ok filter_M P xs", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                x \\<in> set [] \\<Longrightarrow> h \\<turnstile> ok P x;\n     \\<And>x. x \\<in> set [] \\<Longrightarrow> pure (P x) h\\<rbrakk>\n    \\<Longrightarrow> h \\<turnstile> ok filter_M P []\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> set xs \\<Longrightarrow>\n                            h \\<turnstile> ok P x;\n                 \\<And>x.\n                    x \\<in> set xs \\<Longrightarrow> pure (P x) h\\<rbrakk>\n                \\<Longrightarrow> h \\<turnstile> ok filter_M P xs;\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow> h \\<turnstile> ok P x;\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow> pure (P x) h\\<rbrakk>\n       \\<Longrightarrow> h \\<turnstile> ok filter_M P (a # xs)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> set xs \\<Longrightarrow>\n                            h \\<turnstile> ok P x;\n                 \\<And>x.\n                    x \\<in> set xs \\<Longrightarrow> pure (P x) h\\<rbrakk>\n                \\<Longrightarrow> h \\<turnstile> ok filter_M P xs;\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow> h \\<turnstile> ok P x;\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow> pure (P x) h\\<rbrakk>\n       \\<Longrightarrow> h \\<turnstile> ok filter_M P (a # xs)", "by(auto intro!: bind_is_OK_pure_I)"], ["", "lemma filter_M_not_more_elements:\n  assumes \"h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys\" and \"\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h\" and \"x \\<in> set ys\"\n  shows \"x \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs", "apply(insert assms, induct xs arbitrary: ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>h \\<turnstile> filter_M P [] \\<rightarrow>\\<^sub>r ys;\n        \\<And>x. x \\<in> set [] \\<Longrightarrow> pure (P x) h;\n        x \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set []\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>h \\<turnstile> filter_M P xs\n                            \\<rightarrow>\\<^sub>r ys;\n                    \\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h;\n                    x \\<in> set ys\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> set xs;\n        h \\<turnstile> filter_M P (a # xs) \\<rightarrow>\\<^sub>r ys;\n        \\<And>x. x \\<in> set (a # xs) \\<Longrightarrow> pure (P x) h;\n        x \\<in> set ys\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set (a # xs)", "by(auto elim!: bind_returns_result_E2 split: if_splits intro!: set_ConsD)"], ["", "lemma filter_M_in_result_if_ok:\n  assumes \"h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys\" and \"\\<And>h x. x \\<in> set xs \\<Longrightarrow> pure (P x) h\" and \"x \\<in> set xs\" and\n    \"h \\<turnstile> P x \\<rightarrow>\\<^sub>r True\"\n  shows \"x \\<in> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set ys", "apply(insert assms, induct xs arbitrary: ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>h \\<turnstile> filter_M P [] \\<rightarrow>\\<^sub>r ys;\n        \\<And>x xa. x \\<in> set [] \\<Longrightarrow> pure (P x) xa;\n        x \\<in> set [];\n        h \\<turnstile> P x \\<rightarrow>\\<^sub>r True\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>h \\<turnstile> filter_M P xs\n                            \\<rightarrow>\\<^sub>r ys;\n                    \\<And>x xa.\n                       x \\<in> set xs \\<Longrightarrow> pure (P x) xa;\n                    x \\<in> set xs;\n                    h \\<turnstile> P x \\<rightarrow>\\<^sub>r True\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> set ys;\n        h \\<turnstile> filter_M P (a # xs) \\<rightarrow>\\<^sub>r ys;\n        \\<And>x xa. x \\<in> set (a # xs) \\<Longrightarrow> pure (P x) xa;\n        x \\<in> set (a # xs);\n        h \\<turnstile> P x \\<rightarrow>\\<^sub>r True\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set ys", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>h \\<turnstile> filter_M P xs\n                            \\<rightarrow>\\<^sub>r ys;\n                    \\<And>x xa.\n                       x \\<in> set xs \\<Longrightarrow> pure (P x) xa;\n                    x \\<in> set xs;\n                    h \\<turnstile> P x \\<rightarrow>\\<^sub>r True\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> set ys;\n        h \\<turnstile> filter_M P (a # xs) \\<rightarrow>\\<^sub>r ys;\n        \\<And>x xa. x \\<in> set (a # xs) \\<Longrightarrow> pure (P x) xa;\n        x \\<in> set (a # xs);\n        h \\<turnstile> P x \\<rightarrow>\\<^sub>r True\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set ys", "apply(auto elim!: bind_returns_result_E2)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs xa xaa.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>h \\<turnstile> filter_M P xs\n                            \\<rightarrow>\\<^sub>r ys;\n                    x \\<in> set xs\\<rbrakk>\n                   \\<Longrightarrow> x \\<in> set ys;\n        \\<And>xa xb.\n           xa = x \\<or> xa \\<in> set xs \\<Longrightarrow> pure (P xa) xb;\n        h \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P x \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xaa;\n        \\<not> xa\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set xaa", "by (metis returns_result_eq)"], ["", "lemma filter_M_holds_for_result:\n  assumes \"h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys\" and \"x \\<in> set ys\" and \"\\<And>x h. x \\<in> set xs \\<Longrightarrow> pure (P x) h\"\n  shows \"h \\<turnstile> P x \\<rightarrow>\\<^sub>r True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> P x \\<rightarrow>\\<^sub>r True", "apply(insert assms, induct xs arbitrary: ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>h \\<turnstile> filter_M P [] \\<rightarrow>\\<^sub>r ys;\n        x \\<in> set ys;\n        \\<And>x xa. x \\<in> set [] \\<Longrightarrow> pure (P x) xa\\<rbrakk>\n       \\<Longrightarrow> h \\<turnstile> P x \\<rightarrow>\\<^sub>r True\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>h \\<turnstile> filter_M P xs\n                            \\<rightarrow>\\<^sub>r ys;\n                    x \\<in> set ys;\n                    \\<And>x xa.\n                       x \\<in> set xs \\<Longrightarrow>\n                       pure (P x) xa\\<rbrakk>\n                   \\<Longrightarrow> h \\<turnstile> P x\n                                     \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> filter_M P (a # xs) \\<rightarrow>\\<^sub>r ys;\n        x \\<in> set ys;\n        \\<And>x xa.\n           x \\<in> set (a # xs) \\<Longrightarrow> pure (P x) xa\\<rbrakk>\n       \\<Longrightarrow> h \\<turnstile> P x \\<rightarrow>\\<^sub>r True", "by(auto elim!: bind_returns_result_E2 split: if_splits intro!: set_ConsD)"], ["", "lemma filter_M_empty_I:\n  assumes \"\\<And>x. pure (P x) h\"\n    and \"\\<forall>x \\<in> set xs. h \\<turnstile> P x \\<rightarrow>\\<^sub>r False\"\n  shows \"h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r []", "using assms"], ["proof (prove)\nusing this:\n  pure (P ?x) h\n  \\<forall>x\\<in>set xs. h \\<turnstile> P x \\<rightarrow>\\<^sub>r False\n\ngoal (1 subgoal):\n 1. h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r []", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x. pure (P x) h;\n     \\<forall>x\\<in>set [].\n        h \\<turnstile> P x \\<rightarrow>\\<^sub>r False\\<rbrakk>\n    \\<Longrightarrow> h \\<turnstile> filter_M P [] \\<rightarrow>\\<^sub>r []\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x. pure (P x) h;\n                 \\<forall>x\\<in>set xs.\n                    h \\<turnstile> P x \\<rightarrow>\\<^sub>r False\\<rbrakk>\n                \\<Longrightarrow> h \\<turnstile> filter_M P xs\n                                  \\<rightarrow>\\<^sub>r [];\n        \\<And>x. pure (P x) h;\n        \\<forall>x\\<in>set (a # xs).\n           h \\<turnstile> P x \\<rightarrow>\\<^sub>r False\\<rbrakk>\n       \\<Longrightarrow> h \\<turnstile> filter_M P (a # xs)\n                         \\<rightarrow>\\<^sub>r []", "by(auto intro!: bind_pure_returns_result_I)"], ["", "lemma filter_M_subset_2: \"h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys \\<Longrightarrow> h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys' \n                          \\<Longrightarrow> (\\<And>x. pure (P x) h) \\<Longrightarrow> (\\<And>x. pure (P x) h') \n                          \\<Longrightarrow> (\\<forall>b. \\<forall>x \\<in> set xs. h \\<turnstile> P x \\<rightarrow>\\<^sub>r True \\<longrightarrow> h' \\<turnstile> P x \\<rightarrow>\\<^sub>r b \\<longrightarrow> b) \n                          \\<Longrightarrow> set ys \\<subseteq> set ys'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n     h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys';\n     \\<And>x. pure (P x) h; \\<And>x. pure (P x) h';\n     \\<forall>b.\n        \\<forall>x\\<in>set xs.\n           h \\<turnstile> P x \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n           h' \\<turnstile> P x \\<rightarrow>\\<^sub>r b \\<longrightarrow>\n           b\\<rbrakk>\n    \\<Longrightarrow> set ys \\<subseteq> set ys'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n     h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys';\n     \\<And>x. pure (P x) h; \\<And>x. pure (P x) h';\n     \\<forall>b.\n        \\<forall>x\\<in>set xs.\n           h \\<turnstile> P x \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n           h' \\<turnstile> P x \\<rightarrow>\\<^sub>r b \\<longrightarrow>\n           b\\<rbrakk>\n    \\<Longrightarrow> set ys \\<subseteq> set ys'", "assume 1: \"h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys\" and 2: \"h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\" \n    and 3: \"(\\<And>x. pure (P x) h)\" and \"(\\<And>x. pure (P x) h')\" \n    and 4: \"\\<forall>b. \\<forall>x\\<in>set xs. h \\<turnstile> P x \\<rightarrow>\\<^sub>r True \\<longrightarrow> h' \\<turnstile> P x \\<rightarrow>\\<^sub>r b \\<longrightarrow> b\""], ["proof (state)\nthis:\n  h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys\n  h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\n  pure (P ?x) h\n  pure (P ?x) h'\n  \\<forall>b.\n     \\<forall>x\\<in>set xs.\n        h \\<turnstile> P x \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n        h' \\<turnstile> P x \\<rightarrow>\\<^sub>r b \\<longrightarrow> b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n     h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys';\n     \\<And>x. pure (P x) h; \\<And>x. pure (P x) h';\n     \\<forall>b.\n        \\<forall>x\\<in>set xs.\n           h \\<turnstile> P x \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n           h' \\<turnstile> P x \\<rightarrow>\\<^sub>r b \\<longrightarrow>\n           b\\<rbrakk>\n    \\<Longrightarrow> set ys \\<subseteq> set ys'", "have h1: \"\\<forall>x \\<in> set xs. h' \\<turnstile> ok (P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. h' \\<turnstile> ok P x", "using 2 3 \\<open>(\\<And>x. pure (P x) h')\\<close>"], ["proof (prove)\nusing this:\n  h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\n  pure (P ?x) h\n  pure (P ?x) h'\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. h' \\<turnstile> ok P x", "apply(induct xs arbitrary: ys')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys'.\n       \\<lbrakk>h' \\<turnstile> filter_M P [] \\<rightarrow>\\<^sub>r ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set []. h' \\<turnstile> ok P x\n 2. \\<And>a xs ys'.\n       \\<lbrakk>\\<And>ys'.\n                   \\<lbrakk>h' \\<turnstile> filter_M P xs\n                            \\<rightarrow>\\<^sub>r ys';\n                    \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set xs.\n  h' \\<turnstile> ok P x;\n        h' \\<turnstile> filter_M P (a # xs) \\<rightarrow>\\<^sub>r ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (a # xs). h' \\<turnstile> ok P x", "by(auto elim!: bind_returns_result_E2)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs. h' \\<turnstile> ok P x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n     h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys';\n     \\<And>x. pure (P x) h; \\<And>x. pure (P x) h';\n     \\<forall>b.\n        \\<forall>x\\<in>set xs.\n           h \\<turnstile> P x \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n           h' \\<turnstile> P x \\<rightarrow>\\<^sub>r b \\<longrightarrow>\n           b\\<rbrakk>\n    \\<Longrightarrow> set ys \\<subseteq> set ys'", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set xs. h' \\<turnstile> ok P x", "have 5: \"\\<forall>x\\<in>set xs. h \\<turnstile> P x \\<rightarrow>\\<^sub>r True \\<longrightarrow> h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. h' \\<turnstile> ok P x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs.\n       h \\<turnstile> P x \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n       h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True", "using 4"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set xs. h' \\<turnstile> ok P x\n  \\<forall>b.\n     \\<forall>x\\<in>set xs.\n        h \\<turnstile> P x \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n        h' \\<turnstile> P x \\<rightarrow>\\<^sub>r b \\<longrightarrow> b\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs.\n       h \\<turnstile> P x \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n       h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True", "apply(auto)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>set xs. h' \\<turnstile> ok P x;\n        \\<forall>b.\n           \\<forall>x\\<in>set xs.\n              h \\<turnstile> P x\n              \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n              h' \\<turnstile> P x \\<rightarrow>\\<^sub>r b \\<longrightarrow>\n              b;\n        x \\<in> set xs;\n        h \\<turnstile> P x \\<rightarrow>\\<^sub>r True\\<rbrakk>\n       \\<Longrightarrow> h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True", "by (metis is_OK_returns_result_E)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set xs.\n     h \\<turnstile> P x \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n     h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True\n\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n     h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys';\n     \\<And>x. pure (P x) h; \\<And>x. pure (P x) h';\n     \\<forall>b.\n        \\<forall>x\\<in>set xs.\n           h \\<turnstile> P x \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n           h' \\<turnstile> P x \\<rightarrow>\\<^sub>r b \\<longrightarrow>\n           b\\<rbrakk>\n    \\<Longrightarrow> set ys \\<subseteq> set ys'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set ys'", "using 1 2 3 5 \\<open>(\\<And>x. pure (P x) h')\\<close>"], ["proof (prove)\nusing this:\n  h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys\n  h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\n  pure (P ?x) h\n  \\<forall>x\\<in>set xs.\n     h \\<turnstile> P x \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n     h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True\n  pure (P ?x) h'\n\ngoal (1 subgoal):\n 1. set ys \\<subseteq> set ys'", "apply(induct xs arbitrary: ys ys')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys ys'.\n       \\<lbrakk>h \\<turnstile> filter_M P [] \\<rightarrow>\\<^sub>r ys;\n        h' \\<turnstile> filter_M P [] \\<rightarrow>\\<^sub>r ys';\n        \\<And>x. pure (P x) h;\n        \\<forall>x\\<in>set [].\n           h \\<turnstile> P x \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n           h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        \\<And>x. pure (P x) h'\\<rbrakk>\n       \\<Longrightarrow> set ys \\<subseteq> set ys'\n 2. \\<And>a xs ys ys'.\n       \\<lbrakk>\\<And>ys ys'.\n                   \\<lbrakk>h \\<turnstile> filter_M P xs\n                            \\<rightarrow>\\<^sub>r ys;\n                    h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys';\n                    \\<And>x. pure (P x) h;\n                    \\<forall>x\\<in>set xs.\n                       h \\<turnstile> P x\n                       \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                       h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n                    \\<And>x. pure (P x) h'\\<rbrakk>\n                   \\<Longrightarrow> set ys \\<subseteq> set ys';\n        h \\<turnstile> filter_M P (a # xs) \\<rightarrow>\\<^sub>r ys;\n        h' \\<turnstile> filter_M P (a # xs) \\<rightarrow>\\<^sub>r ys';\n        \\<And>x. pure (P x) h;\n        \\<forall>x\\<in>set (a # xs).\n           h \\<turnstile> P x \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n           h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        \\<And>x. pure (P x) h'\\<rbrakk>\n       \\<Longrightarrow> set ys \\<subseteq> set ys'", "apply(auto)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs ys ys'.\n       \\<lbrakk>\\<And>ys ys'.\n                   \\<lbrakk>h \\<turnstile> filter_M P xs\n                            \\<rightarrow>\\<^sub>r ys;\n                    h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys';\n                    \\<And>x. pure (P x) h;\n                    \\<forall>x\\<in>set xs.\n                       h \\<turnstile> P x\n                       \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                       h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n                    \\<And>x. pure (P x) h'\\<rbrakk>\n                   \\<Longrightarrow> set ys \\<subseteq> set ys';\n        h \\<turnstile> filter_M P (a # xs) \\<rightarrow>\\<^sub>r ys;\n        h' \\<turnstile> filter_M P (a # xs) \\<rightarrow>\\<^sub>r ys';\n        \\<And>x. pure (P x) h;\n        \\<forall>x\\<in>set (a # xs).\n           h \\<turnstile> P x \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n           h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        \\<And>x. pure (P x) h'\\<rbrakk>\n       \\<Longrightarrow> set ys \\<subseteq> set ys'", "apply(auto elim!: bind_returns_result_E2 split: if_splits)[1]"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        \\<not> h \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; \\<not> xa;\n        x \\<in> set xc; xb; x \\<notin> set xd\\<rbrakk>\n       \\<Longrightarrow> x = a\n 2. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        \\<not> h \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; \\<not> xa;\n        x \\<in> set xc; \\<not> xb\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set xd\n 3. \\<And>a xs xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; xa;\n        \\<not> xb\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set xd\n 4. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; xa; x \\<in> set xc;\n        xb; x \\<notin> set xd\\<rbrakk>\n       \\<Longrightarrow> x = a\n 5. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; xa; x \\<in> set xc;\n        \\<not> xb\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set xd\n 6. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; \\<not> xa;\n        x \\<in> set xc; xb; x \\<notin> set xd\\<rbrakk>\n       \\<Longrightarrow> x = a\n 7. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; \\<not> xa;\n        x \\<in> set xc; \\<not> xb\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set xd", "apply auto[1]"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        \\<not> h \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; \\<not> xa;\n        x \\<in> set xc; \\<not> xb\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set xd\n 2. \\<And>a xs xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; xa;\n        \\<not> xb\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set xd\n 3. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; xa; x \\<in> set xc;\n        xb; x \\<notin> set xd\\<rbrakk>\n       \\<Longrightarrow> x = a\n 4. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; xa; x \\<in> set xc;\n        \\<not> xb\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set xd\n 5. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; \\<not> xa;\n        x \\<in> set xc; xb; x \\<notin> set xd\\<rbrakk>\n       \\<Longrightarrow> x = a\n 6. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; \\<not> xa;\n        x \\<in> set xc; \\<not> xb\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set xd", "apply auto[1]"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a xs xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; xa;\n        \\<not> xb\\<rbrakk>\n       \\<Longrightarrow> a \\<in> set xd\n 2. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; xa; x \\<in> set xc;\n        xb; x \\<notin> set xd\\<rbrakk>\n       \\<Longrightarrow> x = a\n 3. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; xa; x \\<in> set xc;\n        \\<not> xb\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set xd\n 4. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; \\<not> xa;\n        x \\<in> set xc; xb; x \\<notin> set xd\\<rbrakk>\n       \\<Longrightarrow> x = a\n 5. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; \\<not> xa;\n        x \\<in> set xc; \\<not> xb\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set xd", "apply(metis returns_result_eq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; xa; x \\<in> set xc;\n        xb; x \\<notin> set xd\\<rbrakk>\n       \\<Longrightarrow> x = a\n 2. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; xa; x \\<in> set xc;\n        \\<not> xb\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set xd\n 3. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; \\<not> xa;\n        x \\<in> set xc; xb; x \\<notin> set xd\\<rbrakk>\n       \\<Longrightarrow> x = a\n 4. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; \\<not> xa;\n        x \\<in> set xc; \\<not> xb\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set xd", "apply auto[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; xa; x \\<in> set xc;\n        \\<not> xb\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set xd\n 2. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; \\<not> xa;\n        x \\<in> set xc; xb; x \\<notin> set xd\\<rbrakk>\n       \\<Longrightarrow> x = a\n 3. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; \\<not> xa;\n        x \\<in> set xc; \\<not> xb\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set xd", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; \\<not> xa;\n        x \\<in> set xc; xb; x \\<notin> set xd\\<rbrakk>\n       \\<Longrightarrow> x = a\n 2. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; \\<not> xa;\n        x \\<in> set xc; \\<not> xb\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set xd", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs x xa xb xc xd.\n       \\<lbrakk>\\<forall>x\\<in>set xs.\n                   h \\<turnstile> P x\n                   \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n                   h' \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xc;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xd;\n        h' \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        \\<And>ys ys'.\n           \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n            h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys'\\<rbrakk>\n           \\<Longrightarrow> set ys \\<subseteq> set ys';\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h'; \\<not> xa;\n        x \\<in> set xc; \\<not> xb\\<rbrakk>\n       \\<Longrightarrow> x \\<in> set xd", "by(auto)"], ["proof (state)\nthis:\n  set ys \\<subseteq> set ys'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_M_subset: \"h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys \\<Longrightarrow> set ys \\<subseteq> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys \\<Longrightarrow>\n    set ys \\<subseteq> set xs", "apply(induct xs arbitrary: h ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h ys.\n       h \\<turnstile> filter_M P []\n       \\<rightarrow>\\<^sub>r ys \\<Longrightarrow>\n       set ys \\<subseteq> set []\n 2. \\<And>a xs h ys.\n       \\<lbrakk>\\<And>h ys.\n                   h \\<turnstile> filter_M P xs\n                   \\<rightarrow>\\<^sub>r ys \\<Longrightarrow>\n                   set ys \\<subseteq> set xs;\n        h \\<turnstile> filter_M P (a # xs) \\<rightarrow>\\<^sub>r ys\\<rbrakk>\n       \\<Longrightarrow> set ys \\<subseteq> set (a # xs)", "apply(auto)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs h ys.\n       \\<lbrakk>\\<And>h ys.\n                   h \\<turnstile> filter_M P xs\n                   \\<rightarrow>\\<^sub>r ys \\<Longrightarrow>\n                   set ys \\<subseteq> set xs;\n        h \\<turnstile> filter_M P (a # xs) \\<rightarrow>\\<^sub>r ys\\<rbrakk>\n       \\<Longrightarrow> set ys \\<subseteq> set (a # xs)", "apply(auto elim!: bind_returns_result_E split: if_splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a xs h x h' xa h'a xb.\n       \\<lbrakk>xb \\<notin> set xs;\n        \\<And>h ys.\n           h \\<turnstile> filter_M P xs\n           \\<rightarrow>\\<^sub>r ys \\<Longrightarrow>\n           set ys \\<subseteq> set xs;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>h h';\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xa;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>h h'a; x;\n        xb \\<in> set xa\\<rbrakk>\n       \\<Longrightarrow> xb = a\n 2. \\<And>a xs h x h' xa h'a xb.\n       \\<lbrakk>xb \\<notin> set xs;\n        \\<And>h ys.\n           h \\<turnstile> filter_M P xs\n           \\<rightarrow>\\<^sub>r ys \\<Longrightarrow>\n           set ys \\<subseteq> set xs;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>h h';\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xa;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>h h'a; \\<not> x;\n        xb \\<in> set xa\\<rbrakk>\n       \\<Longrightarrow> xb = a", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs h x h' xa h'a xb.\n       \\<lbrakk>xb \\<notin> set xs;\n        \\<And>h ys.\n           h \\<turnstile> filter_M P xs\n           \\<rightarrow>\\<^sub>r ys \\<Longrightarrow>\n           set ys \\<subseteq> set xs;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r False;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>h h';\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xa;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>h h'a; \\<not> x;\n        xb \\<in> set xa\\<rbrakk>\n       \\<Longrightarrow> xb = a", "by blast"], ["", "lemma filter_M_distinct: \"h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys \\<Longrightarrow> distinct xs \\<Longrightarrow> distinct ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n     distinct xs\\<rbrakk>\n    \\<Longrightarrow> distinct ys", "apply(induct xs arbitrary: h ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h ys.\n       \\<lbrakk>h \\<turnstile> filter_M P [] \\<rightarrow>\\<^sub>r ys;\n        distinct []\\<rbrakk>\n       \\<Longrightarrow> distinct ys\n 2. \\<And>a xs h ys.\n       \\<lbrakk>\\<And>h ys.\n                   \\<lbrakk>h \\<turnstile> filter_M P xs\n                            \\<rightarrow>\\<^sub>r ys;\n                    distinct xs\\<rbrakk>\n                   \\<Longrightarrow> distinct ys;\n        h \\<turnstile> filter_M P (a # xs) \\<rightarrow>\\<^sub>r ys;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct ys", "apply(auto)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs h ys.\n       \\<lbrakk>\\<And>h ys.\n                   \\<lbrakk>h \\<turnstile> filter_M P xs\n                            \\<rightarrow>\\<^sub>r ys;\n                    distinct xs\\<rbrakk>\n                   \\<Longrightarrow> distinct ys;\n        h \\<turnstile> filter_M P (a # xs) \\<rightarrow>\\<^sub>r ys;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct ys", "using filter_M_subset"], ["proof (prove)\nusing this:\n  ?h \\<turnstile> filter_M ?P ?xs\n  \\<rightarrow>\\<^sub>r ?ys \\<Longrightarrow>\n  set ?ys \\<subseteq> set ?xs\n\ngoal (1 subgoal):\n 1. \\<And>a xs h ys.\n       \\<lbrakk>\\<And>h ys.\n                   \\<lbrakk>h \\<turnstile> filter_M P xs\n                            \\<rightarrow>\\<^sub>r ys;\n                    distinct xs\\<rbrakk>\n                   \\<Longrightarrow> distinct ys;\n        h \\<turnstile> filter_M P (a # xs) \\<rightarrow>\\<^sub>r ys;\n        distinct (a # xs)\\<rbrakk>\n       \\<Longrightarrow> distinct ys", "apply(auto elim!: bind_returns_result_E)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs h x h' xa h'a.\n       \\<lbrakk>\\<And>h ys.\n                   h \\<turnstile> filter_M P xs\n                   \\<rightarrow>\\<^sub>r ys \\<Longrightarrow>\n                   distinct ys;\n        \\<And>h P xs ys.\n           h \\<turnstile> filter_M P xs\n           \\<rightarrow>\\<^sub>r ys \\<Longrightarrow>\n           set ys \\<subseteq> set xs;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>r True;\n        h \\<turnstile> P a \\<rightarrow>\\<^sub>h h';\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r xa;\n        h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>h h'a;\n        a \\<notin> set xs; distinct xs; x; a \\<in> set xa\\<rbrakk>\n       \\<Longrightarrow> False", "by fastforce"], ["", "lemma filter_M_filter: \"h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys \\<Longrightarrow> (\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h) \n                       \\<Longrightarrow> (\\<forall>x \\<in> set xs. h \\<turnstile> ok P x) \\<and> ys = filter (\\<lambda>x. |h \\<turnstile> P x|\\<^sub>r) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n     \\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>x\\<in>set xs. h \\<turnstile> ok P x) \\<and>\n                      ys =\n                      filter (\\<lambda>x. |h \\<turnstile> P x|\\<^sub>r) xs", "apply(induct xs arbitrary: ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>h \\<turnstile> filter_M P [] \\<rightarrow>\\<^sub>r ys;\n        \\<And>x. x \\<in> set [] \\<Longrightarrow> pure (P x) h\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>set [].\n                             h \\<turnstile> ok P x) \\<and>\n                         ys =\n                         filter (\\<lambda>x. |h \\<turnstile> P x|\\<^sub>r)\n                          []\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>h \\<turnstile> filter_M P xs\n                            \\<rightarrow>\\<^sub>r ys;\n                    \\<And>x.\n                       x \\<in> set xs \\<Longrightarrow>\n                       pure (P x) h\\<rbrakk>\n                   \\<Longrightarrow> (\\<forall>x\\<in>set xs.\n   h \\<turnstile> ok P x) \\<and>\n                                     ys =\n                                     filter\n(\\<lambda>x. |h \\<turnstile> P x|\\<^sub>r) xs;\n        h \\<turnstile> filter_M P (a # xs) \\<rightarrow>\\<^sub>r ys;\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow> pure (P x) h\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>set (a # xs).\n                             h \\<turnstile> ok P x) \\<and>\n                         ys =\n                         filter (\\<lambda>x. |h \\<turnstile> P x|\\<^sub>r)\n                          (a # xs)", "by(auto elim!: bind_returns_result_E2)"], ["", "lemma filter_M_filter2: \"(\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h \\<and>  h \\<turnstile> ok P x) \n                       \\<Longrightarrow> filter (\\<lambda>x. |h \\<turnstile> P x|\\<^sub>r) xs = ys \\<Longrightarrow> h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                x \\<in> set xs \\<Longrightarrow>\n                pure (P x) h \\<and> h \\<turnstile> ok P x;\n     filter (\\<lambda>x. |h \\<turnstile> P x|\\<^sub>r) xs = ys\\<rbrakk>\n    \\<Longrightarrow> h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys", "apply(induct xs arbitrary: ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>\\<And>x.\n                   x \\<in> set [] \\<Longrightarrow>\n                   pure (P x) h \\<and> h \\<turnstile> ok P x;\n        filter (\\<lambda>x. |h \\<turnstile> P x|\\<^sub>r) [] = ys\\<rbrakk>\n       \\<Longrightarrow> h \\<turnstile> filter_M P []\n                         \\<rightarrow>\\<^sub>r ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>\\<And>x.\n                               x \\<in> set xs \\<Longrightarrow>\n                               pure (P x) h \\<and> h \\<turnstile> ok P x;\n                    filter (\\<lambda>x. |h \\<turnstile> P x|\\<^sub>r) xs =\n                    ys\\<rbrakk>\n                   \\<Longrightarrow> h \\<turnstile> filter_M P xs\n                                     \\<rightarrow>\\<^sub>r ys;\n        \\<And>x.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           pure (P x) h \\<and> h \\<turnstile> ok P x;\n        filter (\\<lambda>x. |h \\<turnstile> P x|\\<^sub>r) (a # xs) =\n        ys\\<rbrakk>\n       \\<Longrightarrow> h \\<turnstile> filter_M P (a # xs)\n                         \\<rightarrow>\\<^sub>r ys", "by(auto elim!: bind_returns_result_E2 intro!: bind_pure_returns_result_I)"], ["", "lemma filter_ex1: \"\\<exists>!x \\<in> set xs. P x \\<Longrightarrow> P x \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow> distinct xs \n                  \\<Longrightarrow> filter P xs = [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>!x. x \\<in> set xs \\<and> P x; P x; x \\<in> set xs;\n     distinct xs\\<rbrakk>\n    \\<Longrightarrow> filter P xs = [x]", "apply(auto)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>P x; x \\<in> set xs; distinct xs;\n        \\<forall>y y'.\n           y \\<in> set xs \\<and>\n           P y \\<and> y' \\<in> set xs \\<and> P y' \\<longrightarrow>\n           y = y';\n        xa \\<in> set xs; P xa\\<rbrakk>\n       \\<Longrightarrow> filter P xs = [x]", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       \\<lbrakk>P x; x \\<in> set []; distinct [];\n        \\<forall>y y'.\n           y \\<in> set [] \\<and>\n           P y \\<and> y' \\<in> set [] \\<and> P y' \\<longrightarrow>\n           y = y';\n        xa \\<in> set []; P xa\\<rbrakk>\n       \\<Longrightarrow> filter P [] = [x]\n 2. \\<And>a xs xa.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>P x; x \\<in> set xs; distinct xs;\n                    \\<forall>y y'.\n                       y \\<in> set xs \\<and>\n                       P y \\<and>\n                       y' \\<in> set xs \\<and> P y' \\<longrightarrow>\n                       y = y';\n                    xa \\<in> set xs; P xa\\<rbrakk>\n                   \\<Longrightarrow> filter P xs = [x];\n        P x; x \\<in> set (a # xs); distinct (a # xs);\n        \\<forall>y y'.\n           y \\<in> set (a # xs) \\<and>\n           P y \\<and> y' \\<in> set (a # xs) \\<and> P y' \\<longrightarrow>\n           y = y';\n        xa \\<in> set (a # xs); P xa\\<rbrakk>\n       \\<Longrightarrow> filter P (a # xs) = [x]", "apply(auto)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs xa.\n       \\<lbrakk>\\<And>xa.\n                   \\<lbrakk>P x; x \\<in> set xs; distinct xs;\n                    \\<forall>y y'.\n                       y \\<in> set xs \\<and>\n                       P y \\<and>\n                       y' \\<in> set xs \\<and> P y' \\<longrightarrow>\n                       y = y';\n                    xa \\<in> set xs; P xa\\<rbrakk>\n                   \\<Longrightarrow> filter P xs = [x];\n        P x; x \\<in> set (a # xs); distinct (a # xs);\n        \\<forall>y y'.\n           y \\<in> set (a # xs) \\<and>\n           P y \\<and> y' \\<in> set (a # xs) \\<and> P y' \\<longrightarrow>\n           y = y';\n        xa \\<in> set (a # xs); P xa\\<rbrakk>\n       \\<Longrightarrow> filter P (a # xs) = [x]", "apply(auto)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>y y'.\n                   (y = x \\<or> y \\<in> set xs) \\<and>\n                   P y \\<and>\n                   (y' = x \\<or> y' \\<in> set xs) \\<and>\n                   P y' \\<longrightarrow>\n                   y = y';\n        x \\<notin> set xs; distinct xs; P x\\<rbrakk>\n       \\<Longrightarrow> filter P xs = []", "using filter_empty_conv"], ["proof (prove)\nusing this:\n  (filter ?P ?xs = []) = (\\<forall>x\\<in>set ?xs. \\<not> ?P x)\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>y y'.\n                   (y = x \\<or> y \\<in> set xs) \\<and>\n                   P y \\<and>\n                   (y' = x \\<or> y' \\<in> set xs) \\<and>\n                   P y' \\<longrightarrow>\n                   y = y';\n        x \\<notin> set xs; distinct xs; P x\\<rbrakk>\n       \\<Longrightarrow> filter P xs = []", "by fastforce"], ["", "lemma filter_M_ex1:\n  assumes \"h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys\"\n    and \"x \\<in> set xs\"\n    and \"\\<exists>!x \\<in> set xs. h \\<turnstile> P x \\<rightarrow>\\<^sub>r True\"\n    and \"\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h\"\n    and \"distinct xs\"\n    and \"h \\<turnstile> P x \\<rightarrow>\\<^sub>r True\"\n  shows \"ys = [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ys = [x]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ys = [x]", "have *: \"\\<exists>!x \\<in> set xs. |h \\<turnstile> P x|\\<^sub>r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> set xs \\<and> |h \\<turnstile> P x|\\<^sub>r", "apply(insert assms(1) assms(3) assms(4))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n     \\<exists>!x.\n        x \\<in> set xs \\<and> h \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n     \\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h\\<rbrakk>\n    \\<Longrightarrow> \\<exists>!x.\n                         x \\<in> set xs \\<and> |h \\<turnstile> P x|\\<^sub>r", "apply(drule filter_M_filter)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<exists>!x.\n                   x \\<in> set xs \\<and>\n                   h \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        \\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h;\n        x \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> pure (P x) h\n 2. \\<lbrakk>\\<exists>!x.\n                x \\<in> set xs \\<and>\n                h \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n     \\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h;\n     (\\<forall>x\\<in>set xs. h \\<turnstile> ok P x) \\<and>\n     ys = filter (\\<lambda>x. |h \\<turnstile> P x|\\<^sub>r) xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>!x.\n                         x \\<in> set xs \\<and> |h \\<turnstile> P x|\\<^sub>r", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>!x.\n                x \\<in> set xs \\<and>\n                h \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n     \\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h;\n     (\\<forall>x\\<in>set xs. h \\<turnstile> ok P x) \\<and>\n     ys = filter (\\<lambda>x. |h \\<turnstile> P x|\\<^sub>r) xs\\<rbrakk>\n    \\<Longrightarrow> \\<exists>!x.\n                         x \\<in> set xs \\<and> |h \\<turnstile> P x|\\<^sub>r", "apply(auto simp add: select_result_I2)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa y.\n       \\<lbrakk>\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h;\n        \\<forall>y y'.\n           y \\<in> set xs \\<and>\n           h \\<turnstile> P y \\<rightarrow>\\<^sub>r True \\<and>\n           y' \\<in> set xs \\<and>\n           h \\<turnstile> P y' \\<rightarrow>\\<^sub>r True \\<longrightarrow>\n           y = y';\n        \\<forall>x\\<in>set xs. h \\<turnstile> ok P x;\n        ys = filter (\\<lambda>x. |h \\<turnstile> P x|\\<^sub>r) xs;\n        x \\<in> set xs; h \\<turnstile> P x \\<rightarrow>\\<^sub>r True;\n        xa \\<in> set xs; |h \\<turnstile> P xa|\\<^sub>r; y \\<in> set xs;\n        |h \\<turnstile> P y|\\<^sub>r\\<rbrakk>\n       \\<Longrightarrow> xa = y", "by (metis (full_types) is_OK_returns_result_E select_result_I2)"], ["proof (state)\nthis:\n  \\<exists>!x. x \\<in> set xs \\<and> |h \\<turnstile> P x|\\<^sub>r\n\ngoal (1 subgoal):\n 1. ys = [x]", "then"], ["proof (chain)\npicking this:\n  \\<exists>!x. x \\<in> set xs \\<and> |h \\<turnstile> P x|\\<^sub>r", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>!x. x \\<in> set xs \\<and> |h \\<turnstile> P x|\\<^sub>r\n\ngoal (1 subgoal):\n 1. ys = [x]", "apply(insert assms(1) assms(4))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys;\n     \\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h\\<rbrakk>\n    \\<Longrightarrow> ys = [x]", "apply(drule filter_M_filter)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h;\n        x \\<in> set xs\\<rbrakk>\n       \\<Longrightarrow> pure (P x) h\n 2. \\<lbrakk>\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h;\n     (\\<forall>x\\<in>set xs. h \\<turnstile> ok P x) \\<and>\n     ys = filter (\\<lambda>x. |h \\<turnstile> P x|\\<^sub>r) xs\\<rbrakk>\n    \\<Longrightarrow> ys = [x]", "apply(auto)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h;\n     (\\<forall>x\\<in>set xs. h \\<turnstile> ok P x) \\<and>\n     ys = filter (\\<lambda>x. |h \\<turnstile> P x|\\<^sub>r) xs\\<rbrakk>\n    \\<Longrightarrow> ys = [x]", "by (metis * assms(2) assms(5) assms(6) distinct_filter \n        distinct_length_2_or_more filter_empty_conv filter_set list.exhaust \n        list.set_intros(1) list.set_intros(2) member_filter select_result_I2)"], ["proof (state)\nthis:\n  ys = [x]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filter_M_eq:\n  assumes \"\\<And>x. pure (P x) h\" and \"\\<And>x. pure (P x) h'\"\n    and \"\\<And>b x. x \\<in> set xs \\<Longrightarrow> h \\<turnstile> P x \\<rightarrow>\\<^sub>r b = h' \\<turnstile> P x \\<rightarrow>\\<^sub>r b\"\n  shows \"h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys \\<longleftrightarrow> h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys =\n    h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys", "using assms"], ["proof (prove)\nusing this:\n  pure (P ?x) h\n  pure (P ?x) h'\n  ?x \\<in> set xs \\<Longrightarrow>\n  h \\<turnstile> P ?x \\<rightarrow>\\<^sub>r ?b =\n  h' \\<turnstile> P ?x \\<rightarrow>\\<^sub>r ?b\n\ngoal (1 subgoal):\n 1. h \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys =\n    h' \\<turnstile> filter_M P xs \\<rightarrow>\\<^sub>r ys", "apply (induct xs arbitrary: ys)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>\\<And>x. pure (P x) h; \\<And>x. pure (P x) h';\n        \\<And>x b.\n           x \\<in> set [] \\<Longrightarrow>\n           h \\<turnstile> P x \\<rightarrow>\\<^sub>r b =\n           h' \\<turnstile> P x \\<rightarrow>\\<^sub>r b\\<rbrakk>\n       \\<Longrightarrow> h \\<turnstile> filter_M P []\n                         \\<rightarrow>\\<^sub>r ys =\n                         h' \\<turnstile> filter_M P []\n                         \\<rightarrow>\\<^sub>r ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>\\<And>x. pure (P x) h; \\<And>x. pure (P x) h';\n                    \\<And>x b.\n                       x \\<in> set xs \\<Longrightarrow>\n                       h \\<turnstile> P x \\<rightarrow>\\<^sub>r b =\n                       h' \\<turnstile> P x \\<rightarrow>\\<^sub>r b\\<rbrakk>\n                   \\<Longrightarrow> h \\<turnstile> filter_M P xs\n                                     \\<rightarrow>\\<^sub>r ys =\n                                     h' \\<turnstile> filter_M P xs\n                                     \\<rightarrow>\\<^sub>r ys;\n        \\<And>x. pure (P x) h; \\<And>x. pure (P x) h';\n        \\<And>x b.\n           x \\<in> set (a # xs) \\<Longrightarrow>\n           h \\<turnstile> P x \\<rightarrow>\\<^sub>r b =\n           h' \\<turnstile> P x \\<rightarrow>\\<^sub>r b\\<rbrakk>\n       \\<Longrightarrow> h \\<turnstile> filter_M P (a # xs)\n                         \\<rightarrow>\\<^sub>r ys =\n                         h' \\<turnstile> filter_M P (a # xs)\n                         \\<rightarrow>\\<^sub>r ys", "by(auto elim!: bind_returns_result_E2 intro!: bind_pure_returns_result_I \n      dest: returns_result_eq)"], ["", "subsection \\<open>Map Filter\\<close>"], ["", "definition map_filter_M :: \"('x \\<Rightarrow> ('heap, 'e, 'y option) prog) \\<Rightarrow> 'x list\n  \\<Rightarrow> ('heap, 'e, 'y list) prog\"\n  where\n    \"map_filter_M f xs = do {\n      ys_opts \\<leftarrow> map_M f xs;\n      ys_no_opts \\<leftarrow> filter_M (\\<lambda>x. return (x \\<noteq> None)) ys_opts;\n      map_M (\\<lambda>x. return (the x)) ys_no_opts\n    }\""], ["", "lemma map_filter_M_pure: \"(\\<And>x h. x \\<in> set xs \\<Longrightarrow> pure (f x) h) \\<Longrightarrow> pure (map_filter_M f xs) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x h.\n        x \\<in> set xs \\<Longrightarrow> pure (f x) h) \\<Longrightarrow>\n    pure (map_filter_M f xs) h", "by(auto simp add: map_filter_M_def map_M_pure_I intro!: bind_pure_I)"], ["", "lemma map_filter_M_pure_E:\n  assumes \"h \\<turnstile> (map_filter_M::('x \\<Rightarrow> ('heap, 'e, 'y option) prog) \\<Rightarrow> 'x list\n  \\<Rightarrow> ('heap, 'e, 'y list) prog) f xs \\<rightarrow>\\<^sub>r ys\" and \"y \\<in> set ys\" and \"\\<And>x h. x \\<in> set xs \\<Longrightarrow> pure (f x) h\"\n  obtains x where \"h \\<turnstile> f x \\<rightarrow>\\<^sub>r Some y\" and \"x \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>h \\<turnstile> f x \\<rightarrow>\\<^sub>r Some y;\n         x \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>h \\<turnstile> f x \\<rightarrow>\\<^sub>r Some y;\n         x \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain ys_opts ys_no_opts where\n    ys_opts: \"h \\<turnstile> map_M f xs \\<rightarrow>\\<^sub>r ys_opts\" and\n    ys_no_opts: \"h \\<turnstile> filter_M (\\<lambda>x. (return (x \\<noteq> None)::('heap, 'e, bool) prog)) ys_opts \\<rightarrow>\\<^sub>r ys_no_opts\" and\n    ys: \"h \\<turnstile> map_M (\\<lambda>x. (return (the x)::('heap, 'e, 'y) prog)) ys_no_opts \\<rightarrow>\\<^sub>r ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ys_opts ys_no_opts.\n        \\<lbrakk>h \\<turnstile> map_M f xs \\<rightarrow>\\<^sub>r ys_opts;\n         h \\<turnstile> filter_M (\\<lambda>x. return (x \\<noteq> None))\n                         ys_opts\n         \\<rightarrow>\\<^sub>r ys_no_opts;\n         h \\<turnstile> map_M (\\<lambda>x. return (the x)) ys_no_opts\n         \\<rightarrow>\\<^sub>r ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> map_filter_M f xs \\<rightarrow>\\<^sub>r ys\n  y \\<in> set ys\n  ?x \\<in> set xs \\<Longrightarrow> pure (f ?x) ?h\n\ngoal (1 subgoal):\n 1. (\\<And>ys_opts ys_no_opts.\n        \\<lbrakk>h \\<turnstile> map_M f xs \\<rightarrow>\\<^sub>r ys_opts;\n         h \\<turnstile> filter_M (\\<lambda>x. return (x \\<noteq> None))\n                         ys_opts\n         \\<rightarrow>\\<^sub>r ys_no_opts;\n         h \\<turnstile> map_M (\\<lambda>x. return (the x)) ys_no_opts\n         \\<rightarrow>\\<^sub>r ys\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: map_filter_M_def map_M_pure_I elim!: bind_returns_result_E2)"], ["proof (state)\nthis:\n  h \\<turnstile> map_M f xs \\<rightarrow>\\<^sub>r ys_opts\n  h \\<turnstile> filter_M (\\<lambda>x. return (x \\<noteq> None)) ys_opts\n  \\<rightarrow>\\<^sub>r ys_no_opts\n  h \\<turnstile> map_M (\\<lambda>x. return (the x)) ys_no_opts\n  \\<rightarrow>\\<^sub>r ys\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>h \\<turnstile> f x \\<rightarrow>\\<^sub>r Some y;\n         x \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<forall>y \\<in> set ys_no_opts. y \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set ys_no_opts. y \\<noteq> None", "using ys_no_opts filter_M_holds_for_result"], ["proof (prove)\nusing this:\n  h \\<turnstile> filter_M (\\<lambda>x. return (x \\<noteq> None)) ys_opts\n  \\<rightarrow>\\<^sub>r ys_no_opts\n  \\<lbrakk>?h \\<turnstile> filter_M ?P ?xs \\<rightarrow>\\<^sub>r ?ys;\n   ?x \\<in> set ?ys;\n   \\<And>x h. x \\<in> set ?xs \\<Longrightarrow> pure (?P x) h\\<rbrakk>\n  \\<Longrightarrow> ?h \\<turnstile> ?P ?x \\<rightarrow>\\<^sub>r True\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set ys_no_opts. y \\<noteq> None", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set ys_no_opts. y \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>h \\<turnstile> f x \\<rightarrow>\\<^sub>r Some y;\n         x \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<forall>y\\<in>set ys_no_opts. y \\<noteq> None", "have \"Some y \\<in> set ys_no_opts\""], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set ys_no_opts. y \\<noteq> None\n\ngoal (1 subgoal):\n 1. Some y \\<in> set ys_no_opts", "using map_M_pure_E2 ys \\<open>y \\<in> set ys\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set ys_no_opts. y \\<noteq> None\n  \\<lbrakk>?h \\<turnstile> map_M ?g ?xs \\<rightarrow>\\<^sub>r ?ys;\n   ?y \\<in> set ?ys;\n   \\<And>x h. x \\<in> set ?xs \\<Longrightarrow> pure (?g x) h;\n   \\<And>x.\n      \\<lbrakk>?h \\<turnstile> ?g x \\<rightarrow>\\<^sub>r ?y;\n       x \\<in> set ?xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  h \\<turnstile> map_M (\\<lambda>x. return (the x)) ys_no_opts\n  \\<rightarrow>\\<^sub>r ys\n  y \\<in> set ys\n\ngoal (1 subgoal):\n 1. Some y \\<in> set ys_no_opts", "by (metis (no_types, lifting) option.collapse return_pure return_returns_result)"], ["proof (state)\nthis:\n  Some y \\<in> set ys_no_opts\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>h \\<turnstile> f x \\<rightarrow>\\<^sub>r Some y;\n         x \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  Some y \\<in> set ys_no_opts", "have \"Some y \\<in> set ys_opts\""], ["proof (prove)\nusing this:\n  Some y \\<in> set ys_no_opts\n\ngoal (1 subgoal):\n 1. Some y \\<in> set ys_opts", "using filter_M_subset ys_no_opts"], ["proof (prove)\nusing this:\n  Some y \\<in> set ys_no_opts\n  ?h \\<turnstile> filter_M ?P ?xs\n  \\<rightarrow>\\<^sub>r ?ys \\<Longrightarrow>\n  set ?ys \\<subseteq> set ?xs\n  h \\<turnstile> filter_M (\\<lambda>x. return (x \\<noteq> None)) ys_opts\n  \\<rightarrow>\\<^sub>r ys_no_opts\n\ngoal (1 subgoal):\n 1. Some y \\<in> set ys_opts", "by fastforce"], ["proof (state)\nthis:\n  Some y \\<in> set ys_opts\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>h \\<turnstile> f x \\<rightarrow>\\<^sub>r Some y;\n         x \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  Some y \\<in> set ys_opts", "show \"(\\<And>x. h \\<turnstile> f x \\<rightarrow>\\<^sub>r Some y \\<Longrightarrow> x \\<in> set xs \\<Longrightarrow> thesis) \\<Longrightarrow> thesis\""], ["proof (prove)\nusing this:\n  Some y \\<in> set ys_opts\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>h \\<turnstile> f x \\<rightarrow>\\<^sub>r Some y;\n         x \\<in> set xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis assms(3) map_M_pure_E2 ys_opts)"], ["proof (state)\nthis:\n  (\\<And>x.\n      \\<lbrakk>h \\<turnstile> f x \\<rightarrow>\\<^sub>r Some y;\n       x \\<in> set xs\\<rbrakk>\n      \\<Longrightarrow> thesis) \\<Longrightarrow>\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Iterate\\<close>"], ["", "fun iterate_M :: \"('heap, 'e, 'result) prog list \\<Rightarrow> ('heap, 'e, 'result) prog\"\n  where\n    \"iterate_M [] = return undefined\"\n  | \"iterate_M (x # xs) = x \\<bind> (\\<lambda>_. iterate_M xs)\""], ["", "lemma iterate_M_concat:\n  assumes \"h \\<turnstile> iterate_M xs \\<rightarrow>\\<^sub>h h'\"\n    and \"h' \\<turnstile> iterate_M ys \\<rightarrow>\\<^sub>h h''\"\n  shows \"h \\<turnstile> iterate_M (xs @ ys) \\<rightarrow>\\<^sub>h h''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> iterate_M (xs @ ys) \\<rightarrow>\\<^sub>h h''", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> iterate_M xs \\<rightarrow>\\<^sub>h h'\n  h' \\<turnstile> iterate_M ys \\<rightarrow>\\<^sub>h h''\n\ngoal (1 subgoal):\n 1. h \\<turnstile> iterate_M (xs @ ys) \\<rightarrow>\\<^sub>h h''", "apply(induct \"xs\" arbitrary: h h'')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h h''.\n       \\<lbrakk>h \\<turnstile> iterate_M [] \\<rightarrow>\\<^sub>h h';\n        h' \\<turnstile> iterate_M ys \\<rightarrow>\\<^sub>h h''\\<rbrakk>\n       \\<Longrightarrow> h \\<turnstile> iterate_M ([] @ ys)\n                         \\<rightarrow>\\<^sub>h h''\n 2. \\<And>a xs h h''.\n       \\<lbrakk>\\<And>h h''.\n                   \\<lbrakk>h \\<turnstile> iterate_M xs\n                            \\<rightarrow>\\<^sub>h h';\n                    h' \\<turnstile> iterate_M ys\n                    \\<rightarrow>\\<^sub>h h''\\<rbrakk>\n                   \\<Longrightarrow> h \\<turnstile> iterate_M (xs @ ys)\n                                     \\<rightarrow>\\<^sub>h h'';\n        h \\<turnstile> iterate_M (a # xs) \\<rightarrow>\\<^sub>h h';\n        h' \\<turnstile> iterate_M ys \\<rightarrow>\\<^sub>h h''\\<rbrakk>\n       \\<Longrightarrow> h \\<turnstile> iterate_M ((a # xs) @ ys)\n                         \\<rightarrow>\\<^sub>h h''", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs h h''.\n       \\<lbrakk>\\<And>h h''.\n                   \\<lbrakk>h \\<turnstile> iterate_M xs\n                            \\<rightarrow>\\<^sub>h h';\n                    h' \\<turnstile> iterate_M ys\n                    \\<rightarrow>\\<^sub>h h''\\<rbrakk>\n                   \\<Longrightarrow> h \\<turnstile> iterate_M (xs @ ys)\n                                     \\<rightarrow>\\<^sub>h h'';\n        h \\<turnstile> iterate_M (a # xs) \\<rightarrow>\\<^sub>h h';\n        h' \\<turnstile> iterate_M ys \\<rightarrow>\\<^sub>h h''\\<rbrakk>\n       \\<Longrightarrow> h \\<turnstile> iterate_M ((a # xs) @ ys)\n                         \\<rightarrow>\\<^sub>h h''", "apply(auto)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a xs h h''.\n       \\<lbrakk>\\<And>h h''.\n                   \\<lbrakk>h \\<turnstile> iterate_M xs\n                            \\<rightarrow>\\<^sub>h h';\n                    h' \\<turnstile> iterate_M ys\n                    \\<rightarrow>\\<^sub>h h''\\<rbrakk>\n                   \\<Longrightarrow> h \\<turnstile> iterate_M (xs @ ys)\n                                     \\<rightarrow>\\<^sub>h h'';\n        h \\<turnstile> a \\<bind> (\\<lambda>_. iterate_M xs)\n        \\<rightarrow>\\<^sub>h h';\n        h' \\<turnstile> iterate_M ys \\<rightarrow>\\<^sub>h h''\\<rbrakk>\n       \\<Longrightarrow> h \\<turnstile> a \\<bind>\n  (\\<lambda>_. iterate_M (xs @ ys))\n                         \\<rightarrow>\\<^sub>h h''", "by (meson bind_returns_heap_E bind_returns_heap_I)"], ["", "subsection\\<open>Miscellaneous Rules\\<close>"], ["", "lemma execute_bind_simp:\n  assumes \"h \\<turnstile> f \\<rightarrow>\\<^sub>r x\" and \"h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\"\n  shows \"h \\<turnstile> f \\<bind> g = h' \\<turnstile> g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<bind> g = h' \\<turnstile> g x", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> f \\<rightarrow>\\<^sub>r x\n  h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<bind> g = h' \\<turnstile> g x", "by(auto simp add: returns_result_def returns_heap_def bind_def execute_def  \n      split: sum.splits)"], ["", "lemma bind_cong [fundef_cong]:\n  fixes f1 f2 :: \"('heap, 'e, 'result) prog\"\n    and g1 g2 :: \"'result \\<Rightarrow> ('heap, 'e, 'result2) prog\"\n  assumes \"h \\<turnstile> f1 = h \\<turnstile> f2\"\n    and \"\\<And>y h'. h \\<turnstile> f1 \\<rightarrow>\\<^sub>r y \\<Longrightarrow> h \\<turnstile> f1 \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h' \\<turnstile> g1 y = h' \\<turnstile> g2 y\"\n  shows \"h \\<turnstile> (f1 \\<bind> g1) = h \\<turnstile> (f2 \\<bind> g2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> f1 \\<bind> g1 = h \\<turnstile> f2 \\<bind> g2", "apply(insert assms, cases \"h \\<turnstile> f1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>h \\<turnstile> f1 = h \\<turnstile> f2;\n        \\<And>y h'.\n           \\<lbrakk>h \\<turnstile> f1 \\<rightarrow>\\<^sub>r y;\n            h \\<turnstile> f1 \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n           \\<Longrightarrow> h' \\<turnstile> g1 y = h' \\<turnstile> g2 y;\n        h \\<turnstile> f1 = Inl a\\<rbrakk>\n       \\<Longrightarrow> h \\<turnstile> f1 \\<bind> g1 =\n                         h \\<turnstile> f2 \\<bind> g2\n 2. \\<And>b.\n       \\<lbrakk>h \\<turnstile> f1 = h \\<turnstile> f2;\n        \\<And>y h'.\n           \\<lbrakk>h \\<turnstile> f1 \\<rightarrow>\\<^sub>r y;\n            h \\<turnstile> f1 \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n           \\<Longrightarrow> h' \\<turnstile> g1 y = h' \\<turnstile> g2 y;\n        h \\<turnstile> f1 = Inr b\\<rbrakk>\n       \\<Longrightarrow> h \\<turnstile> f1 \\<bind> g1 =\n                         h \\<turnstile> f2 \\<bind> g2", "by(auto simp add: bind_def returns_result_def returns_heap_def execute_def \n      split: sum.splits)"], ["", "lemma bind_cong_2:\n  assumes \"pure f h\" and \"pure f h'\"\n    and \"\\<And>x. h \\<turnstile> f \\<rightarrow>\\<^sub>r x = h' \\<turnstile> f \\<rightarrow>\\<^sub>r x\"\n    and \"\\<And>x. h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<Longrightarrow> h \\<turnstile> g x \\<rightarrow>\\<^sub>r y = h' \\<turnstile> g x \\<rightarrow>\\<^sub>r y'\"\n  shows \"h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y = h' \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y =\n    h' \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y'", "using assms"], ["proof (prove)\nusing this:\n  pure f h\n  pure f h'\n  h \\<turnstile> f \\<rightarrow>\\<^sub>r ?x =\n  h' \\<turnstile> f \\<rightarrow>\\<^sub>r ?x\n  h \\<turnstile> f \\<rightarrow>\\<^sub>r ?x \\<Longrightarrow>\n  h \\<turnstile> g ?x \\<rightarrow>\\<^sub>r y =\n  h' \\<turnstile> g ?x \\<rightarrow>\\<^sub>r y'\n\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y =\n    h' \\<turnstile> f \\<bind> g \\<rightarrow>\\<^sub>r y'", "by(auto intro!: bind_pure_returns_result_I elim!: bind_returns_result_E2)"], ["", "lemma bind_case_cong [fundef_cong]:\n  assumes \"x = x'\" and \"\\<And>a. x = Some a \\<Longrightarrow> f a h = f' a h\"\n  shows \"(case x of Some a \\<Rightarrow> f a | None \\<Rightarrow> g) h = (case x' of Some a \\<Rightarrow> f' a | None \\<Rightarrow> g) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case x of None \\<Rightarrow> g | Some a \\<Rightarrow> f a) h =\n    (case x' of None \\<Rightarrow> g | Some a \\<Rightarrow> f' a) h", "by (insert assms, simp add: option.case_eq_if)"], ["", "subsection \\<open>Reasoning About Reads and Writes\\<close>"], ["", "definition preserved :: \"('heap, 'e, 'result) prog \\<Rightarrow> 'heap \\<Rightarrow> 'heap \\<Rightarrow> bool\"\n  where\n    \"preserved f h h' \\<longleftrightarrow> (\\<forall>x. h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<longleftrightarrow> h' \\<turnstile> f \\<rightarrow>\\<^sub>r x)\""], ["", "lemma preserved_code [code]:\n  \"preserved f h h' = (((h \\<turnstile> ok f) \\<and> (h' \\<turnstile> ok f) \\<and> |h \\<turnstile> f|\\<^sub>r = |h' \\<turnstile> f|\\<^sub>r) \\<or> ((\\<not>h \\<turnstile> ok f) \\<and> (\\<not>h' \\<turnstile> ok f)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preserved f h h' =\n    (h \\<turnstile> ok f \\<and>\n     h' \\<turnstile> ok f \\<and>\n     |h \\<turnstile> f|\\<^sub>r = |h' \\<turnstile> f|\\<^sub>r \\<or>\n     \\<not> h \\<turnstile> ok f \\<and> \\<not> h' \\<turnstile> ok f)", "apply(auto simp add: preserved_def)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x.\n                h \\<turnstile> f \\<rightarrow>\\<^sub>r x =\n                h' \\<turnstile> f \\<rightarrow>\\<^sub>r x;\n     h \\<turnstile> ok f\\<rbrakk>\n    \\<Longrightarrow> h' \\<turnstile> ok f\n 2. \\<lbrakk>\\<forall>x.\n                h \\<turnstile> f \\<rightarrow>\\<^sub>r x =\n                h' \\<turnstile> f \\<rightarrow>\\<^sub>r x;\n     h' \\<turnstile> ok f\\<rbrakk>\n    \\<Longrightarrow> h \\<turnstile> ok f", "apply (meson is_OK_returns_result_E is_OK_returns_result_I)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma reflp_preserved_f [simp]: \"reflp (preserved f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflp (preserved f)", "by(auto simp add: preserved_def reflp_def)"], ["", "lemma transp_preserved_f [simp]: \"transp (preserved f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transp (preserved f)", "by(auto simp add: preserved_def transp_def)"], ["", "definition \n  all_args :: \"('a \\<Rightarrow> ('heap, 'e, 'result) prog) \\<Rightarrow> ('heap, 'e, 'result) prog set\"\n  where\n    \"all_args f = (\\<Union>arg. {f arg})\""], ["", "definition  \n  reads :: \"('heap \\<Rightarrow> 'heap \\<Rightarrow> bool) set \\<Rightarrow> ('heap, 'e, 'result) prog \\<Rightarrow> 'heap \n            \\<Rightarrow> 'heap \\<Rightarrow> bool\"\n  where\n    \"reads S getter h h' \\<longleftrightarrow> (\\<forall>P \\<in> S. reflp P \\<and> transp P) \\<and> ((\\<forall>P \\<in> S. P h h') \n                              \\<longrightarrow> preserved getter h h')\""], ["", "lemma reads_singleton [simp]: \"reads {preserved f} f h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reads {preserved f} f h h'", "by(auto simp add: reads_def)"], ["", "lemma reads_bind_pure:\n  assumes \"pure f h\" and \"pure f h'\"\n    and \"reads S f h h'\"\n    and \"\\<And>x. h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<Longrightarrow> reads S (g x) h h'\"\n  shows \"reads S (f \\<bind> g) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reads S (f \\<bind> g) h h'", "using assms"], ["proof (prove)\nusing this:\n  pure f h\n  pure f h'\n  reads S f h h'\n  h \\<turnstile> f \\<rightarrow>\\<^sub>r ?x \\<Longrightarrow>\n  reads S (g ?x) h h'\n\ngoal (1 subgoal):\n 1. reads S (f \\<bind> g) h h'", "by(auto simp add: reads_def pure_pure preserved_def \n      intro!: bind_pure_returns_result_I is_OK_returns_result_I \n      dest: pure_returns_heap_eq \n      elim!: bind_returns_result_E)"], ["", "lemma reads_insert_writes_set_left:\n  \"\\<forall>P \\<in> S. reflp P \\<and> transp P \\<Longrightarrow> reads {getter} f h h' \\<Longrightarrow> reads (insert getter S) f h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>P\\<in>S. reflp P \\<and> transp P;\n     reads {getter} f h h'\\<rbrakk>\n    \\<Longrightarrow> reads (insert getter S) f h h'", "unfolding reads_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>P\\<in>S. reflp P \\<and> transp P;\n     (\\<forall>P\\<in>{getter}. reflp P \\<and> transp P) \\<and>\n     ((\\<forall>P\\<in>{getter}. P h h') \\<longrightarrow>\n      preserved f h h')\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>P\\<in>insert getter S.\n                          reflp P \\<and> transp P) \\<and>\n                      ((\\<forall>P\\<in>insert getter S.\n                           P h h') \\<longrightarrow>\n                       preserved f h h')", "by simp"], ["", "lemma reads_insert_writes_set_right:\n  \"reflp getter \\<Longrightarrow> transp getter \\<Longrightarrow> reads S f h h' \\<Longrightarrow> reads (insert getter S) f h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reflp getter; transp getter; reads S f h h'\\<rbrakk>\n    \\<Longrightarrow> reads (insert getter S) f h h'", "unfolding reads_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reflp getter; transp getter;\n     (\\<forall>P\\<in>S. reflp P \\<and> transp P) \\<and>\n     ((\\<forall>P\\<in>S. P h h') \\<longrightarrow>\n      preserved f h h')\\<rbrakk>\n    \\<Longrightarrow> (\\<forall>P\\<in>insert getter S.\n                          reflp P \\<and> transp P) \\<and>\n                      ((\\<forall>P\\<in>insert getter S.\n                           P h h') \\<longrightarrow>\n                       preserved f h h')", "by blast"], ["", "lemma reads_subset:\n  \"reads S f h h' \\<Longrightarrow> \\<forall>P \\<in> S' - S. reflp P \\<and> transp P \\<Longrightarrow> S \\<subseteq> S' \\<Longrightarrow> reads S' f h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reads S f h h'; \\<forall>P\\<in>S' - S. reflp P \\<and> transp P;\n     S \\<subseteq> S'\\<rbrakk>\n    \\<Longrightarrow> reads S' f h h'", "by(auto simp add: reads_def)"], ["", "lemma return_reads [simp]: \"reads {} (return x) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reads {} (return x) h h'", "by(simp add: reads_def preserved_def)"], ["", "lemma error_reads [simp]: \"reads {} (error e) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reads {} (error e) h h'", "by(simp add: reads_def preserved_def)"], ["", "lemma noop_reads [simp]: \"reads {} noop h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reads {} noop h h'", "by(simp add: reads_def noop_def preserved_def)"], ["", "lemma filter_M_reads:\n  assumes \"\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h\" and \"\\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h'\"\n    and \"\\<And>x. x \\<in> set xs \\<Longrightarrow> reads S (P x) h h'\"\n    and \"\\<forall>P \\<in> S. reflp P \\<and> transp P\"\n  shows \"reads S (filter_M P xs) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reads S (filter_M P xs) h h'", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<Longrightarrow> pure (P ?x) h\n  ?x \\<in> set xs \\<Longrightarrow> pure (P ?x) h'\n  ?x \\<in> set xs \\<Longrightarrow> reads S (P ?x) h h'\n  \\<forall>P\\<in>S. reflp P \\<and> transp P\n\ngoal (1 subgoal):\n 1. reads S (filter_M P xs) h h'", "apply(induct xs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x. x \\<in> set [] \\<Longrightarrow> pure (P x) h;\n     \\<And>x. x \\<in> set [] \\<Longrightarrow> pure (P x) h';\n     \\<And>x. x \\<in> set [] \\<Longrightarrow> reads S (P x) h h';\n     \\<forall>P\\<in>S. reflp P \\<and> transp P\\<rbrakk>\n    \\<Longrightarrow> reads S (filter_M P []) h h'\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>\\<And>x.\n                            x \\<in> set xs \\<Longrightarrow> pure (P x) h;\n                 \\<And>x. x \\<in> set xs \\<Longrightarrow> pure (P x) h';\n                 \\<And>x.\n                    x \\<in> set xs \\<Longrightarrow> reads S (P x) h h';\n                 \\<forall>P\\<in>S. reflp P \\<and> transp P\\<rbrakk>\n                \\<Longrightarrow> reads S (filter_M P xs) h h';\n        \\<And>x. x \\<in> set (a # xs) \\<Longrightarrow> pure (P x) h;\n        \\<And>x. x \\<in> set (a # xs) \\<Longrightarrow> pure (P x) h';\n        \\<And>x. x \\<in> set (a # xs) \\<Longrightarrow> reads S (P x) h h';\n        \\<forall>P\\<in>S. reflp P \\<and> transp P\\<rbrakk>\n       \\<Longrightarrow> reads S (filter_M P (a # xs)) h h'", "by(auto intro: reads_subset[OF return_reads] intro!: reads_bind_pure)"], ["", "definition writes :: \n  \"('heap, 'e, 'result) prog set \\<Rightarrow> ('heap, 'e, 'result2) prog \\<Rightarrow> 'heap \\<Rightarrow> 'heap \\<Rightarrow> bool\"\n  where                                                                                \n    \"writes S setter h h' \n     \\<longleftrightarrow> (h \\<turnstile> setter \\<rightarrow>\\<^sub>h h' \\<longrightarrow> (\\<exists>progs. set progs \\<subseteq> S \\<and> h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'))\""], ["", "lemma writes_singleton [simp]: \"writes (all_args f) (f a) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. writes (all_args f) (f a) h h'", "apply(auto simp add: writes_def all_args_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> f a \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    \\<exists>progs.\n       set progs \\<subseteq> (\\<Union>arg. {f arg}) \\<and>\n       h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'", "apply(rule exI[where x=\"[f a]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> f a \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    set [f a] \\<subseteq> (\\<Union>arg. {f arg}) \\<and>\n    h \\<turnstile> iterate_M [f a] \\<rightarrow>\\<^sub>h h'", "by(auto)"], ["", "lemma writes_singleton2 [simp]: \"writes {f} f h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. writes {f} f h h'", "apply(auto simp add: writes_def all_args_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    \\<exists>progs.\n       set progs \\<subseteq> {f} \\<and>\n       h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'", "apply(rule exI[where x=\"[f]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> f \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    set [f] \\<subseteq> {f} \\<and>\n    h \\<turnstile> iterate_M [f] \\<rightarrow>\\<^sub>h h'", "by(auto)"], ["", "lemma writes_union_left_I:\n  assumes \"writes S f h h'\"\n  shows \"writes (S \\<union> S') f h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. writes (S \\<union> S') f h h'", "using assms"], ["proof (prove)\nusing this:\n  writes S f h h'\n\ngoal (1 subgoal):\n 1. writes (S \\<union> S') f h h'", "by(auto simp add: writes_def)"], ["", "lemma writes_union_right_I:\n  assumes \"writes S' f h h'\"\n  shows \"writes (S \\<union> S') f h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. writes (S \\<union> S') f h h'", "using assms"], ["proof (prove)\nusing this:\n  writes S' f h h'\n\ngoal (1 subgoal):\n 1. writes (S \\<union> S') f h h'", "by(auto simp add: writes_def)"], ["", "lemma writes_union_minus_split:\n  assumes \"writes (S - S2) f h h'\"\n    and \"writes (S' - S2) f h h'\"\n  shows \"writes ((S \\<union> S') - S2) f h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. writes (S \\<union> S' - S2) f h h'", "using assms"], ["proof (prove)\nusing this:\n  writes (S - S2) f h h'\n  writes (S' - S2) f h h'\n\ngoal (1 subgoal):\n 1. writes (S \\<union> S' - S2) f h h'", "by(auto simp add: writes_def)"], ["", "lemma writes_subset: \"writes S f h h' \\<Longrightarrow> S \\<subseteq> S' \\<Longrightarrow> writes S' f h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>writes S f h h'; S \\<subseteq> S'\\<rbrakk>\n    \\<Longrightarrow> writes S' f h h'", "by(auto simp add: writes_def)"], ["", "lemma writes_error [simp]: \"writes S (error e) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. writes S (error e) h h'", "by(simp add: writes_def)"], ["", "lemma writes_not_ok [simp]: \"\\<not>h \\<turnstile> ok f \\<Longrightarrow> writes S f h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> h \\<turnstile> ok f \\<Longrightarrow> writes S f h h'", "by(auto simp add: writes_def)"], ["", "lemma writes_pure [simp]:\n  assumes \"pure f h\"\n  shows \"writes S f h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. writes S f h h'", "using assms"], ["proof (prove)\nusing this:\n  pure f h\n\ngoal (1 subgoal):\n 1. writes S f h h'", "apply(auto simp add: writes_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pure f h; h \\<turnstile> f \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>progs.\n                         set progs \\<subseteq> S \\<and>\n                         h \\<turnstile> iterate_M progs\n                         \\<rightarrow>\\<^sub>h h'", "by (metis bot.extremum iterate_M.simps(1) list.set(1) pure_returns_heap_eq return_returns_heap)"], ["", "lemma writes_bind:\n  assumes \"\\<And>h2. writes S f h h2\" \n  assumes \"\\<And>x h2. h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<Longrightarrow> h \\<turnstile> f \\<rightarrow>\\<^sub>h h2 \\<Longrightarrow> writes S (g x) h2 h'\"\n  shows \"writes S (f \\<bind> g) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. writes S (f \\<bind> g) h h'", "using assms"], ["proof (prove)\nusing this:\n  writes S f h ?h2.0\n  \\<lbrakk>h \\<turnstile> f \\<rightarrow>\\<^sub>r ?x;\n   h \\<turnstile> f \\<rightarrow>\\<^sub>h ?h2.0\\<rbrakk>\n  \\<Longrightarrow> writes S (g ?x) ?h2.0 h'\n\ngoal (1 subgoal):\n 1. writes S (f \\<bind> g) h h'", "apply(auto simp add: writes_def elim!: bind_returns_heap_E)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x h'a.\n       \\<lbrakk>\\<And>h2.\n                   h \\<turnstile> f\n                   \\<rightarrow>\\<^sub>h h2 \\<longrightarrow>\n                   (\\<exists>progs.\n                       set progs \\<subseteq> S \\<and>\n                       h \\<turnstile> iterate_M progs\n                       \\<rightarrow>\\<^sub>h h2);\n        \\<And>x h2.\n           \\<lbrakk>h \\<turnstile> f \\<rightarrow>\\<^sub>r x;\n            h \\<turnstile> f \\<rightarrow>\\<^sub>h h2\\<rbrakk>\n           \\<Longrightarrow> h2 \\<turnstile> g x\n                             \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n                             (\\<exists>progs.\n                                 set progs \\<subseteq> S \\<and>\n                                 h2 \\<turnstile> iterate_M progs\n                                 \\<rightarrow>\\<^sub>h h');\n        h \\<turnstile> f \\<rightarrow>\\<^sub>r x;\n        h \\<turnstile> f \\<rightarrow>\\<^sub>h h'a;\n        h'a \\<turnstile> g x \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>progs.\n                            set progs \\<subseteq> S \\<and>\n                            h \\<turnstile> iterate_M progs\n                            \\<rightarrow>\\<^sub>h h'", "by (metis iterate_M_concat le_supI set_append)"], ["", "lemma writes_bind_pure:\n  assumes \"pure f h\"\n  assumes \"\\<And>x. h \\<turnstile> f \\<rightarrow>\\<^sub>r x \\<Longrightarrow> writes S (g x) h h'\"\n  shows \"writes S (f \\<bind> g) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. writes S (f \\<bind> g) h h'", "using assms"], ["proof (prove)\nusing this:\n  pure f h\n  h \\<turnstile> f \\<rightarrow>\\<^sub>r ?x \\<Longrightarrow>\n  writes S (g ?x) h h'\n\ngoal (1 subgoal):\n 1. writes S (f \\<bind> g) h h'", "by(auto simp add: writes_def elim!: bind_returns_heap_E2)"], ["", "lemma writes_small_big:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow>  h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> P h h'\"\n  assumes \"reflp P\"\n  assumes \"transp P\"\n  shows \"P h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P h h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P h h'", "obtain progs where \"set progs \\<subseteq> SW\" and iterate: \"h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>progs.\n        \\<lbrakk>set progs \\<subseteq> SW;\n         h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson assms(1) assms(2) writes_def)"], ["proof (state)\nthis:\n  set progs \\<subseteq> SW\n  h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. P h h'", "then"], ["proof (chain)\npicking this:\n  set progs \\<subseteq> SW\n  h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'", "have \"\\<And>h h'. \\<forall>prog \\<in> set progs. h \\<turnstile> prog \\<rightarrow>\\<^sub>h h' \\<longrightarrow> P h h'\""], ["proof (prove)\nusing this:\n  set progs \\<subseteq> SW\n  h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<forall>prog\\<in>set progs.\n          h \\<turnstile> prog \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n          P h h'", "using assms(3)"], ["proof (prove)\nusing this:\n  set progs \\<subseteq> SW\n  h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> P ?h ?h'\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<forall>prog\\<in>set progs.\n          h \\<turnstile> prog \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n          P h h'", "by auto"], ["proof (state)\nthis:\n  \\<forall>prog\\<in>set progs.\n     ?h \\<turnstile> prog \\<rightarrow>\\<^sub>h ?h' \\<longrightarrow>\n     P ?h ?h'\n\ngoal (1 subgoal):\n 1. P h h'", "with iterate assms(4) assms(5)"], ["proof (chain)\npicking this:\n  h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'\n  reflp P\n  transp P\n  \\<forall>prog\\<in>set progs.\n     ?h \\<turnstile> prog \\<rightarrow>\\<^sub>h ?h' \\<longrightarrow>\n     P ?h ?h'", "have \"h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> P h h'\""], ["proof (prove)\nusing this:\n  h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'\n  reflp P\n  transp P\n  \\<forall>prog\\<in>set progs.\n     ?h \\<turnstile> prog \\<rightarrow>\\<^sub>h ?h' \\<longrightarrow>\n     P ?h ?h'\n\ngoal (1 subgoal):\n 1. h \\<turnstile> iterate_M progs\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    P h h'", "proof(induct progs arbitrary: h)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h.\n       \\<lbrakk>h \\<turnstile> iterate_M [] \\<rightarrow>\\<^sub>h h';\n        h \\<turnstile> iterate_M [] \\<rightarrow>\\<^sub>h h'; reflp P;\n        transp P;\n        \\<And>h h'.\n           \\<forall>prog\\<in>set [].\n              h \\<turnstile> prog \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n              P h h'\\<rbrakk>\n       \\<Longrightarrow> P h h'\n 2. \\<And>a progs h.\n       \\<lbrakk>\\<And>h.\n                   \\<lbrakk>h \\<turnstile> iterate_M progs\n                            \\<rightarrow>\\<^sub>h h';\n                    h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h';\n                    reflp P; transp P;\n                    \\<And>h h'.\n                       \\<forall>prog\\<in>set progs.\n                          h \\<turnstile> prog\n                          \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n                          P h h'\\<rbrakk>\n                   \\<Longrightarrow> P h h';\n        h \\<turnstile> iterate_M (a # progs) \\<rightarrow>\\<^sub>h h';\n        h \\<turnstile> iterate_M (a # progs) \\<rightarrow>\\<^sub>h h';\n        reflp P; transp P;\n        \\<And>h h'.\n           \\<forall>prog\\<in>set (a # progs).\n              h \\<turnstile> prog \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n              P h h'\\<rbrakk>\n       \\<Longrightarrow> P h h'", "case Nil"], ["proof (state)\nthis:\n  h \\<turnstile> iterate_M [] \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> iterate_M [] \\<rightarrow>\\<^sub>h h'\n  reflp P\n  transp P\n  \\<forall>prog\\<in>set [].\n     ?h \\<turnstile> prog \\<rightarrow>\\<^sub>h ?h' \\<longrightarrow>\n     P ?h ?h'\n\ngoal (2 subgoals):\n 1. \\<And>h.\n       \\<lbrakk>h \\<turnstile> iterate_M [] \\<rightarrow>\\<^sub>h h';\n        h \\<turnstile> iterate_M [] \\<rightarrow>\\<^sub>h h'; reflp P;\n        transp P;\n        \\<And>h h'.\n           \\<forall>prog\\<in>set [].\n              h \\<turnstile> prog \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n              P h h'\\<rbrakk>\n       \\<Longrightarrow> P h h'\n 2. \\<And>a progs h.\n       \\<lbrakk>\\<And>h.\n                   \\<lbrakk>h \\<turnstile> iterate_M progs\n                            \\<rightarrow>\\<^sub>h h';\n                    h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h';\n                    reflp P; transp P;\n                    \\<And>h h'.\n                       \\<forall>prog\\<in>set progs.\n                          h \\<turnstile> prog\n                          \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n                          P h h'\\<rbrakk>\n                   \\<Longrightarrow> P h h';\n        h \\<turnstile> iterate_M (a # progs) \\<rightarrow>\\<^sub>h h';\n        h \\<turnstile> iterate_M (a # progs) \\<rightarrow>\\<^sub>h h';\n        reflp P; transp P;\n        \\<And>h h'.\n           \\<forall>prog\\<in>set (a # progs).\n              h \\<turnstile> prog \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n              P h h'\\<rbrakk>\n       \\<Longrightarrow> P h h'", "then"], ["proof (chain)\npicking this:\n  h \\<turnstile> iterate_M [] \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> iterate_M [] \\<rightarrow>\\<^sub>h h'\n  reflp P\n  transp P\n  \\<forall>prog\\<in>set [].\n     ?h \\<turnstile> prog \\<rightarrow>\\<^sub>h ?h' \\<longrightarrow>\n     P ?h ?h'", "show ?case"], ["proof (prove)\nusing this:\n  h \\<turnstile> iterate_M [] \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> iterate_M [] \\<rightarrow>\\<^sub>h h'\n  reflp P\n  transp P\n  \\<forall>prog\\<in>set [].\n     ?h \\<turnstile> prog \\<rightarrow>\\<^sub>h ?h' \\<longrightarrow>\n     P ?h ?h'\n\ngoal (1 subgoal):\n 1. P h h'", "using reflpE"], ["proof (prove)\nusing this:\n  h \\<turnstile> iterate_M [] \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> iterate_M [] \\<rightarrow>\\<^sub>h h'\n  reflp P\n  transp P\n  \\<forall>prog\\<in>set [].\n     ?h \\<turnstile> prog \\<rightarrow>\\<^sub>h ?h' \\<longrightarrow>\n     P ?h ?h'\n  \\<lbrakk>reflp ?r; ?r ?x ?x \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. P h h'", "by force"], ["proof (state)\nthis:\n  P h h'\n\ngoal (1 subgoal):\n 1. \\<And>a progs h.\n       \\<lbrakk>\\<And>h.\n                   \\<lbrakk>h \\<turnstile> iterate_M progs\n                            \\<rightarrow>\\<^sub>h h';\n                    h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h';\n                    reflp P; transp P;\n                    \\<And>h h'.\n                       \\<forall>prog\\<in>set progs.\n                          h \\<turnstile> prog\n                          \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n                          P h h'\\<rbrakk>\n                   \\<Longrightarrow> P h h';\n        h \\<turnstile> iterate_M (a # progs) \\<rightarrow>\\<^sub>h h';\n        h \\<turnstile> iterate_M (a # progs) \\<rightarrow>\\<^sub>h h';\n        reflp P; transp P;\n        \\<And>h h'.\n           \\<forall>prog\\<in>set (a # progs).\n              h \\<turnstile> prog \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n              P h h'\\<rbrakk>\n       \\<Longrightarrow> P h h'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a progs h.\n       \\<lbrakk>\\<And>h.\n                   \\<lbrakk>h \\<turnstile> iterate_M progs\n                            \\<rightarrow>\\<^sub>h h';\n                    h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h';\n                    reflp P; transp P;\n                    \\<And>h h'.\n                       \\<forall>prog\\<in>set progs.\n                          h \\<turnstile> prog\n                          \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n                          P h h'\\<rbrakk>\n                   \\<Longrightarrow> P h h';\n        h \\<turnstile> iterate_M (a # progs) \\<rightarrow>\\<^sub>h h';\n        h \\<turnstile> iterate_M (a # progs) \\<rightarrow>\\<^sub>h h';\n        reflp P; transp P;\n        \\<And>h h'.\n           \\<forall>prog\\<in>set (a # progs).\n              h \\<turnstile> prog \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n              P h h'\\<rbrakk>\n       \\<Longrightarrow> P h h'", "case (Cons a progs)"], ["proof (state)\nthis:\n  \\<lbrakk>?h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h';\n   ?h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'; reflp P;\n   transp P;\n   \\<And>h h'.\n      \\<forall>prog\\<in>set progs.\n         h \\<turnstile> prog \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n         P h h'\\<rbrakk>\n  \\<Longrightarrow> P ?h h'\n  h \\<turnstile> iterate_M (a # progs) \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> iterate_M (a # progs) \\<rightarrow>\\<^sub>h h'\n  reflp P\n  transp P\n  \\<forall>prog\\<in>set (a # progs).\n     ?h \\<turnstile> prog \\<rightarrow>\\<^sub>h ?h' \\<longrightarrow>\n     P ?h ?h'\n\ngoal (1 subgoal):\n 1. \\<And>a progs h.\n       \\<lbrakk>\\<And>h.\n                   \\<lbrakk>h \\<turnstile> iterate_M progs\n                            \\<rightarrow>\\<^sub>h h';\n                    h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h';\n                    reflp P; transp P;\n                    \\<And>h h'.\n                       \\<forall>prog\\<in>set progs.\n                          h \\<turnstile> prog\n                          \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n                          P h h'\\<rbrakk>\n                   \\<Longrightarrow> P h h';\n        h \\<turnstile> iterate_M (a # progs) \\<rightarrow>\\<^sub>h h';\n        h \\<turnstile> iterate_M (a # progs) \\<rightarrow>\\<^sub>h h';\n        reflp P; transp P;\n        \\<And>h h'.\n           \\<forall>prog\\<in>set (a # progs).\n              h \\<turnstile> prog \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n              P h h'\\<rbrakk>\n       \\<Longrightarrow> P h h'", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h';\n   ?h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'; reflp P;\n   transp P;\n   \\<And>h h'.\n      \\<forall>prog\\<in>set progs.\n         h \\<turnstile> prog \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n         P h h'\\<rbrakk>\n  \\<Longrightarrow> P ?h h'\n  h \\<turnstile> iterate_M (a # progs) \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> iterate_M (a # progs) \\<rightarrow>\\<^sub>h h'\n  reflp P\n  transp P\n  \\<forall>prog\\<in>set (a # progs).\n     ?h \\<turnstile> prog \\<rightarrow>\\<^sub>h ?h' \\<longrightarrow>\n     P ?h ?h'", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>?h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h';\n   ?h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'; reflp P;\n   transp P;\n   \\<And>h h'.\n      \\<forall>prog\\<in>set progs.\n         h \\<turnstile> prog \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n         P h h'\\<rbrakk>\n  \\<Longrightarrow> P ?h h'\n  h \\<turnstile> iterate_M (a # progs) \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> iterate_M (a # progs) \\<rightarrow>\\<^sub>h h'\n  reflp P\n  transp P\n  \\<forall>prog\\<in>set (a # progs).\n     ?h \\<turnstile> prog \\<rightarrow>\\<^sub>h ?h' \\<longrightarrow>\n     P ?h ?h'\n\ngoal (1 subgoal):\n 1. P h h'", "apply(auto elim!: bind_returns_heap_E)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x h'a.\n       \\<lbrakk>\\<And>h.\n                   h \\<turnstile> iterate_M progs\n                   \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n                   P h h';\n        reflp P; transp P;\n        \\<And>h h'.\n           (h \\<turnstile> a \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n            P h h') \\<and>\n           ((\\<exists>prog\\<in>set progs.\n                h \\<turnstile> prog\n                \\<rightarrow>\\<^sub>h h') \\<longrightarrow>\n            P h h');\n        h \\<turnstile> a \\<rightarrow>\\<^sub>r x;\n        h \\<turnstile> a \\<rightarrow>\\<^sub>h h'a;\n        h'a \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> P h h'", "by (metis (full_types) transpD)"], ["proof (state)\nthis:\n  P h h'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n  P h h'\n\ngoal (1 subgoal):\n 1. P h h'", "then"], ["proof (chain)\npicking this:\n  h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n  P h h'", "show ?thesis"], ["proof (prove)\nusing this:\n  h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n  P h h'\n\ngoal (1 subgoal):\n 1. P h h'", "using assms(1) iterate"], ["proof (prove)\nusing this:\n  h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n  P h h'\n  writes SW setter h h'\n  h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. P h h'", "by blast"], ["proof (state)\nthis:\n  P h h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reads_writes_preserved:\n  assumes \"reads SR getter h h'\"\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h'. \\<forall>w \\<in> SW. h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<longrightarrow> (\\<forall>r \\<in> SR. r h h')\"\n  shows \"h \\<turnstile> getter \\<rightarrow>\\<^sub>r x \\<longleftrightarrow> h' \\<turnstile> getter \\<rightarrow>\\<^sub>r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> getter \\<rightarrow>\\<^sub>r x =\n    h' \\<turnstile> getter \\<rightarrow>\\<^sub>r x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. h \\<turnstile> getter \\<rightarrow>\\<^sub>r x =\n    h' \\<turnstile> getter \\<rightarrow>\\<^sub>r x", "obtain progs where \"set progs \\<subseteq> SW\" and iterate: \"h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>progs.\n        \\<lbrakk>set progs \\<subseteq> SW;\n         h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson assms(2) assms(3) writes_def)"], ["proof (state)\nthis:\n  set progs \\<subseteq> SW\n  h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. h \\<turnstile> getter \\<rightarrow>\\<^sub>r x =\n    h' \\<turnstile> getter \\<rightarrow>\\<^sub>r x", "then"], ["proof (chain)\npicking this:\n  set progs \\<subseteq> SW\n  h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'", "have \"\\<And>h h'. \\<forall>prog \\<in> set progs. h \\<turnstile> prog \\<rightarrow>\\<^sub>h h' \\<longrightarrow> (\\<forall>r \\<in> SR. r h h')\""], ["proof (prove)\nusing this:\n  set progs \\<subseteq> SW\n  h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<forall>prog\\<in>set progs.\n          h \\<turnstile> prog \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n          (\\<forall>r\\<in>SR. r h h')", "using assms(4)"], ["proof (prove)\nusing this:\n  set progs \\<subseteq> SW\n  h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'\n  \\<forall>w\\<in>SW.\n     ?h \\<turnstile> w \\<rightarrow>\\<^sub>h ?h' \\<longrightarrow>\n     (\\<forall>r\\<in>SR. r ?h ?h')\n\ngoal (1 subgoal):\n 1. \\<And>h h'.\n       \\<forall>prog\\<in>set progs.\n          h \\<turnstile> prog \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n          (\\<forall>r\\<in>SR. r h h')", "by blast"], ["proof (state)\nthis:\n  \\<forall>prog\\<in>set progs.\n     ?h \\<turnstile> prog \\<rightarrow>\\<^sub>h ?h' \\<longrightarrow>\n     (\\<forall>r\\<in>SR. r ?h ?h')\n\ngoal (1 subgoal):\n 1. h \\<turnstile> getter \\<rightarrow>\\<^sub>r x =\n    h' \\<turnstile> getter \\<rightarrow>\\<^sub>r x", "with iterate"], ["proof (chain)\npicking this:\n  h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'\n  \\<forall>prog\\<in>set progs.\n     ?h \\<turnstile> prog \\<rightarrow>\\<^sub>h ?h' \\<longrightarrow>\n     (\\<forall>r\\<in>SR. r ?h ?h')", "have \"\\<forall>r \\<in> SR. r h h'\""], ["proof (prove)\nusing this:\n  h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'\n  \\<forall>prog\\<in>set progs.\n     ?h \\<turnstile> prog \\<rightarrow>\\<^sub>h ?h' \\<longrightarrow>\n     (\\<forall>r\\<in>SR. r ?h ?h')\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>SR. r h h'", "using writes_small_big assms(1)"], ["proof (prove)\nusing this:\n  h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'\n  \\<forall>prog\\<in>set progs.\n     ?h \\<turnstile> prog \\<rightarrow>\\<^sub>h ?h' \\<longrightarrow>\n     (\\<forall>r\\<in>SR. r ?h ?h')\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> ?P h h';\n   reflp ?P; transp ?P\\<rbrakk>\n  \\<Longrightarrow> ?P ?h ?h'\n  reads SR getter h h'\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>SR. r h h'", "unfolding reads_def"], ["proof (prove)\nusing this:\n  h \\<turnstile> iterate_M progs \\<rightarrow>\\<^sub>h h'\n  \\<forall>prog\\<in>set progs.\n     ?h \\<turnstile> prog \\<rightarrow>\\<^sub>h ?h' \\<longrightarrow>\n     (\\<forall>r\\<in>SR. r ?h ?h')\n  \\<lbrakk>writes ?SW ?setter ?h ?h';\n   ?h \\<turnstile> ?setter \\<rightarrow>\\<^sub>h ?h';\n   \\<And>h h' w.\n      \\<lbrakk>w \\<in> ?SW;\n       h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n      \\<Longrightarrow> ?P h h';\n   reflp ?P; transp ?P\\<rbrakk>\n  \\<Longrightarrow> ?P ?h ?h'\n  (\\<forall>P\\<in>SR. reflp P \\<and> transp P) \\<and>\n  ((\\<forall>P\\<in>SR. P h h') \\<longrightarrow> preserved getter h h')\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>SR. r h h'", "by (metis assms(2) assms(3) assms(4))"], ["proof (state)\nthis:\n  \\<forall>r\\<in>SR. r h h'\n\ngoal (1 subgoal):\n 1. h \\<turnstile> getter \\<rightarrow>\\<^sub>r x =\n    h' \\<turnstile> getter \\<rightarrow>\\<^sub>r x", "then"], ["proof (chain)\npicking this:\n  \\<forall>r\\<in>SR. r h h'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>SR. r h h'\n\ngoal (1 subgoal):\n 1. h \\<turnstile> getter \\<rightarrow>\\<^sub>r x =\n    h' \\<turnstile> getter \\<rightarrow>\\<^sub>r x", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>SR. r h h'\n  reads SR getter h h'\n\ngoal (1 subgoal):\n 1. h \\<turnstile> getter \\<rightarrow>\\<^sub>r x =\n    h' \\<turnstile> getter \\<rightarrow>\\<^sub>r x", "by (simp add: preserved_def reads_def)"], ["proof (state)\nthis:\n  h \\<turnstile> getter \\<rightarrow>\\<^sub>r x =\n  h' \\<turnstile> getter \\<rightarrow>\\<^sub>r x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reads_writes_separate_forwards:\n  assumes \"reads SR getter h h'\"\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> getter \\<rightarrow>\\<^sub>r x\"\n  assumes \"\\<And>h h'. \\<forall>w \\<in> SW. h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<longrightarrow> (\\<forall>r \\<in> SR. r h h')\"\n  shows \"h' \\<turnstile> getter \\<rightarrow>\\<^sub>r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h' \\<turnstile> getter \\<rightarrow>\\<^sub>r x", "using reads_writes_preserved[OF assms(1) assms(2) assms(3) assms(5)] assms(4)"], ["proof (prove)\nusing this:\n  h \\<turnstile> getter \\<rightarrow>\\<^sub>r ?x =\n  h' \\<turnstile> getter \\<rightarrow>\\<^sub>r ?x\n  h \\<turnstile> getter \\<rightarrow>\\<^sub>r x\n\ngoal (1 subgoal):\n 1. h' \\<turnstile> getter \\<rightarrow>\\<^sub>r x", "by(auto simp add: preserved_def)"], ["", "lemma reads_writes_separate_backwards:\n  assumes \"reads SR getter h h'\"\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h' \\<turnstile> getter \\<rightarrow>\\<^sub>r x\"\n  assumes \"\\<And>h h'. \\<forall>w \\<in> SW. h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<longrightarrow> (\\<forall>r \\<in> SR. r h h')\"\n  shows \"h \\<turnstile> getter \\<rightarrow>\\<^sub>r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> getter \\<rightarrow>\\<^sub>r x", "using reads_writes_preserved[OF assms(1) assms(2) assms(3) assms(5)] assms(4)"], ["proof (prove)\nusing this:\n  h \\<turnstile> getter \\<rightarrow>\\<^sub>r ?x =\n  h' \\<turnstile> getter \\<rightarrow>\\<^sub>r ?x\n  h' \\<turnstile> getter \\<rightarrow>\\<^sub>r x\n\ngoal (1 subgoal):\n 1. h \\<turnstile> getter \\<rightarrow>\\<^sub>r x", "by(auto simp add: preserved_def)"], ["", "end"]]}