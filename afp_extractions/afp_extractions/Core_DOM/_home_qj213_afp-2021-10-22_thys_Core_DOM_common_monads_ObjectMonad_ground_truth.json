{"file_name": "/home/qj213/afp-2021-10-22/thys/Core_DOM/common/monads/ObjectMonad.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Core_DOM", "problem_names": ["lemmas object_ptr_kinds_M_defs = a_ptr_kinds_M_def", "lemma get_M_is_l_get_M: \"l_get_M get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t type_wf object_ptr_kinds\"", "lemmas get_M_defs = get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def[unfolded l_get_M.a_get_M_def[OF get_M_is_l_get_M]]", "lemmas get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_ok = get_M_ok[folded get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def]", "lemmas get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_ptr_in_heap = get_M_ptr_in_heap[folded get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def]", "lemma object_ptr_kinds_M_reads: \n  \"reads (\\<Union>object_ptr. {preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing)}) object_ptr_kinds_M h h'\"", "lemmas put_M_defs = a_put_M_def", "lemmas put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_ok = put_M_ok[folded put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def]", "lemmas put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_ptr_in_heap = put_M_ptr_in_heap[folded put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def]", "lemma check_in_heap_ptr_in_heap: \"ptr |\\<in>| object_ptr_kinds h \\<longleftrightarrow> h \\<turnstile> ok (check_in_heap ptr)\"", "lemma check_in_heap_pure [simp]: \"pure (check_in_heap ptr) h\"", "lemma check_in_heap_is_OK [simp]: \n  \"ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow> h \\<turnstile> ok (check_in_heap ptr \\<bind> f) = h \\<turnstile> ok (f ())\"", "lemma check_in_heap_returns_result [simp]: \n  \"ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow> h \\<turnstile> (check_in_heap ptr \\<bind> f) \\<rightarrow>\\<^sub>r x = h \\<turnstile> f () \\<rightarrow>\\<^sub>r x\"", "lemma check_in_heap_returns_heap [simp]: \n  \"ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow> h \\<turnstile> (check_in_heap ptr \\<bind> f) \\<rightarrow>\\<^sub>h h' = h \\<turnstile> f () \\<rightarrow>\\<^sub>h h'\"", "lemma check_in_heap_reads: \n  \"reads {preserved (get_M object_ptr nothing)} (check_in_heap object_ptr) h h'\"", "lemma invoke_split: \"P (invoke ((Pred, f) # xs) ptr args) =\n    ((\\<not>(Pred ptr) \\<longrightarrow> P (invoke xs ptr args))\n  \\<and> (Pred ptr \\<longrightarrow> P (do {check_in_heap ptr; f ptr args})))\"", "lemma invoke_split_asm: \"P (invoke ((Pred, f) # xs) ptr args) =\n    (\\<not>((\\<not>(Pred ptr) \\<and> (\\<not> P (invoke xs ptr args)))\n    \\<or> (Pred ptr \\<and> (\\<not> P (do {check_in_heap ptr; f ptr args})))))\"", "lemmas invoke_splits = invoke_split invoke_split_asm", "lemma invoke_ptr_in_heap: \"h \\<turnstile> ok (invoke xs ptr args) \\<Longrightarrow> ptr |\\<in>| object_ptr_kinds h\"", "lemma invoke_pure [simp]: \"pure (invoke [] ptr args) h\"", "lemma invoke_is_OK [simp]: \n  \"ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow> Pred ptr \n    \\<Longrightarrow> h \\<turnstile> ok (invoke ((Pred, f) # xs) ptr args) = h \\<turnstile> ok (f ptr args)\"", "lemma invoke_returns_result [simp]: \n  \"ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow> Pred ptr \n   \\<Longrightarrow> h \\<turnstile> (invoke ((Pred, f) # xs) ptr args) \\<rightarrow>\\<^sub>r x = h \\<turnstile> f ptr args \\<rightarrow>\\<^sub>r x\"", "lemma invoke_returns_heap [simp]: \n  \"ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow> Pred ptr \n   \\<Longrightarrow> h \\<turnstile> (invoke ((Pred, f) # xs) ptr args) \\<rightarrow>\\<^sub>h h' = h \\<turnstile> f ptr args \\<rightarrow>\\<^sub>h h'\"", "lemma invoke_not [simp]: \"\\<not>Pred ptr \\<Longrightarrow> invoke ((Pred, f) # xs) ptr args = invoke xs ptr args\"", "lemma invoke_empty [simp]: \"\\<not>h \\<turnstile> ok (invoke [] ptr args)\"", "lemma invoke_empty_reads [simp]: \"\\<forall>P \\<in> S. reflp P \\<and> transp P \\<Longrightarrow> reads S (invoke [] ptr args) h h'\"", "lemma get_object_ptr_simp [simp]: \n  \"get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) = (if ptr = object_ptr then Some obj else get object_ptr h)\"", "lemma object_ptr_kinds_simp [simp]: \"object_ptr_kinds (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) = object_ptr_kinds h |\\<union>| {|ptr|}\"", "lemma type_wf_put_I:\n  assumes \"type_wf h\"\n  shows \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"", "lemma type_wf_put_ptr_not_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<notin>| object_ptr_kinds h\"\n  shows \"type_wf h\"", "lemma type_wf_put_ptr_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<in>| object_ptr_kinds h\"\n  shows \"type_wf h\"", "lemma type_wf_preserved: \"type_wf h = type_wf h'\"", "lemma object_ptr_kinds_preserved_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  shows \"object_ptr_kinds h = object_ptr_kinds h'\"", "lemma object_ptr_kinds_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h' w object_ptr. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n          \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  shows \"object_ptr_kinds h = object_ptr_kinds h'\"", "lemma reads_writes_preserved2:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h' x. \\<forall>w \\<in> SW. h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr getter) h h'\"\n  shows \"preserved (get_M ptr getter) h h'\""], "translations": [["", "lemmas object_ptr_kinds_M_defs = a_ptr_kinds_M_def"], ["", "global_interpretation l_dummy defines get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t = \"l_get_M.a_get_M get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma get_M_is_l_get_M: \"l_get_M get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t type_wf object_ptr_kinds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M get type_wf object_ptr_kinds", "by (simp add: a_type_wf_def get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf l_get_M_def)"], ["", "lemmas get_M_defs = get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def[unfolded l_get_M.a_get_M_def[OF get_M_is_l_get_M]]"], ["", "adhoc_overloading get_M get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t"], ["", "locale l_get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_lemmas = l_type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\nbegin"], ["", "interpretation l_get_M get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t type_wf object_ptr_kinds"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M get type_wf object_ptr_kinds", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h ptr.\n       \\<lbrakk>type_wf h; ptr |\\<in>| object_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> get ptr h \\<noteq> None\n 2. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| object_ptr_kinds h", "apply (simp add: get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf local.type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| object_ptr_kinds h", "by (simp add: a_type_wf_def get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf)"], ["", "lemmas get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_ok = get_M_ok[folded get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def]"], ["", "lemmas get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_ptr_in_heap = get_M_ptr_in_heap[folded get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def]"], ["", "end"], ["", "global_interpretation l_get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_lemmas type_wf"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_lemmas type_wf", "by (simp add: l_get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_lemmas_def l_type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_axioms)"], ["", "lemma object_ptr_kinds_M_reads: \n  \"reads (\\<Union>object_ptr. {preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing)}) object_ptr_kinds_M h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reads (\\<Union>object_ptr. {preserved (get_M object_ptr nothing)})\n     object_ptr_kinds_M h h'", "apply(auto simp add: object_ptr_kinds_M_defs get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf type_wf_defs reads_def \n      preserved_def get_M_defs  \n      split: option.splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>y.\n                   (get y h = None \\<longrightarrow> get y h' = None) \\<and>\n                   ((\\<exists>x2. get y h = Some x2) \\<longrightarrow>\n                    (\\<exists>ya. get y h' = Some ya));\n        get x h' = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get x h = Some y\n 2. \\<And>x y.\n       \\<lbrakk>\\<forall>y.\n                   (get y h = None \\<longrightarrow> get y h' = None) \\<and>\n                   ((\\<exists>x2. get y h = Some x2) \\<longrightarrow>\n                    (\\<exists>ya. get y h' = Some ya));\n        get x h' = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get x h = Some y", "using a_type_wf_def get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf"], ["proof (prove)\nusing this:\n  type_wf ?h = True\n  type_wf ?h \\<Longrightarrow>\n  (?object_ptr |\\<in>| object_ptr_kinds ?h) =\n  (get ?object_ptr ?h \\<noteq> None)\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<forall>y.\n                   (get y h = None \\<longrightarrow> get y h' = None) \\<and>\n                   ((\\<exists>x2. get y h = Some x2) \\<longrightarrow>\n                    (\\<exists>ya. get y h' = Some ya));\n        get x h' = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get x h = Some y\n 2. \\<And>x y.\n       \\<lbrakk>\\<forall>y.\n                   (get y h = None \\<longrightarrow> get y h' = None) \\<and>\n                   ((\\<exists>x2. get y h = Some x2) \\<longrightarrow>\n                    (\\<exists>ya. get y h' = Some ya));\n        get x h' = Some y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get x h = Some y", "by blast+"], ["", "global_interpretation l_put_M type_wf object_ptr_kinds get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t \n  rewrites \"a_get_M = get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\" \n  defines put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t = a_put_M"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M type_wf object_ptr_kinds get &&& l_get_M.a_get_M get = get_M", "apply (simp add: get_M_is_l_get_M l_put_M_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M.a_get_M get = get_M", "by (simp add: get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def)"], ["", "lemmas put_M_defs = a_put_M_def"], ["", "adhoc_overloading put_M put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t"], ["", "locale l_put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_lemmas = l_type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\nbegin"], ["", "interpretation l_put_M  type_wf object_ptr_kinds get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M type_wf object_ptr_kinds get", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h ptr.\n       \\<lbrakk>type_wf h; ptr |\\<in>| object_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> get ptr h \\<noteq> None\n 2. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| object_ptr_kinds h", "using get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf l_type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t.type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t local.l_type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_axioms"], ["proof (prove)\nusing this:\n  type_wf ?h \\<Longrightarrow>\n  (?object_ptr |\\<in>| object_ptr_kinds ?h) =\n  (get ?object_ptr ?h \\<noteq> None)\n  \\<lbrakk>l_type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n            ?type_wf;\n   ?type_wf ?h\\<rbrakk>\n  \\<Longrightarrow> type_wf ?h\n  l_type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t type_wf\n\ngoal (2 subgoals):\n 1. \\<And>h ptr.\n       \\<lbrakk>type_wf h; ptr |\\<in>| object_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> get ptr h \\<noteq> None\n 2. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| object_ptr_kinds h", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| object_ptr_kinds h", "by (simp add: a_type_wf_def get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf)"], ["", "lemmas put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_ok = put_M_ok[folded put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def]"], ["", "lemmas put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_ptr_in_heap = put_M_ptr_in_heap[folded put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def]"], ["", "end"], ["", "global_interpretation l_put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_lemmas type_wf"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_lemmas type_wf", "by (simp add: l_put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_lemmas_def l_type_wf\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_axioms)"], ["", "definition check_in_heap :: \"(_) object_ptr \\<Rightarrow> (_, unit) dom_prog\"\n  where\n    \"check_in_heap ptr = do {\n      h \\<leftarrow> get_heap;\n      (if ptr |\\<in>| object_ptr_kinds h then\n        return ()\n      else\n        error SegmentationFault\n      )}\""], ["", "lemma check_in_heap_ptr_in_heap: \"ptr |\\<in>| object_ptr_kinds h \\<longleftrightarrow> h \\<turnstile> ok (check_in_heap ptr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ptr |\\<in>| object_ptr_kinds h) = h \\<turnstile> ok check_in_heap ptr", "by(auto simp add: check_in_heap_def)"], ["", "lemma check_in_heap_pure [simp]: \"pure (check_in_heap ptr) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (check_in_heap ptr) h", "by(auto simp add: check_in_heap_def intro!: bind_pure_I)"], ["", "lemma check_in_heap_is_OK [simp]: \n  \"ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow> h \\<turnstile> ok (check_in_heap ptr \\<bind> f) = h \\<turnstile> ok (f ())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow>\n    h \\<turnstile> ok (check_in_heap ptr \\<bind> f) = h \\<turnstile> ok f ()", "by(simp add: check_in_heap_def)"], ["", "lemma check_in_heap_returns_result [simp]: \n  \"ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow> h \\<turnstile> (check_in_heap ptr \\<bind> f) \\<rightarrow>\\<^sub>r x = h \\<turnstile> f () \\<rightarrow>\\<^sub>r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow>\n    h \\<turnstile> check_in_heap ptr \\<bind> f \\<rightarrow>\\<^sub>r x =\n    h \\<turnstile> f () \\<rightarrow>\\<^sub>r x", "by(simp add: check_in_heap_def)"], ["", "lemma check_in_heap_returns_heap [simp]: \n  \"ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow> h \\<turnstile> (check_in_heap ptr \\<bind> f) \\<rightarrow>\\<^sub>h h' = h \\<turnstile> f () \\<rightarrow>\\<^sub>h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow>\n    h \\<turnstile> check_in_heap ptr \\<bind> f \\<rightarrow>\\<^sub>h h' =\n    h \\<turnstile> f () \\<rightarrow>\\<^sub>h h'", "by(simp add: check_in_heap_def)"], ["", "lemma check_in_heap_reads: \n  \"reads {preserved (get_M object_ptr nothing)} (check_in_heap object_ptr) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reads {preserved (get_M object_ptr nothing)} (check_in_heap object_ptr)\n     h h'", "apply(simp add: check_in_heap_def reads_def preserved_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (object_ptr |\\<in>| object_ptr_kinds h \\<longrightarrow>\n     object_ptr |\\<notin>| object_ptr_kinds h' \\<longrightarrow>\n     h \\<turnstile> get_M object_ptr nothing \\<rightarrow>\\<^sub>r () =\n     (\\<not> h' \\<turnstile> get_M object_ptr nothing\n             \\<rightarrow>\\<^sub>r ())) \\<and>\n    (object_ptr |\\<notin>| object_ptr_kinds h \\<longrightarrow>\n     object_ptr |\\<in>| object_ptr_kinds h' \\<longrightarrow>\n     h \\<turnstile> get_M object_ptr nothing \\<rightarrow>\\<^sub>r () =\n     (\\<not> h' \\<turnstile> get_M object_ptr nothing\n             \\<rightarrow>\\<^sub>r ()))", "by (metis a_type_wf_def get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_ok get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_ptr_in_heap is_OK_returns_result_E \n      is_OK_returns_result_I unit_all_impI)"], ["", "subsection\\<open>Invoke\\<close>"], ["", "fun invoke_rec :: \"(((_) object_ptr \\<Rightarrow> bool) \\<times> ((_) object_ptr \\<Rightarrow> 'args \n                  \\<Rightarrow> (_, 'result) dom_prog)) list \\<Rightarrow> (_) object_ptr \\<Rightarrow> 'args \n                  \\<Rightarrow> (_, 'result) dom_prog\"\n  where\n    \"invoke_rec ((P, f)#xs) ptr args = (if P ptr then f ptr args else invoke_rec xs ptr args)\"\n  | \"invoke_rec [] ptr args = error InvokeError\""], ["", "definition invoke :: \"(((_) object_ptr \\<Rightarrow> bool) \\<times> ((_) object_ptr \\<Rightarrow> 'args \n                     \\<Rightarrow> (_, 'result) dom_prog)) list \n                     \\<Rightarrow> (_) object_ptr \\<Rightarrow> 'args \\<Rightarrow> (_, 'result) dom_prog\"\n  where                               \n    \"invoke xs ptr args = do { check_in_heap ptr; invoke_rec xs ptr args}\""], ["", "lemma invoke_split: \"P (invoke ((Pred, f) # xs) ptr args) =\n    ((\\<not>(Pred ptr) \\<longrightarrow> P (invoke xs ptr args))\n  \\<and> (Pred ptr \\<longrightarrow> P (do {check_in_heap ptr; f ptr args})))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (invoke ((Pred, f) # xs) ptr args) =\n    ((\\<not> Pred ptr \\<longrightarrow> P (invoke xs ptr args)) \\<and>\n     (Pred ptr \\<longrightarrow>\n      P (check_in_heap ptr \\<bind> (\\<lambda>_. f ptr args))))", "by(simp add: invoke_def)"], ["", "lemma invoke_split_asm: \"P (invoke ((Pred, f) # xs) ptr args) =\n    (\\<not>((\\<not>(Pred ptr) \\<and> (\\<not> P (invoke xs ptr args)))\n    \\<or> (Pred ptr \\<and> (\\<not> P (do {check_in_heap ptr; f ptr args})))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (invoke ((Pred, f) # xs) ptr args) =\n    (\\<not> (\\<not> Pred ptr \\<and> \\<not> P (invoke xs ptr args) \\<or>\n             Pred ptr \\<and>\n             \\<not> P (check_in_heap ptr \\<bind> (\\<lambda>_. f ptr args))))", "by(simp add: invoke_def)"], ["", "lemmas invoke_splits = invoke_split invoke_split_asm"], ["", "lemma invoke_ptr_in_heap: \"h \\<turnstile> ok (invoke xs ptr args) \\<Longrightarrow> ptr |\\<in>| object_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> ok invoke xs ptr args \\<Longrightarrow>\n    ptr |\\<in>| object_ptr_kinds h", "by (metis bind_is_OK_E check_in_heap_ptr_in_heap invoke_def is_OK_returns_heap_I)"], ["", "lemma invoke_pure [simp]: \"pure (invoke [] ptr args) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pure (invoke [] ptr args) h", "by(auto simp add: invoke_def intro!: bind_pure_I)"], ["", "lemma invoke_is_OK [simp]: \n  \"ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow> Pred ptr \n    \\<Longrightarrow> h \\<turnstile> ok (invoke ((Pred, f) # xs) ptr args) = h \\<turnstile> ok (f ptr args)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ptr |\\<in>| object_ptr_kinds h; Pred ptr\\<rbrakk>\n    \\<Longrightarrow> h \\<turnstile> ok invoke ((Pred, f) # xs) ptr args =\n                      h \\<turnstile> ok f ptr args", "by(simp add: invoke_def)"], ["", "lemma invoke_returns_result [simp]: \n  \"ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow> Pred ptr \n   \\<Longrightarrow> h \\<turnstile> (invoke ((Pred, f) # xs) ptr args) \\<rightarrow>\\<^sub>r x = h \\<turnstile> f ptr args \\<rightarrow>\\<^sub>r x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ptr |\\<in>| object_ptr_kinds h; Pred ptr\\<rbrakk>\n    \\<Longrightarrow> h \\<turnstile> invoke ((Pred, f) # xs) ptr args\n                      \\<rightarrow>\\<^sub>r x =\n                      h \\<turnstile> f ptr args \\<rightarrow>\\<^sub>r x", "by(simp add: invoke_def)"], ["", "lemma invoke_returns_heap [simp]: \n  \"ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow> Pred ptr \n   \\<Longrightarrow> h \\<turnstile> (invoke ((Pred, f) # xs) ptr args) \\<rightarrow>\\<^sub>h h' = h \\<turnstile> f ptr args \\<rightarrow>\\<^sub>h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ptr |\\<in>| object_ptr_kinds h; Pred ptr\\<rbrakk>\n    \\<Longrightarrow> h \\<turnstile> invoke ((Pred, f) # xs) ptr args\n                      \\<rightarrow>\\<^sub>h h' =\n                      h \\<turnstile> f ptr args \\<rightarrow>\\<^sub>h h'", "by(simp add: invoke_def)"], ["", "lemma invoke_not [simp]: \"\\<not>Pred ptr \\<Longrightarrow> invoke ((Pred, f) # xs) ptr args = invoke xs ptr args\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Pred ptr \\<Longrightarrow>\n    invoke ((Pred, f) # xs) ptr args = invoke xs ptr args", "by(auto simp add: invoke_def)"], ["", "lemma invoke_empty [simp]: \"\\<not>h \\<turnstile> ok (invoke [] ptr args)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> h \\<turnstile> ok invoke [] ptr args", "by(auto simp add: invoke_def check_in_heap_def)"], ["", "lemma invoke_empty_reads [simp]: \"\\<forall>P \\<in> S. reflp P \\<and> transp P \\<Longrightarrow> reads S (invoke [] ptr args) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>P\\<in>S. reflp P \\<and> transp P \\<Longrightarrow>\n    reads S (invoke [] ptr args) h h'", "apply(simp add: invoke_def reads_def preserved_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>P\\<in>S. reflp P \\<and> transp P \\<Longrightarrow>\n    (\\<forall>P\\<in>S. P h h') \\<longrightarrow>\n    (\\<forall>x.\n        h \\<turnstile> check_in_heap ptr \\<bind>\n                       (\\<lambda>_. error InvokeError)\n        \\<rightarrow>\\<^sub>r x =\n        h' \\<turnstile> check_in_heap ptr \\<bind>\n                        (\\<lambda>_. error InvokeError)\n        \\<rightarrow>\\<^sub>r x)", "by (meson bind_returns_result_E error_returns_result)"], ["", "subsection\\<open>Modified Heaps\\<close>"], ["", "lemma get_object_ptr_simp [simp]: \n  \"get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) = (if ptr = object_ptr then Some obj else get object_ptr h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get object_ptr (put ptr obj h) =\n    (if ptr = object_ptr then Some obj else get object_ptr h)", "by(auto simp add: get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def split: option.splits Option.bind_splits)"], ["", "lemma object_ptr_kinds_simp [simp]: \"object_ptr_kinds (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) = object_ptr_kinds h |\\<union>| {|ptr|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds (put ptr obj h) = object_ptr_kinds h |\\<union>| {|ptr|}", "by(auto simp add: object_ptr_kinds_def put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def split: option.splits)"], ["", "lemma type_wf_put_I:\n  assumes \"type_wf h\"\n  shows \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_wf (put ptr obj h)", "using assms"], ["proof (prove)\nusing this:\n  type_wf h\n\ngoal (1 subgoal):\n 1. type_wf (put ptr obj h)", "by(auto simp add: type_wf_defs split: option.splits)"], ["", "lemma type_wf_put_ptr_not_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<notin>| object_ptr_kinds h\"\n  shows \"type_wf h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_wf h", "using assms"], ["proof (prove)\nusing this:\n  type_wf (put ptr obj h)\n  ptr |\\<notin>| object_ptr_kinds h\n\ngoal (1 subgoal):\n 1. type_wf h", "by(auto simp add: type_wf_defs split: option.splits if_splits)"], ["", "lemma type_wf_put_ptr_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<in>| object_ptr_kinds h\"\n  shows \"type_wf h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_wf h", "using assms"], ["proof (prove)\nusing this:\n  type_wf (put ptr obj h)\n  ptr |\\<in>| object_ptr_kinds h\n\ngoal (1 subgoal):\n 1. type_wf h", "by(auto simp add: type_wf_defs split: option.splits if_splits)"], ["", "subsection\\<open>Preserving Types\\<close>"], ["", "lemma type_wf_preserved: \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_wf h = type_wf h'", "by(auto simp add: type_wf_defs)"], ["", "lemma object_ptr_kinds_preserved_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  shows \"object_ptr_kinds h = object_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "using assms"], ["proof (prove)\nusing this:\n  preserved (get_M ?object_ptr nothing) h h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "apply(auto simp add: object_ptr_kinds_def preserved_def get_M_defs get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def \n      split: option.splits)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>object_ptr.\n                   h \\<turnstile> (case fmlookup (the_heap h) object_ptr of\n                                   None \\<Rightarrow>\n                                     error SegmentationFault\n                                   | Some res \\<Rightarrow>\n return (nothing res))\n                   \\<rightarrow>\\<^sub>r () =\n                   h' \\<turnstile> (case fmlookup (the_heap h')\n    object_ptr of\n                                    None \\<Rightarrow>\nerror SegmentationFault\n                                    | Some res \\<Rightarrow>\n  return (nothing res))\n                   \\<rightarrow>\\<^sub>r ();\n        x |\\<in>| fmdom (the_heap h)\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| fmdom (the_heap h')\n 2. \\<And>x.\n       \\<lbrakk>\\<And>object_ptr.\n                   h \\<turnstile> (case fmlookup (the_heap h) object_ptr of\n                                   None \\<Rightarrow>\n                                     error SegmentationFault\n                                   | Some res \\<Rightarrow>\n return (nothing res))\n                   \\<rightarrow>\\<^sub>r () =\n                   h' \\<turnstile> (case fmlookup (the_heap h')\n    object_ptr of\n                                    None \\<Rightarrow>\nerror SegmentationFault\n                                    | Some res \\<Rightarrow>\n  return (nothing res))\n                   \\<rightarrow>\\<^sub>r ();\n        x |\\<in>| fmdom (the_heap h')\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| fmdom (the_heap h)", "apply (metis (mono_tags, lifting) domIff error_returns_result fmdom.rep_eq fmember.rep_eq \n      old.unit.exhaust option.case_eq_if return_returns_result)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>object_ptr.\n                   h \\<turnstile> (case fmlookup (the_heap h) object_ptr of\n                                   None \\<Rightarrow>\n                                     error SegmentationFault\n                                   | Some res \\<Rightarrow>\n return (nothing res))\n                   \\<rightarrow>\\<^sub>r () =\n                   h' \\<turnstile> (case fmlookup (the_heap h')\n    object_ptr of\n                                    None \\<Rightarrow>\nerror SegmentationFault\n                                    | Some res \\<Rightarrow>\n  return (nothing res))\n                   \\<rightarrow>\\<^sub>r ();\n        x |\\<in>| fmdom (the_heap h')\\<rbrakk>\n       \\<Longrightarrow> x |\\<in>| fmdom (the_heap h)", "by (metis (mono_tags, lifting) domIff error_returns_result fmdom.rep_eq fmember.rep_eq \n      old.unit.exhaust option.case_eq_if return_returns_result)"], ["", "lemma object_ptr_kinds_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h' w object_ptr. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n          \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  shows \"object_ptr_kinds h = object_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "fix object_ptr w"], ["proof (state)\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "have \"preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preserved (get_M object_ptr nothing) h h'", "apply(rule writes_small_big[OF assms])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> ?w1 h h' w \\<in> SW\n 2. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> h \\<turnstile> ?w1 h h' w \\<rightarrow>\\<^sub>h h'\n 3. reflp (preserved (get_M object_ptr nothing))\n 4. transp (preserved (get_M object_ptr nothing))", "by auto"], ["proof (state)\nthis:\n  preserved (get_M object_ptr nothing) h h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "}"], ["proof (state)\nthis:\n  preserved (get_M ?object_ptr2 nothing) h h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "then"], ["proof (chain)\npicking this:\n  preserved (get_M ?object_ptr2 nothing) h h'", "show ?thesis"], ["proof (prove)\nusing this:\n  preserved (get_M ?object_ptr2 nothing) h h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "using object_ptr_kinds_preserved_small"], ["proof (prove)\nusing this:\n  preserved (get_M ?object_ptr2 nothing) h h'\n  (\\<And>object_ptr.\n      preserved (get_M object_ptr nothing) ?h ?h') \\<Longrightarrow>\n  object_ptr_kinds ?h = object_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "by blast"], ["proof (state)\nthis:\n  object_ptr_kinds h = object_ptr_kinds h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reads_writes_preserved2:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h' x. \\<forall>w \\<in> SW. h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr getter) h h'\"\n  shows \"preserved (get_M ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preserved (get_M ptr getter) h h'", "apply(clarsimp simp add: preserved_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       h \\<turnstile> get_M ptr getter \\<rightarrow>\\<^sub>r x =\n       h' \\<turnstile> get_M ptr getter \\<rightarrow>\\<^sub>r x", "using reads_singleton assms(1) assms(2)"], ["proof (prove)\nusing this:\n  reads {preserved ?f} ?f ?h ?h'\n  writes SW setter h h'\n  h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       h \\<turnstile> get_M ptr getter \\<rightarrow>\\<^sub>r x =\n       h' \\<turnstile> get_M ptr getter \\<rightarrow>\\<^sub>r x", "apply(rule reads_writes_preserved)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x h h'.\n       \\<forall>w\\<in>SW.\n          h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n          (\\<forall>r\\<in>{preserved (get_M ptr getter)}. r h h')", "using assms(3)"], ["proof (prove)\nusing this:\n  \\<forall>w\\<in>SW.\n     ?h \\<turnstile> w \\<rightarrow>\\<^sub>h ?h' \\<longrightarrow>\n     preserved (get_M ptr getter) ?h ?h'\n\ngoal (1 subgoal):\n 1. \\<And>x h h'.\n       \\<forall>w\\<in>SW.\n          h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<longrightarrow>\n          (\\<forall>r\\<in>{preserved (get_M ptr getter)}. r h h')", "by(auto simp add: preserved_def)"], ["", "end"]]}