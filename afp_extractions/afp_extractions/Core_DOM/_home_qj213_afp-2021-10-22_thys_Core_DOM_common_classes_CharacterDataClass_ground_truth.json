{"file_name": "/home/qj213/afp-2021-10-22/thys/Core_DOM/common/classes/CharacterDataClass.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Core_DOM", "problem_names": ["lemma character_data_ptr_kinds_simp [simp]:\n  \"character_data_ptr_kinds (Heap (fmupd (cast character_data_ptr) character_data (the_heap h))) \n              = {|character_data_ptr|} |\\<union>| character_data_ptr_kinds h\"", "lemmas is_character_data_kind_def = is_character_data_kind\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def", "lemma character_data_ptr_kinds_commutes [simp]:\n  \"cast character_data_ptr |\\<in>| node_ptr_kinds h \n       \\<longleftrightarrow> character_data_ptr |\\<in>| character_data_ptr_kinds h\"", "lemmas type_wf_defs = a_type_wf_def", "lemma get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_type_wf:\n  assumes \"type_wf h\"\n  shows \"character_data_ptr |\\<in>| character_data_ptr_kinds h \n          \\<longleftrightarrow> get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr h \\<noteq> None\"", "lemma put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_ptr_in_heap:\n  assumes \"put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr character_data h = h'\"\n  shows \"character_data_ptr |\\<in>| character_data_ptr_kinds h'\"", "lemma put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_put_ptrs:\n  assumes \"put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr character_data h = h'\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast character_data_ptr|}\"", "lemma cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_inject [simp]: \"cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e x = cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e y \\<longleftrightarrow> x = y\"", "lemma cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_none [simp]:\n  \"cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a node = None \\<longleftrightarrow> \\<not> (\\<exists>character_data. cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e character_data = node)\"", "lemma cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_some [simp]: \n  \"cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a node = Some character_data \\<longleftrightarrow> cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e character_data = node\"", "lemma cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_inv [simp]: \n  \"cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a (cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e character_data) = Some character_data\"", "lemma cast_element_not_character_data [simp]:\n  \"(cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e element \\<noteq> cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e character_data)\"\n  \"(cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e character_data \\<noteq> cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e element)\"", "lemma get_CharacterData_simp1 [simp]: \n  \"get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr (put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr character_data h) \n       = Some character_data\"", "lemma get_CharacterData_simp2 [simp]: \n  \"character_data_ptr \\<noteq> character_data_ptr' \\<Longrightarrow> get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr \n         (put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr' character_data h) = get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr h\"", "lemma get_CharacterData_simp3 [simp]: \n  \"get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr (put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr f h) = get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr h\"", "lemma get_CharacterData_simp4 [simp]: \n  \"get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a element_ptr (put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t character_data_ptr f h) = get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a element_ptr h\"", "lemma new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a [simp]:\n  assumes \"new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h = (new_element_ptr, h')\"\n  shows \"get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr h = get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr h'\"", "lemma new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_ptr_in_heap:\n  assumes \"new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a h = (new_character_data_ptr, h')\"\n  shows \"new_character_data_ptr |\\<in>| character_data_ptr_kinds h'\"", "lemma new_character_data_ptr_new: \n  \"character_data_ptr.Ref (Suc (fMax (finsert 0 (character_data_ptr.the_ref |`| character_data_ptrs h)))) \n              |\\<notin>| character_data_ptrs h\"", "lemma new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_ptr_not_in_heap:\n  assumes \"new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a h = (new_character_data_ptr, h')\"\n  shows \"new_character_data_ptr |\\<notin>| character_data_ptr_kinds h\"", "lemma new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_new_ptr:\n  assumes \"new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a h = (new_character_data_ptr, h')\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast new_character_data_ptr|}\"", "lemma new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_is_character_data_ptr:\n  assumes \"new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a h = (new_character_data_ptr, h')\"\n  shows \"is_character_data_ptr new_character_data_ptr\"", "lemma new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t [simp]:\n  assumes \"new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a h = (new_character_data_ptr, h')\"\n  assumes \"ptr \\<noteq> cast new_character_data_ptr\"\n  shows \"get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr h = get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr h'\"", "lemma new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e [simp]:\n  assumes \"new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a h = (new_character_data_ptr, h')\"\n  assumes \"ptr \\<noteq> cast new_character_data_ptr\"\n  shows \"get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr h = get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr h'\"", "lemma new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t [simp]:\n  assumes \"new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a h = (new_character_data_ptr, h')\"\n  shows \"get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr h = get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr h'\"", "lemma new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a [simp]:\n  assumes \"new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a h = (new_character_data_ptr, h')\"\n  assumes \"ptr \\<noteq> new_character_data_ptr\"\n  shows \"get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr h = get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr h'\"", "lemma known_ptr_not_character_data_ptr: \n  \"\\<not>is_character_data_ptr ptr \\<Longrightarrow> a_known_ptr ptr \\<Longrightarrow> known_ptr ptr\"", "lemmas known_ptr_defs = a_known_ptr_def", "lemma known_ptrs_known_ptr: \"a_known_ptrs h \\<Longrightarrow> ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow> known_ptr ptr\"", "lemma known_ptrs_preserved: \n  \"object_ptr_kinds h = object_ptr_kinds h' \\<Longrightarrow> a_known_ptrs h = a_known_ptrs h'\"", "lemma known_ptrs_subset: \n  \"object_ptr_kinds h' |\\<subseteq>| object_ptr_kinds h \\<Longrightarrow> a_known_ptrs h \\<Longrightarrow> a_known_ptrs h'\"", "lemma known_ptrs_new_ptr:\n  \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|new_ptr|} \\<Longrightarrow> known_ptr new_ptr \\<Longrightarrow>\na_known_ptrs h \\<Longrightarrow> a_known_ptrs h'\"", "lemmas known_ptrs_defs = a_known_ptrs_def", "lemma known_ptrs_is_l_known_ptrs: \"l_known_ptrs known_ptr known_ptrs\""], "translations": [["", "lemma character_data_ptr_kinds_simp [simp]:\n  \"character_data_ptr_kinds (Heap (fmupd (cast character_data_ptr) character_data (the_heap h))) \n              = {|character_data_ptr|} |\\<union>| character_data_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. character_data_ptr_kinds\n     (Heap\n       (fmupd (cast (cast character_data_ptr)) character_data\n         (the_heap h))) =\n    {|character_data_ptr|} |\\<union>| character_data_ptr_kinds h", "apply(auto simp add: character_data_ptr_kinds_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. character_data_ptr |\\<in>|\n    (the \\<circ> cast) |`|\n    ffilter is_character_data_ptr_kind\n     (finsert (cast character_data_ptr) (node_ptr_kinds h))", "by force"], ["", "definition character_data_ptrs :: \"(_) heap \\<Rightarrow> _ character_data_ptr fset\"\n  where\n    \"character_data_ptrs heap = ffilter is_character_data_ptr (character_data_ptr_kinds heap)\""], ["", "abbreviation \"character_data_ptr_exts heap \\<equiv> character_data_ptr_kinds heap - character_data_ptrs heap\""], ["", "definition cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a :: \"(_) Node \\<Rightarrow> (_) CharacterData option\"\n  where\n    \"cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a node = (case RNode.more node of\n          Inr (Inl character_data) \\<Rightarrow> Some (RNode.extend (RNode.truncate node) character_data)\n        | _ \\<Rightarrow> None)\""], ["", "adhoc_overloading cast cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a"], ["", "abbreviation cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a :: \"(_) Object \\<Rightarrow> (_) CharacterData  option\"\n  where\n    \"cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a obj \\<equiv> (case cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e obj of Some node \\<Rightarrow> cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a node \n                                                       | None \\<Rightarrow> None)\""], ["", "adhoc_overloading cast cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a"], ["", "definition cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e :: \"(_) CharacterData \\<Rightarrow> (_) Node\"\n  where\n    \"cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e character_data = RNode.extend (RNode.truncate character_data)\n                                                      (Inr (Inl (RNode.more character_data)))\""], ["", "adhoc_overloading cast cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e"], ["", "abbreviation cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t :: \"(_) CharacterData \\<Rightarrow> (_) Object\"\n  where\n    \"cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr \\<equiv> cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr)\""], ["", "adhoc_overloading cast cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t"], ["", "consts is_character_data_kind :: 'a"], ["", "definition is_character_data_kind\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e :: \"(_) Node \\<Rightarrow> bool\"\n  where\n    \"is_character_data_kind\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr \\<longleftrightarrow> cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr \\<noteq> None\""], ["", "adhoc_overloading is_character_data_kind is_character_data_kind\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e"], ["", "lemmas is_character_data_kind_def = is_character_data_kind\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def"], ["", "abbreviation is_character_data_kind\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t :: \"(_) Object \\<Rightarrow> bool\"\n  where\n    \"is_character_data_kind\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr \\<equiv> cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr \\<noteq> None\""], ["", "adhoc_overloading is_character_data_kind is_character_data_kind\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t"], ["", "lemma character_data_ptr_kinds_commutes [simp]:\n  \"cast character_data_ptr |\\<in>| node_ptr_kinds h \n       \\<longleftrightarrow> character_data_ptr |\\<in>| character_data_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cast character_data_ptr |\\<in>| node_ptr_kinds h) =\n    (character_data_ptr |\\<in>| character_data_ptr_kinds h)", "apply(auto simp add: character_data_ptr_kinds_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. cast character_data_ptr |\\<in>| node_ptr_kinds h \\<Longrightarrow>\n    character_data_ptr |\\<in>|\n    (the \\<circ> cast) |`|\n    ffilter is_character_data_ptr_kind (node_ptr_kinds h)", "by (metis character_data_ptr_casts_commute2 comp_eq_dest_lhs ffmember_filter fimage_eqI \n      is_character_data_ptr_kind_none\n      option.distinct(1) option.sel)"], ["", "definition get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a :: \"(_) character_data_ptr \\<Rightarrow> (_) heap \\<Rightarrow> (_) CharacterData option\"\n  where                             \n    \"get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr h = Option.bind (get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e (cast character_data_ptr) h) cast\""], ["", "adhoc_overloading get get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a"], ["", "locale l_type_wf_def\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\nbegin"], ["", "definition a_type_wf :: \"(_) heap \\<Rightarrow> bool\"\n  where\n    \"a_type_wf h = (ElementClass.type_wf h\n                 \\<and> (\\<forall>character_data_ptr \\<in> fset (character_data_ptr_kinds h).\n                     get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr h \\<noteq> None))\""], ["", "end"], ["", "global_interpretation l_type_wf_def\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a defines type_wf = a_type_wf"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas type_wf_defs = a_type_wf_def"], ["", "locale l_type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a = l_type_wf type_wf for type_wf :: \"((_) heap \\<Rightarrow> bool)\" +\n  assumes type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a: \"type_wf h \\<Longrightarrow> CharacterDataClass.type_wf h\""], ["", "sublocale l_type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a \\<subseteq> l_type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\n     type_wf", "apply(unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h. type_wf h \\<Longrightarrow> ElementClass.type_wf h", "using ElementClass.a_type_wf_def"], ["proof (prove)\nusing this:\n  ElementClass.type_wf ?h =\n  (NodeClass.type_wf ?h \\<and>\n   (\\<forall>element_ptr\\<in>fset (element_ptr_kinds ?h).\n       get element_ptr ?h \\<noteq> None))\n\ngoal (1 subgoal):\n 1. \\<And>h. type_wf h \\<Longrightarrow> ElementClass.type_wf h", "by (meson CharacterDataClass.a_type_wf_def l_type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_axioms l_type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def)"], ["", "locale l_get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_lemmas = l_type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\nbegin"], ["", "sublocale l_get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_lemmas"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_lemmas\n     type_wf", "by unfold_locales"], ["", "lemma get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_type_wf:\n  assumes \"type_wf h\"\n  shows \"character_data_ptr |\\<in>| character_data_ptr_kinds h \n          \\<longleftrightarrow> get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr h \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (character_data_ptr |\\<in>| character_data_ptr_kinds h) =\n    (get character_data_ptr h \\<noteq> None)", "using l_type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_axioms assms"], ["proof (prove)\nusing this:\n  l_type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\n   type_wf\n  type_wf h\n\ngoal (1 subgoal):\n 1. (character_data_ptr |\\<in>| character_data_ptr_kinds h) =\n    (get character_data_ptr h \\<noteq> None)", "apply(simp add: type_wf_defs get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def l_type_wf\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>h.\n                type_wf h \\<longrightarrow>\n                ElementClass.type_wf h \\<and>\n                (\\<forall>character_data_ptr\n                          \\<in>fset (character_data_ptr_kinds h).\n                    \\<exists>y.\n                       Option.bind (get (cast character_data_ptr) h) cast =\n                       Some y);\n     type_wf h\\<rbrakk>\n    \\<Longrightarrow> (character_data_ptr |\\<in>|\n                       character_data_ptr_kinds h) =\n                      (\\<exists>y.\n                          Option.bind (get (cast character_data_ptr) h)\n                           cast =\n                          Some y)", "by (metis assms bind.bind_lzero character_data_ptr_kinds_commutes fmember.rep_eq\n      local.get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_type_wf option.exhaust option.simps(3))"], ["", "end"], ["", "global_interpretation l_get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_lemmas type_wf"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_lemmas\n     CharacterDataClass.type_wf", "by unfold_locales"], ["", "definition put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a :: \"(_) character_data_ptr \\<Rightarrow> (_) CharacterData \\<Rightarrow> (_) heap \\<Rightarrow> (_) heap\"\n  where\n    \"put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr character_data = put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e (cast character_data_ptr) \n                   (cast character_data)\""], ["", "adhoc_overloading put put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a"], ["", "lemma put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_ptr_in_heap:\n  assumes \"put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr character_data h = h'\"\n  shows \"character_data_ptr |\\<in>| character_data_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. character_data_ptr |\\<in>| character_data_ptr_kinds h'", "using assms put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_ptr_in_heap"], ["proof (prove)\nusing this:\n  put character_data_ptr character_data h = h'\n  put ?node_ptr ?node ?h = ?h' \\<Longrightarrow>\n  ?node_ptr |\\<in>| node_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. character_data_ptr |\\<in>| character_data_ptr_kinds h'", "unfolding put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def character_data_ptr_kinds_def"], ["proof (prove)\nusing this:\n  put (cast character_data_ptr) (cast character_data) h = h'\n  put ?node_ptr ?node ?h = ?h' \\<Longrightarrow>\n  ?node_ptr |\\<in>| node_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. character_data_ptr |\\<in>|\n    the |`| cast |`| ffilter is_character_data_ptr_kind (node_ptr_kinds h')", "by (metis character_data_ptr_kinds_commutes character_data_ptr_kinds_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_ptr_in_heap)"], ["", "lemma put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_put_ptrs:\n  assumes \"put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr character_data h = h'\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast character_data_ptr|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast (cast character_data_ptr)|}", "using assms"], ["proof (prove)\nusing this:\n  put character_data_ptr character_data h = h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast (cast character_data_ptr)|}", "by (simp add: put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_put_ptrs)"], ["", "lemma cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_inject [simp]: \"cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e x = cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cast x = cast y) = (x = y)", "apply(simp add: cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def RObject.extend_def RNode.extend_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RNode.more x = RNode.more y) = (x = y)", "by (metis (full_types) RNode.surjective old.unit.exhaust)"], ["", "lemma cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_none [simp]:\n  \"cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a node = None \\<longleftrightarrow> \\<not> (\\<exists>character_data. cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e character_data = node)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cast node = None) =\n    (\\<nexists>character_data. cast character_data = node)", "apply(auto simp add: cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def RObject.extend_def RNode.extend_def \n      split: sum.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1.\n       RNode.more node = Inr (Inl x1) \\<Longrightarrow>\n       \\<exists>character_data.\n          \\<lparr>RObject.nothing = (), RNode.nothing = (),\n             \\<dots> = Inr (Inl (RNode.more character_data))\\<rparr> =\n          node", "by (metis (full_types) RNode.select_convs(2) RNode.surjective old.unit.exhaust)"], ["", "lemma cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_some [simp]: \n  \"cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a node = Some character_data \\<longleftrightarrow> cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e character_data = node\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cast node = Some character_data) = (cast character_data = node)", "by(auto simp add: cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def RObject.extend_def RNode.extend_def \n      split: sum.splits)"], ["", "lemma cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_inv [simp]: \n  \"cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a (cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e character_data) = Some character_data\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cast (cast character_data) = Some character_data", "by simp"], ["", "lemma cast_element_not_character_data [simp]:\n  \"(cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e element \\<noteq> cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e character_data)\"\n  \"(cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e character_data \\<noteq> cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e element)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cast element \\<noteq> cast character_data &&&\n    cast character_data \\<noteq> cast element", "by(auto simp add: cast\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def RNode.extend_def)"], ["", "lemma get_CharacterData_simp1 [simp]: \n  \"get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr (put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr character_data h) \n       = Some character_data\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get character_data_ptr (put character_data_ptr character_data h) =\n    Some character_data", "by(auto simp add: get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def)"], ["", "lemma get_CharacterData_simp2 [simp]: \n  \"character_data_ptr \\<noteq> character_data_ptr' \\<Longrightarrow> get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr \n         (put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr' character_data h) = get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. character_data_ptr \\<noteq> character_data_ptr' \\<Longrightarrow>\n    get character_data_ptr (put character_data_ptr' character_data h) =\n    get character_data_ptr h", "by(auto simp add: get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def)"], ["", "lemma get_CharacterData_simp3 [simp]: \n  \"get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr (put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a character_data_ptr f h) = get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get element_ptr (put character_data_ptr f h) = get element_ptr h", "by(auto simp add: get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def)"], ["", "lemma get_CharacterData_simp4 [simp]: \n  \"get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a element_ptr (put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t character_data_ptr f h) = get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a element_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get element_ptr (put character_data_ptr f h) = get element_ptr h", "by(auto simp add: get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def)"], ["", "lemma new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a [simp]:\n  assumes \"new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h = (new_element_ptr, h')\"\n  shows \"get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr h = get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h =\n  (new_element_ptr, h')\n\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "by(auto simp add: new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def Let_def)"], ["", "abbreviation \"create_character_data_obj val_arg\n  \\<equiv> \\<lparr> RObject.nothing = (), RNode.nothing = (), RCharacterData.nothing = (), val = val_arg, \\<dots> = None \\<rparr>\""], ["", "definition new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a :: \"(_) heap \\<Rightarrow> ((_) character_data_ptr \\<times> (_) heap)\"\n  where\n    \"new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a h =\n      (let new_character_data_ptr = character_data_ptr.Ref (Suc (fMax (character_data_ptr.the_ref \n            |`| (character_data_ptrs h)))) in\n        (new_character_data_ptr, put new_character_data_ptr (create_character_data_obj '''') h))\""], ["", "lemma new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_ptr_in_heap:\n  assumes \"new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a h = (new_character_data_ptr, h')\"\n  shows \"new_character_data_ptr |\\<in>| character_data_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_character_data_ptr |\\<in>| character_data_ptr_kinds h'", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\n   h =\n  (new_character_data_ptr, h')\n\ngoal (1 subgoal):\n 1. new_character_data_ptr |\\<in>| character_data_ptr_kinds h'", "unfolding new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def Let_def"], ["proof (prove)\nusing this:\n  (character_data_ptr.Ref\n    (Suc (fMax (character_data_ptr.the_ref |`| character_data_ptrs h))),\n   put (character_data_ptr.Ref\n         (Suc (fMax\n                (character_data_ptr.the_ref |`| character_data_ptrs h))))\n    (create_character_data_obj []) h) =\n  (new_character_data_ptr, h')\n\ngoal (1 subgoal):\n 1. new_character_data_ptr |\\<in>| character_data_ptr_kinds h'", "using put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_ptr_in_heap"], ["proof (prove)\nusing this:\n  (character_data_ptr.Ref\n    (Suc (fMax (character_data_ptr.the_ref |`| character_data_ptrs h))),\n   put (character_data_ptr.Ref\n         (Suc (fMax\n                (character_data_ptr.the_ref |`| character_data_ptrs h))))\n    (create_character_data_obj []) h) =\n  (new_character_data_ptr, h')\n  put ?character_data_ptr ?character_data ?h = ?h' \\<Longrightarrow>\n  ?character_data_ptr |\\<in>| character_data_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. new_character_data_ptr |\\<in>| character_data_ptr_kinds h'", "by blast"], ["", "lemma new_character_data_ptr_new: \n  \"character_data_ptr.Ref (Suc (fMax (finsert 0 (character_data_ptr.the_ref |`| character_data_ptrs h)))) \n              |\\<notin>| character_data_ptrs h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. character_data_ptr.Ref\n     (Suc (fMax\n            (finsert 0\n              (character_data_ptr.the_ref |`|\n               character_data_ptrs h)))) |\\<notin>|\n    character_data_ptrs h", "by (metis Suc_n_not_le_n character_data_ptr.sel(1) fMax_ge fimage_finsert finsertI1\n      finsertI2 set_finsert)"], ["", "lemma new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_ptr_not_in_heap:\n  assumes \"new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a h = (new_character_data_ptr, h')\"\n  shows \"new_character_data_ptr |\\<notin>| character_data_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_character_data_ptr |\\<notin>| character_data_ptr_kinds h", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\n   h =\n  (new_character_data_ptr, h')\n\ngoal (1 subgoal):\n 1. new_character_data_ptr |\\<notin>| character_data_ptr_kinds h", "unfolding new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def"], ["proof (prove)\nusing this:\n  (let new_character_data_ptr =\n         character_data_ptr.Ref\n          (Suc (fMax\n                 (character_data_ptr.the_ref |`| character_data_ptrs h)))\n   in (new_character_data_ptr,\n       put new_character_data_ptr (create_character_data_obj []) h)) =\n  (new_character_data_ptr, h')\n\ngoal (1 subgoal):\n 1. new_character_data_ptr |\\<notin>| character_data_ptr_kinds h", "by (metis Pair_inject character_data_ptrs_def fMax_finsert fempty_iff ffmember_filter\n      fimage_is_fempty is_character_data_ptr_ref max_0L new_character_data_ptr_new)"], ["", "lemma new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_new_ptr:\n  assumes \"new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a h = (new_character_data_ptr, h')\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast new_character_data_ptr|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast (cast new_character_data_ptr)|}", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\n   h =\n  (new_character_data_ptr, h')\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast (cast new_character_data_ptr)|}", "by (metis Pair_inject new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_put_ptrs)"], ["", "lemma new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_is_character_data_ptr:\n  assumes \"new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a h = (new_character_data_ptr, h')\"\n  shows \"is_character_data_ptr new_character_data_ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_character_data_ptr new_character_data_ptr", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\n   h =\n  (new_character_data_ptr, h')\n\ngoal (1 subgoal):\n 1. is_character_data_ptr new_character_data_ptr", "by(auto simp add: new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def Let_def)"], ["", "lemma new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t [simp]:\n  assumes \"new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a h = (new_character_data_ptr, h')\"\n  assumes \"ptr \\<noteq> cast new_character_data_ptr\"\n  shows \"get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr h = get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\n   h =\n  (new_character_data_ptr, h')\n  ptr \\<noteq> cast (cast new_character_data_ptr)\n\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "by(auto simp add: new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def Let_def put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def)"], ["", "lemma new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e [simp]:\n  assumes \"new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a h = (new_character_data_ptr, h')\"\n  assumes \"ptr \\<noteq> cast new_character_data_ptr\"\n  shows \"get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr h = get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\n   h =\n  (new_character_data_ptr, h')\n  ptr \\<noteq> cast new_character_data_ptr\n\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "by(auto simp add: new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def Let_def put\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def)"], ["", "lemma new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t [simp]:\n  assumes \"new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a h = (new_character_data_ptr, h')\"\n  shows \"get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr h = get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\n   h =\n  (new_character_data_ptr, h')\n\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "by(auto simp add: new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def Let_def)"], ["", "lemma new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a [simp]:\n  assumes \"new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a h = (new_character_data_ptr, h')\"\n  assumes \"ptr \\<noteq> new_character_data_ptr\"\n  shows \"get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr h = get\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a ptr h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\n   h =\n  (new_character_data_ptr, h')\n  ptr \\<noteq> new_character_data_ptr\n\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "by(auto simp add: new\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a_def Let_def)"], ["", "locale l_known_ptr\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a\nbegin"], ["", "definition a_known_ptr :: \"(_) object_ptr \\<Rightarrow> bool\"\n  where\n    \"a_known_ptr ptr = (known_ptr ptr \\<or> is_character_data_ptr ptr)\""], ["", "lemma known_ptr_not_character_data_ptr: \n  \"\\<not>is_character_data_ptr ptr \\<Longrightarrow> a_known_ptr ptr \\<Longrightarrow> known_ptr ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (case cast ptr of None \\<Rightarrow> False\n                     | Some x \\<Rightarrow> is_character_data_ptr x);\n     local.a_known_ptr ptr\\<rbrakk>\n    \\<Longrightarrow> ElementClass.known_ptr ptr", "by(simp add: a_known_ptr_def)"], ["", "end"], ["", "global_interpretation l_known_ptr\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a defines known_ptr = a_known_ptr"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas known_ptr_defs = a_known_ptr_def"], ["", "locale l_known_ptrs\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a = l_known_ptr known_ptr for known_ptr :: \"(_) object_ptr \\<Rightarrow> bool\"\nbegin"], ["", "definition a_known_ptrs :: \"(_) heap \\<Rightarrow> bool\"\n  where\n    \"a_known_ptrs h = (\\<forall>ptr \\<in> fset (object_ptr_kinds h). known_ptr ptr)\""], ["", "lemma known_ptrs_known_ptr: \"a_known_ptrs h \\<Longrightarrow> ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow> known_ptr ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.a_known_ptrs h; ptr |\\<in>| object_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> known_ptr ptr", "apply(simp add: a_known_ptrs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ptr\\<in>fset (object_ptr_kinds h). known_ptr ptr;\n     ptr |\\<in>| object_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> known_ptr ptr", "using notin_fset"], ["proof (prove)\nusing this:\n  (?x |\\<notin>| ?S) = (?x \\<notin> fset ?S)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>ptr\\<in>fset (object_ptr_kinds h). known_ptr ptr;\n     ptr |\\<in>| object_ptr_kinds h\\<rbrakk>\n    \\<Longrightarrow> known_ptr ptr", "by fastforce"], ["", "lemma known_ptrs_preserved: \n  \"object_ptr_kinds h = object_ptr_kinds h' \\<Longrightarrow> a_known_ptrs h = a_known_ptrs h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h' \\<Longrightarrow>\n    local.a_known_ptrs h = local.a_known_ptrs h'", "by(auto simp add: a_known_ptrs_def)"], ["", "lemma known_ptrs_subset: \n  \"object_ptr_kinds h' |\\<subseteq>| object_ptr_kinds h \\<Longrightarrow> a_known_ptrs h \\<Longrightarrow> a_known_ptrs h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>object_ptr_kinds h' |\\<subseteq>| object_ptr_kinds h;\n     local.a_known_ptrs h\\<rbrakk>\n    \\<Longrightarrow> local.a_known_ptrs h'", "by(simp add: a_known_ptrs_def less_eq_fset.rep_eq subsetD)"], ["", "lemma known_ptrs_new_ptr:\n  \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|new_ptr|} \\<Longrightarrow> known_ptr new_ptr \\<Longrightarrow>\na_known_ptrs h \\<Longrightarrow> a_known_ptrs h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>object_ptr_kinds h' =\n             object_ptr_kinds h |\\<union>| {|new_ptr|};\n     known_ptr new_ptr; local.a_known_ptrs h\\<rbrakk>\n    \\<Longrightarrow> local.a_known_ptrs h'", "by(simp add: a_known_ptrs_def)"], ["", "end"], ["", "global_interpretation l_known_ptrs\\<^sub>C\\<^sub>h\\<^sub>a\\<^sub>r\\<^sub>a\\<^sub>c\\<^sub>t\\<^sub>e\\<^sub>r\\<^sub>D\\<^sub>a\\<^sub>t\\<^sub>a known_ptr defines known_ptrs = a_known_ptrs"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas known_ptrs_defs = a_known_ptrs_def"], ["", "lemma known_ptrs_is_l_known_ptrs: \"l_known_ptrs known_ptr known_ptrs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_known_ptrs CharacterDataClass.known_ptr CharacterDataClass.known_ptrs", "using known_ptrs_known_ptr known_ptrs_preserved known_ptrs_subset known_ptrs_new_ptr l_known_ptrs_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>CharacterDataClass.known_ptrs ?h;\n   ?ptr |\\<in>| object_ptr_kinds ?h\\<rbrakk>\n  \\<Longrightarrow> CharacterDataClass.known_ptr ?ptr\n  object_ptr_kinds ?h = object_ptr_kinds ?h' \\<Longrightarrow>\n  CharacterDataClass.known_ptrs ?h = CharacterDataClass.known_ptrs ?h'\n  \\<lbrakk>object_ptr_kinds ?h' |\\<subseteq>| object_ptr_kinds ?h;\n   CharacterDataClass.known_ptrs ?h\\<rbrakk>\n  \\<Longrightarrow> CharacterDataClass.known_ptrs ?h'\n  \\<lbrakk>object_ptr_kinds ?h' =\n           object_ptr_kinds ?h |\\<union>| {|?new_ptr|};\n   CharacterDataClass.known_ptr ?new_ptr;\n   CharacterDataClass.known_ptrs ?h\\<rbrakk>\n  \\<Longrightarrow> CharacterDataClass.known_ptrs ?h'\n  l_known_ptrs ?known_ptr ?known_ptrs \\<equiv>\n  ((\\<forall>h ptr.\n       ?known_ptrs h \\<longrightarrow>\n       ptr |\\<in>| object_ptr_kinds h \\<longrightarrow>\n       ?known_ptr ptr) \\<and>\n   (\\<forall>h h'.\n       object_ptr_kinds h = object_ptr_kinds h' \\<longrightarrow>\n       ?known_ptrs h = ?known_ptrs h')) \\<and>\n  (\\<forall>h' h.\n      object_ptr_kinds h' |\\<subseteq>| object_ptr_kinds h \\<longrightarrow>\n      ?known_ptrs h \\<longrightarrow> ?known_ptrs h') \\<and>\n  (\\<forall>h' h new_ptr.\n      object_ptr_kinds h' =\n      object_ptr_kinds h |\\<union>| {|new_ptr|} \\<longrightarrow>\n      ?known_ptr new_ptr \\<longrightarrow>\n      ?known_ptrs h \\<longrightarrow> ?known_ptrs h')\n\ngoal (1 subgoal):\n 1. l_known_ptrs CharacterDataClass.known_ptr CharacterDataClass.known_ptrs", "by blast"], ["", "end"]]}