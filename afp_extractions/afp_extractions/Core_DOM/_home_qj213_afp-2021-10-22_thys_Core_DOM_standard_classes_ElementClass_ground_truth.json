{"file_name": "/home/qj213/afp-2021-10-22/thys/Core_DOM/standard/classes/ElementClass.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Core_DOM", "problem_names": ["lemma element_ptr_kinds_simp [simp]: \n  \"element_ptr_kinds (Heap (fmupd (cast element_ptr) element (the_heap h))) =\n{|element_ptr|} |\\<union>| element_ptr_kinds h\"", "lemmas is_element_kind_def = is_element_kind\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def", "lemma element_ptr_kinds_commutes [simp]: \n  \"cast element_ptr |\\<in>| node_ptr_kinds h \\<longleftrightarrow> element_ptr |\\<in>| element_ptr_kinds h\"", "lemmas type_wf_defs = a_type_wf_def", "lemma get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_type_wf:\n  assumes \"type_wf h\"\n  shows \"element_ptr |\\<in>| element_ptr_kinds h \\<longleftrightarrow> get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr h \\<noteq> None\"", "lemma put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_ptr_in_heap:\n  assumes \"put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr element h = h'\"\n  shows \"element_ptr |\\<in>| element_ptr_kinds h'\"", "lemma put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_put_ptrs:\n  assumes \"put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr element h = h'\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast element_ptr|}\"", "lemma cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_inject [simp]: \n  \"cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e x = cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e y \\<longleftrightarrow> x = y\"", "lemma cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_none [simp]: \n  \"cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t node = None \\<longleftrightarrow> \\<not> (\\<exists>element. cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e element = node)\"", "lemma cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_some [simp]: \n  \"cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t node = Some element \\<longleftrightarrow> cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e element = node\"", "lemma cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_inv [simp]: \"cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t (cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e element) = Some element\"", "lemma get_elment_ptr_simp1 [simp]: \n  \"get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr (put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr element h) = Some element\"", "lemma get_elment_ptr_simp2 [simp]: \n  \"element_ptr \\<noteq> element_ptr' \n  \\<Longrightarrow> get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr (put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr' element h) = get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr h\"", "lemma new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_ptr_in_heap:\n  assumes \"new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h = (new_element_ptr, h')\"\n  shows \"new_element_ptr |\\<in>| element_ptr_kinds h'\"", "lemma new_element_ptr_new: \n  \"element_ptr.Ref (Suc (fMax (finsert 0 (element_ptr.the_ref |`| element_ptrs h)))) |\\<notin>| element_ptrs h\"", "lemma new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_ptr_not_in_heap:\n  assumes \"new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h = (new_element_ptr, h')\"\n  shows \"new_element_ptr |\\<notin>| element_ptr_kinds h\"", "lemma new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_new_ptr:\n  assumes \"new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h = (new_element_ptr, h')\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast new_element_ptr|}\"", "lemma new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_is_element_ptr:\n  assumes \"new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h = (new_element_ptr, h')\"\n  shows \"is_element_ptr new_element_ptr\"", "lemma new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t [simp]:\n  assumes \"new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h = (new_element_ptr, h')\"\n  assumes \"ptr \\<noteq> cast new_element_ptr\"\n  shows \"get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr h = get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr h'\"", "lemma new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e [simp]:\n  assumes \"new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h = (new_element_ptr, h')\"\n  assumes \"ptr \\<noteq> cast new_element_ptr\"\n  shows \"get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr h = get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr h'\"", "lemma new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t [simp]:\n  assumes \"new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h = (new_element_ptr, h')\"\n  assumes \"ptr \\<noteq> new_element_ptr\"\n  shows \"get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr h = get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr h'\"", "lemma known_ptr_not_element_ptr: \"\\<not>is_element_ptr ptr \\<Longrightarrow> a_known_ptr ptr \\<Longrightarrow> known_ptr ptr\"", "lemmas known_ptr_defs = a_known_ptr_def", "lemma known_ptrs_known_ptr: \n  \"ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow> a_known_ptrs h \\<Longrightarrow> known_ptr ptr\"", "lemma known_ptrs_preserved:\n  \"object_ptr_kinds h = object_ptr_kinds h' \\<Longrightarrow> a_known_ptrs h = a_known_ptrs h'\"", "lemma known_ptrs_subset:\n  \"object_ptr_kinds h' |\\<subseteq>| object_ptr_kinds h \\<Longrightarrow> a_known_ptrs h \\<Longrightarrow> a_known_ptrs h'\"", "lemma known_ptrs_new_ptr:\n  \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|new_ptr|} \\<Longrightarrow> known_ptr new_ptr \\<Longrightarrow>\na_known_ptrs h \\<Longrightarrow> a_known_ptrs h'\"", "lemmas known_ptrs_defs = a_known_ptrs_def", "lemma known_ptrs_is_l_known_ptrs: \"l_known_ptrs known_ptr known_ptrs\""], "translations": [["", "lemma element_ptr_kinds_simp [simp]: \n  \"element_ptr_kinds (Heap (fmupd (cast element_ptr) element (the_heap h))) =\n{|element_ptr|} |\\<union>| element_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. element_ptr_kinds\n     (Heap (fmupd (cast (cast element_ptr)) element (the_heap h))) =\n    {|element_ptr|} |\\<union>| element_ptr_kinds h", "apply(auto simp add: element_ptr_kinds_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. element_ptr |\\<in>|\n    (the \\<circ> cast) |`|\n    ffilter is_element_ptr_kind\n     (finsert (cast element_ptr) (node_ptr_kinds h))", "by force"], ["", "definition element_ptrs :: \"(_) heap \\<Rightarrow> (_) element_ptr fset\"\n  where\n    \"element_ptrs heap = ffilter is_element_ptr (element_ptr_kinds heap)\""], ["", "definition cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t :: \"(_) Node \\<Rightarrow> (_) Element option\"\n  where\n    \"cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t node =\n(case RNode.more node of Inl element \\<Rightarrow> Some (RNode.extend (RNode.truncate node) element) | _ \\<Rightarrow> None)\""], ["", "adhoc_overloading cast cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t"], ["", "abbreviation cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t :: \"(_) Object \\<Rightarrow> (_) Element option\"\n  where\n    \"cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t obj \\<equiv> (case cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e obj of Some node \\<Rightarrow> cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t node | None \\<Rightarrow> None)\""], ["", "adhoc_overloading cast cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t"], ["", "definition cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e :: \"(_) Element \\<Rightarrow> (_) Node\"\n  where\n    \"cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e element = RNode.extend (RNode.truncate element) (Inl (RNode.more element))\""], ["", "adhoc_overloading cast cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e"], ["", "abbreviation cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t :: \"(_) Element \\<Rightarrow> (_) Object\"\n  where\n    \"cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr \\<equiv> cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr)\""], ["", "adhoc_overloading cast cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t"], ["", "consts is_element_kind :: 'a"], ["", "definition is_element_kind\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e :: \"(_) Node \\<Rightarrow> bool\"\n  where\n    \"is_element_kind\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr \\<longleftrightarrow> cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr \\<noteq> None\""], ["", "adhoc_overloading is_element_kind is_element_kind\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e"], ["", "lemmas is_element_kind_def = is_element_kind\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def"], ["", "abbreviation is_element_kind\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t :: \"(_) Object \\<Rightarrow> bool\"\n  where\n    \"is_element_kind\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr \\<equiv> cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr \\<noteq> None\""], ["", "adhoc_overloading is_element_kind is_element_kind\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t"], ["", "lemma element_ptr_kinds_commutes [simp]: \n  \"cast element_ptr |\\<in>| node_ptr_kinds h \\<longleftrightarrow> element_ptr |\\<in>| element_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cast element_ptr |\\<in>| node_ptr_kinds h) =\n    (element_ptr |\\<in>| element_ptr_kinds h)", "apply(auto simp add: node_ptr_kinds_def element_ptr_kinds_def)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>cast element_ptr = the (cast x);\n        x |\\<in>| object_ptr_kinds h; is_node_ptr_kind x\\<rbrakk>\n       \\<Longrightarrow> element_ptr |\\<in>|\n                         (the \\<circ> cast) |`|\n                         ffilter is_element_ptr_kind\n                          ((the \\<circ> cast) |`|\n                           ffilter is_node_ptr_kind (object_ptr_kinds h))", "by (metis (no_types, lifting) element_ptr_casts_commute2 ffmember_filter fimage_eqI \n      fset.map_comp is_element_ptr_kind_none node_ptr_casts_commute3 \n      node_ptr_kinds_commutes node_ptr_kinds_def option.sel option.simps(3))"], ["", "definition get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t :: \"(_) element_ptr \\<Rightarrow> (_) heap \\<Rightarrow> (_) Element option\"\n  where                             \n    \"get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr h = Option.bind (get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e (cast element_ptr) h) cast\""], ["", "adhoc_overloading get get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t"], ["", "locale l_type_wf_def\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\nbegin"], ["", "definition a_type_wf :: \"(_) heap \\<Rightarrow> bool\"\n  where\n    \"a_type_wf h = (NodeClass.type_wf h \\<and> (\\<forall>element_ptr \\<in> fset (element_ptr_kinds h).\n                                                                  get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr h \\<noteq> None))\""], ["", "end"], ["", "global_interpretation l_type_wf_def\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t defines type_wf = a_type_wf"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas type_wf_defs = a_type_wf_def"], ["", "locale l_type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t = l_type_wf type_wf for type_wf :: \"((_) heap \\<Rightarrow> bool)\" +\n  assumes type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t: \"type_wf h \\<Longrightarrow> ElementClass.type_wf h\""], ["", "sublocale l_type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t \\<subseteq> l_type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_type_wf\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e type_wf", "apply(unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h. type_wf h \\<Longrightarrow> NodeClass.type_wf h", "using NodeClass.a_type_wf_def"], ["proof (prove)\nusing this:\n  NodeClass.type_wf ?h =\n  (ObjectClass.type_wf ?h \\<and>\n   (\\<forall>node_ptr\\<in>fset (node_ptr_kinds ?h).\n       get node_ptr ?h \\<noteq> None))\n\ngoal (1 subgoal):\n 1. \\<And>h. type_wf h \\<Longrightarrow> NodeClass.type_wf h", "by (meson ElementClass.a_type_wf_def l_type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_axioms l_type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def)"], ["", "locale l_get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_lemmas = l_type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\nbegin"], ["", "sublocale l_get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_lemmas"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_lemmas type_wf", "by unfold_locales"], ["", "lemma get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_type_wf:\n  assumes \"type_wf h\"\n  shows \"element_ptr |\\<in>| element_ptr_kinds h \\<longleftrightarrow> get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr h \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (element_ptr |\\<in>| element_ptr_kinds h) =\n    (get element_ptr h \\<noteq> None)", "using l_type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_axioms assms"], ["proof (prove)\nusing this:\n  l_type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t type_wf\n  type_wf h\n\ngoal (1 subgoal):\n 1. (element_ptr |\\<in>| element_ptr_kinds h) =\n    (get element_ptr h \\<noteq> None)", "apply(simp add: type_wf_defs get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def l_type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>h.\n                type_wf h \\<longrightarrow>\n                NodeClass.type_wf h \\<and>\n                (\\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n                    \\<exists>y.\n                       Option.bind (get (cast element_ptr) h) cast =\n                       Some y);\n     type_wf h\\<rbrakk>\n    \\<Longrightarrow> (element_ptr |\\<in>| element_ptr_kinds h) =\n                      (\\<exists>y.\n                          Option.bind (get (cast element_ptr) h) cast =\n                          Some y)", "by (metis NodeClass.get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_type_wf bind_eq_None_conv element_ptr_kinds_commutes notin_fset\n      option.distinct(1))"], ["", "end"], ["", "global_interpretation l_get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_lemmas type_wf"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_lemmas\n     ElementClass.type_wf", "by unfold_locales"], ["", "definition put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t :: \"(_) element_ptr \\<Rightarrow> (_) Element \\<Rightarrow> (_) heap \\<Rightarrow> (_) heap\"\n  where                                     \n    \"put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr element = put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e (cast element_ptr) (cast element)\""], ["", "adhoc_overloading put put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t"], ["", "lemma put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_ptr_in_heap:\n  assumes \"put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr element h = h'\"\n  shows \"element_ptr |\\<in>| element_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. element_ptr |\\<in>| element_ptr_kinds h'", "using assms"], ["proof (prove)\nusing this:\n  put element_ptr element h = h'\n\ngoal (1 subgoal):\n 1. element_ptr |\\<in>| element_ptr_kinds h'", "unfolding put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def element_ptr_kinds_def"], ["proof (prove)\nusing this:\n  put (cast element_ptr) (cast element) h = h'\n\ngoal (1 subgoal):\n 1. element_ptr |\\<in>|\n    the |`| cast |`| ffilter is_element_ptr_kind (node_ptr_kinds h')", "by (metis element_ptr_kinds_commutes element_ptr_kinds_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_ptr_in_heap)"], ["", "lemma put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_put_ptrs:\n  assumes \"put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr element h = h'\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast element_ptr|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast (cast element_ptr)|}", "using assms"], ["proof (prove)\nusing this:\n  put element_ptr element h = h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast (cast element_ptr)|}", "by (simp add: put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_put_ptrs)"], ["", "lemma cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_inject [simp]: \n  \"cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e x = cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e y \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cast x = cast y) = (x = y)", "apply(simp add: cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def RObject.extend_def RNode.extend_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (RNode.more x = RNode.more y) = (x = y)", "by (metis (full_types) RNode.surjective old.unit.exhaust)"], ["", "lemma cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_none [simp]: \n  \"cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t node = None \\<longleftrightarrow> \\<not> (\\<exists>element. cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e element = node)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cast node = None) = (\\<nexists>element. cast element = node)", "apply(auto simp add: cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def RObject.extend_def RNode.extend_def \n      split: sum.splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1.\n       RNode.more node = Inl x1 \\<Longrightarrow>\n       \\<exists>element.\n          \\<lparr>RObject.nothing = (), RNode.nothing = (),\n             \\<dots> = Inl (RNode.more element)\\<rparr> =\n          node", "by (metis (full_types) RNode.select_convs(2) RNode.surjective old.unit.exhaust)"], ["", "lemma cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_some [simp]: \n  \"cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t node = Some element \\<longleftrightarrow> cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e element = node\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cast node = Some element) = (cast element = node)", "by(auto simp add: cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def RObject.extend_def RNode.extend_def \n      split: sum.splits)"], ["", "lemma cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_inv [simp]: \"cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t (cast\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e element) = Some element\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cast (cast element) = Some element", "by simp"], ["", "lemma get_elment_ptr_simp1 [simp]: \n  \"get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr (put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr element h) = Some element\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get element_ptr (put element_ptr element h) = Some element", "by(auto simp add: get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def)"], ["", "lemma get_elment_ptr_simp2 [simp]: \n  \"element_ptr \\<noteq> element_ptr' \n  \\<Longrightarrow> get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr (put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr' element h) = get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. element_ptr \\<noteq> element_ptr' \\<Longrightarrow>\n    get element_ptr (put element_ptr' element h) = get element_ptr h", "by(auto simp add: get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def)"], ["", "abbreviation \"create_element_obj tag_name_arg child_nodes_arg attrs_arg shadow_root_opt_arg\n  \\<equiv> \\<lparr> RObject.nothing = (), RNode.nothing = (), RElement.nothing = (),\n      tag_name = tag_name_arg, Element.child_nodes = child_nodes_arg, attrs = attrs_arg,\n      shadow_root_opt = shadow_root_opt_arg, \\<dots> = None \\<rparr>\""], ["", "definition new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t :: \"(_) heap \\<Rightarrow> ((_) element_ptr \\<times> (_) heap)\"\n  where\n    \"new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h = \n      (let new_element_ptr = element_ptr.Ref (Suc (fMax (finsert 0 (element_ptr.the_ref \n                                 |`| (element_ptrs h))))) \n       in\n      (new_element_ptr, put new_element_ptr (create_element_obj '''' [] fmempty None) h))\""], ["", "lemma new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_ptr_in_heap:\n  assumes \"new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h = (new_element_ptr, h')\"\n  shows \"new_element_ptr |\\<in>| element_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_element_ptr |\\<in>| element_ptr_kinds h'", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h =\n  (new_element_ptr, h')\n\ngoal (1 subgoal):\n 1. new_element_ptr |\\<in>| element_ptr_kinds h'", "unfolding new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def Let_def"], ["proof (prove)\nusing this:\n  (element_ptr.Ref\n    (Suc (fMax (finsert 0 (element_ptr.the_ref |`| element_ptrs h)))),\n   put (element_ptr.Ref\n         (Suc (fMax (finsert 0 (element_ptr.the_ref |`| element_ptrs h)))))\n    (create_element_obj [] [] fmempty None) h) =\n  (new_element_ptr, h')\n\ngoal (1 subgoal):\n 1. new_element_ptr |\\<in>| element_ptr_kinds h'", "using put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_ptr_in_heap"], ["proof (prove)\nusing this:\n  (element_ptr.Ref\n    (Suc (fMax (finsert 0 (element_ptr.the_ref |`| element_ptrs h)))),\n   put (element_ptr.Ref\n         (Suc (fMax (finsert 0 (element_ptr.the_ref |`| element_ptrs h)))))\n    (create_element_obj [] [] fmempty None) h) =\n  (new_element_ptr, h')\n  put ?element_ptr ?element ?h = ?h' \\<Longrightarrow>\n  ?element_ptr |\\<in>| element_ptr_kinds ?h'\n\ngoal (1 subgoal):\n 1. new_element_ptr |\\<in>| element_ptr_kinds h'", "by blast"], ["", "lemma new_element_ptr_new: \n  \"element_ptr.Ref (Suc (fMax (finsert 0 (element_ptr.the_ref |`| element_ptrs h)))) |\\<notin>| element_ptrs h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. element_ptr.Ref\n     (Suc (fMax\n            (finsert 0\n              (element_ptr.the_ref |`| element_ptrs h)))) |\\<notin>|\n    element_ptrs h", "by (metis Suc_n_not_le_n element_ptr.sel(1) fMax_ge fimage_finsert finsertI1 finsertI2 set_finsert)"], ["", "lemma new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_ptr_not_in_heap:\n  assumes \"new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h = (new_element_ptr, h')\"\n  shows \"new_element_ptr |\\<notin>| element_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_element_ptr |\\<notin>| element_ptr_kinds h", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h =\n  (new_element_ptr, h')\n\ngoal (1 subgoal):\n 1. new_element_ptr |\\<notin>| element_ptr_kinds h", "unfolding new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def"], ["proof (prove)\nusing this:\n  (let new_element_ptr =\n         element_ptr.Ref\n          (Suc (fMax (finsert 0 (element_ptr.the_ref |`| element_ptrs h))))\n   in (new_element_ptr,\n       put new_element_ptr (create_element_obj [] [] fmempty None) h)) =\n  (new_element_ptr, h')\n\ngoal (1 subgoal):\n 1. new_element_ptr |\\<notin>| element_ptr_kinds h", "by (metis Pair_inject element_ptrs_def ffmember_filter new_element_ptr_new is_element_ptr_ref)"], ["", "lemma new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_new_ptr:\n  assumes \"new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h = (new_element_ptr, h')\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast new_element_ptr|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast (cast new_element_ptr)|}", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h =\n  (new_element_ptr, h')\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast (cast new_element_ptr)|}", "by (metis Pair_inject new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_put_ptrs)"], ["", "lemma new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_is_element_ptr:\n  assumes \"new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h = (new_element_ptr, h')\"\n  shows \"is_element_ptr new_element_ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_element_ptr new_element_ptr", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h =\n  (new_element_ptr, h')\n\ngoal (1 subgoal):\n 1. is_element_ptr new_element_ptr", "by(auto simp add: new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def Let_def)"], ["", "lemma new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t [simp]:\n  assumes \"new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h = (new_element_ptr, h')\"\n  assumes \"ptr \\<noteq> cast new_element_ptr\"\n  shows \"get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr h = get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h =\n  (new_element_ptr, h')\n  ptr \\<noteq> cast (cast new_element_ptr)\n\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "by(auto simp add: new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def Let_def put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def)"], ["", "lemma new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e [simp]:\n  assumes \"new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h = (new_element_ptr, h')\"\n  assumes \"ptr \\<noteq> cast new_element_ptr\"\n  shows \"get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr h = get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h =\n  (new_element_ptr, h')\n  ptr \\<noteq> cast new_element_ptr\n\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "by(auto simp add: new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def Let_def put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def)"], ["", "lemma new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t [simp]:\n  assumes \"new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h = (new_element_ptr, h')\"\n  assumes \"ptr \\<noteq> new_element_ptr\"\n  shows \"get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr h = get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "using assms"], ["proof (prove)\nusing this:\n  new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h =\n  (new_element_ptr, h')\n  ptr \\<noteq> new_element_ptr\n\ngoal (1 subgoal):\n 1. get ptr h = get ptr h'", "by(auto simp add: new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def Let_def)"], ["", "locale l_known_ptr\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\nbegin"], ["", "definition a_known_ptr :: \"(_) object_ptr \\<Rightarrow> bool\"\n  where\n    \"a_known_ptr ptr = (known_ptr ptr \\<or> is_element_ptr ptr)\""], ["", "lemma known_ptr_not_element_ptr: \"\\<not>is_element_ptr ptr \\<Longrightarrow> a_known_ptr ptr \\<Longrightarrow> known_ptr ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> (case cast ptr of None \\<Rightarrow> False\n                     | Some x \\<Rightarrow> is_element_ptr x);\n     local.a_known_ptr ptr\\<rbrakk>\n    \\<Longrightarrow> NodeClass.known_ptr ptr", "by(simp add: a_known_ptr_def)"], ["", "end"], ["", "global_interpretation l_known_ptr\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t defines known_ptr = a_known_ptr"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas known_ptr_defs = a_known_ptr_def"], ["", "locale l_known_ptrs\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t = l_known_ptr known_ptr for known_ptr :: \"(_) object_ptr \\<Rightarrow> bool\"\nbegin"], ["", "definition a_known_ptrs :: \"(_) heap \\<Rightarrow> bool\"\n  where\n    \"a_known_ptrs h = (\\<forall>ptr \\<in> fset (object_ptr_kinds h). known_ptr ptr)\""], ["", "lemma known_ptrs_known_ptr: \n  \"ptr |\\<in>| object_ptr_kinds h \\<Longrightarrow> a_known_ptrs h \\<Longrightarrow> known_ptr ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ptr |\\<in>| object_ptr_kinds h; local.a_known_ptrs h\\<rbrakk>\n    \\<Longrightarrow> known_ptr ptr", "apply(simp add: a_known_ptrs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ptr |\\<in>| object_ptr_kinds h;\n     \\<forall>ptr\\<in>fset (object_ptr_kinds h). known_ptr ptr\\<rbrakk>\n    \\<Longrightarrow> known_ptr ptr", "using notin_fset"], ["proof (prove)\nusing this:\n  (?x |\\<notin>| ?S) = (?x \\<notin> fset ?S)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ptr |\\<in>| object_ptr_kinds h;\n     \\<forall>ptr\\<in>fset (object_ptr_kinds h). known_ptr ptr\\<rbrakk>\n    \\<Longrightarrow> known_ptr ptr", "by fastforce"], ["", "lemma known_ptrs_preserved:\n  \"object_ptr_kinds h = object_ptr_kinds h' \\<Longrightarrow> a_known_ptrs h = a_known_ptrs h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h' \\<Longrightarrow>\n    local.a_known_ptrs h = local.a_known_ptrs h'", "by(auto simp add: a_known_ptrs_def)"], ["", "lemma known_ptrs_subset:\n  \"object_ptr_kinds h' |\\<subseteq>| object_ptr_kinds h \\<Longrightarrow> a_known_ptrs h \\<Longrightarrow> a_known_ptrs h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>object_ptr_kinds h' |\\<subseteq>| object_ptr_kinds h;\n     local.a_known_ptrs h\\<rbrakk>\n    \\<Longrightarrow> local.a_known_ptrs h'", "by(simp add: a_known_ptrs_def less_eq_fset.rep_eq subsetD)"], ["", "lemma known_ptrs_new_ptr:\n  \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|new_ptr|} \\<Longrightarrow> known_ptr new_ptr \\<Longrightarrow>\na_known_ptrs h \\<Longrightarrow> a_known_ptrs h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>object_ptr_kinds h' =\n             object_ptr_kinds h |\\<union>| {|new_ptr|};\n     known_ptr new_ptr; local.a_known_ptrs h\\<rbrakk>\n    \\<Longrightarrow> local.a_known_ptrs h'", "by(simp add: a_known_ptrs_def)"], ["", "end"], ["", "global_interpretation l_known_ptrs\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t known_ptr defines known_ptrs = a_known_ptrs"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemmas known_ptrs_defs = a_known_ptrs_def"], ["", "lemma known_ptrs_is_l_known_ptrs: \"l_known_ptrs known_ptr known_ptrs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_known_ptrs ElementClass.known_ptr ElementClass.known_ptrs", "using known_ptrs_known_ptr known_ptrs_preserved  known_ptrs_subset known_ptrs_new_ptr l_known_ptrs_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?ptr |\\<in>| object_ptr_kinds ?h;\n   ElementClass.known_ptrs ?h\\<rbrakk>\n  \\<Longrightarrow> ElementClass.known_ptr ?ptr\n  object_ptr_kinds ?h = object_ptr_kinds ?h' \\<Longrightarrow>\n  ElementClass.known_ptrs ?h = ElementClass.known_ptrs ?h'\n  \\<lbrakk>object_ptr_kinds ?h' |\\<subseteq>| object_ptr_kinds ?h;\n   ElementClass.known_ptrs ?h\\<rbrakk>\n  \\<Longrightarrow> ElementClass.known_ptrs ?h'\n  \\<lbrakk>object_ptr_kinds ?h' =\n           object_ptr_kinds ?h |\\<union>| {|?new_ptr|};\n   ElementClass.known_ptr ?new_ptr; ElementClass.known_ptrs ?h\\<rbrakk>\n  \\<Longrightarrow> ElementClass.known_ptrs ?h'\n  l_known_ptrs ?known_ptr ?known_ptrs \\<equiv>\n  ((\\<forall>h ptr.\n       ?known_ptrs h \\<longrightarrow>\n       ptr |\\<in>| object_ptr_kinds h \\<longrightarrow>\n       ?known_ptr ptr) \\<and>\n   (\\<forall>h h'.\n       object_ptr_kinds h = object_ptr_kinds h' \\<longrightarrow>\n       ?known_ptrs h = ?known_ptrs h')) \\<and>\n  (\\<forall>h' h.\n      object_ptr_kinds h' |\\<subseteq>| object_ptr_kinds h \\<longrightarrow>\n      ?known_ptrs h \\<longrightarrow> ?known_ptrs h') \\<and>\n  (\\<forall>h' h new_ptr.\n      object_ptr_kinds h' =\n      object_ptr_kinds h |\\<union>| {|new_ptr|} \\<longrightarrow>\n      ?known_ptr new_ptr \\<longrightarrow>\n      ?known_ptrs h \\<longrightarrow> ?known_ptrs h')\n\ngoal (1 subgoal):\n 1. l_known_ptrs ElementClass.known_ptr ElementClass.known_ptrs", "by blast"], ["", "end"]]}