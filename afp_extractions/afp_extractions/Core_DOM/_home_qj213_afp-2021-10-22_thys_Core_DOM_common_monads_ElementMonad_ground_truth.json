{"file_name": "/home/qj213/afp-2021-10-22/thys/Core_DOM/common/monads/ElementMonad.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Core_DOM", "problem_names": ["lemmas element_ptr_kinds_M_defs = a_ptr_kinds_M_def", "lemma element_ptr_kinds_M_eq:\n  assumes \"|h \\<turnstile> node_ptr_kinds_M|\\<^sub>r = |h' \\<turnstile> node_ptr_kinds_M|\\<^sub>r\"\n  shows \"|h \\<turnstile> element_ptr_kinds_M|\\<^sub>r = |h' \\<turnstile> element_ptr_kinds_M|\\<^sub>r\"", "lemma element_ptr_kinds_M_reads: \n  \"reads (\\<Union>element_ptr. {preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t element_ptr RObject.nothing)}) element_ptr_kinds_M h h'\"", "lemma get_M_is_l_get_M: \"l_get_M get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t type_wf element_ptr_kinds\"", "lemmas get_M_defs = get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def[unfolded l_get_M.a_get_M_def[OF get_M_is_l_get_M]]", "lemmas get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_ok = get_M_ok[folded get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def]", "lemmas get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_ptr_in_heap = get_M_ptr_in_heap[folded get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def]", "lemmas put_M_defs = a_put_M_def", "lemmas put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_ok = put_M_ok[folded put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def]", "lemma element_put_get [simp]: \n  \"h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> (\\<And>x. getter (setter (\\<lambda>_. v) x) = v) \n  \\<Longrightarrow> h' \\<turnstile> get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr getter \\<rightarrow>\\<^sub>r v\"", "lemma get_M_Element_preserved1 [simp]: \n  \"element_ptr \\<noteq> element_ptr' \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \n     \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr' getter) h h'\"", "lemma element_put_get_preserved [simp]: \n  \"(\\<And>x. getter (setter (\\<lambda>_. v) x) = getter x) \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \n    \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr' getter) h h'\"", "lemma  get_M_Element_preserved3 [simp]: \n  \"(\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \n    \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\"", "lemma  get_M_Element_preserved4 [simp]: \n  \"(\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \n     \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr getter) h h'\"", "lemma  get_M_Element_preserved5 [simp]: \n  \"cast element_ptr \\<noteq> node_ptr \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \n  \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr getter) h h'\"", "lemma  get_M_Element_preserved6 [simp]: \n  \"h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \n    \\<Longrightarrow> (\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \n    \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr getter) h h'\"", "lemma  get_M_Element_preserved7 [simp]: \n  \"cast element_ptr \\<noteq> node_ptr \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr setter v \\<rightarrow>\\<^sub>h h' \n    \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr getter) h h'\"", "lemma  get_M_Element_preserved8 [simp]: \n  \"cast element_ptr \\<noteq> object_ptr \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \n    \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\"", "lemma  get_M_Element_preserved9 [simp]: \n  \"h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \n    \\<Longrightarrow> (\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \n   \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\"", "lemma  get_M_Element_preserved10 [simp]: \n  \"cast element_ptr \\<noteq> object_ptr \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr setter v \\<rightarrow>\\<^sub>h h' \n    \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr getter) h h'\"", "lemma new_element_ok [simp]:\n  \"h \\<turnstile> ok new_element\"", "lemma new_element_ptr_in_heap:\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\"\n  shows \"new_element_ptr |\\<in>| element_ptr_kinds h'\"", "lemma new_element_ptr_not_in_heap:\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\"\n  shows \"new_element_ptr |\\<notin>| element_ptr_kinds h\"", "lemma new_element_new_ptr:\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast new_element_ptr|}\"", "lemma new_element_is_element_ptr:\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\"\n  shows \"is_element_ptr new_element_ptr\"", "lemma new_element_child_nodes:\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\"\n  shows \"h' \\<turnstile> get_M new_element_ptr child_nodes \\<rightarrow>\\<^sub>r []\"", "lemma new_element_tag_name:\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\"\n  shows \"h' \\<turnstile> get_M new_element_ptr tag_name \\<rightarrow>\\<^sub>r ''''\"", "lemma new_element_attrs:\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\"\n  shows \"h' \\<turnstile> get_M new_element_ptr attrs \\<rightarrow>\\<^sub>r fmempty\"", "lemma new_element_shadow_root_opt:\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\"\n  shows \"h' \\<turnstile> get_M new_element_ptr shadow_root_opt \\<rightarrow>\\<^sub>r None\"", "lemma new_element_get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t: \n  \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr \\<Longrightarrow> ptr \\<noteq> cast new_element_ptr \n   \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr getter) h h'\"", "lemma new_element_get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e: \n  \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr \\<Longrightarrow> ptr \\<noteq> cast new_element_ptr \n    \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr getter) h h'\"", "lemma new_element_get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t: \n  \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr \\<Longrightarrow> ptr \\<noteq> new_element_ptr \n    \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\"", "lemma get_Element_ptr_simp [simp]: \n  \"get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) \n      = (if ptr = cast element_ptr then cast obj else get element_ptr h)\"", "lemma element_ptr_kinds_simp [simp]: \n  \"element_ptr_kinds (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) \n      = element_ptr_kinds h |\\<union>| (if is_element_ptr_kind ptr then {|the (cast ptr)|} else {||})\"", "lemma type_wf_put_I:\n  assumes \"type_wf h\"\n  assumes \"NodeClass.type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"is_element_ptr_kind ptr \\<Longrightarrow> is_element_kind obj\"\n  shows \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"", "lemma type_wf_put_ptr_not_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<notin>| object_ptr_kinds h\"\n  shows \"type_wf h\"", "lemma type_wf_put_ptr_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<in>| object_ptr_kinds h\"\n  assumes \"NodeClass.type_wf h\"\n  assumes \"is_element_ptr_kind ptr \\<Longrightarrow> is_element_kind (the (get ptr h))\"\n  shows \"type_wf h\"", "lemma new_element_type_wf_preserved [simp]: \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma new_element_is_l_new_element: \"l_new_element type_wf\"", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_tag_name_type_wf_preserved [simp]:\n  \"h \\<turnstile> put_M element_ptr tag_name_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_child_nodes_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M element_ptr child_nodes_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_attrs_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M element_ptr attrs_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_shadow_root_opt_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M element_ptr shadow_root_opt_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\"", "lemma put_M_pointers_preserved:\n  assumes \"h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h'\"\n  shows \"object_ptr_kinds h = object_ptr_kinds h'\"", "lemma element_ptr_kinds_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h'. \\<forall>w \\<in> SW. h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n                    \\<longrightarrow> (\\<forall>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h')\"\n  shows \"element_ptr_kinds h = element_ptr_kinds h'\"", "lemma element_ptr_kinds_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  shows \"element_ptr_kinds h = element_ptr_kinds h'\"", "lemma type_wf_preserved_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  assumes \"\\<And>node_ptr. preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr RNode.nothing) h h'\"\n  assumes \"\\<And>element_ptr. preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr RElement.nothing) h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma type_wf_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n           \\<Longrightarrow> \\<forall>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n           \\<Longrightarrow> \\<forall>node_ptr. preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr RNode.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n           \\<Longrightarrow> \\<forall>element_ptr. preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr RElement.nothing) h h'\"\n  shows \"type_wf h = type_wf h'\"", "lemma type_wf_drop: \"type_wf h \\<Longrightarrow> type_wf (Heap (fmdrop ptr (the_heap h)))\""], "translations": [["", "lemmas element_ptr_kinds_M_defs = a_ptr_kinds_M_def"], ["", "lemma element_ptr_kinds_M_eq:\n  assumes \"|h \\<turnstile> node_ptr_kinds_M|\\<^sub>r = |h' \\<turnstile> node_ptr_kinds_M|\\<^sub>r\"\n  shows \"|h \\<turnstile> element_ptr_kinds_M|\\<^sub>r = |h' \\<turnstile> element_ptr_kinds_M|\\<^sub>r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |h \\<turnstile> element_ptr_kinds_M|\\<^sub>r =\n    |h' \\<turnstile> element_ptr_kinds_M|\\<^sub>r", "using assms"], ["proof (prove)\nusing this:\n  |h \\<turnstile> node_ptr_kinds_M|\\<^sub>r =\n  |h' \\<turnstile> node_ptr_kinds_M|\\<^sub>r\n\ngoal (1 subgoal):\n 1. |h \\<turnstile> element_ptr_kinds_M|\\<^sub>r =\n    |h' \\<turnstile> element_ptr_kinds_M|\\<^sub>r", "by(auto simp add: element_ptr_kinds_M_defs node_ptr_kinds_M_defs element_ptr_kinds_def)"], ["", "lemma element_ptr_kinds_M_reads: \n  \"reads (\\<Union>element_ptr. {preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t element_ptr RObject.nothing)}) element_ptr_kinds_M h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reads\n     (\\<Union>element_ptr. {preserved (get_M element_ptr RObject.nothing)})\n     element_ptr_kinds_M h h'", "apply (simp add: reads_def node_ptr_kinds_M_defs element_ptr_kinds_M_defs element_ptr_kinds_def\n    node_ptr_kinds_M_reads preserved_def cong del: image_cong_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>y.\n        h \\<turnstile> get_M y RObject.nothing \\<rightarrow>\\<^sub>r () =\n        h' \\<turnstile> get_M y RObject.nothing\n        \\<rightarrow>\\<^sub>r ()) \\<longrightarrow>\n    (\\<forall>x.\n        (sorted_list_of_set\n          ((the \\<circ> cast) `\n           (Collect is_element_ptr_kind \\<inter> fset (node_ptr_kinds h))) =\n         x) =\n        (sorted_list_of_set\n          ((the \\<circ> cast) `\n           (Collect is_element_ptr_kind \\<inter>\n            fset (node_ptr_kinds h'))) =\n         x))", "apply (metis (mono_tags, hide_lams) node_ptr_kinds_small old.unit.exhaust preserved_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "global_interpretation l_dummy defines get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t = \"l_get_M.a_get_M get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma get_M_is_l_get_M: \"l_get_M get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t type_wf element_ptr_kinds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M get ElementClass.type_wf element_ptr_kinds", "apply(simp add: get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_type_wf l_get_M_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ptr h.\n       (\\<exists>y. get ptr h = Some y) \\<longrightarrow>\n       ptr |\\<in>| element_ptr_kinds h", "by (metis (no_types, lifting) ObjectClass.get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf ObjectClass.type_wf_defs \n      bind_eq_Some_conv bind_eq_Some_conv element_ptr_kinds_commutes get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def \n      get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def node_ptr_kinds_commutes option.simps(3))"], ["", "lemmas get_M_defs = get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def[unfolded l_get_M.a_get_M_def[OF get_M_is_l_get_M]]"], ["", "adhoc_overloading get_M get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t"], ["", "locale l_get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_lemmas = l_type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\nbegin"], ["", "sublocale l_get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_lemmas"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_lemmas type_wf", "by unfold_locales"], ["", "interpretation l_get_M get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t type_wf element_ptr_kinds"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M get type_wf element_ptr_kinds", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h ptr.\n       \\<lbrakk>type_wf h; ptr |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> get ptr h \\<noteq> None\n 2. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| element_ptr_kinds h", "apply (simp add: get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_type_wf local.type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| element_ptr_kinds h", "by (meson ElementMonad.get_M_is_l_get_M l_get_M_def)"], ["", "lemmas get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_ok = get_M_ok[folded get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def]"], ["", "lemmas get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_ptr_in_heap = get_M_ptr_in_heap[folded get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def]"], ["", "end"], ["", "global_interpretation l_get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_lemmas type_wf"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_lemmas\n     ElementClass.type_wf", "by unfold_locales"], ["", "global_interpretation l_put_M type_wf element_ptr_kinds get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t \n  rewrites \"a_get_M = get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\" \n  defines put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t = a_put_M"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M ElementClass.type_wf element_ptr_kinds get &&&\n    l_get_M.a_get_M get = get_M", "apply (simp add: get_M_is_l_get_M l_put_M_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_get_M.a_get_M get = get_M", "by (simp add: get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def)"], ["", "lemmas put_M_defs = a_put_M_def"], ["", "adhoc_overloading put_M put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t"], ["", "locale l_put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_lemmas = l_type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\nbegin"], ["", "sublocale l_put_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_lemmas"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_lemmas type_wf", "by unfold_locales"], ["", "interpretation l_put_M type_wf element_ptr_kinds get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M type_wf element_ptr_kinds get", "apply(unfold_locales)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>h ptr.\n       \\<lbrakk>type_wf h; ptr |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> get ptr h \\<noteq> None\n 2. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| element_ptr_kinds h", "apply (simp add: get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_type_wf local.type_wf\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ptr h.\n       get ptr h \\<noteq> None \\<Longrightarrow>\n       ptr |\\<in>| element_ptr_kinds h", "by (meson ElementMonad.get_M_is_l_get_M l_get_M_def)"], ["", "lemmas put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_ok = put_M_ok[folded put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def]"], ["", "end"], ["", "global_interpretation l_put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_lemmas type_wf"], ["proof (prove)\ngoal (1 subgoal):\n 1. l_put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_lemmas\n     ElementClass.type_wf", "by unfold_locales"], ["", "lemma element_put_get [simp]: \n  \"h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> (\\<And>x. getter (setter (\\<lambda>_. v) x) = v) \n  \\<Longrightarrow> h' \\<turnstile> get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr getter \\<rightarrow>\\<^sub>r v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> put_M element_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (setter (\\<lambda>_. v) x) = v\\<rbrakk>\n    \\<Longrightarrow> h' \\<turnstile> get_M element_ptr getter\n                      \\<rightarrow>\\<^sub>r v", "by(auto simp add: put_M_defs get_M_defs split: option.splits)"], ["", "lemma get_M_Element_preserved1 [simp]: \n  \"element_ptr \\<noteq> element_ptr' \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \n     \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr' getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>element_ptr \\<noteq> element_ptr';\n     h \\<turnstile> put_M element_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M element_ptr' getter) h h'", "by(auto simp add: put_M_defs get_M_defs preserved_def split: option.splits dest: get_heap_E)"], ["", "lemma element_put_get_preserved [simp]: \n  \"(\\<And>x. getter (setter (\\<lambda>_. v) x) = getter x) \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \n    \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr' getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x. getter (setter (\\<lambda>_. v) x) = getter x;\n     h \\<turnstile> put_M element_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M element_ptr' getter) h h'", "apply(cases \"element_ptr = element_ptr'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x. getter (setter (\\<lambda>_. v) x) = getter x;\n     h \\<turnstile> put_M element_ptr setter v \\<rightarrow>\\<^sub>h h';\n     element_ptr = element_ptr'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M element_ptr' getter) h h'\n 2. \\<lbrakk>\\<And>x. getter (setter (\\<lambda>_. v) x) = getter x;\n     h \\<turnstile> put_M element_ptr setter v \\<rightarrow>\\<^sub>h h';\n     element_ptr \\<noteq> element_ptr'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M element_ptr' getter) h h'", "by(auto simp add: put_M_defs get_M_defs preserved_def \n      split: option.splits dest: get_heap_E)"], ["", "lemma  get_M_Element_preserved3 [simp]: \n  \"(\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \n    \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                getter (cast (cast (setter (\\<lambda>_. v) x))) =\n                getter (cast (cast x));\n     h \\<turnstile> put_M element_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "apply(cases \"cast element_ptr = object_ptr\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                getter (cast (cast (setter (\\<lambda>_. v) x))) =\n                getter (cast (cast x));\n     h \\<turnstile> put_M element_ptr setter v \\<rightarrow>\\<^sub>h h';\n     cast (cast element_ptr) = object_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'\n 2. \\<lbrakk>\\<And>x.\n                getter (cast (cast (setter (\\<lambda>_. v) x))) =\n                getter (cast (cast x));\n     h \\<turnstile> put_M element_ptr setter v \\<rightarrow>\\<^sub>h h';\n     cast (cast element_ptr) \\<noteq> object_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "by (auto simp add: put_M_defs get_M_defs ObjectMonad.get_M_defs NodeMonad.get_M_defs get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def \n      get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def preserved_def put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def bind_eq_Some_conv \n      split: option.splits)"], ["", "lemma  get_M_Element_preserved4 [simp]: \n  \"(\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \n     \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     h \\<turnstile> put_M element_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M node_ptr getter) h h'", "apply(cases \"cast element_ptr = node_ptr\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     h \\<turnstile> put_M element_ptr setter v \\<rightarrow>\\<^sub>h h';\n     cast element_ptr = node_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M node_ptr getter) h h'\n 2. \\<lbrakk>\\<And>x.\n                getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     h \\<turnstile> put_M element_ptr setter v \\<rightarrow>\\<^sub>h h';\n     cast element_ptr \\<noteq> node_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M node_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs ObjectMonad.get_M_defs NodeMonad.get_M_defs get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def \n      get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def preserved_def put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def bind_eq_Some_conv \n      split: option.splits)"], ["", "lemma  get_M_Element_preserved5 [simp]: \n  \"cast element_ptr \\<noteq> node_ptr \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \n  \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cast element_ptr \\<noteq> node_ptr;\n     h \\<turnstile> put_M element_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M node_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def NodeMonad.get_M_defs preserved_def \n      split: option.splits dest: get_heap_E)"], ["", "lemma  get_M_Element_preserved6 [simp]: \n  \"h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \n    \\<Longrightarrow> (\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \n    \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> put_M element_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x.\n        getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M node_ptr getter) h h'", "apply(cases \"cast element_ptr \\<noteq> node_ptr\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h \\<turnstile> put_M element_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     cast element_ptr \\<noteq> node_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M node_ptr getter) h h'\n 2. \\<lbrakk>h \\<turnstile> put_M element_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x);\n     \\<not> cast element_ptr \\<noteq> node_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M node_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def NodeMonad.get_M_defs preserved_def \n      split: option.splits bind_splits dest: get_heap_E)"], ["", "lemma  get_M_Element_preserved7 [simp]: \n  \"cast element_ptr \\<noteq> node_ptr \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr setter v \\<rightarrow>\\<^sub>h h' \n    \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cast element_ptr \\<noteq> node_ptr;\n     h \\<turnstile> put_M node_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M element_ptr getter) h h'", "by(auto simp add: NodeMonad.put_M_defs get_M_defs get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def NodeMonad.get_M_defs preserved_def \n      split: option.splits dest: get_heap_E)"], ["", "lemma  get_M_Element_preserved8 [simp]: \n  \"cast element_ptr \\<noteq> object_ptr \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \n    \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cast (cast element_ptr) \\<noteq> object_ptr;\n     h \\<turnstile> put_M element_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def \n      ObjectMonad.get_M_defs preserved_def \n      split: option.splits dest: get_heap_E)"], ["", "lemma  get_M_Element_preserved9 [simp]: \n  \"h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h' \n    \\<Longrightarrow> (\\<And>x. getter (cast (setter (\\<lambda>_. v) x)) = getter (cast x)) \n   \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> put_M element_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x.\n        getter (cast (cast (setter (\\<lambda>_. v) x))) =\n        getter (cast (cast x))\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "apply(cases \"cast element_ptr \\<noteq> object_ptr\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h \\<turnstile> put_M element_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x.\n        getter (cast (cast (setter (\\<lambda>_. v) x))) =\n        getter (cast (cast x));\n     cast (cast element_ptr) \\<noteq> object_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'\n 2. \\<lbrakk>h \\<turnstile> put_M element_ptr setter v\n             \\<rightarrow>\\<^sub>h h';\n     \\<And>x.\n        getter (cast (cast (setter (\\<lambda>_. v) x))) =\n        getter (cast (cast x));\n     \\<not> cast (cast element_ptr) \\<noteq> object_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M object_ptr getter) h h'", "by(auto simp add: put_M_defs get_M_defs get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def \n      ObjectMonad.get_M_defs preserved_def \n      split: option.splits bind_splits dest: get_heap_E)"], ["", "lemma  get_M_Element_preserved10 [simp]: \n  \"cast element_ptr \\<noteq> object_ptr \\<Longrightarrow> h \\<turnstile> put_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr setter v \\<rightarrow>\\<^sub>h h' \n    \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cast (cast element_ptr) \\<noteq> object_ptr;\n     h \\<turnstile> put_M object_ptr setter v\n     \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M element_ptr getter) h h'", "by(auto simp add: ObjectMonad.put_M_defs get_M_defs get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def \n      ObjectMonad.get_M_defs preserved_def \n      split: option.splits dest: get_heap_E)"], ["", "subsection\\<open>Creating Elements\\<close>"], ["", "definition new_element :: \"(_, (_) element_ptr) dom_prog\"\n  where\n    \"new_element = do {\n      h \\<leftarrow> get_heap;\n      (new_ptr, h') \\<leftarrow> return (new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t h);\n      return_heap h';\n      return new_ptr\n    }\""], ["", "lemma new_element_ok [simp]:\n  \"h \\<turnstile> ok new_element\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> ok new_element", "by(auto simp add: new_element_def split: prod.splits)"], ["", "lemma new_element_ptr_in_heap:\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\"\n  shows \"new_element_ptr |\\<in>| element_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_element_ptr |\\<in>| element_ptr_kinds h'", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\n\ngoal (1 subgoal):\n 1. new_element_ptr |\\<in>| element_ptr_kinds h'", "unfolding new_element_def"], ["proof (prove)\nusing this:\n  h \\<turnstile> get_heap \\<bind>\n                 (\\<lambda>h.\n                     return\n                      (new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\n                        h) \\<bind>\n                     (\\<lambda>(new_ptr, h').\n                         return_heap h' \\<bind>\n                         (\\<lambda>_. return new_ptr)))\n  \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> get_heap \\<bind>\n                 (\\<lambda>h.\n                     return\n                      (new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t\n                        h) \\<bind>\n                     (\\<lambda>(new_ptr, h').\n                         return_heap h' \\<bind>\n                         (\\<lambda>_. return new_ptr)))\n  \\<rightarrow>\\<^sub>r new_element_ptr\n\ngoal (1 subgoal):\n 1. new_element_ptr |\\<in>| element_ptr_kinds h'", "by(auto simp add: new_element_def new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def Let_def put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_ptr_in_heap is_OK_returns_result_I\n      elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_element_ptr_not_in_heap:\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\"\n  shows \"new_element_ptr |\\<notin>| element_ptr_kinds h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. new_element_ptr |\\<notin>| element_ptr_kinds h", "using assms new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_ptr_not_in_heap"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\n  new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ?h =\n  (?new_element_ptr, ?h') \\<Longrightarrow>\n  ?new_element_ptr |\\<notin>| element_ptr_kinds ?h\n\ngoal (1 subgoal):\n 1. new_element_ptr |\\<notin>| element_ptr_kinds h", "by(auto simp add: new_element_def split: prod.splits elim!: bind_returns_result_E \n      bind_returns_heap_E)"], ["", "lemma new_element_new_ptr:\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\"\n    and \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\"\n  shows \"object_ptr_kinds h' = object_ptr_kinds h |\\<union>| {|cast new_element_ptr|}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast (cast new_element_ptr)|}", "using assms new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_new_ptr"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\n  new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ?h =\n  (?new_element_ptr, ?h') \\<Longrightarrow>\n  object_ptr_kinds ?h' =\n  object_ptr_kinds ?h |\\<union>| {|cast (cast ?new_element_ptr)|}\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h' =\n    object_ptr_kinds h |\\<union>| {|cast (cast new_element_ptr)|}", "by(auto simp add: new_element_def split: prod.splits elim!: bind_returns_result_E \n      bind_returns_heap_E)"], ["", "lemma new_element_is_element_ptr:\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\"\n  shows \"is_element_ptr new_element_ptr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_element_ptr new_element_ptr", "using assms new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_is_element_ptr"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\n  new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ?h =\n  (?new_element_ptr, ?h') \\<Longrightarrow>\n  is_element_ptr ?new_element_ptr\n\ngoal (1 subgoal):\n 1. is_element_ptr new_element_ptr", "by(auto simp add: new_element_def elim!: bind_returns_result_E split: prod.splits)"], ["", "lemma new_element_child_nodes:\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\"\n  shows \"h' \\<turnstile> get_M new_element_ptr child_nodes \\<rightarrow>\\<^sub>r []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M new_element_ptr child_nodes\n    \\<rightarrow>\\<^sub>r []", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\n\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M new_element_ptr child_nodes\n    \\<rightarrow>\\<^sub>r []", "by(auto simp add: get_M_defs new_element_def new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def Let_def \n      split: option.splits prod.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_element_tag_name:\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\"\n  shows \"h' \\<turnstile> get_M new_element_ptr tag_name \\<rightarrow>\\<^sub>r ''''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M new_element_ptr tag_name \\<rightarrow>\\<^sub>r []", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\n\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M new_element_ptr tag_name \\<rightarrow>\\<^sub>r []", "by(auto simp add: get_M_defs new_element_def new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def Let_def \n      split: option.splits prod.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_element_attrs:\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\"\n  shows \"h' \\<turnstile> get_M new_element_ptr attrs \\<rightarrow>\\<^sub>r fmempty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M new_element_ptr attrs\n    \\<rightarrow>\\<^sub>r fmempty", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\n\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M new_element_ptr attrs\n    \\<rightarrow>\\<^sub>r fmempty", "by(auto simp add: get_M_defs new_element_def new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def Let_def \n      split: option.splits prod.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_element_shadow_root_opt:\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\"\n  assumes \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\"\n  shows \"h' \\<turnstile> get_M new_element_ptr shadow_root_opt \\<rightarrow>\\<^sub>r None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M new_element_ptr shadow_root_opt\n    \\<rightarrow>\\<^sub>r None", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h'\n  h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr\n\ngoal (1 subgoal):\n 1. h' \\<turnstile> get_M new_element_ptr shadow_root_opt\n    \\<rightarrow>\\<^sub>r None", "by(auto simp add: get_M_defs new_element_def new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def Let_def \n      split: option.splits prod.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_element_get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t: \n  \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr \\<Longrightarrow> ptr \\<noteq> cast new_element_ptr \n   \\<Longrightarrow> preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr;\n     ptr \\<noteq> cast (cast new_element_ptr)\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new_element_def ObjectMonad.get_M_defs preserved_def \n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_element_get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e: \n  \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr \\<Longrightarrow> ptr \\<noteq> cast new_element_ptr \n    \\<Longrightarrow> preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr;\n     ptr \\<noteq> cast new_element_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new_element_def NodeMonad.get_M_defs preserved_def \n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "lemma new_element_get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t: \n  \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr \\<Longrightarrow> ptr \\<noteq> new_element_ptr \n    \\<Longrightarrow> preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t ptr getter) h h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h';\n     h \\<turnstile> new_element \\<rightarrow>\\<^sub>r new_element_ptr;\n     ptr \\<noteq> new_element_ptr\\<rbrakk>\n    \\<Longrightarrow> preserved (get_M ptr getter) h h'", "by(auto simp add: new_element_def get_M_defs preserved_def \n      split: prod.splits option.splits elim!: bind_returns_result_E bind_returns_heap_E)"], ["", "subsection\\<open>Modified Heaps\\<close>"], ["", "lemma get_Element_ptr_simp [simp]: \n  \"get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) \n      = (if ptr = cast element_ptr then cast obj else get element_ptr h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get element_ptr (put ptr obj h) =\n    (if ptr = cast (cast element_ptr)\n     then case cast obj of None \\<Rightarrow> None\n          | Some node \\<Rightarrow> cast node\n     else get element_ptr h)", "by(auto simp add: get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def split: option.splits Option.bind_splits)"], ["", "lemma element_ptr_kinds_simp [simp]: \n  \"element_ptr_kinds (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h) \n      = element_ptr_kinds h |\\<union>| (if is_element_ptr_kind ptr then {|the (cast ptr)|} else {||})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. element_ptr_kinds (put ptr obj h) =\n    element_ptr_kinds h |\\<union>|\n    (if case cast ptr of None \\<Rightarrow> False\n        | Some node_ptr \\<Rightarrow> is_element_ptr_kind node_ptr\n     then {|the (case cast ptr of None \\<Rightarrow> None\n                 | Some node_ptr \\<Rightarrow> cast node_ptr)|}\n     else {||})", "by(auto simp add: element_ptr_kinds_def is_node_ptr_kind_def split: option.splits)"], ["", "lemma type_wf_put_I:\n  assumes \"type_wf h\"\n  assumes \"NodeClass.type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"is_element_ptr_kind ptr \\<Longrightarrow> is_element_kind obj\"\n  shows \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ElementClass.type_wf (put ptr obj h)", "using assms"], ["proof (prove)\nusing this:\n  ElementClass.type_wf h\n  NodeClass.type_wf (put ptr obj h)\n  case cast ptr of None \\<Rightarrow> False\n  | Some node_ptr \\<Rightarrow>\n      is_element_ptr_kind node_ptr \\<Longrightarrow>\n  (case cast obj of None \\<Rightarrow> None\n   | Some node \\<Rightarrow> cast node) \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. ElementClass.type_wf (put ptr obj h)", "by(auto simp add: type_wf_defs split: option.splits)"], ["", "lemma type_wf_put_ptr_not_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<notin>| object_ptr_kinds h\"\n  shows \"type_wf h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ElementClass.type_wf h", "using assms"], ["proof (prove)\nusing this:\n  ElementClass.type_wf (put ptr obj h)\n  ptr |\\<notin>| object_ptr_kinds h\n\ngoal (1 subgoal):\n 1. ElementClass.type_wf h", "apply(auto simp add: type_wf_defs elim!: NodeMonad.type_wf_put_ptr_not_in_heap_E \n                                    split: option.splits if_splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2b y.\n       \\<lbrakk>the (cast x2b) |\\<notin>| element_ptr_kinds h;\n        is_element_ptr_kind x2b; ptr = cast x2b;\n        \\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n           x2b = cast element_ptr \\<or>\n           (\\<exists>y. get element_ptr h = Some y);\n        obj = cast (cast y); x2b |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> False", "using assms(2) node_ptr_kinds_commutes"], ["proof (prove)\nusing this:\n  ptr |\\<notin>| object_ptr_kinds h\n  (cast ?node_ptr |\\<in>| object_ptr_kinds ?h) =\n  (?node_ptr |\\<in>| node_ptr_kinds ?h)\n\ngoal (1 subgoal):\n 1. \\<And>x2b y.\n       \\<lbrakk>the (cast x2b) |\\<notin>| element_ptr_kinds h;\n        is_element_ptr_kind x2b; ptr = cast x2b;\n        \\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n           x2b = cast element_ptr \\<or>\n           (\\<exists>y. get element_ptr h = Some y);\n        obj = cast (cast y); x2b |\\<in>| node_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> False", "by blast"], ["", "lemma type_wf_put_ptr_in_heap_E:\n  assumes \"type_wf (put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t ptr obj h)\"\n  assumes \"ptr |\\<in>| object_ptr_kinds h\"\n  assumes \"NodeClass.type_wf h\"\n  assumes \"is_element_ptr_kind ptr \\<Longrightarrow> is_element_kind (the (get ptr h))\"\n  shows \"type_wf h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ElementClass.type_wf h", "using assms"], ["proof (prove)\nusing this:\n  ElementClass.type_wf (put ptr obj h)\n  ptr |\\<in>| object_ptr_kinds h\n  NodeClass.type_wf h\n  case cast ptr of None \\<Rightarrow> False\n  | Some node_ptr \\<Rightarrow>\n      is_element_ptr_kind node_ptr \\<Longrightarrow>\n  (case cast (the (get ptr h)) of None \\<Rightarrow> None\n   | Some node \\<Rightarrow> cast node) \\<noteq>\n  None\n\ngoal (1 subgoal):\n 1. ElementClass.type_wf h", "apply(auto simp add: type_wf_defs split: option.splits if_splits)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2b y ya element_ptr.\n       \\<lbrakk>the (cast x2b) |\\<in>| element_ptr_kinds h;\n        NodeClass.type_wf h; is_element_ptr_kind x2b;\n        NodeClass.type_wf (put (cast x2b) (cast (cast y)) h);\n        \\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n           x2b = cast element_ptr \\<or>\n           (\\<exists>y. get element_ptr h = Some y);\n        cast (cast ya) = the (get (cast x2b) h); ptr = cast x2b;\n        obj = cast (cast y);\n        element_ptr |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptr h = Some y", "by (metis (no_types, lifting) NodeClass.l_get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_lemmas_axioms assms(2) bind.bind_lunit\n            cast\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e\\<^sub>2\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_inv cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_inv finite_set_in get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def\n            l_get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_lemmas.get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_type_wf option.collapse)"], ["", "subsection\\<open>Preserving Types\\<close>"], ["", "lemma new_element_type_wf_preserved [simp]: \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    ElementClass.type_wf h = ElementClass.type_wf h'", "apply(auto simp add: type_wf_defs NodeClass.type_wf_defs ObjectClass.type_wf_defs new\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def \n      new_element_def Let_def put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def \n      get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def\n      split: prod.splits if_splits elim!: bind_returns_heap_E)[1]"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>node_ptr.\n       \\<lbrakk>\\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n                   element_ptr.Ref (Suc 0) = element_ptr \\<or>\n                   (\\<exists>y.\n                       fmlookup (the_heap h)\n                        (cast (cast element_ptr)) \\<bind>\n                       (\\<lambda>y. cast y \\<bind> cast) =\n                       Some y);\n        node_ptr |\\<in>| node_ptr_kinds h; element_ptrs h = {||};\n        h' =\n        Heap\n         (fmupd (cast (cast (element_ptr.Ref (Suc 0))))\n           (cast (cast (create_element_obj [] [] fmempty None)))\n           (the_heap h));\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           cast (element_ptr.Ref (Suc 0)) = node_ptr \\<or>\n           (\\<exists>y.\n               fmlookup (the_heap h) (cast node_ptr) \\<bind> cast =\n               Some y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            fmlookup (the_heap h) (cast node_ptr) \\<bind>\n                            cast =\n                            Some y\n 2. \\<And>element_ptr.\n       \\<lbrakk>\\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n                   element_ptr.Ref (Suc 0) = element_ptr \\<or>\n                   (\\<exists>y.\n                       fmlookup (the_heap h)\n                        (cast (cast element_ptr)) \\<bind>\n                       (\\<lambda>y. cast y \\<bind> cast) =\n                       Some y);\n        element_ptr |\\<in>| element_ptr_kinds h; element_ptrs h = {||};\n        h' =\n        Heap\n         (fmupd (cast (cast (element_ptr.Ref (Suc 0))))\n           (cast (cast (create_element_obj [] [] fmempty None)))\n           (the_heap h));\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           cast (element_ptr.Ref (Suc 0)) = node_ptr \\<or>\n           (\\<exists>y.\n               fmlookup (the_heap h) (cast node_ptr) \\<bind> cast =\n               Some y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            fmlookup (the_heap h)\n                             (cast (cast element_ptr)) \\<bind>\n                            (\\<lambda>y. cast y \\<bind> cast) =\n                            Some y\n 3. \\<And>xa node_ptr.\n       \\<lbrakk>\\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n                   element_ptr.Ref\n                    (Suc (fMax (element_ptr.the_ref |`| element_ptrs h))) =\n                   element_ptr \\<or>\n                   (\\<exists>y.\n                       fmlookup (the_heap h)\n                        (cast (cast element_ptr)) \\<bind>\n                       (\\<lambda>y. cast y \\<bind> cast) =\n                       Some y);\n        node_ptr |\\<in>| node_ptr_kinds h;\n        h' =\n        Heap\n         (fmupd\n           (cast\n             (cast\n               (element_ptr.Ref\n                 (Suc (fMax (element_ptr.the_ref |`| element_ptrs h))))))\n           (cast (cast (create_element_obj [] [] fmempty None)))\n           (the_heap h));\n        xa |\\<in>| element_ptrs h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           cast\n            (element_ptr.Ref\n              (Suc (fMax (element_ptr.the_ref |`| element_ptrs h)))) =\n           node_ptr \\<or>\n           (\\<exists>y.\n               fmlookup (the_heap h) (cast node_ptr) \\<bind> cast =\n               Some y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            fmlookup (the_heap h) (cast node_ptr) \\<bind>\n                            cast =\n                            Some y\n 4. \\<And>xa element_ptr.\n       \\<lbrakk>\\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n                   element_ptr.Ref\n                    (Suc (fMax (element_ptr.the_ref |`| element_ptrs h))) =\n                   element_ptr \\<or>\n                   (\\<exists>y.\n                       fmlookup (the_heap h)\n                        (cast (cast element_ptr)) \\<bind>\n                       (\\<lambda>y. cast y \\<bind> cast) =\n                       Some y);\n        element_ptr |\\<in>| element_ptr_kinds h;\n        h' =\n        Heap\n         (fmupd\n           (cast\n             (cast\n               (element_ptr.Ref\n                 (Suc (fMax (element_ptr.the_ref |`| element_ptrs h))))))\n           (cast (cast (create_element_obj [] [] fmempty None)))\n           (the_heap h));\n        xa |\\<in>| element_ptrs h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           cast\n            (element_ptr.Ref\n              (Suc (fMax (element_ptr.the_ref |`| element_ptrs h)))) =\n           node_ptr \\<or>\n           (\\<exists>y.\n               fmlookup (the_heap h) (cast node_ptr) \\<bind> cast =\n               Some y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            fmlookup (the_heap h)\n                             (cast (cast element_ptr)) \\<bind>\n                            (\\<lambda>y. cast y \\<bind> cast) =\n                            Some y", "apply (metis element_ptr_kinds_commutes element_ptrs_def fempty_iff ffmember_filter finite_set_in\n      is_element_ptr_ref)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>element_ptr.\n       \\<lbrakk>\\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n                   element_ptr.Ref (Suc 0) = element_ptr \\<or>\n                   (\\<exists>y.\n                       fmlookup (the_heap h)\n                        (cast (cast element_ptr)) \\<bind>\n                       (\\<lambda>y. cast y \\<bind> cast) =\n                       Some y);\n        element_ptr |\\<in>| element_ptr_kinds h; element_ptrs h = {||};\n        h' =\n        Heap\n         (fmupd (cast (cast (element_ptr.Ref (Suc 0))))\n           (cast (cast (create_element_obj [] [] fmempty None)))\n           (the_heap h));\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           cast (element_ptr.Ref (Suc 0)) = node_ptr \\<or>\n           (\\<exists>y.\n               fmlookup (the_heap h) (cast node_ptr) \\<bind> cast =\n               Some y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            fmlookup (the_heap h)\n                             (cast (cast element_ptr)) \\<bind>\n                            (\\<lambda>y. cast y \\<bind> cast) =\n                            Some y\n 2. \\<And>xa node_ptr.\n       \\<lbrakk>\\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n                   element_ptr.Ref\n                    (Suc (fMax (element_ptr.the_ref |`| element_ptrs h))) =\n                   element_ptr \\<or>\n                   (\\<exists>y.\n                       fmlookup (the_heap h)\n                        (cast (cast element_ptr)) \\<bind>\n                       (\\<lambda>y. cast y \\<bind> cast) =\n                       Some y);\n        node_ptr |\\<in>| node_ptr_kinds h;\n        h' =\n        Heap\n         (fmupd\n           (cast\n             (cast\n               (element_ptr.Ref\n                 (Suc (fMax (element_ptr.the_ref |`| element_ptrs h))))))\n           (cast (cast (create_element_obj [] [] fmempty None)))\n           (the_heap h));\n        xa |\\<in>| element_ptrs h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           cast\n            (element_ptr.Ref\n              (Suc (fMax (element_ptr.the_ref |`| element_ptrs h)))) =\n           node_ptr \\<or>\n           (\\<exists>y.\n               fmlookup (the_heap h) (cast node_ptr) \\<bind> cast =\n               Some y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            fmlookup (the_heap h) (cast node_ptr) \\<bind>\n                            cast =\n                            Some y\n 3. \\<And>xa element_ptr.\n       \\<lbrakk>\\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n                   element_ptr.Ref\n                    (Suc (fMax (element_ptr.the_ref |`| element_ptrs h))) =\n                   element_ptr \\<or>\n                   (\\<exists>y.\n                       fmlookup (the_heap h)\n                        (cast (cast element_ptr)) \\<bind>\n                       (\\<lambda>y. cast y \\<bind> cast) =\n                       Some y);\n        element_ptr |\\<in>| element_ptr_kinds h;\n        h' =\n        Heap\n         (fmupd\n           (cast\n             (cast\n               (element_ptr.Ref\n                 (Suc (fMax (element_ptr.the_ref |`| element_ptrs h))))))\n           (cast (cast (create_element_obj [] [] fmempty None)))\n           (the_heap h));\n        xa |\\<in>| element_ptrs h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           cast\n            (element_ptr.Ref\n              (Suc (fMax (element_ptr.the_ref |`| element_ptrs h)))) =\n           node_ptr \\<or>\n           (\\<exists>y.\n               fmlookup (the_heap h) (cast node_ptr) \\<bind> cast =\n               Some y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            fmlookup (the_heap h)\n                             (cast (cast element_ptr)) \\<bind>\n                            (\\<lambda>y. cast y \\<bind> cast) =\n                            Some y", "apply (metis element_ptrs_def fempty_iff ffmember_filter finite_set_in is_element_ptr_ref)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa node_ptr.\n       \\<lbrakk>\\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n                   element_ptr.Ref\n                    (Suc (fMax (element_ptr.the_ref |`| element_ptrs h))) =\n                   element_ptr \\<or>\n                   (\\<exists>y.\n                       fmlookup (the_heap h)\n                        (cast (cast element_ptr)) \\<bind>\n                       (\\<lambda>y. cast y \\<bind> cast) =\n                       Some y);\n        node_ptr |\\<in>| node_ptr_kinds h;\n        h' =\n        Heap\n         (fmupd\n           (cast\n             (cast\n               (element_ptr.Ref\n                 (Suc (fMax (element_ptr.the_ref |`| element_ptrs h))))))\n           (cast (cast (create_element_obj [] [] fmempty None)))\n           (the_heap h));\n        xa |\\<in>| element_ptrs h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           cast\n            (element_ptr.Ref\n              (Suc (fMax (element_ptr.the_ref |`| element_ptrs h)))) =\n           node_ptr \\<or>\n           (\\<exists>y.\n               fmlookup (the_heap h) (cast node_ptr) \\<bind> cast =\n               Some y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            fmlookup (the_heap h) (cast node_ptr) \\<bind>\n                            cast =\n                            Some y\n 2. \\<And>xa element_ptr.\n       \\<lbrakk>\\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n                   element_ptr.Ref\n                    (Suc (fMax (element_ptr.the_ref |`| element_ptrs h))) =\n                   element_ptr \\<or>\n                   (\\<exists>y.\n                       fmlookup (the_heap h)\n                        (cast (cast element_ptr)) \\<bind>\n                       (\\<lambda>y. cast y \\<bind> cast) =\n                       Some y);\n        element_ptr |\\<in>| element_ptr_kinds h;\n        h' =\n        Heap\n         (fmupd\n           (cast\n             (cast\n               (element_ptr.Ref\n                 (Suc (fMax (element_ptr.the_ref |`| element_ptrs h))))))\n           (cast (cast (create_element_obj [] [] fmempty None)))\n           (the_heap h));\n        xa |\\<in>| element_ptrs h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           cast\n            (element_ptr.Ref\n              (Suc (fMax (element_ptr.the_ref |`| element_ptrs h)))) =\n           node_ptr \\<or>\n           (\\<exists>y.\n               fmlookup (the_heap h) (cast node_ptr) \\<bind> cast =\n               Some y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            fmlookup (the_heap h)\n                             (cast (cast element_ptr)) \\<bind>\n                            (\\<lambda>y. cast y \\<bind> cast) =\n                            Some y", "apply (metis (no_types, lifting) Suc_n_not_le_n element_ptr.sel(1) element_ptr_kinds_commutes\n                element_ptrs_def fMax_ge ffmember_filter fimage_eqI is_element_ptr_ref notin_fset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa element_ptr.\n       \\<lbrakk>\\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n                   element_ptr.Ref\n                    (Suc (fMax (element_ptr.the_ref |`| element_ptrs h))) =\n                   element_ptr \\<or>\n                   (\\<exists>y.\n                       fmlookup (the_heap h)\n                        (cast (cast element_ptr)) \\<bind>\n                       (\\<lambda>y. cast y \\<bind> cast) =\n                       Some y);\n        element_ptr |\\<in>| element_ptr_kinds h;\n        h' =\n        Heap\n         (fmupd\n           (cast\n             (cast\n               (element_ptr.Ref\n                 (Suc (fMax (element_ptr.the_ref |`| element_ptrs h))))))\n           (cast (cast (create_element_obj [] [] fmempty None)))\n           (the_heap h));\n        xa |\\<in>| element_ptrs h;\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           cast\n            (element_ptr.Ref\n              (Suc (fMax (element_ptr.the_ref |`| element_ptrs h)))) =\n           node_ptr \\<or>\n           (\\<exists>y.\n               fmlookup (the_heap h) (cast node_ptr) \\<bind> cast =\n               Some y)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            fmlookup (the_heap h)\n                             (cast (cast element_ptr)) \\<bind>\n                            (\\<lambda>y. cast y \\<bind> cast) =\n                            Some y", "apply (metis (no_types, lifting) Suc_n_not_le_n element_ptr.sel(1) element_ptrs_def\n               fMax_ge ffmember_filter fimage_eqI finite_set_in is_element_ptr_ref)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "locale l_new_element = l_type_wf +\n  assumes new_element_types_preserved: \"h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["", "lemma new_element_is_l_new_element: \"l_new_element type_wf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_new_element ElementClass.type_wf", "using l_new_element.intro new_element_type_wf_preserved"], ["proof (prove)\nusing this:\n  (\\<And>h h'.\n      h \\<turnstile> new_element \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n      ?type_wf h = ?type_wf h') \\<Longrightarrow>\n  l_new_element ?type_wf\n  ?h \\<turnstile> new_element \\<rightarrow>\\<^sub>h ?h' \\<Longrightarrow>\n  ElementClass.type_wf ?h = ElementClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. l_new_element ElementClass.type_wf", "by blast"], ["", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_tag_name_type_wf_preserved [simp]:\n  \"h \\<turnstile> put_M element_ptr tag_name_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M element_ptr tag_name_update v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    ElementClass.type_wf h = ElementClass.type_wf h'", "apply(auto simp add: type_wf_defs NodeClass.type_wf_defs ObjectClass.type_wf_defs  \n      Let_def put_M_defs get_M_defs put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def \n      get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def \n      split: prod.splits option.splits Option.bind_splits elim!: bind_returns_heap_E)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x2 node_ptr va.\n       \\<lbrakk>h' =\n                Heap\n                 (fmupd (cast (cast element_ptr))\n                   (cast (cast (x2\\<lparr>tag_name := v\\<rparr>)))\n                   (the_heap h));\n        fmlookup (the_heap h) (cast (cast element_ptr)) =\n        Some (cast (cast x2));\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           (fmlookup (the_heap h) (cast node_ptr) = None \\<longrightarrow>\n            cast element_ptr = node_ptr) \\<and>\n           (\\<forall>v.\n               fmlookup (the_heap h) (cast node_ptr) =\n               Some v \\<longrightarrow>\n               cast element_ptr \\<noteq> node_ptr \\<longrightarrow>\n               (\\<exists>y. cast y = v));\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           (fmlookup (the_heap h) (cast (cast element_ptra)) =\n            None \\<longrightarrow>\n            element_ptr = element_ptra) \\<and>\n           (\\<forall>v.\n               ((\\<forall>node. cast node \\<noteq> v) \\<longrightarrow>\n                fmlookup (the_heap h) (cast (cast element_ptra)) =\n                Some v \\<longrightarrow>\n                element_ptr = element_ptra) \\<and>\n               (\\<forall>va.\n                   cast va = v \\<longrightarrow>\n                   fmlookup (the_heap h) (cast (cast element_ptra)) =\n                   Some v \\<longrightarrow>\n                   element_ptr \\<noteq> element_ptra \\<longrightarrow>\n                   (\\<exists>y. cast y = va)));\n        node_ptr |\\<in>| node_ptr_kinds h;\n        fmlookup (the_heap h) (cast node_ptr) = Some va\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = va\n 2. \\<And>x2 element_ptra va.\n       \\<lbrakk>h' =\n                Heap\n                 (fmupd (cast (cast element_ptr))\n                   (cast (cast (x2\\<lparr>tag_name := v\\<rparr>)))\n                   (the_heap h));\n        fmlookup (the_heap h) (cast (cast element_ptr)) =\n        Some (cast (cast x2));\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           (fmlookup (the_heap h) (cast node_ptr) = None \\<longrightarrow>\n            cast element_ptr = node_ptr) \\<and>\n           (\\<forall>v.\n               fmlookup (the_heap h) (cast node_ptr) =\n               Some v \\<longrightarrow>\n               cast element_ptr \\<noteq> node_ptr \\<longrightarrow>\n               (\\<exists>y. cast y = v));\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           (fmlookup (the_heap h) (cast (cast element_ptra)) =\n            None \\<longrightarrow>\n            element_ptr = element_ptra) \\<and>\n           (\\<forall>v.\n               ((\\<forall>node. cast node \\<noteq> v) \\<longrightarrow>\n                fmlookup (the_heap h) (cast (cast element_ptra)) =\n                Some v \\<longrightarrow>\n                element_ptr = element_ptra) \\<and>\n               (\\<forall>va.\n                   cast va = v \\<longrightarrow>\n                   fmlookup (the_heap h) (cast (cast element_ptra)) =\n                   Some v \\<longrightarrow>\n                   element_ptr \\<noteq> element_ptra \\<longrightarrow>\n                   (\\<exists>y. cast y = va)));\n        element_ptra |\\<in>| element_ptr_kinds h;\n        fmlookup (the_heap h) (cast (cast element_ptra)) =\n        Some (cast va)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = va", "apply (metis finite_set_in option.inject)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 element_ptra va.\n       \\<lbrakk>h' =\n                Heap\n                 (fmupd (cast (cast element_ptr))\n                   (cast (cast (x2\\<lparr>tag_name := v\\<rparr>)))\n                   (the_heap h));\n        fmlookup (the_heap h) (cast (cast element_ptr)) =\n        Some (cast (cast x2));\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           (fmlookup (the_heap h) (cast node_ptr) = None \\<longrightarrow>\n            cast element_ptr = node_ptr) \\<and>\n           (\\<forall>v.\n               fmlookup (the_heap h) (cast node_ptr) =\n               Some v \\<longrightarrow>\n               cast element_ptr \\<noteq> node_ptr \\<longrightarrow>\n               (\\<exists>y. cast y = v));\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           (fmlookup (the_heap h) (cast (cast element_ptra)) =\n            None \\<longrightarrow>\n            element_ptr = element_ptra) \\<and>\n           (\\<forall>v.\n               ((\\<forall>node. cast node \\<noteq> v) \\<longrightarrow>\n                fmlookup (the_heap h) (cast (cast element_ptra)) =\n                Some v \\<longrightarrow>\n                element_ptr = element_ptra) \\<and>\n               (\\<forall>va.\n                   cast va = v \\<longrightarrow>\n                   fmlookup (the_heap h) (cast (cast element_ptra)) =\n                   Some v \\<longrightarrow>\n                   element_ptr \\<noteq> element_ptra \\<longrightarrow>\n                   (\\<exists>y. cast y = va)));\n        element_ptra |\\<in>| element_ptr_kinds h;\n        fmlookup (the_heap h) (cast (cast element_ptra)) =\n        Some (cast va)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = va", "apply (metis cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_inv finite_set_in option.sel)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_child_nodes_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M element_ptr child_nodes_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M element_ptr child_nodes_update v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    ElementClass.type_wf h = ElementClass.type_wf h'", "apply(auto simp add: type_wf_defs NodeClass.type_wf_defs ObjectClass.type_wf_defs  \n      Let_def put_M_defs get_M_defs put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def \n      get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def \n      split: prod.splits option.splits Option.bind_splits elim!: bind_returns_heap_E)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x2 node_ptr va.\n       \\<lbrakk>h' =\n                Heap\n                 (fmupd (cast (cast element_ptr))\n                   (cast (cast (x2\\<lparr>child_nodes := v\\<rparr>)))\n                   (the_heap h));\n        fmlookup (the_heap h) (cast (cast element_ptr)) =\n        Some (cast (cast x2));\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           (fmlookup (the_heap h) (cast node_ptr) = None \\<longrightarrow>\n            cast element_ptr = node_ptr) \\<and>\n           (\\<forall>v.\n               fmlookup (the_heap h) (cast node_ptr) =\n               Some v \\<longrightarrow>\n               cast element_ptr \\<noteq> node_ptr \\<longrightarrow>\n               (\\<exists>y. cast y = v));\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           (fmlookup (the_heap h) (cast (cast element_ptra)) =\n            None \\<longrightarrow>\n            element_ptr = element_ptra) \\<and>\n           (\\<forall>v.\n               ((\\<forall>node. cast node \\<noteq> v) \\<longrightarrow>\n                fmlookup (the_heap h) (cast (cast element_ptra)) =\n                Some v \\<longrightarrow>\n                element_ptr = element_ptra) \\<and>\n               (\\<forall>va.\n                   cast va = v \\<longrightarrow>\n                   fmlookup (the_heap h) (cast (cast element_ptra)) =\n                   Some v \\<longrightarrow>\n                   element_ptr \\<noteq> element_ptra \\<longrightarrow>\n                   (\\<exists>y. cast y = va)));\n        node_ptr |\\<in>| node_ptr_kinds h;\n        fmlookup (the_heap h) (cast node_ptr) = Some va\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = va\n 2. \\<And>x2 element_ptra va.\n       \\<lbrakk>h' =\n                Heap\n                 (fmupd (cast (cast element_ptr))\n                   (cast (cast (x2\\<lparr>child_nodes := v\\<rparr>)))\n                   (the_heap h));\n        fmlookup (the_heap h) (cast (cast element_ptr)) =\n        Some (cast (cast x2));\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           (fmlookup (the_heap h) (cast node_ptr) = None \\<longrightarrow>\n            cast element_ptr = node_ptr) \\<and>\n           (\\<forall>v.\n               fmlookup (the_heap h) (cast node_ptr) =\n               Some v \\<longrightarrow>\n               cast element_ptr \\<noteq> node_ptr \\<longrightarrow>\n               (\\<exists>y. cast y = v));\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           (fmlookup (the_heap h) (cast (cast element_ptra)) =\n            None \\<longrightarrow>\n            element_ptr = element_ptra) \\<and>\n           (\\<forall>v.\n               ((\\<forall>node. cast node \\<noteq> v) \\<longrightarrow>\n                fmlookup (the_heap h) (cast (cast element_ptra)) =\n                Some v \\<longrightarrow>\n                element_ptr = element_ptra) \\<and>\n               (\\<forall>va.\n                   cast va = v \\<longrightarrow>\n                   fmlookup (the_heap h) (cast (cast element_ptra)) =\n                   Some v \\<longrightarrow>\n                   element_ptr \\<noteq> element_ptra \\<longrightarrow>\n                   (\\<exists>y. cast y = va)));\n        element_ptra |\\<in>| element_ptr_kinds h;\n        fmlookup (the_heap h) (cast (cast element_ptra)) =\n        Some (cast va)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = va", "apply (metis finite_set_in option.inject)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 element_ptra va.\n       \\<lbrakk>h' =\n                Heap\n                 (fmupd (cast (cast element_ptr))\n                   (cast (cast (x2\\<lparr>child_nodes := v\\<rparr>)))\n                   (the_heap h));\n        fmlookup (the_heap h) (cast (cast element_ptr)) =\n        Some (cast (cast x2));\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           (fmlookup (the_heap h) (cast node_ptr) = None \\<longrightarrow>\n            cast element_ptr = node_ptr) \\<and>\n           (\\<forall>v.\n               fmlookup (the_heap h) (cast node_ptr) =\n               Some v \\<longrightarrow>\n               cast element_ptr \\<noteq> node_ptr \\<longrightarrow>\n               (\\<exists>y. cast y = v));\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           (fmlookup (the_heap h) (cast (cast element_ptra)) =\n            None \\<longrightarrow>\n            element_ptr = element_ptra) \\<and>\n           (\\<forall>v.\n               ((\\<forall>node. cast node \\<noteq> v) \\<longrightarrow>\n                fmlookup (the_heap h) (cast (cast element_ptra)) =\n                Some v \\<longrightarrow>\n                element_ptr = element_ptra) \\<and>\n               (\\<forall>va.\n                   cast va = v \\<longrightarrow>\n                   fmlookup (the_heap h) (cast (cast element_ptra)) =\n                   Some v \\<longrightarrow>\n                   element_ptr \\<noteq> element_ptra \\<longrightarrow>\n                   (\\<exists>y. cast y = va)));\n        element_ptra |\\<in>| element_ptr_kinds h;\n        fmlookup (the_heap h) (cast (cast element_ptra)) =\n        Some (cast va)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = va", "apply (metis cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_inv finite_set_in option.sel)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_attrs_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M element_ptr attrs_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M element_ptr attrs_update v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    ElementClass.type_wf h = ElementClass.type_wf h'", "apply(auto simp add: type_wf_defs NodeClass.type_wf_defs ObjectClass.type_wf_defs  Let_def \n      put_M_defs get_M_defs put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def \n      get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def \n      split: prod.splits option.splits Option.bind_splits elim!: bind_returns_heap_E)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x2 node_ptr va.\n       \\<lbrakk>h' =\n                Heap\n                 (fmupd (cast (cast element_ptr))\n                   (cast (cast (x2\\<lparr>attrs := v\\<rparr>)))\n                   (the_heap h));\n        fmlookup (the_heap h) (cast (cast element_ptr)) =\n        Some (cast (cast x2));\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           (fmlookup (the_heap h) (cast node_ptr) = None \\<longrightarrow>\n            cast element_ptr = node_ptr) \\<and>\n           (\\<forall>v.\n               fmlookup (the_heap h) (cast node_ptr) =\n               Some v \\<longrightarrow>\n               cast element_ptr \\<noteq> node_ptr \\<longrightarrow>\n               (\\<exists>y. cast y = v));\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           (fmlookup (the_heap h) (cast (cast element_ptra)) =\n            None \\<longrightarrow>\n            element_ptr = element_ptra) \\<and>\n           (\\<forall>v.\n               ((\\<forall>node. cast node \\<noteq> v) \\<longrightarrow>\n                fmlookup (the_heap h) (cast (cast element_ptra)) =\n                Some v \\<longrightarrow>\n                element_ptr = element_ptra) \\<and>\n               (\\<forall>va.\n                   cast va = v \\<longrightarrow>\n                   fmlookup (the_heap h) (cast (cast element_ptra)) =\n                   Some v \\<longrightarrow>\n                   element_ptr \\<noteq> element_ptra \\<longrightarrow>\n                   (\\<exists>y. cast y = va)));\n        node_ptr |\\<in>| node_ptr_kinds h;\n        fmlookup (the_heap h) (cast node_ptr) = Some va\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = va\n 2. \\<And>x2 element_ptra va.\n       \\<lbrakk>h' =\n                Heap\n                 (fmupd (cast (cast element_ptr))\n                   (cast (cast (x2\\<lparr>attrs := v\\<rparr>)))\n                   (the_heap h));\n        fmlookup (the_heap h) (cast (cast element_ptr)) =\n        Some (cast (cast x2));\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           (fmlookup (the_heap h) (cast node_ptr) = None \\<longrightarrow>\n            cast element_ptr = node_ptr) \\<and>\n           (\\<forall>v.\n               fmlookup (the_heap h) (cast node_ptr) =\n               Some v \\<longrightarrow>\n               cast element_ptr \\<noteq> node_ptr \\<longrightarrow>\n               (\\<exists>y. cast y = v));\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           (fmlookup (the_heap h) (cast (cast element_ptra)) =\n            None \\<longrightarrow>\n            element_ptr = element_ptra) \\<and>\n           (\\<forall>v.\n               ((\\<forall>node. cast node \\<noteq> v) \\<longrightarrow>\n                fmlookup (the_heap h) (cast (cast element_ptra)) =\n                Some v \\<longrightarrow>\n                element_ptr = element_ptra) \\<and>\n               (\\<forall>va.\n                   cast va = v \\<longrightarrow>\n                   fmlookup (the_heap h) (cast (cast element_ptra)) =\n                   Some v \\<longrightarrow>\n                   element_ptr \\<noteq> element_ptra \\<longrightarrow>\n                   (\\<exists>y. cast y = va)));\n        element_ptra |\\<in>| element_ptr_kinds h;\n        fmlookup (the_heap h) (cast (cast element_ptra)) =\n        Some (cast va)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = va", "apply (metis finite_set_in option.inject)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 element_ptra va.\n       \\<lbrakk>h' =\n                Heap\n                 (fmupd (cast (cast element_ptr))\n                   (cast (cast (x2\\<lparr>attrs := v\\<rparr>)))\n                   (the_heap h));\n        fmlookup (the_heap h) (cast (cast element_ptr)) =\n        Some (cast (cast x2));\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           (fmlookup (the_heap h) (cast node_ptr) = None \\<longrightarrow>\n            cast element_ptr = node_ptr) \\<and>\n           (\\<forall>v.\n               fmlookup (the_heap h) (cast node_ptr) =\n               Some v \\<longrightarrow>\n               cast element_ptr \\<noteq> node_ptr \\<longrightarrow>\n               (\\<exists>y. cast y = v));\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           (fmlookup (the_heap h) (cast (cast element_ptra)) =\n            None \\<longrightarrow>\n            element_ptr = element_ptra) \\<and>\n           (\\<forall>v.\n               ((\\<forall>node. cast node \\<noteq> v) \\<longrightarrow>\n                fmlookup (the_heap h) (cast (cast element_ptra)) =\n                Some v \\<longrightarrow>\n                element_ptr = element_ptra) \\<and>\n               (\\<forall>va.\n                   cast va = v \\<longrightarrow>\n                   fmlookup (the_heap h) (cast (cast element_ptra)) =\n                   Some v \\<longrightarrow>\n                   element_ptr \\<noteq> element_ptra \\<longrightarrow>\n                   (\\<exists>y. cast y = va)));\n        element_ptra |\\<in>| element_ptr_kinds h;\n        fmlookup (the_heap h) (cast (cast element_ptra)) =\n        Some (cast va)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = va", "apply (metis cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_inv finite_set_in option.sel)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_shadow_root_opt_type_wf_preserved [simp]: \n  \"h \\<turnstile> put_M element_ptr shadow_root_opt_update v \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<turnstile> put_M element_ptr shadow_root_opt_update v\n    \\<rightarrow>\\<^sub>h h' \\<Longrightarrow>\n    ElementClass.type_wf h = ElementClass.type_wf h'", "apply(auto simp add: type_wf_defs NodeClass.type_wf_defs ObjectClass.type_wf_defs  \n      Let_def put_M_defs get_M_defs put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def \n      get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def \n      split: prod.splits option.splits Option.bind_splits elim!: bind_returns_heap_E)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x2 node_ptr va.\n       \\<lbrakk>h' =\n                Heap\n                 (fmupd (cast (cast element_ptr))\n                   (cast (cast (x2\\<lparr>shadow_root_opt := v\\<rparr>)))\n                   (the_heap h));\n        fmlookup (the_heap h) (cast (cast element_ptr)) =\n        Some (cast (cast x2));\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           (fmlookup (the_heap h) (cast node_ptr) = None \\<longrightarrow>\n            cast element_ptr = node_ptr) \\<and>\n           (\\<forall>v.\n               fmlookup (the_heap h) (cast node_ptr) =\n               Some v \\<longrightarrow>\n               cast element_ptr \\<noteq> node_ptr \\<longrightarrow>\n               (\\<exists>y. cast y = v));\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           (fmlookup (the_heap h) (cast (cast element_ptra)) =\n            None \\<longrightarrow>\n            element_ptr = element_ptra) \\<and>\n           (\\<forall>v.\n               ((\\<forall>node. cast node \\<noteq> v) \\<longrightarrow>\n                fmlookup (the_heap h) (cast (cast element_ptra)) =\n                Some v \\<longrightarrow>\n                element_ptr = element_ptra) \\<and>\n               (\\<forall>va.\n                   cast va = v \\<longrightarrow>\n                   fmlookup (the_heap h) (cast (cast element_ptra)) =\n                   Some v \\<longrightarrow>\n                   element_ptr \\<noteq> element_ptra \\<longrightarrow>\n                   (\\<exists>y. cast y = va)));\n        node_ptr |\\<in>| node_ptr_kinds h;\n        fmlookup (the_heap h) (cast node_ptr) = Some va\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = va\n 2. \\<And>x2 element_ptra va.\n       \\<lbrakk>h' =\n                Heap\n                 (fmupd (cast (cast element_ptr))\n                   (cast (cast (x2\\<lparr>shadow_root_opt := v\\<rparr>)))\n                   (the_heap h));\n        fmlookup (the_heap h) (cast (cast element_ptr)) =\n        Some (cast (cast x2));\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           (fmlookup (the_heap h) (cast node_ptr) = None \\<longrightarrow>\n            cast element_ptr = node_ptr) \\<and>\n           (\\<forall>v.\n               fmlookup (the_heap h) (cast node_ptr) =\n               Some v \\<longrightarrow>\n               cast element_ptr \\<noteq> node_ptr \\<longrightarrow>\n               (\\<exists>y. cast y = v));\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           (fmlookup (the_heap h) (cast (cast element_ptra)) =\n            None \\<longrightarrow>\n            element_ptr = element_ptra) \\<and>\n           (\\<forall>v.\n               ((\\<forall>node. cast node \\<noteq> v) \\<longrightarrow>\n                fmlookup (the_heap h) (cast (cast element_ptra)) =\n                Some v \\<longrightarrow>\n                element_ptr = element_ptra) \\<and>\n               (\\<forall>va.\n                   cast va = v \\<longrightarrow>\n                   fmlookup (the_heap h) (cast (cast element_ptra)) =\n                   Some v \\<longrightarrow>\n                   element_ptr \\<noteq> element_ptra \\<longrightarrow>\n                   (\\<exists>y. cast y = va)));\n        element_ptra |\\<in>| element_ptr_kinds h;\n        fmlookup (the_heap h) (cast (cast element_ptra)) =\n        Some (cast va)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = va", "apply (metis finite_set_in option.inject)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2 element_ptra va.\n       \\<lbrakk>h' =\n                Heap\n                 (fmupd (cast (cast element_ptr))\n                   (cast (cast (x2\\<lparr>shadow_root_opt := v\\<rparr>)))\n                   (the_heap h));\n        fmlookup (the_heap h) (cast (cast element_ptr)) =\n        Some (cast (cast x2));\n        \\<forall>node_ptr\\<in>fset (node_ptr_kinds h).\n           (fmlookup (the_heap h) (cast node_ptr) = None \\<longrightarrow>\n            cast element_ptr = node_ptr) \\<and>\n           (\\<forall>v.\n               fmlookup (the_heap h) (cast node_ptr) =\n               Some v \\<longrightarrow>\n               cast element_ptr \\<noteq> node_ptr \\<longrightarrow>\n               (\\<exists>y. cast y = v));\n        \\<forall>element_ptra\\<in>fset (element_ptr_kinds h).\n           (fmlookup (the_heap h) (cast (cast element_ptra)) =\n            None \\<longrightarrow>\n            element_ptr = element_ptra) \\<and>\n           (\\<forall>v.\n               ((\\<forall>node. cast node \\<noteq> v) \\<longrightarrow>\n                fmlookup (the_heap h) (cast (cast element_ptra)) =\n                Some v \\<longrightarrow>\n                element_ptr = element_ptra) \\<and>\n               (\\<forall>va.\n                   cast va = v \\<longrightarrow>\n                   fmlookup (the_heap h) (cast (cast element_ptra)) =\n                   Some v \\<longrightarrow>\n                   element_ptr \\<noteq> element_ptra \\<longrightarrow>\n                   (\\<exists>y. cast y = va)));\n        element_ptra |\\<in>| element_ptr_kinds h;\n        fmlookup (the_heap h) (cast (cast element_ptra)) =\n        Some (cast va)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. cast y = va", "apply (metis cast\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\\<^sub>2\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_inv finite_set_in option.sel)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma put_M_pointers_preserved:\n  assumes \"h \\<turnstile> put_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr setter v \\<rightarrow>\\<^sub>h h'\"\n  shows \"object_ptr_kinds h = object_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "using assms"], ["proof (prove)\nusing this:\n  h \\<turnstile> put_M element_ptr setter v \\<rightarrow>\\<^sub>h h'\n\ngoal (1 subgoal):\n 1. object_ptr_kinds h = object_ptr_kinds h'", "apply(auto simp add: put_M_defs put\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def put\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def put\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def \n      elim!: bind_returns_heap_E2 dest!: get_heap_E)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>h \\<turnstile> get_M element_ptr id \\<rightarrow>\\<^sub>r x;\n        h' =\n        Heap\n         (fmupd (cast (cast element_ptr))\n           (cast (cast (setter (\\<lambda>_. v) x))) (the_heap h))\\<rbrakk>\n       \\<Longrightarrow> element_ptr |\\<in>| element_ptr_kinds h", "by (meson get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_ptr_in_heap is_OK_returns_result_I)"], ["", "lemma element_ptr_kinds_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h'. \\<forall>w \\<in> SW. h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n                    \\<longrightarrow> (\\<forall>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h')\"\n  shows \"element_ptr_kinds h = element_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. element_ptr_kinds h = element_ptr_kinds h'", "using writes_small_big[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>reflp\n            (\\<lambda>h h'.\n                \\<forall>w\\<in>SW.\n                   ?h4 h h' \\<turnstile> w\n                   \\<rightarrow>\\<^sub>h ?h'5 h h' \\<longrightarrow>\n                   (\\<forall>object_ptr.\n                       preserved (get_M object_ptr RObject.nothing)\n                        (?h4 h h') (?h'5 h h')));\n   transp\n    (\\<lambda>h h'.\n        \\<forall>w\\<in>SW.\n           ?h4 h h' \\<turnstile> w\n           \\<rightarrow>\\<^sub>h ?h'5 h h' \\<longrightarrow>\n           (\\<forall>object_ptr.\n               preserved (get_M object_ptr RObject.nothing) (?h4 h h')\n                (?h'5 h h')))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>w\\<in>SW.\n                       ?h4 h h' \\<turnstile> w\n                       \\<rightarrow>\\<^sub>h ?h'5 h h' \\<longrightarrow>\n                       (\\<forall>object_ptr.\n                           preserved (get_M object_ptr RObject.nothing)\n                            (?h4 h h') (?h'5 h h'))\n\ngoal (1 subgoal):\n 1. element_ptr_kinds h = element_ptr_kinds h'", "apply(simp add: reflp_def transp_def preserved_def element_ptr_kinds_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ha h'a.\n        \\<lbrakk>\\<forall>x.\n                    (\\<exists>w\\<in>SW.\n                        ha x x \\<turnstile> w\n                        \\<rightarrow>\\<^sub>h h'a x x) \\<longrightarrow>\n                    (\\<forall>object_ptr.\n                        ha x x \\<turnstile> get_M object_ptr RObject.nothing\n                        \\<rightarrow>\\<^sub>r () =\n                        h'a x x\n                        \\<turnstile> get_M object_ptr RObject.nothing\n                        \\<rightarrow>\\<^sub>r ());\n         \\<forall>x y.\n            ((\\<exists>w\\<in>SW.\n                 ha x y \\<turnstile> w\n                 \\<rightarrow>\\<^sub>h h'a x y) \\<longrightarrow>\n             (\\<forall>object_ptr.\n                 ha x y \\<turnstile> get_M object_ptr RObject.nothing\n                 \\<rightarrow>\\<^sub>r () =\n                 h'a x y \\<turnstile> get_M object_ptr RObject.nothing\n                 \\<rightarrow>\\<^sub>r ())) \\<longrightarrow>\n            (\\<forall>z.\n                ((\\<exists>w\\<in>SW.\n                     ha y z \\<turnstile> w\n                     \\<rightarrow>\\<^sub>h h'a y z) \\<longrightarrow>\n                 (\\<forall>object_ptr.\n                     ha y z \\<turnstile> get_M object_ptr RObject.nothing\n                     \\<rightarrow>\\<^sub>r () =\n                     h'a y z \\<turnstile> get_M object_ptr RObject.nothing\n                     \\<rightarrow>\\<^sub>r ())) \\<longrightarrow>\n                (\\<exists>w\\<in>SW.\n                    ha x z \\<turnstile> w\n                    \\<rightarrow>\\<^sub>h h'a x z) \\<longrightarrow>\n                (\\<forall>object_ptr.\n                    ha x z \\<turnstile> get_M object_ptr RObject.nothing\n                    \\<rightarrow>\\<^sub>r () =\n                    h'a x z \\<turnstile> get_M object_ptr RObject.nothing\n                    \\<rightarrow>\\<^sub>r ()))\\<rbrakk>\n        \\<Longrightarrow> (\\<exists>w\\<in>SW.\n                              ha h h' \\<turnstile> w\n                              \\<rightarrow>\\<^sub>h h'a h\n               h') \\<longrightarrow>\n                          (\\<forall>object_ptr.\n                              ha h h'\n                              \\<turnstile> get_M object_ptr RObject.nothing\n                              \\<rightarrow>\\<^sub>r () =\n                              h'a h h'\n                              \\<turnstile> get_M object_ptr RObject.nothing\n                              \\<rightarrow>\\<^sub>r ())) \\<Longrightarrow>\n    (the \\<circ> cast) |`| ffilter is_element_ptr_kind (node_ptr_kinds h) =\n    (the \\<circ> cast) |`| ffilter is_element_ptr_kind (node_ptr_kinds h')", "by (metis assms node_ptr_kinds_preserved)"], ["", "lemma element_ptr_kinds_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  shows \"element_ptr_kinds h = element_ptr_kinds h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. element_ptr_kinds h = element_ptr_kinds h'", "by(simp add: element_ptr_kinds_def node_ptr_kinds_def preserved_def \n      object_ptr_kinds_preserved_small[OF assms])"], ["", "lemma type_wf_preserved_small:\n  assumes \"\\<And>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  assumes \"\\<And>node_ptr. preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr RNode.nothing) h h'\"\n  assumes \"\\<And>element_ptr. preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr RElement.nothing) h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ElementClass.type_wf h = ElementClass.type_wf h'", "using type_wf_preserved_small[OF assms(1) assms(2)] allI[OF assms(3), of id, simplified]"], ["proof (prove)\nusing this:\n  NodeClass.type_wf h = NodeClass.type_wf h'\n  \\<forall>x. preserved (get_M x RElement.nothing) h h'\n\ngoal (1 subgoal):\n 1. ElementClass.type_wf h = ElementClass.type_wf h'", "apply(auto simp add: type_wf_defs )[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>element_ptr.\n       \\<lbrakk>\\<forall>x. preserved (get_M x RElement.nothing) h h';\n        NodeClass.type_wf h; NodeClass.type_wf h';\n        \\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n           \\<exists>y. get element_ptr h = Some y;\n        element_ptr |\\<in>| element_ptr_kinds h'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptr h' = Some y\n 2. \\<And>element_ptr.\n       \\<lbrakk>\\<forall>x. preserved (get_M x RElement.nothing) h h';\n        NodeClass.type_wf h; NodeClass.type_wf h';\n        \\<forall>element_ptr\\<in>fset (element_ptr_kinds h').\n           \\<exists>y. get element_ptr h' = Some y;\n        element_ptr |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptr h = Some y", "apply(auto simp add: preserved_def get_M_defs element_ptr_kinds_small[OF assms(1)] \n      split: option.splits,force)[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>element_ptr.\n       \\<lbrakk>\\<forall>x. preserved (get_M x RElement.nothing) h h';\n        NodeClass.type_wf h; NodeClass.type_wf h';\n        \\<forall>element_ptr\\<in>fset (element_ptr_kinds h').\n           \\<exists>y. get element_ptr h' = Some y;\n        element_ptr |\\<in>| element_ptr_kinds h\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. get element_ptr h = Some y", "by(auto simp add: preserved_def get_M_defs element_ptr_kinds_small[OF assms(1)] \n      split: option.splits,force)"], ["", "lemma type_wf_preserved:\n  assumes \"writes SW setter h h'\"\n  assumes \"h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n           \\<Longrightarrow> \\<forall>object_ptr. preserved (get_M\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t object_ptr RObject.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n           \\<Longrightarrow> \\<forall>node_ptr. preserved (get_M\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e node_ptr RNode.nothing) h h'\"\n  assumes \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \n           \\<Longrightarrow> \\<forall>element_ptr. preserved (get_M\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t element_ptr RElement.nothing) h h'\"\n  shows \"type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ElementClass.type_wf h = ElementClass.type_wf h'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ElementClass.type_wf h = ElementClass.type_wf h'", "have \"\\<And>h h' w. w \\<in> SW \\<Longrightarrow> h \\<turnstile> w \\<rightarrow>\\<^sub>h h' \\<Longrightarrow> type_wf h = type_wf h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> ElementClass.type_wf h = ElementClass.type_wf h'", "using assms type_wf_preserved_small"], ["proof (prove)\nusing this:\n  writes SW setter h h'\n  h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>object_ptr.\n                       preserved (get_M object_ptr RObject.nothing) ?h ?h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>node_ptr.\n                       preserved (get_M node_ptr RNode.nothing) ?h ?h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> \\<forall>element_ptr.\n                       preserved (get_M element_ptr RElement.nothing) ?h ?h'\n  \\<lbrakk>\\<And>object_ptr.\n              preserved (get_M object_ptr RObject.nothing) ?h ?h';\n   \\<And>node_ptr. preserved (get_M node_ptr RNode.nothing) ?h ?h';\n   \\<And>element_ptr.\n      preserved (get_M element_ptr RElement.nothing) ?h ?h'\\<rbrakk>\n  \\<Longrightarrow> ElementClass.type_wf ?h = ElementClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> ElementClass.type_wf h = ElementClass.type_wf h'", "by fast"], ["proof (state)\nthis:\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> ElementClass.type_wf ?h = ElementClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. ElementClass.type_wf h = ElementClass.type_wf h'", "with assms(1) assms(2)"], ["proof (chain)\npicking this:\n  writes SW setter h h'\n  h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> ElementClass.type_wf ?h = ElementClass.type_wf ?h'", "show ?thesis"], ["proof (prove)\nusing this:\n  writes SW setter h h'\n  h \\<turnstile> setter \\<rightarrow>\\<^sub>h h'\n  \\<lbrakk>?w \\<in> SW;\n   ?h \\<turnstile> ?w \\<rightarrow>\\<^sub>h ?h'\\<rbrakk>\n  \\<Longrightarrow> ElementClass.type_wf ?h = ElementClass.type_wf ?h'\n\ngoal (1 subgoal):\n 1. ElementClass.type_wf h = ElementClass.type_wf h'", "apply(rule writes_small_big)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> ?w1 h h' w \\<in> SW\n 2. \\<And>h h' w.\n       \\<lbrakk>w \\<in> SW;\n        h \\<turnstile> w \\<rightarrow>\\<^sub>h h'\\<rbrakk>\n       \\<Longrightarrow> h \\<turnstile> ?w1 h h' w \\<rightarrow>\\<^sub>h h'\n 3. reflp (\\<lambda>h h'. ElementClass.type_wf h = ElementClass.type_wf h')\n 4. transp (\\<lambda>h h'. ElementClass.type_wf h = ElementClass.type_wf h')", "by(auto simp add: reflp_def transp_def)"], ["proof (state)\nthis:\n  ElementClass.type_wf h = ElementClass.type_wf h'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma type_wf_drop: \"type_wf h \\<Longrightarrow> type_wf (Heap (fmdrop ptr (the_heap h)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ElementClass.type_wf h \\<Longrightarrow>\n    ElementClass.type_wf (Heap (fmdrop ptr (the_heap h)))", "apply(auto simp add: type_wf_defs NodeClass.type_wf_defs ObjectClass.type_wf_defs \n      node_ptr_kinds_def object_ptr_kinds_def is_node_ptr_kind_def \n      get\\<^sub>E\\<^sub>l\\<^sub>e\\<^sub>m\\<^sub>e\\<^sub>n\\<^sub>t_def get\\<^sub>N\\<^sub>o\\<^sub>d\\<^sub>e_def get\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>element_ptr.\n       \\<lbrakk>element_ptr |\\<in>|\n                element_ptr_kinds (Heap (fmdrop ptr (the_heap h)));\n        \\<forall>node_ptr\n                 \\<in>Collect is_node_ptr_kind \\<inter>\n                      fset (fmdom (the_heap h)).\n           \\<exists>y. fmlookup (the_heap h) node_ptr \\<bind> cast = Some y;\n        \\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              fmlookup (the_heap h) (cast (cast element_ptr)) \\<bind>\n              (\\<lambda>y. cast y \\<bind> cast) =\n              Some y;\n        cast (cast element_ptr) \\<noteq> ptr\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            fmlookup (the_heap h)\n                             (cast (cast element_ptr)) \\<bind>\n                            (\\<lambda>y. cast y \\<bind> cast) =\n                            Some y\n 2. \\<And>element_ptr.\n       \\<lbrakk>element_ptr |\\<in>|\n                element_ptr_kinds\n                 (Heap (fmdrop (cast (cast element_ptr)) (the_heap h)));\n        \\<forall>node_ptr\n                 \\<in>Collect is_node_ptr_kind \\<inter>\n                      fset (fmdom (the_heap h)).\n           \\<exists>y. fmlookup (the_heap h) node_ptr \\<bind> cast = Some y;\n        \\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              fmlookup (the_heap h) (cast (cast element_ptr)) \\<bind>\n              (\\<lambda>y. cast y \\<bind> cast) =\n              Some y;\n        ptr = cast (cast element_ptr)\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis (no_types, lifting) element_ptr_kinds_commutes finite_set_in fmdom_notD fmdom_notI\n                fmlookup_drop heap.sel node_ptr_kinds_commutes o_apply object_ptr_kinds_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>element_ptr.\n       \\<lbrakk>element_ptr |\\<in>|\n                element_ptr_kinds\n                 (Heap (fmdrop (cast (cast element_ptr)) (the_heap h)));\n        \\<forall>node_ptr\n                 \\<in>Collect is_node_ptr_kind \\<inter>\n                      fset (fmdom (the_heap h)).\n           \\<exists>y. fmlookup (the_heap h) node_ptr \\<bind> cast = Some y;\n        \\<forall>element_ptr\\<in>fset (element_ptr_kinds h).\n           \\<exists>y.\n              fmlookup (the_heap h) (cast (cast element_ptr)) \\<bind>\n              (\\<lambda>y. cast y \\<bind> cast) =\n              Some y;\n        ptr = cast (cast element_ptr)\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis element_ptr_kinds_commutes fmdom_notI fmdrop_lookup heap.sel node_ptr_kinds_commutes\n            o_apply object_ptr_kinds_def)"], ["", "end"]]}