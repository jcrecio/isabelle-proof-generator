{"file_name": "/home/qj213/afp-2021-10-22/thys/Minkowskis_Theorem/Minkowskis_Theorem.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Minkowskis_Theorem", "problem_names": ["lemma bij_betw_UN:\n  assumes \"bij_betw f A B\"\n  shows   \"(\\<Union>n\\<in>A. g (f n)) = (\\<Union>n\\<in>B. g n)\"", "lemma of_int_vec_nth [simp]: \"of_int_vec v $ n = of_int (v $ n)\"", "lemma of_int_vec_eq_iff [simp]:\n  \"(of_int_vec a :: ('a :: ring_char_0) ^ 'n) = of_int_vec b \\<longleftrightarrow> a = b\"", "lemma inj_axis:\n  assumes \"c \\<noteq> 0\"\n  shows   \"inj (\\<lambda>k. axis k c :: ('a :: {zero}) ^ 'n)\"", "lemma compactD:\n  assumes \"compact (A :: 'a :: metric_space set)\" \"range f \\<subseteq> A\"\n  shows   \"\\<exists>h l. strict_mono (h::nat\\<Rightarrow>nat) \\<and> (f \\<circ> h) \\<longlonglongrightarrow> l\"", "lemma closed_lattice:\n  fixes A :: \"(real ^ 'n) set\"\n  assumes \"\\<And>v i. v \\<in> A \\<Longrightarrow> v $ i \\<in> \\<int>\"\n  shows   \"closed A\"", "lemma emeasure_lborel_cbox_eq':\n  \"emeasure lborel (cbox a b) = ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))\"", "lemma emeasure_lborel_cbox_cart_eq:\n  fixes a b :: \"real ^ ('n :: finite)\"\n  shows \"emeasure lborel (cbox a b) = ennreal (\\<Prod>i \\<in> UNIV. max 0 ((b - a) $ i))\"", "lemma sum_emeasure':\n  assumes [simp]: \"finite A\"\n  assumes [measurable]: \"\\<And>x. x \\<in> A \\<Longrightarrow> B x \\<in> sets M\"\n  assumes \"\\<And>x y. x \\<in> A \\<Longrightarrow> y \\<in> A \\<Longrightarrow> x \\<noteq> y \\<Longrightarrow> emeasure M (B x \\<inter> B y) = 0\"\n  shows   \"(\\<Sum>x\\<in>A. emeasure M (B x)) = emeasure M (\\<Union>x\\<in>A. B x)\"", "lemma sums_emeasure':\n  assumes [measurable]: \"\\<And>x. B x \\<in> sets M\"\n  assumes \"\\<And>x y. x \\<noteq> y \\<Longrightarrow> emeasure M (B x \\<inter> B y) = 0\"\n  shows   \"(\\<lambda>x. emeasure M (B x)) sums emeasure M (\\<Union>x. B x)\"", "theorem minkowski:\n  fixes B :: \"(real ^ 'n) set\"\n  assumes \"convex B\" and symmetric: \"uminus ` B \\<subseteq> B\"\n  assumes meas_B [measurable]: \"B \\<in> sets lebesgue\"\n  assumes measure_B: \"emeasure lebesgue B > 2 ^ CARD('n)\"\n  obtains x where \"x \\<in> B\" and \"x \\<noteq> 0\" and \"\\<And>i. x $ i \\<in> \\<int>\"", "theorem minkowski_compact:\n  fixes B :: \"(real ^ 'n) set\"\n  assumes \"convex B\" and \"compact B\" and symmetric: \"uminus ` B \\<subseteq> B\"\n  assumes measure_B: \"emeasure lebesgue B \\<ge> 2 ^ CARD('n)\"\n  obtains x where \"x \\<in> B\" and \"x \\<noteq> 0\" and \"\\<And>i. x $ i \\<in> \\<int>\""], "translations": [["", "lemma bij_betw_UN:\n  assumes \"bij_betw f A B\"\n  shows   \"(\\<Union>n\\<in>A. g (f n)) = (\\<Union>n\\<in>B. g n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>n\\<in>A. g (f n)) = \\<Union> (g ` B)", "using assms"], ["proof (prove)\nusing this:\n  bij_betw f A B\n\ngoal (1 subgoal):\n 1. (\\<Union>n\\<in>A. g (f n)) = \\<Union> (g ` B)", "by (auto simp: bij_betw_def)"], ["", "definition of_int_vec where\n  \"of_int_vec v = (\\<chi> i. of_int (v $ i))\""], ["", "lemma of_int_vec_nth [simp]: \"of_int_vec v $ n = of_int (v $ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_vec v $ n = of_int (v $ n)", "by (simp add: of_int_vec_def)"], ["", "lemma of_int_vec_eq_iff [simp]:\n  \"(of_int_vec a :: ('a :: ring_char_0) ^ 'n) = of_int_vec b \\<longleftrightarrow> a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_int_vec a = of_int_vec b) = (a = b)", "by (simp add: of_int_vec_def vec_eq_iff)"], ["", "lemma inj_axis:\n  assumes \"c \\<noteq> 0\"\n  shows   \"inj (\\<lambda>k. axis k c :: ('a :: {zero}) ^ 'n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>k. axis k c)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV; axis x c = axis y c\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y :: 'n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV; axis x c = axis y c\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume *: \"axis x c = axis y c\""], ["proof (state)\nthis:\n  axis x c = axis y c\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV; axis x c = axis y c\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"axis x c $ x = axis x c $ y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. axis x c $ x = axis x c $ y", "by (subst *) simp"], ["proof (state)\nthis:\n  axis x c $ x = axis x c $ y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV; axis x c = axis y c\\<rbrakk>\n       \\<Longrightarrow> x = y", "thus \"x = y\""], ["proof (prove)\nusing this:\n  axis x c $ x = axis x c $ y\n\ngoal (1 subgoal):\n 1. x = y", "using assms"], ["proof (prove)\nusing this:\n  axis x c $ x = axis x c $ y\n  c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. x = y", "by (auto simp: axis_def split: if_splits)"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compactD:\n  assumes \"compact (A :: 'a :: metric_space set)\" \"range f \\<subseteq> A\"\n  shows   \"\\<exists>h l. strict_mono (h::nat\\<Rightarrow>nat) \\<and> (f \\<circ> h) \\<longlonglongrightarrow> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h l.\n       strict_mono h \\<and> (f \\<circ> h) \\<longlonglongrightarrow> l", "using assms"], ["proof (prove)\nusing this:\n  compact A\n  range f \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<exists>h l.\n       strict_mono h \\<and> (f \\<circ> h) \\<longlonglongrightarrow> l", "unfolding compact_def"], ["proof (prove)\nusing this:\n  \\<forall>f.\n     (\\<forall>n. f n \\<in> A) \\<longrightarrow>\n     (\\<exists>l\\<in>A.\n         \\<exists>r.\n            strict_mono r \\<and> (f \\<circ> r) \\<longlonglongrightarrow> l)\n  range f \\<subseteq> A\n\ngoal (1 subgoal):\n 1. \\<exists>h l.\n       strict_mono h \\<and> (f \\<circ> h) \\<longlonglongrightarrow> l", "by blast"], ["", "lemma closed_lattice:\n  fixes A :: \"(real ^ 'n) set\"\n  assumes \"\\<And>v i. v \\<in> A \\<Longrightarrow> v $ i \\<in> \\<int>\"\n  shows   \"closed A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed A", "proof (rule discrete_imp_closed[OF zero_less_one], safe, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; dist y x < 1\\<rbrakk>\n       \\<Longrightarrow> y = x", "case (1 x y)"], ["proof (state)\nthis:\n  x \\<in> A\n  y \\<in> A\n  dist y x < 1\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; dist y x < 1\\<rbrakk>\n       \\<Longrightarrow> y = x", "have \"x $ i = y $ i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. x $ i = y $ i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x $ i = y $ i", "from 1 and assms"], ["proof (chain)\npicking this:\n  x \\<in> A\n  y \\<in> A\n  dist y x < 1\n  ?v \\<in> A \\<Longrightarrow> ?v $ ?i \\<in> \\<int>", "have \"x $ i - y $ i \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  x \\<in> A\n  y \\<in> A\n  dist y x < 1\n  ?v \\<in> A \\<Longrightarrow> ?v $ ?i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. x $ i - y $ i \\<in> \\<int>", "by auto"], ["proof (state)\nthis:\n  x $ i - y $ i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. x $ i = y $ i", "then"], ["proof (chain)\npicking this:\n  x $ i - y $ i \\<in> \\<int>", "obtain m where m: \"of_int m = (x $ i - y $ i)\""], ["proof (prove)\nusing this:\n  x $ i - y $ i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        real_of_int m = x $ i - y $ i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (elim Ints_cases) auto"], ["proof (state)\nthis:\n  real_of_int m = x $ i - y $ i\n\ngoal (1 subgoal):\n 1. x $ i = y $ i", "hence \"of_int (abs m) = abs ((x - y) $ i)\""], ["proof (prove)\nusing this:\n  real_of_int m = x $ i - y $ i\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>m\\<bar> = \\<bar>(x - y) $ i\\<bar>", "by simp"], ["proof (state)\nthis:\n  real_of_int \\<bar>m\\<bar> = \\<bar>(x - y) $ i\\<bar>\n\ngoal (1 subgoal):\n 1. x $ i = y $ i", "also"], ["proof (state)\nthis:\n  real_of_int \\<bar>m\\<bar> = \\<bar>(x - y) $ i\\<bar>\n\ngoal (1 subgoal):\n 1. x $ i = y $ i", "have \"\\<dots> \\<le> norm (x - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>(x - y) $ i\\<bar> \\<le> norm (x - y)", "by (rule component_le_norm_cart)"], ["proof (state)\nthis:\n  \\<bar>(x - y) $ i\\<bar> \\<le> norm (x - y)\n\ngoal (1 subgoal):\n 1. x $ i = y $ i", "also"], ["proof (state)\nthis:\n  \\<bar>(x - y) $ i\\<bar> \\<le> norm (x - y)\n\ngoal (1 subgoal):\n 1. x $ i = y $ i", "have \"\\<dots> < of_int 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. norm (x - y) < real_of_int 1", "using 1"], ["proof (prove)\nusing this:\n  x \\<in> A\n  y \\<in> A\n  dist y x < 1\n\ngoal (1 subgoal):\n 1. norm (x - y) < real_of_int 1", "by (simp add: dist_norm norm_minus_commute)"], ["proof (state)\nthis:\n  norm (x - y) < real_of_int 1\n\ngoal (1 subgoal):\n 1. x $ i = y $ i", "finally"], ["proof (chain)\npicking this:\n  real_of_int \\<bar>m\\<bar> < real_of_int 1", "have \"abs m < 1\""], ["proof (prove)\nusing this:\n  real_of_int \\<bar>m\\<bar> < real_of_int 1\n\ngoal (1 subgoal):\n 1. \\<bar>m\\<bar> < 1", "by (subst (asm) of_int_less_iff)"], ["proof (state)\nthis:\n  \\<bar>m\\<bar> < 1\n\ngoal (1 subgoal):\n 1. x $ i = y $ i", "thus \"x $ i = y $ i\""], ["proof (prove)\nusing this:\n  \\<bar>m\\<bar> < 1\n\ngoal (1 subgoal):\n 1. x $ i = y $ i", "using m"], ["proof (prove)\nusing this:\n  \\<bar>m\\<bar> < 1\n  real_of_int m = x $ i - y $ i\n\ngoal (1 subgoal):\n 1. x $ i = y $ i", "by simp"], ["proof (state)\nthis:\n  x $ i = y $ i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x $ ?i = y $ ?i\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> A; y \\<in> A; dist y x < 1\\<rbrakk>\n       \\<Longrightarrow> y = x", "thus \"y = x\""], ["proof (prove)\nusing this:\n  x $ ?i = y $ ?i\n\ngoal (1 subgoal):\n 1. y = x", "by (simp add: vec_eq_iff)"], ["proof (state)\nthis:\n  y = x\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Auxiliary theorems about measure theory\\<close>"], ["", "lemma emeasure_lborel_cbox_eq':\n  \"emeasure lborel (cbox a b) = ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))", "proof (cases \"\\<forall>ba\\<in>Basis. a \\<bullet> ba \\<le> b \\<bullet> ba\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>ba\\<in>Basis.\n       a \\<bullet> ba \\<le> b \\<bullet> ba \\<Longrightarrow>\n    emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))\n 2. \\<not> (\\<forall>ba\\<in>Basis.\n               a \\<bullet> ba \\<le> b \\<bullet> ba) \\<Longrightarrow>\n    emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))", "case True"], ["proof (state)\nthis:\n  \\<forall>ba\\<in>Basis. a \\<bullet> ba \\<le> b \\<bullet> ba\n\ngoal (2 subgoals):\n 1. \\<forall>ba\\<in>Basis.\n       a \\<bullet> ba \\<le> b \\<bullet> ba \\<Longrightarrow>\n    emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))\n 2. \\<not> (\\<forall>ba\\<in>Basis.\n               a \\<bullet> ba \\<le> b \\<bullet> ba) \\<Longrightarrow>\n    emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))", "hence \"emeasure lborel (cbox a b) = ennreal (prod ((\\<bullet>) (b - a)) Basis)\""], ["proof (prove)\nusing this:\n  \\<forall>ba\\<in>Basis. a \\<bullet> ba \\<le> b \\<bullet> ba\n\ngoal (1 subgoal):\n 1. emeasure lborel (cbox a b) = ennreal (prod ((\\<bullet>) (b - a)) Basis)", "unfolding emeasure_lborel_cbox_eq"], ["proof (prove)\nusing this:\n  \\<forall>ba\\<in>Basis. a \\<bullet> ba \\<le> b \\<bullet> ba\n\ngoal (1 subgoal):\n 1. ennreal\n     (if \\<forall>ba\\<in>Basis. a \\<bullet> ba \\<le> b \\<bullet> ba\n      then prod ((\\<bullet>) (b - a)) Basis else 0) =\n    ennreal (prod ((\\<bullet>) (b - a)) Basis)", "by auto"], ["proof (state)\nthis:\n  emeasure lborel (cbox a b) = ennreal (prod ((\\<bullet>) (b - a)) Basis)\n\ngoal (2 subgoals):\n 1. \\<forall>ba\\<in>Basis.\n       a \\<bullet> ba \\<le> b \\<bullet> ba \\<Longrightarrow>\n    emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))\n 2. \\<not> (\\<forall>ba\\<in>Basis.\n               a \\<bullet> ba \\<le> b \\<bullet> ba) \\<Longrightarrow>\n    emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))", "also"], ["proof (state)\nthis:\n  emeasure lborel (cbox a b) = ennreal (prod ((\\<bullet>) (b - a)) Basis)\n\ngoal (2 subgoals):\n 1. \\<forall>ba\\<in>Basis.\n       a \\<bullet> ba \\<le> b \\<bullet> ba \\<Longrightarrow>\n    emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))\n 2. \\<not> (\\<forall>ba\\<in>Basis.\n               a \\<bullet> ba \\<le> b \\<bullet> ba) \\<Longrightarrow>\n    emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))", "have \"prod ((\\<bullet>) (b - a)) Basis = (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod ((\\<bullet>) (b - a)) Basis =\n    (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))", "using True"], ["proof (prove)\nusing this:\n  \\<forall>ba\\<in>Basis. a \\<bullet> ba \\<le> b \\<bullet> ba\n\ngoal (1 subgoal):\n 1. prod ((\\<bullet>) (b - a)) Basis =\n    (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))", "by (intro prod.cong refl) (auto simp: max_def inner_simps)"], ["proof (state)\nthis:\n  prod ((\\<bullet>) (b - a)) Basis =\n  (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))\n\ngoal (2 subgoals):\n 1. \\<forall>ba\\<in>Basis.\n       a \\<bullet> ba \\<le> b \\<bullet> ba \\<Longrightarrow>\n    emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))\n 2. \\<not> (\\<forall>ba\\<in>Basis.\n               a \\<bullet> ba \\<le> b \\<bullet> ba) \\<Longrightarrow>\n    emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))", "finally"], ["proof (chain)\npicking this:\n  emeasure lborel (cbox a b) =\n  ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure lborel (cbox a b) =\n  ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))\n\ngoal (1 subgoal):\n 1. emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))", "."], ["proof (state)\nthis:\n  emeasure lborel (cbox a b) =\n  ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ba\\<in>Basis.\n               a \\<bullet> ba \\<le> b \\<bullet> ba) \\<Longrightarrow>\n    emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ba\\<in>Basis.\n               a \\<bullet> ba \\<le> b \\<bullet> ba) \\<Longrightarrow>\n    emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>ba\\<in>Basis. a \\<bullet> ba \\<le> b \\<bullet> ba)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ba\\<in>Basis.\n               a \\<bullet> ba \\<le> b \\<bullet> ba) \\<Longrightarrow>\n    emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))", "hence \"emeasure lborel (cbox a b) = ennreal 0\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>ba\\<in>Basis. a \\<bullet> ba \\<le> b \\<bullet> ba)\n\ngoal (1 subgoal):\n 1. emeasure lborel (cbox a b) = ennreal 0", "by (auto simp: emeasure_lborel_cbox_eq)"], ["proof (state)\nthis:\n  emeasure lborel (cbox a b) = ennreal 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ba\\<in>Basis.\n               a \\<bullet> ba \\<le> b \\<bullet> ba) \\<Longrightarrow>\n    emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))", "also"], ["proof (state)\nthis:\n  emeasure lborel (cbox a b) = ennreal 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ba\\<in>Basis.\n               a \\<bullet> ba \\<le> b \\<bullet> ba) \\<Longrightarrow>\n    emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))", "from False"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>ba\\<in>Basis. a \\<bullet> ba \\<le> b \\<bullet> ba)", "have \"0 = (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>ba\\<in>Basis. a \\<bullet> ba \\<le> b \\<bullet> ba)\n\ngoal (1 subgoal):\n 1. 0 = (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))", "by (auto simp: max_def inner_simps)"], ["proof (state)\nthis:\n  0 = (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>ba\\<in>Basis.\n               a \\<bullet> ba \\<le> b \\<bullet> ba) \\<Longrightarrow>\n    emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))", "finally"], ["proof (chain)\npicking this:\n  emeasure lborel (cbox a b) =\n  ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure lborel (cbox a b) =\n  ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))\n\ngoal (1 subgoal):\n 1. emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))", "."], ["proof (state)\nthis:\n  emeasure lborel (cbox a b) =\n  ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma emeasure_lborel_cbox_cart_eq:\n  fixes a b :: \"real ^ ('n :: finite)\"\n  shows \"emeasure lborel (cbox a b) = ennreal (\\<Prod>i \\<in> UNIV. max 0 ((b - a) $ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>i\\<in>UNIV. max 0 ((b - a) $ i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>i\\<in>UNIV. max 0 ((b - a) $ i))", "have \"emeasure lborel (cbox a b) = ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))", "unfolding emeasure_lborel_cbox_eq'"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e)) =\n    ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))", ".."], ["proof (state)\nthis:\n  emeasure lborel (cbox a b) =\n  ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))\n\ngoal (1 subgoal):\n 1. emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>i\\<in>UNIV. max 0 ((b - a) $ i))", "also"], ["proof (state)\nthis:\n  emeasure lborel (cbox a b) =\n  ennreal (\\<Prod>e\\<in>Basis. max 0 ((b - a) \\<bullet> e))\n\ngoal (1 subgoal):\n 1. emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>i\\<in>UNIV. max 0 ((b - a) $ i))", "have \"(Basis :: (real ^ 'n) set) = range (\\<lambda>k. axis k 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Basis = range (\\<lambda>k. axis k 1)", "unfolding Basis_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>i. \\<Union>u\\<in>Basis. {axis i u}) =\n    range (\\<lambda>k. axis k 1)", "by auto"], ["proof (state)\nthis:\n  Basis = range (\\<lambda>k. axis k 1)\n\ngoal (1 subgoal):\n 1. emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>i\\<in>UNIV. max 0 ((b - a) $ i))", "also"], ["proof (state)\nthis:\n  Basis = range (\\<lambda>k. axis k 1)\n\ngoal (1 subgoal):\n 1. emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>i\\<in>UNIV. max 0 ((b - a) $ i))", "have \"(\\<Prod>e\\<in>\\<dots>. max 0 ((b - a) \\<bullet> e)) = (\\<Prod> i \\<in> UNIV . max 0 ((b - a) $ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>e\\<in>range (\\<lambda>k. axis k 1).\n       max 0 ((b - a) \\<bullet> e)) =\n    (\\<Prod>i\\<in>UNIV. max 0 ((b - a) $ i))", "by (subst prod.reindex) (auto intro!: inj_axis simp: algebra_simps inner_axis)"], ["proof (state)\nthis:\n  (\\<Prod>e\\<in>range (\\<lambda>k. axis k 1). max 0 ((b - a) \\<bullet> e)) =\n  (\\<Prod>i\\<in>UNIV. max 0 ((b - a) $ i))\n\ngoal (1 subgoal):\n 1. emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>i\\<in>UNIV. max 0 ((b - a) $ i))", "finally"], ["proof (chain)\npicking this:\n  emeasure lborel (cbox a b) =\n  ennreal (\\<Prod>i\\<in>UNIV. max 0 ((b - a) $ i))", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure lborel (cbox a b) =\n  ennreal (\\<Prod>i\\<in>UNIV. max 0 ((b - a) $ i))\n\ngoal (1 subgoal):\n 1. emeasure lborel (cbox a b) =\n    ennreal (\\<Prod>i\\<in>UNIV. max 0 ((b - a) $ i))", "."], ["proof (state)\nthis:\n  emeasure lborel (cbox a b) =\n  ennreal (\\<Prod>i\\<in>UNIV. max 0 ((b - a) $ i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_emeasure':\n  assumes [simp]: \"finite A\"\n  assumes [measurable]: \"\\<And>x. x \\<in> A \\<Longrightarrow> B x \\<in> sets M\"\n  assumes \"\\<And>x y. x \\<in> A \\<Longrightarrow> y \\<in> A \\<Longrightarrow> x \\<noteq> y \\<Longrightarrow> emeasure M (B x \\<inter> B y) = 0\"\n  shows   \"(\\<Sum>x\\<in>A. emeasure M (B x)) = emeasure M (\\<Union>x\\<in>A. B x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. emeasure M (B x)) = emeasure M (\\<Union> (B ` A))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. emeasure M (B x)) = emeasure M (\\<Union> (B ` A))", "define C where \"C = (\\<Union>x\\<in>A. \\<Union>y\\<in>(A-{x}). B x \\<inter> B y)\""], ["proof (state)\nthis:\n  C = (\\<Union>x\\<in>A. \\<Union>y\\<in>A - {x}. B x \\<inter> B y)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. emeasure M (B x)) = emeasure M (\\<Union> (B ` A))", "have C: \"C \\<in> null_sets M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> null_sets M", "unfolding C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>A. \\<Union>y\\<in>A - {x}. B x \\<inter> B y)\n    \\<in> null_sets M", "using assms"], ["proof (prove)\nusing this:\n  finite A\n  ?x \\<in> A \\<Longrightarrow> B ?x \\<in> sets M\n  \\<lbrakk>?x \\<in> A; ?y \\<in> A; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> emeasure M (B ?x \\<inter> B ?y) = 0\n\ngoal (1 subgoal):\n 1. (\\<Union>x\\<in>A. \\<Union>y\\<in>A - {x}. B x \\<inter> B y)\n    \\<in> null_sets M", "by (intro null_sets.finite_UN) (auto simp: null_sets_def)"], ["proof (state)\nthis:\n  C \\<in> null_sets M\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. emeasure M (B x)) = emeasure M (\\<Union> (B ` A))", "hence [measurable]: \"C \\<in> sets M\" and [simp]: \"emeasure M C = 0\""], ["proof (prove)\nusing this:\n  C \\<in> null_sets M\n\ngoal (1 subgoal):\n 1. C \\<in> sets M &&& emeasure M C = 0", "by (simp_all add: null_sets_def)"], ["proof (state)\nthis:\n  C \\<in> sets M\n  emeasure M C = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. emeasure M (B x)) = emeasure M (\\<Union> (B ` A))", "have \"(\\<Union>x\\<in>A. B x) = (\\<Union>x\\<in>A. B x - C) \\<union> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (B ` A) = (\\<Union>x\\<in>A. B x - C) \\<union> C", "by (auto simp: C_def)"], ["proof (state)\nthis:\n  \\<Union> (B ` A) = (\\<Union>x\\<in>A. B x - C) \\<union> C\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. emeasure M (B x)) = emeasure M (\\<Union> (B ` A))", "also"], ["proof (state)\nthis:\n  \\<Union> (B ` A) = (\\<Union>x\\<in>A. B x - C) \\<union> C\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. emeasure M (B x)) = emeasure M (\\<Union> (B ` A))", "have \"emeasure M \\<dots> = emeasure M (\\<Union>x\\<in>A. B x - C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure M ((\\<Union>x\\<in>A. B x - C) \\<union> C) =\n    emeasure M (\\<Union>x\\<in>A. B x - C)", "by (subst emeasure_Un_null_set) (auto intro!: sets.Un sets.Diff)"], ["proof (state)\nthis:\n  emeasure M ((\\<Union>x\\<in>A. B x - C) \\<union> C) =\n  emeasure M (\\<Union>x\\<in>A. B x - C)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. emeasure M (B x)) = emeasure M (\\<Union> (B ` A))", "also"], ["proof (state)\nthis:\n  emeasure M ((\\<Union>x\\<in>A. B x - C) \\<union> C) =\n  emeasure M (\\<Union>x\\<in>A. B x - C)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. emeasure M (B x)) = emeasure M (\\<Union> (B ` A))", "from assms"], ["proof (chain)\npicking this:\n  finite A\n  ?x \\<in> A \\<Longrightarrow> B ?x \\<in> sets M\n  \\<lbrakk>?x \\<in> A; ?y \\<in> A; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> emeasure M (B ?x \\<inter> B ?y) = 0", "have \"\\<dots> = (\\<Sum>x\\<in>A. emeasure M (B x - C))\""], ["proof (prove)\nusing this:\n  finite A\n  ?x \\<in> A \\<Longrightarrow> B ?x \\<in> sets M\n  \\<lbrakk>?x \\<in> A; ?y \\<in> A; ?x \\<noteq> ?y\\<rbrakk>\n  \\<Longrightarrow> emeasure M (B ?x \\<inter> B ?y) = 0\n\ngoal (1 subgoal):\n 1. emeasure M (\\<Union>x\\<in>A. B x - C) =\n    (\\<Sum>x\\<in>A. emeasure M (B x - C))", "by (subst sum_emeasure)\n       (auto simp: disjoint_family_on_def C_def intro!: sets.Diff sets.finite_UN)"], ["proof (state)\nthis:\n  emeasure M (\\<Union>x\\<in>A. B x - C) =\n  (\\<Sum>x\\<in>A. emeasure M (B x - C))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. emeasure M (B x)) = emeasure M (\\<Union> (B ` A))", "also"], ["proof (state)\nthis:\n  emeasure M (\\<Union>x\\<in>A. B x - C) =\n  (\\<Sum>x\\<in>A. emeasure M (B x - C))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. emeasure M (B x)) = emeasure M (\\<Union> (B ` A))", "have \"\\<dots> = (\\<Sum>x\\<in>A. emeasure M (B x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. emeasure M (B x - C)) =\n    (\\<Sum>x\\<in>A. emeasure M (B x))", "by (intro sum.cong refl emeasure_Diff_null_set) auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>A. emeasure M (B x - C)) = (\\<Sum>x\\<in>A. emeasure M (B x))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. emeasure M (B x)) = emeasure M (\\<Union> (B ` A))", "finally"], ["proof (chain)\npicking this:\n  emeasure M (\\<Union> (B ` A)) = (\\<Sum>x\\<in>A. emeasure M (B x))", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure M (\\<Union> (B ` A)) = (\\<Sum>x\\<in>A. emeasure M (B x))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>A. emeasure M (B x)) = emeasure M (\\<Union> (B ` A))", ".."], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>A. emeasure M (B x)) = emeasure M (\\<Union> (B ` A))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sums_emeasure':\n  assumes [measurable]: \"\\<And>x. B x \\<in> sets M\"\n  assumes \"\\<And>x y. x \\<noteq> y \\<Longrightarrow> emeasure M (B x \\<inter> B y) = 0\"\n  shows   \"(\\<lambda>x. emeasure M (B x)) sums emeasure M (\\<Union>x. B x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. emeasure M (B x)) sums emeasure M (\\<Union> (range B))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x. emeasure M (B x)) sums emeasure M (\\<Union> (range B))", "define C where \"C = (\\<Union>x. \\<Union>y\\<in>-{x}. B x \\<inter> B y)\""], ["proof (state)\nthis:\n  C = (\\<Union>x. \\<Union>y\\<in>- {x}. B x \\<inter> B y)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. emeasure M (B x)) sums emeasure M (\\<Union> (range B))", "have C: \"C \\<in> null_sets M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C \\<in> null_sets M", "unfolding C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>x. \\<Union>y\\<in>- {x}. B x \\<inter> B y) \\<in> null_sets M", "using assms"], ["proof (prove)\nusing this:\n  B ?x \\<in> sets M\n  ?x \\<noteq> ?y \\<Longrightarrow> emeasure M (B ?x \\<inter> B ?y) = 0\n\ngoal (1 subgoal):\n 1. (\\<Union>x. \\<Union>y\\<in>- {x}. B x \\<inter> B y) \\<in> null_sets M", "by (intro null_sets_UN') (auto simp: null_sets_def)"], ["proof (state)\nthis:\n  C \\<in> null_sets M\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. emeasure M (B x)) sums emeasure M (\\<Union> (range B))", "hence [measurable]: \"C \\<in> sets M\" and [simp]: \"emeasure M C = 0\""], ["proof (prove)\nusing this:\n  C \\<in> null_sets M\n\ngoal (1 subgoal):\n 1. C \\<in> sets M &&& emeasure M C = 0", "by (simp_all add: null_sets_def)"], ["proof (state)\nthis:\n  C \\<in> sets M\n  emeasure M C = 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. emeasure M (B x)) sums emeasure M (\\<Union> (range B))", "have \"(\\<Union>x. B x) = (\\<Union>x. B x - C) \\<union> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (range B) = (\\<Union>x. B x - C) \\<union> C", "by (auto simp: C_def)"], ["proof (state)\nthis:\n  \\<Union> (range B) = (\\<Union>x. B x - C) \\<union> C\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. emeasure M (B x)) sums emeasure M (\\<Union> (range B))", "also"], ["proof (state)\nthis:\n  \\<Union> (range B) = (\\<Union>x. B x - C) \\<union> C\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. emeasure M (B x)) sums emeasure M (\\<Union> (range B))", "have \"emeasure M \\<dots> = emeasure M (\\<Union>x. B x - C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure M ((\\<Union>x. B x - C) \\<union> C) =\n    emeasure M (\\<Union>x. B x - C)", "by (subst emeasure_Un_null_set) (auto intro!: sets.Un sets.Diff)"], ["proof (state)\nthis:\n  emeasure M ((\\<Union>x. B x - C) \\<union> C) =\n  emeasure M (\\<Union>x. B x - C)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. emeasure M (B x)) sums emeasure M (\\<Union> (range B))", "also"], ["proof (state)\nthis:\n  emeasure M ((\\<Union>x. B x - C) \\<union> C) =\n  emeasure M (\\<Union>x. B x - C)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. emeasure M (B x)) sums emeasure M (\\<Union> (range B))", "from assms"], ["proof (chain)\npicking this:\n  B ?x \\<in> sets M\n  ?x \\<noteq> ?y \\<Longrightarrow> emeasure M (B ?x \\<inter> B ?y) = 0", "have \"(\\<lambda>x. emeasure M (B x - C)) sums \\<dots>  \""], ["proof (prove)\nusing this:\n  B ?x \\<in> sets M\n  ?x \\<noteq> ?y \\<Longrightarrow> emeasure M (B ?x \\<inter> B ?y) = 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. emeasure M (B x - C)) sums emeasure M (\\<Union>x. B x - C)", "by (intro sums_emeasure)\n       (auto simp: disjoint_family_on_def C_def intro!: sets.Diff sets.finite_UN)"], ["proof (state)\nthis:\n  (\\<lambda>x. emeasure M (B x - C)) sums emeasure M (\\<Union>x. B x - C)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. emeasure M (B x)) sums emeasure M (\\<Union> (range B))", "also"], ["proof (state)\nthis:\n  (\\<lambda>x. emeasure M (B x - C)) sums emeasure M (\\<Union>x. B x - C)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. emeasure M (B x)) sums emeasure M (\\<Union> (range B))", "have \"(\\<lambda>x. emeasure M (B x - C)) = (\\<lambda>x. emeasure M (B x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. emeasure M (B x - C)) = (\\<lambda>x. emeasure M (B x))", "by (intro ext emeasure_Diff_null_set) auto"], ["proof (state)\nthis:\n  (\\<lambda>x. emeasure M (B x - C)) = (\\<lambda>x. emeasure M (B x))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. emeasure M (B x)) sums emeasure M (\\<Union> (range B))", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>x. emeasure M (B x)) sums emeasure M (\\<Union> (range B))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>x. emeasure M (B x)) sums emeasure M (\\<Union> (range B))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. emeasure M (B x)) sums emeasure M (\\<Union> (range B))", "."], ["proof (state)\nthis:\n  (\\<lambda>x. emeasure M (B x)) sums emeasure M (\\<Union> (range B))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Blichfeldt's theorem\\<close>"], ["", "text \\<open>\n  Blichfeldt's theorem states that, given a subset of $\\mathbb{R}^n$ with $n > 0$ and a\n  volume of more than 1, there exist two different points in that set whose difference\n  vector has integer components.\n\n  This will be the key ingredient in proving Minkowski's theorem.\n\n  Note that in the HOL Light version, it is additionally required -- both for\n  Blichfeldt's theorem and for Minkowski's theorem -- that the set is bounded,\n  which we do not need.\n\\<close>"], ["", "proposition blichfeldt:\n  fixes S :: \"(real ^ 'n) set\"\n  assumes [measurable]: \"S \\<in> sets lebesgue\"\n  assumes \"emeasure lebesgue S > 1\"\n  obtains x y where \"x \\<noteq> y\" and \"x \\<in> S\" and \"y \\<in> S\" and \"\\<And>i. (x - y) $ i \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -\n  \\<comment> \\<open>We define for each lattice point in $\\mathbb{Z}^n$ the corresponding cell in $\\mathbb{R}^n$.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define R :: \"int ^ 'n \\<Rightarrow> (real ^ 'n) set\"\n    where \"R = (\\<lambda>a. cbox (of_int_vec a) (of_int_vec (a + 1)))\"\n\n  \\<comment> \\<open>For each lattice point, we can intersect the cell it defines with our set @{term S}\n      to obtain a partitioning of @{term S}.\\<close>"], ["proof (state)\nthis:\n  R = (\\<lambda>a. cbox (of_int_vec a) (of_int_vec (a + 1)))\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define T :: \"int ^ 'n \\<Rightarrow> (real ^ 'n) set\"\n    where \"T = (\\<lambda>a. S \\<inter> R a)\"\n\n  \\<comment> \\<open>We can then translate each such partition into the cell at the origin, i.\\,e. the\n      unit box @{term \"R 0\"}.\\<close>"], ["proof (state)\nthis:\n  T = (\\<lambda>a. S \\<inter> R a)\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define T' :: \"int ^ 'n \\<Rightarrow> (real ^ 'n) set\"\n    where \"T' = (\\<lambda>a. (\\<lambda>x. x - of_int_vec a) ` T a)\""], ["proof (state)\nthis:\n  T' = (\\<lambda>a. (\\<lambda>x. x - of_int_vec a) ` T a)\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have T'_altdef: \"T' a = (\\<lambda>x. x + of_int_vec a) -` T a\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. T' a = (\\<lambda>x. x + of_int_vec a) -` T a", "unfolding T'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x - of_int_vec a) ` T a =\n    (\\<lambda>x. x + of_int_vec a) -` T a", "by force\n\n  \\<comment> \\<open>We need to show measurability of all the defined sets.\\<close>"], ["proof (state)\nthis:\n  T' ?a = (\\<lambda>x. x + of_int_vec ?a) -` T ?a\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have [measurable, simp]: \"R a \\<in> sets lebesgue\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. R a \\<in> sets lebesgue", "unfolding R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cbox (of_int_vec a) (of_int_vec (a + 1)) \\<in> sets lebesgue", "by simp"], ["proof (state)\nthis:\n  R ?a \\<in> sets lebesgue\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have [measurable, simp]: \"T a \\<in> sets lebesgue\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. T a \\<in> sets lebesgue", "unfolding T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<inter> R a \\<in> sets lebesgue", "by auto"], ["proof (state)\nthis:\n  T ?a \\<in> sets lebesgue\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"(\\<lambda>x::real^'n. x + of_int_vec a) \\<in> lebesgue \\<rightarrow>\\<^sub>M lebesgue\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x + of_int_vec a)\n    \\<in> lebesgue \\<rightarrow>\\<^sub>M lebesgue", "using lebesgue_affine_measurable[of \"\\<lambda>_. 1\" \"of_int_vec a\"]"], ["proof (prove)\nusing this:\n  (\\<And>j. j \\<in> Basis \\<Longrightarrow> 1 \\<noteq> 0) \\<Longrightarrow>\n  (\\<lambda>x.\n      of_int_vec a + (\\<Sum>j\\<in>Basis. (1 * (x \\<bullet> j)) *\\<^sub>R j))\n  \\<in> lebesgue \\<rightarrow>\\<^sub>M lebesgue\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. x + of_int_vec a)\n    \\<in> lebesgue \\<rightarrow>\\<^sub>M lebesgue", "by (auto simp: euclidean_representation add_ac)"], ["proof (state)\nthis:\n  (\\<lambda>x. x + of_int_vec ?a)\n  \\<in> lebesgue \\<rightarrow>\\<^sub>M lebesgue\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from measurable_sets[OF this, of \"T a\" a for a]"], ["proof (chain)\npicking this:\n  T ?a2 \\<in> sets lebesgue \\<Longrightarrow>\n  (\\<lambda>x. x + of_int_vec ?a2) -` T ?a2 \\<inter> space lebesgue\n  \\<in> sets lebesgue", "have [measurable, simp]: \"T' a \\<in> sets lebesgue\" for a"], ["proof (prove)\nusing this:\n  T ?a2 \\<in> sets lebesgue \\<Longrightarrow>\n  (\\<lambda>x. x + of_int_vec ?a2) -` T ?a2 \\<inter> space lebesgue\n  \\<in> sets lebesgue\n\ngoal (1 subgoal):\n 1. T' a \\<in> sets lebesgue", "unfolding T'_altdef"], ["proof (prove)\nusing this:\n  T ?a2 \\<in> sets lebesgue \\<Longrightarrow>\n  (\\<lambda>x. x + of_int_vec ?a2) -` T ?a2 \\<inter> space lebesgue\n  \\<in> sets lebesgue\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. x + of_int_vec a) -` T a \\<in> sets lebesgue", "by simp\n\n  \\<comment> \\<open>Obviously, the original set @{term S} is the union of all the lattice\n      point cell partitions.\\<close>"], ["proof (state)\nthis:\n  T' ?a \\<in> sets lebesgue\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have S_decompose: \"S = (\\<Union>a. T a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = \\<Union> (range T)", "unfolding T_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S = (\\<Union>a. S \\<inter> R a)", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> (\\<Union>a. S \\<inter> R a)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> (\\<Union>a. S \\<inter> R a)", "assume x: \"x \\<in> S\""], ["proof (state)\nthis:\n  x \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> (\\<Union>a. S \\<inter> R a)", "define a where \"a = (\\<chi> i. \\<lfloor>x $ i\\<rfloor>)\""], ["proof (state)\nthis:\n  a = (\\<chi>i. \\<lfloor>x $ i\\<rfloor>)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> (\\<Union>a. S \\<inter> R a)", "have \"x \\<in> R a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> R a", "unfolding R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> cbox (of_int_vec a) (of_int_vec (a + 1))", "by (auto simp: cbox_interval less_eq_vec_def of_int_vec_def a_def)"], ["proof (state)\nthis:\n  x \\<in> R a\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S \\<Longrightarrow> x \\<in> (\\<Union>a. S \\<inter> R a)", "with x"], ["proof (chain)\npicking this:\n  x \\<in> S\n  x \\<in> R a", "show \"x \\<in> (\\<Union>a. S \\<inter> R a)\""], ["proof (prove)\nusing this:\n  x \\<in> S\n  x \\<in> R a\n\ngoal (1 subgoal):\n 1. x \\<in> (\\<Union>a. S \\<inter> R a)", "by auto"], ["proof (state)\nthis:\n  x \\<in> (\\<Union>a. S \\<inter> R a)\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>Translating the partitioned subsets does not change their volume.\\<close>"], ["proof (state)\nthis:\n  S = \\<Union> (range T)\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have emeasure_T': \"emeasure lebesgue (T' a) = emeasure lebesgue (T a)\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure lebesgue (T' a) = emeasure lebesgue (T a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure lebesgue (T' a) = emeasure lebesgue (T a)", "have \"T' a = (\\<lambda>x. 1 *\\<^sub>R x + (- of_int_vec a)) ` T a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T' a = (\\<lambda>x. 1 *\\<^sub>R x + - of_int_vec a) ` T a", "by (simp add: T'_def)"], ["proof (state)\nthis:\n  T' a = (\\<lambda>x. 1 *\\<^sub>R x + - of_int_vec a) ` T a\n\ngoal (1 subgoal):\n 1. emeasure lebesgue (T' a) = emeasure lebesgue (T a)", "also"], ["proof (state)\nthis:\n  T' a = (\\<lambda>x. 1 *\\<^sub>R x + - of_int_vec a) ` T a\n\ngoal (1 subgoal):\n 1. emeasure lebesgue (T' a) = emeasure lebesgue (T a)", "have \"emeasure lebesgue \\<dots> = emeasure lebesgue (T a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure lebesgue ((\\<lambda>x. 1 *\\<^sub>R x + - of_int_vec a) ` T a) =\n    emeasure lebesgue (T a)", "by (subst emeasure_lebesgue_affine) auto"], ["proof (state)\nthis:\n  emeasure lebesgue ((\\<lambda>x. 1 *\\<^sub>R x + - of_int_vec a) ` T a) =\n  emeasure lebesgue (T a)\n\ngoal (1 subgoal):\n 1. emeasure lebesgue (T' a) = emeasure lebesgue (T a)", "finally"], ["proof (chain)\npicking this:\n  emeasure lebesgue (T' a) = emeasure lebesgue (T a)", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure lebesgue (T' a) = emeasure lebesgue (T a)\n\ngoal (1 subgoal):\n 1. emeasure lebesgue (T' a) = emeasure lebesgue (T a)", "by simp"], ["proof (state)\nthis:\n  emeasure lebesgue (T' a) = emeasure lebesgue (T a)\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>Each translated partition of @{term S} is a subset of the unit cell at the origin.\\<close>"], ["proof (state)\nthis:\n  emeasure lebesgue (T' ?a) = emeasure lebesgue (T ?a)\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have T'_subset: \"T' a \\<subseteq> cbox 0 1\" for a"], ["proof (prove)\ngoal (1 subgoal):\n 1. T' a \\<subseteq> cbox 0 1", "unfolding T'_def T_def R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x - of_int_vec a) `\n    (S \\<inter> cbox (of_int_vec a) (of_int_vec (a + 1)))\n    \\<subseteq> cbox 0 1", "by (auto simp: algebra_simps cbox_interval of_int_vec_def less_eq_vec_def)\n\n  \\<comment> \\<open>It is clear that the intersection of two different lattice point cells is a null set.\\<close>"], ["proof (state)\nthis:\n  T' ?a \\<subseteq> cbox 0 1\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have R_Int: \"R a \\<inter> R b \\<in> null_sets lebesgue\" if \"a \\<noteq> b\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. R a \\<inter> R b \\<in> null_sets lebesgue", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. R a \\<inter> R b \\<in> null_sets lebesgue", "from that"], ["proof (chain)\npicking this:\n  a \\<noteq> b", "obtain i where i: \"a $ i \\<noteq> b $ i\""], ["proof (prove)\nusing this:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        a $ i \\<noteq> b $ i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: vec_eq_iff)"], ["proof (state)\nthis:\n  a $ i \\<noteq> b $ i\n\ngoal (1 subgoal):\n 1. R a \\<inter> R b \\<in> null_sets lebesgue", "have \"R a \\<inter> R b = cbox (\\<chi> i. max (a $ i) (b $ i)) (\\<chi> i. min (a $ i + 1) (b $ i + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R a \\<inter> R b =\n    cbox (\\<chi>x. real_of_int (max (a $ x) (b $ x)))\n     (\\<chi>x. real_of_int (min (a $ x + 1) (b $ x + 1)))", "unfolding Int_interval_cart R_def interval_cbox"], ["proof (prove)\ngoal (1 subgoal):\n 1. cbox (\\<chi>i. max (of_int_vec a $ i) (of_int_vec b $ i))\n     (\\<chi>i. min (of_int_vec (a + 1) $ i) (of_int_vec (b + 1) $ i)) =\n    cbox (\\<chi>x. real_of_int (max (a $ x) (b $ x)))\n     (\\<chi>x. real_of_int (min (a $ x + 1) (b $ x + 1)))", "by (simp add: of_int_vec_def max_def min_def if_distrib cong: if_cong)"], ["proof (state)\nthis:\n  R a \\<inter> R b =\n  cbox (\\<chi>x. real_of_int (max (a $ x) (b $ x)))\n   (\\<chi>x. real_of_int (min (a $ x + 1) (b $ x + 1)))\n\ngoal (1 subgoal):\n 1. R a \\<inter> R b \\<in> null_sets lebesgue", "hence \"emeasure lebesgue (R a \\<inter> R b) = emeasure lborel \\<dots>\""], ["proof (prove)\nusing this:\n  R a \\<inter> R b =\n  cbox (\\<chi>x. real_of_int (max (a $ x) (b $ x)))\n   (\\<chi>x. real_of_int (min (a $ x + 1) (b $ x + 1)))\n\ngoal (1 subgoal):\n 1. emeasure lebesgue (R a \\<inter> R b) =\n    emeasure lborel\n     (cbox (\\<chi>x. real_of_int (max (a $ x) (b $ x)))\n       (\\<chi>x. real_of_int (min (a $ x + 1) (b $ x + 1))))", "by simp"], ["proof (state)\nthis:\n  emeasure lebesgue (R a \\<inter> R b) =\n  emeasure lborel\n   (cbox (\\<chi>x. real_of_int (max (a $ x) (b $ x)))\n     (\\<chi>x. real_of_int (min (a $ x + 1) (b $ x + 1))))\n\ngoal (1 subgoal):\n 1. R a \\<inter> R b \\<in> null_sets lebesgue", "also"], ["proof (state)\nthis:\n  emeasure lebesgue (R a \\<inter> R b) =\n  emeasure lborel\n   (cbox (\\<chi>x. real_of_int (max (a $ x) (b $ x)))\n     (\\<chi>x. real_of_int (min (a $ x + 1) (b $ x + 1))))\n\ngoal (1 subgoal):\n 1. R a \\<inter> R b \\<in> null_sets lebesgue", "have \"\\<dots> = ennreal (\\<Prod>i\\<in>UNIV. max 0 (((\\<chi> x. real_of_int (min (a $ x + 1) (b $ x + 1))) -\n                                  (\\<chi> x. real_of_int (max (a $ x) (b $ x)))) $ i))\"\n      (is \"_ = ennreal ?P\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure lborel\n     (cbox (\\<chi>x. real_of_int (max (a $ x) (b $ x)))\n       (\\<chi>x. real_of_int (min (a $ x + 1) (b $ x + 1)))) =\n    ennreal\n     (\\<Prod>i\\<in>UNIV.\n        max 0\n         (((\\<chi>x. real_of_int (min (a $ x + 1) (b $ x + 1))) -\n           (\\<chi>x. real_of_int (max (a $ x) (b $ x)))) $\n          i))", "unfolding emeasure_lborel_cbox_cart_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal\n     (\\<Prod>i\\<in>UNIV.\n        max 0\n         (((\\<chi>x. real_of_int (min (a $ x + 1) (b $ x + 1))) -\n           (\\<chi>x. real_of_int (max (a $ x) (b $ x)))) $\n          i)) =\n    ennreal\n     (\\<Prod>i\\<in>UNIV.\n        max 0\n         (((\\<chi>x. real_of_int (min (a $ x + 1) (b $ x + 1))) -\n           (\\<chi>x. real_of_int (max (a $ x) (b $ x)))) $\n          i))", "by simp"], ["proof (state)\nthis:\n  emeasure lborel\n   (cbox (\\<chi>x. real_of_int (max (a $ x) (b $ x)))\n     (\\<chi>x. real_of_int (min (a $ x + 1) (b $ x + 1)))) =\n  ennreal\n   (\\<Prod>i\\<in>UNIV.\n      max 0\n       (((\\<chi>x. real_of_int (min (a $ x + 1) (b $ x + 1))) -\n         (\\<chi>x. real_of_int (max (a $ x) (b $ x)))) $\n        i))\n\ngoal (1 subgoal):\n 1. R a \\<inter> R b \\<in> null_sets lebesgue", "also"], ["proof (state)\nthis:\n  emeasure lborel\n   (cbox (\\<chi>x. real_of_int (max (a $ x) (b $ x)))\n     (\\<chi>x. real_of_int (min (a $ x + 1) (b $ x + 1)))) =\n  ennreal\n   (\\<Prod>i\\<in>UNIV.\n      max 0\n       (((\\<chi>x. real_of_int (min (a $ x + 1) (b $ x + 1))) -\n         (\\<chi>x. real_of_int (max (a $ x) (b $ x)))) $\n        i))\n\ngoal (1 subgoal):\n 1. R a \\<inter> R b \\<in> null_sets lebesgue", "have \"?P = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV.\n       max 0\n        (((\\<chi>x. real_of_int (min (a $ x + 1) (b $ x + 1))) -\n          (\\<chi>x. real_of_int (max (a $ x) (b $ x)))) $\n         i)) =\n    0", "using i"], ["proof (prove)\nusing this:\n  a $ i \\<noteq> b $ i\n\ngoal (1 subgoal):\n 1. (\\<Prod>i\\<in>UNIV.\n       max 0\n        (((\\<chi>x. real_of_int (min (a $ x + 1) (b $ x + 1))) -\n          (\\<chi>x. real_of_int (max (a $ x) (b $ x)))) $\n         i)) =\n    0", "by (auto simp: max_def intro!: exI[of _ i])"], ["proof (state)\nthis:\n  (\\<Prod>i\\<in>UNIV.\n     max 0\n      (((\\<chi>x. real_of_int (min (a $ x + 1) (b $ x + 1))) -\n        (\\<chi>x. real_of_int (max (a $ x) (b $ x)))) $\n       i)) =\n  0\n\ngoal (1 subgoal):\n 1. R a \\<inter> R b \\<in> null_sets lebesgue", "finally"], ["proof (chain)\npicking this:\n  emeasure lebesgue (R a \\<inter> R b) = ennreal 0", "show ?thesis"], ["proof (prove)\nusing this:\n  emeasure lebesgue (R a \\<inter> R b) = ennreal 0\n\ngoal (1 subgoal):\n 1. R a \\<inter> R b \\<in> null_sets lebesgue", "by (auto simp: null_sets_def R_def)"], ["proof (state)\nthis:\n  R a \\<inter> R b \\<in> null_sets lebesgue\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>Therefore, the intersection of two lattice point cell partitionings of @{term S} is\n      also a null set.\\<close>"], ["proof (state)\nthis:\n  ?a \\<noteq> ?b \\<Longrightarrow>\n  R ?a \\<inter> R ?b \\<in> null_sets lebesgue\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have T_Int: \"T a \\<inter> T b \\<in> null_sets lebesgue\" if \"a \\<noteq> b\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. T a \\<inter> T b \\<in> null_sets lebesgue", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T a \\<inter> T b \\<in> null_sets lebesgue", "have \"T a \\<inter> T b = (R a \\<inter> R b) \\<inter> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T a \\<inter> T b = R a \\<inter> R b \\<inter> S", "by (auto simp: T_def)"], ["proof (state)\nthis:\n  T a \\<inter> T b = R a \\<inter> R b \\<inter> S\n\ngoal (1 subgoal):\n 1. T a \\<inter> T b \\<in> null_sets lebesgue", "also"], ["proof (state)\nthis:\n  T a \\<inter> T b = R a \\<inter> R b \\<inter> S\n\ngoal (1 subgoal):\n 1. T a \\<inter> T b \\<in> null_sets lebesgue", "have \"\\<dots> \\<in> null_sets lebesgue\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R a \\<inter> R b \\<inter> S \\<in> null_sets lebesgue", "by (rule null_set_Int2) (insert that, auto intro: R_Int assms)"], ["proof (state)\nthis:\n  R a \\<inter> R b \\<inter> S \\<in> null_sets lebesgue\n\ngoal (1 subgoal):\n 1. T a \\<inter> T b \\<in> null_sets lebesgue", "finally"], ["proof (chain)\npicking this:\n  T a \\<inter> T b \\<in> null_sets lebesgue", "show ?thesis"], ["proof (prove)\nusing this:\n  T a \\<inter> T b \\<in> null_sets lebesgue\n\ngoal (1 subgoal):\n 1. T a \\<inter> T b \\<in> null_sets lebesgue", "."], ["proof (state)\nthis:\n  T a \\<inter> T b \\<in> null_sets lebesgue\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?a \\<noteq> ?b \\<Longrightarrow>\n  T ?a \\<inter> T ?b \\<in> null_sets lebesgue\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have emeasure_T_Int: \"emeasure lebesgue (T a \\<inter> T b) = 0\" if \"a \\<noteq> b\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure lebesgue (T a \\<inter> T b) = 0", "using T_Int[OF that]"], ["proof (prove)\nusing this:\n  T a \\<inter> T b \\<in> null_sets lebesgue\n\ngoal (1 subgoal):\n 1. emeasure lebesgue (T a \\<inter> T b) = 0", "unfolding null_sets_def"], ["proof (prove)\nusing this:\n  T a \\<inter> T b \\<in> {N \\<in> sets lebesgue. emeasure lebesgue N = 0}\n\ngoal (1 subgoal):\n 1. emeasure lebesgue (T a \\<inter> T b) = 0", "by blast\n\n  \\<comment> \\<open>The set of lattice points $\\mathbb{Z}^n$ is countably infinite, so there exists\n      a bijection $f: \\mathbb{N} \\to \\mathbb{Z}^n$. We need this for summing over all\n      lattice points.\\<close>"], ["proof (state)\nthis:\n  ?a \\<noteq> ?b \\<Longrightarrow>\n  emeasure lebesgue (T ?a \\<inter> T ?b) = 0\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define f :: \"nat \\<Rightarrow> int ^ 'n\" where \"f = from_nat_into UNIV\""], ["proof (state)\nthis:\n  f = from_nat_into UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"countable (UNIV :: (int ^ 'n) set)\" \"infinite (UNIV :: (int ^ 'n) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable UNIV &&& infinite UNIV", "using infinite_UNIV_char_0"], ["proof (prove)\nusing this:\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. countable UNIV &&& infinite UNIV", "by simp_all"], ["proof (state)\nthis:\n  countable UNIV\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from bij_betw_from_nat_into [OF this]"], ["proof (chain)\npicking this:\n  bij (from_nat_into UNIV)", "have f: \"bij f\""], ["proof (prove)\nusing this:\n  bij (from_nat_into UNIV)\n\ngoal (1 subgoal):\n 1. bij f", "by (simp add: f_def)\n\n  \\<comment> \\<open>Suppose all the translated cell partitions @{term T'} are disjoint.\\<close>"], ["proof (state)\nthis:\n  bij f\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\nthis:\n  bij f\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume disjoint: \"\\<And>a b. a \\<noteq> b \\<Longrightarrow> T' a \\<inter> T' b = {}\"\n    \\<comment> \\<open>We know by assumption that the volume of @{term S} is greater than 1.\\<close>"], ["proof (state)\nthis:\n  ?a \\<noteq> ?b \\<Longrightarrow> T' ?a \\<inter> T' ?b = {}\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"1 < emeasure lebesgue S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < emeasure lebesgue S", "by fact"], ["proof (state)\nthis:\n  1 < emeasure lebesgue S\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  1 < emeasure lebesgue S\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"emeasure lebesgue S = emeasure lebesgue (\\<Union>n. T' (f n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure lebesgue S = emeasure lebesgue (\\<Union>n. T' (f n))", "proof -\n      \\<comment> \\<open>The sum of the volumes of all the @{term T'} is precisely the volume\n          of their union, which is @{term \"S\"}.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. emeasure lebesgue S = emeasure lebesgue (\\<Union>n. T' (f n))", "have \"S = (\\<Union>a. T a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S = \\<Union> (range T)", "by (rule S_decompose)"], ["proof (state)\nthis:\n  S = \\<Union> (range T)\n\ngoal (1 subgoal):\n 1. emeasure lebesgue S = emeasure lebesgue (\\<Union>n. T' (f n))", "also"], ["proof (state)\nthis:\n  S = \\<Union> (range T)\n\ngoal (1 subgoal):\n 1. emeasure lebesgue S = emeasure lebesgue (\\<Union>n. T' (f n))", "have \"\\<dots> = (\\<Union>n. T (f n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (range T) = (\\<Union>n. T (f n))", "by (rule bij_betw_UN [OF f, symmetric])"], ["proof (state)\nthis:\n  \\<Union> (range T) = (\\<Union>n. T (f n))\n\ngoal (1 subgoal):\n 1. emeasure lebesgue S = emeasure lebesgue (\\<Union>n. T' (f n))", "also"], ["proof (state)\nthis:\n  \\<Union> (range T) = (\\<Union>n. T (f n))\n\ngoal (1 subgoal):\n 1. emeasure lebesgue S = emeasure lebesgue (\\<Union>n. T' (f n))", "have \"(\\<lambda>n. emeasure lebesgue (T (f n))) sums emeasure lebesgue \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. emeasure lebesgue (T (f n))) sums\n    emeasure lebesgue (\\<Union>n. T (f n))", "by (intro sums_emeasure' emeasure_T_Int) (insert f, auto simp: bij_betw_def inj_on_def)"], ["proof (state)\nthis:\n  (\\<lambda>n. emeasure lebesgue (T (f n))) sums\n  emeasure lebesgue (\\<Union>n. T (f n))\n\ngoal (1 subgoal):\n 1. emeasure lebesgue S = emeasure lebesgue (\\<Union>n. T' (f n))", "also"], ["proof (state)\nthis:\n  (\\<lambda>n. emeasure lebesgue (T (f n))) sums\n  emeasure lebesgue (\\<Union>n. T (f n))\n\ngoal (1 subgoal):\n 1. emeasure lebesgue S = emeasure lebesgue (\\<Union>n. T' (f n))", "have \"(\\<lambda>n. emeasure lebesgue (T (f n))) = (\\<lambda>n. emeasure lebesgue (T' (f n)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. emeasure lebesgue (T (f n))) =\n    (\\<lambda>n. emeasure lebesgue (T' (f n)))", "by (simp add: emeasure_T')"], ["proof (state)\nthis:\n  (\\<lambda>n. emeasure lebesgue (T (f n))) =\n  (\\<lambda>n. emeasure lebesgue (T' (f n)))\n\ngoal (1 subgoal):\n 1. emeasure lebesgue S = emeasure lebesgue (\\<Union>n. T' (f n))", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>n. emeasure lebesgue (T' (f n))) sums emeasure lebesgue S", "have \"(\\<lambda>n. emeasure lebesgue (T' (f n))) sums emeasure lebesgue S\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. emeasure lebesgue (T' (f n))) sums emeasure lebesgue S\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. emeasure lebesgue (T' (f n))) sums emeasure lebesgue S", "."], ["proof (state)\nthis:\n  (\\<lambda>n. emeasure lebesgue (T' (f n))) sums emeasure lebesgue S\n\ngoal (1 subgoal):\n 1. emeasure lebesgue S = emeasure lebesgue (\\<Union>n. T' (f n))", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>n. emeasure lebesgue (T' (f n))) sums emeasure lebesgue S\n\ngoal (1 subgoal):\n 1. emeasure lebesgue S = emeasure lebesgue (\\<Union>n. T' (f n))", "have \"(\\<lambda>n. emeasure lebesgue (T' (f n))) sums emeasure lebesgue (\\<Union>n. T' (f n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. emeasure lebesgue (T' (f n))) sums\n    emeasure lebesgue (\\<Union>n. T' (f n))", "using disjoint"], ["proof (prove)\nusing this:\n  ?a \\<noteq> ?b \\<Longrightarrow> T' ?a \\<inter> T' ?b = {}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. emeasure lebesgue (T' (f n))) sums\n    emeasure lebesgue (\\<Union>n. T' (f n))", "by (intro sums_emeasure)\n                          (insert f, auto simp: disjoint_family_on_def bij_betw_def inj_on_def)"], ["proof (state)\nthis:\n  (\\<lambda>n. emeasure lebesgue (T' (f n))) sums\n  emeasure lebesgue (\\<Union>n. T' (f n))\n\ngoal (1 subgoal):\n 1. emeasure lebesgue S = emeasure lebesgue (\\<Union>n. T' (f n))", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>n. emeasure lebesgue (T' (f n))) sums emeasure lebesgue S\n  (\\<lambda>n. emeasure lebesgue (T' (f n))) sums\n  emeasure lebesgue (\\<Union>n. T' (f n))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>n. emeasure lebesgue (T' (f n))) sums emeasure lebesgue S\n  (\\<lambda>n. emeasure lebesgue (T' (f n))) sums\n  emeasure lebesgue (\\<Union>n. T' (f n))\n\ngoal (1 subgoal):\n 1. emeasure lebesgue S = emeasure lebesgue (\\<Union>n. T' (f n))", "by (auto simp: sums_iff)"], ["proof (state)\nthis:\n  emeasure lebesgue S = emeasure lebesgue (\\<Union>n. T' (f n))\n\ngoal:\nNo subgoals!", "qed\n    \\<comment> \\<open>On the other hand, all the translated partitions lie in the unit cell\n        @{term \"cbox (0 :: real ^ 'n) 1\"}, so their combined volume cannot be\n        greater than 1.\\<close>"], ["proof (state)\nthis:\n  emeasure lebesgue S = emeasure lebesgue (\\<Union>n. T' (f n))\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  emeasure lebesgue S = emeasure lebesgue (\\<Union>n. T' (f n))\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"emeasure lebesgue (\\<Union>n. T' (f n)) \\<le> emeasure lebesgue (cbox 0 (1 :: real ^ 'n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure lebesgue (\\<Union>n. T' (f n))\n    \\<le> emeasure lebesgue (cbox 0 1)", "using T'_subset"], ["proof (prove)\nusing this:\n  T' ?a \\<subseteq> cbox 0 1\n\ngoal (1 subgoal):\n 1. emeasure lebesgue (\\<Union>n. T' (f n))\n    \\<le> emeasure lebesgue (cbox 0 1)", "by (intro emeasure_mono) auto"], ["proof (state)\nthis:\n  emeasure lebesgue (\\<Union>n. T' (f n)) \\<le> emeasure lebesgue (cbox 0 1)\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  emeasure lebesgue (\\<Union>n. T' (f n)) \\<le> emeasure lebesgue (cbox 0 1)\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emeasure lebesgue (cbox 0 1) = 1", "by (simp add: emeasure_lborel_cbox_cart_eq)\n    \\<comment> \\<open>This leads to a contradiction.\\<close>"], ["proof (state)\nthis:\n  emeasure lebesgue (cbox 0 1) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  1 < 1", "have False"], ["proof (prove)\nusing this:\n  1 < 1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}\n  \\<comment> \\<open>Therefore, there exists a point that lies in two different translated partitions,\n      which obviously corresponds two two points in the non-translated partitions\n      whose difference is the difference between two lattice points and therefore\n      has integer components.\\<close>"], ["proof (state)\nthis:\n  (\\<And>a b.\n      a \\<noteq> b \\<Longrightarrow>\n      T' a \\<inter> T' b = {}) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  (\\<And>a b.\n      a \\<noteq> b \\<Longrightarrow>\n      T' a \\<inter> T' b = {}) \\<Longrightarrow>\n  False", "obtain a b x where \"a \\<noteq> b\" \"x \\<in> T' a\" \"x \\<in> T' b\""], ["proof (prove)\nusing this:\n  (\\<And>a b.\n      a \\<noteq> b \\<Longrightarrow>\n      T' a \\<inter> T' b = {}) \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. (\\<And>a b x.\n        \\<lbrakk>a \\<noteq> b; x \\<in> T' a; x \\<in> T' b\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> b\n  x \\<in> T' a\n  x \\<in> T' b\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> S; y \\<in> S;\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  x \\<in> T' a\n  x \\<in> T' b\n\ngoal (1 subgoal):\n 1. thesis", "by (intro that[of \"x + of_int_vec a\" \"x + of_int_vec b\"])\n       (auto simp: T'_def T_def algebra_simps)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Minkowski's theorem\\<close>"], ["", "text \\<open>\n  Minkowski's theorem now states that, given a convex subset of $\\mathbb{R}^n$ that is\n  symmetric around the origin and has a volume greater than $2^n$, that set must contain\n  a non-zero point with integer coordinates.\n\\<close>"], ["", "theorem minkowski:\n  fixes B :: \"(real ^ 'n) set\"\n  assumes \"convex B\" and symmetric: \"uminus ` B \\<subseteq> B\"\n  assumes meas_B [measurable]: \"B \\<in> sets lebesgue\"\n  assumes measure_B: \"emeasure lebesgue B > 2 ^ CARD('n)\"\n  obtains x where \"x \\<in> B\" and \"x \\<noteq> 0\" and \"\\<And>i. x $ i \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n         \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -\n  \\<comment> \\<open>We scale @{term B} with $\\frac{1}{2}$.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n         \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define B' where \"B' = (\\<lambda>x. 2 *\\<^sub>R x) -` B\""], ["proof (state)\nthis:\n  B' = (*\\<^sub>R) 2 -` B\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n         \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have meas_B' [measurable]: \"B' \\<in> sets lebesgue\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B' \\<in> sets lebesgue", "using measurable_sets[OF lebesgue_measurable_scaling[of 2] meas_B]"], ["proof (prove)\nusing this:\n  (*\\<^sub>R) 2 -` B \\<inter> space lebesgue \\<in> sets lebesgue\n\ngoal (1 subgoal):\n 1. B' \\<in> sets lebesgue", "by (simp add: B'_def)"], ["proof (state)\nthis:\n  B' \\<in> sets lebesgue\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n         \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have B'_altdef: \"B' = (\\<lambda>x. (1/2) *\\<^sub>R x) ` B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B' = (*\\<^sub>R) (1 / 2) ` B", "unfolding B'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (*\\<^sub>R) 2 -` B = (*\\<^sub>R) (1 / 2) ` B", "by force\n\n  \\<comment> \\<open>The volume of the scaled set is $2^n$ times smaller than the original set, and\n      therefore still has a volume greater than 1.\\<close>"], ["proof (state)\nthis:\n  B' = (*\\<^sub>R) (1 / 2) ` B\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n         \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"1 < ennreal ((1 / 2) ^ CARD('n)) * emeasure lebesgue B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < ennreal ((1 / 2) ^ CARD('n)) * emeasure lebesgue B", "proof (cases \"emeasure lebesgue B\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; emeasure lebesgue B = ennreal r\\<rbrakk>\n       \\<Longrightarrow> 1 < ennreal ((1 / 2) ^ CARD('n)) *\n                             emeasure lebesgue B\n 2. emeasure lebesgue B = top \\<Longrightarrow>\n    1 < ennreal ((1 / 2) ^ CARD('n)) * emeasure lebesgue B", "case (real x)"], ["proof (state)\nthis:\n  0 \\<le> x\n  emeasure lebesgue B = ennreal x\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; emeasure lebesgue B = ennreal r\\<rbrakk>\n       \\<Longrightarrow> 1 < ennreal ((1 / 2) ^ CARD('n)) *\n                             emeasure lebesgue B\n 2. emeasure lebesgue B = top \\<Longrightarrow>\n    1 < ennreal ((1 / 2) ^ CARD('n)) * emeasure lebesgue B", "have \"ennreal (2 ^ CARD('n)) = 2 ^ CARD('n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal (2 ^ CARD('n)) = 2 ^ CARD('n)", "by (subst ennreal_power [symmetric]) auto"], ["proof (state)\nthis:\n  ennreal (2 ^ CARD('n)) = 2 ^ CARD('n)\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; emeasure lebesgue B = ennreal r\\<rbrakk>\n       \\<Longrightarrow> 1 < ennreal ((1 / 2) ^ CARD('n)) *\n                             emeasure lebesgue B\n 2. emeasure lebesgue B = top \\<Longrightarrow>\n    1 < ennreal ((1 / 2) ^ CARD('n)) * emeasure lebesgue B", "also"], ["proof (state)\nthis:\n  ennreal (2 ^ CARD('n)) = 2 ^ CARD('n)\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; emeasure lebesgue B = ennreal r\\<rbrakk>\n       \\<Longrightarrow> 1 < ennreal ((1 / 2) ^ CARD('n)) *\n                             emeasure lebesgue B\n 2. emeasure lebesgue B = top \\<Longrightarrow>\n    1 < ennreal ((1 / 2) ^ CARD('n)) * emeasure lebesgue B", "from measure_B and real"], ["proof (chain)\npicking this:\n  2 ^ CARD('n) < emeasure lebesgue B\n  0 \\<le> x\n  emeasure lebesgue B = ennreal x", "have \"\\<dots> < ennreal x\""], ["proof (prove)\nusing this:\n  2 ^ CARD('n) < emeasure lebesgue B\n  0 \\<le> x\n  emeasure lebesgue B = ennreal x\n\ngoal (1 subgoal):\n 1. 2 ^ CARD('n) < ennreal x", "by simp"], ["proof (state)\nthis:\n  2 ^ CARD('n) < ennreal x\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; emeasure lebesgue B = ennreal r\\<rbrakk>\n       \\<Longrightarrow> 1 < ennreal ((1 / 2) ^ CARD('n)) *\n                             emeasure lebesgue B\n 2. emeasure lebesgue B = top \\<Longrightarrow>\n    1 < ennreal ((1 / 2) ^ CARD('n)) * emeasure lebesgue B", "finally"], ["proof (chain)\npicking this:\n  ennreal (2 ^ CARD('n)) < ennreal x", "have \"(2 ^ CARD('n)) < x\""], ["proof (prove)\nusing this:\n  ennreal (2 ^ CARD('n)) < ennreal x\n\ngoal (1 subgoal):\n 1. 2 ^ CARD('n) < x", "by (subst (asm) ennreal_less_iff) auto"], ["proof (state)\nthis:\n  2 ^ CARD('n) < x\n\ngoal (2 subgoals):\n 1. \\<And>r.\n       \\<lbrakk>0 \\<le> r; emeasure lebesgue B = ennreal r\\<rbrakk>\n       \\<Longrightarrow> 1 < ennreal ((1 / 2) ^ CARD('n)) *\n                             emeasure lebesgue B\n 2. emeasure lebesgue B = top \\<Longrightarrow>\n    1 < ennreal ((1 / 2) ^ CARD('n)) * emeasure lebesgue B", "thus ?thesis"], ["proof (prove)\nusing this:\n  2 ^ CARD('n) < x\n\ngoal (1 subgoal):\n 1. 1 < ennreal ((1 / 2) ^ CARD('n)) * emeasure lebesgue B", "using real"], ["proof (prove)\nusing this:\n  2 ^ CARD('n) < x\n  0 \\<le> x\n  emeasure lebesgue B = ennreal x\n\ngoal (1 subgoal):\n 1. 1 < ennreal ((1 / 2) ^ CARD('n)) * emeasure lebesgue B", "by (simp add: ennreal_1 [symmetric] ennreal_mult' [symmetric]\n                       ennreal_less_iff field_simps del: ennreal_1)"], ["proof (state)\nthis:\n  1 < ennreal ((1 / 2) ^ CARD('n)) * emeasure lebesgue B\n\ngoal (1 subgoal):\n 1. emeasure lebesgue B = top \\<Longrightarrow>\n    1 < ennreal ((1 / 2) ^ CARD('n)) * emeasure lebesgue B", "qed (simp_all add: ennreal_mult_top)"], ["proof (state)\nthis:\n  1 < ennreal ((1 / 2) ^ CARD('n)) * emeasure lebesgue B\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n         \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  1 < ennreal ((1 / 2) ^ CARD('n)) * emeasure lebesgue B\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n         \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = emeasure lebesgue B'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal ((1 / 2) ^ CARD('n)) * emeasure lebesgue B =\n    emeasure lebesgue B'", "unfolding B'_altdef"], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal ((1 / 2) ^ CARD('n)) * emeasure lebesgue B =\n    emeasure lebesgue ((*\\<^sub>R) (1 / 2) ` B)", "using emeasure_lebesgue_affine[of \"1/2\" 0 B]"], ["proof (prove)\nusing this:\n  emeasure lebesgue ((\\<lambda>x. (1 / 2) *\\<^sub>R x + 0) ` B) =\n  ennreal (\\<bar>1 / 2\\<bar> ^ DIM((real, 'n) vec)) * emeasure lebesgue B\n\ngoal (1 subgoal):\n 1. ennreal ((1 / 2) ^ CARD('n)) * emeasure lebesgue B =\n    emeasure lebesgue ((*\\<^sub>R) (1 / 2) ` B)", "by simp"], ["proof (state)\nthis:\n  ennreal ((1 / 2) ^ CARD('n)) * emeasure lebesgue B = emeasure lebesgue B'\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n         \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  1 < emeasure lebesgue B'", "have *: \"emeasure lebesgue B' > 1\""], ["proof (prove)\nusing this:\n  1 < emeasure lebesgue B'\n\ngoal (1 subgoal):\n 1. 1 < emeasure lebesgue B'", ".\n\n  \\<comment> \\<open>We apply Blichfeldt's theorem to get two points whose difference vector has\n      integer coefficients. It only remains to show that that difference vector is\n      itself a point in the original set.\\<close>"], ["proof (state)\nthis:\n  1 < emeasure lebesgue B'\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n         \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain x y\n    where xy: \"x \\<noteq> y\" \"x \\<in> B'\" \"y \\<in> B'\" \"\\<And>i. (x - y) $ i \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>x \\<noteq> y; x \\<in> B'; y \\<in> B';\n         \\<And>i. (x - y) $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (erule blichfeldt [OF meas_B' *])"], ["proof (state)\nthis:\n  x \\<noteq> y\n  x \\<in> B'\n  y \\<in> B'\n  (x - y) $ ?i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n         \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"2 *\\<^sub>R x \\<in> B\" \"2 *\\<^sub>R y \\<in> B\""], ["proof (prove)\nusing this:\n  x \\<noteq> y\n  x \\<in> B'\n  y \\<in> B'\n  (x - y) $ ?i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. 2 *\\<^sub>R x \\<in> B &&& 2 *\\<^sub>R y \\<in> B", "by (auto simp: B'_def)\n  \\<comment> \\<open>Exploiting the symmetric of @{term B}, the reflection of @{term \"2 *\\<^sub>R y\"} is\n      also in @{term B}.\\<close>"], ["proof (state)\nthis:\n  2 *\\<^sub>R x \\<in> B\n  2 *\\<^sub>R y \\<in> B\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n         \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  2 *\\<^sub>R x \\<in> B\n  2 *\\<^sub>R y \\<in> B\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n         \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this and symmetric"], ["proof (chain)\npicking this:\n  2 *\\<^sub>R x \\<in> B\n  2 *\\<^sub>R y \\<in> B\n  uminus ` B \\<subseteq> B", "have \"-(2 *\\<^sub>R y) \\<in> B\""], ["proof (prove)\nusing this:\n  2 *\\<^sub>R x \\<in> B\n  2 *\\<^sub>R y \\<in> B\n  uminus ` B \\<subseteq> B\n\ngoal (1 subgoal):\n 1. - (2 *\\<^sub>R y) \\<in> B", "by blast\n  \\<comment> \\<open>Since @{term B} is convex, the mid-point between @{term \"2 *\\<^sub>R x\"} and @{term \"-2 *\\<^sub>R y\"}\n      is also in @{term B}, and that point is simply @{term \"x - y\"} as desired.\\<close>"], ["proof (state)\nthis:\n  - (2 *\\<^sub>R y) \\<in> B\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n         \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  2 *\\<^sub>R x \\<in> B\n  2 *\\<^sub>R y \\<in> B\n  - (2 *\\<^sub>R y) \\<in> B", "have \"(1 / 2) *\\<^sub>R 2 *\\<^sub>R x + (1 / 2) *\\<^sub>R (- 2 *\\<^sub>R y) \\<in> B\""], ["proof (prove)\nusing this:\n  2 *\\<^sub>R x \\<in> B\n  2 *\\<^sub>R y \\<in> B\n  - (2 *\\<^sub>R y) \\<in> B\n\ngoal (1 subgoal):\n 1. (1 / 2) *\\<^sub>R 2 *\\<^sub>R x + (1 / 2) *\\<^sub>R - 2 *\\<^sub>R y\n    \\<in> B", "using \\<open>convex B\\<close>"], ["proof (prove)\nusing this:\n  2 *\\<^sub>R x \\<in> B\n  2 *\\<^sub>R y \\<in> B\n  - (2 *\\<^sub>R y) \\<in> B\n  convex B\n\ngoal (1 subgoal):\n 1. (1 / 2) *\\<^sub>R 2 *\\<^sub>R x + (1 / 2) *\\<^sub>R - 2 *\\<^sub>R y\n    \\<in> B", "by (intro convexD) auto"], ["proof (state)\nthis:\n  (1 / 2) *\\<^sub>R 2 *\\<^sub>R x + (1 / 2) *\\<^sub>R - 2 *\\<^sub>R y\n  \\<in> B\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n         \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  (1 / 2) *\\<^sub>R 2 *\\<^sub>R x + (1 / 2) *\\<^sub>R - 2 *\\<^sub>R y\n  \\<in> B\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n         \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"(1 / 2) *\\<^sub>R 2 *\\<^sub>R x + (1 / 2) *\\<^sub>R (- 2 *\\<^sub>R y) = x - y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 / 2) *\\<^sub>R 2 *\\<^sub>R x + (1 / 2) *\\<^sub>R - 2 *\\<^sub>R y =\n    x - y", "by simp"], ["proof (state)\nthis:\n  (1 / 2) *\\<^sub>R 2 *\\<^sub>R x + (1 / 2) *\\<^sub>R - 2 *\\<^sub>R y =\n  x - y\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n         \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  x - y \\<in> B", "show ?thesis"], ["proof (prove)\nusing this:\n  x - y \\<in> B\n\ngoal (1 subgoal):\n 1. thesis", "using xy"], ["proof (prove)\nusing this:\n  x - y \\<in> B\n  x \\<noteq> y\n  x \\<in> B'\n  y \\<in> B'\n  (x - y) $ ?i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. thesis", "by (intro that[of \"x - y\"]) auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  If the set in question is compact, the restriction to the volume can be weakened\n  to ``at least 1'' from ``greater than 1''.\n\\<close>"], ["", "theorem minkowski_compact:\n  fixes B :: \"(real ^ 'n) set\"\n  assumes \"convex B\" and \"compact B\" and symmetric: \"uminus ` B \\<subseteq> B\"\n  assumes measure_B: \"emeasure lebesgue B \\<ge> 2 ^ CARD('n)\"\n  obtains x where \"x \\<in> B\" and \"x \\<noteq> 0\" and \"\\<And>i. x $ i \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n         \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof (cases \"emeasure lebesgue B = 2 ^ CARD('n)\")\n  \\<comment> \\<open>If the volume is greater than 1, we can just apply the theorem from before.\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B \\<noteq> 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  emeasure lebesgue B \\<noteq> 2 ^ CARD('n)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B \\<noteq> 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "with measure_B"], ["proof (chain)\npicking this:\n  2 ^ CARD('n) \\<le> emeasure lebesgue B\n  emeasure lebesgue B \\<noteq> 2 ^ CARD('n)", "have less: \"emeasure lebesgue B > 2 ^ CARD('n)\""], ["proof (prove)\nusing this:\n  2 ^ CARD('n) \\<le> emeasure lebesgue B\n  emeasure lebesgue B \\<noteq> 2 ^ CARD('n)\n\ngoal (1 subgoal):\n 1. 2 ^ CARD('n) < emeasure lebesgue B", "by simp"], ["proof (state)\nthis:\n  2 ^ CARD('n) < emeasure lebesgue B\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B \\<noteq> 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "from \\<open>compact B\\<close>"], ["proof (chain)\npicking this:\n  compact B", "have meas: \"B \\<in> sets lebesgue\""], ["proof (prove)\nusing this:\n  compact B\n\ngoal (1 subgoal):\n 1. B \\<in> sets lebesgue", "by (intro sets_completionI_sets lborelD borel_closed compact_imp_closed)"], ["proof (state)\nthis:\n  B \\<in> sets lebesgue\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B \\<noteq> 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "from minkowski[OF assms(1) symmetric meas less] and that"], ["proof (chain)\npicking this:\n  (\\<And>x.\n      \\<lbrakk>x \\<in> B; x \\<noteq> 0; \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  \\<lbrakk>?x \\<in> B; ?x \\<noteq> 0; \\<And>i. ?x $ i \\<in> \\<int>\\<rbrakk>\n  \\<Longrightarrow> thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x.\n      \\<lbrakk>x \\<in> B; x \\<noteq> 0; \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  \\<lbrakk>?x \\<in> B; ?x \\<noteq> 0; \\<And>i. ?x $ i \\<in> \\<int>\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True\n  \\<comment> \\<open>If the volume is precisely one, we look at what happens when @{term B} is\n      scaled with a factor of $1 + \\varepsilon$.\\<close>"], ["proof (state)\nthis:\n  emeasure lebesgue B = 2 ^ CARD('n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "define B' where \"B' = (\\<lambda>\\<epsilon>. (*\\<^sub>R) (1 + \\<epsilon>) ` B)\""], ["proof (state)\nthis:\n  B' = (\\<lambda>\\<epsilon>. (*\\<^sub>R) (1 + \\<epsilon>) ` B)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "from \\<open>compact B\\<close>"], ["proof (chain)\npicking this:\n  compact B", "have compact': \"compact (B' \\<epsilon>)\" for \\<epsilon>"], ["proof (prove)\nusing this:\n  compact B\n\ngoal (1 subgoal):\n 1. compact (B' \\<epsilon>)", "unfolding B'_def"], ["proof (prove)\nusing this:\n  compact B\n\ngoal (1 subgoal):\n 1. compact ((*\\<^sub>R) (1 + \\<epsilon>) ` B)", "by (intro compact_scaling)"], ["proof (state)\nthis:\n  compact (B' ?\\<epsilon>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "have B'_altdef: \"B' \\<epsilon> = (*\\<^sub>R) (inverse (1 + \\<epsilon>)) -` B\" if \\<epsilon>: \"\\<epsilon> > 0\" for \\<epsilon>"], ["proof (prove)\ngoal (1 subgoal):\n 1. B' \\<epsilon> = (*\\<^sub>R) (inverse (1 + \\<epsilon>)) -` B", "using \\<epsilon>"], ["proof (prove)\nusing this:\n  0 < \\<epsilon>\n\ngoal (1 subgoal):\n 1. B' \\<epsilon> = (*\\<^sub>R) (inverse (1 + \\<epsilon>)) -` B", "unfolding B'_def"], ["proof (prove)\nusing this:\n  0 < \\<epsilon>\n\ngoal (1 subgoal):\n 1. (*\\<^sub>R) (1 + \\<epsilon>) ` B =\n    (*\\<^sub>R) (inverse (1 + \\<epsilon>)) -` B", "by force\n\n  \\<comment> \\<open>Since the scaled sets are convex, they are stable under scaling.\\<close>"], ["proof (state)\nthis:\n  0 < ?\\<epsilon> \\<Longrightarrow>\n  B' ?\\<epsilon> = (*\\<^sub>R) (inverse (1 + ?\\<epsilon>)) -` B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "have B_scale: \"a *\\<^sub>R x \\<in> B\" if \"x \\<in> B\" \"a \\<in> {0..1}\" for a x"], ["proof (prove)\ngoal (1 subgoal):\n 1. a *\\<^sub>R x \\<in> B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a *\\<^sub>R x \\<in> B", "have \"((a + 1) / 2) *\\<^sub>R x + (1 - ((a + 1) / 2)) *\\<^sub>R (-x) \\<in> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a + 1) / 2) *\\<^sub>R x + (1 - (a + 1) / 2) *\\<^sub>R - x \\<in> B", "using that and \\<open>convex B\\<close> and symmetric"], ["proof (prove)\nusing this:\n  x \\<in> B\n  a \\<in> {0..1}\n  convex B\n  uminus ` B \\<subseteq> B\n\ngoal (1 subgoal):\n 1. ((a + 1) / 2) *\\<^sub>R x + (1 - (a + 1) / 2) *\\<^sub>R - x \\<in> B", "by (intro convexD) auto"], ["proof (state)\nthis:\n  ((a + 1) / 2) *\\<^sub>R x + (1 - (a + 1) / 2) *\\<^sub>R - x \\<in> B\n\ngoal (1 subgoal):\n 1. a *\\<^sub>R x \\<in> B", "also"], ["proof (state)\nthis:\n  ((a + 1) / 2) *\\<^sub>R x + (1 - (a + 1) / 2) *\\<^sub>R - x \\<in> B\n\ngoal (1 subgoal):\n 1. a *\\<^sub>R x \\<in> B", "have \"((a + 1) / 2) *\\<^sub>R x + (1 - ((a + 1) / 2)) *\\<^sub>R (-x) =\n                 (1 + a) *\\<^sub>R ((1/2) *\\<^sub>R (x + x)) - x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a + 1) / 2) *\\<^sub>R x + (1 - (a + 1) / 2) *\\<^sub>R - x =\n    (1 + a) *\\<^sub>R (1 / 2) *\\<^sub>R (x + x) - x", "by (simp add: algebra_simps del: scaleR_half_double)"], ["proof (state)\nthis:\n  ((a + 1) / 2) *\\<^sub>R x + (1 - (a + 1) / 2) *\\<^sub>R - x =\n  (1 + a) *\\<^sub>R (1 / 2) *\\<^sub>R (x + x) - x\n\ngoal (1 subgoal):\n 1. a *\\<^sub>R x \\<in> B", "also"], ["proof (state)\nthis:\n  ((a + 1) / 2) *\\<^sub>R x + (1 - (a + 1) / 2) *\\<^sub>R - x =\n  (1 + a) *\\<^sub>R (1 / 2) *\\<^sub>R (x + x) - x\n\ngoal (1 subgoal):\n 1. a *\\<^sub>R x \\<in> B", "have \"\\<dots> = a *\\<^sub>R x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 + a) *\\<^sub>R (1 / 2) *\\<^sub>R (x + x) - x = a *\\<^sub>R x", "by (subst scaleR_half_double) (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (1 + a) *\\<^sub>R (1 / 2) *\\<^sub>R (x + x) - x = a *\\<^sub>R x\n\ngoal (1 subgoal):\n 1. a *\\<^sub>R x \\<in> B", "finally"], ["proof (chain)\npicking this:\n  a *\\<^sub>R x \\<in> B", "show \"\\<dots> \\<in> B\""], ["proof (prove)\nusing this:\n  a *\\<^sub>R x \\<in> B\n\ngoal (1 subgoal):\n 1. a *\\<^sub>R x \\<in> B", "."], ["proof (state)\nthis:\n  a *\\<^sub>R x \\<in> B\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>This means that @{term B'} is monotonic.\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> B; ?a \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> ?a *\\<^sub>R ?x \\<in> B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "have B'_subset: \"B' a \\<subseteq> B' b\" if \"0 \\<le> a\" \"a \\<le> b\" for a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. B' a \\<subseteq> B' b", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> B' a \\<Longrightarrow> x \\<in> B' b", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> B' a \\<Longrightarrow> x \\<in> B' b", "assume \"x \\<in> B' a\""], ["proof (state)\nthis:\n  x \\<in> B' a\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> B' a \\<Longrightarrow> x \\<in> B' b", "then"], ["proof (chain)\npicking this:\n  x \\<in> B' a", "obtain y where \"x = (1 + a) *\\<^sub>R y\" \"y \\<in> B\""], ["proof (prove)\nusing this:\n  x \\<in> B' a\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>x = (1 + a) *\\<^sub>R y; y \\<in> B\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: B'_def)"], ["proof (state)\nthis:\n  x = (1 + a) *\\<^sub>R y\n  y \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> B' a \\<Longrightarrow> x \\<in> B' b", "moreover"], ["proof (state)\nthis:\n  x = (1 + a) *\\<^sub>R y\n  y \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> B' a \\<Longrightarrow> x \\<in> B' b", "then"], ["proof (chain)\npicking this:\n  x = (1 + a) *\\<^sub>R y\n  y \\<in> B", "have \"(inverse (1 + b) * (1 + a)) *\\<^sub>R y \\<in> B\""], ["proof (prove)\nusing this:\n  x = (1 + a) *\\<^sub>R y\n  y \\<in> B\n\ngoal (1 subgoal):\n 1. (inverse (1 + b) * (1 + a)) *\\<^sub>R y \\<in> B", "using that"], ["proof (prove)\nusing this:\n  x = (1 + a) *\\<^sub>R y\n  y \\<in> B\n  0 \\<le> a\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. (inverse (1 + b) * (1 + a)) *\\<^sub>R y \\<in> B", "by (intro B_scale) (auto simp: field_simps)"], ["proof (state)\nthis:\n  (inverse (1 + b) * (1 + a)) *\\<^sub>R y \\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> B' a \\<Longrightarrow> x \\<in> B' b", "ultimately"], ["proof (chain)\npicking this:\n  x = (1 + a) *\\<^sub>R y\n  y \\<in> B\n  (inverse (1 + b) * (1 + a)) *\\<^sub>R y \\<in> B", "show \"x \\<in> B' b\""], ["proof (prove)\nusing this:\n  x = (1 + a) *\\<^sub>R y\n  y \\<in> B\n  (inverse (1 + b) * (1 + a)) *\\<^sub>R y \\<in> B\n\ngoal (1 subgoal):\n 1. x \\<in> B' b", "using that"], ["proof (prove)\nusing this:\n  x = (1 + a) *\\<^sub>R y\n  y \\<in> B\n  (inverse (1 + b) * (1 + a)) *\\<^sub>R y \\<in> B\n  0 \\<le> a\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. x \\<in> B' b", "by (force simp: B'_def)"], ["proof (state)\nthis:\n  x \\<in> B' b\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>We obtain some upper bound on the norm of @{term B}.\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>0 \\<le> ?a; ?a \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> B' ?a \\<subseteq> B' ?b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "from \\<open>compact B\\<close>"], ["proof (chain)\npicking this:\n  compact B", "have \"bounded B\""], ["proof (prove)\nusing this:\n  compact B\n\ngoal (1 subgoal):\n 1. bounded B", "by (rule compact_imp_bounded)"], ["proof (state)\nthis:\n  bounded B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  bounded B", "obtain C where C: \"norm x \\<le> C\" if \"x \\<in> B\" for x"], ["proof (prove)\nusing this:\n  bounded B\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        (\\<And>x.\n            x \\<in> B \\<Longrightarrow> norm x \\<le> C) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding bounded_iff"], ["proof (prove)\nusing this:\n  \\<exists>a. \\<forall>x\\<in>B. norm x \\<le> a\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        (\\<And>x.\n            x \\<in> B \\<Longrightarrow> norm x \\<le> C) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast\n\n  \\<comment> \\<open>We can then bound the distance of any point in a scaled set to the original set.\\<close>"], ["proof (state)\nthis:\n  ?x \\<in> B \\<Longrightarrow> norm ?x \\<le> C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "have setdist_le: \"setdist {x} B \\<le> \\<epsilon> * C\" if \"x \\<in> B' \\<epsilon>\" and \"\\<epsilon> \\<ge> 0\" for x \\<epsilon>"], ["proof (prove)\ngoal (1 subgoal):\n 1. setdist {x} B \\<le> \\<epsilon> * C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. setdist {x} B \\<le> \\<epsilon> * C", "from that"], ["proof (chain)\npicking this:\n  x \\<in> B' \\<epsilon>\n  0 \\<le> \\<epsilon>", "obtain y where y: \"y \\<in> B\" and [simp]: \"x = (1 + \\<epsilon>) *\\<^sub>R y\""], ["proof (prove)\nusing this:\n  x \\<in> B' \\<epsilon>\n  0 \\<le> \\<epsilon>\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in> B; x = (1 + \\<epsilon>) *\\<^sub>R y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: B'_def)"], ["proof (state)\nthis:\n  y \\<in> B\n  x = (1 + \\<epsilon>) *\\<^sub>R y\n\ngoal (1 subgoal):\n 1. setdist {x} B \\<le> \\<epsilon> * C", "from y"], ["proof (chain)\npicking this:\n  y \\<in> B", "have \"setdist {x} B \\<le> dist x y\""], ["proof (prove)\nusing this:\n  y \\<in> B\n\ngoal (1 subgoal):\n 1. setdist {x} B \\<le> dist x y", "by (intro setdist_le_dist) auto"], ["proof (state)\nthis:\n  setdist {x} B \\<le> dist x y\n\ngoal (1 subgoal):\n 1. setdist {x} B \\<le> \\<epsilon> * C", "also"], ["proof (state)\nthis:\n  setdist {x} B \\<le> dist x y\n\ngoal (1 subgoal):\n 1. setdist {x} B \\<le> \\<epsilon> * C", "from that"], ["proof (chain)\npicking this:\n  x \\<in> B' \\<epsilon>\n  0 \\<le> \\<epsilon>", "have \"dist x y = \\<epsilon> * norm y\""], ["proof (prove)\nusing this:\n  x \\<in> B' \\<epsilon>\n  0 \\<le> \\<epsilon>\n\ngoal (1 subgoal):\n 1. dist x y = \\<epsilon> * norm y", "by (simp add: dist_norm algebra_simps)"], ["proof (state)\nthis:\n  dist x y = \\<epsilon> * norm y\n\ngoal (1 subgoal):\n 1. setdist {x} B \\<le> \\<epsilon> * C", "also"], ["proof (state)\nthis:\n  dist x y = \\<epsilon> * norm y\n\ngoal (1 subgoal):\n 1. setdist {x} B \\<le> \\<epsilon> * C", "from y"], ["proof (chain)\npicking this:\n  y \\<in> B", "have \"norm y \\<le> C\""], ["proof (prove)\nusing this:\n  y \\<in> B\n\ngoal (1 subgoal):\n 1. norm y \\<le> C", "by (rule C)"], ["proof (state)\nthis:\n  norm y \\<le> C\n\ngoal (1 subgoal):\n 1. setdist {x} B \\<le> \\<epsilon> * C", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      \\<epsilon> * x \\<le> \\<epsilon> * y) \\<Longrightarrow>\n  setdist {x} B \\<le> \\<epsilon> * C", "show \"setdist {x} B \\<le> \\<epsilon> * C\""], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      \\<epsilon> * x \\<le> \\<epsilon> * y) \\<Longrightarrow>\n  setdist {x} B \\<le> \\<epsilon> * C\n\ngoal (1 subgoal):\n 1. setdist {x} B \\<le> \\<epsilon> * C", "using that"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow>\n      \\<epsilon> * x \\<le> \\<epsilon> * y) \\<Longrightarrow>\n  setdist {x} B \\<le> \\<epsilon> * C\n  x \\<in> B' \\<epsilon>\n  0 \\<le> \\<epsilon>\n\ngoal (1 subgoal):\n 1. setdist {x} B \\<le> \\<epsilon> * C", "by (simp add: mult_left_mono)"], ["proof (state)\nthis:\n  setdist {x} B \\<le> \\<epsilon> * C\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>By applying the standard Minkowski theorem to the a scaled set, we can see that\n      any scaled set contains a non-zero point with integer coordinates.\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> B' ?\\<epsilon>; 0 \\<le> ?\\<epsilon>\\<rbrakk>\n  \\<Longrightarrow> setdist {?x} B \\<le> ?\\<epsilon> * C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"\\<exists>v. v \\<in> B' \\<epsilon> - {0} \\<and> (\\<forall>i. v $ i \\<in> \\<int>)\" if \\<epsilon>: \"\\<epsilon> > 0\" for \\<epsilon>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> B' \\<epsilon> - {0} \\<and> (\\<forall>i. v $ i \\<in> \\<int>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> B' \\<epsilon> - {0} \\<and> (\\<forall>i. v $ i \\<in> \\<int>)", "from \\<open>convex B\\<close>"], ["proof (chain)\npicking this:\n  convex B", "have convex': \"convex (B' \\<epsilon>)\""], ["proof (prove)\nusing this:\n  convex B\n\ngoal (1 subgoal):\n 1. convex (B' \\<epsilon>)", "unfolding B'_def"], ["proof (prove)\nusing this:\n  convex B\n\ngoal (1 subgoal):\n 1. convex ((*\\<^sub>R) (1 + \\<epsilon>) ` B)", "by (rule convex_scaling)"], ["proof (state)\nthis:\n  convex (B' \\<epsilon>)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> B' \\<epsilon> - {0} \\<and> (\\<forall>i. v $ i \\<in> \\<int>)", "from \\<open>compact B\\<close>"], ["proof (chain)\npicking this:\n  compact B", "have meas: \"B' \\<epsilon> \\<in> sets lebesgue\""], ["proof (prove)\nusing this:\n  compact B\n\ngoal (1 subgoal):\n 1. B' \\<epsilon> \\<in> sets lebesgue", "unfolding B'_def"], ["proof (prove)\nusing this:\n  compact B\n\ngoal (1 subgoal):\n 1. (*\\<^sub>R) (1 + \\<epsilon>) ` B \\<in> sets lebesgue", "by (intro sets_completionI_sets lborelD borel_closed compact_imp_closed compact_scaling)"], ["proof (state)\nthis:\n  B' \\<epsilon> \\<in> sets lebesgue\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> B' \\<epsilon> - {0} \\<and> (\\<forall>i. v $ i \\<in> \\<int>)", "from symmetric"], ["proof (chain)\npicking this:\n  uminus ` B \\<subseteq> B", "have symmetric': \"uminus ` B' \\<epsilon> \\<subseteq> B' \\<epsilon>\""], ["proof (prove)\nusing this:\n  uminus ` B \\<subseteq> B\n\ngoal (1 subgoal):\n 1. uminus ` B' \\<epsilon> \\<subseteq> B' \\<epsilon>", "by (auto simp: B'_altdef[OF \\<epsilon>])"], ["proof (state)\nthis:\n  uminus ` B' \\<epsilon> \\<subseteq> B' \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> B' \\<epsilon> - {0} \\<and> (\\<forall>i. v $ i \\<in> \\<int>)", "have \"2 ^ CARD('n) = ennreal (2 ^ CARD('n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ CARD('n) = ennreal (2 ^ CARD('n))", "by (subst ennreal_power [symmetric]) auto"], ["proof (state)\nthis:\n  2 ^ CARD('n) = ennreal (2 ^ CARD('n))\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> B' \\<epsilon> - {0} \\<and> (\\<forall>i. v $ i \\<in> \\<int>)", "hence \"1 * emeasure lebesgue B < ennreal ((1 + \\<epsilon>) ^ CARD('n)) * emeasure lebesgue B\""], ["proof (prove)\nusing this:\n  2 ^ CARD('n) = ennreal (2 ^ CARD('n))\n\ngoal (1 subgoal):\n 1. 1 * emeasure lebesgue B\n    < ennreal ((1 + \\<epsilon>) ^ CARD('n)) * emeasure lebesgue B", "using True and \\<epsilon>"], ["proof (prove)\nusing this:\n  2 ^ CARD('n) = ennreal (2 ^ CARD('n))\n  emeasure lebesgue B = 2 ^ CARD('n)\n  0 < \\<epsilon>\n\ngoal (1 subgoal):\n 1. 1 * emeasure lebesgue B\n    < ennreal ((1 + \\<epsilon>) ^ CARD('n)) * emeasure lebesgue B", "by (intro ennreal_mult_strict_right_mono) (auto)"], ["proof (state)\nthis:\n  1 * emeasure lebesgue B\n  < ennreal ((1 + \\<epsilon>) ^ CARD('n)) * emeasure lebesgue B\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> B' \\<epsilon> - {0} \\<and> (\\<forall>i. v $ i \\<in> \\<int>)", "also"], ["proof (state)\nthis:\n  1 * emeasure lebesgue B\n  < ennreal ((1 + \\<epsilon>) ^ CARD('n)) * emeasure lebesgue B\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> B' \\<epsilon> - {0} \\<and> (\\<forall>i. v $ i \\<in> \\<int>)", "have \"\\<dots> = emeasure lebesgue (B' \\<epsilon>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ennreal ((1 + \\<epsilon>) ^ CARD('n)) * emeasure lebesgue B =\n    emeasure lebesgue (B' \\<epsilon>)", "using emeasure_lebesgue_affine[of \"1+\\<epsilon>\" 0 B] and \\<epsilon>"], ["proof (prove)\nusing this:\n  emeasure lebesgue ((\\<lambda>x. (1 + \\<epsilon>) *\\<^sub>R x + 0) ` B) =\n  ennreal (\\<bar>1 + \\<epsilon>\\<bar> ^ DIM((real, 'n) vec)) *\n  emeasure lebesgue B\n  0 < \\<epsilon>\n\ngoal (1 subgoal):\n 1. ennreal ((1 + \\<epsilon>) ^ CARD('n)) * emeasure lebesgue B =\n    emeasure lebesgue (B' \\<epsilon>)", "by (simp add: B'_def)"], ["proof (state)\nthis:\n  ennreal ((1 + \\<epsilon>) ^ CARD('n)) * emeasure lebesgue B =\n  emeasure lebesgue (B' \\<epsilon>)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> B' \\<epsilon> - {0} \\<and> (\\<forall>i. v $ i \\<in> \\<int>)", "finally"], ["proof (chain)\npicking this:\n  1 * emeasure lebesgue B < emeasure lebesgue (B' \\<epsilon>)", "have measure_B': \"emeasure lebesgue (B' \\<epsilon>) > 2 ^ CARD('n)\""], ["proof (prove)\nusing this:\n  1 * emeasure lebesgue B < emeasure lebesgue (B' \\<epsilon>)\n\ngoal (1 subgoal):\n 1. 2 ^ CARD('n) < emeasure lebesgue (B' \\<epsilon>)", "using True"], ["proof (prove)\nusing this:\n  1 * emeasure lebesgue B < emeasure lebesgue (B' \\<epsilon>)\n  emeasure lebesgue B = 2 ^ CARD('n)\n\ngoal (1 subgoal):\n 1. 2 ^ CARD('n) < emeasure lebesgue (B' \\<epsilon>)", "by simp"], ["proof (state)\nthis:\n  2 ^ CARD('n) < emeasure lebesgue (B' \\<epsilon>)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> B' \\<epsilon> - {0} \\<and> (\\<forall>i. v $ i \\<in> \\<int>)", "obtain v where \"v \\<in> B' \\<epsilon>\" \"v \\<noteq> 0\" \"\\<And>i. v $ i \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>v \\<in> B' \\<epsilon>; v \\<noteq> 0;\n         \\<And>i. v $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (erule minkowski[OF convex' symmetric' meas measure_B'])"], ["proof (state)\nthis:\n  v \\<in> B' \\<epsilon>\n  v \\<noteq> 0\n  v $ ?i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> B' \\<epsilon> - {0} \\<and> (\\<forall>i. v $ i \\<in> \\<int>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> B' \\<epsilon>\n  v \\<noteq> 0\n  v $ ?i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<in> B' \\<epsilon> - {0} \\<and> (\\<forall>i. v $ i \\<in> \\<int>)", "by blast"], ["proof (state)\nthis:\n  \\<exists>v.\n     v \\<in> B' \\<epsilon> - {0} \\<and> (\\<forall>i. v $ i \\<in> \\<int>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?\\<epsilon> \\<Longrightarrow>\n  \\<exists>v.\n     v \\<in> B' ?\\<epsilon> - {0} \\<and> (\\<forall>i. v $ i \\<in> \\<int>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"\\<forall>n. \\<exists>v. v \\<in> B' (1/Suc n) - {0} \\<and> (\\<forall>i. v $ i \\<in> \\<int>)\""], ["proof (prove)\nusing this:\n  0 < ?\\<epsilon> \\<Longrightarrow>\n  \\<exists>v.\n     v \\<in> B' ?\\<epsilon> - {0} \\<and> (\\<forall>i. v $ i \\<in> \\<int>)\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<exists>v.\n          v \\<in> B' (1 / real (Suc n)) - {0} \\<and>\n          (\\<forall>i. v $ i \\<in> \\<int>)", "by auto\n  \\<comment> \\<open>In particular, this means we can choose some sequence tending to zero\n      -- say $\\frac{1}{n+1}$ -- and always find a lattice point in the scaled set.\\<close>"], ["proof (state)\nthis:\n  \\<forall>n.\n     \\<exists>v.\n        v \\<in> B' (1 / real (Suc n)) - {0} \\<and>\n        (\\<forall>i. v $ i \\<in> \\<int>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"\\<exists>v. \\<forall>n. v n \\<in> B' (1/Suc n) - {0} \\<and> (\\<forall>i. v n $ i \\<in> \\<int>)\""], ["proof (prove)\nusing this:\n  \\<forall>n.\n     \\<exists>v.\n        v \\<in> B' (1 / real (Suc n)) - {0} \\<and>\n        (\\<forall>i. v $ i \\<in> \\<int>)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       \\<forall>n.\n          v n \\<in> B' (1 / real (Suc n)) - {0} \\<and>\n          (\\<forall>i. v n $ i \\<in> \\<int>)", "by (subst (asm) choice_iff)"], ["proof (state)\nthis:\n  \\<exists>v.\n     \\<forall>n.\n        v n \\<in> B' (1 / real (Suc n)) - {0} \\<and>\n        (\\<forall>i. v n $ i \\<in> \\<int>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>v.\n     \\<forall>n.\n        v n \\<in> B' (1 / real (Suc n)) - {0} \\<and>\n        (\\<forall>i. v n $ i \\<in> \\<int>)", "obtain v where v: \"v n \\<in> B' (1/Suc n) - {0}\" \"v n $ i \\<in> \\<int>\" for i n"], ["proof (prove)\nusing this:\n  \\<exists>v.\n     \\<forall>n.\n        v n \\<in> B' (1 / real (Suc n)) - {0} \\<and>\n        (\\<forall>i. v n $ i \\<in> \\<int>)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>\\<And>n. v n \\<in> B' (1 / real (Suc n)) - {0};\n         \\<And>i n. v n $ i \\<in> \\<int>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast\n\n  \\<comment> \\<open>By the Bolzano--Weierstra{\\ss} theorem, there exists a convergent subsequence of @{term v}.\\<close>"], ["proof (state)\nthis:\n  v ?n \\<in> B' (1 / real (Suc ?n)) - {0}\n  v ?n $ ?i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"\\<exists>h l. strict_mono (h::nat\\<Rightarrow>nat) \\<and> (v \\<circ> h) \\<longlonglongrightarrow> l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h l.\n       strict_mono h \\<and> (v \\<circ> h) \\<longlonglongrightarrow> l", "proof (rule compactD)"], ["proof (state)\ngoal (2 subgoals):\n 1. compact ?A\n 2. range v \\<subseteq> ?A", "show \"compact (B' 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compact (B' 1)", "by (rule compact')"], ["proof (state)\nthis:\n  compact (B' 1)\n\ngoal (1 subgoal):\n 1. range v \\<subseteq> B' 1", "show \"range v \\<subseteq> B' 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range v \\<subseteq> B' 1", "using B'_subset[of \"1/Suc n\" 1 for n] and v"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 \\<le> 1 / real (Suc ?n2); 1 / real (Suc ?n2) \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> B' (1 / real (Suc ?n2)) \\<subseteq> B' 1\n  v ?n \\<in> B' (1 / real (Suc ?n)) - {0}\n  v ?n $ ?i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. range v \\<subseteq> B' 1", "by auto"], ["proof (state)\nthis:\n  range v \\<subseteq> B' 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>h l.\n     strict_mono h \\<and> (v \\<circ> h) \\<longlonglongrightarrow> l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  \\<exists>h l.\n     strict_mono h \\<and> (v \\<circ> h) \\<longlonglongrightarrow> l", "obtain h l where h: \"strict_mono h\" and l: \"(v \\<circ> h) \\<longlonglongrightarrow> l\""], ["proof (prove)\nusing this:\n  \\<exists>h l.\n     strict_mono h \\<and> (v \\<circ> h) \\<longlonglongrightarrow> l\n\ngoal (1 subgoal):\n 1. (\\<And>h l.\n        \\<lbrakk>strict_mono h;\n         (v \\<circ> h) \\<longlonglongrightarrow> l\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast\n\n  \\<comment> \\<open>Since the convergent subsequence tends to @{term l}, the distance of the\n      sequence elements to @{term B} tends to the distance of @{term l} and @{term B}.\n      Furthermore, the distance of the sequence elements is bounded by $(1+\\varepsilon)C$,\n      which tends to 0, so the distance of @{term l} to @{term B} must be 0.\\<close>"], ["proof (state)\nthis:\n  strict_mono h\n  (v \\<circ> h) \\<longlonglongrightarrow> l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"setdist {l} B \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. setdist {l} B \\<le> 0", "proof (rule tendsto_le)"], ["proof (state)\ngoal (4 subgoals):\n 1. ?F \\<noteq> bot\n 2. (?f \\<longlongrightarrow> 0) ?F\n 3. (?g \\<longlongrightarrow> setdist {l} B) ?F\n 4. \\<forall>\\<^sub>F x in ?F. ?g x \\<le> ?f x", "show \"((\\<lambda>x. setdist {x} B) \\<circ> (v \\<circ> h)) \\<longlonglongrightarrow> setdist {l} B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. setdist {x} B) \\<circ> (v \\<circ> h))\n    \\<longlonglongrightarrow> setdist {l} B", "by (intro continuous_imp_tendsto l continuous_at_setdist)"], ["proof (state)\nthis:\n  ((\\<lambda>x. setdist {x} B) \\<circ> (v \\<circ> h))\n  \\<longlonglongrightarrow> setdist {l} B\n\ngoal (3 subgoals):\n 1. sequentially \\<noteq> bot\n 2. ?f \\<longlonglongrightarrow> 0\n 3. \\<forall>\\<^sub>F x in sequentially.\n       ((\\<lambda>x. setdist {x} B) \\<circ> (v \\<circ> h)) x \\<le> ?f x", "show \"(\\<lambda>n. inverse (Suc (h n)) * C) \\<longlonglongrightarrow> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. inverse (real (Suc (h n))) * C) \\<longlonglongrightarrow> 0", "by (intro tendsto_mult_left_zero filterlim_compose[OF _ filterlim_subseq[OF h]]\n                LIMSEQ_inverse_real_of_nat)"], ["proof (state)\nthis:\n  (\\<lambda>n. inverse (real (Suc (h n))) * C) \\<longlonglongrightarrow> 0\n\ngoal (2 subgoals):\n 1. sequentially \\<noteq> bot\n 2. \\<forall>\\<^sub>F x in sequentially.\n       ((\\<lambda>x. setdist {x} B) \\<circ> (v \\<circ> h)) x\n       \\<le> inverse (real (Suc (h x))) * C", "show \"\\<forall>\\<^sub>F x in sequentially. ((\\<lambda>x. setdist {x} B) \\<circ> (v \\<circ> h)) x\n                                  \\<le> inverse (real (Suc (h x))) * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in sequentially.\n       ((\\<lambda>x. setdist {x} B) \\<circ> (v \\<circ> h)) x\n       \\<le> inverse (real (Suc (h x))) * C", "using setdist_le and v"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> B' ?\\<epsilon>; 0 \\<le> ?\\<epsilon>\\<rbrakk>\n  \\<Longrightarrow> setdist {?x} B \\<le> ?\\<epsilon> * C\n  v ?n \\<in> B' (1 / real (Suc ?n)) - {0}\n  v ?n $ ?i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in sequentially.\n       ((\\<lambda>x. setdist {x} B) \\<circ> (v \\<circ> h)) x\n       \\<le> inverse (real (Suc (h x))) * C", "unfolding o_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> B' ?\\<epsilon>; 0 \\<le> ?\\<epsilon>\\<rbrakk>\n  \\<Longrightarrow> setdist {?x} B \\<le> ?\\<epsilon> * C\n  v ?n \\<in> B' (1 / real (Suc ?n)) - {0}\n  v ?n $ ?i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in sequentially.\n       setdist {v (h x)} B \\<le> inverse (real (Suc (h x))) * C", "by (intro always_eventually allI setdist_le) (auto simp: field_simps)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in sequentially.\n     ((\\<lambda>x. setdist {x} B) \\<circ> (v \\<circ> h)) x\n     \\<le> inverse (real (Suc (h x))) * C\n\ngoal (1 subgoal):\n 1. sequentially \\<noteq> bot", "qed auto"], ["proof (state)\nthis:\n  setdist {l} B \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"setdist {l} B = 0\""], ["proof (prove)\nusing this:\n  setdist {l} B \\<le> 0\n\ngoal (1 subgoal):\n 1. setdist {l} B = 0", "by (intro antisym setdist_pos_le)"], ["proof (state)\nthis:\n  setdist {l} B = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "with assms and \\<open>compact B\\<close>"], ["proof (chain)\npicking this:\n  convex B\n  compact B\n  uminus ` B \\<subseteq> B\n  2 ^ CARD('n) \\<le> emeasure lebesgue B\n  compact B\n  setdist {l} B = 0", "have \"l \\<in> B\""], ["proof (prove)\nusing this:\n  convex B\n  compact B\n  uminus ` B \\<subseteq> B\n  2 ^ CARD('n) \\<le> emeasure lebesgue B\n  compact B\n  setdist {l} B = 0\n\ngoal (1 subgoal):\n 1. l \\<in> B", "by (subst (asm) setdist_eq_0_closed) (auto intro: compact_imp_closed)\n\n  \\<comment> \\<open>It is also easy to see that, since the lattice is a closed set and all sequence\n      elements lie on it, the limit @{term l} also lies on it.\\<close>"], ["proof (state)\nthis:\n  l \\<in> B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  l \\<in> B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"l \\<in> {l. \\<forall>i. l $ i \\<in> \\<int>} - {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> {l. \\<forall>i. l $ i \\<in> \\<int>} - {0}", "using v"], ["proof (prove)\nusing this:\n  v ?n \\<in> B' (1 / real (Suc ?n)) - {0}\n  v ?n $ ?i \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. l \\<in> {l. \\<forall>i. l $ i \\<in> \\<int>} - {0}", "by (intro closed_sequentially[OF closed_lattice _ l]) auto"], ["proof (state)\nthis:\n  l \\<in> {l. \\<forall>i. l $ i \\<in> \\<int>} - {0}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x.\n                \\<lbrakk>x \\<in> B; x \\<noteq> 0;\n                 \\<And>i. x $ i \\<in> \\<int>\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     emeasure lebesgue B = 2 ^ CARD('n)\\<rbrakk>\n    \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  l \\<in> B\n  l \\<in> {l. \\<forall>i. l $ i \\<in> \\<int>} - {0}", "show ?thesis"], ["proof (prove)\nusing this:\n  l \\<in> B\n  l \\<in> {l. \\<forall>i. l $ i \\<in> \\<int>} - {0}\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  l \\<in> B\n  l \\<in> {l. \\<forall>i. l $ i \\<in> \\<int>} - {0}\n  \\<lbrakk>?x \\<in> B; ?x \\<noteq> 0; \\<And>i. ?x $ i \\<in> \\<int>\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}