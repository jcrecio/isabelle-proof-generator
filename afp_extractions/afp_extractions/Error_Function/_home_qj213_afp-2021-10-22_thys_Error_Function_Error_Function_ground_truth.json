{"file_name": "/home/qj213/afp-2021-10-22/thys/Error_Function/Error_Function.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Error_Function", "problem_names": ["lemma tendsto_sandwich_mono:\n  assumes \"(\\<lambda>n. f (real n)) \\<longlonglongrightarrow> (c::real)\"\n  assumes \"eventually (\\<lambda>x. \\<forall>y z. x \\<le> y \\<and> y \\<le> z \\<longrightarrow> f y \\<le> f z) at_top\"\n  shows   \"(f \\<longlongrightarrow> c) at_top\"", "lemma tendsto_sandwich_antimono:\n  assumes \"(\\<lambda>n. f (real n)) \\<longlonglongrightarrow> (c::real)\"\n  assumes \"eventually (\\<lambda>x. \\<forall>y z. x \\<le> y \\<and> y \\<le> z \\<longrightarrow> f y \\<ge> f z) at_top\"\n  shows   \"(f \\<longlongrightarrow> c) at_top\"", "lemma has_bochner_integral_completion [intro]:\n  fixes f :: \"'a \\<Rightarrow> 'b::{banach, second_countable_topology}\"\n  shows \"has_bochner_integral M f I \\<Longrightarrow> has_bochner_integral (completion M) f I\"", "lemma has_bochner_integral_imp_has_integral:\n  \"has_bochner_integral lebesgue (\\<lambda>x. indicator S x *\\<^sub>R f x) I \\<Longrightarrow> \n     (f has_integral (I :: 'b :: euclidean_space)) S\"", "lemma has_bochner_integral_imp_has_integral':\n  \"has_bochner_integral lborel (\\<lambda>x. indicator S x *\\<^sub>R f x) I \\<Longrightarrow> \n     (f has_integral (I :: 'b :: euclidean_space)) S\"", "lemma has_bochner_integral_erf_aux:\n  \"has_bochner_integral lborel (\\<lambda>x. indicator {0..} x *\\<^sub>R exp (- x\\<^sup>2)) (sqrt pi / 2)\"", "lemma has_integral_erf_aux: \"((\\<lambda>t::real. exp (-t\\<^sup>2)) has_integral (sqrt pi / 2)) {0..}\"", "lemma contour_integrable_on_linepath_neg_exp_squared [simp, intro]:\n  \"(\\<lambda>t. exp (-(t^2))) contour_integrable_on linepath 0 z\"", "lemma holomorphic_on_chain:\n  \"g holomorphic_on t \\<Longrightarrow> f holomorphic_on s \\<Longrightarrow> f ` s \\<subseteq> t \\<Longrightarrow> \n    (\\<lambda>x. g (f x)) holomorphic_on s\"", "lemma holomorphic_on_chain_UNIV:\n  \"g holomorphic_on UNIV \\<Longrightarrow> f holomorphic_on s\\<Longrightarrow> \n    (\\<lambda>x. g (f x)) holomorphic_on s\"", "lemmas holomorphic_on_exp' [holomorphic_intros] = \n  holomorphic_on_exp [THEN holomorphic_on_chain_UNIV]", "lemma leibniz_rule_field_derivative_real:\n  fixes f::\"'a::{real_normed_field, banach} \\<Rightarrow> real \\<Rightarrow> 'a\"\n  assumes fx: \"\\<And>x t. x \\<in> U \\<Longrightarrow> t \\<in> {a..b} \\<Longrightarrow> ((\\<lambda>x. f x t) has_field_derivative fx x t) (at x within U)\"\n  assumes integrable_f2: \"\\<And>x. x \\<in> U \\<Longrightarrow> (f x) integrable_on {a..b}\"\n  assumes cont_fx: \"continuous_on (U \\<times> {a..b}) (\\<lambda>(x, t). fx x t)\"\n  assumes U: \"x0 \\<in> U\" \"convex U\"\n  shows \"((\\<lambda>x. integral {a..b} (f x)) has_field_derivative integral {a..b} (fx x0)) (at x0 within U)\"", "lemma has_vector_derivative_linepath_within [derivative_intros]:\n  assumes [derivative_intros]: \n    \"(f has_vector_derivative f') (at x within S)\" \"(g has_vector_derivative g') (at x within S)\"\n    \"(h has_real_derivative h') (at x within S)\"\n  shows \"((\\<lambda>x. linepath (f x) (g x) (h x)) has_vector_derivative \n           (1 - h x) *\\<^sub>R f' + h x *\\<^sub>R g' - h' *\\<^sub>R (f x - g x)) (at x within S)\"", "lemma has_field_derivative_linepath_within [derivative_intros]:\n  assumes [derivative_intros]: \n    \"(f has_field_derivative f') (at x within S)\" \"(g has_field_derivative g') (at x within S)\"\n    \"(h has_real_derivative h') (at x within S)\"\n  shows \"((\\<lambda>x. linepath (f x) (g x) (h x)) has_field_derivative \n           (1 - h x) *\\<^sub>R f' + h x *\\<^sub>R g' - h' *\\<^sub>R (f x - g x)) (at x within S)\"", "lemma continuous_on_linepath' [continuous_intros]:\n  assumes [continuous_intros]: \"continuous_on A f\" \"continuous_on A g\" \"continuous_on A h\"\n  shows   \"continuous_on A (\\<lambda>x. linepath (f x) (g x) (h x))\"", "lemma contour_integral_has_field_derivative:\n  assumes A: \"open A\" \"convex A\" \"a \\<in> A\" \"z \\<in> A\"\n  assumes integrable: \"\\<And>z. z \\<in> A \\<Longrightarrow> f contour_integrable_on linepath a z\"\n  assumes holo: \"f holomorphic_on A\"\n  shows   \"((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative f z) (at z within B)\"", "lemma summable_erf:\n  fixes z :: \"'a :: {real_normed_div_algebra, banach}\"\n  shows \"summable (\\<lambda>n. of_real (erf_coeffs n) * z ^ n)\"", "lemma erf_converges: \"(\\<lambda>n. of_real (erf_coeffs n) * z ^ n) sums erf z\"", "lemma erf_0 [simp]: \"erf 0 = 0\"", "lemma erf_minus [simp]: \"erf (-z) = - erf z\"", "lemma erf_of_real [simp]: \"erf (of_real x) = of_real (erf x)\"", "lemma of_real_erf_numeral [simp]: \"of_real (erf (numeral n)) = erf (numeral n)\"", "lemma of_real_erf_1 [simp]: \"of_real (erf 1) = erf 1\"", "lemma erf_has_field_derivative:\n  \"(erf has_field_derivative of_real (2 / sqrt pi) * exp (-(z^2))) (at z within A)\"", "lemmas erf_has_field_derivative' [derivative_intros] =\n  erf_has_field_derivative [THEN DERIV_chain2]", "lemma erf_continuous_on: \"continuous_on A erf\"", "lemma continuous_on_compose2_UNIV:\n  \"continuous_on UNIV g \\<Longrightarrow> continuous_on s f \\<Longrightarrow> continuous_on s (\\<lambda>x. g (f x))\"", "lemmas erf_continuous_on' [continuous_intros] = \n  erf_continuous_on [THEN continuous_on_compose2_UNIV]", "lemma erf_continuous [continuous_intros]: \"continuous (at x within A) erf\"", "lemmas erf_continuous' [continuous_intros] = \n  continuous_within_compose2[OF _ erf_continuous]", "lemmas tendsto_erf [tendsto_intros] = isCont_tendsto_compose[OF erf_continuous]", "lemma erf_cnj [simp]: \"erf (cnj z) = cnj (erf z)\"", "lemma integral_exp_minus_squared_real:\n  assumes \"a \\<le> b\"\n  shows   \"((\\<lambda>t. exp (-(t^2))) has_integral (sqrt pi / 2 * (erf b - erf a))) {a..b}\"", "lemma erf_real_altdef_nonneg:\n  \"x \\<ge> 0 \\<Longrightarrow> erf (x::real) = 2 / sqrt pi * integral {0..x} (\\<lambda>t. exp (-(t^2)))\"", "lemma erf_real_altdef_nonpos:\n  \"x \\<le> 0 \\<Longrightarrow> erf (x::real) = -2 / sqrt pi * integral {0..-x} (\\<lambda>t. exp (-(t^2)))\"", "lemma less_imp_erf_real_less:\n  assumes \"a < (b::real)\"\n  shows   \"erf a < erf b\"", "lemma le_imp_erf_real_le: \"a \\<le> (b::real) \\<Longrightarrow> erf a \\<le> erf b\"", "lemma erf_real_less_cancel [simp]: \"(erf (a :: real) < erf b) \\<longleftrightarrow> a < b\"", "lemma erf_real_eq_iff [simp]: \"erf (a::real) = erf b \\<longleftrightarrow> a = b\"", "lemma erf_real_le_cancel [simp]: \"(erf (a :: real) \\<le> erf b) \\<longleftrightarrow> a \\<le> b\"", "lemma inj_on_erf_real [intro]: \"inj_on (erf :: real \\<Rightarrow> real) A\"", "lemma strict_mono_erf_real [intro]: \"strict_mono (erf :: real \\<Rightarrow> real)\"", "lemma mono_erf_real [intro]: \"mono (erf :: real \\<Rightarrow> real)\"", "lemma erf_real_ge_0_iff [simp]: \"erf (x::real) \\<ge> 0 \\<longleftrightarrow> x \\<ge> 0\"", "lemma erf_real_le_0_iff [simp]: \"erf (x::real) \\<le> 0 \\<longleftrightarrow> x \\<le> 0\"", "lemma erf_real_gt_0_iff [simp]: \"erf (x::real) > 0 \\<longleftrightarrow> x > 0\"", "lemma erf_real_less_0_iff [simp]: \"erf (x::real) < 0 \\<longleftrightarrow> x < 0\"", "lemma erf_at_top [tendsto_intros]: \"((erf :: real \\<Rightarrow> real) \\<longlongrightarrow> 1) at_top\"", "lemma erf_at_bot [tendsto_intros]: \"((erf :: real \\<Rightarrow> real) \\<longlongrightarrow> -1) at_bot\"", "lemmas tendsto_erf_at_top [tendsto_intros] = filterlim_compose[OF erf_at_top]", "lemmas tendsto_erf_at_bot [tendsto_intros] = filterlim_compose[OF erf_at_bot]", "lemma erf_conv_erfc: \"erf z = 1 - erfc z\"", "lemma erfc_0 [simp]: \"erfc 0 = 1\"", "lemma erfc_minus: \"erfc (-z) = 2 - erfc z\"", "lemma erfc_of_real [simp]: \"erfc (of_real x) = of_real (erfc x)\"", "lemma of_real_erfc_numeral [simp]: \"of_real (erfc (numeral n)) = erfc (numeral n)\"", "lemma of_real_erfc_1 [simp]: \"of_real (erfc 1) = erfc 1\"", "lemma less_imp_erfc_real_less: \"a < (b::real) \\<Longrightarrow> erfc a > erfc b\"", "lemma le_imp_erfc_real_le: \"a \\<le> (b::real) \\<Longrightarrow> erfc a \\<ge> erfc b\"", "lemma erfc_real_less_cancel [simp]: \"(erfc (a :: real) < erfc b) \\<longleftrightarrow> a > b\"", "lemma erfc_real_eq_iff [simp]: \"erfc (a::real) = erfc b \\<longleftrightarrow> a = b\"", "lemma erfc_real_le_cancel [simp]: \"(erfc (a :: real) \\<le> erfc b) \\<longleftrightarrow> a \\<ge> b\"", "lemma inj_on_erfc_real [intro]: \"inj_on (erfc :: real \\<Rightarrow> real) A\"", "lemma antimono_erfc_real [intro]: \"antimono (erfc :: real \\<Rightarrow> real)\"", "lemma erfc_real_ge_0_iff [simp]: \"erfc (x::real) \\<ge> 1 \\<longleftrightarrow> x \\<le> 0\"", "lemma erfc_real_le_0_iff [simp]: \"erfc (x::real) \\<le> 1 \\<longleftrightarrow> x \\<ge> 0\"", "lemma erfc_real_gt_0_iff [simp]: \"erfc (x::real) > 1 \\<longleftrightarrow> x < 0\"", "lemma erfc_real_less_0_iff [simp]: \"erfc (x::real) < 1 \\<longleftrightarrow> x > 0\"", "lemma erfc_has_field_derivative:\n  \"(erfc has_field_derivative -of_real (2 / sqrt pi) * exp (-(z^2))) (at z within A)\"", "lemmas erfc_has_field_derivative' [derivative_intros] =\n  erfc_has_field_derivative [THEN DERIV_chain2]", "lemma erfc_continuous_on: \"continuous_on A erfc\"", "lemmas erfc_continuous_on' [continuous_intros] = \n  erfc_continuous_on [THEN continuous_on_compose2_UNIV]", "lemma erfc_continuous [continuous_intros]: \"continuous (at x within A) erfc\"", "lemmas erfc_continuous' [continuous_intros] = \n  continuous_within_compose2[OF _ erfc_continuous]", "lemmas tendsto_erfc [tendsto_intros] = isCont_tendsto_compose[OF erfc_continuous]", "lemma erfc_at_top [tendsto_intros]: \"((erfc :: real \\<Rightarrow> real) \\<longlongrightarrow> 0) at_top\"", "lemma erfc_at_bot [tendsto_intros]: \"((erfc :: real \\<Rightarrow> real) \\<longlongrightarrow> 2) at_bot\"", "lemmas tendsto_erfc_at_top [tendsto_intros] = filterlim_compose[OF erfc_at_top]", "lemmas tendsto_erfc_at_bot [tendsto_intros] = filterlim_compose[OF erfc_at_bot]", "lemma integrable_exp_minus_squared:\n  assumes \"A \\<subseteq> {0..}\" \"A \\<in> sets lborel\"\n  shows   \"set_integrable lborel A (\\<lambda>t::real. exp (-t\\<^sup>2))\" (is ?thesis1)\n    and   \"(\\<lambda>t::real. exp (-t\\<^sup>2)) integrable_on A\" (is ?thesis2)", "lemma\n  assumes \"x \\<ge> 0\"\n  shows   erfc_real_altdef_nonneg: \"erfc x = 2 / sqrt pi * integral {x..} (\\<lambda>t. exp (-t\\<^sup>2))\"\n    and   has_integral_erfc:       \"((\\<lambda>t. exp (-t\\<^sup>2)) has_integral (sqrt pi / 2 * erfc x)) {x..}\"", "lemma erfc_real_gt_0 [simp, intro]: \"erfc (x::real) > 0\"", "lemma erfc_real_less_2 [intro]: \"erfc (x::real) < 2\"", "lemma erf_real_gt_neg1 [intro]: \"erf (x::real) > -1\"", "lemma erf_real_less_1 [intro]: \"erf (x::real) < 1\"", "lemma erfc_cnj [simp]: \"erfc (cnj z) = cnj (erfc z)\"", "lemma erf_complex_altdef:\n  \"erf z = of_real (2 / sqrt pi) * contour_integral (linepath 0 z) (\\<lambda>t. exp (-(t^2)))\"", "lemma erf_holomorphic_on: \"erf holomorphic_on A\"", "lemmas erf_holomorphic_on' [holomorphic_intros] = \n  erf_holomorphic_on [THEN holomorphic_on_chain_UNIV]", "lemma erf_analytic_on: \"erf analytic_on A\"", "lemma erf_analytic_on'  [analytic_intros]:\n  assumes \"f analytic_on A\"\n  shows   \"(\\<lambda>x. erf (f x)) analytic_on A\"", "lemma erfc_holomorphic_on: \"erfc holomorphic_on A\"", "lemmas erfc_holomorphic_on' [holomorphic_intros] = \n  erfc_holomorphic_on [THEN holomorphic_on_chain_UNIV]", "lemma erfc_analytic_on: \"erfc analytic_on A\"", "lemma erfc_analytic_on' [analytic_intros]:\n  assumes \"f analytic_on A\"\n  shows   \"(\\<lambda>x. erfc (f x)) analytic_on A\""], "translations": [["", "lemma tendsto_sandwich_mono:\n  assumes \"(\\<lambda>n. f (real n)) \\<longlonglongrightarrow> (c::real)\"\n  assumes \"eventually (\\<lambda>x. \\<forall>y z. x \\<le> y \\<and> y \\<le> z \\<longrightarrow> f y \\<le> f z) at_top\"\n  shows   \"(f \\<longlongrightarrow> c) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> c) at_top", "proof (rule tendsto_sandwich)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in at_top. ?f n \\<le> f n\n 2. \\<forall>\\<^sub>F n in at_top. f n \\<le> ?h n\n 3. (?f \\<longlongrightarrow> c) at_top\n 4. (?h \\<longlongrightarrow> c) at_top", "from assms(2)"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_top.\n     \\<forall>y z.\n        x \\<le> y \\<and> y \\<le> z \\<longrightarrow> f y \\<le> f z", "obtain C where C: \"\\<And>x y. C \\<le> x \\<Longrightarrow> x \\<le> y \\<Longrightarrow> f x \\<le> f y\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top.\n     \\<forall>y z.\n        x \\<le> y \\<and> y \\<le> z \\<longrightarrow> f y \\<le> f z\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        (\\<And>x y.\n            \\<lbrakk>C \\<le> x; x \\<le> y\\<rbrakk>\n            \\<Longrightarrow> f x \\<le> f y) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: eventually_at_top_linorder)"], ["proof (state)\nthis:\n  \\<lbrakk>C \\<le> ?x; ?x \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> f ?x \\<le> f ?y\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in at_top. ?f n \\<le> f n\n 2. \\<forall>\\<^sub>F n in at_top. f n \\<le> ?h n\n 3. (?f \\<longlongrightarrow> c) at_top\n 4. (?h \\<longlongrightarrow> c) at_top", "show \"eventually (\\<lambda>x. f (real (nat \\<lfloor>x\\<rfloor>)) \\<le> f x) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       f (real (nat \\<lfloor>x\\<rfloor>)) \\<le> f x", "using eventually_gt_at_top[of \"0::real\"] eventually_gt_at_top[of \"C+1::real\"]"], ["proof (prove)\nusing this:\n  eventually ((<) 0) at_top\n  eventually ((<) (C + 1)) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       f (real (nat \\<lfloor>x\\<rfloor>)) \\<le> f x", "by eventually_elim (rule C, linarith+)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top.\n     f (real (nat \\<lfloor>x\\<rfloor>)) \\<le> f x\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in at_top. f n \\<le> ?h n\n 2. ((\\<lambda>x. f (real (nat \\<lfloor>x\\<rfloor>))) \\<longlongrightarrow>\n     c)\n     at_top\n 3. (?h \\<longlongrightarrow> c) at_top", "show \"eventually (\\<lambda>x. f (real (Suc (nat \\<lfloor>x\\<rfloor>))) \\<ge> f x) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       f x \\<le> f (real (Suc (nat \\<lfloor>x\\<rfloor>)))", "using eventually_gt_at_top[of \"0::real\"] eventually_gt_at_top[of \"C+1::real\"]"], ["proof (prove)\nusing this:\n  eventually ((<) 0) at_top\n  eventually ((<) (C + 1)) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       f x \\<le> f (real (Suc (nat \\<lfloor>x\\<rfloor>)))", "by eventually_elim (rule C, linarith+)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top.\n     f x \\<le> f (real (Suc (nat \\<lfloor>x\\<rfloor>)))\n\ngoal (2 subgoals):\n 1. ((\\<lambda>x. f (real (nat \\<lfloor>x\\<rfloor>))) \\<longlongrightarrow>\n     c)\n     at_top\n 2. ((\\<lambda>x.\n         f (real (Suc (nat \\<lfloor>x\\<rfloor>)))) \\<longlongrightarrow>\n     c)\n     at_top", "qed (auto intro!: filterlim_compose[OF assms(1)]\n                  filterlim_compose[OF filterlim_nat_sequentially]\n                  filterlim_compose[OF filterlim_Suc] filterlim_floor_sequentially\n          simp del: of_nat_Suc)"], ["", "lemma tendsto_sandwich_antimono:\n  assumes \"(\\<lambda>n. f (real n)) \\<longlonglongrightarrow> (c::real)\"\n  assumes \"eventually (\\<lambda>x. \\<forall>y z. x \\<le> y \\<and> y \\<le> z \\<longrightarrow> f y \\<ge> f z) at_top\"\n  shows   \"(f \\<longlongrightarrow> c) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<longlongrightarrow> c) at_top", "proof (rule tendsto_sandwich)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in at_top. ?f n \\<le> f n\n 2. \\<forall>\\<^sub>F n in at_top. f n \\<le> ?h n\n 3. (?f \\<longlongrightarrow> c) at_top\n 4. (?h \\<longlongrightarrow> c) at_top", "from assms(2)"], ["proof (chain)\npicking this:\n  \\<forall>\\<^sub>F x in at_top.\n     \\<forall>y z.\n        x \\<le> y \\<and> y \\<le> z \\<longrightarrow> f z \\<le> f y", "obtain C where C: \"\\<And>x y. C \\<le> x \\<Longrightarrow> x \\<le> y \\<Longrightarrow> f x \\<ge> f y\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F x in at_top.\n     \\<forall>y z.\n        x \\<le> y \\<and> y \\<le> z \\<longrightarrow> f z \\<le> f y\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        (\\<And>x y.\n            \\<lbrakk>C \\<le> x; x \\<le> y\\<rbrakk>\n            \\<Longrightarrow> f y \\<le> f x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: eventually_at_top_linorder)"], ["proof (state)\nthis:\n  \\<lbrakk>C \\<le> ?x; ?x \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> f ?y \\<le> f ?x\n\ngoal (4 subgoals):\n 1. \\<forall>\\<^sub>F n in at_top. ?f n \\<le> f n\n 2. \\<forall>\\<^sub>F n in at_top. f n \\<le> ?h n\n 3. (?f \\<longlongrightarrow> c) at_top\n 4. (?h \\<longlongrightarrow> c) at_top", "show \"eventually (\\<lambda>x. f (real (nat \\<lfloor>x\\<rfloor>)) \\<ge> f x) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       f x \\<le> f (real (nat \\<lfloor>x\\<rfloor>))", "using eventually_gt_at_top[of \"0::real\"] eventually_gt_at_top[of \"C+1::real\"]"], ["proof (prove)\nusing this:\n  eventually ((<) 0) at_top\n  eventually ((<) (C + 1)) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       f x \\<le> f (real (nat \\<lfloor>x\\<rfloor>))", "by eventually_elim (rule C, linarith+)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top.\n     f x \\<le> f (real (nat \\<lfloor>x\\<rfloor>))\n\ngoal (3 subgoals):\n 1. \\<forall>\\<^sub>F n in at_top. ?f n \\<le> f n\n 2. (?f \\<longlongrightarrow> c) at_top\n 3. ((\\<lambda>x. f (real (nat \\<lfloor>x\\<rfloor>))) \\<longlongrightarrow>\n     c)\n     at_top", "show \"eventually (\\<lambda>x. f (real (Suc (nat \\<lfloor>x\\<rfloor>))) \\<le> f x) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       f (real (Suc (nat \\<lfloor>x\\<rfloor>))) \\<le> f x", "using eventually_gt_at_top[of \"0::real\"] eventually_gt_at_top[of \"C+1::real\"]"], ["proof (prove)\nusing this:\n  eventually ((<) 0) at_top\n  eventually ((<) (C + 1)) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F x in at_top.\n       f (real (Suc (nat \\<lfloor>x\\<rfloor>))) \\<le> f x", "by eventually_elim (rule C, linarith+)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F x in at_top.\n     f (real (Suc (nat \\<lfloor>x\\<rfloor>))) \\<le> f x\n\ngoal (2 subgoals):\n 1. ((\\<lambda>x.\n         f (real (Suc (nat \\<lfloor>x\\<rfloor>)))) \\<longlongrightarrow>\n     c)\n     at_top\n 2. ((\\<lambda>x. f (real (nat \\<lfloor>x\\<rfloor>))) \\<longlongrightarrow>\n     c)\n     at_top", "qed (auto intro!: filterlim_compose[OF assms(1)]\n                  filterlim_compose[OF filterlim_nat_sequentially]\n                  filterlim_compose[OF filterlim_Suc] filterlim_floor_sequentially\n          simp del: of_nat_Suc)"], ["", "lemma has_bochner_integral_completion [intro]:\n  fixes f :: \"'a \\<Rightarrow> 'b::{banach, second_countable_topology}\"\n  shows \"has_bochner_integral M f I \\<Longrightarrow> has_bochner_integral (completion M) f I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_bochner_integral M f I \\<Longrightarrow>\n    has_bochner_integral (completion M) f I", "by (auto simp: has_bochner_integral_iff integrable_completion integral_completion \n                 borel_measurable_integrable)"], ["", "lemma has_bochner_integral_imp_has_integral:\n  \"has_bochner_integral lebesgue (\\<lambda>x. indicator S x *\\<^sub>R f x) I \\<Longrightarrow> \n     (f has_integral (I :: 'b :: euclidean_space)) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_bochner_integral lebesgue\n     (\\<lambda>x. indicat_real S x *\\<^sub>R f x) I \\<Longrightarrow>\n    (f has_integral I) S", "using has_integral_set_lebesgue[of S f]"], ["proof (prove)\nusing this:\n  f absolutely_integrable_on S \\<Longrightarrow>\n  (f has_integral set_lebesgue_integral lebesgue S f) S\n\ngoal (1 subgoal):\n 1. has_bochner_integral lebesgue\n     (\\<lambda>x. indicat_real S x *\\<^sub>R f x) I \\<Longrightarrow>\n    (f has_integral I) S", "by (simp add: has_bochner_integral_iff set_integrable_def set_lebesgue_integral_def)"], ["", "lemma has_bochner_integral_imp_has_integral':\n  \"has_bochner_integral lborel (\\<lambda>x. indicator S x *\\<^sub>R f x) I \\<Longrightarrow> \n     (f has_integral (I :: 'b :: euclidean_space)) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_bochner_integral lborel (\\<lambda>x. indicat_real S x *\\<^sub>R f x)\n     I \\<Longrightarrow>\n    (f has_integral I) S", "by (intro has_bochner_integral_imp_has_integral has_bochner_integral_completion)"], ["", "lemma has_bochner_integral_erf_aux:\n  \"has_bochner_integral lborel (\\<lambda>x. indicator {0..} x *\\<^sub>R exp (- x\\<^sup>2)) (sqrt pi / 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "let ?pI = \"\\<lambda>f. (\\<integral>\\<^sup>+s. f (s::real) * indicator {0..} s \\<partial>lborel)\""], ["proof (state)\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "let ?gauss = \"\\<lambda>x. exp (- x\\<^sup>2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "let ?I = \"indicator {0<..} :: real \\<Rightarrow> real\""], ["proof (state)\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "let ?ff= \"\\<lambda>x s. x * exp (- x\\<^sup>2 * (1 + s\\<^sup>2)) :: real\""], ["proof (state)\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "have *: \"?pI ?gauss = (\\<integral>\\<^sup>+x. ?gauss x * ?I x \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (exp (- x\\<^sup>2) * indicat_real {0<..} x)\n                       \\<partial>lborel", "by (intro nn_integral_cong_AE AE_I[where N=\"{0}\"]) (auto split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+ x. ennreal (exp (- x\\<^sup>2) * indicat_real {0<..} x)\n                     \\<partial>lborel\n\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "have \"?pI ?gauss * ?pI ?gauss = (\\<integral>\\<^sup>+x. \\<integral>\\<^sup>+s. ?gauss x * ?gauss s * ?I s * ?I x \\<partial>lborel \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n     \\<partial>lborel) *\n    (\\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n     \\<partial>lborel) =\n    \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ xa.\n          ennreal\n           (exp (- x\\<^sup>2) * exp (- xa\\<^sup>2) *\n            indicat_real {0<..} xa *\n            indicat_real {0<..} x)\n        \\<partial>lborel\n                       \\<partial>lborel", "by (auto simp: nn_integral_cmult[symmetric] nn_integral_multc[symmetric] * \n                   ennreal_mult[symmetric] intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n   \\<partial>lborel) *\n  (\\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n   \\<partial>lborel) =\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ xa.\n        ennreal\n         (exp (- x\\<^sup>2) * exp (- xa\\<^sup>2) * indicat_real {0<..} xa *\n          indicat_real {0<..} x)\n      \\<partial>lborel\n                     \\<partial>lborel\n\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "also"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n   \\<partial>lborel) *\n  (\\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n   \\<partial>lborel) =\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ xa.\n        ennreal\n         (exp (- x\\<^sup>2) * exp (- xa\\<^sup>2) * indicat_real {0<..} xa *\n          indicat_real {0<..} x)\n      \\<partial>lborel\n                     \\<partial>lborel\n\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "have \"\\<dots> = (\\<integral>\\<^sup>+x. \\<integral>\\<^sup>+s. ?ff x s * ?I s * ?I x \\<partial>lborel \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ xa.\n          ennreal\n           (exp (- x\\<^sup>2) * exp (- xa\\<^sup>2) *\n            indicat_real {0<..} xa *\n            indicat_real {0<..} x)\n        \\<partial>lborel\n                       \\<partial>lborel =\n    \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ xa.\n          ennreal\n           (x * exp (- x\\<^sup>2 * (1 + xa\\<^sup>2)) *\n            indicat_real {0<..} xa *\n            indicat_real {0<..} x)\n        \\<partial>lborel\n                       \\<partial>lborel", "proof (rule nn_integral_cong, cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; ?P2 x\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+ xa.\n        ennreal\n         (exp (- x\\<^sup>2) * exp (- xa\\<^sup>2) * indicat_real {0<..} xa *\n          indicat_real {0<..} x)\n      \\<partial>lborel =\n                         \\<integral>\\<^sup>+ xa.\n        ennreal\n         (x * exp (- x\\<^sup>2 * (1 + xa\\<^sup>2)) *\n          indicat_real {0<..} xa *\n          indicat_real {0<..} x)\n      \\<partial>lborel\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; \\<not> ?P2 x\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+ xa.\n        ennreal\n         (exp (- x\\<^sup>2) * exp (- xa\\<^sup>2) * indicat_real {0<..} xa *\n          indicat_real {0<..} x)\n      \\<partial>lborel =\n                         \\<integral>\\<^sup>+ xa.\n        ennreal\n         (x * exp (- x\\<^sup>2 * (1 + xa\\<^sup>2)) *\n          indicat_real {0<..} xa *\n          indicat_real {0<..} x)\n      \\<partial>lborel", "fix x :: real"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; ?P2 x\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+ xa.\n        ennreal\n         (exp (- x\\<^sup>2) * exp (- xa\\<^sup>2) * indicat_real {0<..} xa *\n          indicat_real {0<..} x)\n      \\<partial>lborel =\n                         \\<integral>\\<^sup>+ xa.\n        ennreal\n         (x * exp (- x\\<^sup>2 * (1 + xa\\<^sup>2)) *\n          indicat_real {0<..} xa *\n          indicat_real {0<..} x)\n      \\<partial>lborel\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; \\<not> ?P2 x\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+ xa.\n        ennreal\n         (exp (- x\\<^sup>2) * exp (- xa\\<^sup>2) * indicat_real {0<..} xa *\n          indicat_real {0<..} x)\n      \\<partial>lborel =\n                         \\<integral>\\<^sup>+ xa.\n        ennreal\n         (x * exp (- x\\<^sup>2 * (1 + xa\\<^sup>2)) *\n          indicat_real {0<..} xa *\n          indicat_real {0<..} x)\n      \\<partial>lborel", "assume \"x \\<noteq> 0\""], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; ?P2 x\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+ xa.\n        ennreal\n         (exp (- x\\<^sup>2) * exp (- xa\\<^sup>2) * indicat_real {0<..} xa *\n          indicat_real {0<..} x)\n      \\<partial>lborel =\n                         \\<integral>\\<^sup>+ xa.\n        ennreal\n         (x * exp (- x\\<^sup>2 * (1 + xa\\<^sup>2)) *\n          indicat_real {0<..} xa *\n          indicat_real {0<..} x)\n      \\<partial>lborel\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; \\<not> ?P2 x\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+ xa.\n        ennreal\n         (exp (- x\\<^sup>2) * exp (- xa\\<^sup>2) * indicat_real {0<..} xa *\n          indicat_real {0<..} x)\n      \\<partial>lborel =\n                         \\<integral>\\<^sup>+ xa.\n        ennreal\n         (x * exp (- x\\<^sup>2 * (1 + xa\\<^sup>2)) *\n          indicat_real {0<..} xa *\n          indicat_real {0<..} x)\n      \\<partial>lborel", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> 0", "show \"(\\<integral>\\<^sup>+s. ?gauss x * ?gauss s * ?I s * ?I x \\<partial>lborel) =\n                 (\\<integral>\\<^sup>+s. ?ff x s * ?I s * ?I x \\<partial>lborel)\""], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ xa. ennreal\n                             (exp (- x\\<^sup>2) * exp (- xa\\<^sup>2) *\n                              indicat_real {0<..} xa *\n                              indicat_real {0<..} x)\n                       \\<partial>lborel =\n    \\<integral>\\<^sup>+ xa. ennreal\n                             (x * exp (- x\\<^sup>2 * (1 + xa\\<^sup>2)) *\n                              indicat_real {0<..} xa *\n                              indicat_real {0<..} x)\n                       \\<partial>lborel", "by (subst nn_integral_real_affine[where t=\"0\" and c=\"x\"])\n         (auto simp: mult_exp_exp nn_integral_cmult[symmetric] field_simps zero_less_mult_iff ennreal_mult[symmetric]\n               intro!: nn_integral_cong split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ xa. ennreal\n                           (exp (- x\\<^sup>2) * exp (- xa\\<^sup>2) *\n                            indicat_real {0<..} xa *\n                            indicat_real {0<..} x)\n                     \\<partial>lborel =\n  \\<integral>\\<^sup>+ xa. ennreal\n                           (x * exp (- x\\<^sup>2 * (1 + xa\\<^sup>2)) *\n                            indicat_real {0<..} xa *\n                            indicat_real {0<..} x)\n                     \\<partial>lborel\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; \\<not> x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+ xa.\n        ennreal\n         (exp (- x\\<^sup>2) * exp (- xa\\<^sup>2) * indicat_real {0<..} xa *\n          indicat_real {0<..} x)\n      \\<partial>lborel =\n                         \\<integral>\\<^sup>+ xa.\n        ennreal\n         (x * exp (- x\\<^sup>2 * (1 + xa\\<^sup>2)) *\n          indicat_real {0<..} xa *\n          indicat_real {0<..} x)\n      \\<partial>lborel", "qed simp"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ xa.\n        ennreal\n         (exp (- x\\<^sup>2) * exp (- xa\\<^sup>2) * indicat_real {0<..} xa *\n          indicat_real {0<..} x)\n      \\<partial>lborel\n                     \\<partial>lborel =\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ xa.\n        ennreal\n         (x * exp (- x\\<^sup>2 * (1 + xa\\<^sup>2)) *\n          indicat_real {0<..} xa *\n          indicat_real {0<..} x)\n      \\<partial>lborel\n                     \\<partial>lborel\n\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ xa.\n        ennreal\n         (exp (- x\\<^sup>2) * exp (- xa\\<^sup>2) * indicat_real {0<..} xa *\n          indicat_real {0<..} x)\n      \\<partial>lborel\n                     \\<partial>lborel =\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ xa.\n        ennreal\n         (x * exp (- x\\<^sup>2 * (1 + xa\\<^sup>2)) *\n          indicat_real {0<..} xa *\n          indicat_real {0<..} x)\n      \\<partial>lborel\n                     \\<partial>lborel\n\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "have \"... = \\<integral>\\<^sup>+s. \\<integral>\\<^sup>+x. ?ff x s * ?I s * ?I x \\<partial>lborel \\<partial>lborel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ xa.\n          ennreal\n           (x * exp (- x\\<^sup>2 * (1 + xa\\<^sup>2)) *\n            indicat_real {0<..} xa *\n            indicat_real {0<..} x)\n        \\<partial>lborel\n                       \\<partial>lborel =\n    \\<integral>\\<^sup>+ s. \\<integral>\\<^sup>+ x.\n          ennreal\n           (x * exp (- x\\<^sup>2 * (1 + s\\<^sup>2)) *\n            indicat_real {0<..} s *\n            indicat_real {0<..} x)\n        \\<partial>lborel\n                       \\<partial>lborel", "by (rule lborel_pair.Fubini'[symmetric]) auto"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ xa.\n        ennreal\n         (x * exp (- x\\<^sup>2 * (1 + xa\\<^sup>2)) *\n          indicat_real {0<..} xa *\n          indicat_real {0<..} x)\n      \\<partial>lborel\n                     \\<partial>lborel =\n  \\<integral>\\<^sup>+ s. \\<integral>\\<^sup>+ x.\n        ennreal\n         (x * exp (- x\\<^sup>2 * (1 + s\\<^sup>2)) * indicat_real {0<..} s *\n          indicat_real {0<..} x)\n      \\<partial>lborel\n                     \\<partial>lborel\n\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ x. \\<integral>\\<^sup>+ xa.\n        ennreal\n         (x * exp (- x\\<^sup>2 * (1 + xa\\<^sup>2)) *\n          indicat_real {0<..} xa *\n          indicat_real {0<..} x)\n      \\<partial>lborel\n                     \\<partial>lborel =\n  \\<integral>\\<^sup>+ s. \\<integral>\\<^sup>+ x.\n        ennreal\n         (x * exp (- x\\<^sup>2 * (1 + s\\<^sup>2)) * indicat_real {0<..} s *\n          indicat_real {0<..} x)\n      \\<partial>lborel\n                     \\<partial>lborel\n\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "have \"... = ?pI (\\<lambda>s. ?pI (\\<lambda>x. ?ff x s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+ s. \\<integral>\\<^sup>+ x.\n          ennreal\n           (x * exp (- x\\<^sup>2 * (1 + s\\<^sup>2)) *\n            indicat_real {0<..} s *\n            indicat_real {0<..} x)\n        \\<partial>lborel\n                       \\<partial>lborel =\n    \\<integral>\\<^sup>+s\\<in>{0..}.\n                       (\\<integral>\\<^sup>+sa\\<in>{0..}.\n     ennreal (sa * exp (- sa\\<^sup>2 * (1 + s\\<^sup>2)))\n                        \\<partial>lborel)\n    \\<partial>lborel", "by (rule nn_integral_cong_AE)\n       (auto intro!: nn_integral_cong_AE AE_I[where N=\"{0}\"] split: split_indicator_asm)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ s. \\<integral>\\<^sup>+ x.\n        ennreal\n         (x * exp (- x\\<^sup>2 * (1 + s\\<^sup>2)) * indicat_real {0<..} s *\n          indicat_real {0<..} x)\n      \\<partial>lborel\n                     \\<partial>lborel =\n  \\<integral>\\<^sup>+s\\<in>{0..}.\n                     (\\<integral>\\<^sup>+sa\\<in>{0..}.\n   ennreal (sa * exp (- sa\\<^sup>2 * (1 + s\\<^sup>2)))\n                      \\<partial>lborel)\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+ s. \\<integral>\\<^sup>+ x.\n        ennreal\n         (x * exp (- x\\<^sup>2 * (1 + s\\<^sup>2)) * indicat_real {0<..} s *\n          indicat_real {0<..} x)\n      \\<partial>lborel\n                     \\<partial>lborel =\n  \\<integral>\\<^sup>+s\\<in>{0..}.\n                     (\\<integral>\\<^sup>+sa\\<in>{0..}.\n   ennreal (sa * exp (- sa\\<^sup>2 * (1 + s\\<^sup>2)))\n                      \\<partial>lborel)\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "have \"\\<dots> = ?pI (\\<lambda>s. ennreal (1 / (2 * (1 + s\\<^sup>2))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+s\\<in>{0..}.\n                       (\\<integral>\\<^sup>+sa\\<in>{0..}.\n     ennreal (sa * exp (- sa\\<^sup>2 * (1 + s\\<^sup>2)))\n                        \\<partial>lborel)\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+s\\<in>{0..}. ennreal (1 / (2 * (1 + s\\<^sup>2)))\n    \\<partial>lborel", "proof (intro nn_integral_cong ennreal_mult_right_cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; indicator {0..} x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+s\\<in>{0..}.\n      ennreal (s * exp (- s\\<^sup>2 * (1 + x\\<^sup>2)))\n                         \\<partial>lborel =\n                         ennreal (1 / (2 * (1 + x\\<^sup>2)))", "fix s :: real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> space lborel; indicator {0..} x \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> \\<integral>\\<^sup>+s\\<in>{0..}.\n      ennreal (s * exp (- s\\<^sup>2 * (1 + x\\<^sup>2)))\n                         \\<partial>lborel =\n                         ennreal (1 / (2 * (1 + x\\<^sup>2)))", "show \"?pI (\\<lambda>x. ?ff x s) = ennreal (1 / (2 * (1 + s\\<^sup>2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+sa\\<in>{0..}.\n                       ennreal (sa * exp (- sa\\<^sup>2 * (1 + s\\<^sup>2)))\n    \\<partial>lborel =\n    ennreal (1 / (2 * (1 + s\\<^sup>2)))", "proof (subst nn_integral_FTC_atLeast)"], ["proof (state)\ngoal (5 subgoals):\n 1. (\\<lambda>sa. sa * exp (- sa\\<^sup>2 * (1 + s\\<^sup>2)))\n    \\<in> borel_measurable borel\n 2. \\<And>x.\n       0 \\<le> x \\<Longrightarrow>\n       (?F has_real_derivative x * exp (- x\\<^sup>2 * (1 + s\\<^sup>2)))\n        (at x)\n 3. \\<And>x.\n       0 \\<le> x \\<Longrightarrow>\n       0 \\<le> x * exp (- x\\<^sup>2 * (1 + s\\<^sup>2))\n 4. (?F \\<longlongrightarrow> ?T) at_top\n 5. ennreal (?T - ?F 0) = ennreal (1 / (2 * (1 + s\\<^sup>2)))", "have \"((\\<lambda>a. - (exp (- ((1 + s\\<^sup>2) * a\\<^sup>2)) / (2 + 2 * s\\<^sup>2))) \\<longlongrightarrow> (- (0 / (2 + 2 * s\\<^sup>2)))) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>a.\n         - (exp (- ((1 + s\\<^sup>2) * a\\<^sup>2)) /\n            (2 + 2 * s\\<^sup>2))) \\<longlongrightarrow>\n     - (0 / (2 + 2 * s\\<^sup>2)))\n     at_top", "by (intro tendsto_intros filterlim_compose[OF exp_at_bot]\n                  filterlim_compose[OF filterlim_uminus_at_bot_at_top]\n                  filterlim_tendsto_pos_mult_at_top)\n           (auto intro!: filterlim_at_top_mult_at_top[OF filterlim_ident filterlim_ident]\n                 simp: add_pos_nonneg  power2_eq_square add_nonneg_eq_0_iff)"], ["proof (state)\nthis:\n  ((\\<lambda>a.\n       - (exp (- ((1 + s\\<^sup>2) * a\\<^sup>2)) /\n          (2 + 2 * s\\<^sup>2))) \\<longlongrightarrow>\n   - (0 / (2 + 2 * s\\<^sup>2)))\n   at_top\n\ngoal (5 subgoals):\n 1. (\\<lambda>sa. sa * exp (- sa\\<^sup>2 * (1 + s\\<^sup>2)))\n    \\<in> borel_measurable borel\n 2. \\<And>x.\n       0 \\<le> x \\<Longrightarrow>\n       (?F has_real_derivative x * exp (- x\\<^sup>2 * (1 + s\\<^sup>2)))\n        (at x)\n 3. \\<And>x.\n       0 \\<le> x \\<Longrightarrow>\n       0 \\<le> x * exp (- x\\<^sup>2 * (1 + s\\<^sup>2))\n 4. (?F \\<longlongrightarrow> ?T) at_top\n 5. ennreal (?T - ?F 0) = ennreal (1 / (2 * (1 + s\\<^sup>2)))", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>a.\n       - (exp (- ((1 + s\\<^sup>2) * a\\<^sup>2)) /\n          (2 + 2 * s\\<^sup>2))) \\<longlongrightarrow>\n   - (0 / (2 + 2 * s\\<^sup>2)))\n   at_top", "show \"((\\<lambda>a. - (exp (- a\\<^sup>2 - s\\<^sup>2 * a\\<^sup>2) / (2 + 2 * s\\<^sup>2))) \\<longlongrightarrow> 0) at_top\""], ["proof (prove)\nusing this:\n  ((\\<lambda>a.\n       - (exp (- ((1 + s\\<^sup>2) * a\\<^sup>2)) /\n          (2 + 2 * s\\<^sup>2))) \\<longlongrightarrow>\n   - (0 / (2 + 2 * s\\<^sup>2)))\n   at_top\n\ngoal (1 subgoal):\n 1. ((\\<lambda>a.\n         - (exp (- a\\<^sup>2 - s\\<^sup>2 * a\\<^sup>2) /\n            (2 + 2 * s\\<^sup>2))) \\<longlongrightarrow>\n     0)\n     at_top", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  ((\\<lambda>a.\n       - (exp (- a\\<^sup>2 - s\\<^sup>2 * a\\<^sup>2) /\n          (2 + 2 * s\\<^sup>2))) \\<longlongrightarrow>\n   0)\n   at_top\n\ngoal (4 subgoals):\n 1. (\\<lambda>sa. sa * exp (- sa\\<^sup>2 * (1 + s\\<^sup>2)))\n    \\<in> borel_measurable borel\n 2. \\<And>x.\n       0 \\<le> x \\<Longrightarrow>\n       ((\\<lambda>a.\n            - (exp (- a\\<^sup>2 - s\\<^sup>2 * a\\<^sup>2) /\n               (2 + 2 * s\\<^sup>2))) has_real_derivative\n        x * exp (- x\\<^sup>2 * (1 + s\\<^sup>2)))\n        (at x)\n 3. \\<And>x.\n       0 \\<le> x \\<Longrightarrow>\n       0 \\<le> x * exp (- x\\<^sup>2 * (1 + s\\<^sup>2))\n 4. ennreal\n     (0 -\n      - (exp (- 0\\<^sup>2 - s\\<^sup>2 * 0\\<^sup>2) / (2 + 2 * s\\<^sup>2))) =\n    ennreal (1 / (2 * (1 + s\\<^sup>2)))", "qed (auto intro!: derivative_eq_intros simp: field_simps add_nonneg_eq_0_iff)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+sa\\<in>{0..}.\n                     ennreal (sa * exp (- sa\\<^sup>2 * (1 + s\\<^sup>2)))\n  \\<partial>lborel =\n  ennreal (1 / (2 * (1 + s\\<^sup>2)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+s\\<in>{0..}.\n                     (\\<integral>\\<^sup>+sa\\<in>{0..}.\n   ennreal (sa * exp (- sa\\<^sup>2 * (1 + s\\<^sup>2)))\n                      \\<partial>lborel)\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+s\\<in>{0..}. ennreal (1 / (2 * (1 + s\\<^sup>2)))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+s\\<in>{0..}.\n                     (\\<integral>\\<^sup>+sa\\<in>{0..}.\n   ennreal (sa * exp (- sa\\<^sup>2 * (1 + s\\<^sup>2)))\n                      \\<partial>lborel)\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+s\\<in>{0..}. ennreal (1 / (2 * (1 + s\\<^sup>2)))\n  \\<partial>lborel\n\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "have \"... = ennreal (pi / 4)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+s\\<in>{0..}. ennreal (1 / (2 * (1 + s\\<^sup>2)))\n    \\<partial>lborel =\n    ennreal (pi / 4)", "proof (subst nn_integral_FTC_atLeast)"], ["proof (state)\ngoal (5 subgoals):\n 1. (\\<lambda>s. 1 / (2 * (1 + s\\<^sup>2))) \\<in> borel_measurable borel\n 2. \\<And>x.\n       0 \\<le> x \\<Longrightarrow>\n       (?F has_real_derivative 1 / (2 * (1 + x\\<^sup>2))) (at x)\n 3. \\<And>x. 0 \\<le> x \\<Longrightarrow> 0 \\<le> 1 / (2 * (1 + x\\<^sup>2))\n 4. (?F \\<longlongrightarrow> ?T) at_top\n 5. ennreal (?T - ?F 0) = ennreal (pi / 4)", "show \"((\\<lambda>a. arctan a / 2) \\<longlongrightarrow> (pi / 2) / 2 ) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>a. arctan a / 2) \\<longlongrightarrow> pi / 2 / 2) at_top", "by (intro tendsto_intros) (simp_all add: tendsto_arctan_at_top)"], ["proof (state)\nthis:\n  ((\\<lambda>a. arctan a / 2) \\<longlongrightarrow> pi / 2 / 2) at_top\n\ngoal (4 subgoals):\n 1. (\\<lambda>s. 1 / (2 * (1 + s\\<^sup>2))) \\<in> borel_measurable borel\n 2. \\<And>x.\n       0 \\<le> x \\<Longrightarrow>\n       ((\\<lambda>a. arctan a / 2) has_real_derivative\n        1 / (2 * (1 + x\\<^sup>2)))\n        (at x)\n 3. \\<And>x. 0 \\<le> x \\<Longrightarrow> 0 \\<le> 1 / (2 * (1 + x\\<^sup>2))\n 4. ennreal (pi / 2 / 2 - arctan 0 / 2) = ennreal (pi / 4)", "qed (auto intro!: derivative_eq_intros simp: add_nonneg_eq_0_iff field_simps power2_eq_square)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+s\\<in>{0..}. ennreal (1 / (2 * (1 + s\\<^sup>2)))\n  \\<partial>lborel =\n  ennreal (pi / 4)\n\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "finally"], ["proof (chain)\npicking this:\n  (\\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n   \\<partial>lborel) *\n  (\\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n   \\<partial>lborel) =\n  ennreal (pi / 4)", "have \"?pI ?gauss^2 = pi / 4\""], ["proof (prove)\nusing this:\n  (\\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n   \\<partial>lborel) *\n  (\\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n   \\<partial>lborel) =\n  ennreal (pi / 4)\n\ngoal (1 subgoal):\n 1. (\\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n     \\<partial>lborel)\\<^sup>2 =\n    ennreal (pi / 4)", "by (simp add: power2_eq_square)"], ["proof (state)\nthis:\n  (\\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n   \\<partial>lborel)\\<^sup>2 =\n  ennreal (pi / 4)\n\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "then"], ["proof (chain)\npicking this:\n  (\\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n   \\<partial>lborel)\\<^sup>2 =\n  ennreal (pi / 4)", "have \"?pI ?gauss = sqrt (pi / 4)\""], ["proof (prove)\nusing this:\n  (\\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n   \\<partial>lborel)\\<^sup>2 =\n  ennreal (pi / 4)\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n    \\<partial>lborel =\n    ennreal (sqrt (pi / 4))", "using power_eq_iff_eq_base[of 2 \"enn2real (?pI ?gauss)\" \"sqrt (pi / 4)\"]"], ["proof (prove)\nusing this:\n  (\\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n   \\<partial>lborel)\\<^sup>2 =\n  ennreal (pi / 4)\n  \\<lbrakk>0 < 2;\n   0 \\<le> enn2real\n            (\\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n             \\<partial>lborel);\n   0 \\<le> sqrt (pi / 4)\\<rbrakk>\n  \\<Longrightarrow> ((enn2real\n                       (\\<integral>\\<^sup>+s\\<in>{0..}.\n     ennreal (exp (- s\\<^sup>2))\n                        \\<partial>lborel))\\<^sup>2 =\n                     (sqrt (pi / 4))\\<^sup>2) =\n                    (enn2real\n                      (\\<integral>\\<^sup>+s\\<in>{0..}.\n    ennreal (exp (- s\\<^sup>2))\n                       \\<partial>lborel) =\n                     sqrt (pi / 4))\n\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n    \\<partial>lborel =\n    ennreal (sqrt (pi / 4))", "by (cases \"?pI ?gauss\") (auto simp: power2_eq_square ennreal_mult[symmetric] ennreal_top_mult)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n  \\<partial>lborel =\n  ennreal (sqrt (pi / 4))\n\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n  \\<partial>lborel =\n  ennreal (sqrt (pi / 4))\n\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "have \"?pI ?gauss = (\\<integral>\\<^sup>+x. indicator {0..} x *\\<^sub>R exp (- x\\<^sup>2) \\<partial>lborel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n    \\<partial>lborel =\n    \\<integral>\\<^sup>+ x. ennreal\n                            (indicat_real {0..} x *\\<^sub>R\n                             exp (- x\\<^sup>2))\n                       \\<partial>lborel", "by (intro nn_integral_cong) (simp split: split_indicator)"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n                     \\<partial>lborel\n\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "also"], ["proof (state)\nthis:\n  \\<integral>\\<^sup>+s\\<in>{0..}. ennreal (exp (- s\\<^sup>2))\n  \\<partial>lborel =\n  \\<integral>\\<^sup>+ x. ennreal\n                          (indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n                     \\<partial>lborel\n\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "have \"sqrt (pi / 4) = sqrt pi / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqrt (pi / 4) = sqrt pi / 2", "by (simp add: real_sqrt_divide)"], ["proof (state)\nthis:\n  sqrt (pi / 4) = sqrt pi / 2\n\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "finally"], ["proof (chain)\npicking this:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n                     \\<partial>lborel =\n  ennreal (sqrt pi / 2)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<integral>\\<^sup>+ x. ennreal\n                          (indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n                     \\<partial>lborel =\n  ennreal (sqrt pi / 2)\n\ngoal (1 subgoal):\n 1. has_bochner_integral lborel\n     (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n     (sqrt pi / 2)", "by (rule has_bochner_integral_nn_integral[rotated 3])\n       auto"], ["proof (state)\nthis:\n  has_bochner_integral lborel\n   (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n   (sqrt pi / 2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_integral_erf_aux: \"((\\<lambda>t::real. exp (-t\\<^sup>2)) has_integral (sqrt pi / 2)) {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral sqrt pi / 2) {0..}", "by (intro has_bochner_integral_imp_has_integral' has_bochner_integral_erf_aux)"], ["", "lemma contour_integrable_on_linepath_neg_exp_squared [simp, intro]:\n  \"(\\<lambda>t. exp (-(t^2))) contour_integrable_on linepath 0 z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t. exp (- t\\<^sup>2)) contour_integrable_on linepath 0 z", "by (auto intro!: contour_integrable_continuous_linepath continuous_intros)"], ["", "lemma holomorphic_on_chain:\n  \"g holomorphic_on t \\<Longrightarrow> f holomorphic_on s \\<Longrightarrow> f ` s \\<subseteq> t \\<Longrightarrow> \n    (\\<lambda>x. g (f x)) holomorphic_on s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g holomorphic_on t; f holomorphic_on s;\n     f ` s \\<subseteq> t\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. g (f x)) holomorphic_on s", "using holomorphic_on_compose_gen[of f s g t]"], ["proof (prove)\nusing this:\n  \\<lbrakk>f holomorphic_on s; g holomorphic_on t;\n   f ` s \\<subseteq> t\\<rbrakk>\n  \\<Longrightarrow> g \\<circ> f holomorphic_on s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g holomorphic_on t; f holomorphic_on s;\n     f ` s \\<subseteq> t\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. g (f x)) holomorphic_on s", "by (simp add: o_def)"], ["", "lemma holomorphic_on_chain_UNIV:\n  \"g holomorphic_on UNIV \\<Longrightarrow> f holomorphic_on s\\<Longrightarrow> \n    (\\<lambda>x. g (f x)) holomorphic_on s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g holomorphic_on UNIV; f holomorphic_on s\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. g (f x)) holomorphic_on s", "using holomorphic_on_compose_gen[of f s g UNIV]"], ["proof (prove)\nusing this:\n  \\<lbrakk>f holomorphic_on s; g holomorphic_on UNIV;\n   f ` s \\<subseteq> UNIV\\<rbrakk>\n  \\<Longrightarrow> g \\<circ> f holomorphic_on s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g holomorphic_on UNIV; f holomorphic_on s\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. g (f x)) holomorphic_on s", "by (simp add: o_def)"], ["", "lemmas holomorphic_on_exp' [holomorphic_intros] = \n  holomorphic_on_exp [THEN holomorphic_on_chain_UNIV]"], ["", "lemma leibniz_rule_field_derivative_real:\n  fixes f::\"'a::{real_normed_field, banach} \\<Rightarrow> real \\<Rightarrow> 'a\"\n  assumes fx: \"\\<And>x t. x \\<in> U \\<Longrightarrow> t \\<in> {a..b} \\<Longrightarrow> ((\\<lambda>x. f x t) has_field_derivative fx x t) (at x within U)\"\n  assumes integrable_f2: \"\\<And>x. x \\<in> U \\<Longrightarrow> (f x) integrable_on {a..b}\"\n  assumes cont_fx: \"continuous_on (U \\<times> {a..b}) (\\<lambda>(x, t). fx x t)\"\n  assumes U: \"x0 \\<in> U\" \"convex U\"\n  shows \"((\\<lambda>x. integral {a..b} (f x)) has_field_derivative integral {a..b} (fx x0)) (at x0 within U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. integral {a..b} (f x)) has_field_derivative\n     integral {a..b} (fx x0))\n     (at x0 within U)", "using leibniz_rule_field_derivative[of U a b f fx x0] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x t.\n              \\<lbrakk>x \\<in> U; t \\<in> cbox a b\\<rbrakk>\n              \\<Longrightarrow> ((\\<lambda>x. f x t) has_field_derivative\n                                 fx x t)\n                                 (at x within U);\n   \\<And>x. x \\<in> U \\<Longrightarrow> f x integrable_on cbox a b;\n   continuous_on (U \\<times> cbox a b) (\\<lambda>(x, t). fx x t);\n   x0 \\<in> U; convex U\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x.\n                         integral (cbox a b) (f x)) has_field_derivative\n                     integral (cbox a b) (fx x0))\n                     (at x0 within U)\n  \\<lbrakk>?x \\<in> U; ?t \\<in> {a..b}\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x. f x ?t) has_field_derivative fx ?x ?t)\n                     (at ?x within U)\n  ?x \\<in> U \\<Longrightarrow> f ?x integrable_on {a..b}\n  continuous_on (U \\<times> {a..b}) (\\<lambda>(x, t). fx x t)\n  x0 \\<in> U\n  convex U\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. integral {a..b} (f x)) has_field_derivative\n     integral {a..b} (fx x0))\n     (at x0 within U)", "by simp"], ["", "lemma has_vector_derivative_linepath_within [derivative_intros]:\n  assumes [derivative_intros]: \n    \"(f has_vector_derivative f') (at x within S)\" \"(g has_vector_derivative g') (at x within S)\"\n    \"(h has_real_derivative h') (at x within S)\"\n  shows \"((\\<lambda>x. linepath (f x) (g x) (h x)) has_vector_derivative \n           (1 - h x) *\\<^sub>R f' + h x *\\<^sub>R g' - h' *\\<^sub>R (f x - g x)) (at x within S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. linepath (f x) (g x) (h x)) has_vector_derivative\n     (1 - h x) *\\<^sub>R f' + h x *\\<^sub>R g' - h' *\\<^sub>R (f x - g x))\n     (at x within S)", "unfolding linepath_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (1 - h x) *\\<^sub>R f x + h x *\\<^sub>R g x) has_vector_derivative\n     (1 - h x) *\\<^sub>R f' + h x *\\<^sub>R g' - h' *\\<^sub>R (f x - g x))\n     (at x within S)", "by (auto intro!: derivative_eq_intros simp: field_simps scaleR_diff_right)"], ["", "lemma has_field_derivative_linepath_within [derivative_intros]:\n  assumes [derivative_intros]: \n    \"(f has_field_derivative f') (at x within S)\" \"(g has_field_derivative g') (at x within S)\"\n    \"(h has_real_derivative h') (at x within S)\"\n  shows \"((\\<lambda>x. linepath (f x) (g x) (h x)) has_field_derivative \n           (1 - h x) *\\<^sub>R f' + h x *\\<^sub>R g' - h' *\\<^sub>R (f x - g x)) (at x within S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. linepath (f x) (g x) (h x)) has_real_derivative\n     (1 - h x) *\\<^sub>R f' + h x *\\<^sub>R g' - h' *\\<^sub>R (f x - g x))\n     (at x within S)", "unfolding linepath_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         (1 - h x) *\\<^sub>R f x + h x *\\<^sub>R g x) has_real_derivative\n     (1 - h x) *\\<^sub>R f' + h x *\\<^sub>R g' - h' *\\<^sub>R (f x - g x))\n     (at x within S)", "by (auto intro!: derivative_eq_intros simp: field_simps scaleR_diff_right)"], ["", "lemma continuous_on_linepath' [continuous_intros]:\n  assumes [continuous_intros]: \"continuous_on A f\" \"continuous_on A g\" \"continuous_on A h\"\n  shows   \"continuous_on A (\\<lambda>x. linepath (f x) (g x) (h x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on A (\\<lambda>x. linepath (f x) (g x) (h x))", "using assms"], ["proof (prove)\nusing this:\n  continuous_on A f\n  continuous_on A g\n  continuous_on A h\n\ngoal (1 subgoal):\n 1. continuous_on A (\\<lambda>x. linepath (f x) (g x) (h x))", "unfolding linepath_def"], ["proof (prove)\nusing this:\n  continuous_on A f\n  continuous_on A g\n  continuous_on A h\n\ngoal (1 subgoal):\n 1. continuous_on A\n     (\\<lambda>x. (1 - h x) *\\<^sub>R f x + h x *\\<^sub>R g x)", "by (auto intro!: continuous_intros)"], ["", "lemma contour_integral_has_field_derivative:\n  assumes A: \"open A\" \"convex A\" \"a \\<in> A\" \"z \\<in> A\"\n  assumes integrable: \"\\<And>z. z \\<in> A \\<Longrightarrow> f contour_integrable_on linepath a z\"\n  assumes holo: \"f holomorphic_on A\"\n  shows   \"((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative f z) (at z within B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative\n     f z)\n     (at z within B)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative\n     f z)\n     (at z within B)", "have \"(f has_field_derivative deriv f z) (at z)\" if \"z \\<in> A\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f has_field_derivative deriv f z) (at z)", "using that assms"], ["proof (prove)\nusing this:\n  z \\<in> A\n  open A\n  convex A\n  a \\<in> A\n  z \\<in> A\n  ?z \\<in> A \\<Longrightarrow> f contour_integrable_on linepath a ?z\n  f holomorphic_on A\n\ngoal (1 subgoal):\n 1. (f has_field_derivative deriv f z) (at z)", "by (auto intro!: holomorphic_derivI)"], ["proof (state)\nthis:\n  ?z \\<in> A \\<Longrightarrow> (f has_field_derivative deriv f ?z) (at ?z)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative\n     f z)\n     (at z within B)", "note [derivative_intros] = DERIV_chain2[OF this]"], ["proof (state)\nthis:\n  \\<lbrakk>?g ?x \\<in> A;\n   (?g has_field_derivative ?Db) (at ?x within ?s)\\<rbrakk>\n  \\<Longrightarrow> ((\\<lambda>x. f (?g x)) has_field_derivative\n                     deriv f (?g ?x) * ?Db)\n                     (at ?x within ?s)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative\n     f z)\n     (at z within B)", "note [continuous_intros] = \n    continuous_on_compose2[OF holomorphic_on_imp_continuous_on [OF holo]]\n    continuous_on_compose2[OF holomorphic_on_imp_continuous_on [OF holomorphic_deriv[OF holo]]]"], ["proof (state)\nthis:\n  \\<lbrakk>continuous_on ?s ?f; ?f ` ?s \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> continuous_on ?s (\\<lambda>x. f (?f x))\n  \\<lbrakk>open A; continuous_on ?s ?f; ?f ` ?s \\<subseteq> A\\<rbrakk>\n  \\<Longrightarrow> continuous_on ?s (\\<lambda>x. deriv f (?f x))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative\n     f z)\n     (at z within B)", "have [derivative_intros]:\n      \"((\\<lambda>x. linepath a x t) has_field_derivative of_real t) (at x within A)\" for t x"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. linepath a x t) has_field_derivative complex_of_real t)\n     (at x within A)", "by (auto simp: linepath_def scaleR_conv_of_real intro!: derivative_eq_intros)"], ["proof (state)\nthis:\n  ((\\<lambda>x. linepath a x ?t) has_field_derivative complex_of_real ?t)\n   (at ?x within A)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative\n     f z)\n     (at z within B)", "have *: \"linepath a b t \\<in> A\" if \"a \\<in> A\" \"b \\<in> A\" \"t \\<in> {0..1}\" for a b t"], ["proof (prove)\ngoal (1 subgoal):\n 1. linepath a b t \\<in> A", "using that linepath_in_convex_hull[of a A b t] \\<open>convex A\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> A\n  b \\<in> A\n  t \\<in> {0..1}\n  \\<lbrakk>a \\<in> convex hull A; b \\<in> convex hull A; 0 \\<le> t;\n   t \\<le> 1\\<rbrakk>\n  \\<Longrightarrow> linepath a b t \\<in> convex hull A\n  convex A\n\ngoal (1 subgoal):\n 1. linepath a b t \\<in> A", "by (simp add: hull_same)"], ["proof (state)\nthis:\n  \\<lbrakk>?a \\<in> A; ?b \\<in> A; ?t \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> linepath ?a ?b ?t \\<in> A\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative\n     f z)\n     (at z within B)", "have \"((\\<lambda>z. integral {0..1} (\\<lambda>x. f (linepath a z x)) * (z - a)) has_field_derivative \n      integral {0..1} (\\<lambda>t. deriv f (linepath a z t) * of_real t) * (z - a) +\n      integral {0..1} (\\<lambda>x. f (linepath a z x))) (at z within A)\" \n      (is \"(_ has_field_derivative ?I) _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>z.\n         integral {0..1} (\\<lambda>x. f (linepath a z x)) *\n         (z - a)) has_field_derivative\n     integral {0..1}\n      (\\<lambda>t. deriv f (linepath a z t) * complex_of_real t) *\n     (z - a) +\n     integral {0..1} (\\<lambda>x. f (linepath a z x)))\n     (at z within A)", "by (rule derivative_eq_intros leibniz_rule_field_derivative_real)+\n       (insert assms,\n        auto intro!: derivative_eq_intros leibniz_rule_field_derivative_real\n                     integrable_continuous_real continuous_intros \n             simp:   split_beta scaleR_conv_of_real *)"], ["proof (state)\nthis:\n  ((\\<lambda>z.\n       integral {0..1} (\\<lambda>x. f (linepath a z x)) *\n       (z - a)) has_field_derivative\n   integral {0..1}\n    (\\<lambda>t. deriv f (linepath a z t) * complex_of_real t) *\n   (z - a) +\n   integral {0..1} (\\<lambda>x. f (linepath a z x)))\n   (at z within A)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative\n     f z)\n     (at z within B)", "also"], ["proof (state)\nthis:\n  ((\\<lambda>z.\n       integral {0..1} (\\<lambda>x. f (linepath a z x)) *\n       (z - a)) has_field_derivative\n   integral {0..1}\n    (\\<lambda>t. deriv f (linepath a z t) * complex_of_real t) *\n   (z - a) +\n   integral {0..1} (\\<lambda>x. f (linepath a z x)))\n   (at z within A)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative\n     f z)\n     (at z within B)", "have \"(\\<lambda>z. integral {0..1} (\\<lambda>x. f (linepath a z x)) * (z - a)) = \n               (\\<lambda>z. contour_integral (linepath a z) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>z.\n        integral {0..1} (\\<lambda>x. f (linepath a z x)) * (z - a)) =\n    (\\<lambda>z. contour_integral (linepath a z) f)", "by (simp add: contour_integral_integral)"], ["proof (state)\nthis:\n  (\\<lambda>z. integral {0..1} (\\<lambda>x. f (linepath a z x)) * (z - a)) =\n  (\\<lambda>z. contour_integral (linepath a z) f)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative\n     f z)\n     (at z within B)", "also"], ["proof (state)\nthis:\n  (\\<lambda>z. integral {0..1} (\\<lambda>x. f (linepath a z x)) * (z - a)) =\n  (\\<lambda>z. contour_integral (linepath a z) f)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative\n     f z)\n     (at z within B)", "have \"?I = integral {0..1} (\\<lambda>x. deriv f (linepath a z x) * of_real x * (z - a) + \n                     f (linepath a z x))\" (is \"_ = integral _ ?g\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>t. deriv f (linepath a z t) * complex_of_real t) *\n    (z - a) +\n    integral {0..1} (\\<lambda>x. f (linepath a z x)) =\n    integral {0..1}\n     (\\<lambda>x.\n         deriv f (linepath a z x) * complex_of_real x * (z - a) +\n         f (linepath a z x))", "by (subst integral_mult_left [symmetric], subst integral_add [symmetric])\n       (insert assms, auto intro!: integrable_continuous_real continuous_intros simp: *)"], ["proof (state)\nthis:\n  integral {0..1}\n   (\\<lambda>t. deriv f (linepath a z t) * complex_of_real t) *\n  (z - a) +\n  integral {0..1} (\\<lambda>x. f (linepath a z x)) =\n  integral {0..1}\n   (\\<lambda>x.\n       deriv f (linepath a z x) * complex_of_real x * (z - a) +\n       f (linepath a z x))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative\n     f z)\n     (at z within B)", "also"], ["proof (state)\nthis:\n  integral {0..1}\n   (\\<lambda>t. deriv f (linepath a z t) * complex_of_real t) *\n  (z - a) +\n  integral {0..1} (\\<lambda>x. f (linepath a z x)) =\n  integral {0..1}\n   (\\<lambda>x.\n       deriv f (linepath a z x) * complex_of_real x * (z - a) +\n       f (linepath a z x))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative\n     f z)\n     (at z within B)", "have \"(?g has_integral of_real 1 * f (linepath a z 1) - of_real 0 * f (linepath a z 0)) {0..1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         deriv f (linepath a z x) * complex_of_real x * (z - a) +\n         f (linepath a z x)) has_integral\n     complex_of_real 1 * f (linepath a z 1) -\n     complex_of_real 0 * f (linepath a z 0))\n     {0..1}", "using * A"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> A; ?b \\<in> A; ?t \\<in> {0..1}\\<rbrakk>\n  \\<Longrightarrow> linepath ?a ?b ?t \\<in> A\n  open A\n  convex A\n  a \\<in> A\n  z \\<in> A\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x.\n         deriv f (linepath a z x) * complex_of_real x * (z - a) +\n         f (linepath a z x)) has_integral\n     complex_of_real 1 * f (linepath a z 1) -\n     complex_of_real 0 * f (linepath a z 0))\n     {0..1}", "by (intro fundamental_theorem_of_calculus)\n       (auto intro!: derivative_eq_intros has_vector_derivative_real_field \n             simp: linepath_def scaleR_conv_of_real)"], ["proof (state)\nthis:\n  ((\\<lambda>x.\n       deriv f (linepath a z x) * complex_of_real x * (z - a) +\n       f (linepath a z x)) has_integral\n   complex_of_real 1 * f (linepath a z 1) -\n   complex_of_real 0 * f (linepath a z 0))\n   {0..1}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative\n     f z)\n     (at z within B)", "hence \"integral {0..1} ?g = f (linepath a z 1)\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x.\n       deriv f (linepath a z x) * complex_of_real x * (z - a) +\n       f (linepath a z x)) has_integral\n   complex_of_real 1 * f (linepath a z 1) -\n   complex_of_real 0 * f (linepath a z 0))\n   {0..1}\n\ngoal (1 subgoal):\n 1. integral {0..1}\n     (\\<lambda>x.\n         deriv f (linepath a z x) * complex_of_real x * (z - a) +\n         f (linepath a z x)) =\n    f (linepath a z 1)", "by (simp add: has_integral_iff)"], ["proof (state)\nthis:\n  integral {0..1}\n   (\\<lambda>x.\n       deriv f (linepath a z x) * complex_of_real x * (z - a) +\n       f (linepath a z x)) =\n  f (linepath a z 1)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative\n     f z)\n     (at z within B)", "also"], ["proof (state)\nthis:\n  integral {0..1}\n   (\\<lambda>x.\n       deriv f (linepath a z x) * complex_of_real x * (z - a) +\n       f (linepath a z x)) =\n  f (linepath a z 1)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative\n     f z)\n     (at z within B)", "have \"linepath a z 1 = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linepath a z 1 = z", "by (simp add: linepath_def)"], ["proof (state)\nthis:\n  linepath a z 1 = z\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative\n     f z)\n     (at z within B)", "also"], ["proof (state)\nthis:\n  linepath a z 1 = z\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative\n     f z)\n     (at z within B)", "from \\<open>z \\<in> A\\<close> and \\<open>open A\\<close>"], ["proof (chain)\npicking this:\n  z \\<in> A\n  open A", "have \"at z within A = at z\""], ["proof (prove)\nusing this:\n  z \\<in> A\n  open A\n\ngoal (1 subgoal):\n 1. at z within A = at z", "by (rule at_within_open)"], ["proof (state)\nthis:\n  at z within A = at z\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative\n     f z)\n     (at z within B)", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative f z)\n   (at z)", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative f z)\n   (at z)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative\n     f z)\n     (at z within B)", "by (rule DERIV_subset) simp_all"], ["proof (state)\nthis:\n  ((\\<lambda>z. contour_integral (linepath a z) f) has_field_derivative f z)\n   (at z within B)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Definition of the error function\\<close>"], ["", "definition erf_coeffs :: \"nat \\<Rightarrow> real\" where\n  \"erf_coeffs n = \n     (if odd n then 2 / sqrt pi * (-1) ^ (n div 2) / (of_nat n * fact (n div 2)) \n      else 0)\""], ["", "lemma summable_erf:\n  fixes z :: \"'a :: {real_normed_div_algebra, banach}\"\n  shows \"summable (\\<lambda>n. of_real (erf_coeffs n) * z ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. of_real (erf_coeffs n) * z ^ n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. of_real (erf_coeffs n) * z ^ n)", "define b where \"b = (\\<lambda>n. 2 / sqrt pi * (if odd n then inverse (fact (n div 2)) else 0))\""], ["proof (state)\nthis:\n  b =\n  (\\<lambda>n.\n      2 / sqrt pi * (if odd n then inverse (fact (n div 2)) else 0))\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. of_real (erf_coeffs n) * z ^ n)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. of_real (erf_coeffs n) * z ^ n)", "proof (rule summable_comparison_test[OF exI[of _ 1]], clarify)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       1 \\<le> n \\<Longrightarrow>\n       norm (of_real (erf_coeffs n) * z ^ n) \\<le> ?g n\n 2. summable ?g", "fix n :: nat"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       1 \\<le> n \\<Longrightarrow>\n       norm (of_real (erf_coeffs n) * z ^ n) \\<le> ?g n\n 2. summable ?g", "assume n: \"n \\<ge> 1\""], ["proof (state)\nthis:\n  1 \\<le> n\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       1 \\<le> n \\<Longrightarrow>\n       norm (of_real (erf_coeffs n) * z ^ n) \\<le> ?g n\n 2. summable ?g", "hence \"norm (of_real (erf_coeffs n) * z ^ n) \\<le> b n * norm z ^ n\""], ["proof (prove)\nusing this:\n  1 \\<le> n\n\ngoal (1 subgoal):\n 1. norm (of_real (erf_coeffs n) * z ^ n) \\<le> b n * norm z ^ n", "unfolding norm_mult norm_power erf_coeffs_def b_def"], ["proof (prove)\nusing this:\n  1 \\<le> n\n\ngoal (1 subgoal):\n 1. norm\n     (of_real\n       (if odd n\n        then 2 / sqrt pi * (- 1) ^ (n div 2) / (real n * fact (n div 2))\n        else 0)) *\n    norm z ^ n\n    \\<le> 2 / sqrt pi * (if odd n then inverse (fact (n div 2)) else 0) *\n          norm z ^ n", "by (intro mult_right_mono) (auto simp: field_simps norm_divide abs_mult)"], ["proof (state)\nthis:\n  norm (of_real (erf_coeffs n) * z ^ n) \\<le> b n * norm z ^ n\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       1 \\<le> n \\<Longrightarrow>\n       norm (of_real (erf_coeffs n) * z ^ n) \\<le> ?g n\n 2. summable ?g", "thus \"norm (of_real (erf_coeffs n) * z ^ n) \\<le> b n * norm z ^ n\""], ["proof (prove)\nusing this:\n  norm (of_real (erf_coeffs n) * z ^ n) \\<le> b n * norm z ^ n\n\ngoal (1 subgoal):\n 1. norm (of_real (erf_coeffs n) * z ^ n) \\<le> b n * norm z ^ n", "by (simp add: mult_ac)"], ["proof (state)\nthis:\n  norm (of_real (erf_coeffs n) * z ^ n) \\<le> b n * norm z ^ n\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. b n * norm z ^ n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. b n * norm z ^ n)", "have \"summable (\\<lambda>n. (norm z * 2 / sqrt pi) * (inverse (fact n) * norm z ^ (2*n)))\" \n      (is \"summable ?c\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. summable\n     (\\<lambda>n.\n         norm z * 2 / sqrt pi * (inverse (fact n) * norm z ^ (2 * n)))", "unfolding power_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. summable\n     (\\<lambda>n.\n         norm z * 2 / sqrt pi * (inverse (fact n) * (norm z)\\<^sup>2 ^ n))", "by (intro summable_mult summable_exp)"], ["proof (state)\nthis:\n  summable\n   (\\<lambda>n.\n       norm z * 2 / sqrt pi * (inverse (fact n) * norm z ^ (2 * n)))\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. b n * norm z ^ n)", "also"], ["proof (state)\nthis:\n  summable\n   (\\<lambda>n.\n       norm z * 2 / sqrt pi * (inverse (fact n) * norm z ^ (2 * n)))\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. b n * norm z ^ n)", "have \"?c = (\\<lambda>n. b (2*n+1) * norm z ^ (2*n+1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        norm z * 2 / sqrt pi * (inverse (fact n) * norm z ^ (2 * n))) =\n    (\\<lambda>n. b (2 * n + 1) * norm z ^ (2 * n + 1))", "unfolding b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n.\n        norm z * 2 / sqrt pi * (inverse (fact n) * norm z ^ (2 * n))) =\n    (\\<lambda>n.\n        2 / sqrt pi *\n        (if odd (2 * n + 1) then inverse (fact ((2 * n + 1) div 2))\n         else 0) *\n        norm z ^ (2 * n + 1))", "by (auto simp: fun_eq_iff b_def)"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      norm z * 2 / sqrt pi * (inverse (fact n) * norm z ^ (2 * n))) =\n  (\\<lambda>n. b (2 * n + 1) * norm z ^ (2 * n + 1))\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. b n * norm z ^ n)", "also"], ["proof (state)\nthis:\n  (\\<lambda>n.\n      norm z * 2 / sqrt pi * (inverse (fact n) * norm z ^ (2 * n))) =\n  (\\<lambda>n. b (2 * n + 1) * norm z ^ (2 * n + 1))\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. b n * norm z ^ n)", "have \"summable \\<dots> \\<longleftrightarrow> summable (\\<lambda>n. b n * norm z ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. b (2 * n + 1) * norm z ^ (2 * n + 1)) =\n    summable (\\<lambda>n. b n * norm z ^ n)", "using summable_mono_reindex [of \"\\<lambda>n. 2*n+1\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>strict_mono (\\<lambda>n. 2 * n + 1);\n   \\<And>n.\n      n \\<notin> range (\\<lambda>n. 2 * n + 1) \\<Longrightarrow>\n      ?f n = (0::?'a)\\<rbrakk>\n  \\<Longrightarrow> summable (\\<lambda>n. ?f (2 * n + 1)) = summable ?f\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. b (2 * n + 1) * norm z ^ (2 * n + 1)) =\n    summable (\\<lambda>n. b n * norm z ^ n)", "by (intro summable_mono_reindex [of \"\\<lambda>n. 2*n+1\"]) \n         (auto elim!: oddE simp: strict_mono_def b_def)"], ["proof (state)\nthis:\n  summable (\\<lambda>n. b (2 * n + 1) * norm z ^ (2 * n + 1)) =\n  summable (\\<lambda>n. b n * norm z ^ n)\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. b n * norm z ^ n)", "finally"], ["proof (chain)\npicking this:\n  summable (\\<lambda>n. b n * norm z ^ n)", "show \\<dots>"], ["proof (prove)\nusing this:\n  summable (\\<lambda>n. b n * norm z ^ n)\n\ngoal (1 subgoal):\n 1. summable (\\<lambda>n. b n * norm z ^ n)", "."], ["proof (state)\nthis:\n  summable (\\<lambda>n. b n * norm z ^ n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  summable (\\<lambda>n. of_real (erf_coeffs n) * z ^ n)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition erf :: \"('a :: {real_normed_field, banach}) \\<Rightarrow> 'a\" where\n  \"erf z = (\\<Sum>n. of_real (erf_coeffs n) * z ^ n)\""], ["", "lemma erf_converges: \"(\\<lambda>n. of_real (erf_coeffs n) * z ^ n) sums erf z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. of_real (erf_coeffs n) * z ^ n) sums erf z", "using summable_erf"], ["proof (prove)\nusing this:\n  summable (\\<lambda>n. of_real (erf_coeffs n) * ?z ^ n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. of_real (erf_coeffs n) * z ^ n) sums erf z", "by (simp add: sums_iff erf_def)"], ["", "lemma erf_0 [simp]: \"erf 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. erf (0::'a) = (0::'a)", "unfolding erf_def powser_zero"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_real (erf_coeffs 0) = (0::'a)", "by (simp add: erf_coeffs_def)"], ["", "lemma erf_minus [simp]: \"erf (-z) = - erf z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. erf (- z) = - erf z", "unfolding erf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. of_real (erf_coeffs n) * (- z) ^ n) =\n    - (\\<Sum>n. of_real (erf_coeffs n) * z ^ n)", "by (subst suminf_minus [OF summable_erf, symmetric], rule suminf_cong)\n     (simp_all add: erf_coeffs_def)"], ["", "lemma erf_of_real [simp]: \"erf (of_real x) = of_real (erf x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. erf (of_real x) = of_real (erf x)", "unfolding erf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. of_real (erf_coeffs n) * of_real x ^ n) =\n    of_real (\\<Sum>n. of_real (erf_coeffs n) * x ^ n)", "using summable_erf[of x]"], ["proof (prove)\nusing this:\n  summable (\\<lambda>n. of_real (erf_coeffs n) * x ^ n)\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. of_real (erf_coeffs n) * of_real x ^ n) =\n    of_real (\\<Sum>n. of_real (erf_coeffs n) * x ^ n)", "by (subst suminf_of_real) (simp_all add: summable_erf)"], ["", "lemma of_real_erf_numeral [simp]: \"of_real (erf (numeral n)) = erf (numeral n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_real (erf (numeral n)) = erf (numeral n)", "by (simp only: erf_of_real [symmetric] of_real_numeral)"], ["", "lemma of_real_erf_1 [simp]: \"of_real (erf 1) = erf 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_real (erf 1) = erf (1::'a)", "by (simp only: erf_of_real [symmetric] of_real_1)"], ["", "lemma erf_has_field_derivative:\n  \"(erf has_field_derivative of_real (2 / sqrt pi) * exp (-(z^2))) (at z within A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (erf has_field_derivative of_real (2 / sqrt pi) * exp (- z\\<^sup>2))\n     (at z within A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (erf has_field_derivative of_real (2 / sqrt pi) * exp (- z\\<^sup>2))\n     (at z within A)", "define a' where \"a' = (\\<lambda>n. 2 / sqrt pi *\n     (if even n then (- 1) ^ (n div 2) / fact (n div 2) else 0))\""], ["proof (state)\nthis:\n  a' =\n  (\\<lambda>n.\n      2 / sqrt pi *\n      (if even n then (- 1) ^ (n div 2) / fact (n div 2) else 0))\n\ngoal (1 subgoal):\n 1. (erf has_field_derivative of_real (2 / sqrt pi) * exp (- z\\<^sup>2))\n     (at z within A)", "have \"(erf has_field_derivative\n           (\\<Sum>n. diffs (\\<lambda>n. of_real (erf_coeffs n)) n * z ^ n)) (at z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (erf has_field_derivative\n     (\\<Sum>n. diffs (\\<lambda>n. of_real (erf_coeffs n)) n * z ^ n))\n     (at z)", "using summable_erf"], ["proof (prove)\nusing this:\n  summable (\\<lambda>n. of_real (erf_coeffs n) * ?z ^ n)\n\ngoal (1 subgoal):\n 1. (erf has_field_derivative\n     (\\<Sum>n. diffs (\\<lambda>n. of_real (erf_coeffs n)) n * z ^ n))\n     (at z)", "unfolding erf_def"], ["proof (prove)\nusing this:\n  summable (\\<lambda>n. of_real (erf_coeffs n) * ?z ^ n)\n\ngoal (1 subgoal):\n 1. ((\\<lambda>z.\n         \\<Sum>n. of_real (erf_coeffs n) * z ^ n) has_field_derivative\n     (\\<Sum>n. diffs (\\<lambda>n. of_real (erf_coeffs n)) n * z ^ n))\n     (at z)", "by (rule termdiffs_strong_converges_everywhere)"], ["proof (state)\nthis:\n  (erf has_field_derivative\n   (\\<Sum>n. diffs (\\<lambda>n. of_real (erf_coeffs n)) n * z ^ n))\n   (at z)\n\ngoal (1 subgoal):\n 1. (erf has_field_derivative of_real (2 / sqrt pi) * exp (- z\\<^sup>2))\n     (at z within A)", "also"], ["proof (state)\nthis:\n  (erf has_field_derivative\n   (\\<Sum>n. diffs (\\<lambda>n. of_real (erf_coeffs n)) n * z ^ n))\n   (at z)\n\ngoal (1 subgoal):\n 1. (erf has_field_derivative of_real (2 / sqrt pi) * exp (- z\\<^sup>2))\n     (at z within A)", "have \"diffs (\\<lambda>n. of_real (erf_coeffs n)) = (\\<lambda>n. of_real (a' n) :: 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diffs (\\<lambda>n. of_real (erf_coeffs n)) =\n    (\\<lambda>n. of_real (a' n))", "by (simp add: erf_coeffs_def a'_def diffs_def fun_eq_iff del: of_nat_Suc)"], ["proof (state)\nthis:\n  diffs (\\<lambda>n. of_real (erf_coeffs n)) = (\\<lambda>n. of_real (a' n))\n\ngoal (1 subgoal):\n 1. (erf has_field_derivative of_real (2 / sqrt pi) * exp (- z\\<^sup>2))\n     (at z within A)", "hence \"(\\<Sum>n. diffs (\\<lambda>n. of_real (erf_coeffs n)) n * z ^ n) = \n           (\\<Sum>n. of_real (a' n) * z ^ n)\""], ["proof (prove)\nusing this:\n  diffs (\\<lambda>n. of_real (erf_coeffs n)) = (\\<lambda>n. of_real (a' n))\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. diffs (\\<lambda>n. of_real (erf_coeffs n)) n * z ^ n) =\n    (\\<Sum>n. of_real (a' n) * z ^ n)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>n. diffs (\\<lambda>n. of_real (erf_coeffs n)) n * z ^ n) =\n  (\\<Sum>n. of_real (a' n) * z ^ n)\n\ngoal (1 subgoal):\n 1. (erf has_field_derivative of_real (2 / sqrt pi) * exp (- z\\<^sup>2))\n     (at z within A)", "also"], ["proof (state)\nthis:\n  (\\<Sum>n. diffs (\\<lambda>n. of_real (erf_coeffs n)) n * z ^ n) =\n  (\\<Sum>n. of_real (a' n) * z ^ n)\n\ngoal (1 subgoal):\n 1. (erf has_field_derivative of_real (2 / sqrt pi) * exp (- z\\<^sup>2))\n     (at z within A)", "have \"\\<dots> = (\\<Sum>n. of_real (a' (2*n)) * z ^ (2*n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. of_real (a' n) * z ^ n) =\n    (\\<Sum>n. of_real (a' (2 * n)) * z ^ (2 * n))", "by (intro suminf_mono_reindex [symmetric]) (auto simp: strict_mono_def a'_def elim!: evenE)"], ["proof (state)\nthis:\n  (\\<Sum>n. of_real (a' n) * z ^ n) =\n  (\\<Sum>n. of_real (a' (2 * n)) * z ^ (2 * n))\n\ngoal (1 subgoal):\n 1. (erf has_field_derivative of_real (2 / sqrt pi) * exp (- z\\<^sup>2))\n     (at z within A)", "also"], ["proof (state)\nthis:\n  (\\<Sum>n. of_real (a' n) * z ^ n) =\n  (\\<Sum>n. of_real (a' (2 * n)) * z ^ (2 * n))\n\ngoal (1 subgoal):\n 1. (erf has_field_derivative of_real (2 / sqrt pi) * exp (- z\\<^sup>2))\n     (at z within A)", "have \"(\\<lambda>n. of_real (a' (2*n)) * z ^ (2*n)) = \n               (\\<lambda>n. of_real (2 / sqrt pi) * (inverse (fact n) * (-(z^2))^n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. of_real (a' (2 * n)) * z ^ (2 * n)) =\n    (\\<lambda>n.\n        of_real (2 / sqrt pi) * (inverse (fact n) * (- z\\<^sup>2) ^ n))", "by (simp add: fun_eq_iff power_mult [symmetric] a'_def field_simps power_minus')"], ["proof (state)\nthis:\n  (\\<lambda>n. of_real (a' (2 * n)) * z ^ (2 * n)) =\n  (\\<lambda>n.\n      of_real (2 / sqrt pi) * (inverse (fact n) * (- z\\<^sup>2) ^ n))\n\ngoal (1 subgoal):\n 1. (erf has_field_derivative of_real (2 / sqrt pi) * exp (- z\\<^sup>2))\n     (at z within A)", "also"], ["proof (state)\nthis:\n  (\\<lambda>n. of_real (a' (2 * n)) * z ^ (2 * n)) =\n  (\\<lambda>n.\n      of_real (2 / sqrt pi) * (inverse (fact n) * (- z\\<^sup>2) ^ n))\n\ngoal (1 subgoal):\n 1. (erf has_field_derivative of_real (2 / sqrt pi) * exp (- z\\<^sup>2))\n     (at z within A)", "have \"suminf \\<dots> = of_real (2 / sqrt pi) * exp (-(z^2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        of_real (2 / sqrt pi) * (inverse (fact n) * (- z\\<^sup>2) ^ n)) =\n    of_real (2 / sqrt pi) * exp (- z\\<^sup>2)", "by (subst suminf_mult, intro summable_exp) \n       (auto simp: field_simps scaleR_conv_of_real exp_def)"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      of_real (2 / sqrt pi) * (inverse (fact n) * (- z\\<^sup>2) ^ n)) =\n  of_real (2 / sqrt pi) * exp (- z\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (erf has_field_derivative of_real (2 / sqrt pi) * exp (- z\\<^sup>2))\n     (at z within A)", "finally"], ["proof (chain)\npicking this:\n  (erf has_field_derivative of_real (2 / sqrt pi) * exp (- z\\<^sup>2))\n   (at z)", "show ?thesis"], ["proof (prove)\nusing this:\n  (erf has_field_derivative of_real (2 / sqrt pi) * exp (- z\\<^sup>2))\n   (at z)\n\ngoal (1 subgoal):\n 1. (erf has_field_derivative of_real (2 / sqrt pi) * exp (- z\\<^sup>2))\n     (at z within A)", "by (rule DERIV_subset) simp_all"], ["proof (state)\nthis:\n  (erf has_field_derivative of_real (2 / sqrt pi) * exp (- z\\<^sup>2))\n   (at z within A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas erf_has_field_derivative' [derivative_intros] =\n  erf_has_field_derivative [THEN DERIV_chain2]"], ["", "lemma erf_continuous_on: \"continuous_on A erf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on A erf", "by (rule DERIV_continuous_on erf_has_field_derivative)+"], ["", "lemma continuous_on_compose2_UNIV:\n  \"continuous_on UNIV g \\<Longrightarrow> continuous_on s f \\<Longrightarrow> continuous_on s (\\<lambda>x. g (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>continuous_on UNIV g; continuous_on s f\\<rbrakk>\n    \\<Longrightarrow> continuous_on s (\\<lambda>x. g (f x))", "by (rule continuous_on_compose2[of UNIV g s f]) simp_all"], ["", "lemmas erf_continuous_on' [continuous_intros] = \n  erf_continuous_on [THEN continuous_on_compose2_UNIV]"], ["", "lemma erf_continuous [continuous_intros]: \"continuous (at x within A) erf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous (at x within A) erf", "by (rule continuous_within_subset[OF _ subset_UNIV])\n     (insert erf_continuous_on[of UNIV], auto simp: continuous_on_eq_continuous_at)"], ["", "lemmas erf_continuous' [continuous_intros] = \n  continuous_within_compose2[OF _ erf_continuous]"], ["", "lemmas tendsto_erf [tendsto_intros] = isCont_tendsto_compose[OF erf_continuous]"], ["", "lemma erf_cnj [simp]: \"erf (cnj z) = cnj (erf z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. erf (cnj z) = cnj (erf z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. erf (cnj z) = cnj (erf z)", "interpret bounded_linear cnj"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_linear cnj", "by (rule bounded_linear_cnj)"], ["proof (state)\ngoal (1 subgoal):\n 1. erf (cnj z) = cnj (erf z)", "from suminf[OF summable_erf]"], ["proof (chain)\npicking this:\n  cnj (\\<Sum>n. complex_of_real (erf_coeffs n) * ?z1 ^ n) =\n  (\\<Sum>n. cnj (complex_of_real (erf_coeffs n) * ?z1 ^ n))", "show ?thesis"], ["proof (prove)\nusing this:\n  cnj (\\<Sum>n. complex_of_real (erf_coeffs n) * ?z1 ^ n) =\n  (\\<Sum>n. cnj (complex_of_real (erf_coeffs n) * ?z1 ^ n))\n\ngoal (1 subgoal):\n 1. erf (cnj z) = cnj (erf z)", "by (simp add: erf_def erf_coeffs_def)"], ["proof (state)\nthis:\n  erf (cnj z) = cnj (erf z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma integral_exp_minus_squared_real:\n  assumes \"a \\<le> b\"\n  shows   \"((\\<lambda>t. exp (-(t^2))) has_integral (sqrt pi / 2 * (erf b - erf a))) {a..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral\n     sqrt pi / 2 * (erf b - erf a))\n     {a..b}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral\n     sqrt pi / 2 * (erf b - erf a))\n     {a..b}", "have \"((\\<lambda>t. exp (-(t^2))) has_integral (sqrt pi / 2 * erf b - sqrt pi / 2 * erf a)) {a..b}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral\n     sqrt pi / 2 * erf b - sqrt pi / 2 * erf a)\n     {a..b}", "using assms"], ["proof (prove)\nusing this:\n  a \\<le> b\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral\n     sqrt pi / 2 * erf b - sqrt pi / 2 * erf a)\n     {a..b}", "by (intro fundamental_theorem_of_calculus)\n       (auto intro!: derivative_eq_intros \n             simp: has_field_derivative_iff_has_vector_derivative [symmetric])"], ["proof (state)\nthis:\n  ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral\n   sqrt pi / 2 * erf b - sqrt pi / 2 * erf a)\n   {a..b}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral\n     sqrt pi / 2 * (erf b - erf a))\n     {a..b}", "thus ?thesis"], ["proof (prove)\nusing this:\n  ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral\n   sqrt pi / 2 * erf b - sqrt pi / 2 * erf a)\n   {a..b}\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral\n     sqrt pi / 2 * (erf b - erf a))\n     {a..b}", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral\n   sqrt pi / 2 * (erf b - erf a))\n   {a..b}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma erf_real_altdef_nonneg:\n  \"x \\<ge> 0 \\<Longrightarrow> erf (x::real) = 2 / sqrt pi * integral {0..x} (\\<lambda>t. exp (-(t^2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<Longrightarrow>\n    erf x = 2 / sqrt pi * integral {0..x} (\\<lambda>t. exp (- t\\<^sup>2))", "using integral_exp_minus_squared_real[of 0 x]"], ["proof (prove)\nusing this:\n  0 \\<le> x \\<Longrightarrow>\n  ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral\n   sqrt pi / 2 * (erf x - erf 0))\n   {0..x}\n\ngoal (1 subgoal):\n 1. 0 \\<le> x \\<Longrightarrow>\n    erf x = 2 / sqrt pi * integral {0..x} (\\<lambda>t. exp (- t\\<^sup>2))", "by (simp add: has_integral_iff field_simps)"], ["", "lemma erf_real_altdef_nonpos:\n  \"x \\<le> 0 \\<Longrightarrow> erf (x::real) = -2 / sqrt pi * integral {0..-x} (\\<lambda>t. exp (-(t^2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> 0 \\<Longrightarrow>\n    erf x =\n    - 2 / sqrt pi * integral {0..- x} (\\<lambda>t. exp (- t\\<^sup>2))", "using erf_real_altdef_nonneg[of \"-x\"]"], ["proof (prove)\nusing this:\n  0 \\<le> - x \\<Longrightarrow>\n  erf (- x) =\n  2 / sqrt pi * integral {0..- x} (\\<lambda>t. exp (- t\\<^sup>2))\n\ngoal (1 subgoal):\n 1. x \\<le> 0 \\<Longrightarrow>\n    erf x =\n    - 2 / sqrt pi * integral {0..- x} (\\<lambda>t. exp (- t\\<^sup>2))", "by simp"], ["", "lemma less_imp_erf_real_less:\n  assumes \"a < (b::real)\"\n  shows   \"erf a < erf b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. erf a < erf b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. erf a < erf b", "from assms"], ["proof (chain)\npicking this:\n  a < b", "have \"\\<exists>z. z > a \\<and> z < b \\<and> erf b - erf a = (b - a) * (2 / sqrt pi * exp (- z\\<^sup>2))\""], ["proof (prove)\nusing this:\n  a < b\n\ngoal (1 subgoal):\n 1. \\<exists>z>a.\n       z < b \\<and>\n       erf b - erf a = (b - a) * (2 / sqrt pi * exp (- z\\<^sup>2))", "by (intro MVT2) (auto intro!: derivative_eq_intros simp: field_simps)"], ["proof (state)\nthis:\n  \\<exists>z>a.\n     z < b \\<and>\n     erf b - erf a = (b - a) * (2 / sqrt pi * exp (- z\\<^sup>2))\n\ngoal (1 subgoal):\n 1. erf a < erf b", "then"], ["proof (chain)\npicking this:\n  \\<exists>z>a.\n     z < b \\<and>\n     erf b - erf a = (b - a) * (2 / sqrt pi * exp (- z\\<^sup>2))", "guess z"], ["proof (prove)\nusing this:\n  \\<exists>z>a.\n     z < b \\<and>\n     erf b - erf a = (b - a) * (2 / sqrt pi * exp (- z\\<^sup>2))\n\ngoal (1 subgoal):\n 1. thesis", "by (elim exE conjE)"], ["proof (state)\nthis:\n  a < z\n  z < b\n  erf b - erf a = (b - a) * (2 / sqrt pi * exp (- z\\<^sup>2))\n\ngoal (1 subgoal):\n 1. erf a < erf b", "note z = this"], ["proof (state)\nthis:\n  a < z\n  z < b\n  erf b - erf a = (b - a) * (2 / sqrt pi * exp (- z\\<^sup>2))\n\ngoal (1 subgoal):\n 1. erf a < erf b", "note z(3)"], ["proof (state)\nthis:\n  erf b - erf a = (b - a) * (2 / sqrt pi * exp (- z\\<^sup>2))\n\ngoal (1 subgoal):\n 1. erf a < erf b", "also"], ["proof (state)\nthis:\n  erf b - erf a = (b - a) * (2 / sqrt pi * exp (- z\\<^sup>2))\n\ngoal (1 subgoal):\n 1. erf a < erf b", "from assms"], ["proof (chain)\npicking this:\n  a < b", "have \"(b - a) * (2 / sqrt pi * exp (- z\\<^sup>2)) > 0\""], ["proof (prove)\nusing this:\n  a < b\n\ngoal (1 subgoal):\n 1. 0 < (b - a) * (2 / sqrt pi * exp (- z\\<^sup>2))", "by (intro mult_pos_pos divide_pos_pos) simp_all"], ["proof (state)\nthis:\n  0 < (b - a) * (2 / sqrt pi * exp (- z\\<^sup>2))\n\ngoal (1 subgoal):\n 1. erf a < erf b", "finally"], ["proof (chain)\npicking this:\n  0 < erf b - erf a", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < erf b - erf a\n\ngoal (1 subgoal):\n 1. erf a < erf b", "by simp"], ["proof (state)\nthis:\n  erf a < erf b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma le_imp_erf_real_le: \"a \\<le> (b::real) \\<Longrightarrow> erf a \\<le> erf b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow> erf a \\<le> erf b", "by (cases \"a < b\") (auto dest: less_imp_erf_real_less)"], ["", "lemma erf_real_less_cancel [simp]: \"(erf (a :: real) < erf b) \\<longleftrightarrow> a < b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (erf a < erf b) = (a < b)", "using less_imp_erf_real_less[of a b] less_imp_erf_real_less[of b a]"], ["proof (prove)\nusing this:\n  a < b \\<Longrightarrow> erf a < erf b\n  b < a \\<Longrightarrow> erf b < erf a\n\ngoal (1 subgoal):\n 1. (erf a < erf b) = (a < b)", "by (cases a b rule: linorder_cases) simp_all"], ["", "lemma erf_real_eq_iff [simp]: \"erf (a::real) = erf b \\<longleftrightarrow> a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (erf a = erf b) = (a = b)", "by (cases a b rule: linorder_cases) (auto dest: less_imp_erf_real_less)"], ["", "lemma erf_real_le_cancel [simp]: \"(erf (a :: real) \\<le> erf b) \\<longleftrightarrow> a \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (erf a \\<le> erf b) = (a \\<le> b)", "by (cases a b rule: linorder_cases) (auto simp: less_eq_real_def)"], ["", "lemma inj_on_erf_real [intro]: \"inj_on (erf :: real \\<Rightarrow> real) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on erf A", "by (auto simp: inj_on_def)"], ["", "lemma strict_mono_erf_real [intro]: \"strict_mono (erf :: real \\<Rightarrow> real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_mono erf", "by (auto simp: strict_mono_def)"], ["", "lemma mono_erf_real [intro]: \"mono (erf :: real \\<Rightarrow> real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono erf", "by (auto simp: mono_def)"], ["", "lemma erf_real_ge_0_iff [simp]: \"erf (x::real) \\<ge> 0 \\<longleftrightarrow> x \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 \\<le> erf x) = (0 \\<le> x)", "using erf_real_le_cancel[of 0 x]"], ["proof (prove)\nusing this:\n  (erf 0 \\<le> erf x) = (0 \\<le> x)\n\ngoal (1 subgoal):\n 1. (0 \\<le> erf x) = (0 \\<le> x)", "unfolding erf_0"], ["proof (prove)\nusing this:\n  (0 \\<le> erf x) = (0 \\<le> x)\n\ngoal (1 subgoal):\n 1. (0 \\<le> erf x) = (0 \\<le> x)", "."], ["", "lemma erf_real_le_0_iff [simp]: \"erf (x::real) \\<le> 0 \\<longleftrightarrow> x \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (erf x \\<le> 0) = (x \\<le> 0)", "using erf_real_le_cancel[of x 0]"], ["proof (prove)\nusing this:\n  (erf x \\<le> erf 0) = (x \\<le> 0)\n\ngoal (1 subgoal):\n 1. (erf x \\<le> 0) = (x \\<le> 0)", "unfolding erf_0"], ["proof (prove)\nusing this:\n  (erf x \\<le> 0) = (x \\<le> 0)\n\ngoal (1 subgoal):\n 1. (erf x \\<le> 0) = (x \\<le> 0)", "."], ["", "lemma erf_real_gt_0_iff [simp]: \"erf (x::real) > 0 \\<longleftrightarrow> x > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0 < erf x) = (0 < x)", "using erf_real_less_cancel[of 0 x]"], ["proof (prove)\nusing this:\n  (erf 0 < erf x) = (0 < x)\n\ngoal (1 subgoal):\n 1. (0 < erf x) = (0 < x)", "unfolding erf_0"], ["proof (prove)\nusing this:\n  (0 < erf x) = (0 < x)\n\ngoal (1 subgoal):\n 1. (0 < erf x) = (0 < x)", "."], ["", "lemma erf_real_less_0_iff [simp]: \"erf (x::real) < 0 \\<longleftrightarrow> x < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (erf x < 0) = (x < 0)", "using erf_real_less_cancel[of x 0]"], ["proof (prove)\nusing this:\n  (erf x < erf 0) = (x < 0)\n\ngoal (1 subgoal):\n 1. (erf x < 0) = (x < 0)", "unfolding erf_0"], ["proof (prove)\nusing this:\n  (erf x < 0) = (x < 0)\n\ngoal (1 subgoal):\n 1. (erf x < 0) = (x < 0)", "."], ["", "lemma erf_at_top [tendsto_intros]: \"((erf :: real \\<Rightarrow> real) \\<longlongrightarrow> 1) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (erf \\<longlongrightarrow> 1) at_top", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (erf \\<longlongrightarrow> 1) at_top", "have *: \"(\\<Union>n. {0..real n}) = {0..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>n. {0..real n}) = {0..}", "by (auto intro!: real_nat_ceiling_ge)"], ["proof (state)\nthis:\n  (\\<Union>n. {0..real n}) = {0..}\n\ngoal (1 subgoal):\n 1. (erf \\<longlongrightarrow> 1) at_top", "let ?f = \"\\<lambda>t::real. exp (-t\\<^sup>2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (erf \\<longlongrightarrow> 1) at_top", "have \"(\\<lambda>n. set_lebesgue_integral lborel {0..real n} ?f)\n          \\<longlonglongrightarrow> set_lebesgue_integral lborel (\\<Union>n. {0..real n}) ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. LBINT t:{0..real n}. exp (- t\\<^sup>2))\n    \\<longlonglongrightarrow> LBINT t:(\\<Union>n. {0..real n}).\n                                 exp (- t\\<^sup>2)", "using has_bochner_integral_erf_aux"], ["proof (prove)\nusing this:\n  has_bochner_integral lborel\n   (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n   (sqrt pi / 2)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LBINT t:{0..real n}. exp (- t\\<^sup>2))\n    \\<longlonglongrightarrow> LBINT t:(\\<Union>n. {0..real n}).\n                                 exp (- t\\<^sup>2)", "by (intro set_integral_cont_up )\n       (insert *, auto simp: incseq_def has_bochner_integral_iff set_integrable_def)"], ["proof (state)\nthis:\n  (\\<lambda>n. LBINT t:{0..real n}. exp (- t\\<^sup>2))\n  \\<longlonglongrightarrow> LBINT t:(\\<Union>n. {0..real n}).\n                               exp (- t\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (erf \\<longlongrightarrow> 1) at_top", "also"], ["proof (state)\nthis:\n  (\\<lambda>n. LBINT t:{0..real n}. exp (- t\\<^sup>2))\n  \\<longlonglongrightarrow> LBINT t:(\\<Union>n. {0..real n}).\n                               exp (- t\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (erf \\<longlongrightarrow> 1) at_top", "note *"], ["proof (state)\nthis:\n  (\\<Union>n. {0..real n}) = {0..}\n\ngoal (1 subgoal):\n 1. (erf \\<longlongrightarrow> 1) at_top", "also"], ["proof (state)\nthis:\n  (\\<Union>n. {0..real n}) = {0..}\n\ngoal (1 subgoal):\n 1. (erf \\<longlongrightarrow> 1) at_top", "have \"(\\<lambda>n. set_lebesgue_integral lborel {0..real n} ?f) = (\\<lambda>n. integral {0..real n} ?f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. LBINT t:{0..real n}. exp (- t\\<^sup>2)) =\n    (\\<lambda>n. integral {0..real n} (\\<lambda>t. exp (- t\\<^sup>2)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>n. LBINT t:{0..real n}. exp (- t\\<^sup>2)) =\n    (\\<lambda>n. integral {0..real n} (\\<lambda>t. exp (- t\\<^sup>2)))", "have \"\\<And>n. set_integrable lborel {0..real n} (\\<lambda>x. exp (- x\\<^sup>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       set_integrable lborel {0..real n} (\\<lambda>x. exp (- x\\<^sup>2))", "unfolding set_integrable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       integrable lborel\n        (\\<lambda>x. indicat_real {0..real n} x *\\<^sub>R exp (- x\\<^sup>2))", "by (intro borel_integrable_compact) (auto intro!: continuous_intros)"], ["proof (state)\nthis:\n  set_integrable lborel {0..real ?n} (\\<lambda>x. exp (- x\\<^sup>2))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LBINT t:{0..real n}. exp (- t\\<^sup>2)) =\n    (\\<lambda>n. integral {0..real n} (\\<lambda>t. exp (- t\\<^sup>2)))", "then"], ["proof (chain)\npicking this:\n  set_integrable lborel {0..real ?n} (\\<lambda>x. exp (- x\\<^sup>2))", "show ?thesis"], ["proof (prove)\nusing this:\n  set_integrable lborel {0..real ?n} (\\<lambda>x. exp (- x\\<^sup>2))\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. LBINT t:{0..real n}. exp (- t\\<^sup>2)) =\n    (\\<lambda>n. integral {0..real n} (\\<lambda>t. exp (- t\\<^sup>2)))", "by (intro set_borel_integral_eq_integral ext)"], ["proof (state)\nthis:\n  (\\<lambda>n. LBINT t:{0..real n}. exp (- t\\<^sup>2)) =\n  (\\<lambda>n. integral {0..real n} (\\<lambda>t. exp (- t\\<^sup>2)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>n. LBINT t:{0..real n}. exp (- t\\<^sup>2)) =\n  (\\<lambda>n. integral {0..real n} (\\<lambda>t. exp (- t\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. (erf \\<longlongrightarrow> 1) at_top", "also"], ["proof (state)\nthis:\n  (\\<lambda>n. LBINT t:{0..real n}. exp (- t\\<^sup>2)) =\n  (\\<lambda>n. integral {0..real n} (\\<lambda>t. exp (- t\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. (erf \\<longlongrightarrow> 1) at_top", "have \"\\<dots> = (\\<lambda>n. sqrt pi / 2 * erf (real n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>n. integral {0..real n} (\\<lambda>t. exp (- t\\<^sup>2))) =\n    (\\<lambda>n. sqrt pi / 2 * erf (real n))", "by (simp add: erf_real_altdef_nonneg)"], ["proof (state)\nthis:\n  (\\<lambda>n. integral {0..real n} (\\<lambda>t. exp (- t\\<^sup>2))) =\n  (\\<lambda>n. sqrt pi / 2 * erf (real n))\n\ngoal (1 subgoal):\n 1. (erf \\<longlongrightarrow> 1) at_top", "also"], ["proof (state)\nthis:\n  (\\<lambda>n. integral {0..real n} (\\<lambda>t. exp (- t\\<^sup>2))) =\n  (\\<lambda>n. sqrt pi / 2 * erf (real n))\n\ngoal (1 subgoal):\n 1. (erf \\<longlongrightarrow> 1) at_top", "have \"set_lebesgue_integral lborel {0..} ?f = sqrt pi / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT t:{0..}. exp (- t\\<^sup>2) = sqrt pi / 2", "using has_bochner_integral_erf_aux"], ["proof (prove)\nusing this:\n  has_bochner_integral lborel\n   (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n   (sqrt pi / 2)\n\ngoal (1 subgoal):\n 1. LBINT t:{0..}. exp (- t\\<^sup>2) = sqrt pi / 2", "by (simp add: has_bochner_integral_iff set_lebesgue_integral_def)"], ["proof (state)\nthis:\n  LBINT t:{0..}. exp (- t\\<^sup>2) = sqrt pi / 2\n\ngoal (1 subgoal):\n 1. (erf \\<longlongrightarrow> 1) at_top", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>n. sqrt pi / 2 * erf (real n))\n  \\<longlonglongrightarrow> sqrt pi / 2", "have \"(\\<lambda>n. 2 / sqrt pi * (sqrt pi / 2 * erf (real n))) \\<longlonglongrightarrow> \n                  (2 / sqrt pi) * (sqrt pi / 2)\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. sqrt pi / 2 * erf (real n))\n  \\<longlonglongrightarrow> sqrt pi / 2\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. 2 / sqrt pi * (sqrt pi / 2 * erf (real n)))\n    \\<longlonglongrightarrow> 2 / sqrt pi * (sqrt pi / 2)", "by (intro tendsto_intros)"], ["proof (state)\nthis:\n  (\\<lambda>n. 2 / sqrt pi * (sqrt pi / 2 * erf (real n)))\n  \\<longlonglongrightarrow> 2 / sqrt pi * (sqrt pi / 2)\n\ngoal (1 subgoal):\n 1. (erf \\<longlongrightarrow> 1) at_top", "hence \"(\\<lambda>n. erf (real n)) \\<longlonglongrightarrow> 1\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. 2 / sqrt pi * (sqrt pi / 2 * erf (real n)))\n  \\<longlonglongrightarrow> 2 / sqrt pi * (sqrt pi / 2)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. erf (real n)) \\<longlonglongrightarrow> 1", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>n. erf (real n)) \\<longlonglongrightarrow> 1\n\ngoal (1 subgoal):\n 1. (erf \\<longlongrightarrow> 1) at_top", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>n. erf (real n)) \\<longlonglongrightarrow> 1\n\ngoal (1 subgoal):\n 1. (erf \\<longlongrightarrow> 1) at_top", "by (rule tendsto_sandwich_mono) auto"], ["proof (state)\nthis:\n  (erf \\<longlongrightarrow> 1) at_top\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma erf_at_bot [tendsto_intros]: \"((erf :: real \\<Rightarrow> real) \\<longlongrightarrow> -1) at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (erf \\<longlongrightarrow> - 1) at_bot", "by (simp add: filterlim_at_bot_mirror tendsto_minus_cancel_left erf_at_top)"], ["", "lemmas tendsto_erf_at_top [tendsto_intros] = filterlim_compose[OF erf_at_top]"], ["", "lemmas tendsto_erf_at_bot [tendsto_intros] = filterlim_compose[OF erf_at_bot]"], ["", "subsection \\<open>The complimentary error function\\<close>"], ["", "definition erfc where \"erfc z = 1 - erf z\""], ["", "lemma erf_conv_erfc: \"erf z = 1 - erfc z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. erf z = (1::'a) - erfc z", "by (simp add: erfc_def)"], ["", "lemma erfc_0 [simp]: \"erfc 0 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. erfc (0::'a) = (1::'a)", "by (simp add: erfc_def)"], ["", "lemma erfc_minus: \"erfc (-z) = 2 - erfc z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. erfc (- z) = (2::'a) - erfc z", "by (simp add: erfc_def)"], ["", "lemma erfc_of_real [simp]: \"erfc (of_real x) = of_real (erfc x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. erfc (of_real x) = of_real (erfc x)", "by (simp add: erfc_def)"], ["", "lemma of_real_erfc_numeral [simp]: \"of_real (erfc (numeral n)) = erfc (numeral n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_real (erfc (numeral n)) = erfc (numeral n)", "by (simp add: erfc_def)"], ["", "lemma of_real_erfc_1 [simp]: \"of_real (erfc 1) = erfc 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_real (erfc 1) = erfc (1::'a)", "by (simp add: erfc_def)"], ["", "lemma less_imp_erfc_real_less: \"a < (b::real) \\<Longrightarrow> erfc a > erfc b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < b \\<Longrightarrow> erfc b < erfc a", "by (simp add: erfc_def)"], ["", "lemma le_imp_erfc_real_le: \"a \\<le> (b::real) \\<Longrightarrow> erfc a \\<ge> erfc b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow> erfc b \\<le> erfc a", "by (simp add: erfc_def)"], ["", "lemma erfc_real_less_cancel [simp]: \"(erfc (a :: real) < erfc b) \\<longleftrightarrow> a > b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (erfc a < erfc b) = (b < a)", "by (simp add: erfc_def)"], ["", "lemma erfc_real_eq_iff [simp]: \"erfc (a::real) = erfc b \\<longleftrightarrow> a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (erfc a = erfc b) = (a = b)", "by (simp add: erfc_def)"], ["", "lemma erfc_real_le_cancel [simp]: \"(erfc (a :: real) \\<le> erfc b) \\<longleftrightarrow> a \\<ge> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (erfc a \\<le> erfc b) = (b \\<le> a)", "by (simp add: erfc_def)"], ["", "lemma inj_on_erfc_real [intro]: \"inj_on (erfc :: real \\<Rightarrow> real) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on erfc A", "by (auto simp: inj_on_def)"], ["", "lemma antimono_erfc_real [intro]: \"antimono (erfc :: real \\<Rightarrow> real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antimono erfc", "by (auto simp: antimono_def)"], ["", "lemma erfc_real_ge_0_iff [simp]: \"erfc (x::real) \\<ge> 1 \\<longleftrightarrow> x \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 \\<le> erfc x) = (x \\<le> 0)", "by (simp add: erfc_def)"], ["", "lemma erfc_real_le_0_iff [simp]: \"erfc (x::real) \\<le> 1 \\<longleftrightarrow> x \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (erfc x \\<le> 1) = (0 \\<le> x)", "by (simp add: erfc_def)"], ["", "lemma erfc_real_gt_0_iff [simp]: \"erfc (x::real) > 1 \\<longleftrightarrow> x < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 < erfc x) = (x < 0)", "by (simp add: erfc_def)"], ["", "lemma erfc_real_less_0_iff [simp]: \"erfc (x::real) < 1 \\<longleftrightarrow> x > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (erfc x < 1) = (0 < x)", "by (simp add: erfc_def)"], ["", "lemma erfc_has_field_derivative:\n  \"(erfc has_field_derivative -of_real (2 / sqrt pi) * exp (-(z^2))) (at z within A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (erfc has_field_derivative - of_real (2 / sqrt pi) * exp (- z\\<^sup>2))\n     (at z within A)", "unfolding erfc_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>z. (1::'a) - erf z) has_field_derivative\n     - of_real (2 / sqrt pi) * exp (- z\\<^sup>2))\n     (at z within A)", "by (auto intro!: derivative_eq_intros)"], ["", "lemmas erfc_has_field_derivative' [derivative_intros] =\n  erfc_has_field_derivative [THEN DERIV_chain2]"], ["", "lemma erfc_continuous_on: \"continuous_on A erfc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous_on A erfc", "by (rule DERIV_continuous_on erfc_has_field_derivative)+"], ["", "lemmas erfc_continuous_on' [continuous_intros] = \n  erfc_continuous_on [THEN continuous_on_compose2_UNIV]"], ["", "lemma erfc_continuous [continuous_intros]: \"continuous (at x within A) erfc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. continuous (at x within A) erfc", "by (rule continuous_within_subset[OF _ subset_UNIV])\n     (insert erfc_continuous_on[of UNIV], auto simp: continuous_on_eq_continuous_at)"], ["", "lemmas erfc_continuous' [continuous_intros] = \n  continuous_within_compose2[OF _ erfc_continuous]"], ["", "lemmas tendsto_erfc [tendsto_intros] = isCont_tendsto_compose[OF erfc_continuous]"], ["", "lemma erfc_at_top [tendsto_intros]: \"((erfc :: real \\<Rightarrow> real) \\<longlongrightarrow> 0) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (erfc \\<longlongrightarrow> 0) at_top", "unfolding erfc_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>z. 1 - erf z) \\<longlongrightarrow> 0) at_top", "by (auto intro!: tendsto_eq_intros)"], ["", "lemma erfc_at_bot [tendsto_intros]: \"((erfc :: real \\<Rightarrow> real) \\<longlongrightarrow> 2) at_bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (erfc \\<longlongrightarrow> 2) at_bot", "unfolding erfc_def [abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>z. 1 - erf z) \\<longlongrightarrow> 2) at_bot", "by (auto intro!: tendsto_eq_intros)"], ["", "lemmas tendsto_erfc_at_top [tendsto_intros] = filterlim_compose[OF erfc_at_top]"], ["", "lemmas tendsto_erfc_at_bot [tendsto_intros] = filterlim_compose[OF erfc_at_bot]"], ["", "lemma integrable_exp_minus_squared:\n  assumes \"A \\<subseteq> {0..}\" \"A \\<in> sets lborel\"\n  shows   \"set_integrable lborel A (\\<lambda>t::real. exp (-t\\<^sup>2))\" (is ?thesis1)\n    and   \"(\\<lambda>t::real. exp (-t\\<^sup>2)) integrable_on A\" (is ?thesis2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel A (\\<lambda>t. exp (- t\\<^sup>2)) &&&\n    (\\<lambda>t. exp (- t\\<^sup>2)) integrable_on A", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. set_integrable lborel A (\\<lambda>t. exp (- t\\<^sup>2))\n 2. (\\<lambda>t. exp (- t\\<^sup>2)) integrable_on A", "show ?thesis1"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel A (\\<lambda>t. exp (- t\\<^sup>2))", "by (rule set_integrable_subset[of _ \"{0..}\"]) \n       (insert assms has_bochner_integral_erf_aux, auto simp: has_bochner_integral_iff set_integrable_def)"], ["proof (state)\nthis:\n  set_integrable lborel A (\\<lambda>t. exp (- t\\<^sup>2))\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. exp (- t\\<^sup>2)) integrable_on A", "thus ?thesis2"], ["proof (prove)\nusing this:\n  set_integrable lborel A (\\<lambda>t. exp (- t\\<^sup>2))\n\ngoal (1 subgoal):\n 1. (\\<lambda>t. exp (- t\\<^sup>2)) integrable_on A", "by (rule set_borel_integral_eq_integral)"], ["proof (state)\nthis:\n  (\\<lambda>t. exp (- t\\<^sup>2)) integrable_on A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma\n  assumes \"x \\<ge> 0\"\n  shows   erfc_real_altdef_nonneg: \"erfc x = 2 / sqrt pi * integral {x..} (\\<lambda>t. exp (-t\\<^sup>2))\"\n    and   has_integral_erfc:       \"((\\<lambda>t. exp (-t\\<^sup>2)) has_integral (sqrt pi / 2 * erfc x)) {x..}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. erfc x =\n    2 / sqrt pi * integral {x..} (\\<lambda>t. exp (- t\\<^sup>2)) &&&\n    ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral sqrt pi / 2 * erfc x)\n     {x..}", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. erfc x = 2 / sqrt pi * integral {x..} (\\<lambda>t. exp (- t\\<^sup>2))\n 2. ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral sqrt pi / 2 * erfc x)\n     {x..}", "let ?f = \"\\<lambda>t::real. exp (-t\\<^sup>2)\""], ["proof (state)\ngoal (2 subgoals):\n 1. erfc x = 2 / sqrt pi * integral {x..} (\\<lambda>t. exp (- t\\<^sup>2))\n 2. ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral sqrt pi / 2 * erfc x)\n     {x..}", "have int: \"set_integrable lborel {0..} ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_integrable lborel {0..} (\\<lambda>t. exp (- t\\<^sup>2))", "using has_bochner_integral_erf_aux"], ["proof (prove)\nusing this:\n  has_bochner_integral lborel\n   (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n   (sqrt pi / 2)\n\ngoal (1 subgoal):\n 1. set_integrable lborel {0..} (\\<lambda>t. exp (- t\\<^sup>2))", "by (simp add: has_bochner_integral_iff set_integrable_def)"], ["proof (state)\nthis:\n  set_integrable lborel {0..} (\\<lambda>t. exp (- t\\<^sup>2))\n\ngoal (2 subgoals):\n 1. erfc x = 2 / sqrt pi * integral {x..} (\\<lambda>t. exp (- t\\<^sup>2))\n 2. ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral sqrt pi / 2 * erfc x)\n     {x..}", "from assms"], ["proof (chain)\npicking this:\n  0 \\<le> x", "have *: \"{(0::real)..} = {0..x} \\<union> {x..}\""], ["proof (prove)\nusing this:\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. {0..} = {0..x} \\<union> {x..}", "by auto"], ["proof (state)\nthis:\n  {0..} = {0..x} \\<union> {x..}\n\ngoal (2 subgoals):\n 1. erfc x = 2 / sqrt pi * integral {x..} (\\<lambda>t. exp (- t\\<^sup>2))\n 2. ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral sqrt pi / 2 * erfc x)\n     {x..}", "have \"set_lebesgue_integral lborel ({0..x} \\<union> {x..}) ?f = \n               set_lebesgue_integral lborel {0..x} ?f + set_lebesgue_integral lborel {x..} ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT t:{0..x} \\<union> {x..}. exp (- t\\<^sup>2) =\n    (LBINT t:{0..x}. exp (- t\\<^sup>2)) + (LBINT t:{x..}. exp (- t\\<^sup>2))", "by (subst set_integral_Un_AE; (rule set_integrable_subset[OF int])?)\n       (insert assms AE_lborel_singleton[of x], auto elim!: eventually_mono)"], ["proof (state)\nthis:\n  LBINT t:{0..x} \\<union> {x..}. exp (- t\\<^sup>2) =\n  (LBINT t:{0..x}. exp (- t\\<^sup>2)) + (LBINT t:{x..}. exp (- t\\<^sup>2))\n\ngoal (2 subgoals):\n 1. erfc x = 2 / sqrt pi * integral {x..} (\\<lambda>t. exp (- t\\<^sup>2))\n 2. ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral sqrt pi / 2 * erfc x)\n     {x..}", "also"], ["proof (state)\nthis:\n  LBINT t:{0..x} \\<union> {x..}. exp (- t\\<^sup>2) =\n  (LBINT t:{0..x}. exp (- t\\<^sup>2)) + (LBINT t:{x..}. exp (- t\\<^sup>2))\n\ngoal (2 subgoals):\n 1. erfc x = 2 / sqrt pi * integral {x..} (\\<lambda>t. exp (- t\\<^sup>2))\n 2. ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral sqrt pi / 2 * erfc x)\n     {x..}", "note * [symmetric]"], ["proof (state)\nthis:\n  {0..x} \\<union> {x..} = {0..}\n\ngoal (2 subgoals):\n 1. erfc x = 2 / sqrt pi * integral {x..} (\\<lambda>t. exp (- t\\<^sup>2))\n 2. ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral sqrt pi / 2 * erfc x)\n     {x..}", "also"], ["proof (state)\nthis:\n  {0..x} \\<union> {x..} = {0..}\n\ngoal (2 subgoals):\n 1. erfc x = 2 / sqrt pi * integral {x..} (\\<lambda>t. exp (- t\\<^sup>2))\n 2. ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral sqrt pi / 2 * erfc x)\n     {x..}", "have \"set_lebesgue_integral lborel {0..} ?f = sqrt pi / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT t:{0..}. exp (- t\\<^sup>2) = sqrt pi / 2", "using has_bochner_integral_erf_aux"], ["proof (prove)\nusing this:\n  has_bochner_integral lborel\n   (\\<lambda>x. indicat_real {0..} x *\\<^sub>R exp (- x\\<^sup>2))\n   (sqrt pi / 2)\n\ngoal (1 subgoal):\n 1. LBINT t:{0..}. exp (- t\\<^sup>2) = sqrt pi / 2", "by (simp add: has_bochner_integral_iff set_lebesgue_integral_def)"], ["proof (state)\nthis:\n  LBINT t:{0..}. exp (- t\\<^sup>2) = sqrt pi / 2\n\ngoal (2 subgoals):\n 1. erfc x = 2 / sqrt pi * integral {x..} (\\<lambda>t. exp (- t\\<^sup>2))\n 2. ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral sqrt pi / 2 * erfc x)\n     {x..}", "also"], ["proof (state)\nthis:\n  LBINT t:{0..}. exp (- t\\<^sup>2) = sqrt pi / 2\n\ngoal (2 subgoals):\n 1. erfc x = 2 / sqrt pi * integral {x..} (\\<lambda>t. exp (- t\\<^sup>2))\n 2. ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral sqrt pi / 2 * erfc x)\n     {x..}", "have \"set_lebesgue_integral lborel {0..x} ?f = sqrt pi / 2 * erf x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT t:{0..x}. exp (- t\\<^sup>2) = sqrt pi / 2 * erf x", "by (subst set_borel_integral_eq_integral(2)[OF set_integrable_subset[OF int]])\n       (insert assms, auto simp: erf_real_altdef_nonneg)"], ["proof (state)\nthis:\n  LBINT t:{0..x}. exp (- t\\<^sup>2) = sqrt pi / 2 * erf x\n\ngoal (2 subgoals):\n 1. erfc x = 2 / sqrt pi * integral {x..} (\\<lambda>t. exp (- t\\<^sup>2))\n 2. ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral sqrt pi / 2 * erfc x)\n     {x..}", "also"], ["proof (state)\nthis:\n  LBINT t:{0..x}. exp (- t\\<^sup>2) = sqrt pi / 2 * erf x\n\ngoal (2 subgoals):\n 1. erfc x = 2 / sqrt pi * integral {x..} (\\<lambda>t. exp (- t\\<^sup>2))\n 2. ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral sqrt pi / 2 * erfc x)\n     {x..}", "have \"set_lebesgue_integral lborel {x..} ?f = integral {x..} ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LBINT t:{x..}. exp (- t\\<^sup>2) =\n    integral {x..} (\\<lambda>t. exp (- t\\<^sup>2))", "by (subst set_borel_integral_eq_integral(2)[OF set_integrable_subset[OF int]])\n       (insert assms, auto)"], ["proof (state)\nthis:\n  LBINT t:{x..}. exp (- t\\<^sup>2) =\n  integral {x..} (\\<lambda>t. exp (- t\\<^sup>2))\n\ngoal (2 subgoals):\n 1. erfc x = 2 / sqrt pi * integral {x..} (\\<lambda>t. exp (- t\\<^sup>2))\n 2. ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral sqrt pi / 2 * erfc x)\n     {x..}", "finally"], ["proof (chain)\npicking this:\n  sqrt pi / 2 =\n  sqrt pi / 2 * erf x + integral {x..} (\\<lambda>t. exp (- t\\<^sup>2))", "show \"erfc x = 2 / sqrt pi * integral {x..} ?f\""], ["proof (prove)\nusing this:\n  sqrt pi / 2 =\n  sqrt pi / 2 * erf x + integral {x..} (\\<lambda>t. exp (- t\\<^sup>2))\n\ngoal (1 subgoal):\n 1. erfc x = 2 / sqrt pi * integral {x..} (\\<lambda>t. exp (- t\\<^sup>2))", "by (simp add: field_simps erfc_def)"], ["proof (state)\nthis:\n  erfc x = 2 / sqrt pi * integral {x..} (\\<lambda>t. exp (- t\\<^sup>2))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral sqrt pi / 2 * erfc x)\n     {x..}", "with integrable_exp_minus_squared(2)[of \"{x..}\"] assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>{x..} \\<subseteq> {0..}; {x..} \\<in> sets lborel\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>t. exp (- t\\<^sup>2)) integrable_on {x..}\n  0 \\<le> x\n  erfc x = 2 / sqrt pi * integral {x..} (\\<lambda>t. exp (- t\\<^sup>2))", "show \"(?f has_integral (sqrt pi / 2 * erfc x)) {x..}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>{x..} \\<subseteq> {0..}; {x..} \\<in> sets lborel\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>t. exp (- t\\<^sup>2)) integrable_on {x..}\n  0 \\<le> x\n  erfc x = 2 / sqrt pi * integral {x..} (\\<lambda>t. exp (- t\\<^sup>2))\n\ngoal (1 subgoal):\n 1. ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral sqrt pi / 2 * erfc x)\n     {x..}", "by (simp add: has_integral_iff)"], ["proof (state)\nthis:\n  ((\\<lambda>t. exp (- t\\<^sup>2)) has_integral sqrt pi / 2 * erfc x) {x..}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma erfc_real_gt_0 [simp, intro]: \"erfc (x::real) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < erfc x", "proof (cases \"x \\<ge> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> x \\<Longrightarrow> 0 < erfc x\n 2. \\<not> 0 \\<le> x \\<Longrightarrow> 0 < erfc x", "case True"], ["proof (state)\nthis:\n  0 \\<le> x\n\ngoal (2 subgoals):\n 1. 0 \\<le> x \\<Longrightarrow> 0 < erfc x\n 2. \\<not> 0 \\<le> x \\<Longrightarrow> 0 < erfc x", "have \"0 < integral {x..x+1} (\\<lambda>t. exp (-(x+1)\\<^sup>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < integral {x..x + 1} (\\<lambda>t. exp (- (x + 1)\\<^sup>2))", "by simp"], ["proof (state)\nthis:\n  0 < integral {x..x + 1} (\\<lambda>t. exp (- (x + 1)\\<^sup>2))\n\ngoal (2 subgoals):\n 1. 0 \\<le> x \\<Longrightarrow> 0 < erfc x\n 2. \\<not> 0 \\<le> x \\<Longrightarrow> 0 < erfc x", "also"], ["proof (state)\nthis:\n  0 < integral {x..x + 1} (\\<lambda>t. exp (- (x + 1)\\<^sup>2))\n\ngoal (2 subgoals):\n 1. 0 \\<le> x \\<Longrightarrow> 0 < erfc x\n 2. \\<not> 0 \\<le> x \\<Longrightarrow> 0 < erfc x", "from True"], ["proof (chain)\npicking this:\n  0 \\<le> x", "have \"\\<dots> \\<le> integral {x..x+1} (\\<lambda>t. exp (-t\\<^sup>2))\""], ["proof (prove)\nusing this:\n  0 \\<le> x\n\ngoal (1 subgoal):\n 1. integral {x..x + 1} (\\<lambda>t. exp (- (x + 1)\\<^sup>2))\n    \\<le> integral {x..x + 1} (\\<lambda>t. exp (- t\\<^sup>2))", "by (intro integral_le) \n       (auto intro!: integrable_continuous_real continuous_intros power_mono)"], ["proof (state)\nthis:\n  integral {x..x + 1} (\\<lambda>t. exp (- (x + 1)\\<^sup>2))\n  \\<le> integral {x..x + 1} (\\<lambda>t. exp (- t\\<^sup>2))\n\ngoal (2 subgoals):\n 1. 0 \\<le> x \\<Longrightarrow> 0 < erfc x\n 2. \\<not> 0 \\<le> x \\<Longrightarrow> 0 < erfc x", "also"], ["proof (state)\nthis:\n  integral {x..x + 1} (\\<lambda>t. exp (- (x + 1)\\<^sup>2))\n  \\<le> integral {x..x + 1} (\\<lambda>t. exp (- t\\<^sup>2))\n\ngoal (2 subgoals):\n 1. 0 \\<le> x \\<Longrightarrow> 0 < erfc x\n 2. \\<not> 0 \\<le> x \\<Longrightarrow> 0 < erfc x", "have \"\\<dots> \\<le> sqrt pi / 2 * erfc x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. integral {x..x + 1} (\\<lambda>t. exp (- t\\<^sup>2))\n    \\<le> sqrt pi / 2 * erfc x", "by (rule has_integral_subset_le[OF _ integrable_integral has_integral_erfc])\n       (auto intro!: integrable_continuous_real continuous_intros True)"], ["proof (state)\nthis:\n  integral {x..x + 1} (\\<lambda>t. exp (- t\\<^sup>2))\n  \\<le> sqrt pi / 2 * erfc x\n\ngoal (2 subgoals):\n 1. 0 \\<le> x \\<Longrightarrow> 0 < erfc x\n 2. \\<not> 0 \\<le> x \\<Longrightarrow> 0 < erfc x", "finally"], ["proof (chain)\npicking this:\n  0 < sqrt pi / 2 * erfc x", "have \"sqrt pi / 2 * erfc x > 0\""], ["proof (prove)\nusing this:\n  0 < sqrt pi / 2 * erfc x\n\ngoal (1 subgoal):\n 1. 0 < sqrt pi / 2 * erfc x", "."], ["proof (state)\nthis:\n  0 < sqrt pi / 2 * erfc x\n\ngoal (2 subgoals):\n 1. 0 \\<le> x \\<Longrightarrow> 0 < erfc x\n 2. \\<not> 0 \\<le> x \\<Longrightarrow> 0 < erfc x", "hence \"\\<dots> * (2 / sqrt pi) > 0\""], ["proof (prove)\nusing this:\n  0 < sqrt pi / 2 * erfc x\n\ngoal (1 subgoal):\n 1. 0 < sqrt pi / 2 * erfc x * (2 / sqrt pi)", "by (rule mult_pos_pos) simp_all"], ["proof (state)\nthis:\n  0 < sqrt pi / 2 * erfc x * (2 / sqrt pi)\n\ngoal (2 subgoals):\n 1. 0 \\<le> x \\<Longrightarrow> 0 < erfc x\n 2. \\<not> 0 \\<le> x \\<Longrightarrow> 0 < erfc x", "thus \"erfc x > 0\""], ["proof (prove)\nusing this:\n  0 < sqrt pi / 2 * erfc x * (2 / sqrt pi)\n\ngoal (1 subgoal):\n 1. 0 < erfc x", "by simp"], ["proof (state)\nthis:\n  0 < erfc x\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x \\<Longrightarrow> 0 < erfc x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x \\<Longrightarrow> 0 < erfc x", "case False"], ["proof (state)\nthis:\n  \\<not> 0 \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x \\<Longrightarrow> 0 < erfc x", "have \"0 \\<le> (1::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> 1", "by simp"], ["proof (state)\nthis:\n  0 \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x \\<Longrightarrow> 0 < erfc x", "also"], ["proof (state)\nthis:\n  0 \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x \\<Longrightarrow> 0 < erfc x", "from False"], ["proof (chain)\npicking this:\n  \\<not> 0 \\<le> x", "have \"\\<dots> < erfc x\""], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> x\n\ngoal (1 subgoal):\n 1. 1 < erfc x", "by simp"], ["proof (state)\nthis:\n  1 < erfc x\n\ngoal (1 subgoal):\n 1. \\<not> 0 \\<le> x \\<Longrightarrow> 0 < erfc x", "finally"], ["proof (chain)\npicking this:\n  0 < erfc x", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < erfc x\n\ngoal (1 subgoal):\n 1. 0 < erfc x", "."], ["proof (state)\nthis:\n  0 < erfc x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma erfc_real_less_2 [intro]: \"erfc (x::real) < 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. erfc x < 2", "using erfc_real_gt_0[of \"-x\"]"], ["proof (prove)\nusing this:\n  0 < erfc (- x)\n\ngoal (1 subgoal):\n 1. erfc x < 2", "unfolding erfc_minus"], ["proof (prove)\nusing this:\n  0 < 2 - erfc x\n\ngoal (1 subgoal):\n 1. erfc x < 2", "by simp"], ["", "lemma erf_real_gt_neg1 [intro]: \"erf (x::real) > -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 < erf x", "using erfc_real_less_2[of x]"], ["proof (prove)\nusing this:\n  erfc x < 2\n\ngoal (1 subgoal):\n 1. - 1 < erf x", "unfolding erfc_def"], ["proof (prove)\nusing this:\n  1 - erf x < 2\n\ngoal (1 subgoal):\n 1. - 1 < erf x", "by simp"], ["", "lemma erf_real_less_1 [intro]: \"erf (x::real) < 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. erf x < 1", "using erfc_real_gt_0[of x]"], ["proof (prove)\nusing this:\n  0 < erfc x\n\ngoal (1 subgoal):\n 1. erf x < 1", "unfolding erfc_def"], ["proof (prove)\nusing this:\n  0 < 1 - erf x\n\ngoal (1 subgoal):\n 1. erf x < 1", "by simp"], ["", "lemma erfc_cnj [simp]: \"erfc (cnj z) = cnj (erfc z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. erfc (cnj z) = cnj (erfc z)", "by (simp add: erfc_def)"], ["", "subsection \\<open>Specific facts about the complex case\\<close>"], ["", "lemma erf_complex_altdef:\n  \"erf z = of_real (2 / sqrt pi) * contour_integral (linepath 0 z) (\\<lambda>t. exp (-(t^2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. erf z =\n    complex_of_real (2 / sqrt pi) *\n    contour_integral (linepath 0 z) (\\<lambda>t. exp (- t\\<^sup>2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. erf z =\n    complex_of_real (2 / sqrt pi) *\n    contour_integral (linepath 0 z) (\\<lambda>t. exp (- t\\<^sup>2))", "define A where \"A = (\\<lambda>z. contour_integral (linepath 0 z) (\\<lambda>t. exp (-(t^2))))\""], ["proof (state)\nthis:\n  A =\n  (\\<lambda>z.\n      contour_integral (linepath 0 z) (\\<lambda>t. exp (- t\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. erf z =\n    complex_of_real (2 / sqrt pi) *\n    contour_integral (linepath 0 z) (\\<lambda>t. exp (- t\\<^sup>2))", "have [derivative_intros]: \"(A has_field_derivative exp (-(z^2))) (at z)\" for z :: complex"], ["proof (prove)\ngoal (1 subgoal):\n 1. (A has_field_derivative exp (- z\\<^sup>2)) (at z)", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>z.\n         contour_integral (linepath 0 z)\n          (\\<lambda>t. exp (- t\\<^sup>2))) has_field_derivative\n     exp (- z\\<^sup>2))\n     (at z)", "by (rule contour_integral_has_field_derivative[where A = UNIV])\n       (auto intro!: holomorphic_intros)"], ["proof (state)\nthis:\n  (A has_field_derivative exp (- ?z\\<^sup>2)) (at ?z)\n\ngoal (1 subgoal):\n 1. erf z =\n    complex_of_real (2 / sqrt pi) *\n    contour_integral (linepath 0 z) (\\<lambda>t. exp (- t\\<^sup>2))", "have \"erf z - 2 / sqrt pi * A z = erf 0 - 2 / sqrt pi * A 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. erf z - complex_of_real (2 / sqrt pi) * A z =\n    erf 0 - complex_of_real (2 / sqrt pi) * A 0", "by (rule has_derivative_zero_unique [where f = \"\\<lambda>z. erf z - 2 / sqrt pi * A z\" and s = UNIV])\n       (auto intro!: has_field_derivative_imp_has_derivative derivative_eq_intros)"], ["proof (state)\nthis:\n  erf z - complex_of_real (2 / sqrt pi) * A z =\n  erf 0 - complex_of_real (2 / sqrt pi) * A 0\n\ngoal (1 subgoal):\n 1. erf z =\n    complex_of_real (2 / sqrt pi) *\n    contour_integral (linepath 0 z) (\\<lambda>t. exp (- t\\<^sup>2))", "also"], ["proof (state)\nthis:\n  erf z - complex_of_real (2 / sqrt pi) * A z =\n  erf 0 - complex_of_real (2 / sqrt pi) * A 0\n\ngoal (1 subgoal):\n 1. erf z =\n    complex_of_real (2 / sqrt pi) *\n    contour_integral (linepath 0 z) (\\<lambda>t. exp (- t\\<^sup>2))", "have \"A 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A 0 = 0", "by (simp only: A_def contour_integral_trivial)"], ["proof (state)\nthis:\n  A 0 = 0\n\ngoal (1 subgoal):\n 1. erf z =\n    complex_of_real (2 / sqrt pi) *\n    contour_integral (linepath 0 z) (\\<lambda>t. exp (- t\\<^sup>2))", "finally"], ["proof (chain)\npicking this:\n  erf z - complex_of_real (2 / sqrt pi) * A z =\n  erf 0 - complex_of_real (2 / sqrt pi) * 0", "show ?thesis"], ["proof (prove)\nusing this:\n  erf z - complex_of_real (2 / sqrt pi) * A z =\n  erf 0 - complex_of_real (2 / sqrt pi) * 0\n\ngoal (1 subgoal):\n 1. erf z =\n    complex_of_real (2 / sqrt pi) *\n    contour_integral (linepath 0 z) (\\<lambda>t. exp (- t\\<^sup>2))", "unfolding A_def"], ["proof (prove)\nusing this:\n  erf z -\n  complex_of_real (2 / sqrt pi) *\n  contour_integral (linepath 0 z) (\\<lambda>t. exp (- t\\<^sup>2)) =\n  erf 0 - complex_of_real (2 / sqrt pi) * 0\n\ngoal (1 subgoal):\n 1. erf z =\n    complex_of_real (2 / sqrt pi) *\n    contour_integral (linepath 0 z) (\\<lambda>t. exp (- t\\<^sup>2))", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  erf z =\n  complex_of_real (2 / sqrt pi) *\n  contour_integral (linepath 0 z) (\\<lambda>t. exp (- t\\<^sup>2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma erf_holomorphic_on: \"erf holomorphic_on A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. erf holomorphic_on A", "by (auto simp: holomorphic_on_def field_differentiable_def intro!: erf_has_field_derivative)"], ["", "lemmas erf_holomorphic_on' [holomorphic_intros] = \n  erf_holomorphic_on [THEN holomorphic_on_chain_UNIV]"], ["", "lemma erf_analytic_on: \"erf analytic_on A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. erf analytic_on A", "by (auto simp: analytic_on_def) (auto intro!: exI[of _ 1] holomorphic_intros)"], ["", "lemma erf_analytic_on'  [analytic_intros]:\n  assumes \"f analytic_on A\"\n  shows   \"(\\<lambda>x. erf (f x)) analytic_on A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. erf (f x)) analytic_on A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x. erf (f x)) analytic_on A", "from assms and erf_analytic_on"], ["proof (chain)\npicking this:\n  f analytic_on A\n  erf analytic_on ?A", "have \"erf \\<circ> f analytic_on A\""], ["proof (prove)\nusing this:\n  f analytic_on A\n  erf analytic_on ?A\n\ngoal (1 subgoal):\n 1. erf \\<circ> f analytic_on A", "by (rule analytic_on_compose_gen) auto"], ["proof (state)\nthis:\n  erf \\<circ> f analytic_on A\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. erf (f x)) analytic_on A", "thus ?thesis"], ["proof (prove)\nusing this:\n  erf \\<circ> f analytic_on A\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. erf (f x)) analytic_on A", "by (simp add: o_def)"], ["proof (state)\nthis:\n  (\\<lambda>x. erf (f x)) analytic_on A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma erfc_holomorphic_on: \"erfc holomorphic_on A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. erfc holomorphic_on A", "by (auto simp: holomorphic_on_def field_differentiable_def intro!: erfc_has_field_derivative)"], ["", "lemmas erfc_holomorphic_on' [holomorphic_intros] = \n  erfc_holomorphic_on [THEN holomorphic_on_chain_UNIV]"], ["", "lemma erfc_analytic_on: \"erfc analytic_on A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. erfc analytic_on A", "by (auto simp: analytic_on_def) (auto intro!: exI[of _ 1] holomorphic_intros)"], ["", "lemma erfc_analytic_on' [analytic_intros]:\n  assumes \"f analytic_on A\"\n  shows   \"(\\<lambda>x. erfc (f x)) analytic_on A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. erfc (f x)) analytic_on A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x. erfc (f x)) analytic_on A", "from assms and erfc_analytic_on"], ["proof (chain)\npicking this:\n  f analytic_on A\n  erfc analytic_on ?A", "have \"erfc \\<circ> f analytic_on A\""], ["proof (prove)\nusing this:\n  f analytic_on A\n  erfc analytic_on ?A\n\ngoal (1 subgoal):\n 1. erfc \\<circ> f analytic_on A", "by (rule analytic_on_compose_gen) auto"], ["proof (state)\nthis:\n  erfc \\<circ> f analytic_on A\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. erfc (f x)) analytic_on A", "thus ?thesis"], ["proof (prove)\nusing this:\n  erfc \\<circ> f analytic_on A\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. erfc (f x)) analytic_on A", "by (simp add: o_def)"], ["proof (state)\nthis:\n  (\\<lambda>x. erfc (f x)) analytic_on A\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}