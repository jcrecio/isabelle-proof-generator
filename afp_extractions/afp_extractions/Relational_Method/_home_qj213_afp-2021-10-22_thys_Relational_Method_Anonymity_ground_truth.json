{"file_name": "/home/qj213/afp-2021-10-22/thys/Relational_Method/Anonymity.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Relational_Method", "problem_names": ["lemma crypts_union_1:\n \"crypts (H \\<union> H') \\<subseteq> crypts H \\<union> crypts H'\"", "lemma crypts_union_2:\n \"crypts H \\<union> crypts H' \\<subseteq> crypts (H \\<union> H')\"", "lemma crypts_hash_1:\n \"crypts {Hash X} \\<subseteq> insert (Hash X) (crypts {X})\"", "lemma crypts_hash_2:\n \"insert (Hash X) (crypts {X}) \\<subseteq> crypts {Hash X}\"", "lemma crypts_crypt_1:\n \"crypts {Crypt K X} \\<subseteq> Crypt K ` crypts {X}\"", "lemma crypts_crypt_2:\n \"Crypt K ` crypts {X} \\<subseteq> crypts {Crypt K X}\"", "lemma crypts_mpair_1:\n \"crypts {\\<lbrace>X, Y\\<rbrace>} \\<subseteq> insert \\<lbrace>X, Y\\<rbrace> (crypts {X} \\<union> crypts {Y})\"", "lemma crypts_mpair_2:\n \"insert \\<lbrace>X, Y\\<rbrace> (crypts {X} \\<union> crypts {Y}) \\<subseteq> crypts {\\<lbrace>X, Y\\<rbrace>}\"", "lemma key_sets_crypt_1:\n \"X \\<noteq> Crypt K Y \\<Longrightarrow>\n    key_sets X {Crypt K Y} \\<subseteq> insert (InvKey K) ` key_sets X {Y}\"", "lemma key_sets_crypt_2:\n \"insert (InvKey K) ` key_sets X {Y} \\<subseteq> key_sets X {Crypt K Y}\"", "lemma log_spied_1:\n \"\\<lbrakk>s \\<turnstile> s';\n    Log X \\<in> parts (used s) \\<longrightarrow> Log X \\<in> spied s;\n    Log X \\<in> parts (used s')\\<rbrakk> \\<Longrightarrow>\n  Log X \\<in> spied s'\"", "lemma idinfo_spied_1:\n \"\\<lbrakk>s \\<turnstile> s';\n    \\<langle>n, X\\<rangle> \\<in> parts (used s) \\<longrightarrow> \\<langle>n, X\\<rangle> \\<in> spied s;\n    \\<langle>n, X\\<rangle> \\<in> parts (used s')\\<rbrakk> \\<Longrightarrow>\n  \\<langle>n, X\\<rangle> \\<in> spied s'\"", "lemma idinfo_msg_1:\n  assumes A: \"s\\<^sub>0 \\<Turnstile> s\"\n  shows \"\\<lbrakk>s \\<turnstile> s'; \\<langle>n, X\\<rangle> \\<in> spied s \\<longrightarrow> X \\<in> spied s; \\<langle>n, X\\<rangle> \\<in> spied s'\\<rbrakk> \\<Longrightarrow>\n    X \\<in> spied s'\"", "lemma idinfo_init_1 [rule_format]:\n  assumes A: \"s\\<^sub>0 \\<Turnstile> s\"\n  shows \"\\<lbrakk>s \\<turnstile> s'; n \\<notin> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey;\n    \\<forall>X. \\<langle>n, X\\<rangle> \\<notin> spied s\\<rbrakk> \\<Longrightarrow>\n  \\<langle>n, X\\<rangle> \\<notin> spied s'\"", "lemma idinfo_mpair_1 [rule_format]:\n \"\\<lbrakk>(s, s') \\<in> rel_id_hash \\<union> rel_id_crypt \\<union> rel_id_sep \\<union> rel_id_con;\n    \\<forall>X Y. \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle> \\<in> spied s \\<longrightarrow>\n      key_sets \\<lbrace>X, Y\\<rbrace> (crypts (Log -` spied s)) \\<noteq> {};\n    \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle> \\<in> spied s'\\<rbrakk> \\<Longrightarrow>\n  key_sets \\<lbrace>X, Y\\<rbrace> (crypts (Log -` spied s')) \\<noteq> {}\"", "lemma idinfo_mpair_2 [rule_format]:\n  assumes A: \"s\\<^sub>0 \\<Turnstile> s\"\n  shows \"\\<lbrakk>s \\<turnstile> s'; (s, s') \\<notin> rel_id_hash \\<union> rel_id_crypt \\<union> rel_id_sep \\<union> rel_id_con;\n    \\<forall>X Y. \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle> \\<in> spied s \\<longrightarrow>\n      key_sets \\<lbrace>X, Y\\<rbrace> (crypts (Log -` spied s)) \\<noteq> {};\n    \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle> \\<in> spied s'\\<rbrakk> \\<Longrightarrow>\n  key_sets \\<lbrace>X, Y\\<rbrace> (crypts (Log -` spied s')) \\<noteq> {}\"", "lemma pwd_anonymous_1 [rule_format]:\n \"\\<lbrakk>s\\<^sub>0 \\<Turnstile> s; n \\<notin> bad_id_password\\<rbrakk> \\<Longrightarrow>\n    \\<langle>n, Pwd n\\<rangle> \\<in> spied s \\<longrightarrow>\n  (\\<exists>SK. SesKey SK \\<in> spied s \\<and>\n    ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n     (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s))\"\n  (is \"\\<lbrakk>_; _\\<rbrakk> \\<Longrightarrow> _ \\<longrightarrow> ?P s\")", "theorem pwd_anonymous:\n  assumes\n    A: \"s\\<^sub>0 \\<Turnstile> s\" and\n    B: \"n \\<notin> bad_id_password\" and\n    C: \"n \\<notin> bad_shakey \\<inter> (bad_pwd \\<union> bad_prikey) \\<inter> (bad_id_pubkey \\<union> bad_id_shak)\"\n  shows \"\\<langle>n, Pwd n\\<rangle> \\<notin> spied s\"", "theorem auth_prikey_anonymous:\n  assumes\n    A: \"s\\<^sub>0 \\<Turnstile> s\" and\n    B: \"n \\<notin> bad_id_prikey\" and\n    C: \"n \\<notin> bad_shakey \\<inter> bad_prikey \\<inter> (bad_id_password \\<union> bad_id_shak)\"\n  shows \"\\<langle>n, Auth_PriKey n\\<rangle> \\<notin> spied s\"", "theorem auth_shakey_anonymous:\n  assumes\n    A: \"s\\<^sub>0 \\<Turnstile> s\" and\n    B: \"n \\<notin> bad_id_shakey\" and\n    C: \"n \\<notin> bad_shakey \\<inter> (bad_id_password \\<union> bad_id_pubkey)\"\n  shows \"\\<langle>n, Key (Auth_ShaKey n)\\<rangle> \\<notin> spied s\""], "translations": [["", "lemma crypts_union_1:\n \"crypts (H \\<union> H') \\<subseteq> crypts H \\<union> crypts H'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crypts (H \\<union> H') \\<subseteq> crypts H \\<union> crypts H'", "by (rule subsetI, erule crypts.induct, auto)"], ["", "lemma crypts_union_2:\n \"crypts H \\<union> crypts H' \\<subseteq> crypts (H \\<union> H')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crypts H \\<union> crypts H' \\<subseteq> crypts (H \\<union> H')", "by (rule subsetI, erule UnE, erule_tac [!] crypts.induct, auto)"], ["", "proposition crypts_union:\n \"crypts (H \\<union> H') = crypts H \\<union> crypts H'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crypts (H \\<union> H') = crypts H \\<union> crypts H'", "by (rule equalityI, rule crypts_union_1, rule crypts_union_2)"], ["", "proposition crypts_insert:\n \"crypts (insert X H) = crypts_msg X \\<union> crypts H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crypts (insert X H) = crypts_msg X \\<union> crypts H", "by (simp only: insert_def crypts_union, subst crypts_msg_def, simp)"], ["", "proposition crypts_msg_num [simp]:\n \"crypts_msg (Num n) = {Num n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crypts_msg (Num n) = {Num n}", "by (subst crypts_msg_def, rule equalityI, rule subsetI, erule crypts.induct, simp,\n rotate_tac [1-3], erule_tac [1-3] rev_mp, rule_tac [1-3] list.induct, simp_all,\n blast)"], ["", "proposition crypts_msg_agent [simp]:\n \"crypts_msg (Agent n) = {Agent n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crypts_msg (Agent n) = {Agent n}", "by (subst crypts_msg_def, rule equalityI, rule subsetI, erule crypts.induct, simp,\n rotate_tac [1-3], erule_tac [1-3] rev_mp, rule_tac [1-3] list.induct, simp_all,\n blast)"], ["", "proposition crypts_msg_pwd [simp]:\n \"crypts_msg (Pwd n) = {Pwd n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crypts_msg (Pwd n) = {Pwd n}", "by (subst crypts_msg_def, rule equalityI, rule subsetI, erule crypts.induct, simp,\n rotate_tac [1-3], erule_tac [1-3] rev_mp, rule_tac [1-3] list.induct, simp_all,\n blast)"], ["", "proposition crypts_msg_key [simp]:\n \"crypts_msg (Key K) = {Key K}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crypts_msg (Key K) = {Key K}", "by (subst crypts_msg_def, rule equalityI, rule subsetI, erule crypts.induct, simp,\n rotate_tac [1-3], erule_tac [1-3] rev_mp, rule_tac [1-3] list.induct, simp_all,\n blast)"], ["", "proposition crypts_msg_mult [simp]:\n \"crypts_msg (A \\<otimes> B) = {A \\<otimes> B}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crypts_msg (A \\<otimes> B) = {A \\<otimes> B}", "by (subst crypts_msg_def, rule equalityI, rule subsetI, erule crypts.induct, simp,\n rotate_tac [1-3], erule_tac [1-3] rev_mp, rule_tac [1-3] list.induct, simp_all,\n blast)"], ["", "lemma crypts_hash_1:\n \"crypts {Hash X} \\<subseteq> insert (Hash X) (crypts {X})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crypts {Hash X} \\<subseteq> insert (Hash X) (crypts {X})", "by (rule subsetI, erule crypts.induct, simp_all, (erule disjE, rotate_tac, erule rev_mp,\n rule list.induct, simp_all, blast, (drule crypts_hash, simp)?)+)"], ["", "lemma crypts_hash_2:\n \"insert (Hash X) (crypts {X}) \\<subseteq> crypts {Hash X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (Hash X) (crypts {X}) \\<subseteq> crypts {Hash X}", "by (rule subsetI, simp, erule disjE, blast, erule crypts.induct, simp,\n subst id_apply [symmetric], subst foldr_Nil [symmetric], rule crypts_hash, simp,\n blast+)"], ["", "proposition crypts_msg_hash [simp]:\n \"crypts_msg (Hash X) = insert (Hash X) (crypts_msg X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crypts_msg (Hash X) = insert (Hash X) (crypts_msg X)", "by (simp add: crypts_msg_def, rule equalityI, rule crypts_hash_1, rule crypts_hash_2)"], ["", "proposition crypts_comp:\n \"X \\<in> crypts H \\<Longrightarrow> Crypt K X \\<in> crypts (Crypt K ` H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<in> crypts H \\<Longrightarrow> Crypt K X \\<in> crypts (Crypt K ` H)", "by (erule crypts.induct, blast, (simp only: comp_apply\n [symmetric, where f = \"Crypt K\"] foldr_Cons [symmetric],\n (erule crypts_hash | erule crypts_fst | erule crypts_snd))+)"], ["", "lemma crypts_crypt_1:\n \"crypts {Crypt K X} \\<subseteq> Crypt K ` crypts {X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crypts {Crypt K X} \\<subseteq> Crypt K ` crypts {X}", "by (rule subsetI, erule crypts.induct, fastforce, rotate_tac [!], erule_tac [!] rev_mp,\n rule_tac [!] list.induct, auto)"], ["", "lemma crypts_crypt_2:\n \"Crypt K ` crypts {X} \\<subseteq> crypts {Crypt K X}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Crypt K ` crypts {X} \\<subseteq> crypts {Crypt K X}", "by (rule subsetI, simp add: image_iff, erule bexE, drule crypts_comp, simp)"], ["", "proposition crypts_msg_crypt [simp]:\n \"crypts_msg (Crypt K X) = Crypt K ` crypts_msg X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crypts_msg (Crypt K X) = Crypt K ` crypts_msg X", "by (simp add: crypts_msg_def, rule equalityI, rule crypts_crypt_1, rule crypts_crypt_2)"], ["", "lemma crypts_mpair_1:\n \"crypts {\\<lbrace>X, Y\\<rbrace>} \\<subseteq> insert \\<lbrace>X, Y\\<rbrace> (crypts {X} \\<union> crypts {Y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crypts {\\<lbrace>X, Y\\<rbrace>}\n    \\<subseteq> insert \\<lbrace>X, Y\\<rbrace>\n                 (crypts {X} \\<union> crypts {Y})", "by (rule subsetI, erule crypts.induct, simp_all, (erule disjE, rotate_tac, erule rev_mp,\n rule list.induct, (simp+, blast)+)+)"], ["", "lemma crypts_mpair_2:\n \"insert \\<lbrace>X, Y\\<rbrace> (crypts {X} \\<union> crypts {Y}) \\<subseteq> crypts {\\<lbrace>X, Y\\<rbrace>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert \\<lbrace>X, Y\\<rbrace> (crypts {X} \\<union> crypts {Y})\n    \\<subseteq> crypts {\\<lbrace>X, Y\\<rbrace>}", "by (rule subsetI, simp, erule disjE, blast, erule disjE, (erule crypts.induct, simp,\n subst id_apply [symmetric], subst foldr_Nil [symmetric], (rule crypts_fst [of _ X] |\n rule crypts_snd), rule crypts_used, simp, blast+)+)"], ["", "proposition crypts_msg_mpair [simp]:\n \"crypts_msg \\<lbrace>X, Y\\<rbrace> = insert \\<lbrace>X, Y\\<rbrace> (crypts_msg X \\<union> crypts_msg Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. crypts_msg \\<lbrace>X, Y\\<rbrace> =\n    insert \\<lbrace>X, Y\\<rbrace> (crypts_msg X \\<union> crypts_msg Y)", "by (simp add: crypts_msg_def, rule equalityI, rule crypts_mpair_1, rule crypts_mpair_2)"], ["", "proposition foldr_crypt_size:\n \"size (foldr Crypt KS X) = size X + length KS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size (foldr Crypt KS X) = size X + length KS", "by (induction KS, simp_all)"], ["", "proposition key_sets_empty [simp]:\n \"key_sets X {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_sets X {} = {}", "by (simp add: key_sets_def)"], ["", "proposition key_sets_mono:\n \"H \\<subseteq> H' \\<Longrightarrow> key_sets X H \\<subseteq> key_sets X H'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. H \\<subseteq> H' \\<Longrightarrow>\n    key_sets X H \\<subseteq> key_sets X H'", "by (auto simp add: key_sets_def)"], ["", "proposition key_sets_union:\n \"key_sets X (H \\<union> H') = key_sets X H \\<union> key_sets X H'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_sets X (H \\<union> H') = key_sets X H \\<union> key_sets X H'", "by (auto simp add: key_sets_def)"], ["", "proposition key_sets_insert:\n \"key_sets X (insert Y H) = key_sets_msg X Y \\<union> key_sets X H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_sets X (insert Y H) = key_sets_msg X Y \\<union> key_sets X H", "by (simp only: insert_def key_sets_union, subst key_sets_msg_def, simp)"], ["", "proposition key_sets_msg_eq:\n \"key_sets_msg X X = {{}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_sets_msg X X = {{}}", "by (simp add: key_sets_msg_def key_sets_def, rule equalityI, rule subsetI, simp,\n erule exE, erule rev_mp, rule list.induct, simp, rule impI, erule conjE,\n drule arg_cong [of _ X size], simp_all add: foldr_crypt_size)"], ["", "proposition key_sets_msg_num [simp]:\n \"key_sets_msg X (Num n) = (if X = Num n then {{}} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_sets_msg X (Num n) = (if X = Num n then {{}} else {})", "by (simp add: key_sets_msg_eq, simp add: key_sets_msg_def key_sets_def, rule impI,\n rule allI, rule list.induct, simp_all)"], ["", "proposition key_sets_msg_agent [simp]:\n \"key_sets_msg X (Agent n) = (if X = Agent n then {{}} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_sets_msg X (Agent n) = (if X = Agent n then {{}} else {})", "by (simp add: key_sets_msg_eq, simp add: key_sets_msg_def key_sets_def, rule impI,\n rule allI, rule list.induct, simp_all)"], ["", "proposition key_sets_msg_pwd [simp]:\n \"key_sets_msg X (Pwd n) = (if X = Pwd n then {{}} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_sets_msg X (Pwd n) = (if X = Pwd n then {{}} else {})", "by (simp add: key_sets_msg_eq, simp add: key_sets_msg_def key_sets_def, rule impI,\n rule allI, rule list.induct, simp_all)"], ["", "proposition key_sets_msg_key [simp]:\n \"key_sets_msg X (Key K) = (if X = Key K then {{}} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_sets_msg X (Key K) = (if X = Key K then {{}} else {})", "by (simp add: key_sets_msg_eq, simp add: key_sets_msg_def key_sets_def, rule impI,\n rule allI, rule list.induct, simp_all)"], ["", "proposition key_sets_msg_mult [simp]:\n \"key_sets_msg X (A \\<otimes> B) = (if X = A \\<otimes> B then {{}} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_sets_msg X (A \\<otimes> B) =\n    (if X = A \\<otimes> B then {{}} else {})", "by (simp add: key_sets_msg_eq, simp add: key_sets_msg_def key_sets_def, rule impI,\n rule allI, rule list.induct, simp_all)"], ["", "proposition key_sets_msg_hash [simp]:\n \"key_sets_msg X (Hash Y) = (if X = Hash Y then {{}} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_sets_msg X (Hash Y) = (if X = Hash Y then {{}} else {})", "by (simp add: key_sets_msg_eq, simp add: key_sets_msg_def key_sets_def, rule impI,\n rule allI, rule list.induct, simp_all)"], ["", "lemma key_sets_crypt_1:\n \"X \\<noteq> Crypt K Y \\<Longrightarrow>\n    key_sets X {Crypt K Y} \\<subseteq> insert (InvKey K) ` key_sets X {Y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<noteq> Crypt K Y \\<Longrightarrow>\n    key_sets X {Crypt K Y} \\<subseteq> insert (InvKey K) ` key_sets X {Y}", "by (rule subsetI, simp add: key_sets_def, erule exE, rotate_tac, erule rev_mp,\n rule list.induct, auto)"], ["", "lemma key_sets_crypt_2:\n \"insert (InvKey K) ` key_sets X {Y} \\<subseteq> key_sets X {Crypt K Y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (InvKey K) ` key_sets X {Y} \\<subseteq> key_sets X {Crypt K Y}", "by (rule subsetI, simp add: key_sets_def image_iff, (erule exE, erule conjE)+,\n drule arg_cong [where f = \"Crypt K\"], simp only: comp_apply\n [symmetric, of \"Crypt K\"] foldr_Cons [symmetric], subst conj_commute,\n rule exI, rule conjI, assumption, simp)"], ["", "proposition key_sets_msg_crypt [simp]:\n \"key_sets_msg X (Crypt K Y) = (if X = Crypt K Y then {{}} else\n    insert (InvKey K) ` key_sets_msg X Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_sets_msg X (Crypt K Y) =\n    (if X = Crypt K Y then {{}} else insert (InvKey K) ` key_sets_msg X Y)", "by (simp add: key_sets_msg_eq, simp add: key_sets_msg_def, rule impI,\n rule equalityI, erule key_sets_crypt_1 [simplified],\n rule key_sets_crypt_2 [simplified])"], ["", "proposition key_sets_msg_mpair [simp]:\n \"key_sets_msg X \\<lbrace>Y, Z\\<rbrace> = (if X = \\<lbrace>Y, Z\\<rbrace> then {{}} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_sets_msg X \\<lbrace>Y, Z\\<rbrace> =\n    (if X = \\<lbrace>Y, Z\\<rbrace> then {{}} else {})", "by (simp add: key_sets_msg_eq, simp add: key_sets_msg_def key_sets_def, rule impI,\n rule allI, rule list.induct, simp_all)"], ["", "proposition key_sets_range:\n \"U \\<in> key_sets X H \\<Longrightarrow> U \\<subseteq> range Key\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U \\<in> key_sets X H \\<Longrightarrow> U \\<subseteq> range Key", "by (simp add: key_sets_def, blast)"], ["", "proposition key_sets_crypts_hash:\n \"key_sets (Hash X) (crypts H) \\<subseteq> key_sets X (crypts H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_sets (Hash X) (crypts H) \\<subseteq> key_sets X (crypts H)", "by (simp add: key_sets_def, blast)"], ["", "proposition key_sets_crypts_fst:\n \"key_sets \\<lbrace>X, Y\\<rbrace> (crypts H) \\<subseteq> key_sets X (crypts H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_sets \\<lbrace>X, Y\\<rbrace> (crypts H)\n    \\<subseteq> key_sets X (crypts H)", "by (simp add: key_sets_def, blast)"], ["", "proposition key_sets_crypts_snd:\n \"key_sets \\<lbrace>X, Y\\<rbrace> (crypts H) \\<subseteq> key_sets Y (crypts H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_sets \\<lbrace>X, Y\\<rbrace> (crypts H)\n    \\<subseteq> key_sets Y (crypts H)", "by (simp add: key_sets_def, blast)"], ["", "lemma log_spied_1:\n \"\\<lbrakk>s \\<turnstile> s';\n    Log X \\<in> parts (used s) \\<longrightarrow> Log X \\<in> spied s;\n    Log X \\<in> parts (used s')\\<rbrakk> \\<Longrightarrow>\n  Log X \\<in> spied s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<turnstile> s';\n     Log X \\<in> parts (used s) \\<longrightarrow> Log X \\<in> spied s;\n     Log X \\<in> parts (used s')\\<rbrakk>\n    \\<Longrightarrow> Log X \\<in> spied s'", "by (simp add: rel_def, ((erule disjE)?, ((erule exE)+)?, simp add: parts_insert,\n ((subst (asm) disj_assoc [symmetric])?, erule disjE, (drule parts_dec |\n drule parts_enc | drule parts_sep | drule parts_con), simp+)?)+)"], ["", "proposition log_spied [rule_format]:\n \"s\\<^sub>0 \\<Turnstile> s \\<Longrightarrow>\n    Log X \\<in> parts (used s) \\<longrightarrow>\n  Log X \\<in> spied s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^sub>0 \\<Turnstile> s \\<Longrightarrow>\n    Log X \\<in> parts (used s) \\<longrightarrow> Log X \\<in> spied s", "by (erule rtrancl_induct, subst parts_init, simp add: Range_iff image_def, rule impI,\n rule log_spied_1)"], ["", "proposition log_dec:\n \"\\<lbrakk>s\\<^sub>0 \\<Turnstile> s; s' = insert (Spy, X) s \\<and> (Spy, Crypt K X) \\<in> s \\<and>\n    (Spy, Key (InvK K)) \\<in> s\\<rbrakk> \\<Longrightarrow>\n  key_sets Y (crypts {Y. Log Y = X}) \\<subseteq> key_sets Y (crypts (Log -` spied s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s\\<^sub>0 \\<Turnstile> s;\n     s' = insert (Spy, X) s \\<and>\n     (Spy, Crypt K X) \\<in> s \\<and> (Spy, Key (InvK K)) \\<in> s\\<rbrakk>\n    \\<Longrightarrow> key_sets Y (crypts {Y. Log Y = X})\n                      \\<subseteq> key_sets Y (crypts (Log -` spied s))", "by (rule key_sets_mono, rule crypts_mono, rule subsetI, simp, drule parts_dec\n [where Y = X], drule_tac [!] sym, simp_all, rule log_spied [simplified])"], ["", "proposition log_sep:\n \"\\<lbrakk>s\\<^sub>0 \\<Turnstile> s; s' = insert (Spy, X) (insert (Spy, Y) s) \\<and> (Spy, \\<lbrace>X, Y\\<rbrace>) \\<in> s\\<rbrakk> \\<Longrightarrow>\n    key_sets Z (crypts {Z. Log Z = X}) \\<subseteq> key_sets Z (crypts (Log -` spied s)) \\<and>\n    key_sets Z (crypts {Z. Log Z = Y}) \\<subseteq> key_sets Z (crypts (Log -` spied s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s\\<^sub>0 \\<Turnstile> s;\n     s' = insert (Spy, X) (insert (Spy, Y) s) \\<and>\n     (Spy, \\<lbrace>X, Y\\<rbrace>) \\<in> s\\<rbrakk>\n    \\<Longrightarrow> key_sets Z (crypts {Z. Log Z = X})\n                      \\<subseteq> key_sets Z\n                                   (crypts (Log -` spied s)) \\<and>\n                      key_sets Z (crypts {Z. Log Z = Y})\n                      \\<subseteq> key_sets Z (crypts (Log -` spied s))", "by (rule conjI, (rule key_sets_mono, rule crypts_mono, rule subsetI, simp,\n frule parts_sep [where Z = X], drule_tac [2] parts_sep [where Z = Y],\n simp_all add: parts_msg_def, blast+, drule sym, simp,\n rule log_spied [simplified], assumption+)+)"], ["", "lemma idinfo_spied_1:\n \"\\<lbrakk>s \\<turnstile> s';\n    \\<langle>n, X\\<rangle> \\<in> parts (used s) \\<longrightarrow> \\<langle>n, X\\<rangle> \\<in> spied s;\n    \\<langle>n, X\\<rangle> \\<in> parts (used s')\\<rbrakk> \\<Longrightarrow>\n  \\<langle>n, X\\<rangle> \\<in> spied s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<turnstile> s';\n     \\<langle>n, X\\<rangle> \\<in> parts (used s) \\<longrightarrow>\n     \\<langle>n, X\\<rangle> \\<in> spied s;\n     \\<langle>n, X\\<rangle> \\<in> parts (used s')\\<rbrakk>\n    \\<Longrightarrow> \\<langle>n, X\\<rangle> \\<in> spied s'", "by (simp add: rel_def, (erule disjE, (erule exE)+, simp add: parts_insert,\n ((subst (asm) disj_assoc [symmetric])?, erule disjE, (drule parts_dec |\n drule parts_enc | drule parts_sep | drule parts_con), simp+)?)+,\n auto simp add: parts_insert)"], ["", "proposition idinfo_spied [rule_format]:\n \"s\\<^sub>0 \\<Turnstile> s \\<Longrightarrow>\n    \\<langle>n, X\\<rangle> \\<in> parts (used s) \\<longrightarrow>\n  \\<langle>n, X\\<rangle> \\<in> spied s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^sub>0 \\<Turnstile> s \\<Longrightarrow>\n    \\<langle>n, X\\<rangle> \\<in> parts (used s) \\<longrightarrow>\n    \\<langle>n, X\\<rangle> \\<in> spied s", "by (erule rtrancl_induct, subst parts_init, simp add: Range_iff image_def, rule impI,\n rule idinfo_spied_1)"], ["", "proposition idinfo_dec:\n \"\\<lbrakk>s\\<^sub>0 \\<Turnstile> s; s' = insert (Spy, X) s \\<and> (Spy, Crypt K X) \\<in> s \\<and>\n    (Spy, Key (InvK K)) \\<in> s; \\<langle>n, Y\\<rangle> = X\\<rbrakk> \\<Longrightarrow>\n  \\<langle>n, Y\\<rangle> \\<in> spied s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s\\<^sub>0 \\<Turnstile> s;\n     s' = insert (Spy, X) s \\<and>\n     (Spy, Crypt K X) \\<in> s \\<and> (Spy, Key (InvK K)) \\<in> s;\n     \\<langle>n, Y\\<rangle> = X\\<rbrakk>\n    \\<Longrightarrow> \\<langle>n, Y\\<rangle> \\<in> spied s", "by (drule parts_dec [where Y = \"\\<langle>n, Y\\<rangle>\"], drule sym, simp, rule idinfo_spied)"], ["", "proposition idinfo_sep:\n \"\\<lbrakk>s\\<^sub>0 \\<Turnstile> s; s' = insert (Spy, X) (insert (Spy, Y) s) \\<and> (Spy, \\<lbrace>X, Y\\<rbrace>) \\<in> s;\n    \\<langle>n, Z\\<rangle> = X \\<or> \\<langle>n, Z\\<rangle> = Y\\<rbrakk> \\<Longrightarrow>\n  \\<langle>n, Z\\<rangle> \\<in> spied s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s\\<^sub>0 \\<Turnstile> s;\n     s' = insert (Spy, X) (insert (Spy, Y) s) \\<and>\n     (Spy, \\<lbrace>X, Y\\<rbrace>) \\<in> s;\n     \\<langle>n, Z\\<rangle> = X \\<or> \\<langle>n, Z\\<rangle> = Y\\<rbrakk>\n    \\<Longrightarrow> \\<langle>n, Z\\<rangle> \\<in> spied s", "by (drule parts_sep [where Z = \"\\<langle>n, Z\\<rangle>\"], erule disjE, (drule sym, simp)+,\n rule idinfo_spied)"], ["", "lemma idinfo_msg_1:\n  assumes A: \"s\\<^sub>0 \\<Turnstile> s\"\n  shows \"\\<lbrakk>s \\<turnstile> s'; \\<langle>n, X\\<rangle> \\<in> spied s \\<longrightarrow> X \\<in> spied s; \\<langle>n, X\\<rangle> \\<in> spied s'\\<rbrakk> \\<Longrightarrow>\n    X \\<in> spied s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<turnstile> s';\n     \\<langle>n, X\\<rangle> \\<in> spied s \\<longrightarrow> X \\<in> spied s;\n     \\<langle>n, X\\<rangle> \\<in> spied s'\\<rbrakk>\n    \\<Longrightarrow> X \\<in> spied s'", "by (simp add: rel_def, (erule disjE, (erule exE)+, simp, ((subst (asm) disj_assoc\n [symmetric])?, erule disjE, (drule idinfo_dec [OF A] | drule idinfo_sep [OF A]),\n simp+ | erule disjE, (simp add: image_iff)+, blast?)?)+)"], ["", "proposition idinfo_msg [rule_format]:\n \"s\\<^sub>0 \\<Turnstile> s \\<Longrightarrow>\n    \\<langle>n, X\\<rangle> \\<in> spied s \\<longrightarrow>\n  X \\<in> spied s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^sub>0 \\<Turnstile> s \\<Longrightarrow>\n    \\<langle>n, X\\<rangle> \\<in> spied s \\<longrightarrow> X \\<in> spied s", "by (erule rtrancl_induct, simp, blast, rule impI, rule idinfo_msg_1)"], ["", "proposition parts_agent:\n \"\\<lbrakk>s\\<^sub>0 \\<Turnstile> s; n \\<notin> bad_agent\\<rbrakk> \\<Longrightarrow> Agent n \\<notin> parts (used s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s\\<^sub>0 \\<Turnstile> s; n \\<notin> bad_agent\\<rbrakk>\n    \\<Longrightarrow> Agent n \\<notin> parts (used s)", "apply (erule rtrancl_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. n \\<notin> bad_agent \\<Longrightarrow>\n    Agent n \\<notin> parts (used s\\<^sub>0)\n 2. \\<And>y z.\n       \\<lbrakk>n \\<notin> bad_agent; s\\<^sub>0 \\<Turnstile> y;\n        y \\<turnstile> z; Agent n \\<notin> parts (used y)\\<rbrakk>\n       \\<Longrightarrow> Agent n \\<notin> parts (used z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<notin> bad_agent \\<Longrightarrow>\n    Agent n \\<notin> parts (used s\\<^sub>0)", "apply (subst parts_init)"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<notin> bad_agent \\<Longrightarrow>\n    Agent n\n    \\<notin> used s\\<^sub>0 \\<union> range (Hash \\<circ> Agent) \\<union>\n             range (Hash \\<circ> Auth_PubKey) \\<union>\n             range\n              (\\<lambda>n.\n                  \\<lbrace>Hash (Agent n), Hash (Auth_PubKey n)\\<rbrace>)", "apply (simp add: Range_iff image_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>n \\<notin> bad_agent; s\\<^sub>0 \\<Turnstile> y;\n        y \\<turnstile> z; Agent n \\<notin> parts (used y)\\<rbrakk>\n       \\<Longrightarrow> Agent n \\<notin> parts (used z)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<notin> bad_agent; s\\<^sub>0 \\<Turnstile> y_;\n     y_ \\<turnstile> z_; Agent n \\<notin> parts (used y_)\\<rbrakk>\n    \\<Longrightarrow> Agent n \\<notin> parts (used z_)", "apply (simp add: rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<notin> bad_agent;\n     (insert (Spy, VerKey)\n       (range (\\<lambda>x. (Asset x, Key (PriK (Auth_PriK x)))) \\<union>\n        {Spy} \\<times>\n        (range Num \\<union>\n         range (\\<lambda>x. Key (PubK (Auth_PriK x))) \\<union>\n         range\n          (\\<lambda>x.\n              Crypt SigK\n               \\<lbrace>Hash (Agent x),\n                 Hash (Key (PubK (Auth_PriK x)))\\<rbrace>) \\<union>\n         Agent ` bad_agent \\<union>\n         Pwd ` bad_pwd \\<union>\n         (\\<lambda>x. Key (PriK x)) ` bad_prik \\<union>\n         (\\<lambda>x. Key (ShaK x)) ` bad_shak \\<union>\n         (\\<lambda>n. \\<langle>n, Pwd n\\<rangle>) ` bad_id_password \\<union>\n         (\\<lambda>x. \\<langle>x, Key (PriK (Auth_PriK x))\\<rangle>) `\n         bad_id_prikey \\<union>\n         (\\<lambda>x. \\<langle>x, Key (PubK (Auth_PriK x))\\<rangle>) `\n         bad_id_pubkey \\<union>\n         (\\<lambda>x. \\<langle>x, Key (ShaK (Auth_ShaK x))\\<rangle>) `\n         bad_id_shakey)),\n      y_)\n     \\<in> ({(s, s').\n             \\<exists>n S.\n                s' =\n                insert\n                 (Spy, Log (Crypt (ShaK (Auth_ShaK n)) (Key (PriK S))))\n                 (insert\n                   (Asset n, Crypt (ShaK (Auth_ShaK n)) (Key (PriK S)))\n                   (insert (Spy, Crypt (ShaK (Auth_ShaK n)) (Key (PriK S)))\n                     (insert (Asset n, Key (PriK S)) s))) \\<and>\n                Key (PriK S) \\<notin> used s} \\<union>\n            {(s, s').\n             \\<exists>n S A K.\n                s' =\n                insert (Spy, Log (Crypt K (Key (PriK S))))\n                 (insert\n                   (Spy, Log \\<lbrace>Num (Suc 0), Key (PubK A)\\<rbrace>)\n                   (insert\n                     (Owner n, \\<lbrace>Num (Suc 0), Key (PubK A)\\<rbrace>)\n                     (insert\n                       (Spy, \\<lbrace>Num (Suc 0), Key (PubK A)\\<rbrace>)\n                       (insert (Owner n, Key (PriK A)) s)))) \\<and>\n                Crypt K (Key (PriK S)) \\<in> used s \\<and>\n                Key (PriK A) \\<notin> used s} \\<union>\n            {(s, s').\n             \\<exists>n A B.\n                s' =\n                insert\n                 (Spy, Log \\<lbrace>Num (Suc 0), Key (PubK A)\\<rbrace>)\n                 (insert (Spy, Log \\<lbrace>Num 2, Key (PubK B)\\<rbrace>)\n                   (insert (Asset n, \\<lbrace>Num 2, Key (PubK B)\\<rbrace>)\n                     (insert (Spy, \\<lbrace>Num 2, Key (PubK B)\\<rbrace>)\n                       (insert (Asset n, Key (PriK B)) s)))) \\<and>\n                \\<lbrace>Num (Suc 0), Key (PubK A)\\<rbrace>\n                \\<in> used s \\<and>\n                Key (PriK B) \\<notin> used s} \\<union>\n            {(s, s').\n             \\<exists>n B C.\n                s' =\n                insert (Spy, Log \\<lbrace>Num 2, Key (PubK B)\\<rbrace>)\n                 (insert (Spy, Log \\<lbrace>Num 3, Key (PubK C)\\<rbrace>)\n                   (insert (Owner n, \\<lbrace>Num 3, Key (PubK C)\\<rbrace>)\n                     (insert (Spy, \\<lbrace>Num 3, Key (PubK C)\\<rbrace>)\n                       (insert (Owner n, Key (PriK C)) s)))) \\<and>\n                \\<lbrace>Num 2, Key (PubK B)\\<rbrace> \\<in> used s \\<and>\n                Key (PriK C) \\<notin> used s} \\<union>\n            {(s, s').\n             \\<exists>n C D.\n                s' =\n                insert (Spy, Log \\<lbrace>Num 3, Key (PubK C)\\<rbrace>)\n                 (insert (Spy, Log \\<lbrace>Num 4, Key (PubK D)\\<rbrace>)\n                   (insert (Asset n, \\<lbrace>Num 4, Key (PubK D)\\<rbrace>)\n                     (insert (Spy, \\<lbrace>Num 4, Key (PubK D)\\<rbrace>)\n                       (insert (Asset n, Key (PriK D)) s)))) \\<and>\n                \\<lbrace>Num 3, Key (PubK C)\\<rbrace> \\<in> used s \\<and>\n                Key (PriK D) \\<notin> used s} \\<union>\n            {(s, s').\n             \\<exists>n S A B C D K.\n                s' =\n                insert (Spy, Log \\<lbrace>Num 4, Key (PubK D)\\<rbrace>)\n                 (insert\n                   (Spy,\n                    Log (Crypt\n                          (SesK\n                            (if K = ShaK (Auth_ShaK n) then Some S\n                             else None,\n                             {A, B}, {C, D}))\n                          (Key (PubK D))))\n                   (insert\n                     (Owner n,\n                      Crypt\n                       (SesK\n                         (if K = ShaK (Auth_ShaK n) then Some S else None,\n                          {A, B}, {C, D}))\n                       (Key (PubK D)))\n                     (insert\n                       (Spy,\n                        Crypt\n                         (SesK\n                           (if K = ShaK (Auth_ShaK n) then Some S else None,\n                            {A, B}, {C, D}))\n                         (Key (PubK D)))\n                       (insert\n                         (Owner n,\n                          Key (SesK\n                                (if K = ShaK (Auth_ShaK n) then Some S\n                                 else None,\n                                 {A, B}, {C, D})))\n                         s)))) \\<and>\n                Crypt K (Key (PriK S)) \\<in> used s \\<and>\n                \\<lbrace>Num 2, Key (PubK B)\\<rbrace> \\<in> used s \\<and>\n                \\<lbrace>Num 4, Key (PubK D)\\<rbrace> \\<in> used s \\<and>\n                (Owner n, \\<lbrace>Num (Suc 0), Key (PubK A)\\<rbrace>)\n                \\<in> s \\<and>\n                (Owner n, \\<lbrace>Num 3, Key (PubK C)\\<rbrace>)\n                \\<in> s} \\<union>\n            {(s, s').\n             \\<exists>n S A B C D.\n                s' =\n                insert\n                 (Spy,\n                  Log (Crypt (SesK (Some S, {A, B}, {C, D}))\n                        (Key (PubK D))))\n                 (insert\n                   (Spy,\n                    Log \\<lbrace>Crypt (SesK (Some S, {A, B}, {C, D}))\n                                  (Key (PubK C)),\n                          Crypt (SesK (Some S, {A, B}, {C, D}))\n                           (Auth_PriK n \\<otimes> B),\n                          Crypt (SesK (Some S, {A, B}, {C, D}))\n                           (Crypt SigK\n                             \\<lbrace>Hash (Agent n),\n                               Hash\n                                (Key (PubK\n (Auth_PriK n)))\\<rbrace>)\\<rbrace>)\n                   (insert\n                     (Asset n,\n                      \\<lbrace>Crypt (SesK (Some S, {A, B}, {C, D}))\n                                (Key (PubK C)),\n                        Crypt (SesK (Some S, {A, B}, {C, D}))\n                         (Auth_PriK n \\<otimes> B),\n                        Crypt (SesK (Some S, {A, B}, {C, D}))\n                         (Crypt SigK\n                           \\<lbrace>Hash (Agent n),\n                             Hash\n                              (Key (PubK (Auth_PriK n)))\\<rbrace>)\\<rbrace>)\n                     (insert\n                       (Spy,\n                        \\<lbrace>Crypt (SesK (Some S, {A, B}, {C, D}))\n                                  (Key (PubK C)),\n                          Crypt (SesK (Some S, {A, B}, {C, D}))\n                           (Auth_PriK n \\<otimes> B),\n                          Crypt (SesK (Some S, {A, B}, {C, D}))\n                           (Crypt SigK\n                             \\<lbrace>Hash (Agent n),\n                               Hash\n                                (Key (PubK\n (Auth_PriK n)))\\<rbrace>)\\<rbrace>)\n                       (insert\n                         (Asset n, Key (SesK (Some S, {A, B}, {C, D})))\n                         (insert (Asset n, Key (PubK B)) s))))) \\<and>\n                (Asset n, Crypt (ShaK (Auth_ShaK n)) (Key (PriK S)))\n                \\<in> s \\<and>\n                (Asset n, \\<lbrace>Num 2, Key (PubK B)\\<rbrace>)\n                \\<in> s \\<and>\n                (Asset n, \\<lbrace>Num 4, Key (PubK D)\\<rbrace>)\n                \\<in> s \\<and>\n                \\<lbrace>Num (Suc 0), Key (PubK A)\\<rbrace>\n                \\<in> used s \\<and>\n                \\<lbrace>Num 3, Key (PubK C)\\<rbrace> \\<in> used s \\<and>\n                Crypt (SesK (Some S, {A, B}, {C, D})) (Key (PubK D))\n                \\<in> used s \\<and>\n                (Asset n, Key (PubK B)) \\<notin> s} \\<union>\n            {(s, s').\n             \\<exists>n A B C a aa b.\n                s' =\n                insert\n                 (Spy,\n                  Log \\<lbrace>Crypt (SesK (a, aa, b)) (Key (PubK C)),\n                        Crypt (SesK (a, aa, b)) (A \\<otimes> B),\n                        Crypt (SesK (a, aa, b))\n                         (Crypt SigK\n                           \\<lbrace>Hash (Agent n),\n                             Hash (Key (PubK A))\\<rbrace>)\\<rbrace>)\n                 (insert (Spy, Log (Crypt (SesK (a, aa, b)) (Pwd n)))\n                   (insert (Owner n, Crypt (SesK (a, aa, b)) (Pwd n))\n                     (insert (Spy, Crypt (SesK (a, aa, b)) (Pwd n))\n                       s))) \\<and>\n                \\<lbrace>Crypt (SesK (a, aa, b)) (Key (PubK C)),\n                  Crypt (SesK (a, aa, b)) (A \\<otimes> B),\n                  Crypt (SesK (a, aa, b))\n                   (Crypt SigK\n                     \\<lbrace>Hash (Agent n),\n                       Hash (Key (PubK A))\\<rbrace>)\\<rbrace>\n                \\<in> used s \\<and>\n                (Owner n, Key (SesK (a, aa, b))) \\<in> s \\<and>\n                B \\<in> aa} \\<union>\n            {(s, s').\n             \\<exists>n a aa b.\n                s' =\n                insert (Spy, Log (Crypt (SesK (a, aa, b)) (Pwd n)))\n                 (insert (Spy, Log (Crypt (SesK (a, aa, b)) (Num 0)))\n                   (insert (Asset n, Crypt (SesK (a, aa, b)) (Num 0))\n                     (insert (Spy, Crypt (SesK (a, aa, b)) (Num 0))\n                       s))) \\<and>\n                (Asset n, Key (SesK (a, aa, b))) \\<in> s \\<and>\n                Crypt (SesK (a, aa, b)) (Pwd n) \\<in> used s} \\<union>\n            {(s, s').\n             \\<exists>A.\n                s' = insert (Spy, Key (PriK A)) s \\<and>\n                Key (PriK A) \\<notin> used s} \\<union>\n            {(s, s').\n             \\<exists>A.\n                s' = insert (Spy, Key (PubK A)) s \\<and>\n                (Spy, Key (PriK A)) \\<in> s} \\<union>\n            {(s, s').\n             \\<exists>A B C D S.\n                s' =\n                insert (Spy, Key (SesK (Some S, {A, B}, {C, D}))) s \\<and>\n                (Spy, Key (PriK S)) \\<in> s \\<and>\n                (Spy, Key (PriK A)) \\<in> s \\<and>\n                (Spy, Key (PubK B)) \\<in> s \\<and>\n                (Spy, Key (PriK C)) \\<in> s \\<and>\n                (Spy, Key (PubK D)) \\<in> s} \\<union>\n            {(s, s').\n             \\<exists>A B.\n                s' =\n                insert (Spy, Key (PriK A))\n                 (insert (Spy, Key (PriK B)) s) \\<and>\n                (Spy, A \\<otimes> B) \\<in> s \\<and>\n                ((Spy, Key (PriK A)) \\<in> s \\<or>\n                 (Spy, Key (PriK B)) \\<in> s)} \\<union>\n            {(s, s').\n             \\<exists>A B.\n                s' = insert (Spy, A \\<otimes> B) s \\<and>\n                (Spy, Key (PriK A)) \\<in> s \\<and>\n                (Spy, Key (PriK B)) \\<in> s} \\<union>\n            {(s, s').\n             \\<exists>X.\n                s' = insert (Spy, Hash X) s \\<and>\n                (Spy, X) \\<in> s} \\<union>\n            {(s, s').\n             \\<exists>K X.\n                s' = insert (Spy, X) s \\<and>\n                (Spy, Crypt K X) \\<in> s \\<and>\n                (Spy, Key (InvK K)) \\<in> s} \\<union>\n            {(s, s').\n             \\<exists>K X.\n                s' = insert (Spy, Crypt K X) s \\<and>\n                (Spy, X) \\<in> s \\<and> (Spy, Key K) \\<in> s} \\<union>\n            {(s, s').\n             \\<exists>X Y.\n                s' = insert (Spy, X) (insert (Spy, Y) s) \\<and>\n                (Spy, \\<lbrace>X, Y\\<rbrace>) \\<in> s} \\<union>\n            {(s, s').\n             \\<exists>X Y.\n                s' = insert (Spy, \\<lbrace>X, Y\\<rbrace>) s \\<and>\n                (Spy, X) \\<in> s \\<and> (Spy, Y) \\<in> s} \\<union>\n            {(s, s').\n             \\<exists>n.\n                s' = insert (Spy, \\<langle>n, Agent n\\<rangle>) s \\<and>\n                (Spy, Agent n) \\<in> s} \\<union>\n            {(s, s').\n             \\<exists>n K.\n                s' =\n                insert (Spy, \\<langle>n, Key (InvK K)\\<rangle>) s \\<and>\n                (Spy, Key (InvK K)) \\<in> s \\<and>\n                (Spy, \\<langle>n, Key K\\<rangle>) \\<in> s} \\<union>\n            {(s, s').\n             \\<exists>n A a aa b.\n                s' =\n                insert (Spy, \\<langle>n, Key (PubK A)\\<rangle>)\n                 (insert (Spy, \\<langle>n, Key (SesK (a, aa, b))\\<rangle>)\n                   s) \\<and>\n                (Spy, Key (PubK A)) \\<in> s \\<and>\n                (Spy, Key (SesK (a, aa, b))) \\<in> s \\<and>\n                ((Spy, \\<langle>n, Key (PubK A)\\<rangle>) \\<in> s \\<or>\n                 (Spy, \\<langle>n, Key (SesK (a, aa, b))\\<rangle>)\n                 \\<in> s) \\<and>\n                A \\<in> seskey_set (a, aa, b) \\<and>\n                (\\<exists>X U.\n                    Key (SesK (a, aa, b)) \\<in> U \\<and>\n                    U \\<in> key_sets X (crypts (Log -` spied s)))} \\<union>\n            {(s, s').\n             \\<exists>n A B.\n                s' =\n                insert (Spy, \\<langle>n, Key (PriK A)\\<rangle>)\n                 (insert (Spy, \\<langle>n, Key (PriK B)\\<rangle>) s) \\<and>\n                (Spy, Key (PriK A)) \\<in> s \\<and>\n                (Spy, Key (PriK B)) \\<in> s \\<and>\n                (Spy, \\<langle>n, A \\<otimes> B\\<rangle>) \\<in> s} \\<union>\n            {(s, s').\n             \\<exists>n A B.\n                s' =\n                insert (Spy, \\<langle>n, A \\<otimes> B\\<rangle>) s \\<and>\n                (Spy, Key (PriK A)) \\<in> s \\<and>\n                (Spy, Key (PriK B)) \\<in> s \\<and>\n                (Spy, A \\<otimes> B) \\<in> s \\<and>\n                (\\<exists>U\\<subseteq>spied s.\n                    ((Spy, \\<langle>n, Key (PriK A)\\<rangle>) \\<in> s \\<or>\n                     (Spy, \\<langle>n, Key (PriK B)\\<rangle>)\n                     \\<in> s) \\<and>\n                    U \\<in> key_sets (A \\<otimes> B)\n                             (crypts (Log -` spied s)))} \\<union>\n            {(s, s').\n             \\<exists>n X.\n                s' =\n                insert (Spy, \\<langle>n, X\\<rangle>)\n                 (insert (Spy, \\<langle>n, Hash X\\<rangle>) s) \\<and>\n                (Spy, X) \\<in> s \\<and>\n                (Spy, Hash X) \\<in> s \\<and>\n                (\\<exists>U\\<subseteq>spied s.\n                    ((Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<or>\n                     (Spy, \\<langle>n, Hash X\\<rangle>) \\<in> s) \\<and>\n                    U \\<in> key_sets (Hash X)\n                             (crypts (Log -` spied s)))} \\<union>\n            {(s, s').\n             \\<exists>n X U.\n                s' =\n                insert (Spy, \\<langle>n, X\\<rangle>)\n                 (s \\<union> {Spy} \\<times> IDInfo n ` U) \\<and>\n                (Spy, X) \\<in> s \\<and>\n                U \\<subseteq> spied s \\<and>\n                ((Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<or>\n                 (\\<exists>K\\<in>U.\n                     (Spy, \\<langle>n, K\\<rangle>) \\<in> s)) \\<and>\n                U \\<in> key_sets X (crypts (Log -` spied s))} \\<union>\n            {(s, s').\n             \\<exists>n X Y.\n                s' =\n                insert (Spy, \\<langle>n, X\\<rangle>)\n                 (insert (Spy, \\<langle>n, Y\\<rangle>) s) \\<and>\n                (Spy, X) \\<in> s \\<and>\n                (Spy, Y) \\<in> s \\<and>\n                (Spy, \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle>)\n                \\<in> s} \\<union>\n            {(s, s').\n             \\<exists>n X Y.\n                s' =\n                insert (Spy, \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle>)\n                 s \\<and>\n                (Spy, X) \\<in> s \\<and>\n                (Spy, Y) \\<in> s \\<and>\n                (Spy, \\<lbrace>X, Y\\<rbrace>) \\<in> s \\<and>\n                (\\<exists>U\\<subseteq>spied s.\n                    ((Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<or>\n                     (Spy, \\<langle>n, Y\\<rangle>) \\<in> s) \\<and>\n                    U \\<in> key_sets \\<lbrace>X, Y\\<rbrace>\n                             (crypts (Log -` spied s)))})\\<^sup>*;\n     (\\<exists>n S.\n         z_ =\n         insert (Spy, Log (Crypt (ShaK (Auth_ShaK n)) (Key (PriK S))))\n          (insert (Asset n, Crypt (ShaK (Auth_ShaK n)) (Key (PriK S)))\n            (insert (Spy, Crypt (ShaK (Auth_ShaK n)) (Key (PriK S)))\n              (insert (Asset n, Key (PriK S)) y_))) \\<and>\n         Key (PriK S) \\<notin> used y_) \\<or>\n     (\\<exists>n S A K.\n         z_ =\n         insert (Spy, Log (Crypt K (Key (PriK S))))\n          (insert (Spy, Log \\<lbrace>Num (Suc 0), Key (PubK A)\\<rbrace>)\n            (insert (Owner n, \\<lbrace>Num (Suc 0), Key (PubK A)\\<rbrace>)\n              (insert (Spy, \\<lbrace>Num (Suc 0), Key (PubK A)\\<rbrace>)\n                (insert (Owner n, Key (PriK A)) y_)))) \\<and>\n         Crypt K (Key (PriK S)) \\<in> used y_ \\<and>\n         Key (PriK A) \\<notin> used y_) \\<or>\n     (\\<exists>n A B.\n         z_ =\n         insert (Spy, Log \\<lbrace>Num (Suc 0), Key (PubK A)\\<rbrace>)\n          (insert (Spy, Log \\<lbrace>Num 2, Key (PubK B)\\<rbrace>)\n            (insert (Asset n, \\<lbrace>Num 2, Key (PubK B)\\<rbrace>)\n              (insert (Spy, \\<lbrace>Num 2, Key (PubK B)\\<rbrace>)\n                (insert (Asset n, Key (PriK B)) y_)))) \\<and>\n         \\<lbrace>Num (Suc 0), Key (PubK A)\\<rbrace> \\<in> used y_ \\<and>\n         Key (PriK B) \\<notin> used y_) \\<or>\n     (\\<exists>n B C.\n         z_ =\n         insert (Spy, Log \\<lbrace>Num 2, Key (PubK B)\\<rbrace>)\n          (insert (Spy, Log \\<lbrace>Num 3, Key (PubK C)\\<rbrace>)\n            (insert (Owner n, \\<lbrace>Num 3, Key (PubK C)\\<rbrace>)\n              (insert (Spy, \\<lbrace>Num 3, Key (PubK C)\\<rbrace>)\n                (insert (Owner n, Key (PriK C)) y_)))) \\<and>\n         \\<lbrace>Num 2, Key (PubK B)\\<rbrace> \\<in> used y_ \\<and>\n         Key (PriK C) \\<notin> used y_) \\<or>\n     (\\<exists>n C D.\n         z_ =\n         insert (Spy, Log \\<lbrace>Num 3, Key (PubK C)\\<rbrace>)\n          (insert (Spy, Log \\<lbrace>Num 4, Key (PubK D)\\<rbrace>)\n            (insert (Asset n, \\<lbrace>Num 4, Key (PubK D)\\<rbrace>)\n              (insert (Spy, \\<lbrace>Num 4, Key (PubK D)\\<rbrace>)\n                (insert (Asset n, Key (PriK D)) y_)))) \\<and>\n         \\<lbrace>Num 3, Key (PubK C)\\<rbrace> \\<in> used y_ \\<and>\n         Key (PriK D) \\<notin> used y_) \\<or>\n     (\\<exists>n S A B C D K.\n         z_ =\n         insert (Spy, Log \\<lbrace>Num 4, Key (PubK D)\\<rbrace>)\n          (insert\n            (Spy,\n             Log (Crypt\n                   (SesK\n                     (if K = ShaK (Auth_ShaK n) then Some S else None,\n                      {A, B}, {C, D}))\n                   (Key (PubK D))))\n            (insert\n              (Owner n,\n               Crypt\n                (SesK\n                  (if K = ShaK (Auth_ShaK n) then Some S else None, {A, B},\n                   {C, D}))\n                (Key (PubK D)))\n              (insert\n                (Spy,\n                 Crypt\n                  (SesK\n                    (if K = ShaK (Auth_ShaK n) then Some S else None,\n                     {A, B}, {C, D}))\n                  (Key (PubK D)))\n                (insert\n                  (Owner n,\n                   Key (SesK\n                         (if K = ShaK (Auth_ShaK n) then Some S else None,\n                          {A, B}, {C, D})))\n                  y_)))) \\<and>\n         Crypt K (Key (PriK S)) \\<in> used y_ \\<and>\n         \\<lbrace>Num 2, Key (PubK B)\\<rbrace> \\<in> used y_ \\<and>\n         \\<lbrace>Num 4, Key (PubK D)\\<rbrace> \\<in> used y_ \\<and>\n         (Owner n, \\<lbrace>Num (Suc 0), Key (PubK A)\\<rbrace>)\n         \\<in> y_ \\<and>\n         (Owner n, \\<lbrace>Num 3, Key (PubK C)\\<rbrace>) \\<in> y_) \\<or>\n     (\\<exists>n S A B C D.\n         z_ =\n         insert\n          (Spy, Log (Crypt (SesK (Some S, {A, B}, {C, D})) (Key (PubK D))))\n          (insert\n            (Spy,\n             Log \\<lbrace>Crypt (SesK (Some S, {A, B}, {C, D}))\n                           (Key (PubK C)),\n                   Crypt (SesK (Some S, {A, B}, {C, D}))\n                    (Auth_PriK n \\<otimes> B),\n                   Crypt (SesK (Some S, {A, B}, {C, D}))\n                    (Crypt SigK\n                      \\<lbrace>Hash (Agent n),\n                        Hash (Key (PubK (Auth_PriK n)))\\<rbrace>)\\<rbrace>)\n            (insert\n              (Asset n,\n               \\<lbrace>Crypt (SesK (Some S, {A, B}, {C, D}))\n                         (Key (PubK C)),\n                 Crypt (SesK (Some S, {A, B}, {C, D}))\n                  (Auth_PriK n \\<otimes> B),\n                 Crypt (SesK (Some S, {A, B}, {C, D}))\n                  (Crypt SigK\n                    \\<lbrace>Hash (Agent n),\n                      Hash (Key (PubK (Auth_PriK n)))\\<rbrace>)\\<rbrace>)\n              (insert\n                (Spy,\n                 \\<lbrace>Crypt (SesK (Some S, {A, B}, {C, D}))\n                           (Key (PubK C)),\n                   Crypt (SesK (Some S, {A, B}, {C, D}))\n                    (Auth_PriK n \\<otimes> B),\n                   Crypt (SesK (Some S, {A, B}, {C, D}))\n                    (Crypt SigK\n                      \\<lbrace>Hash (Agent n),\n                        Hash (Key (PubK (Auth_PriK n)))\\<rbrace>)\\<rbrace>)\n                (insert (Asset n, Key (SesK (Some S, {A, B}, {C, D})))\n                  (insert (Asset n, Key (PubK B)) y_))))) \\<and>\n         (Asset n, Crypt (ShaK (Auth_ShaK n)) (Key (PriK S)))\n         \\<in> y_ \\<and>\n         (Asset n, \\<lbrace>Num 2, Key (PubK B)\\<rbrace>) \\<in> y_ \\<and>\n         (Asset n, \\<lbrace>Num 4, Key (PubK D)\\<rbrace>) \\<in> y_ \\<and>\n         \\<lbrace>Num (Suc 0), Key (PubK A)\\<rbrace> \\<in> used y_ \\<and>\n         \\<lbrace>Num 3, Key (PubK C)\\<rbrace> \\<in> used y_ \\<and>\n         Crypt (SesK (Some S, {A, B}, {C, D})) (Key (PubK D))\n         \\<in> used y_ \\<and>\n         (Asset n, Key (PubK B)) \\<notin> y_) \\<or>\n     (\\<exists>n A B C a aa b.\n         z_ =\n         insert\n          (Spy,\n           Log \\<lbrace>Crypt (SesK (a, aa, b)) (Key (PubK C)),\n                 Crypt (SesK (a, aa, b)) (A \\<otimes> B),\n                 Crypt (SesK (a, aa, b))\n                  (Crypt SigK\n                    \\<lbrace>Hash (Agent n),\n                      Hash (Key (PubK A))\\<rbrace>)\\<rbrace>)\n          (insert (Spy, Log (Crypt (SesK (a, aa, b)) (Pwd n)))\n            (insert (Owner n, Crypt (SesK (a, aa, b)) (Pwd n))\n              (insert (Spy, Crypt (SesK (a, aa, b)) (Pwd n)) y_))) \\<and>\n         \\<lbrace>Crypt (SesK (a, aa, b)) (Key (PubK C)),\n           Crypt (SesK (a, aa, b)) (A \\<otimes> B),\n           Crypt (SesK (a, aa, b))\n            (Crypt SigK\n              \\<lbrace>Hash (Agent n),\n                Hash (Key (PubK A))\\<rbrace>)\\<rbrace>\n         \\<in> used y_ \\<and>\n         (Owner n, Key (SesK (a, aa, b))) \\<in> y_ \\<and> B \\<in> aa) \\<or>\n     (\\<exists>n a aa b.\n         z_ =\n         insert (Spy, Log (Crypt (SesK (a, aa, b)) (Pwd n)))\n          (insert (Spy, Log (Crypt (SesK (a, aa, b)) (Num 0)))\n            (insert (Asset n, Crypt (SesK (a, aa, b)) (Num 0))\n              (insert (Spy, Crypt (SesK (a, aa, b)) (Num 0)) y_))) \\<and>\n         (Asset n, Key (SesK (a, aa, b))) \\<in> y_ \\<and>\n         Crypt (SesK (a, aa, b)) (Pwd n) \\<in> used y_) \\<or>\n     (\\<exists>A.\n         z_ = insert (Spy, Key (PriK A)) y_ \\<and>\n         Key (PriK A) \\<notin> used y_) \\<or>\n     (\\<exists>A.\n         z_ = insert (Spy, Key (PubK A)) y_ \\<and>\n         (Spy, Key (PriK A)) \\<in> y_) \\<or>\n     (\\<exists>A B C D S.\n         z_ = insert (Spy, Key (SesK (Some S, {A, B}, {C, D}))) y_ \\<and>\n         (Spy, Key (PriK S)) \\<in> y_ \\<and>\n         (Spy, Key (PriK A)) \\<in> y_ \\<and>\n         (Spy, Key (PubK B)) \\<in> y_ \\<and>\n         (Spy, Key (PriK C)) \\<in> y_ \\<and>\n         (Spy, Key (PubK D)) \\<in> y_) \\<or>\n     (\\<exists>A B.\n         z_ =\n         insert (Spy, Key (PriK A)) (insert (Spy, Key (PriK B)) y_) \\<and>\n         (Spy, A \\<otimes> B) \\<in> y_ \\<and>\n         ((Spy, Key (PriK A)) \\<in> y_ \\<or>\n          (Spy, Key (PriK B)) \\<in> y_)) \\<or>\n     (\\<exists>A B.\n         z_ = insert (Spy, A \\<otimes> B) y_ \\<and>\n         (Spy, Key (PriK A)) \\<in> y_ \\<and>\n         (Spy, Key (PriK B)) \\<in> y_) \\<or>\n     (\\<exists>X.\n         z_ = insert (Spy, Hash X) y_ \\<and> (Spy, X) \\<in> y_) \\<or>\n     (\\<exists>K X.\n         z_ = insert (Spy, X) y_ \\<and>\n         (Spy, Crypt K X) \\<in> y_ \\<and>\n         (Spy, Key (InvK K)) \\<in> y_) \\<or>\n     (\\<exists>K X.\n         z_ = insert (Spy, Crypt K X) y_ \\<and>\n         (Spy, X) \\<in> y_ \\<and> (Spy, Key K) \\<in> y_) \\<or>\n     (\\<exists>X Y.\n         z_ = insert (Spy, X) (insert (Spy, Y) y_) \\<and>\n         (Spy, \\<lbrace>X, Y\\<rbrace>) \\<in> y_) \\<or>\n     (\\<exists>X Y.\n         z_ = insert (Spy, \\<lbrace>X, Y\\<rbrace>) y_ \\<and>\n         (Spy, X) \\<in> y_ \\<and> (Spy, Y) \\<in> y_) \\<or>\n     (\\<exists>n.\n         z_ = insert (Spy, \\<langle>n, Agent n\\<rangle>) y_ \\<and>\n         (Spy, Agent n) \\<in> y_) \\<or>\n     (\\<exists>n K.\n         z_ = insert (Spy, \\<langle>n, Key (InvK K)\\<rangle>) y_ \\<and>\n         (Spy, Key (InvK K)) \\<in> y_ \\<and>\n         (Spy, \\<langle>n, Key K\\<rangle>) \\<in> y_) \\<or>\n     (\\<exists>n A a aa b.\n         z_ =\n         insert (Spy, \\<langle>n, Key (PubK A)\\<rangle>)\n          (insert (Spy, \\<langle>n, Key (SesK (a, aa, b))\\<rangle>)\n            y_) \\<and>\n         (Spy, Key (PubK A)) \\<in> y_ \\<and>\n         (Spy, Key (SesK (a, aa, b))) \\<in> y_ \\<and>\n         ((Spy, \\<langle>n, Key (PubK A)\\<rangle>) \\<in> y_ \\<or>\n          (Spy, \\<langle>n, Key (SesK (a, aa, b))\\<rangle>) \\<in> y_) \\<and>\n         A \\<in> seskey_set (a, aa, b) \\<and>\n         (\\<exists>X U.\n             Key (SesK (a, aa, b)) \\<in> U \\<and>\n             U \\<in> key_sets X (crypts (Log -` spied y_)))) \\<or>\n     (\\<exists>n A B.\n         z_ =\n         insert (Spy, \\<langle>n, Key (PriK A)\\<rangle>)\n          (insert (Spy, \\<langle>n, Key (PriK B)\\<rangle>) y_) \\<and>\n         (Spy, Key (PriK A)) \\<in> y_ \\<and>\n         (Spy, Key (PriK B)) \\<in> y_ \\<and>\n         (Spy, \\<langle>n, A \\<otimes> B\\<rangle>) \\<in> y_) \\<or>\n     (\\<exists>n A B.\n         z_ = insert (Spy, \\<langle>n, A \\<otimes> B\\<rangle>) y_ \\<and>\n         (Spy, Key (PriK A)) \\<in> y_ \\<and>\n         (Spy, Key (PriK B)) \\<in> y_ \\<and>\n         (Spy, A \\<otimes> B) \\<in> y_ \\<and>\n         (\\<exists>U\\<subseteq>spied y_.\n             ((Spy, \\<langle>n, Key (PriK A)\\<rangle>) \\<in> y_ \\<or>\n              (Spy, \\<langle>n, Key (PriK B)\\<rangle>) \\<in> y_) \\<and>\n             U \\<in> key_sets (A \\<otimes> B)\n                      (crypts (Log -` spied y_)))) \\<or>\n     (\\<exists>n X.\n         z_ =\n         insert (Spy, \\<langle>n, X\\<rangle>)\n          (insert (Spy, \\<langle>n, Hash X\\<rangle>) y_) \\<and>\n         (Spy, X) \\<in> y_ \\<and>\n         (Spy, Hash X) \\<in> y_ \\<and>\n         (\\<exists>U\\<subseteq>spied y_.\n             ((Spy, \\<langle>n, X\\<rangle>) \\<in> y_ \\<or>\n              (Spy, \\<langle>n, Hash X\\<rangle>) \\<in> y_) \\<and>\n             U \\<in> key_sets (Hash X) (crypts (Log -` spied y_)))) \\<or>\n     (\\<exists>n X U.\n         z_ =\n         insert (Spy, \\<langle>n, X\\<rangle>)\n          (y_ \\<union> {Spy} \\<times> IDInfo n ` U) \\<and>\n         (Spy, X) \\<in> y_ \\<and>\n         U \\<subseteq> spied y_ \\<and>\n         ((Spy, \\<langle>n, X\\<rangle>) \\<in> y_ \\<or>\n          (\\<exists>K\\<in>U. (Spy, \\<langle>n, K\\<rangle>) \\<in> y_)) \\<and>\n         U \\<in> key_sets X (crypts (Log -` spied y_))) \\<or>\n     (\\<exists>n X Y.\n         z_ =\n         insert (Spy, \\<langle>n, X\\<rangle>)\n          (insert (Spy, \\<langle>n, Y\\<rangle>) y_) \\<and>\n         (Spy, X) \\<in> y_ \\<and>\n         (Spy, Y) \\<in> y_ \\<and>\n         (Spy, \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle>) \\<in> y_) \\<or>\n     (\\<exists>n X Y.\n         z_ =\n         insert (Spy, \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle>) y_ \\<and>\n         (Spy, X) \\<in> y_ \\<and>\n         (Spy, Y) \\<in> y_ \\<and>\n         (Spy, \\<lbrace>X, Y\\<rbrace>) \\<in> y_ \\<and>\n         (\\<exists>U\\<subseteq>spied y_.\n             ((Spy, \\<langle>n, X\\<rangle>) \\<in> y_ \\<or>\n              (Spy, \\<langle>n, Y\\<rangle>) \\<in> y_) \\<and>\n             U \\<in> key_sets \\<lbrace>X, Y\\<rbrace>\n                      (crypts (Log -` spied y_))));\n     Agent n \\<notin> parts (used y_)\\<rbrakk>\n    \\<Longrightarrow> Agent n \\<notin> parts (used z_)", "apply ((erule disjE)?, (erule exE)+, simp add: parts_insert image_iff,\n (rule ccontr, (drule parts_dec | drule parts_enc | drule parts_sep |\n drule parts_con), simp+)?)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma idinfo_init_1 [rule_format]:\n  assumes A: \"s\\<^sub>0 \\<Turnstile> s\"\n  shows \"\\<lbrakk>s \\<turnstile> s'; n \\<notin> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey;\n    \\<forall>X. \\<langle>n, X\\<rangle> \\<notin> spied s\\<rbrakk> \\<Longrightarrow>\n  \\<langle>n, X\\<rangle> \\<notin> spied s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<turnstile> s';\n     n \\<notin> bad_id_password \\<union> bad_id_pubkey \\<union>\n                bad_id_shakey;\n     \\<forall>X. \\<langle>n, X\\<rangle> \\<notin> spied s\\<rbrakk>\n    \\<Longrightarrow> \\<langle>n, X\\<rangle> \\<notin> spied s'", "by (rule notI, simp add: rel_def, ((erule disjE)?, (erule exE)+, (blast | simp,\n ((drule idinfo_dec [OF A] | drule idinfo_sep [OF A]), simp, blast |\n (erule conjE)+, drule parts_agent [OF A], blast))?)+)"], ["", "proposition idinfo_init:\n \"\\<lbrakk>s\\<^sub>0 \\<Turnstile> s; n \\<notin> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\\<rbrakk> \\<Longrightarrow>\n  \\<langle>n, X\\<rangle> \\<notin> spied s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s\\<^sub>0 \\<Turnstile> s;\n     n \\<notin> bad_id_password \\<union> bad_id_pubkey \\<union>\n                bad_id_shakey\\<rbrakk>\n    \\<Longrightarrow> \\<langle>n, X\\<rangle> \\<notin> spied s", "by (induction arbitrary: X rule: rtrancl_induct, simp add: image_def, blast,\n rule idinfo_init_1)"], ["", "lemma idinfo_mpair_1 [rule_format]:\n \"\\<lbrakk>(s, s') \\<in> rel_id_hash \\<union> rel_id_crypt \\<union> rel_id_sep \\<union> rel_id_con;\n    \\<forall>X Y. \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle> \\<in> spied s \\<longrightarrow>\n      key_sets \\<lbrace>X, Y\\<rbrace> (crypts (Log -` spied s)) \\<noteq> {};\n    \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle> \\<in> spied s'\\<rbrakk> \\<Longrightarrow>\n  key_sets \\<lbrace>X, Y\\<rbrace> (crypts (Log -` spied s')) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, s')\n             \\<in> rel_id_hash \\<union> rel_id_crypt \\<union>\n                   rel_id_sep \\<union>\n                   rel_id_con;\n     \\<forall>X Y.\n        \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle>\n        \\<in> spied s \\<longrightarrow>\n        key_sets \\<lbrace>X, Y\\<rbrace> (crypts (Log -` spied s)) \\<noteq>\n        {};\n     \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle> \\<in> spied s'\\<rbrakk>\n    \\<Longrightarrow> key_sets \\<lbrace>X, Y\\<rbrace>\n                       (crypts (Log -` spied s')) \\<noteq>\n                      {}", "by ((erule disjE)?, clarify?, simp add: image_iff Image_def, (drule subsetD\n [OF key_sets_crypts_hash] | drule key_sets_range, blast | (drule spec)+,\n drule mp, simp, simp add: ex_in_conv [symmetric], erule exE, frule subsetD\n [OF key_sets_crypts_fst], drule subsetD [OF key_sets_crypts_snd])?)+"], ["", "lemma idinfo_mpair_2 [rule_format]:\n  assumes A: \"s\\<^sub>0 \\<Turnstile> s\"\n  shows \"\\<lbrakk>s \\<turnstile> s'; (s, s') \\<notin> rel_id_hash \\<union> rel_id_crypt \\<union> rel_id_sep \\<union> rel_id_con;\n    \\<forall>X Y. \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle> \\<in> spied s \\<longrightarrow>\n      key_sets \\<lbrace>X, Y\\<rbrace> (crypts (Log -` spied s)) \\<noteq> {};\n    \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle> \\<in> spied s'\\<rbrakk> \\<Longrightarrow>\n  key_sets \\<lbrace>X, Y\\<rbrace> (crypts (Log -` spied s')) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<turnstile> s';\n     (s, s')\n     \\<notin> rel_id_hash \\<union> rel_id_crypt \\<union> rel_id_sep \\<union>\n              rel_id_con;\n     \\<forall>X Y.\n        \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle>\n        \\<in> spied s \\<longrightarrow>\n        key_sets \\<lbrace>X, Y\\<rbrace> (crypts (Log -` spied s)) \\<noteq>\n        {};\n     \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle> \\<in> spied s'\\<rbrakk>\n    \\<Longrightarrow> key_sets \\<lbrace>X, Y\\<rbrace>\n                       (crypts (Log -` spied s')) \\<noteq>\n                      {}", "by (simp only: rel_def Un_iff de_Morgan_disj, simp, ((erule disjE)?, (erule exE)+,\n simp add: Image_def, (simp only: Collect_disj_eq crypts_union key_sets_union, simp)?,\n ((subst (asm) disj_assoc [symmetric])?, erule disjE, (drule idinfo_dec [OF A] |\n drule idinfo_sep [OF A]), simp+)?)+)"], ["", "proposition idinfo_mpair [rule_format]:\n \"s\\<^sub>0 \\<Turnstile> s \\<Longrightarrow>\n    \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle> \\<in> spied s \\<longrightarrow>\n  key_sets \\<lbrace>X, Y\\<rbrace> (crypts (Log -` spied s)) \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^sub>0 \\<Turnstile> s \\<Longrightarrow>\n    \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle>\n    \\<in> spied s \\<longrightarrow>\n    key_sets \\<lbrace>X, Y\\<rbrace> (crypts (Log -` spied s)) \\<noteq> {}", "proof (induction arbitrary: X Y rule: rtrancl_induct, simp add: image_def,\n rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z X Y.\n       \\<lbrakk>s\\<^sub>0 \\<Turnstile> y; y \\<turnstile> z;\n        \\<And>X Y.\n           \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle>\n           \\<in> spied y \\<longrightarrow>\n           key_sets \\<lbrace>X, Y\\<rbrace>\n            (crypts (Log -` spied y)) \\<noteq>\n           {};\n        \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle> \\<in> spied z\\<rbrakk>\n       \\<Longrightarrow> key_sets \\<lbrace>X, Y\\<rbrace>\n                          (crypts (Log -` spied z)) \\<noteq>\n                         {}", "fix s s' X Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z X Y.\n       \\<lbrakk>s\\<^sub>0 \\<Turnstile> y; y \\<turnstile> z;\n        \\<And>X Y.\n           \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle>\n           \\<in> spied y \\<longrightarrow>\n           key_sets \\<lbrace>X, Y\\<rbrace>\n            (crypts (Log -` spied y)) \\<noteq>\n           {};\n        \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle> \\<in> spied z\\<rbrakk>\n       \\<Longrightarrow> key_sets \\<lbrace>X, Y\\<rbrace>\n                          (crypts (Log -` spied z)) \\<noteq>\n                         {}", "assume\n   \"s\\<^sub>0 \\<Turnstile> s\" and\n   \"s \\<turnstile> s'\" and\n   \"\\<And>X Y. \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle> \\<in> spied s \\<longrightarrow>\n      key_sets \\<lbrace>X, Y\\<rbrace> (crypts (Log -` spied s)) \\<noteq> {}\" and\n   \"\\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle> \\<in> spied s'\""], ["proof (state)\nthis:\n  s\\<^sub>0 \\<Turnstile> s\n  s \\<turnstile> s'\n  \\<langle>n, \\<lbrace>?X, ?Y\\<rbrace>\\<rangle>\n  \\<in> spied s \\<longrightarrow>\n  key_sets \\<lbrace>?X, ?Y\\<rbrace> (crypts (Log -` spied s)) \\<noteq> {}\n  \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle> \\<in> spied s'\n\ngoal (1 subgoal):\n 1. \\<And>y z X Y.\n       \\<lbrakk>s\\<^sub>0 \\<Turnstile> y; y \\<turnstile> z;\n        \\<And>X Y.\n           \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle>\n           \\<in> spied y \\<longrightarrow>\n           key_sets \\<lbrace>X, Y\\<rbrace>\n            (crypts (Log -` spied y)) \\<noteq>\n           {};\n        \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle> \\<in> spied z\\<rbrakk>\n       \\<Longrightarrow> key_sets \\<lbrace>X, Y\\<rbrace>\n                          (crypts (Log -` spied z)) \\<noteq>\n                         {}", "thus \"key_sets \\<lbrace>X, Y\\<rbrace> (crypts (Log -` spied s')) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  s\\<^sub>0 \\<Turnstile> s\n  s \\<turnstile> s'\n  \\<langle>n, \\<lbrace>?X, ?Y\\<rbrace>\\<rangle>\n  \\<in> spied s \\<longrightarrow>\n  key_sets \\<lbrace>?X, ?Y\\<rbrace> (crypts (Log -` spied s)) \\<noteq> {}\n  \\<langle>n, \\<lbrace>X, Y\\<rbrace>\\<rangle> \\<in> spied s'\n\ngoal (1 subgoal):\n 1. key_sets \\<lbrace>X, Y\\<rbrace> (crypts (Log -` spied s')) \\<noteq> {}", "by (cases \"(s, s') \\<in> rel_id_hash \\<union> rel_id_crypt \\<union> rel_id_sep \\<union> rel_id_con\",\n     erule_tac [2] idinfo_mpair_2, erule_tac idinfo_mpair_1, simp_all)"], ["proof (state)\nthis:\n  key_sets \\<lbrace>X, Y\\<rbrace> (crypts (Log -` spied s')) \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition key_sets_pwd_empty:\n \"s\\<^sub>0 \\<Turnstile> s \\<Longrightarrow>\n    key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n    key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) = {} \\<and>\n    key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) = {}\"\n  (is \"_ \\<Longrightarrow> key_sets ?X (?H s) = _ \\<and> key_sets ?Y _ = _ \\<and> key_sets ?Z _ = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^sub>0 \\<Turnstile> s \\<Longrightarrow>\n    key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n    key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n    {} \\<and>\n    key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) = {}", "proof (erule rtrancl_induct, simp add: image_iff Image_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>s\\<^sub>0 \\<Turnstile> y; y \\<turnstile> z;\n        key_sets (Hash (Pwd n)) (crypts (Log -` spied y)) = {} \\<and>\n        key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied y)) =\n        {} \\<and>\n        key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied y)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> key_sets (Hash (Pwd n)) (crypts (Log -` spied z)) =\n                         {} \\<and>\n                         key_sets \\<lbrace>Pwd n, X\\<rbrace>\n                          (crypts (Log -` spied z)) =\n                         {} \\<and>\n                         key_sets \\<lbrace>X, Pwd n\\<rbrace>\n                          (crypts (Log -` spied z)) =\n                         {}", "fix s s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>s\\<^sub>0 \\<Turnstile> y; y \\<turnstile> z;\n        key_sets (Hash (Pwd n)) (crypts (Log -` spied y)) = {} \\<and>\n        key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied y)) =\n        {} \\<and>\n        key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied y)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> key_sets (Hash (Pwd n)) (crypts (Log -` spied z)) =\n                         {} \\<and>\n                         key_sets \\<lbrace>Pwd n, X\\<rbrace>\n                          (crypts (Log -` spied z)) =\n                         {} \\<and>\n                         key_sets \\<lbrace>X, Pwd n\\<rbrace>\n                          (crypts (Log -` spied z)) =\n                         {}", "assume\n    A: \"s\\<^sub>0 \\<Turnstile> s\" and\n    B: \"s \\<turnstile> s'\" and\n    C: \"key_sets (Hash (Pwd n)) (?H s) = {} \\<and>\n      key_sets \\<lbrace>Pwd n, X\\<rbrace> (?H s) = {} \\<and>\n      key_sets \\<lbrace>X, Pwd n\\<rbrace> (?H s) = {}\""], ["proof (state)\nthis:\n  s\\<^sub>0 \\<Turnstile> s\n  s \\<turnstile> s'\n  key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n  key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) = {} \\<and>\n  key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) = {}\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>s\\<^sub>0 \\<Turnstile> y; y \\<turnstile> z;\n        key_sets (Hash (Pwd n)) (crypts (Log -` spied y)) = {} \\<and>\n        key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied y)) =\n        {} \\<and>\n        key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied y)) =\n        {}\\<rbrakk>\n       \\<Longrightarrow> key_sets (Hash (Pwd n)) (crypts (Log -` spied z)) =\n                         {} \\<and>\n                         key_sets \\<lbrace>Pwd n, X\\<rbrace>\n                          (crypts (Log -` spied z)) =\n                         {} \\<and>\n                         key_sets \\<lbrace>X, Pwd n\\<rbrace>\n                          (crypts (Log -` spied z)) =\n                         {}", "show \"key_sets (Hash (Pwd n)) (?H s') = {} \\<and>\n    key_sets \\<lbrace>Pwd n, X\\<rbrace> (?H s') = {} \\<and>\n    key_sets \\<lbrace>X, Pwd n\\<rbrace> (?H s') = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. key_sets (Hash (Pwd n)) (crypts (Log -` spied s')) = {} \\<and>\n    key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s')) =\n    {} \\<and>\n    key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s')) = {}", "by (insert B C, simp add: rel_def, ((erule disjE)?, ((erule exE)+)?, simp add:\n     image_iff Image_def, (simp only: Collect_disj_eq crypts_union\n     key_sets_union, simp add: crypts_insert key_sets_insert)?,\n     (frule log_dec [OF A, where Y = \"?X\"],\n     frule log_dec [OF A, where Y = \"?Y\"], drule log_dec [OF A, where Y = \"?Z\"] |\n     frule log_sep [OF A, where Z = \"?X\"], frule log_sep [OF A, where Z = \"?Y\"],\n     drule log_sep [OF A, where Z = \"?Z\"])?)+)"], ["proof (state)\nthis:\n  key_sets (Hash (Pwd n)) (crypts (Log -` spied s')) = {} \\<and>\n  key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s')) = {} \\<and>\n  key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s')) = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition key_sets_pwd_seskey [rule_format]:\n \"s\\<^sub>0 \\<Turnstile> s \\<Longrightarrow>\n    U \\<in> key_sets (Pwd n) (crypts (Log -` spied s)) \\<longrightarrow>\n  (\\<exists>SK. U = {SesKey SK} \\<and>\n    ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n     (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s))\"\n  (is \"_ \\<Longrightarrow> _ \\<longrightarrow> ?P s\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^sub>0 \\<Turnstile> s \\<Longrightarrow>\n    U \\<in> key_sets (Pwd n) (crypts (Log -` spied s)) \\<longrightarrow>\n    (\\<exists>SK.\n        U = {SesKey SK} \\<and>\n        ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n         (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s))", "proof (erule rtrancl_induct, simp add: image_iff Image_def, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>s\\<^sub>0 \\<Turnstile> y; y \\<turnstile> z;\n        U \\<in> key_sets (Pwd n) (crypts (Log -` spied y)) \\<longrightarrow>\n        (\\<exists>SK.\n            U = {SesKey SK} \\<and>\n            ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> y \\<or>\n             (Asset n, Crypt (SesK SK) (Num 0)) \\<in> y));\n        U \\<in> key_sets (Pwd n) (crypts (Log -` spied z))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>SK.\n                            U = {SesKey SK} \\<and>\n                            ((Owner n, Crypt (SesK SK) (Pwd n))\n                             \\<in> z \\<or>\n                             (Asset n, Crypt (SesK SK) (Num 0)) \\<in> z)", "fix s s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>s\\<^sub>0 \\<Turnstile> y; y \\<turnstile> z;\n        U \\<in> key_sets (Pwd n) (crypts (Log -` spied y)) \\<longrightarrow>\n        (\\<exists>SK.\n            U = {SesKey SK} \\<and>\n            ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> y \\<or>\n             (Asset n, Crypt (SesK SK) (Num 0)) \\<in> y));\n        U \\<in> key_sets (Pwd n) (crypts (Log -` spied z))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>SK.\n                            U = {SesKey SK} \\<and>\n                            ((Owner n, Crypt (SesK SK) (Pwd n))\n                             \\<in> z \\<or>\n                             (Asset n, Crypt (SesK SK) (Num 0)) \\<in> z)", "assume\n    A: \"s\\<^sub>0 \\<Turnstile> s\" and\n    B: \"s \\<turnstile> s'\" and\n    C: \"U \\<in> key_sets (Pwd n) (crypts (Log -` spied s)) \\<longrightarrow> ?P s\" and\n    D: \"U \\<in> key_sets (Pwd n) (crypts (Log -` spied s'))\""], ["proof (state)\nthis:\n  s\\<^sub>0 \\<Turnstile> s\n  s \\<turnstile> s'\n  U \\<in> key_sets (Pwd n) (crypts (Log -` spied s)) \\<longrightarrow>\n  (\\<exists>SK.\n      U = {SesKey SK} \\<and>\n      ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n       (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s))\n  U \\<in> key_sets (Pwd n) (crypts (Log -` spied s'))\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>s\\<^sub>0 \\<Turnstile> y; y \\<turnstile> z;\n        U \\<in> key_sets (Pwd n) (crypts (Log -` spied y)) \\<longrightarrow>\n        (\\<exists>SK.\n            U = {SesKey SK} \\<and>\n            ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> y \\<or>\n             (Asset n, Crypt (SesK SK) (Num 0)) \\<in> y));\n        U \\<in> key_sets (Pwd n) (crypts (Log -` spied z))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>SK.\n                            U = {SesKey SK} \\<and>\n                            ((Owner n, Crypt (SesK SK) (Pwd n))\n                             \\<in> z \\<or>\n                             (Asset n, Crypt (SesK SK) (Num 0)) \\<in> z)", "show \"?P s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>SK.\n       U = {SesKey SK} \\<and>\n       ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s' \\<or>\n        (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s')", "by (insert B C D, simp add: rel_def, ((erule disjE)?, ((erule exE)+)?, simp\n     add: image_iff Image_def, (simp only: Collect_disj_eq crypts_union\n     key_sets_union, simp add: crypts_insert key_sets_insert split: if_split_asm,\n     blast?)?, (erule disjE, (drule log_dec [OF A] | drule log_sep [OF A]),\n     (erule conjE)?, drule subsetD, simp)?)+)"], ["proof (state)\nthis:\n  \\<exists>SK.\n     U = {SesKey SK} \\<and>\n     ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s' \\<or>\n      (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pwd_anonymous_1 [rule_format]:\n \"\\<lbrakk>s\\<^sub>0 \\<Turnstile> s; n \\<notin> bad_id_password\\<rbrakk> \\<Longrightarrow>\n    \\<langle>n, Pwd n\\<rangle> \\<in> spied s \\<longrightarrow>\n  (\\<exists>SK. SesKey SK \\<in> spied s \\<and>\n    ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n     (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s))\"\n  (is \"\\<lbrakk>_; _\\<rbrakk> \\<Longrightarrow> _ \\<longrightarrow> ?P s\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s\\<^sub>0 \\<Turnstile> s; n \\<notin> bad_id_password\\<rbrakk>\n    \\<Longrightarrow> \\<langle>n, Pwd n\\<rangle>\n                      \\<in> spied s \\<longrightarrow>\n                      (\\<exists>SK.\n                          SesKey SK \\<in> spied s \\<and>\n                          ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n                           (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s))", "proof (erule rtrancl_induct, simp add: image_def, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>n \\<notin> bad_id_password; s\\<^sub>0 \\<Turnstile> y;\n        y \\<turnstile> z;\n        \\<langle>n, Pwd n\\<rangle> \\<in> spied y \\<longrightarrow>\n        (\\<exists>SK.\n            SesKey SK \\<in> spied y \\<and>\n            ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> y \\<or>\n             (Asset n, Crypt (SesK SK) (Num 0)) \\<in> y));\n        \\<langle>n, Pwd n\\<rangle> \\<in> spied z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>SK.\n                            SesKey SK \\<in> spied z \\<and>\n                            ((Owner n, Crypt (SesK SK) (Pwd n))\n                             \\<in> z \\<or>\n                             (Asset n, Crypt (SesK SK) (Num 0)) \\<in> z)", "fix s s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>n \\<notin> bad_id_password; s\\<^sub>0 \\<Turnstile> y;\n        y \\<turnstile> z;\n        \\<langle>n, Pwd n\\<rangle> \\<in> spied y \\<longrightarrow>\n        (\\<exists>SK.\n            SesKey SK \\<in> spied y \\<and>\n            ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> y \\<or>\n             (Asset n, Crypt (SesK SK) (Num 0)) \\<in> y));\n        \\<langle>n, Pwd n\\<rangle> \\<in> spied z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>SK.\n                            SesKey SK \\<in> spied z \\<and>\n                            ((Owner n, Crypt (SesK SK) (Pwd n))\n                             \\<in> z \\<or>\n                             (Asset n, Crypt (SesK SK) (Num 0)) \\<in> z)", "assume\n    A: \"s\\<^sub>0 \\<Turnstile> s\" and\n    B: \"s \\<turnstile> s'\" and\n    C: \"\\<langle>n, Pwd n\\<rangle> \\<in> spied s \\<longrightarrow> ?P s\" and\n    D: \"\\<langle>n, Pwd n\\<rangle> \\<in> spied s'\""], ["proof (state)\nthis:\n  s\\<^sub>0 \\<Turnstile> s\n  s \\<turnstile> s'\n  \\<langle>n, Pwd n\\<rangle> \\<in> spied s \\<longrightarrow>\n  (\\<exists>SK.\n      SesKey SK \\<in> spied s \\<and>\n      ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n       (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s))\n  \\<langle>n, Pwd n\\<rangle> \\<in> spied s'\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>n \\<notin> bad_id_password; s\\<^sub>0 \\<Turnstile> y;\n        y \\<turnstile> z;\n        \\<langle>n, Pwd n\\<rangle> \\<in> spied y \\<longrightarrow>\n        (\\<exists>SK.\n            SesKey SK \\<in> spied y \\<and>\n            ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> y \\<or>\n             (Asset n, Crypt (SesK SK) (Num 0)) \\<in> y));\n        \\<langle>n, Pwd n\\<rangle> \\<in> spied z\\<rbrakk>\n       \\<Longrightarrow> \\<exists>SK.\n                            SesKey SK \\<in> spied z \\<and>\n                            ((Owner n, Crypt (SesK SK) (Pwd n))\n                             \\<in> z \\<or>\n                             (Asset n, Crypt (SesK SK) (Num 0)) \\<in> z)", "show \"?P s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>SK.\n       SesKey SK \\<in> spied s' \\<and>\n       ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s' \\<or>\n        (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s')", "by (insert B C D, simp add: rel_def, ((erule disjE)?, (erule exE)+, simp add:\n     image_iff, blast?, ((subst (asm) disj_assoc [symmetric])?, erule disjE,\n     (drule idinfo_dec [OF A] | drule idinfo_sep [OF A]), simp, blast+ |\n     insert key_sets_pwd_empty [OF A], clarsimp)?, (((erule disjE)?, erule\n     conjE, drule sym, simp, (drule key_sets_pwd_seskey [OF A] | drule\n     idinfo_mpair [OF A, simplified]), simp)+ | drule key_sets_range, blast)?)+)"], ["proof (state)\nthis:\n  \\<exists>SK.\n     SesKey SK \\<in> spied s' \\<and>\n     ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s' \\<or>\n      (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s')\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem pwd_anonymous:\n  assumes\n    A: \"s\\<^sub>0 \\<Turnstile> s\" and\n    B: \"n \\<notin> bad_id_password\" and\n    C: \"n \\<notin> bad_shakey \\<inter> (bad_pwd \\<union> bad_prikey) \\<inter> (bad_id_pubkey \\<union> bad_id_shak)\"\n  shows \"\\<langle>n, Pwd n\\<rangle> \\<notin> spied s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>n, Pwd n\\<rangle> \\<notin> spied s", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>n, Pwd n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "assume D: \"\\<langle>n, Pwd n\\<rangle> \\<in> spied s\""], ["proof (state)\nthis:\n  \\<langle>n, Pwd n\\<rangle> \\<in> spied s\n\ngoal (1 subgoal):\n 1. \\<langle>n, Pwd n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "hence \"n \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\""], ["proof (prove)\nusing this:\n  \\<langle>n, Pwd n\\<rangle> \\<in> spied s\n\ngoal (1 subgoal):\n 1. n \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey", "by (rule contrapos_pp, rule_tac idinfo_init [OF A])"], ["proof (state)\nthis:\n  n \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\n\ngoal (1 subgoal):\n 1. \\<langle>n, Pwd n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  n \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\n\ngoal (1 subgoal):\n 1. \\<langle>n, Pwd n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "have \"\\<exists>SK. SesKey SK \\<in> spied s \\<and>\n    ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n     (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s)\"\n    (is \"\\<exists>SK. ?P SK \\<and> (?Q SK \\<or> ?R SK)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>SK.\n       SesKey SK \\<in> spied s \\<and>\n       ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n        (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s)", "by (rule pwd_anonymous_1 [OF A B D])"], ["proof (state)\nthis:\n  \\<exists>SK.\n     SesKey SK \\<in> spied s \\<and>\n     ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n      (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s)\n\ngoal (1 subgoal):\n 1. \\<langle>n, Pwd n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>SK.\n     SesKey SK \\<in> spied s \\<and>\n     ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n      (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s)", "obtain SK where \"?P SK\" and \"?Q SK \\<or> ?R SK\""], ["proof (prove)\nusing this:\n  \\<exists>SK.\n     SesKey SK \\<in> spied s \\<and>\n     ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n      (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s)\n\ngoal (1 subgoal):\n 1. (\\<And>SK.\n        \\<lbrakk>SesKey SK \\<in> spied s;\n         (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n         (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  SesKey SK \\<in> spied s\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n  (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s\n\ngoal (1 subgoal):\n 1. \\<langle>n, Pwd n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  SesKey SK \\<in> spied s\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n  (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s\n\ngoal (1 subgoal):\n 1. \\<langle>n, Pwd n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  SesKey SK \\<in> spied s\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n  (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s\n\ngoal (1 subgoal):\n 1. \\<langle>n, Pwd n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "assume \"?Q SK\""], ["proof (state)\nthis:\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s\n\ngoal (1 subgoal):\n 1. \\<langle>n, Pwd n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "hence \"n \\<in> bad_shakey \\<inter> bad_prikey\""], ["proof (prove)\nusing this:\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s\n\ngoal (1 subgoal):\n 1. n \\<in> bad_shakey \\<inter> bad_prikey", "by (rule_tac contrapos_pp [OF \\<open>?P SK\\<close>], rule_tac owner_seskey_secret [OF A])"], ["proof (state)\nthis:\n  n \\<in> bad_shakey \\<inter> bad_prikey\n\ngoal (1 subgoal):\n 1. \\<langle>n, Pwd n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<Longrightarrow>\n  n \\<in> bad_shakey \\<inter> bad_prikey\n\ngoal (1 subgoal):\n 1. \\<langle>n, Pwd n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<Longrightarrow>\n  n \\<in> bad_shakey \\<inter> bad_prikey\n\ngoal (1 subgoal):\n 1. \\<langle>n, Pwd n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<Longrightarrow>\n  n \\<in> bad_shakey \\<inter> bad_prikey\n\ngoal (1 subgoal):\n 1. \\<langle>n, Pwd n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "assume \"?R SK\""], ["proof (state)\nthis:\n  (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s\n\ngoal (1 subgoal):\n 1. \\<langle>n, Pwd n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "hence \"n \\<in> bad_shakey \\<inter> (bad_pwd \\<union> bad_prikey)\""], ["proof (prove)\nusing this:\n  (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s\n\ngoal (1 subgoal):\n 1. n \\<in> bad_shakey \\<inter> (bad_pwd \\<union> bad_prikey)", "by (rule_tac contrapos_pp [OF \\<open>?P SK\\<close>], rule_tac asset_seskey_secret [OF A])"], ["proof (state)\nthis:\n  n \\<in> bad_shakey \\<inter> (bad_pwd \\<union> bad_prikey)\n\ngoal (1 subgoal):\n 1. \\<langle>n, Pwd n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s \\<Longrightarrow>\n  n \\<in> bad_shakey \\<inter> (bad_pwd \\<union> bad_prikey)\n\ngoal (1 subgoal):\n 1. \\<langle>n, Pwd n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  n \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\n  SesKey SK \\<in> spied s\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n  (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<Longrightarrow>\n  n \\<in> bad_shakey \\<inter> bad_prikey\n  (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s \\<Longrightarrow>\n  n \\<in> bad_shakey \\<inter> (bad_pwd \\<union> bad_prikey)", "show False"], ["proof (prove)\nusing this:\n  n \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\n  SesKey SK \\<in> spied s\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n  (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<Longrightarrow>\n  n \\<in> bad_shakey \\<inter> bad_prikey\n  (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s \\<Longrightarrow>\n  n \\<in> bad_shakey \\<inter> (bad_pwd \\<union> bad_prikey)\n\ngoal (1 subgoal):\n 1. False", "using B and C"], ["proof (prove)\nusing this:\n  n \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\n  SesKey SK \\<in> spied s\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n  (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<Longrightarrow>\n  n \\<in> bad_shakey \\<inter> bad_prikey\n  (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s \\<Longrightarrow>\n  n \\<in> bad_shakey \\<inter> (bad_pwd \\<union> bad_prikey)\n  n \\<notin> bad_id_password\n  n \\<notin> bad_shakey \\<inter> (bad_pwd \\<union> bad_prikey) \\<inter>\n             (bad_id_pubkey \\<union> bad_id_shak)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition idinfo_pwd_start:\n  assumes\n    A: \"s\\<^sub>0 \\<Turnstile> s\" and\n    B: \"n \\<notin> bad_agent\"\n  shows \"\\<lbrakk>s \\<turnstile> s'; \\<exists>X. \\<langle>n, X\\<rangle> \\<in> spied s' \\<and> X \\<noteq> Pwd n;\n    \\<not> (\\<exists>X. \\<langle>n, X\\<rangle> \\<in> spied s \\<and> X \\<noteq> Pwd n)\\<rbrakk> \\<Longrightarrow>\n      \\<exists>SK. SesKey SK \\<in> spied s \\<and>\n        ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n         (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s \\<turnstile> s';\n     \\<exists>X.\n        \\<langle>n, X\\<rangle> \\<in> spied s' \\<and> X \\<noteq> Pwd n;\n     \\<nexists>X.\n        \\<langle>n, X\\<rangle> \\<in> spied s \\<and>\n        X \\<noteq> Pwd n\\<rbrakk>\n    \\<Longrightarrow> \\<exists>SK.\n                         SesKey SK \\<in> spied s \\<and>\n                         ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n                          (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s)", "proof (simp add: rel_def, insert parts_agent [OF A B], insert key_sets_pwd_empty\n [OF A], (erule disjE, (erule exE)+, simp, erule conjE, (subst (asm) disj_assoc\n [symmetric])?, (erule disjE)?, (drule idinfo_dec [OF A] | drule idinfo_sep\n [OF A] | drule spec, drule mp), simp+)+, auto, rule FalseE, rule_tac [3] FalseE)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>Xa U K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        Xa \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Xa U x.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> Xa;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U;\n        (Spy, \\<langle>n, Xa\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            (Spy, Key (SesK (a, aa, b))) \\<in> s \\<and>\n                            ((Owner n, Crypt (SesK (a, aa, b)) Xa)\n                             \\<in> s \\<or>\n                             (Asset n, Crypt (SesK (a, aa, b)) (Num 0))\n                             \\<in> s)\n 3. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "fix X U K"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>Xa U K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        Xa \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Xa U x.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> Xa;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U;\n        (Spy, \\<langle>n, Xa\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            (Spy, Key (SesK (a, aa, b))) \\<in> s \\<and>\n                            ((Owner n, Crypt (SesK (a, aa, b)) Xa)\n                             \\<in> s \\<or>\n                             (Asset n, Crypt (SesK (a, aa, b)) (Num 0))\n                             \\<in> s)\n 3. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"\\<forall>X. (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow> X = Pwd n\" and \"(Spy, \\<langle>n, K\\<rangle>) \\<in> s\""], ["proof (state)\nthis:\n  \\<forall>X.\n     (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow> X = Pwd n\n  (Spy, \\<langle>n, K\\<rangle>) \\<in> s\n\ngoal (3 subgoals):\n 1. \\<And>Xa U K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        Xa \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Xa U x.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> Xa;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U;\n        (Spy, \\<langle>n, Xa\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            (Spy, Key (SesK (a, aa, b))) \\<in> s \\<and>\n                            ((Owner n, Crypt (SesK (a, aa, b)) Xa)\n                             \\<in> s \\<or>\n                             (Asset n, Crypt (SesK (a, aa, b)) (Num 0))\n                             \\<in> s)\n 3. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"K = Pwd n\""], ["proof (prove)\nusing this:\n  \\<forall>X.\n     (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow> X = Pwd n\n  (Spy, \\<langle>n, K\\<rangle>) \\<in> s\n\ngoal (1 subgoal):\n 1. K = Pwd n", "by simp"], ["proof (state)\nthis:\n  K = Pwd n\n\ngoal (3 subgoals):\n 1. \\<And>Xa U K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        Xa \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Xa U x.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> Xa;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U;\n        (Spy, \\<langle>n, Xa\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            (Spy, Key (SesK (a, aa, b))) \\<in> s \\<and>\n                            ((Owner n, Crypt (SesK (a, aa, b)) Xa)\n                             \\<in> s \\<or>\n                             (Asset n, Crypt (SesK (a, aa, b)) (Num 0))\n                             \\<in> s)\n 3. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  K = Pwd n\n\ngoal (3 subgoals):\n 1. \\<And>Xa U K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        Xa \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Xa U x.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> Xa;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U;\n        (Spy, \\<langle>n, Xa\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            (Spy, Key (SesK (a, aa, b))) \\<in> s \\<and>\n                            ((Owner n, Crypt (SesK (a, aa, b)) Xa)\n                             \\<in> s \\<or>\n                             (Asset n, Crypt (SesK (a, aa, b)) (Num 0))\n                             \\<in> s)\n 3. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"U \\<in> key_sets X (crypts (Log -` spied s))\""], ["proof (state)\nthis:\n  U \\<in> key_sets X (crypts (Log -` spied s))\n\ngoal (3 subgoals):\n 1. \\<And>Xa U K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        Xa \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Xa U x.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> Xa;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U;\n        (Spy, \\<langle>n, Xa\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            (Spy, Key (SesK (a, aa, b))) \\<in> s \\<and>\n                            ((Owner n, Crypt (SesK (a, aa, b)) Xa)\n                             \\<in> s \\<or>\n                             (Asset n, Crypt (SesK (a, aa, b)) (Num 0))\n                             \\<in> s)\n 3. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"U \\<subseteq> range Key\""], ["proof (prove)\nusing this:\n  U \\<in> key_sets X (crypts (Log -` spied s))\n\ngoal (1 subgoal):\n 1. U \\<subseteq> range Key", "by (rule key_sets_range)"], ["proof (state)\nthis:\n  U \\<subseteq> range Key\n\ngoal (3 subgoals):\n 1. \\<And>Xa U K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        Xa \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Xa U x.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> Xa;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U;\n        (Spy, \\<langle>n, Xa\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            (Spy, Key (SesK (a, aa, b))) \\<in> s \\<and>\n                            ((Owner n, Crypt (SesK (a, aa, b)) Xa)\n                             \\<in> s \\<or>\n                             (Asset n, Crypt (SesK (a, aa, b)) (Num 0))\n                             \\<in> s)\n 3. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  U \\<subseteq> range Key\n\ngoal (3 subgoals):\n 1. \\<And>Xa U K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        Xa \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Xa U x.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> Xa;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U;\n        (Spy, \\<langle>n, Xa\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            (Spy, Key (SesK (a, aa, b))) \\<in> s \\<and>\n                            ((Owner n, Crypt (SesK (a, aa, b)) Xa)\n                             \\<in> s \\<or>\n                             (Asset n, Crypt (SesK (a, aa, b)) (Num 0))\n                             \\<in> s)\n 3. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"K \\<in> U\""], ["proof (state)\nthis:\n  K \\<in> U\n\ngoal (3 subgoals):\n 1. \\<And>Xa U K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        Xa \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>Xa U x.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> Xa;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U;\n        (Spy, \\<langle>n, Xa\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            (Spy, Key (SesK (a, aa, b))) \\<in> s \\<and>\n                            ((Owner n, Crypt (SesK (a, aa, b)) Xa)\n                             \\<in> s \\<or>\n                             (Asset n, Crypt (SesK (a, aa, b)) (Num 0))\n                             \\<in> s)\n 3. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  K = Pwd n\n  U \\<subseteq> range Key\n  K \\<in> U", "show False"], ["proof (prove)\nusing this:\n  K = Pwd n\n  U \\<subseteq> range Key\n  K \\<in> U\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>Xa U x.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> Xa;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U;\n        (Spy, \\<langle>n, Xa\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            (Spy, Key (SesK (a, aa, b))) \\<in> s \\<and>\n                            ((Owner n, Crypt (SesK (a, aa, b)) Xa)\n                             \\<in> s \\<or>\n                             (Asset n, Crypt (SesK (a, aa, b)) (Num 0))\n                             \\<in> s)\n 2. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Xa U x.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> Xa;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U;\n        (Spy, \\<langle>n, Xa\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            (Spy, Key (SesK (a, aa, b))) \\<in> s \\<and>\n                            ((Owner n, Crypt (SesK (a, aa, b)) Xa)\n                             \\<in> s \\<or>\n                             (Asset n, Crypt (SesK (a, aa, b)) (Num 0))\n                             \\<in> s)\n 2. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "fix X U"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Xa U x.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> Xa;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U;\n        (Spy, \\<langle>n, Xa\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            (Spy, Key (SesK (a, aa, b))) \\<in> s \\<and>\n                            ((Owner n, Crypt (SesK (a, aa, b)) Xa)\n                             \\<in> s \\<or>\n                             (Asset n, Crypt (SesK (a, aa, b)) (Num 0))\n                             \\<in> s)\n 2. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"\\<forall>X. (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow> X = Pwd n\" and \"(Spy, \\<langle>n, X\\<rangle>) \\<in> s\""], ["proof (state)\nthis:\n  \\<forall>X.\n     (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow> X = Pwd n\n  (Spy, \\<langle>n, X\\<rangle>) \\<in> s\n\ngoal (2 subgoals):\n 1. \\<And>Xa U x.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> Xa;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U;\n        (Spy, \\<langle>n, Xa\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            (Spy, Key (SesK (a, aa, b))) \\<in> s \\<and>\n                            ((Owner n, Crypt (SesK (a, aa, b)) Xa)\n                             \\<in> s \\<or>\n                             (Asset n, Crypt (SesK (a, aa, b)) (Num 0))\n                             \\<in> s)\n 2. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "hence C: \"X = Pwd n\""], ["proof (prove)\nusing this:\n  \\<forall>X.\n     (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow> X = Pwd n\n  (Spy, \\<langle>n, X\\<rangle>) \\<in> s\n\ngoal (1 subgoal):\n 1. X = Pwd n", "by simp"], ["proof (state)\nthis:\n  X = Pwd n\n\ngoal (2 subgoals):\n 1. \\<And>Xa U x.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> Xa;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U;\n        (Spy, \\<langle>n, Xa\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            (Spy, Key (SesK (a, aa, b))) \\<in> s \\<and>\n                            ((Owner n, Crypt (SesK (a, aa, b)) Xa)\n                             \\<in> s \\<or>\n                             (Asset n, Crypt (SesK (a, aa, b)) (Num 0))\n                             \\<in> s)\n 2. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  X = Pwd n\n\ngoal (2 subgoals):\n 1. \\<And>Xa U x.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> Xa;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U;\n        (Spy, \\<langle>n, Xa\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            (Spy, Key (SesK (a, aa, b))) \\<in> s \\<and>\n                            ((Owner n, Crypt (SesK (a, aa, b)) Xa)\n                             \\<in> s \\<or>\n                             (Asset n, Crypt (SesK (a, aa, b)) (Num 0))\n                             \\<in> s)\n 2. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"U \\<in> key_sets X (crypts (Log -` spied s))\""], ["proof (state)\nthis:\n  U \\<in> key_sets X (crypts (Log -` spied s))\n\ngoal (2 subgoals):\n 1. \\<And>Xa U x.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> Xa;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U;\n        (Spy, \\<langle>n, Xa\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            (Spy, Key (SesK (a, aa, b))) \\<in> s \\<and>\n                            ((Owner n, Crypt (SesK (a, aa, b)) Xa)\n                             \\<in> s \\<or>\n                             (Asset n, Crypt (SesK (a, aa, b)) (Num 0))\n                             \\<in> s)\n 2. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  X = Pwd n\n  U \\<in> key_sets X (crypts (Log -` spied s))", "have \"U \\<in> key_sets (Pwd n) (crypts (Log -` spied s))\""], ["proof (prove)\nusing this:\n  X = Pwd n\n  U \\<in> key_sets X (crypts (Log -` spied s))\n\ngoal (1 subgoal):\n 1. U \\<in> key_sets (Pwd n) (crypts (Log -` spied s))", "by simp"], ["proof (state)\nthis:\n  U \\<in> key_sets (Pwd n) (crypts (Log -` spied s))\n\ngoal (2 subgoals):\n 1. \\<And>Xa U x.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> Xa;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U;\n        (Spy, \\<langle>n, Xa\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            (Spy, Key (SesK (a, aa, b))) \\<in> s \\<and>\n                            ((Owner n, Crypt (SesK (a, aa, b)) Xa)\n                             \\<in> s \\<or>\n                             (Asset n, Crypt (SesK (a, aa, b)) (Num 0))\n                             \\<in> s)\n 2. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"\\<exists>SK. U = {SesKey SK} \\<and>\n    ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n     (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s)\""], ["proof (prove)\nusing this:\n  U \\<in> key_sets (Pwd n) (crypts (Log -` spied s))\n\ngoal (1 subgoal):\n 1. \\<exists>SK.\n       U = {SesKey SK} \\<and>\n       ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n        (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s)", "by (rule key_sets_pwd_seskey [OF A])"], ["proof (state)\nthis:\n  \\<exists>SK.\n     U = {SesKey SK} \\<and>\n     ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n      (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s)\n\ngoal (2 subgoals):\n 1. \\<And>Xa U x.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> Xa;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U;\n        (Spy, \\<langle>n, Xa\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            (Spy, Key (SesK (a, aa, b))) \\<in> s \\<and>\n                            ((Owner n, Crypt (SesK (a, aa, b)) Xa)\n                             \\<in> s \\<or>\n                             (Asset n, Crypt (SesK (a, aa, b)) (Num 0))\n                             \\<in> s)\n 2. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<exists>SK.\n     U = {SesKey SK} \\<and>\n     ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n      (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s)\n\ngoal (2 subgoals):\n 1. \\<And>Xa U x.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> Xa;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U;\n        (Spy, \\<langle>n, Xa\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            (Spy, Key (SesK (a, aa, b))) \\<in> s \\<and>\n                            ((Owner n, Crypt (SesK (a, aa, b)) Xa)\n                             \\<in> s \\<or>\n                             (Asset n, Crypt (SesK (a, aa, b)) (Num 0))\n                             \\<in> s)\n 2. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"U \\<subseteq> spied s\""], ["proof (state)\nthis:\n  U \\<subseteq> spied s\n\ngoal (2 subgoals):\n 1. \\<And>Xa U x.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> Xa;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U;\n        (Spy, \\<langle>n, Xa\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a aa b.\n                            (Spy, Key (SesK (a, aa, b))) \\<in> s \\<and>\n                            ((Owner n, Crypt (SesK (a, aa, b)) Xa)\n                             \\<in> s \\<or>\n                             (Asset n, Crypt (SesK (a, aa, b)) (Num 0))\n                             \\<in> s)\n 2. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>SK.\n     U = {SesKey SK} \\<and>\n     ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n      (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s)\n  U \\<subseteq> spied s", "show \"\\<exists>x U V. (Spy, Key (SesK (x, U, V))) \\<in> s \\<and>\n    ((Owner n, Crypt (SesK (x, U, V)) X) \\<in> s \\<or>\n     (Asset n, Crypt (SesK (x, U, V)) (Num 0)) \\<in> s)\""], ["proof (prove)\nusing this:\n  \\<exists>SK.\n     U = {SesKey SK} \\<and>\n     ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n      (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s)\n  U \\<subseteq> spied s\n\ngoal (1 subgoal):\n 1. \\<exists>x U V.\n       (Spy, Key (SesK (x, U, V))) \\<in> s \\<and>\n       ((Owner n, Crypt (SesK (x, U, V)) X) \\<in> s \\<or>\n        (Asset n, Crypt (SesK (x, U, V)) (Num 0)) \\<in> s)", "using C"], ["proof (prove)\nusing this:\n  \\<exists>SK.\n     U = {SesKey SK} \\<and>\n     ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n      (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s)\n  U \\<subseteq> spied s\n  X = Pwd n\n\ngoal (1 subgoal):\n 1. \\<exists>x U V.\n       (Spy, Key (SesK (x, U, V))) \\<in> s \\<and>\n       ((Owner n, Crypt (SesK (x, U, V)) X) \\<in> s \\<or>\n        (Asset n, Crypt (SesK (x, U, V)) (Num 0)) \\<in> s)", "by auto"], ["proof (state)\nthis:\n  \\<exists>x U V.\n     (Spy, Key (SesK (x, U, V))) \\<in> s \\<and>\n     ((Owner n, Crypt (SesK (x, U, V)) X) \\<in> s \\<or>\n      (Asset n, Crypt (SesK (x, U, V)) (Num 0)) \\<in> s)\n\ngoal (1 subgoal):\n 1. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "fix X U K"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"\\<forall>X. (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow> X = Pwd n\" and \"(Spy, \\<langle>n, K\\<rangle>) \\<in> s\""], ["proof (state)\nthis:\n  \\<forall>X.\n     (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow> X = Pwd n\n  (Spy, \\<langle>n, K\\<rangle>) \\<in> s\n\ngoal (1 subgoal):\n 1. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"K = Pwd n\""], ["proof (prove)\nusing this:\n  \\<forall>X.\n     (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow> X = Pwd n\n  (Spy, \\<langle>n, K\\<rangle>) \\<in> s\n\ngoal (1 subgoal):\n 1. K = Pwd n", "by simp"], ["proof (state)\nthis:\n  K = Pwd n\n\ngoal (1 subgoal):\n 1. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  K = Pwd n\n\ngoal (1 subgoal):\n 1. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"U \\<in> key_sets X (crypts (Log -` spied s))\""], ["proof (state)\nthis:\n  U \\<in> key_sets X (crypts (Log -` spied s))\n\ngoal (1 subgoal):\n 1. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"U \\<subseteq> range Key\""], ["proof (prove)\nusing this:\n  U \\<in> key_sets X (crypts (Log -` spied s))\n\ngoal (1 subgoal):\n 1. U \\<subseteq> range Key", "by (rule key_sets_range)"], ["proof (state)\nthis:\n  U \\<subseteq> range Key\n\ngoal (1 subgoal):\n 1. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  U \\<subseteq> range Key\n\ngoal (1 subgoal):\n 1. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"K \\<in> U\""], ["proof (state)\nthis:\n  K \\<in> U\n\ngoal (1 subgoal):\n 1. \\<And>Xa U x K.\n       \\<lbrakk>\\<forall>X.\n                   (Spy, \\<langle>n, X\\<rangle>) \\<in> s \\<longrightarrow>\n                   X = Pwd n;\n        Agent n \\<notin> parts (used s);\n        \\<And>n X.\n           key_sets (Hash (Pwd n)) (crypts (Log -` spied s)) = {} \\<and>\n           key_sets \\<lbrace>Pwd n, X\\<rbrace> (crypts (Log -` spied s)) =\n           {} \\<and>\n           key_sets \\<lbrace>X, Pwd n\\<rbrace> (crypts (Log -` spied s)) =\n           {};\n        x \\<noteq> K;\n        s' =\n        insert (Spy, \\<langle>n, Xa\\<rangle>)\n         (s \\<union> {Spy} \\<times> IDInfo n ` U);\n        (Spy, Xa) \\<in> s; U \\<subseteq> spied s;\n        U \\<in> key_sets Xa (crypts (Log -` spied s)); x \\<in> U; K \\<in> U;\n        (Spy, \\<langle>n, K\\<rangle>) \\<in> s\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  K = Pwd n\n  U \\<subseteq> range Key\n  K \\<in> U", "show False"], ["proof (prove)\nusing this:\n  K = Pwd n\n  U \\<subseteq> range Key\n  K \\<in> U\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition idinfo_pwd:\n \"\\<lbrakk>s\\<^sub>0 \\<Turnstile> s; \\<exists>X. \\<langle>n, X\\<rangle> \\<in> spied s \\<and> X \\<noteq> Pwd n;\n    n \\<notin> bad_id_pubkey \\<union> bad_id_shakey\\<rbrakk> \\<Longrightarrow>\n  \\<exists>SK. SesKey SK \\<in> spied s \\<and>\n    ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n     (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s\\<^sub>0 \\<Turnstile> s;\n     \\<exists>X.\n        \\<langle>n, X\\<rangle> \\<in> spied s \\<and> X \\<noteq> Pwd n;\n     n \\<notin> bad_id_pubkey \\<union> bad_id_shakey\\<rbrakk>\n    \\<Longrightarrow> \\<exists>SK.\n                         SesKey SK \\<in> spied s \\<and>\n                         ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n                          (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s)", "by (drule rtrancl_start, assumption, simp, blast, (erule exE)+, (erule conjE)+,\n frule idinfo_pwd_start [of _ n], simp+, drule r_into_rtrancl, drule rtrancl_trans,\n assumption, (drule state_subset)+, blast)"], ["", "theorem auth_prikey_anonymous:\n  assumes\n    A: \"s\\<^sub>0 \\<Turnstile> s\" and\n    B: \"n \\<notin> bad_id_prikey\" and\n    C: \"n \\<notin> bad_shakey \\<inter> bad_prikey \\<inter> (bad_id_password \\<union> bad_id_shak)\"\n  shows \"\\<langle>n, Auth_PriKey n\\<rangle> \\<notin> spied s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>n, Auth_PriKey n\\<rangle> \\<notin> spied s", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>n, Auth_PriKey n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "assume D: \"\\<langle>n, Auth_PriKey n\\<rangle> \\<in> spied s\""], ["proof (state)\nthis:\n  \\<langle>n, Auth_PriKey n\\<rangle> \\<in> spied s\n\ngoal (1 subgoal):\n 1. \\<langle>n, Auth_PriKey n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "hence \"n \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\""], ["proof (prove)\nusing this:\n  \\<langle>n, Auth_PriKey n\\<rangle> \\<in> spied s\n\ngoal (1 subgoal):\n 1. n \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey", "by (rule contrapos_pp, rule_tac idinfo_init [OF A])"], ["proof (state)\nthis:\n  n \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\n\ngoal (1 subgoal):\n 1. \\<langle>n, Auth_PriKey n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  n \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\n\ngoal (1 subgoal):\n 1. \\<langle>n, Auth_PriKey n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "have \"Auth_PriKey n \\<in> spied s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Auth_PriKey n \\<in> spied s", "by (rule idinfo_msg [OF A D])"], ["proof (state)\nthis:\n  Auth_PriKey n \\<in> spied s\n\ngoal (1 subgoal):\n 1. \\<langle>n, Auth_PriKey n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "hence \"n \\<in> bad_prikey\""], ["proof (prove)\nusing this:\n  Auth_PriKey n \\<in> spied s\n\ngoal (1 subgoal):\n 1. n \\<in> bad_prikey", "by (rule contrapos_pp, rule_tac auth_prikey_secret [OF A])"], ["proof (state)\nthis:\n  n \\<in> bad_prikey\n\ngoal (1 subgoal):\n 1. \\<langle>n, Auth_PriKey n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  n \\<in> bad_prikey\n\ngoal (1 subgoal):\n 1. \\<langle>n, Auth_PriKey n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  n \\<in> bad_prikey", "have E: \"n \\<notin> bad_id_pubkey\""], ["proof (prove)\nusing this:\n  n \\<in> bad_prikey\n\ngoal (1 subgoal):\n 1. n \\<notin> bad_id_pubkey", "using B"], ["proof (prove)\nusing this:\n  n \\<in> bad_prikey\n  n \\<notin> bad_id_prikey\n\ngoal (1 subgoal):\n 1. n \\<notin> bad_id_pubkey", "by simp"], ["proof (state)\nthis:\n  n \\<notin> bad_id_pubkey\n\ngoal (1 subgoal):\n 1. \\<langle>n, Auth_PriKey n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  n \\<notin> bad_id_pubkey\n\ngoal (1 subgoal):\n 1. \\<langle>n, Auth_PriKey n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "have \"n \\<in> bad_shakey\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<in> bad_shakey", "proof (cases \"n \\<in> bad_id_shakey\", simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<notin> bad_id_shakey \\<Longrightarrow> n \\<in> bad_shakey", "case False"], ["proof (state)\nthis:\n  n \\<notin> bad_id_shakey\n\ngoal (1 subgoal):\n 1. n \\<notin> bad_id_shakey \\<Longrightarrow> n \\<in> bad_shakey", "with D and E"], ["proof (chain)\npicking this:\n  \\<langle>n, Auth_PriKey n\\<rangle> \\<in> spied s\n  n \\<notin> bad_id_pubkey\n  n \\<notin> bad_id_shakey", "have \"\\<exists>SK. SesKey SK \\<in> spied s \\<and>\n      ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n       (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s)\"\n      (is \"\\<exists>SK. ?P SK \\<and> (?Q SK \\<or> ?R SK)\")"], ["proof (prove)\nusing this:\n  \\<langle>n, Auth_PriKey n\\<rangle> \\<in> spied s\n  n \\<notin> bad_id_pubkey\n  n \\<notin> bad_id_shakey\n\ngoal (1 subgoal):\n 1. \\<exists>SK.\n       SesKey SK \\<in> spied s \\<and>\n       ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n        (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s)", "by (rule_tac idinfo_pwd [OF A], rule_tac exI [of _ \"Auth_PriKey n\"], simp_all)"], ["proof (state)\nthis:\n  \\<exists>SK.\n     SesKey SK \\<in> spied s \\<and>\n     ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n      (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s)\n\ngoal (1 subgoal):\n 1. n \\<notin> bad_id_shakey \\<Longrightarrow> n \\<in> bad_shakey", "then"], ["proof (chain)\npicking this:\n  \\<exists>SK.\n     SesKey SK \\<in> spied s \\<and>\n     ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n      (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s)", "obtain SK where \"?P SK\" and \"?Q SK \\<or> ?R SK\""], ["proof (prove)\nusing this:\n  \\<exists>SK.\n     SesKey SK \\<in> spied s \\<and>\n     ((Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n      (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s)\n\ngoal (1 subgoal):\n 1. (\\<And>SK.\n        \\<lbrakk>SesKey SK \\<in> spied s;\n         (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n         (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  SesKey SK \\<in> spied s\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n  (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s\n\ngoal (1 subgoal):\n 1. n \\<notin> bad_id_shakey \\<Longrightarrow> n \\<in> bad_shakey", "moreover"], ["proof (state)\nthis:\n  SesKey SK \\<in> spied s\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n  (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s\n\ngoal (1 subgoal):\n 1. n \\<notin> bad_id_shakey \\<Longrightarrow> n \\<in> bad_shakey", "{"], ["proof (state)\nthis:\n  SesKey SK \\<in> spied s\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n  (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s\n\ngoal (1 subgoal):\n 1. n \\<notin> bad_id_shakey \\<Longrightarrow> n \\<in> bad_shakey", "assume \"?Q SK\""], ["proof (state)\nthis:\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s\n\ngoal (1 subgoal):\n 1. n \\<notin> bad_id_shakey \\<Longrightarrow> n \\<in> bad_shakey", "hence \"n \\<in> bad_shakey \\<inter> bad_prikey\""], ["proof (prove)\nusing this:\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s\n\ngoal (1 subgoal):\n 1. n \\<in> bad_shakey \\<inter> bad_prikey", "by (rule_tac contrapos_pp [OF \\<open>?P SK\\<close>], rule_tac owner_seskey_secret\n         [OF A])"], ["proof (state)\nthis:\n  n \\<in> bad_shakey \\<inter> bad_prikey\n\ngoal (1 subgoal):\n 1. n \\<notin> bad_id_shakey \\<Longrightarrow> n \\<in> bad_shakey", "}"], ["proof (state)\nthis:\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<Longrightarrow>\n  n \\<in> bad_shakey \\<inter> bad_prikey\n\ngoal (1 subgoal):\n 1. n \\<notin> bad_id_shakey \\<Longrightarrow> n \\<in> bad_shakey", "moreover"], ["proof (state)\nthis:\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<Longrightarrow>\n  n \\<in> bad_shakey \\<inter> bad_prikey\n\ngoal (1 subgoal):\n 1. n \\<notin> bad_id_shakey \\<Longrightarrow> n \\<in> bad_shakey", "{"], ["proof (state)\nthis:\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<Longrightarrow>\n  n \\<in> bad_shakey \\<inter> bad_prikey\n\ngoal (1 subgoal):\n 1. n \\<notin> bad_id_shakey \\<Longrightarrow> n \\<in> bad_shakey", "assume \"?R SK\""], ["proof (state)\nthis:\n  (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s\n\ngoal (1 subgoal):\n 1. n \\<notin> bad_id_shakey \\<Longrightarrow> n \\<in> bad_shakey", "hence \"n \\<in> bad_shakey \\<inter> (bad_pwd \\<union> bad_prikey)\""], ["proof (prove)\nusing this:\n  (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s\n\ngoal (1 subgoal):\n 1. n \\<in> bad_shakey \\<inter> (bad_pwd \\<union> bad_prikey)", "by (rule_tac contrapos_pp [OF \\<open>?P SK\\<close>], rule_tac asset_seskey_secret\n         [OF A])"], ["proof (state)\nthis:\n  n \\<in> bad_shakey \\<inter> (bad_pwd \\<union> bad_prikey)\n\ngoal (1 subgoal):\n 1. n \\<notin> bad_id_shakey \\<Longrightarrow> n \\<in> bad_shakey", "}"], ["proof (state)\nthis:\n  (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s \\<Longrightarrow>\n  n \\<in> bad_shakey \\<inter> (bad_pwd \\<union> bad_prikey)\n\ngoal (1 subgoal):\n 1. n \\<notin> bad_id_shakey \\<Longrightarrow> n \\<in> bad_shakey", "ultimately"], ["proof (chain)\npicking this:\n  SesKey SK \\<in> spied s\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n  (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<Longrightarrow>\n  n \\<in> bad_shakey \\<inter> bad_prikey\n  (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s \\<Longrightarrow>\n  n \\<in> bad_shakey \\<inter> (bad_pwd \\<union> bad_prikey)", "show ?thesis"], ["proof (prove)\nusing this:\n  SesKey SK \\<in> spied s\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<or>\n  (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s\n  (Owner n, Crypt (SesK SK) (Pwd n)) \\<in> s \\<Longrightarrow>\n  n \\<in> bad_shakey \\<inter> bad_prikey\n  (Asset n, Crypt (SesK SK) (Num 0)) \\<in> s \\<Longrightarrow>\n  n \\<in> bad_shakey \\<inter> (bad_pwd \\<union> bad_prikey)\n\ngoal (1 subgoal):\n 1. n \\<in> bad_shakey", "by blast"], ["proof (state)\nthis:\n  n \\<in> bad_shakey\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<in> bad_shakey\n\ngoal (1 subgoal):\n 1. \\<langle>n, Auth_PriKey n\\<rangle> \\<in> spied s \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  n \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\n  n \\<in> bad_prikey\n  n \\<notin> bad_id_pubkey\n  n \\<in> bad_shakey", "show False"], ["proof (prove)\nusing this:\n  n \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\n  n \\<in> bad_prikey\n  n \\<notin> bad_id_pubkey\n  n \\<in> bad_shakey\n\ngoal (1 subgoal):\n 1. False", "using C"], ["proof (prove)\nusing this:\n  n \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\n  n \\<in> bad_prikey\n  n \\<notin> bad_id_pubkey\n  n \\<in> bad_shakey\n  n \\<notin> bad_shakey \\<inter> bad_prikey \\<inter>\n             (bad_id_password \\<union> bad_id_shak)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem auth_shakey_anonymous:\n  assumes\n    A: \"s\\<^sub>0 \\<Turnstile> s\" and\n    B: \"n \\<notin> bad_id_shakey\" and\n    C: \"n \\<notin> bad_shakey \\<inter> (bad_id_password \\<union> bad_id_pubkey)\"\n  shows \"\\<langle>n, Key (Auth_ShaKey n)\\<rangle> \\<notin> spied s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>n, Key (Auth_ShaKey n)\\<rangle> \\<notin> spied s", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>n, Key (Auth_ShaKey n)\\<rangle> \\<in> spied s \\<Longrightarrow>\n    False", "assume D: \"\\<langle>n, Key (Auth_ShaKey n)\\<rangle> \\<in> spied s\""], ["proof (state)\nthis:\n  \\<langle>n, Key (Auth_ShaKey n)\\<rangle> \\<in> spied s\n\ngoal (1 subgoal):\n 1. \\<langle>n, Key (Auth_ShaKey n)\\<rangle> \\<in> spied s \\<Longrightarrow>\n    False", "hence \"n \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\""], ["proof (prove)\nusing this:\n  \\<langle>n, Key (Auth_ShaKey n)\\<rangle> \\<in> spied s\n\ngoal (1 subgoal):\n 1. n \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey", "by (rule contrapos_pp, rule_tac idinfo_init [OF A])"], ["proof (state)\nthis:\n  n \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\n\ngoal (1 subgoal):\n 1. \\<langle>n, Key (Auth_ShaKey n)\\<rangle> \\<in> spied s \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  n \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\n\ngoal (1 subgoal):\n 1. \\<langle>n, Key (Auth_ShaKey n)\\<rangle> \\<in> spied s \\<Longrightarrow>\n    False", "have \"Key (Auth_ShaKey n) \\<in> spied s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Key (Auth_ShaKey n) \\<in> spied s", "by (rule idinfo_msg [OF A D])"], ["proof (state)\nthis:\n  Key (Auth_ShaKey n) \\<in> spied s\n\ngoal (1 subgoal):\n 1. \\<langle>n, Key (Auth_ShaKey n)\\<rangle> \\<in> spied s \\<Longrightarrow>\n    False", "hence \"n \\<in> bad_shakey\""], ["proof (prove)\nusing this:\n  Key (Auth_ShaKey n) \\<in> spied s\n\ngoal (1 subgoal):\n 1. n \\<in> bad_shakey", "by (rule contrapos_pp, rule_tac auth_shakey_secret [OF A])"], ["proof (state)\nthis:\n  n \\<in> bad_shakey\n\ngoal (1 subgoal):\n 1. \\<langle>n, Key (Auth_ShaKey n)\\<rangle> \\<in> spied s \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  n \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\n  n \\<in> bad_shakey", "show False"], ["proof (prove)\nusing this:\n  n \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\n  n \\<in> bad_shakey\n\ngoal (1 subgoal):\n 1. False", "using B and C"], ["proof (prove)\nusing this:\n  n \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\n  n \\<in> bad_shakey\n  n \\<notin> bad_id_shakey\n  n \\<notin> bad_shakey \\<inter> (bad_id_password \\<union> bad_id_pubkey)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}