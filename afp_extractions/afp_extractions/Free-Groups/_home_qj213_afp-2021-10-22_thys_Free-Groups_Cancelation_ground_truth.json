{"file_name": "/home/qj213/afp-2021-10-22/thys/Free-Groups/Cancelation.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Free-Groups", "problem_names": ["theorem lconfluent_confluent:\n  \"\\<lbrakk> wfP (R^--1); \\<And>a b c. R a b \\<Longrightarrow> R a c \\<Longrightarrow> \\<exists>d. R^** b d \\<and> R^** c d  \\<rbrakk> \\<Longrightarrow> confluent R\"", "lemma confluentD:\n  \"\\<lbrakk> confluent R; R^** a b; R^** a c  \\<rbrakk> \\<Longrightarrow> \\<exists>d. R^** b d \\<and> R^** c d\"", "lemma tranclp_DomainP: \"R^++ a b \\<Longrightarrow> Domainp R a\"", "lemma confluent_unique_normal_form:\n  \"\\<lbrakk> confluent R; R^** a b; R^** a c; \\<not> Domainp R b; \\<not> Domainp R c  \\<rbrakk> \\<Longrightarrow> b = c\"", "lemma cancel_cancel: \"\\<lbrakk> canceling a b; canceling b c \\<rbrakk> \\<Longrightarrow> a = c\"", "lemma cancel_sym: \"canceling a b \\<Longrightarrow> canceling b a\"", "lemma cancel_sym_neg: \"\\<not>canceling a b \\<Longrightarrow> \\<not>canceling b a\"", "lemma cancel_at_length[simp]:\n  \"1+i < length l \\<Longrightarrow> length (cancel_at i l) = length l - 2\"", "lemma cancel_at_nth1[simp]:\n  \"\\<lbrakk> n < i; 1+i < length l  \\<rbrakk> \\<Longrightarrow> (cancel_at i l) ! n = l ! n\"", "lemma cancel_at_nth2[simp]:\n  assumes \"n \\<ge> i\" and \"n < length l - 2\"\n  shows \"(cancel_at i l) ! n = l ! (n + 2)\"", "lemma cancels_to_trans [trans]:\n  \"\\<lbrakk> cancels_to a b; cancels_to b c \\<rbrakk> \\<Longrightarrow> cancels_to a c\"", "lemma cancels_to_1_unfold:\n  assumes \"cancels_to_1 x y\"\n  obtains xs1 x1 x2 xs2\n  where \"x = xs1 @ x1 # x2 # xs2\"\n    and \"y = xs1 @ xs2\"\n    and \"canceling x1 x2\"", "lemma cancels_to_1_fold:\n  \"canceling x1 x2 \\<Longrightarrow> cancels_to_1 (xs1 @ x1 # x2 # xs2) (xs1 @ xs2)\"", "lemma canceling_terminates: \"wfP (cancels_to_1^--1)\"", "lemma canceling_neighbor:\n  assumes \"cancels_to_1_at i l a\" and \"cancels_to_1_at (Suc i) l b\"\n  shows \"a = b\"", "lemma canceling_indep:\n  assumes \"cancels_to_1_at i l a\" and \"cancels_to_1_at j l b\" and \"j > Suc i\"\n  obtains c where \"cancels_to_1_at (j - 2) a c\" and \"cancels_to_1_at i b c\"", "lemma confluent_cancels_to_1: \"confluent cancels_to_1\"", "lemma norm_form_uniq:\n  assumes \"cancels_to a b\"\n      and \"cancels_to a c\"\n      and \"canceled b\"\n      and \"canceled c\"\n  shows \"b = c\"", "lemma cancel_to_1_append:\n  assumes \"cancels_to_1 a b\"\n  shows \"cancels_to_1 (l@a@l') (l@b@l')\"", "lemma cancel_to_append:\n  assumes \"cancels_to a b\"\n  shows \"cancels_to (l@a@l') (l@b@l')\"", "lemma cancels_to_append2:\n  assumes \"cancels_to a a'\"\n      and \"cancels_to b b'\"\n  shows \"cancels_to (a@b) (a'@b')\"", "lemma empty_canceled[simp]: \"canceled []\"", "lemma singleton_canceled[simp]: \"canceled [a]\"", "lemma cons_canceled:\n  assumes \"canceled (a#x)\"\n  shows   \"canceled x\"", "lemma cancels_to_self[simp]: \"cancels_to l l\"", "lemma\n  shows normalized_canceled[simp]: \"canceled (normalize l)\"\n  and   normalized_cancels_to[simp]: \"cancels_to l (normalize l)\"", "lemma normalize_discover:\n  assumes \"canceled l'\"\n      and \"cancels_to l l'\"\n  shows \"normalize l = l'\"", "lemma normalize_canceled[simp]:\n  assumes \"cancels_to l l'\"\n  shows   \"normalize l = normalize l'\"", "lemma normalize_idemp[simp]:\n  assumes \"canceled l\"\n  shows \"normalize l = l\"", "lemma normalize_append_cancel_to:\n  assumes \"cancels_to l1 l1'\"\n  and     \"cancels_to l2 l2'\"\n  shows \"normalize (l1 @ l2) = normalize (l1' @ l2')\"", "lemma cancels_to_1_preserves_generators:\n  assumes \"cancels_to_1 l l'\"\n      and \"l \\<in> lists (UNIV \\<times> gens)\"\n  shows \"l' \\<in> lists (UNIV \\<times> gens)\"", "lemma cancels_to_preserves_generators:\n  assumes \"cancels_to l l'\"\n      and \"l \\<in> lists (UNIV \\<times> gens)\"\n  shows \"l' \\<in> lists (UNIV \\<times> gens)\"", "lemma normalize_preserves_generators:\n  assumes \"l \\<in> lists (UNIV \\<times> gens)\"\n    shows \"normalize l \\<in> lists (UNIV \\<times> gens)\"", "lemma empty_in_lists[simp]:\n  \"[] \\<in> lists A\"", "lemma lists_empty[simp]: \"lists {} = {[]}\"", "lemma rename_gens_cancel_at: \"cancel_at i (map f l) = map f (cancel_at i l)\"", "lemma rename_gens_cancels_to_1:\n  assumes \"inj f\"\n      and \"cancels_to_1 l l'\"\n    shows \"cancels_to_1 (map (map_prod f g) l) (map (map_prod f g) l')\"", "lemma rename_gens_cancels_to:\n  assumes \"inj f\"\n      and \"cancels_to l l'\"\n    shows \"cancels_to (map (map_prod f g) l) (map (map_prod f g) l')\"", "lemma rename_gens_canceled:\n  assumes \"inj_on g (snd`set l)\"\n      and \"canceled l\"\n  shows \"canceled (map (map_prod f g) l)\"", "lemma rename_gens_normalize:\n  assumes \"inj f\"\n  and \"inj_on g (snd ` set l)\"\n  shows \"normalize (map (map_prod f g) l) = map (map_prod f g) (normalize l)\""], "translations": [["", "theorem lconfluent_confluent:\n  \"\\<lbrakk> wfP (R^--1); \\<And>a b c. R a b \\<Longrightarrow> R a c \\<Longrightarrow> \\<exists>d. R^** b d \\<and> R^** c d  \\<rbrakk> \\<Longrightarrow> confluent R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wfP R\\<inverse>\\<inverse>;\n     \\<And>a b c.\n        \\<lbrakk>R a b; R a c\\<rbrakk>\n        \\<Longrightarrow> \\<exists>d.\n                             R\\<^sup>*\\<^sup>* b d \\<and>\n                             R\\<^sup>*\\<^sup>* c d\\<rbrakk>\n    \\<Longrightarrow> confluent R", "by(auto simp add: diamond_def commute_def square_def intro: newman)"], ["", "lemma confluentD:\n  \"\\<lbrakk> confluent R; R^** a b; R^** a c  \\<rbrakk> \\<Longrightarrow> \\<exists>d. R^** b d \\<and> R^** c d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>confluent R; R\\<^sup>*\\<^sup>* a b;\n     R\\<^sup>*\\<^sup>* a c\\<rbrakk>\n    \\<Longrightarrow> \\<exists>d.\n                         R\\<^sup>*\\<^sup>* b d \\<and> R\\<^sup>*\\<^sup>* c d", "by(auto simp add: commute_def diamond_def square_def)"], ["", "lemma tranclp_DomainP: \"R^++ a b \\<Longrightarrow> Domainp R a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R\\<^sup>+\\<^sup>+ a b \\<Longrightarrow> Domainp R a", "by(auto elim: converse_tranclpE)"], ["", "lemma confluent_unique_normal_form:\n  \"\\<lbrakk> confluent R; R^** a b; R^** a c; \\<not> Domainp R b; \\<not> Domainp R c  \\<rbrakk> \\<Longrightarrow> b = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>confluent R; R\\<^sup>*\\<^sup>* a b; R\\<^sup>*\\<^sup>* a c;\n     \\<not> Domainp R b; \\<not> Domainp R c\\<rbrakk>\n    \\<Longrightarrow> b = c", "by(fastforce dest!: confluentD[of R a b c] dest: tranclp_DomainP rtranclpD[where a=b] rtranclpD[where a=c])"], ["", "subsection \\<open>Definition of the @{term \"canceling\"} relation\\<close>"], ["", "type_synonym 'a \"g_i\" = \"(bool \\<times> 'a)\""], ["", "(* A generator or its inverse *)"], ["", "type_synonym 'a \"word_g_i\" = \"'a g_i list\""], ["", "(* A word in the generators or their inverses *)"], ["", "text \\<open>\nThese type aliases encode the notion of a ``generator or its inverse''\n(@{typ \"'a g_i\"}) and the notion of a ``word in generators and their inverses''\n(@{typ \"'a word_g_i\"}), which form the building blocks of Free Groups.\n\\<close>"], ["", "definition canceling :: \"'a g_i \\<Rightarrow> 'a g_i \\<Rightarrow> bool\"\n where \"canceling a b = ((snd a = snd b) \\<and> (fst a \\<noteq> fst b))\""], ["", "subsubsection \\<open>Simple results about canceling\\<close>"], ["", "text \\<open>\nA generators cancels with its inverse, either way. The relation is symmetic.\n\\<close>"], ["", "lemma cancel_cancel: \"\\<lbrakk> canceling a b; canceling b c \\<rbrakk> \\<Longrightarrow> a = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>canceling a b; canceling b c\\<rbrakk> \\<Longrightarrow> a = c", "by (auto intro: prod_eqI simp add:canceling_def)"], ["", "lemma cancel_sym: \"canceling a b \\<Longrightarrow> canceling b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canceling a b \\<Longrightarrow> canceling b a", "by (simp add:canceling_def)"], ["", "lemma cancel_sym_neg: \"\\<not>canceling a b \\<Longrightarrow> \\<not>canceling b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> canceling a b \\<Longrightarrow> \\<not> canceling b a", "by (rule classical, simp add:canceling_def)"], ["", "subsection \\<open>Definition of the @{term \"cancels_to\"} relation\\<close>"], ["", "text \\<open>\nFirst, we define the function that removes the @{term i}th and \\<open>(i+1)\\<close>st\nelement from a word of generators, together with basic properties.\n\\<close>"], ["", "definition cancel_at :: \"nat \\<Rightarrow> 'a word_g_i \\<Rightarrow> 'a word_g_i\"\nwhere \"cancel_at i l = take i l @ drop (2+i) l\""], ["", "lemma cancel_at_length[simp]:\n  \"1+i < length l \\<Longrightarrow> length (cancel_at i l) = length l - 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + i < length l \\<Longrightarrow> length (cancel_at i l) = length l - 2", "by(auto simp add: cancel_at_def)"], ["", "lemma cancel_at_nth1[simp]:\n  \"\\<lbrakk> n < i; 1+i < length l  \\<rbrakk> \\<Longrightarrow> (cancel_at i l) ! n = l ! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>n < i; 1 + i < length l\\<rbrakk>\n    \\<Longrightarrow> cancel_at i l ! n = l ! n", "by(auto simp add: cancel_at_def nth_append)"], ["", "lemma cancel_at_nth2[simp]:\n  assumes \"n \\<ge> i\" and \"n < length l - 2\"\n  shows \"(cancel_at i l) ! n = l ! (n + 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cancel_at i l ! n = l ! (n + 2)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. cancel_at i l ! n = l ! (n + 2)", "from \\<open>n \\<ge> i\\<close> and \\<open>n < length l - 2\\<close>"], ["proof (chain)\npicking this:\n  i \\<le> n\n  n < length l - 2", "have \"i = min (length l) i\""], ["proof (prove)\nusing this:\n  i \\<le> n\n  n < length l - 2\n\ngoal (1 subgoal):\n 1. i = min (length l) i", "by auto"], ["proof (state)\nthis:\n  i = min (length l) i\n\ngoal (1 subgoal):\n 1. cancel_at i l ! n = l ! (n + 2)", "with \\<open>n \\<ge> i\\<close> and \\<open>n < length l - 2\\<close>"], ["proof (chain)\npicking this:\n  i \\<le> n\n  n < length l - 2\n  i = min (length l) i", "show \"(cancel_at i l) ! n = l ! (n + 2)\""], ["proof (prove)\nusing this:\n  i \\<le> n\n  n < length l - 2\n  i = min (length l) i\n\ngoal (1 subgoal):\n 1. cancel_at i l ! n = l ! (n + 2)", "by(auto simp add: cancel_at_def nth_append nth_via_drop)"], ["proof (state)\nthis:\n  cancel_at i l ! n = l ! (n + 2)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThen we can define the relation @{term \"cancels_to_1_at i a b\"} which specifies\nthat @{term b} can be obtained by @{term a} by canceling the @{term i}th and\n\\<open>(i+1)\\<close>st position.\n\nBased on that, we existentially quantify over the position \\<open>i\\<close> to obtain\nthe relation \\<open>cancels_to_1\\<close>, of which \\<open>cancels_to\\<close> is the\nreflexive and transitive closure.\n\nA word is \\<open>canceled\\<close> if it can not be canceled any futher.\n\\<close>"], ["", "definition cancels_to_1_at ::  \"nat \\<Rightarrow> 'a word_g_i \\<Rightarrow> 'a word_g_i \\<Rightarrow> bool\"\nwhere  \"cancels_to_1_at i l1 l2 = (0\\<le>i \\<and> (1+i) < length l1\n                              \\<and> canceling (l1 ! i) (l1 ! (1+i))\n                              \\<and> (l2 = cancel_at i l1))\""], ["", "definition cancels_to_1 :: \"'a word_g_i \\<Rightarrow> 'a word_g_i \\<Rightarrow> bool\"\nwhere \"cancels_to_1 l1 l2 = (\\<exists>i. cancels_to_1_at i l1 l2)\""], ["", "definition cancels_to  :: \"'a word_g_i \\<Rightarrow> 'a word_g_i \\<Rightarrow> bool\"\nwhere \"cancels_to = cancels_to_1^**\""], ["", "lemma cancels_to_trans [trans]:\n  \"\\<lbrakk> cancels_to a b; cancels_to b c \\<rbrakk> \\<Longrightarrow> cancels_to a c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cancels_to a b; cancels_to b c\\<rbrakk>\n    \\<Longrightarrow> cancels_to a c", "by (auto simp add:cancels_to_def)"], ["", "definition canceled :: \"'a word_g_i \\<Rightarrow> bool\"\n where \"canceled l = (\\<not> Domainp cancels_to_1 l)\""], ["", "(* Alternative view on cancelation, sometimes easier to work with *)"], ["", "lemma cancels_to_1_unfold:\n  assumes \"cancels_to_1 x y\"\n  obtains xs1 x1 x2 xs2\n  where \"x = xs1 @ x1 # x2 # xs2\"\n    and \"y = xs1 @ xs2\"\n    and \"canceling x1 x2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>xs1 x1 x2 xs2.\n        \\<lbrakk>x = xs1 @ x1 # x2 # xs2; y = xs1 @ xs2;\n         canceling x1 x2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>xs1 x1 x2 xs2.\n        \\<lbrakk>x = xs1 @ x1 # x2 # xs2; y = xs1 @ xs2;\n         canceling x1 x2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume a: \"(\\<And>xs1 x1 x2 xs2. \\<lbrakk>x = xs1 @ x1 # x2 # xs2; y = xs1 @ xs2; canceling x1 x2\\<rbrakk> \\<Longrightarrow> thesis)\""], ["proof (state)\nthis:\n  \\<lbrakk>x = ?xs1.0 @ ?x1.0 # ?x2.0 # ?xs2.0; y = ?xs1.0 @ ?xs2.0;\n   canceling ?x1.0 ?x2.0\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>xs1 x1 x2 xs2.\n        \\<lbrakk>x = xs1 @ x1 # x2 # xs2; y = xs1 @ xs2;\n         canceling x1 x2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>cancels_to_1 x y\\<close>"], ["proof (chain)\npicking this:\n  cancels_to_1 x y", "obtain i where \"cancels_to_1_at i x y\""], ["proof (prove)\nusing this:\n  cancels_to_1 x y\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        cancels_to_1_at i x y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding cancels_to_1_def"], ["proof (prove)\nusing this:\n  \\<exists>i. cancels_to_1_at i x y\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        cancels_to_1_at i x y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  cancels_to_1_at i x y\n\ngoal (1 subgoal):\n 1. (\\<And>xs1 x1 x2 xs2.\n        \\<lbrakk>x = xs1 @ x1 # x2 # xs2; y = xs1 @ xs2;\n         canceling x1 x2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"canceling (x ! i) (x ! Suc i)\"\n    and \"y = (take i x) @ (drop (Suc (Suc i)) x)\"\n    and \"x = (take i x) @ x ! i # x ! Suc i # (drop (Suc (Suc i)) x)\""], ["proof (prove)\nusing this:\n  cancels_to_1_at i x y\n\ngoal (1 subgoal):\n 1. canceling (x ! i) (x ! Suc i) &&&\n    y = take i x @ drop (Suc (Suc i)) x &&&\n    x = take i x @ x ! i # x ! Suc i # drop (Suc (Suc i)) x", "unfolding cancel_at_def and cancels_to_1_at_def"], ["proof (prove)\nusing this:\n  0 \\<le> i \\<and>\n  1 + i < length x \\<and>\n  canceling (x ! i) (x ! (1 + i)) \\<and> y = take i x @ drop (2 + i) x\n\ngoal (1 subgoal):\n 1. canceling (x ! i) (x ! Suc i) &&&\n    y = take i x @ drop (Suc (Suc i)) x &&&\n    x = take i x @ x ! i # x ! Suc i # drop (Suc (Suc i)) x", "by (auto simp add: Cons_nth_drop_Suc)"], ["proof (state)\nthis:\n  canceling (x ! i) (x ! Suc i)\n  y = take i x @ drop (Suc (Suc i)) x\n  x = take i x @ x ! i # x ! Suc i # drop (Suc (Suc i)) x\n\ngoal (1 subgoal):\n 1. (\\<And>xs1 x1 x2 xs2.\n        \\<lbrakk>x = xs1 @ x1 # x2 # xs2; y = xs1 @ xs2;\n         canceling x1 x2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with a"], ["proof (chain)\npicking this:\n  \\<lbrakk>x = ?xs1.0 @ ?x1.0 # ?x2.0 # ?xs2.0; y = ?xs1.0 @ ?xs2.0;\n   canceling ?x1.0 ?x2.0\\<rbrakk>\n  \\<Longrightarrow> thesis\n  canceling (x ! i) (x ! Suc i)\n  y = take i x @ drop (Suc (Suc i)) x\n  x = take i x @ x ! i # x ! Suc i # drop (Suc (Suc i)) x", "show thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>x = ?xs1.0 @ ?x1.0 # ?x2.0 # ?xs2.0; y = ?xs1.0 @ ?xs2.0;\n   canceling ?x1.0 ?x2.0\\<rbrakk>\n  \\<Longrightarrow> thesis\n  canceling (x ! i) (x ! Suc i)\n  y = take i x @ drop (Suc (Suc i)) x\n  x = take i x @ x ! i # x ! Suc i # drop (Suc (Suc i)) x\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "(* And the reverse direction *)"], ["", "lemma cancels_to_1_fold:\n  \"canceling x1 x2 \\<Longrightarrow> cancels_to_1 (xs1 @ x1 # x2 # xs2) (xs1 @ xs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canceling x1 x2 \\<Longrightarrow>\n    cancels_to_1 (xs1 @ x1 # x2 # xs2) (xs1 @ xs2)", "unfolding cancels_to_1_def and cancels_to_1_at_def and cancel_at_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. canceling x1 x2 \\<Longrightarrow>\n    \\<exists>i\\<ge>0.\n       1 + i < length (xs1 @ x1 # x2 # xs2) \\<and>\n       canceling ((xs1 @ x1 # x2 # xs2) ! i)\n        ((xs1 @ x1 # x2 # xs2) ! (1 + i)) \\<and>\n       xs1 @ xs2 =\n       take i (xs1 @ x1 # x2 # xs2) @ drop (2 + i) (xs1 @ x1 # x2 # xs2)", "by (rule_tac x=\"length xs1\" in exI, auto simp add:nth_append)"], ["", "subsubsection \\<open>Existence of the normal form\\<close>"], ["", "text \\<open>\nOne of two steps to show that we have a normal form is the following lemma,\nguaranteeing that by canceling, we always end up at a fully canceled word.\n\\<close>"], ["", "lemma canceling_terminates: \"wfP (cancels_to_1^--1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP cancels_to_1\\<inverse>\\<inverse>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. wfP cancels_to_1\\<inverse>\\<inverse>", "have \"wf (measure length)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measure length)", "by auto"], ["proof (state)\nthis:\n  wf (measure length)\n\ngoal (1 subgoal):\n 1. wfP cancels_to_1\\<inverse>\\<inverse>", "moreover"], ["proof (state)\nthis:\n  wf (measure length)\n\ngoal (1 subgoal):\n 1. wfP cancels_to_1\\<inverse>\\<inverse>", "have \"{(x, y). cancels_to_1 y x} \\<subseteq> measure length\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(x, y). cancels_to_1 y x} \\<subseteq> measure length", "by (auto simp add: cancels_to_1_def cancel_at_def cancels_to_1_at_def)"], ["proof (state)\nthis:\n  {(x, y). cancels_to_1 y x} \\<subseteq> measure length\n\ngoal (1 subgoal):\n 1. wfP cancels_to_1\\<inverse>\\<inverse>", "ultimately"], ["proof (chain)\npicking this:\n  wf (measure length)\n  {(x, y). cancels_to_1 y x} \\<subseteq> measure length", "have \"wf {(x, y). cancels_to_1 y x}\""], ["proof (prove)\nusing this:\n  wf (measure length)\n  {(x, y). cancels_to_1 y x} \\<subseteq> measure length\n\ngoal (1 subgoal):\n 1. wf {(x, y). cancels_to_1 y x}", "by(rule wf_subset)"], ["proof (state)\nthis:\n  wf {(x, y). cancels_to_1 y x}\n\ngoal (1 subgoal):\n 1. wfP cancels_to_1\\<inverse>\\<inverse>", "thus ?thesis"], ["proof (prove)\nusing this:\n  wf {(x, y). cancels_to_1 y x}\n\ngoal (1 subgoal):\n 1. wfP cancels_to_1\\<inverse>\\<inverse>", "by (simp add:wfP_def)"], ["proof (state)\nthis:\n  wfP cancels_to_1\\<inverse>\\<inverse>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThe next two lemmas prepare for the proof of confluence. It does not matter in\nwhich order we cancel, we can obtain the same result.\n\\<close>"], ["", "lemma canceling_neighbor:\n  assumes \"cancels_to_1_at i l a\" and \"cancels_to_1_at (Suc i) l b\"\n  shows \"a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = b", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. a = b", "from \\<open>cancels_to_1_at i l a\\<close>"], ["proof (chain)\npicking this:\n  cancels_to_1_at i l a", "have \"canceling (l ! i) (l ! Suc i)\" and \"i < length l\""], ["proof (prove)\nusing this:\n  cancels_to_1_at i l a\n\ngoal (1 subgoal):\n 1. canceling (l ! i) (l ! Suc i) &&& i < length l", "by (auto simp add: cancels_to_1_at_def)"], ["proof (state)\nthis:\n  canceling (l ! i) (l ! Suc i)\n  i < length l\n\ngoal (1 subgoal):\n 1. a = b", "from \\<open>cancels_to_1_at (Suc i) l b\\<close>"], ["proof (chain)\npicking this:\n  cancels_to_1_at (Suc i) l b", "have \"canceling (l ! Suc i) (l ! Suc (Suc i))\" and \"Suc (Suc i) < length l\""], ["proof (prove)\nusing this:\n  cancels_to_1_at (Suc i) l b\n\ngoal (1 subgoal):\n 1. canceling (l ! Suc i) (l ! Suc (Suc i)) &&& Suc (Suc i) < length l", "by (auto simp add: cancels_to_1_at_def)"], ["proof (state)\nthis:\n  canceling (l ! Suc i) (l ! Suc (Suc i))\n  Suc (Suc i) < length l\n\ngoal (1 subgoal):\n 1. a = b", "from \\<open>canceling (l ! i) (l ! Suc i)\\<close> and \\<open>canceling (l ! Suc i) (l ! Suc (Suc i))\\<close>"], ["proof (chain)\npicking this:\n  canceling (l ! i) (l ! Suc i)\n  canceling (l ! Suc i) (l ! Suc (Suc i))", "have \"l ! i = l ! Suc (Suc i)\""], ["proof (prove)\nusing this:\n  canceling (l ! i) (l ! Suc i)\n  canceling (l ! Suc i) (l ! Suc (Suc i))\n\ngoal (1 subgoal):\n 1. l ! i = l ! Suc (Suc i)", "by (rule cancel_cancel)"], ["proof (state)\nthis:\n  l ! i = l ! Suc (Suc i)\n\ngoal (1 subgoal):\n 1. a = b", "from \\<open>cancels_to_1_at (Suc i) l b\\<close>"], ["proof (chain)\npicking this:\n  cancels_to_1_at (Suc i) l b", "have \"b = take (Suc i) l @ drop (Suc (Suc (Suc i))) l\""], ["proof (prove)\nusing this:\n  cancels_to_1_at (Suc i) l b\n\ngoal (1 subgoal):\n 1. b = take (Suc i) l @ drop (Suc (Suc (Suc i))) l", "by (simp add: cancels_to_1_at_def cancel_at_def)"], ["proof (state)\nthis:\n  b = take (Suc i) l @ drop (Suc (Suc (Suc i))) l\n\ngoal (1 subgoal):\n 1. a = b", "also"], ["proof (state)\nthis:\n  b = take (Suc i) l @ drop (Suc (Suc (Suc i))) l\n\ngoal (1 subgoal):\n 1. a = b", "from \\<open>i < length l\\<close>"], ["proof (chain)\npicking this:\n  i < length l", "have \"\\<dots> = take i l @ [l ! i] @ drop (Suc (Suc (Suc i))) l\""], ["proof (prove)\nusing this:\n  i < length l\n\ngoal (1 subgoal):\n 1. take (Suc i) l @ drop (Suc (Suc (Suc i))) l =\n    take i l @ [l ! i] @ drop (Suc (Suc (Suc i))) l", "by(auto simp add: take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  take (Suc i) l @ drop (Suc (Suc (Suc i))) l =\n  take i l @ [l ! i] @ drop (Suc (Suc (Suc i))) l\n\ngoal (1 subgoal):\n 1. a = b", "also"], ["proof (state)\nthis:\n  take (Suc i) l @ drop (Suc (Suc (Suc i))) l =\n  take i l @ [l ! i] @ drop (Suc (Suc (Suc i))) l\n\ngoal (1 subgoal):\n 1. a = b", "from \\<open>l ! i = l ! Suc (Suc i)\\<close>"], ["proof (chain)\npicking this:\n  l ! i = l ! Suc (Suc i)", "have \"\\<dots> = take i l @ [l ! Suc (Suc i)] @ drop (Suc (Suc (Suc i))) l\""], ["proof (prove)\nusing this:\n  l ! i = l ! Suc (Suc i)\n\ngoal (1 subgoal):\n 1. take i l @ [l ! i] @ drop (Suc (Suc (Suc i))) l =\n    take i l @ [l ! Suc (Suc i)] @ drop (Suc (Suc (Suc i))) l", "by simp"], ["proof (state)\nthis:\n  take i l @ [l ! i] @ drop (Suc (Suc (Suc i))) l =\n  take i l @ [l ! Suc (Suc i)] @ drop (Suc (Suc (Suc i))) l\n\ngoal (1 subgoal):\n 1. a = b", "also"], ["proof (state)\nthis:\n  take i l @ [l ! i] @ drop (Suc (Suc (Suc i))) l =\n  take i l @ [l ! Suc (Suc i)] @ drop (Suc (Suc (Suc i))) l\n\ngoal (1 subgoal):\n 1. a = b", "from \\<open>Suc (Suc i) < length l\\<close>"], ["proof (chain)\npicking this:\n  Suc (Suc i) < length l", "have \"\\<dots> = take i l @ drop (Suc (Suc i)) l\""], ["proof (prove)\nusing this:\n  Suc (Suc i) < length l\n\ngoal (1 subgoal):\n 1. take i l @ [l ! Suc (Suc i)] @ drop (Suc (Suc (Suc i))) l =\n    take i l @ drop (Suc (Suc i)) l", "by (simp add: Cons_nth_drop_Suc)"], ["proof (state)\nthis:\n  take i l @ [l ! Suc (Suc i)] @ drop (Suc (Suc (Suc i))) l =\n  take i l @ drop (Suc (Suc i)) l\n\ngoal (1 subgoal):\n 1. a = b", "also"], ["proof (state)\nthis:\n  take i l @ [l ! Suc (Suc i)] @ drop (Suc (Suc (Suc i))) l =\n  take i l @ drop (Suc (Suc i)) l\n\ngoal (1 subgoal):\n 1. a = b", "from \\<open>cancels_to_1_at i l a\\<close>"], ["proof (chain)\npicking this:\n  cancels_to_1_at i l a", "have \"\\<dots> = a\""], ["proof (prove)\nusing this:\n  cancels_to_1_at i l a\n\ngoal (1 subgoal):\n 1. take i l @ drop (Suc (Suc i)) l = a", "by (simp add: cancels_to_1_at_def cancel_at_def)"], ["proof (state)\nthis:\n  take i l @ drop (Suc (Suc i)) l = a\n\ngoal (1 subgoal):\n 1. a = b", "finally"], ["proof (chain)\npicking this:\n  b = a", "show \"a = b\""], ["proof (prove)\nusing this:\n  b = a\n\ngoal (1 subgoal):\n 1. a = b", "by(rule sym)"], ["proof (state)\nthis:\n  a = b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma canceling_indep:\n  assumes \"cancels_to_1_at i l a\" and \"cancels_to_1_at j l b\" and \"j > Suc i\"\n  obtains c where \"cancels_to_1_at (j - 2) a c\" and \"cancels_to_1_at i b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>cancels_to_1_at (j - 2) a c; cancels_to_1_at i b c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c. cancels_to_1_at (j - 2) a c \\<and> cancels_to_1_at i b c", "from \\<open>cancels_to_1_at i l a\\<close>"], ["proof (chain)\npicking this:\n  cancels_to_1_at i l a", "have \"Suc i < length l\"\n     and \"canceling (l ! i) (l ! Suc i)\"\n     and \"a = cancel_at i l\"\n     and \"length a = length l - 2\"\n     and \"min (length l) i = i\""], ["proof (prove)\nusing this:\n  cancels_to_1_at i l a\n\ngoal (1 subgoal):\n 1. (Suc i < length l &&& canceling (l ! i) (l ! Suc i)) &&&\n    a = cancel_at i l &&& length a = length l - 2 &&& min (length l) i = i", "by (auto simp add:cancels_to_1_at_def)"], ["proof (state)\nthis:\n  Suc i < length l\n  canceling (l ! i) (l ! Suc i)\n  a = cancel_at i l\n  length a = length l - 2\n  min (length l) i = i\n\ngoal (1 subgoal):\n 1. \\<exists>c. cancels_to_1_at (j - 2) a c \\<and> cancels_to_1_at i b c", "from \\<open>cancels_to_1_at j l b\\<close>"], ["proof (chain)\npicking this:\n  cancels_to_1_at j l b", "have \"Suc j < length l\"\n     and \"canceling (l ! j) (l ! Suc j)\"\n     and \"b = cancel_at j l\"\n     and \"length b = length l - 2\""], ["proof (prove)\nusing this:\n  cancels_to_1_at j l b\n\ngoal (1 subgoal):\n 1. (Suc j < length l &&& canceling (l ! j) (l ! Suc j)) &&&\n    b = cancel_at j l &&& length b = length l - 2", "by (auto simp add:cancels_to_1_at_def)"], ["proof (state)\nthis:\n  Suc j < length l\n  canceling (l ! j) (l ! Suc j)\n  b = cancel_at j l\n  length b = length l - 2\n\ngoal (1 subgoal):\n 1. \\<exists>c. cancels_to_1_at (j - 2) a c \\<and> cancels_to_1_at i b c", "let ?c = \"cancel_at (j - 2) a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c. cancels_to_1_at (j - 2) a c \\<and> cancels_to_1_at i b c", "from \\<open>j > Suc i\\<close>"], ["proof (chain)\npicking this:\n  Suc i < j", "have \"Suc (Suc (j - 2)) = j\"\n    and \"Suc (Suc (Suc j - 2)) = Suc j\""], ["proof (prove)\nusing this:\n  Suc i < j\n\ngoal (1 subgoal):\n 1. Suc (Suc (j - 2)) = j &&& Suc (Suc (Suc j - 2)) = Suc j", "by auto"], ["proof (state)\nthis:\n  Suc (Suc (j - 2)) = j\n  Suc (Suc (Suc j - 2)) = Suc j\n\ngoal (1 subgoal):\n 1. \\<exists>c. cancels_to_1_at (j - 2) a c \\<and> cancels_to_1_at i b c", "with \\<open>min (length l) i = i\\<close> and \\<open>j > Suc i\\<close> and \\<open>Suc j < length l\\<close>"], ["proof (chain)\npicking this:\n  min (length l) i = i\n  Suc i < j\n  Suc j < length l\n  Suc (Suc (j - 2)) = j\n  Suc (Suc (Suc j - 2)) = Suc j", "have \"(l ! j) = (cancel_at i l ! (j - 2))\"\n    and \"(l ! (Suc j)) = (cancel_at i l ! Suc (j - 2))\""], ["proof (prove)\nusing this:\n  min (length l) i = i\n  Suc i < j\n  Suc j < length l\n  Suc (Suc (j - 2)) = j\n  Suc (Suc (Suc j - 2)) = Suc j\n\ngoal (1 subgoal):\n 1. l ! j = cancel_at i l ! (j - 2) &&&\n    l ! Suc j = cancel_at i l ! Suc (j - 2)", "by(auto simp add:cancel_at_def simp add:nth_append)"], ["proof (state)\nthis:\n  l ! j = cancel_at i l ! (j - 2)\n  l ! Suc j = cancel_at i l ! Suc (j - 2)\n\ngoal (1 subgoal):\n 1. \\<exists>c. cancels_to_1_at (j - 2) a c \\<and> cancels_to_1_at i b c", "with \\<open>cancels_to_1_at i l a\\<close>\n    and \\<open>cancels_to_1_at j l b\\<close>"], ["proof (chain)\npicking this:\n  cancels_to_1_at i l a\n  cancels_to_1_at j l b\n  l ! j = cancel_at i l ! (j - 2)\n  l ! Suc j = cancel_at i l ! Suc (j - 2)", "have \"canceling (a ! (j - 2)) (a ! Suc (j - 2))\""], ["proof (prove)\nusing this:\n  cancels_to_1_at i l a\n  cancels_to_1_at j l b\n  l ! j = cancel_at i l ! (j - 2)\n  l ! Suc j = cancel_at i l ! Suc (j - 2)\n\ngoal (1 subgoal):\n 1. canceling (a ! (j - 2)) (a ! Suc (j - 2))", "by(auto simp add:cancels_to_1_at_def)"], ["proof (state)\nthis:\n  canceling (a ! (j - 2)) (a ! Suc (j - 2))\n\ngoal (1 subgoal):\n 1. \\<exists>c. cancels_to_1_at (j - 2) a c \\<and> cancels_to_1_at i b c", "with \\<open>j > Suc i\\<close> and \\<open>Suc j < length l\\<close> and \\<open>length a = length l - 2\\<close>"], ["proof (chain)\npicking this:\n  Suc i < j\n  Suc j < length l\n  length a = length l - 2\n  canceling (a ! (j - 2)) (a ! Suc (j - 2))", "have \"cancels_to_1_at (j - 2) a ?c\""], ["proof (prove)\nusing this:\n  Suc i < j\n  Suc j < length l\n  length a = length l - 2\n  canceling (a ! (j - 2)) (a ! Suc (j - 2))\n\ngoal (1 subgoal):\n 1. cancels_to_1_at (j - 2) a (cancel_at (j - 2) a)", "by (auto simp add: cancels_to_1_at_def)"], ["proof (state)\nthis:\n  cancels_to_1_at (j - 2) a (cancel_at (j - 2) a)\n\ngoal (1 subgoal):\n 1. \\<exists>c. cancels_to_1_at (j - 2) a c \\<and> cancels_to_1_at i b c", "from \\<open>length b = length l - 2\\<close> and \\<open>j > Suc i\\<close> and \\<open>Suc j < length l\\<close>"], ["proof (chain)\npicking this:\n  length b = length l - 2\n  Suc i < j\n  Suc j < length l", "have \"Suc i < length b\""], ["proof (prove)\nusing this:\n  length b = length l - 2\n  Suc i < j\n  Suc j < length l\n\ngoal (1 subgoal):\n 1. Suc i < length b", "by auto"], ["proof (state)\nthis:\n  Suc i < length b\n\ngoal (1 subgoal):\n 1. \\<exists>c. cancels_to_1_at (j - 2) a c \\<and> cancels_to_1_at i b c", "moreover"], ["proof (state)\nthis:\n  Suc i < length b\n\ngoal (1 subgoal):\n 1. \\<exists>c. cancels_to_1_at (j - 2) a c \\<and> cancels_to_1_at i b c", "from \\<open>b = cancel_at j l\\<close> and \\<open>j > Suc i\\<close> and \\<open>Suc i < length l\\<close>"], ["proof (chain)\npicking this:\n  b = cancel_at j l\n  Suc i < j\n  Suc i < length l", "have \"(b ! i) = (l ! i)\" and \"(b ! Suc i) = (l ! Suc i)\""], ["proof (prove)\nusing this:\n  b = cancel_at j l\n  Suc i < j\n  Suc i < length l\n\ngoal (1 subgoal):\n 1. b ! i = l ! i &&& b ! Suc i = l ! Suc i", "by (auto simp add:cancel_at_def nth_append)"], ["proof (state)\nthis:\n  b ! i = l ! i\n  b ! Suc i = l ! Suc i\n\ngoal (1 subgoal):\n 1. \\<exists>c. cancels_to_1_at (j - 2) a c \\<and> cancels_to_1_at i b c", "with \\<open>canceling (l ! i) (l ! Suc i)\\<close>"], ["proof (chain)\npicking this:\n  canceling (l ! i) (l ! Suc i)\n  b ! i = l ! i\n  b ! Suc i = l ! Suc i", "have \"canceling (b ! i) (b ! Suc i)\""], ["proof (prove)\nusing this:\n  canceling (l ! i) (l ! Suc i)\n  b ! i = l ! i\n  b ! Suc i = l ! Suc i\n\ngoal (1 subgoal):\n 1. canceling (b ! i) (b ! Suc i)", "by simp"], ["proof (state)\nthis:\n  canceling (b ! i) (b ! Suc i)\n\ngoal (1 subgoal):\n 1. \\<exists>c. cancels_to_1_at (j - 2) a c \\<and> cancels_to_1_at i b c", "moreover"], ["proof (state)\nthis:\n  canceling (b ! i) (b ! Suc i)\n\ngoal (1 subgoal):\n 1. \\<exists>c. cancels_to_1_at (j - 2) a c \\<and> cancels_to_1_at i b c", "from \\<open>j > Suc i\\<close> and \\<open>Suc j < length l\\<close>"], ["proof (chain)\npicking this:\n  Suc i < j\n  Suc j < length l", "have \"min i j = i\"\n    and \"min (j - 2) i = i\"\n    and \"min (length l) j = j\"\n    and \"min (length l) i = i\"\n    and \"Suc (Suc (j - 2)) = j\""], ["proof (prove)\nusing this:\n  Suc i < j\n  Suc j < length l\n\ngoal (1 subgoal):\n 1. (min i j = i &&& min (j - 2) i = i) &&&\n    min (length l) j = j &&& min (length l) i = i &&& Suc (Suc (j - 2)) = j", "by auto"], ["proof (state)\nthis:\n  min i j = i\n  min (j - 2) i = i\n  min (length l) j = j\n  min (length l) i = i\n  Suc (Suc (j - 2)) = j\n\ngoal (1 subgoal):\n 1. \\<exists>c. cancels_to_1_at (j - 2) a c \\<and> cancels_to_1_at i b c", "with \\<open>a = cancel_at i l\\<close> and \\<open>b = cancel_at j l\\<close> and \\<open>Suc (Suc (j - 2)) = j\\<close>"], ["proof (chain)\npicking this:\n  a = cancel_at i l\n  b = cancel_at j l\n  Suc (Suc (j - 2)) = j\n  min i j = i\n  min (j - 2) i = i\n  min (length l) j = j\n  min (length l) i = i\n  Suc (Suc (j - 2)) = j", "have \"cancel_at (j - 2) a = cancel_at i b\""], ["proof (prove)\nusing this:\n  a = cancel_at i l\n  b = cancel_at j l\n  Suc (Suc (j - 2)) = j\n  min i j = i\n  min (j - 2) i = i\n  min (length l) j = j\n  min (length l) i = i\n  Suc (Suc (j - 2)) = j\n\ngoal (1 subgoal):\n 1. cancel_at (j - 2) a = cancel_at i b", "by (auto simp add:cancel_at_def take_drop)"], ["proof (state)\nthis:\n  cancel_at (j - 2) a = cancel_at i b\n\ngoal (1 subgoal):\n 1. \\<exists>c. cancels_to_1_at (j - 2) a c \\<and> cancels_to_1_at i b c", "ultimately"], ["proof (chain)\npicking this:\n  Suc i < length b\n  canceling (b ! i) (b ! Suc i)\n  cancel_at (j - 2) a = cancel_at i b", "have \"cancels_to_1_at i b (cancel_at (j - 2) a)\""], ["proof (prove)\nusing this:\n  Suc i < length b\n  canceling (b ! i) (b ! Suc i)\n  cancel_at (j - 2) a = cancel_at i b\n\ngoal (1 subgoal):\n 1. cancels_to_1_at i b (cancel_at (j - 2) a)", "by (auto simp add:cancels_to_1_at_def)"], ["proof (state)\nthis:\n  cancels_to_1_at i b (cancel_at (j - 2) a)\n\ngoal (1 subgoal):\n 1. \\<exists>c. cancels_to_1_at (j - 2) a c \\<and> cancels_to_1_at i b c", "with \\<open>cancels_to_1_at (j - 2) a ?c\\<close>"], ["proof (chain)\npicking this:\n  cancels_to_1_at (j - 2) a (cancel_at (j - 2) a)\n  cancels_to_1_at i b (cancel_at (j - 2) a)", "show \"\\<exists>c. cancels_to_1_at (j - 2) a c \\<and> cancels_to_1_at i b c\""], ["proof (prove)\nusing this:\n  cancels_to_1_at (j - 2) a (cancel_at (j - 2) a)\n  cancels_to_1_at i b (cancel_at (j - 2) a)\n\ngoal (1 subgoal):\n 1. \\<exists>c. cancels_to_1_at (j - 2) a c \\<and> cancels_to_1_at i b c", "by blast"], ["proof (state)\nthis:\n  \\<exists>c. cancels_to_1_at (j - 2) a c \\<and> cancels_to_1_at i b c\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This is the confluence lemma\\<close>"], ["", "lemma confluent_cancels_to_1: \"confluent cancels_to_1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. confluent cancels_to_1", "proof(rule lconfluent_confluent)"], ["proof (state)\ngoal (2 subgoals):\n 1. wfP cancels_to_1\\<inverse>\\<inverse>\n 2. \\<And>a b c.\n       \\<lbrakk>cancels_to_1 a b; cancels_to_1 a c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n                            cancels_to_1\\<^sup>*\\<^sup>* c d", "show \"wfP cancels_to_1\\<inverse>\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP cancels_to_1\\<inverse>\\<inverse>", "by (rule canceling_terminates)"], ["proof (state)\nthis:\n  wfP cancels_to_1\\<inverse>\\<inverse>\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>cancels_to_1 a b; cancels_to_1 a c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n                            cancels_to_1\\<^sup>*\\<^sup>* c d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>cancels_to_1 a b; cancels_to_1 a c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n                            cancels_to_1\\<^sup>*\\<^sup>* c d", "fix a b c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>cancels_to_1 a b; cancels_to_1 a c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n                            cancels_to_1\\<^sup>*\\<^sup>* c d", "assume \"cancels_to_1 a b\""], ["proof (state)\nthis:\n  cancels_to_1 a b\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>cancels_to_1 a b; cancels_to_1 a c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n                            cancels_to_1\\<^sup>*\\<^sup>* c d", "then"], ["proof (chain)\npicking this:\n  cancels_to_1 a b", "obtain i where \"cancels_to_1_at i a b\""], ["proof (prove)\nusing this:\n  cancels_to_1 a b\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        cancels_to_1_at i a b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(simp add: cancels_to_1_def)(erule exE)"], ["proof (state)\nthis:\n  cancels_to_1_at i a b\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>cancels_to_1 a b; cancels_to_1 a c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n                            cancels_to_1\\<^sup>*\\<^sup>* c d", "assume \"cancels_to_1 a c\""], ["proof (state)\nthis:\n  cancels_to_1 a c\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>cancels_to_1 a b; cancels_to_1 a c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n                            cancels_to_1\\<^sup>*\\<^sup>* c d", "then"], ["proof (chain)\npicking this:\n  cancels_to_1 a c", "obtain j where \"cancels_to_1_at j a c\""], ["proof (prove)\nusing this:\n  cancels_to_1 a c\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        cancels_to_1_at j a c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(simp add: cancels_to_1_def)(erule exE)"], ["proof (state)\nthis:\n  cancels_to_1_at j a c\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>cancels_to_1 a b; cancels_to_1 a c\\<rbrakk>\n       \\<Longrightarrow> \\<exists>d.\n                            cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n                            cancels_to_1\\<^sup>*\\<^sup>* c d", "show \"\\<exists>d. cancels_to_1\\<^sup>*\\<^sup>* b d \\<and> cancels_to_1\\<^sup>*\\<^sup>* c d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "proof (cases \"i=j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d\n 2. i \\<noteq> j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "assume \"i=j\""], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d\n 2. i \\<noteq> j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "from \\<open>cancels_to_1_at i a b\\<close>"], ["proof (chain)\npicking this:\n  cancels_to_1_at i a b", "have \"b = cancel_at i a\""], ["proof (prove)\nusing this:\n  cancels_to_1_at i a b\n\ngoal (1 subgoal):\n 1. b = cancel_at i a", "by (simp add:cancels_to_1_at_def)"], ["proof (state)\nthis:\n  b = cancel_at i a\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d\n 2. i \\<noteq> j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "moreover"], ["proof (state)\nthis:\n  b = cancel_at i a\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d\n 2. i \\<noteq> j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "from \\<open>i=j\\<close>"], ["proof (chain)\npicking this:\n  i = j", "have \"\\<dots> = cancel_at j a\""], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. cancel_at i a = cancel_at j a", "by (clarify)"], ["proof (state)\nthis:\n  cancel_at i a = cancel_at j a\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d\n 2. i \\<noteq> j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "moreover"], ["proof (state)\nthis:\n  cancel_at i a = cancel_at j a\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d\n 2. i \\<noteq> j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "from \\<open>cancels_to_1_at j a c\\<close>"], ["proof (chain)\npicking this:\n  cancels_to_1_at j a c", "have \"\\<dots> = c\""], ["proof (prove)\nusing this:\n  cancels_to_1_at j a c\n\ngoal (1 subgoal):\n 1. cancel_at j a = c", "by (simp add:cancels_to_1_at_def)"], ["proof (state)\nthis:\n  cancel_at j a = c\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d\n 2. i \\<noteq> j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "ultimately"], ["proof (chain)\npicking this:\n  b = cancel_at i a\n  cancel_at i a = cancel_at j a\n  cancel_at j a = c", "have \"b = c\""], ["proof (prove)\nusing this:\n  b = cancel_at i a\n  cancel_at i a = cancel_at j a\n  cancel_at j a = c\n\ngoal (1 subgoal):\n 1. b = c", "by (simp)"], ["proof (state)\nthis:\n  b = c\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d\n 2. i \\<noteq> j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "hence \"cancels_to_1\\<^sup>*\\<^sup>* b b\"\n      and \"cancels_to_1\\<^sup>*\\<^sup>* c b\""], ["proof (prove)\nusing this:\n  b = c\n\ngoal (1 subgoal):\n 1. cancels_to_1\\<^sup>*\\<^sup>* b b &&& cancels_to_1\\<^sup>*\\<^sup>* c b", "by auto"], ["proof (state)\nthis:\n  cancels_to_1\\<^sup>*\\<^sup>* b b\n  cancels_to_1\\<^sup>*\\<^sup>* c b\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d\n 2. i \\<noteq> j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "thus \"\\<exists>d. cancels_to_1\\<^sup>*\\<^sup>* b d \\<and> cancels_to_1\\<^sup>*\\<^sup>* c d\""], ["proof (prove)\nusing this:\n  cancels_to_1\\<^sup>*\\<^sup>* b b\n  cancels_to_1\\<^sup>*\\<^sup>* c b\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "by blast"], ["proof (state)\nthis:\n  \\<exists>d.\n     cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n     cancels_to_1\\<^sup>*\\<^sup>* c d\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "assume \"i \\<noteq> j\""], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "proof (cases \"j = Suc i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j = Suc i \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d\n 2. j \\<noteq> Suc i \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "assume \"j = Suc i\""], ["proof (state)\nthis:\n  j = Suc i\n\ngoal (2 subgoals):\n 1. j = Suc i \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d\n 2. j \\<noteq> Suc i \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "with \\<open>cancels_to_1_at i a b\\<close> and \\<open>cancels_to_1_at j a c\\<close>"], ["proof (chain)\npicking this:\n  cancels_to_1_at i a b\n  cancels_to_1_at j a c\n  j = Suc i", "have \"b = c\""], ["proof (prove)\nusing this:\n  cancels_to_1_at i a b\n  cancels_to_1_at j a c\n  j = Suc i\n\ngoal (1 subgoal):\n 1. b = c", "by (auto elim: canceling_neighbor)"], ["proof (state)\nthis:\n  b = c\n\ngoal (2 subgoals):\n 1. j = Suc i \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d\n 2. j \\<noteq> Suc i \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "hence \"cancels_to_1\\<^sup>*\\<^sup>* b b\"\n        and \"cancels_to_1\\<^sup>*\\<^sup>* c b\""], ["proof (prove)\nusing this:\n  b = c\n\ngoal (1 subgoal):\n 1. cancels_to_1\\<^sup>*\\<^sup>* b b &&& cancels_to_1\\<^sup>*\\<^sup>* c b", "by auto"], ["proof (state)\nthis:\n  cancels_to_1\\<^sup>*\\<^sup>* b b\n  cancels_to_1\\<^sup>*\\<^sup>* c b\n\ngoal (2 subgoals):\n 1. j = Suc i \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d\n 2. j \\<noteq> Suc i \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "thus \"\\<exists>d. cancels_to_1\\<^sup>*\\<^sup>* b d \\<and> cancels_to_1\\<^sup>*\\<^sup>* c d\""], ["proof (prove)\nusing this:\n  cancels_to_1\\<^sup>*\\<^sup>* b b\n  cancels_to_1\\<^sup>*\\<^sup>* c b\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "by blast"], ["proof (state)\nthis:\n  \\<exists>d.\n     cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n     cancels_to_1\\<^sup>*\\<^sup>* c d\n\ngoal (1 subgoal):\n 1. j \\<noteq> Suc i \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<noteq> Suc i \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "assume \"j \\<noteq> Suc i\""], ["proof (state)\nthis:\n  j \\<noteq> Suc i\n\ngoal (1 subgoal):\n 1. j \\<noteq> Suc i \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "proof (cases \"i = Suc j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = Suc j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d\n 2. i \\<noteq> Suc j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "assume \"i = Suc j\""], ["proof (state)\nthis:\n  i = Suc j\n\ngoal (2 subgoals):\n 1. i = Suc j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d\n 2. i \\<noteq> Suc j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "with \\<open>cancels_to_1_at i a b\\<close> and \\<open>cancels_to_1_at j a c\\<close>"], ["proof (chain)\npicking this:\n  cancels_to_1_at i a b\n  cancels_to_1_at j a c\n  i = Suc j", "have \"c = b\""], ["proof (prove)\nusing this:\n  cancels_to_1_at i a b\n  cancels_to_1_at j a c\n  i = Suc j\n\ngoal (1 subgoal):\n 1. c = b", "by (auto elim: canceling_neighbor)"], ["proof (state)\nthis:\n  c = b\n\ngoal (2 subgoals):\n 1. i = Suc j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d\n 2. i \\<noteq> Suc j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "hence \"cancels_to_1\\<^sup>*\\<^sup>* b b\"\n          and \"cancels_to_1\\<^sup>*\\<^sup>* c b\""], ["proof (prove)\nusing this:\n  c = b\n\ngoal (1 subgoal):\n 1. cancels_to_1\\<^sup>*\\<^sup>* b b &&& cancels_to_1\\<^sup>*\\<^sup>* c b", "by auto"], ["proof (state)\nthis:\n  cancels_to_1\\<^sup>*\\<^sup>* b b\n  cancels_to_1\\<^sup>*\\<^sup>* c b\n\ngoal (2 subgoals):\n 1. i = Suc j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d\n 2. i \\<noteq> Suc j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "thus \"\\<exists>d. cancels_to_1\\<^sup>*\\<^sup>* b d \\<and> cancels_to_1\\<^sup>*\\<^sup>* c d\""], ["proof (prove)\nusing this:\n  cancels_to_1\\<^sup>*\\<^sup>* b b\n  cancels_to_1\\<^sup>*\\<^sup>* c b\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "by blast"], ["proof (state)\nthis:\n  \\<exists>d.\n     cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n     cancels_to_1\\<^sup>*\\<^sup>* c d\n\ngoal (1 subgoal):\n 1. i \\<noteq> Suc j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> Suc j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "assume \"i \\<noteq> Suc j\""], ["proof (state)\nthis:\n  i \\<noteq> Suc j\n\ngoal (1 subgoal):\n 1. i \\<noteq> Suc j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "proof (cases \"i < j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d\n 2. \\<not> i < j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "assume \"i < j\""], ["proof (state)\nthis:\n  i < j\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d\n 2. \\<not> i < j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "with \\<open>j \\<noteq> Suc i\\<close>"], ["proof (chain)\npicking this:\n  j \\<noteq> Suc i\n  i < j", "have \"Suc i < j\""], ["proof (prove)\nusing this:\n  j \\<noteq> Suc i\n  i < j\n\ngoal (1 subgoal):\n 1. Suc i < j", "by auto"], ["proof (state)\nthis:\n  Suc i < j\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d\n 2. \\<not> i < j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "with \\<open>cancels_to_1_at i a b\\<close> and \\<open>cancels_to_1_at j a c\\<close>"], ["proof (chain)\npicking this:\n  cancels_to_1_at i a b\n  cancels_to_1_at j a c\n  Suc i < j", "obtain d where \"cancels_to_1_at (j - 2) b d\" and \"cancels_to_1_at i c d\""], ["proof (prove)\nusing this:\n  cancels_to_1_at i a b\n  cancels_to_1_at j a c\n  Suc i < j\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>cancels_to_1_at (j - 2) b d; cancels_to_1_at i c d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule canceling_indep)"], ["proof (state)\nthis:\n  cancels_to_1_at (j - 2) b d\n  cancels_to_1_at i c d\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d\n 2. \\<not> i < j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "hence \"cancels_to_1 b d\" and \"cancels_to_1 c d\""], ["proof (prove)\nusing this:\n  cancels_to_1_at (j - 2) b d\n  cancels_to_1_at i c d\n\ngoal (1 subgoal):\n 1. cancels_to_1 b d &&& cancels_to_1 c d", "by (auto simp add:cancels_to_1_def)"], ["proof (state)\nthis:\n  cancels_to_1 b d\n  cancels_to_1 c d\n\ngoal (2 subgoals):\n 1. i < j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d\n 2. \\<not> i < j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "thus \"\\<exists>d. cancels_to_1\\<^sup>*\\<^sup>* b d \\<and> cancels_to_1\\<^sup>*\\<^sup>* c d\""], ["proof (prove)\nusing this:\n  cancels_to_1 b d\n  cancels_to_1 c d\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "by (auto)"], ["proof (state)\nthis:\n  \\<exists>d.\n     cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n     cancels_to_1\\<^sup>*\\<^sup>* c d\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "assume \"\\<not> i < j\""], ["proof (state)\nthis:\n  \\<not> i < j\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "with \\<open>j \\<noteq> Suc i\\<close> and \\<open>i \\<noteq> j\\<close> and \\<open>i \\<noteq> Suc j\\<close>"], ["proof (chain)\npicking this:\n  j \\<noteq> Suc i\n  i \\<noteq> j\n  i \\<noteq> Suc j\n  \\<not> i < j", "have \"Suc j < i\""], ["proof (prove)\nusing this:\n  j \\<noteq> Suc i\n  i \\<noteq> j\n  i \\<noteq> Suc j\n  \\<not> i < j\n\ngoal (1 subgoal):\n 1. Suc j < i", "by auto"], ["proof (state)\nthis:\n  Suc j < i\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "with \\<open>cancels_to_1_at i a b\\<close> and \\<open>cancels_to_1_at j a c\\<close>"], ["proof (chain)\npicking this:\n  cancels_to_1_at i a b\n  cancels_to_1_at j a c\n  Suc j < i", "obtain d where \"cancels_to_1_at (i - 2) c d\" and \"cancels_to_1_at j b d\""], ["proof (prove)\nusing this:\n  cancels_to_1_at i a b\n  cancels_to_1_at j a c\n  Suc j < i\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>cancels_to_1_at (i - 2) c d; cancels_to_1_at j b d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(erule canceling_indep)"], ["proof (state)\nthis:\n  cancels_to_1_at (i - 2) c d\n  cancels_to_1_at j b d\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "hence \"cancels_to_1 b d\" and \"cancels_to_1 c d\""], ["proof (prove)\nusing this:\n  cancels_to_1_at (i - 2) c d\n  cancels_to_1_at j b d\n\ngoal (1 subgoal):\n 1. cancels_to_1 b d &&& cancels_to_1 c d", "by (auto simp add:cancels_to_1_def)"], ["proof (state)\nthis:\n  cancels_to_1 b d\n  cancels_to_1 c d\n\ngoal (1 subgoal):\n 1. \\<not> i < j \\<Longrightarrow>\n    \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "thus \"\\<exists>d. cancels_to_1\\<^sup>*\\<^sup>* b d \\<and> cancels_to_1\\<^sup>*\\<^sup>* c d\""], ["proof (prove)\nusing this:\n  cancels_to_1 b d\n  cancels_to_1 c d\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n       cancels_to_1\\<^sup>*\\<^sup>* c d", "by (auto)"], ["proof (state)\nthis:\n  \\<exists>d.\n     cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n     cancels_to_1\\<^sup>*\\<^sup>* c d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d.\n     cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n     cancels_to_1\\<^sup>*\\<^sup>* c d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d.\n     cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n     cancels_to_1\\<^sup>*\\<^sup>* c d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d.\n     cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n     cancels_to_1\\<^sup>*\\<^sup>* c d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>d.\n     cancels_to_1\\<^sup>*\\<^sup>* b d \\<and>\n     cancels_to_1\\<^sup>*\\<^sup>* c d\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nAnd finally, we show that there exists a unique normal form for each word.\n\\<close>"], ["", "(*\nlemma inv_rtrcl: \"R^**^--1 = R^--1^**\" (* Did I overlook this in the standard libs? *)\nby (auto simp add:fun_eq_iff intro: dest:rtranclp_converseD intro:rtranclp_converseI)\n*)"], ["", "lemma norm_form_uniq:\n  assumes \"cancels_to a b\"\n      and \"cancels_to a c\"\n      and \"canceled b\"\n      and \"canceled c\"\n  shows \"b = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = c", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. b = c", "have \"confluent cancels_to_1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. confluent cancels_to_1", "by (rule confluent_cancels_to_1)"], ["proof (state)\nthis:\n  confluent cancels_to_1\n\ngoal (1 subgoal):\n 1. b = c", "moreover"], ["proof (state)\nthis:\n  confluent cancels_to_1\n\ngoal (1 subgoal):\n 1. b = c", "from \\<open>cancels_to a b\\<close>"], ["proof (chain)\npicking this:\n  cancels_to a b", "have \"cancels_to_1^** a b\""], ["proof (prove)\nusing this:\n  cancels_to a b\n\ngoal (1 subgoal):\n 1. cancels_to_1\\<^sup>*\\<^sup>* a b", "by (simp add: cancels_to_def)"], ["proof (state)\nthis:\n  cancels_to_1\\<^sup>*\\<^sup>* a b\n\ngoal (1 subgoal):\n 1. b = c", "moreover"], ["proof (state)\nthis:\n  cancels_to_1\\<^sup>*\\<^sup>* a b\n\ngoal (1 subgoal):\n 1. b = c", "from \\<open>cancels_to a c\\<close>"], ["proof (chain)\npicking this:\n  cancels_to a c", "have \"cancels_to_1^** a c\""], ["proof (prove)\nusing this:\n  cancels_to a c\n\ngoal (1 subgoal):\n 1. cancels_to_1\\<^sup>*\\<^sup>* a c", "by (simp add: cancels_to_def)"], ["proof (state)\nthis:\n  cancels_to_1\\<^sup>*\\<^sup>* a c\n\ngoal (1 subgoal):\n 1. b = c", "moreover"], ["proof (state)\nthis:\n  cancels_to_1\\<^sup>*\\<^sup>* a c\n\ngoal (1 subgoal):\n 1. b = c", "from \\<open>canceled b\\<close>"], ["proof (chain)\npicking this:\n  canceled b", "have \"\\<not> Domainp cancels_to_1 b\""], ["proof (prove)\nusing this:\n  canceled b\n\ngoal (1 subgoal):\n 1. \\<not> Domainp cancels_to_1 b", "by (simp add: canceled_def)"], ["proof (state)\nthis:\n  \\<not> Domainp cancels_to_1 b\n\ngoal (1 subgoal):\n 1. b = c", "moreover"], ["proof (state)\nthis:\n  \\<not> Domainp cancels_to_1 b\n\ngoal (1 subgoal):\n 1. b = c", "from \\<open>canceled c\\<close>"], ["proof (chain)\npicking this:\n  canceled c", "have \"\\<not> Domainp cancels_to_1 c\""], ["proof (prove)\nusing this:\n  canceled c\n\ngoal (1 subgoal):\n 1. \\<not> Domainp cancels_to_1 c", "by (simp add: canceled_def)"], ["proof (state)\nthis:\n  \\<not> Domainp cancels_to_1 c\n\ngoal (1 subgoal):\n 1. b = c", "ultimately"], ["proof (chain)\npicking this:\n  confluent cancels_to_1\n  cancels_to_1\\<^sup>*\\<^sup>* a b\n  cancels_to_1\\<^sup>*\\<^sup>* a c\n  \\<not> Domainp cancels_to_1 b\n  \\<not> Domainp cancels_to_1 c", "show \"b = c\""], ["proof (prove)\nusing this:\n  confluent cancels_to_1\n  cancels_to_1\\<^sup>*\\<^sup>* a b\n  cancels_to_1\\<^sup>*\\<^sup>* a c\n  \\<not> Domainp cancels_to_1 b\n  \\<not> Domainp cancels_to_1 c\n\ngoal (1 subgoal):\n 1. b = c", "by (rule confluent_unique_normal_form)"], ["proof (state)\nthis:\n  b = c\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Some properties of cancelation\\<close>"], ["", "text \\<open>\nDistributivity rules of cancelation and \\<open>append\\<close>.\n\\<close>"], ["", "lemma cancel_to_1_append:\n  assumes \"cancels_to_1 a b\"\n  shows \"cancels_to_1 (l@a@l') (l@b@l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cancels_to_1 (l @ a @ l') (l @ b @ l')", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. cancels_to_1 (l @ a @ l') (l @ b @ l')", "from \\<open>cancels_to_1 a b\\<close>"], ["proof (chain)\npicking this:\n  cancels_to_1 a b", "obtain i where \"cancels_to_1_at i a b\""], ["proof (prove)\nusing this:\n  cancels_to_1 a b\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        cancels_to_1_at i a b \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(simp add: cancels_to_1_def)(erule exE)"], ["proof (state)\nthis:\n  cancels_to_1_at i a b\n\ngoal (1 subgoal):\n 1. cancels_to_1 (l @ a @ l') (l @ b @ l')", "hence \"cancels_to_1_at (length l + i) (l@a@l') (l@b@l')\""], ["proof (prove)\nusing this:\n  cancels_to_1_at i a b\n\ngoal (1 subgoal):\n 1. cancels_to_1_at (length l + i) (l @ a @ l') (l @ b @ l')", "by (auto simp add:cancels_to_1_at_def nth_append cancel_at_def)"], ["proof (state)\nthis:\n  cancels_to_1_at (length l + i) (l @ a @ l') (l @ b @ l')\n\ngoal (1 subgoal):\n 1. cancels_to_1 (l @ a @ l') (l @ b @ l')", "thus \"cancels_to_1 (l@a@l') (l@b@l')\""], ["proof (prove)\nusing this:\n  cancels_to_1_at (length l + i) (l @ a @ l') (l @ b @ l')\n\ngoal (1 subgoal):\n 1. cancels_to_1 (l @ a @ l') (l @ b @ l')", "by (auto simp add: cancels_to_1_def)"], ["proof (state)\nthis:\n  cancels_to_1 (l @ a @ l') (l @ b @ l')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cancel_to_append:\n  assumes \"cancels_to a b\"\n  shows \"cancels_to (l@a@l') (l@b@l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cancels_to (l @ a @ l') (l @ b @ l')", "using assms"], ["proof (prove)\nusing this:\n  cancels_to a b\n\ngoal (1 subgoal):\n 1. cancels_to (l @ a @ l') (l @ b @ l')", "unfolding cancels_to_def"], ["proof (prove)\nusing this:\n  cancels_to_1\\<^sup>*\\<^sup>* a b\n\ngoal (1 subgoal):\n 1. cancels_to_1\\<^sup>*\\<^sup>* (l @ a @ l') (l @ b @ l')", "proof(induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. cancels_to_1\\<^sup>*\\<^sup>* (l @ a @ l') (l @ a @ l')\n 2. \\<And>y z.\n       \\<lbrakk>cancels_to_1\\<^sup>*\\<^sup>* a y; cancels_to_1 y z;\n        cancels_to_1\\<^sup>*\\<^sup>* (l @ a @ l') (l @ y @ l')\\<rbrakk>\n       \\<Longrightarrow> cancels_to_1\\<^sup>*\\<^sup>* (l @ a @ l')\n                          (l @ z @ l')", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. cancels_to_1\\<^sup>*\\<^sup>* (l @ a @ l') (l @ a @ l')\n 2. \\<And>y z.\n       \\<lbrakk>cancels_to_1\\<^sup>*\\<^sup>* a y; cancels_to_1 y z;\n        cancels_to_1\\<^sup>*\\<^sup>* (l @ a @ l') (l @ y @ l')\\<rbrakk>\n       \\<Longrightarrow> cancels_to_1\\<^sup>*\\<^sup>* (l @ a @ l')\n                          (l @ z @ l')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. cancels_to_1\\<^sup>*\\<^sup>* (l @ a @ l') (l @ a @ l')", "by (simp add:cancels_to_def)"], ["proof (state)\nthis:\n  cancels_to_1\\<^sup>*\\<^sup>* (l @ a @ l') (l @ a @ l')\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>cancels_to_1\\<^sup>*\\<^sup>* a y; cancels_to_1 y z;\n        cancels_to_1\\<^sup>*\\<^sup>* (l @ a @ l') (l @ y @ l')\\<rbrakk>\n       \\<Longrightarrow> cancels_to_1\\<^sup>*\\<^sup>* (l @ a @ l')\n                          (l @ z @ l')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>cancels_to_1\\<^sup>*\\<^sup>* a y; cancels_to_1 y z;\n        cancels_to_1\\<^sup>*\\<^sup>* (l @ a @ l') (l @ y @ l')\\<rbrakk>\n       \\<Longrightarrow> cancels_to_1\\<^sup>*\\<^sup>* (l @ a @ l')\n                          (l @ z @ l')", "case (step b c)"], ["proof (state)\nthis:\n  cancels_to_1\\<^sup>*\\<^sup>* a b\n  cancels_to_1 b c\n  cancels_to_1\\<^sup>*\\<^sup>* (l @ a @ l') (l @ b @ l')\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>cancels_to_1\\<^sup>*\\<^sup>* a y; cancels_to_1 y z;\n        cancels_to_1\\<^sup>*\\<^sup>* (l @ a @ l') (l @ y @ l')\\<rbrakk>\n       \\<Longrightarrow> cancels_to_1\\<^sup>*\\<^sup>* (l @ a @ l')\n                          (l @ z @ l')", "from \\<open>cancels_to_1 b c\\<close>"], ["proof (chain)\npicking this:\n  cancels_to_1 b c", "have \"cancels_to_1 (l @ b @ l') (l @ c @ l')\""], ["proof (prove)\nusing this:\n  cancels_to_1 b c\n\ngoal (1 subgoal):\n 1. cancels_to_1 (l @ b @ l') (l @ c @ l')", "by (rule cancel_to_1_append)"], ["proof (state)\nthis:\n  cancels_to_1 (l @ b @ l') (l @ c @ l')\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>cancels_to_1\\<^sup>*\\<^sup>* a y; cancels_to_1 y z;\n        cancels_to_1\\<^sup>*\\<^sup>* (l @ a @ l') (l @ y @ l')\\<rbrakk>\n       \\<Longrightarrow> cancels_to_1\\<^sup>*\\<^sup>* (l @ a @ l')\n                          (l @ z @ l')", "with \\<open>cancels_to_1^** (l @ a @ l') (l @ b @ l')\\<close>"], ["proof (chain)\npicking this:\n  cancels_to_1\\<^sup>*\\<^sup>* (l @ a @ l') (l @ b @ l')\n  cancels_to_1 (l @ b @ l') (l @ c @ l')", "show ?case"], ["proof (prove)\nusing this:\n  cancels_to_1\\<^sup>*\\<^sup>* (l @ a @ l') (l @ b @ l')\n  cancels_to_1 (l @ b @ l') (l @ c @ l')\n\ngoal (1 subgoal):\n 1. cancels_to_1\\<^sup>*\\<^sup>* (l @ a @ l') (l @ c @ l')", "by (auto simp add:cancels_to_def)"], ["proof (state)\nthis:\n  cancels_to_1\\<^sup>*\\<^sup>* (l @ a @ l') (l @ c @ l')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cancels_to_append2:\n  assumes \"cancels_to a a'\"\n      and \"cancels_to b b'\"\n  shows \"cancels_to (a@b) (a'@b')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cancels_to (a @ b) (a' @ b')", "using \\<open>cancels_to a a'\\<close>"], ["proof (prove)\nusing this:\n  cancels_to a a'\n\ngoal (1 subgoal):\n 1. cancels_to (a @ b) (a' @ b')", "unfolding cancels_to_def"], ["proof (prove)\nusing this:\n  cancels_to_1\\<^sup>*\\<^sup>* a a'\n\ngoal (1 subgoal):\n 1. cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (a' @ b')", "proof(induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (a @ b')\n 2. \\<And>y z.\n       \\<lbrakk>cancels_to_1\\<^sup>*\\<^sup>* a y; cancels_to_1 y z;\n        cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (y @ b')\\<rbrakk>\n       \\<Longrightarrow> cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (z @ b')", "case base"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (a @ b')\n 2. \\<And>y z.\n       \\<lbrakk>cancels_to_1\\<^sup>*\\<^sup>* a y; cancels_to_1 y z;\n        cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (y @ b')\\<rbrakk>\n       \\<Longrightarrow> cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (z @ b')", "from \\<open>cancels_to b b'\\<close>"], ["proof (chain)\npicking this:\n  cancels_to b b'", "have \"cancels_to (a@b@[]) (a@b'@[])\""], ["proof (prove)\nusing this:\n  cancels_to b b'\n\ngoal (1 subgoal):\n 1. cancels_to (a @ b @ []) (a @ b' @ [])", "by (rule cancel_to_append)"], ["proof (state)\nthis:\n  cancels_to (a @ b @ []) (a @ b' @ [])\n\ngoal (2 subgoals):\n 1. cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (a @ b')\n 2. \\<And>y z.\n       \\<lbrakk>cancels_to_1\\<^sup>*\\<^sup>* a y; cancels_to_1 y z;\n        cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (y @ b')\\<rbrakk>\n       \\<Longrightarrow> cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (z @ b')", "thus ?case"], ["proof (prove)\nusing this:\n  cancels_to (a @ b @ []) (a @ b' @ [])\n\ngoal (1 subgoal):\n 1. cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (a @ b')", "unfolding cancels_to_def"], ["proof (prove)\nusing this:\n  cancels_to_1\\<^sup>*\\<^sup>* (a @ b @ []) (a @ b' @ [])\n\ngoal (1 subgoal):\n 1. cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (a @ b')", "by simp"], ["proof (state)\nthis:\n  cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (a @ b')\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>cancels_to_1\\<^sup>*\\<^sup>* a y; cancels_to_1 y z;\n        cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (y @ b')\\<rbrakk>\n       \\<Longrightarrow> cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (z @ b')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>cancels_to_1\\<^sup>*\\<^sup>* a y; cancels_to_1 y z;\n        cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (y @ b')\\<rbrakk>\n       \\<Longrightarrow> cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (z @ b')", "case (step ba c)"], ["proof (state)\nthis:\n  cancels_to_1\\<^sup>*\\<^sup>* a ba\n  cancels_to_1 ba c\n  cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (ba @ b')\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>cancels_to_1\\<^sup>*\\<^sup>* a y; cancels_to_1 y z;\n        cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (y @ b')\\<rbrakk>\n       \\<Longrightarrow> cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (z @ b')", "from \\<open>cancels_to_1 ba c\\<close>"], ["proof (chain)\npicking this:\n  cancels_to_1 ba c", "have \"cancels_to_1 ([]@ba@b') ([]@c@b')\""], ["proof (prove)\nusing this:\n  cancels_to_1 ba c\n\ngoal (1 subgoal):\n 1. cancels_to_1 ([] @ ba @ b') ([] @ c @ b')", "by(rule cancel_to_1_append)"], ["proof (state)\nthis:\n  cancels_to_1 ([] @ ba @ b') ([] @ c @ b')\n\ngoal (1 subgoal):\n 1. \\<And>y z.\n       \\<lbrakk>cancels_to_1\\<^sup>*\\<^sup>* a y; cancels_to_1 y z;\n        cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (y @ b')\\<rbrakk>\n       \\<Longrightarrow> cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (z @ b')", "with \\<open>cancels_to_1^** (a @ b) (ba @ b')\\<close>"], ["proof (chain)\npicking this:\n  cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (ba @ b')\n  cancels_to_1 ([] @ ba @ b') ([] @ c @ b')", "show ?case"], ["proof (prove)\nusing this:\n  cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (ba @ b')\n  cancels_to_1 ([] @ ba @ b') ([] @ c @ b')\n\ngoal (1 subgoal):\n 1. cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (c @ b')", "unfolding cancels_to_def"], ["proof (prove)\nusing this:\n  cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (ba @ b')\n  cancels_to_1 ([] @ ba @ b') ([] @ c @ b')\n\ngoal (1 subgoal):\n 1. cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (c @ b')", "by simp"], ["proof (state)\nthis:\n  cancels_to_1\\<^sup>*\\<^sup>* (a @ b) (c @ b')\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThe empty list is canceled, a one letter word is canceled and a word is\ntrivially cancled from itself.\n\\<close>"], ["", "lemma empty_canceled[simp]: \"canceled []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canceled []", "by(auto simp add: canceled_def cancels_to_1_def cancels_to_1_at_def)"], ["", "lemma singleton_canceled[simp]: \"canceled [a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canceled [a]", "by(auto simp add: canceled_def cancels_to_1_def cancels_to_1_at_def)"], ["", "lemma cons_canceled:\n  assumes \"canceled (a#x)\"\n  shows   \"canceled x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canceled x", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> canceled x \\<Longrightarrow> False", "assume \"\\<not> canceled x\""], ["proof (state)\nthis:\n  \\<not> canceled x\n\ngoal (1 subgoal):\n 1. \\<not> canceled x \\<Longrightarrow> False", "hence \"Domainp cancels_to_1 x\""], ["proof (prove)\nusing this:\n  \\<not> canceled x\n\ngoal (1 subgoal):\n 1. Domainp cancels_to_1 x", "by (simp add:canceled_def)"], ["proof (state)\nthis:\n  Domainp cancels_to_1 x\n\ngoal (1 subgoal):\n 1. \\<not> canceled x \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Domainp cancels_to_1 x", "obtain x' where \"cancels_to_1 x x'\""], ["proof (prove)\nusing this:\n  Domainp cancels_to_1 x\n\ngoal (1 subgoal):\n 1. (\\<And>x'. cancels_to_1 x x' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  cancels_to_1 x x'\n\ngoal (1 subgoal):\n 1. \\<not> canceled x \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  cancels_to_1 x x'", "obtain xs1 x1 x2 xs2\n    where x: \"x = xs1 @ x1 # x2 # xs2\"\n    and   \"canceling x1 x2\""], ["proof (prove)\nusing this:\n  cancels_to_1 x x'\n\ngoal (1 subgoal):\n 1. (\\<And>xs1 x1 x2 xs2.\n        \\<lbrakk>x = xs1 @ x1 # x2 # xs2; canceling x1 x2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule cancels_to_1_unfold)"], ["proof (state)\nthis:\n  x = xs1 @ x1 # x2 # xs2\n  canceling x1 x2\n\ngoal (1 subgoal):\n 1. \\<not> canceled x \\<Longrightarrow> False", "hence \"cancels_to_1 ((a#xs1) @ x1 # x2 # xs2) ( (a#xs1) @ xs2)\""], ["proof (prove)\nusing this:\n  x = xs1 @ x1 # x2 # xs2\n  canceling x1 x2\n\ngoal (1 subgoal):\n 1. cancels_to_1 ((a # xs1) @ x1 # x2 # xs2) ((a # xs1) @ xs2)", "by (auto intro:cancels_to_1_fold simp del:append_Cons)"], ["proof (state)\nthis:\n  cancels_to_1 ((a # xs1) @ x1 # x2 # xs2) ((a # xs1) @ xs2)\n\ngoal (1 subgoal):\n 1. \\<not> canceled x \\<Longrightarrow> False", "with x"], ["proof (chain)\npicking this:\n  x = xs1 @ x1 # x2 # xs2\n  cancels_to_1 ((a # xs1) @ x1 # x2 # xs2) ((a # xs1) @ xs2)", "have \"cancels_to_1 (a#x) (a#xs1 @ xs2)\""], ["proof (prove)\nusing this:\n  x = xs1 @ x1 # x2 # xs2\n  cancels_to_1 ((a # xs1) @ x1 # x2 # xs2) ((a # xs1) @ xs2)\n\ngoal (1 subgoal):\n 1. cancels_to_1 (a # x) (a # xs1 @ xs2)", "by simp"], ["proof (state)\nthis:\n  cancels_to_1 (a # x) (a # xs1 @ xs2)\n\ngoal (1 subgoal):\n 1. \\<not> canceled x \\<Longrightarrow> False", "hence \"\\<not> canceled (a#x)\""], ["proof (prove)\nusing this:\n  cancels_to_1 (a # x) (a # xs1 @ xs2)\n\ngoal (1 subgoal):\n 1. \\<not> canceled (a # x)", "by (auto simp add:canceled_def)"], ["proof (state)\nthis:\n  \\<not> canceled (a # x)\n\ngoal (1 subgoal):\n 1. \\<not> canceled x \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<not> canceled (a # x)\n\ngoal (1 subgoal):\n 1. False", "using \\<open>canceled (a#x)\\<close>"], ["proof (prove)\nusing this:\n  \\<not> canceled (a # x)\n  canceled (a # x)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cancels_to_self[simp]: \"cancels_to l l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cancels_to l l", "by (simp add:cancels_to_def)"], ["", "subsection \\<open>Definition of normalization\\<close>"], ["", "text \\<open>\nUsing the THE construct, we can define the normalization function\n\\<open>normalize\\<close> as the unique fully cancled word that the argument cancels\nto.\n\\<close>"], ["", "definition normalize :: \"'a word_g_i \\<Rightarrow> 'a word_g_i\"\nwhere \"normalize l = (THE l'. cancels_to l l' \\<and> canceled l')\""], ["", "text \\<open>\nSome obvious properties of the normalize function, and other useful lemmas.\n\\<close>"], ["", "lemma\n  shows normalized_canceled[simp]: \"canceled (normalize l)\"\n  and   normalized_cancels_to[simp]: \"cancels_to l (normalize l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canceled (Cancelation.normalize l) &&&\n    cancels_to l (Cancelation.normalize l)", "proof-"], ["proof (state)\ngoal (2 subgoals):\n 1. canceled (Cancelation.normalize l)\n 2. cancels_to l (Cancelation.normalize l)", "let ?Q = \"{l'. cancels_to_1^** l l'}\""], ["proof (state)\ngoal (2 subgoals):\n 1. canceled (Cancelation.normalize l)\n 2. cancels_to l (Cancelation.normalize l)", "have \"l \\<in> ?Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> {l'. cancels_to_1\\<^sup>*\\<^sup>* l l'}", "by (auto)"], ["proof (state)\nthis:\n  l \\<in> {l'. cancels_to_1\\<^sup>*\\<^sup>* l l'}\n\ngoal (2 subgoals):\n 1. canceled (Cancelation.normalize l)\n 2. cancels_to l (Cancelation.normalize l)", "hence \"\\<exists>x. x \\<in> ?Q\""], ["proof (prove)\nusing this:\n  l \\<in> {l'. cancels_to_1\\<^sup>*\\<^sup>* l l'}\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {l'. cancels_to_1\\<^sup>*\\<^sup>* l l'}", "by (rule exI)"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> {l'. cancels_to_1\\<^sup>*\\<^sup>* l l'}\n\ngoal (2 subgoals):\n 1. canceled (Cancelation.normalize l)\n 2. cancels_to l (Cancelation.normalize l)", "have \"wfP cancels_to_1^--1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP cancels_to_1\\<inverse>\\<inverse>", "by (rule canceling_terminates)"], ["proof (state)\nthis:\n  wfP cancels_to_1\\<inverse>\\<inverse>\n\ngoal (2 subgoals):\n 1. canceled (Cancelation.normalize l)\n 2. cancels_to l (Cancelation.normalize l)", "hence \"\\<forall>Q. (\\<exists>x. x \\<in> Q) \\<longrightarrow> (\\<exists>z\\<in>Q. \\<forall>y. cancels_to_1 z y \\<longrightarrow> y \\<notin> Q)\""], ["proof (prove)\nusing this:\n  wfP cancels_to_1\\<inverse>\\<inverse>\n\ngoal (1 subgoal):\n 1. \\<forall>Q.\n       (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n       (\\<exists>z\\<in>Q.\n           \\<forall>y. cancels_to_1 z y \\<longrightarrow> y \\<notin> Q)", "by (simp add:wfP_eq_minimal)"], ["proof (state)\nthis:\n  \\<forall>Q.\n     (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y. cancels_to_1 z y \\<longrightarrow> y \\<notin> Q)\n\ngoal (2 subgoals):\n 1. canceled (Cancelation.normalize l)\n 2. cancels_to l (Cancelation.normalize l)", "hence \"(\\<exists>x. x \\<in> ?Q) \\<longrightarrow> (\\<exists>z\\<in>?Q. \\<forall>y. cancels_to_1 z y \\<longrightarrow> y \\<notin> ?Q)\""], ["proof (prove)\nusing this:\n  \\<forall>Q.\n     (\\<exists>x. x \\<in> Q) \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y. cancels_to_1 z y \\<longrightarrow> y \\<notin> Q)\n\ngoal (1 subgoal):\n 1. (\\<exists>x.\n        x \\<in> {l'. cancels_to_1\\<^sup>*\\<^sup>* l l'}) \\<longrightarrow>\n    (\\<exists>z\\<in>{l'. cancels_to_1\\<^sup>*\\<^sup>* l l'}.\n        \\<forall>y.\n           cancels_to_1 z y \\<longrightarrow>\n           y \\<notin> {l'. cancels_to_1\\<^sup>*\\<^sup>* l l'})", "by (erule_tac x=\"?Q\" in allE)"], ["proof (state)\nthis:\n  (\\<exists>x.\n      x \\<in> {l'. cancels_to_1\\<^sup>*\\<^sup>* l l'}) \\<longrightarrow>\n  (\\<exists>z\\<in>{l'. cancels_to_1\\<^sup>*\\<^sup>* l l'}.\n      \\<forall>y.\n         cancels_to_1 z y \\<longrightarrow>\n         y \\<notin> {l'. cancels_to_1\\<^sup>*\\<^sup>* l l'})\n\ngoal (2 subgoals):\n 1. canceled (Cancelation.normalize l)\n 2. cancels_to l (Cancelation.normalize l)", "then"], ["proof (chain)\npicking this:\n  (\\<exists>x.\n      x \\<in> {l'. cancels_to_1\\<^sup>*\\<^sup>* l l'}) \\<longrightarrow>\n  (\\<exists>z\\<in>{l'. cancels_to_1\\<^sup>*\\<^sup>* l l'}.\n      \\<forall>y.\n         cancels_to_1 z y \\<longrightarrow>\n         y \\<notin> {l'. cancels_to_1\\<^sup>*\\<^sup>* l l'})", "obtain l' where \"l' \\<in> ?Q\" and minimal: \"\\<And>y. cancels_to_1 l' y \\<Longrightarrow> y \\<notin> ?Q\""], ["proof (prove)\nusing this:\n  (\\<exists>x.\n      x \\<in> {l'. cancels_to_1\\<^sup>*\\<^sup>* l l'}) \\<longrightarrow>\n  (\\<exists>z\\<in>{l'. cancels_to_1\\<^sup>*\\<^sup>* l l'}.\n      \\<forall>y.\n         cancels_to_1 z y \\<longrightarrow>\n         y \\<notin> {l'. cancels_to_1\\<^sup>*\\<^sup>* l l'})\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        \\<lbrakk>l' \\<in> {l'. cancels_to_1\\<^sup>*\\<^sup>* l l'};\n         \\<And>y.\n            cancels_to_1 l' y \\<Longrightarrow>\n            y \\<notin> {l'. cancels_to_1\\<^sup>*\\<^sup>* l l'}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l' \\<in> {l'. cancels_to_1\\<^sup>*\\<^sup>* l l'}\n  cancels_to_1 l' ?y2 \\<Longrightarrow>\n  ?y2 \\<notin> {l'. cancels_to_1\\<^sup>*\\<^sup>* l l'}\n\ngoal (2 subgoals):\n 1. canceled (Cancelation.normalize l)\n 2. cancels_to l (Cancelation.normalize l)", "from \\<open>l' \\<in> ?Q\\<close>"], ["proof (chain)\npicking this:\n  l' \\<in> {l'. cancels_to_1\\<^sup>*\\<^sup>* l l'}", "have \"cancels_to l l'\""], ["proof (prove)\nusing this:\n  l' \\<in> {l'. cancels_to_1\\<^sup>*\\<^sup>* l l'}\n\ngoal (1 subgoal):\n 1. cancels_to l l'", "by (auto simp add: cancels_to_def)"], ["proof (state)\nthis:\n  cancels_to l l'\n\ngoal (2 subgoals):\n 1. canceled (Cancelation.normalize l)\n 2. cancels_to l (Cancelation.normalize l)", "have \"canceled l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canceled l'", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> canceled l' \\<Longrightarrow> False", "assume \"\\<not> canceled l'\""], ["proof (state)\nthis:\n  \\<not> canceled l'\n\ngoal (1 subgoal):\n 1. \\<not> canceled l' \\<Longrightarrow> False", "hence \"Domainp cancels_to_1 l'\""], ["proof (prove)\nusing this:\n  \\<not> canceled l'\n\ngoal (1 subgoal):\n 1. Domainp cancels_to_1 l'", "by (simp add: canceled_def)"], ["proof (state)\nthis:\n  Domainp cancels_to_1 l'\n\ngoal (1 subgoal):\n 1. \\<not> canceled l' \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Domainp cancels_to_1 l'", "obtain y where \"cancels_to_1 l' y\""], ["proof (prove)\nusing this:\n  Domainp cancels_to_1 l'\n\ngoal (1 subgoal):\n 1. (\\<And>y. cancels_to_1 l' y \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  cancels_to_1 l' y\n\ngoal (1 subgoal):\n 1. \\<not> canceled l' \\<Longrightarrow> False", "with \\<open>cancels_to l l'\\<close>"], ["proof (chain)\npicking this:\n  cancels_to l l'\n  cancels_to_1 l' y", "have \"cancels_to l y\""], ["proof (prove)\nusing this:\n  cancels_to l l'\n  cancels_to_1 l' y\n\ngoal (1 subgoal):\n 1. cancels_to l y", "by (auto simp add: cancels_to_def)"], ["proof (state)\nthis:\n  cancels_to l y\n\ngoal (1 subgoal):\n 1. \\<not> canceled l' \\<Longrightarrow> False", "from \\<open>cancels_to_1 l' y\\<close>"], ["proof (chain)\npicking this:\n  cancels_to_1 l' y", "have \"y \\<notin> ?Q\""], ["proof (prove)\nusing this:\n  cancels_to_1 l' y\n\ngoal (1 subgoal):\n 1. y \\<notin> {l'. cancels_to_1\\<^sup>*\\<^sup>* l l'}", "by(rule minimal)"], ["proof (state)\nthis:\n  y \\<notin> {l'. cancels_to_1\\<^sup>*\\<^sup>* l l'}\n\ngoal (1 subgoal):\n 1. \\<not> canceled l' \\<Longrightarrow> False", "hence \"\\<not> cancels_to_1^** l y\""], ["proof (prove)\nusing this:\n  y \\<notin> {l'. cancels_to_1\\<^sup>*\\<^sup>* l l'}\n\ngoal (1 subgoal):\n 1. \\<not> cancels_to_1\\<^sup>*\\<^sup>* l y", "by auto"], ["proof (state)\nthis:\n  \\<not> cancels_to_1\\<^sup>*\\<^sup>* l y\n\ngoal (1 subgoal):\n 1. \\<not> canceled l' \\<Longrightarrow> False", "hence \"\\<not> cancels_to l y\""], ["proof (prove)\nusing this:\n  \\<not> cancels_to_1\\<^sup>*\\<^sup>* l y\n\ngoal (1 subgoal):\n 1. \\<not> cancels_to l y", "by (simp add: cancels_to_def)"], ["proof (state)\nthis:\n  \\<not> cancels_to l y\n\ngoal (1 subgoal):\n 1. \\<not> canceled l' \\<Longrightarrow> False", "with \\<open>cancels_to l y\\<close>"], ["proof (chain)\npicking this:\n  cancels_to l y\n  \\<not> cancels_to l y", "show False"], ["proof (prove)\nusing this:\n  cancels_to l y\n  \\<not> cancels_to l y\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  canceled l'\n\ngoal (2 subgoals):\n 1. canceled (Cancelation.normalize l)\n 2. cancels_to l (Cancelation.normalize l)", "from \\<open>cancels_to l l'\\<close> and \\<open>canceled l'\\<close>"], ["proof (chain)\npicking this:\n  cancels_to l l'\n  canceled l'", "have \"cancels_to l l' \\<and> canceled l'\""], ["proof (prove)\nusing this:\n  cancels_to l l'\n  canceled l'\n\ngoal (1 subgoal):\n 1. cancels_to l l' \\<and> canceled l'", "by simp"], ["proof (state)\nthis:\n  cancels_to l l' \\<and> canceled l'\n\ngoal (2 subgoals):\n 1. canceled (Cancelation.normalize l)\n 2. cancels_to l (Cancelation.normalize l)", "hence \"cancels_to l (normalize l) \\<and> canceled (normalize l)\""], ["proof (prove)\nusing this:\n  cancels_to l l' \\<and> canceled l'\n\ngoal (1 subgoal):\n 1. cancels_to l (Cancelation.normalize l) \\<and>\n    canceled (Cancelation.normalize l)", "unfolding normalize_def"], ["proof (prove)\nusing this:\n  cancels_to l l' \\<and> canceled l'\n\ngoal (1 subgoal):\n 1. cancels_to l (THE l'. cancels_to l l' \\<and> canceled l') \\<and>\n    canceled (THE l'. cancels_to l l' \\<and> canceled l')", "proof (rule theI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l'a.\n       cancels_to l l'a \\<and> canceled l'a \\<Longrightarrow> l'a = l'", "fix l'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l'a.\n       cancels_to l l'a \\<and> canceled l'a \\<Longrightarrow> l'a = l'", "assume \"cancels_to l l'a \\<and> canceled l'a\""], ["proof (state)\nthis:\n  cancels_to l l'a \\<and> canceled l'a\n\ngoal (1 subgoal):\n 1. \\<And>l'a.\n       cancels_to l l'a \\<and> canceled l'a \\<Longrightarrow> l'a = l'", "thus \"l'a = l'\""], ["proof (prove)\nusing this:\n  cancels_to l l'a \\<and> canceled l'a\n\ngoal (1 subgoal):\n 1. l'a = l'", "using \\<open>cancels_to l l' \\<and> canceled l'\\<close>"], ["proof (prove)\nusing this:\n  cancels_to l l'a \\<and> canceled l'a\n  cancels_to l l' \\<and> canceled l'\n\ngoal (1 subgoal):\n 1. l'a = l'", "by (auto elim:norm_form_uniq)"], ["proof (state)\nthis:\n  l'a = l'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cancels_to l (Cancelation.normalize l) \\<and>\n  canceled (Cancelation.normalize l)\n\ngoal (2 subgoals):\n 1. canceled (Cancelation.normalize l)\n 2. cancels_to l (Cancelation.normalize l)", "thus \"canceled (normalize l)\" and \"cancels_to l (normalize l)\""], ["proof (prove)\nusing this:\n  cancels_to l (Cancelation.normalize l) \\<and>\n  canceled (Cancelation.normalize l)\n\ngoal (1 subgoal):\n 1. canceled (Cancelation.normalize l) &&&\n    cancels_to l (Cancelation.normalize l)", "by auto"], ["proof (state)\nthis:\n  canceled (Cancelation.normalize l)\n  cancels_to l (Cancelation.normalize l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma normalize_discover:\n  assumes \"canceled l'\"\n      and \"cancels_to l l'\"\n  shows \"normalize l = l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cancelation.normalize l = l'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Cancelation.normalize l = l'", "from \\<open>canceled l'\\<close> and \\<open>cancels_to l l'\\<close>"], ["proof (chain)\npicking this:\n  canceled l'\n  cancels_to l l'", "have \"cancels_to l l' \\<and> canceled l'\""], ["proof (prove)\nusing this:\n  canceled l'\n  cancels_to l l'\n\ngoal (1 subgoal):\n 1. cancels_to l l' \\<and> canceled l'", "by auto"], ["proof (state)\nthis:\n  cancels_to l l' \\<and> canceled l'\n\ngoal (1 subgoal):\n 1. Cancelation.normalize l = l'", "thus ?thesis"], ["proof (prove)\nusing this:\n  cancels_to l l' \\<and> canceled l'\n\ngoal (1 subgoal):\n 1. Cancelation.normalize l = l'", "unfolding normalize_def"], ["proof (prove)\nusing this:\n  cancels_to l l' \\<and> canceled l'\n\ngoal (1 subgoal):\n 1. (THE l'. cancels_to l l' \\<and> canceled l') = l'", "by (auto elim:norm_form_uniq)"], ["proof (state)\nthis:\n  Cancelation.normalize l = l'\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Words, related by cancelation, have the same normal form.\\<close>"], ["", "lemma normalize_canceled[simp]:\n  assumes \"cancels_to l l'\"\n  shows   \"normalize l = normalize l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cancelation.normalize l = Cancelation.normalize l'", "proof(rule normalize_discover)"], ["proof (state)\ngoal (2 subgoals):\n 1. canceled (Cancelation.normalize l')\n 2. cancels_to l (Cancelation.normalize l')", "show \"canceled (normalize l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canceled (Cancelation.normalize l')", "by (rule normalized_canceled)"], ["proof (state)\nthis:\n  canceled (Cancelation.normalize l')\n\ngoal (1 subgoal):\n 1. cancels_to l (Cancelation.normalize l')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cancels_to l (Cancelation.normalize l')", "have \"cancels_to l' (normalize l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cancels_to l' (Cancelation.normalize l')", "by (rule normalized_cancels_to)"], ["proof (state)\nthis:\n  cancels_to l' (Cancelation.normalize l')\n\ngoal (1 subgoal):\n 1. cancels_to l (Cancelation.normalize l')", "with \\<open>cancels_to l l'\\<close>"], ["proof (chain)\npicking this:\n  cancels_to l l'\n  cancels_to l' (Cancelation.normalize l')", "show \"cancels_to l (normalize l')\""], ["proof (prove)\nusing this:\n  cancels_to l l'\n  cancels_to l' (Cancelation.normalize l')\n\ngoal (1 subgoal):\n 1. cancels_to l (Cancelation.normalize l')", "by (rule cancels_to_trans)"], ["proof (state)\nthis:\n  cancels_to l (Cancelation.normalize l')\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Normalization is idempotent.\\<close>"], ["", "lemma normalize_idemp[simp]:\n  assumes \"canceled l\"\n  shows \"normalize l = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cancelation.normalize l = l", "using assms"], ["proof (prove)\nusing this:\n  canceled l\n\ngoal (1 subgoal):\n 1. Cancelation.normalize l = l", "by(rule normalize_discover)(rule cancels_to_self)"], ["", "text \\<open>\nThis lemma lifts the distributivity results from above to the normalize\nfunction.\n\\<close>"], ["", "lemma normalize_append_cancel_to:\n  assumes \"cancels_to l1 l1'\"\n  and     \"cancels_to l2 l2'\"\n  shows \"normalize (l1 @ l2) = normalize (l1' @ l2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cancelation.normalize (l1 @ l2) = Cancelation.normalize (l1' @ l2')", "proof(rule normalize_discover)"], ["proof (state)\ngoal (2 subgoals):\n 1. canceled (Cancelation.normalize (l1' @ l2'))\n 2. cancels_to (l1 @ l2) (Cancelation.normalize (l1' @ l2'))", "show \"canceled (normalize (l1' @ l2'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canceled (Cancelation.normalize (l1' @ l2'))", "by (rule normalized_canceled)"], ["proof (state)\nthis:\n  canceled (Cancelation.normalize (l1' @ l2'))\n\ngoal (1 subgoal):\n 1. cancels_to (l1 @ l2) (Cancelation.normalize (l1' @ l2'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cancels_to (l1 @ l2) (Cancelation.normalize (l1' @ l2'))", "from \\<open>cancels_to l1 l1'\\<close> and \\<open>cancels_to l2 l2'\\<close>"], ["proof (chain)\npicking this:\n  cancels_to l1 l1'\n  cancels_to l2 l2'", "have \"cancels_to (l1 @ l2) (l1' @ l2')\""], ["proof (prove)\nusing this:\n  cancels_to l1 l1'\n  cancels_to l2 l2'\n\ngoal (1 subgoal):\n 1. cancels_to (l1 @ l2) (l1' @ l2')", "by (rule cancels_to_append2)"], ["proof (state)\nthis:\n  cancels_to (l1 @ l2) (l1' @ l2')\n\ngoal (1 subgoal):\n 1. cancels_to (l1 @ l2) (Cancelation.normalize (l1' @ l2'))", "also"], ["proof (state)\nthis:\n  cancels_to (l1 @ l2) (l1' @ l2')\n\ngoal (1 subgoal):\n 1. cancels_to (l1 @ l2) (Cancelation.normalize (l1' @ l2'))", "have \"cancels_to (l1' @ l2') (normalize (l1' @ l2'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cancels_to (l1' @ l2') (Cancelation.normalize (l1' @ l2'))", "by (rule normalized_cancels_to)"], ["proof (state)\nthis:\n  cancels_to (l1' @ l2') (Cancelation.normalize (l1' @ l2'))\n\ngoal (1 subgoal):\n 1. cancels_to (l1 @ l2) (Cancelation.normalize (l1' @ l2'))", "finally"], ["proof (chain)\npicking this:\n  cancels_to (l1 @ l2) (Cancelation.normalize (l1' @ l2'))", "show \"cancels_to (l1 @ l2) (normalize (l1' @ l2'))\""], ["proof (prove)\nusing this:\n  cancels_to (l1 @ l2) (Cancelation.normalize (l1' @ l2'))\n\ngoal (1 subgoal):\n 1. cancels_to (l1 @ l2) (Cancelation.normalize (l1' @ l2'))", "."], ["proof (state)\nthis:\n  cancels_to (l1 @ l2) (Cancelation.normalize (l1' @ l2'))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Normalization preserves generators\\<close>"], ["", "text \\<open>\nSomewhat obvious, but still required to formalize Free Groups, is the fact that\ncanceling a word of generators of a specific set (and their inverses) results\nin a word in generators from that set.\n\\<close>"], ["", "lemma cancels_to_1_preserves_generators:\n  assumes \"cancels_to_1 l l'\"\n      and \"l \\<in> lists (UNIV \\<times> gens)\"\n  shows \"l' \\<in> lists (UNIV \\<times> gens)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l' \\<in> lists (UNIV \\<times> gens)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. l' \\<in> lists (UNIV \\<times> gens)", "from assms"], ["proof (chain)\npicking this:\n  cancels_to_1 l l'\n  l \\<in> lists (UNIV \\<times> gens)", "obtain i where \"l' = cancel_at i l\""], ["proof (prove)\nusing this:\n  cancels_to_1 l l'\n  l \\<in> lists (UNIV \\<times> gens)\n\ngoal (1 subgoal):\n 1. (\\<And>i. l' = cancel_at i l \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding cancels_to_1_def and cancels_to_1_at_def"], ["proof (prove)\nusing this:\n  \\<exists>i\\<ge>0.\n     1 + i < length l \\<and>\n     canceling (l ! i) (l ! (1 + i)) \\<and> l' = cancel_at i l\n  l \\<in> lists (UNIV \\<times> gens)\n\ngoal (1 subgoal):\n 1. (\\<And>i. l' = cancel_at i l \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  l' = cancel_at i l\n\ngoal (1 subgoal):\n 1. l' \\<in> lists (UNIV \\<times> gens)", "hence \"l' = take i l @ drop (2 + i) l\""], ["proof (prove)\nusing this:\n  l' = cancel_at i l\n\ngoal (1 subgoal):\n 1. l' = take i l @ drop (2 + i) l", "unfolding cancel_at_def"], ["proof (prove)\nusing this:\n  l' = take i l @ drop (2 + i) l\n\ngoal (1 subgoal):\n 1. l' = take i l @ drop (2 + i) l", "."], ["proof (state)\nthis:\n  l' = take i l @ drop (2 + i) l\n\ngoal (1 subgoal):\n 1. l' \\<in> lists (UNIV \\<times> gens)", "hence \"set l' = set (take i l @ drop (2 + i) l)\""], ["proof (prove)\nusing this:\n  l' = take i l @ drop (2 + i) l\n\ngoal (1 subgoal):\n 1. set l' = set (take i l @ drop (2 + i) l)", "by simp"], ["proof (state)\nthis:\n  set l' = set (take i l @ drop (2 + i) l)\n\ngoal (1 subgoal):\n 1. l' \\<in> lists (UNIV \\<times> gens)", "moreover"], ["proof (state)\nthis:\n  set l' = set (take i l @ drop (2 + i) l)\n\ngoal (1 subgoal):\n 1. l' \\<in> lists (UNIV \\<times> gens)", "have \"\\<dots> = set (take i l @ drop (2 + i) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (take i l @ drop (2 + i) l) = set (take i l @ drop (2 + i) l)", "by auto"], ["proof (state)\nthis:\n  set (take i l @ drop (2 + i) l) = set (take i l @ drop (2 + i) l)\n\ngoal (1 subgoal):\n 1. l' \\<in> lists (UNIV \\<times> gens)", "moreover"], ["proof (state)\nthis:\n  set (take i l @ drop (2 + i) l) = set (take i l @ drop (2 + i) l)\n\ngoal (1 subgoal):\n 1. l' \\<in> lists (UNIV \\<times> gens)", "have \"\\<dots> \\<subseteq> set (take i l) \\<union> set (drop (2 + i) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (take i l @ drop (2 + i) l)\n    \\<subseteq> set (take i l) \\<union> set (drop (2 + i) l)", "by auto"], ["proof (state)\nthis:\n  set (take i l @ drop (2 + i) l)\n  \\<subseteq> set (take i l) \\<union> set (drop (2 + i) l)\n\ngoal (1 subgoal):\n 1. l' \\<in> lists (UNIV \\<times> gens)", "moreover"], ["proof (state)\nthis:\n  set (take i l @ drop (2 + i) l)\n  \\<subseteq> set (take i l) \\<union> set (drop (2 + i) l)\n\ngoal (1 subgoal):\n 1. l' \\<in> lists (UNIV \\<times> gens)", "have \"\\<dots> \\<subseteq> set l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (take i l) \\<union> set (drop (2 + i) l) \\<subseteq> set l", "by (auto dest: in_set_takeD in_set_dropD)"], ["proof (state)\nthis:\n  set (take i l) \\<union> set (drop (2 + i) l) \\<subseteq> set l\n\ngoal (1 subgoal):\n 1. l' \\<in> lists (UNIV \\<times> gens)", "ultimately"], ["proof (chain)\npicking this:\n  set l' = set (take i l @ drop (2 + i) l)\n  set (take i l @ drop (2 + i) l) = set (take i l @ drop (2 + i) l)\n  set (take i l @ drop (2 + i) l)\n  \\<subseteq> set (take i l) \\<union> set (drop (2 + i) l)\n  set (take i l) \\<union> set (drop (2 + i) l) \\<subseteq> set l", "have \"set l' \\<subseteq> set l\""], ["proof (prove)\nusing this:\n  set l' = set (take i l @ drop (2 + i) l)\n  set (take i l @ drop (2 + i) l) = set (take i l @ drop (2 + i) l)\n  set (take i l @ drop (2 + i) l)\n  \\<subseteq> set (take i l) \\<union> set (drop (2 + i) l)\n  set (take i l) \\<union> set (drop (2 + i) l) \\<subseteq> set l\n\ngoal (1 subgoal):\n 1. set l' \\<subseteq> set l", "by simp"], ["proof (state)\nthis:\n  set l' \\<subseteq> set l\n\ngoal (1 subgoal):\n 1. l' \\<in> lists (UNIV \\<times> gens)", "thus ?thesis"], ["proof (prove)\nusing this:\n  set l' \\<subseteq> set l\n\ngoal (1 subgoal):\n 1. l' \\<in> lists (UNIV \\<times> gens)", "using assms(2)"], ["proof (prove)\nusing this:\n  set l' \\<subseteq> set l\n  l \\<in> lists (UNIV \\<times> gens)\n\ngoal (1 subgoal):\n 1. l' \\<in> lists (UNIV \\<times> gens)", "by auto"], ["proof (state)\nthis:\n  l' \\<in> lists (UNIV \\<times> gens)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cancels_to_preserves_generators:\n  assumes \"cancels_to l l'\"\n      and \"l \\<in> lists (UNIV \\<times> gens)\"\n  shows \"l' \\<in> lists (UNIV \\<times> gens)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l' \\<in> lists (UNIV \\<times> gens)", "using assms"], ["proof (prove)\nusing this:\n  cancels_to l l'\n  l \\<in> lists (UNIV \\<times> gens)\n\ngoal (1 subgoal):\n 1. l' \\<in> lists (UNIV \\<times> gens)", "unfolding cancels_to_def"], ["proof (prove)\nusing this:\n  cancels_to_1\\<^sup>*\\<^sup>* l l'\n  l \\<in> lists (UNIV \\<times> gens)\n\ngoal (1 subgoal):\n 1. l' \\<in> lists (UNIV \\<times> gens)", "by (induct, auto dest:cancels_to_1_preserves_generators)"], ["", "lemma normalize_preserves_generators:\n  assumes \"l \\<in> lists (UNIV \\<times> gens)\"\n    shows \"normalize l \\<in> lists (UNIV \\<times> gens)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cancelation.normalize l \\<in> lists (UNIV \\<times> gens)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Cancelation.normalize l \\<in> lists (UNIV \\<times> gens)", "have \"cancels_to l (normalize l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cancels_to l (Cancelation.normalize l)", "by simp"], ["proof (state)\nthis:\n  cancels_to l (Cancelation.normalize l)\n\ngoal (1 subgoal):\n 1. Cancelation.normalize l \\<in> lists (UNIV \\<times> gens)", "thus ?thesis"], ["proof (prove)\nusing this:\n  cancels_to l (Cancelation.normalize l)\n\ngoal (1 subgoal):\n 1. Cancelation.normalize l \\<in> lists (UNIV \\<times> gens)", "using assms"], ["proof (prove)\nusing this:\n  cancels_to l (Cancelation.normalize l)\n  l \\<in> lists (UNIV \\<times> gens)\n\ngoal (1 subgoal):\n 1. Cancelation.normalize l \\<in> lists (UNIV \\<times> gens)", "by(rule cancels_to_preserves_generators)"], ["proof (state)\nthis:\n  Cancelation.normalize l \\<in> lists (UNIV \\<times> gens)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nTwo simplification lemmas about lists.\n\\<close>"], ["", "lemma empty_in_lists[simp]:\n  \"[] \\<in> lists A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [] \\<in> lists A", "by auto"], ["", "lemma lists_empty[simp]: \"lists {} = {[]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lists {} = {[]}", "by auto"], ["", "subsection \\<open>Normalization and renaming generators\\<close>"], ["", "text \\<open>\nRenaming the generators, i.e. mapping them through an injective function, commutes\nwith normalization. Similarly, replacing generators by their inverses and\nvica-versa commutes with normalization. Both operations are similar enough to be\nhandled at once here.\n\\<close>"], ["", "lemma rename_gens_cancel_at: \"cancel_at i (map f l) = map f (cancel_at i l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cancel_at i (map f l) = map f (cancel_at i l)", "unfolding \"cancel_at_def\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take i (map f l) @ drop (2 + i) (map f l) =\n    map f (take i l @ drop (2 + i) l)", "by (auto simp add:take_map drop_map)"], ["", "lemma rename_gens_cancels_to_1:\n  assumes \"inj f\"\n      and \"cancels_to_1 l l'\"\n    shows \"cancels_to_1 (map (map_prod f g) l) (map (map_prod f g) l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cancels_to_1 (map (map_prod f g) l) (map (map_prod f g) l')", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. cancels_to_1 (map (map_prod f g) l) (map (map_prod f g) l')", "from \\<open>cancels_to_1 l l'\\<close>"], ["proof (chain)\npicking this:\n  cancels_to_1 l l'", "obtain ls1 l1 l2 ls2\n    where \"l = ls1 @ l1 # l2 # ls2\"\n      and \"l' = ls1 @ ls2\"\n      and \"canceling l1 l2\""], ["proof (prove)\nusing this:\n  cancels_to_1 l l'\n\ngoal (1 subgoal):\n 1. (\\<And>ls1 l1 l2 ls2.\n        \\<lbrakk>l = ls1 @ l1 # l2 # ls2; l' = ls1 @ ls2;\n         canceling l1 l2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (rule cancels_to_1_unfold)"], ["proof (state)\nthis:\n  l = ls1 @ l1 # l2 # ls2\n  l' = ls1 @ ls2\n  canceling l1 l2\n\ngoal (1 subgoal):\n 1. cancels_to_1 (map (map_prod f g) l) (map (map_prod f g) l')", "from \\<open>canceling l1 l2\\<close>"], ["proof (chain)\npicking this:\n  canceling l1 l2", "have \"fst l1 \\<noteq> fst l2\" and \"snd l1 = snd l2\""], ["proof (prove)\nusing this:\n  canceling l1 l2\n\ngoal (1 subgoal):\n 1. fst l1 \\<noteq> fst l2 &&& snd l1 = snd l2", "unfolding canceling_def"], ["proof (prove)\nusing this:\n  snd l1 = snd l2 \\<and> fst l1 \\<noteq> fst l2\n\ngoal (1 subgoal):\n 1. fst l1 \\<noteq> fst l2 &&& snd l1 = snd l2", "by auto"], ["proof (state)\nthis:\n  fst l1 \\<noteq> fst l2\n  snd l1 = snd l2\n\ngoal (1 subgoal):\n 1. cancels_to_1 (map (map_prod f g) l) (map (map_prod f g) l')", "from \\<open>fst l1 \\<noteq> fst l2\\<close> and \\<open>inj f\\<close>"], ["proof (chain)\npicking this:\n  fst l1 \\<noteq> fst l2\n  inj f", "have \"f (fst l1) \\<noteq> f (fst l2)\""], ["proof (prove)\nusing this:\n  fst l1 \\<noteq> fst l2\n  inj f\n\ngoal (1 subgoal):\n 1. f (fst l1) \\<noteq> f (fst l2)", "by(auto dest!:inj_on_contraD)"], ["proof (state)\nthis:\n  f (fst l1) \\<noteq> f (fst l2)\n\ngoal (1 subgoal):\n 1. cancels_to_1 (map (map_prod f g) l) (map (map_prod f g) l')", "hence \"fst (map_prod f g l1) \\<noteq> fst (map_prod f g l2)\""], ["proof (prove)\nusing this:\n  f (fst l1) \\<noteq> f (fst l2)\n\ngoal (1 subgoal):\n 1. fst (map_prod f g l1) \\<noteq> fst (map_prod f g l2)", "by auto"], ["proof (state)\nthis:\n  fst (map_prod f g l1) \\<noteq> fst (map_prod f g l2)\n\ngoal (1 subgoal):\n 1. cancels_to_1 (map (map_prod f g) l) (map (map_prod f g) l')", "moreover"], ["proof (state)\nthis:\n  fst (map_prod f g l1) \\<noteq> fst (map_prod f g l2)\n\ngoal (1 subgoal):\n 1. cancels_to_1 (map (map_prod f g) l) (map (map_prod f g) l')", "from \\<open>snd l1 = snd l2\\<close>"], ["proof (chain)\npicking this:\n  snd l1 = snd l2", "have \"snd (map_prod f g l1) = snd (map_prod f g l2)\""], ["proof (prove)\nusing this:\n  snd l1 = snd l2\n\ngoal (1 subgoal):\n 1. snd (map_prod f g l1) = snd (map_prod f g l2)", "by auto"], ["proof (state)\nthis:\n  snd (map_prod f g l1) = snd (map_prod f g l2)\n\ngoal (1 subgoal):\n 1. cancels_to_1 (map (map_prod f g) l) (map (map_prod f g) l')", "ultimately"], ["proof (chain)\npicking this:\n  fst (map_prod f g l1) \\<noteq> fst (map_prod f g l2)\n  snd (map_prod f g l1) = snd (map_prod f g l2)", "have \"canceling (map_prod f g (l1)) (map_prod f g (l2))\""], ["proof (prove)\nusing this:\n  fst (map_prod f g l1) \\<noteq> fst (map_prod f g l2)\n  snd (map_prod f g l1) = snd (map_prod f g l2)\n\ngoal (1 subgoal):\n 1. canceling (map_prod f g l1) (map_prod f g l2)", "unfolding canceling_def"], ["proof (prove)\nusing this:\n  fst (map_prod f g l1) \\<noteq> fst (map_prod f g l2)\n  snd (map_prod f g l1) = snd (map_prod f g l2)\n\ngoal (1 subgoal):\n 1. snd (map_prod f g l1) = snd (map_prod f g l2) \\<and>\n    fst (map_prod f g l1) \\<noteq> fst (map_prod f g l2)", "by auto"], ["proof (state)\nthis:\n  canceling (map_prod f g l1) (map_prod f g l2)\n\ngoal (1 subgoal):\n 1. cancels_to_1 (map (map_prod f g) l) (map (map_prod f g) l')", "hence \"cancels_to_1 (map (map_prod f g) ls1 @ map_prod f g l1 # map_prod f g l2 # map (map_prod f g) ls2) (map (map_prod f g) ls1 @ map (map_prod f g) ls2)\""], ["proof (prove)\nusing this:\n  canceling (map_prod f g l1) (map_prod f g l2)\n\ngoal (1 subgoal):\n 1. cancels_to_1\n     (map (map_prod f g) ls1 @\n      map_prod f g l1 # map_prod f g l2 # map (map_prod f g) ls2)\n     (map (map_prod f g) ls1 @ map (map_prod f g) ls2)", "by(rule cancels_to_1_fold)"], ["proof (state)\nthis:\n  cancels_to_1\n   (map (map_prod f g) ls1 @\n    map_prod f g l1 # map_prod f g l2 # map (map_prod f g) ls2)\n   (map (map_prod f g) ls1 @ map (map_prod f g) ls2)\n\ngoal (1 subgoal):\n 1. cancels_to_1 (map (map_prod f g) l) (map (map_prod f g) l')", "with \\<open>l = ls1 @ l1 # l2 # ls2\\<close> and \\<open>l' = ls1 @ ls2\\<close>"], ["proof (chain)\npicking this:\n  l = ls1 @ l1 # l2 # ls2\n  l' = ls1 @ ls2\n  cancels_to_1\n   (map (map_prod f g) ls1 @\n    map_prod f g l1 # map_prod f g l2 # map (map_prod f g) ls2)\n   (map (map_prod f g) ls1 @ map (map_prod f g) ls2)", "show \"cancels_to_1 (map (map_prod f g) l) (map (map_prod f g) l')\""], ["proof (prove)\nusing this:\n  l = ls1 @ l1 # l2 # ls2\n  l' = ls1 @ ls2\n  cancels_to_1\n   (map (map_prod f g) ls1 @\n    map_prod f g l1 # map_prod f g l2 # map (map_prod f g) ls2)\n   (map (map_prod f g) ls1 @ map (map_prod f g) ls2)\n\ngoal (1 subgoal):\n 1. cancels_to_1 (map (map_prod f g) l) (map (map_prod f g) l')", "by simp"], ["proof (state)\nthis:\n  cancels_to_1 (map (map_prod f g) l) (map (map_prod f g) l')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rename_gens_cancels_to:\n  assumes \"inj f\"\n      and \"cancels_to l l'\"\n    shows \"cancels_to (map (map_prod f g) l) (map (map_prod f g) l')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cancels_to (map (map_prod f g) l) (map (map_prod f g) l')", "using \\<open>cancels_to l l'\\<close>"], ["proof (prove)\nusing this:\n  cancels_to l l'\n\ngoal (1 subgoal):\n 1. cancels_to (map (map_prod f g) l) (map (map_prod f g) l')", "unfolding cancels_to_def"], ["proof (prove)\nusing this:\n  cancels_to_1\\<^sup>*\\<^sup>* l l'\n\ngoal (1 subgoal):\n 1. cancels_to_1\\<^sup>*\\<^sup>* (map (map_prod f g) l)\n     (map (map_prod f g) l')", "proof(induct rule:rtranclp_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. cancels_to_1\\<^sup>*\\<^sup>* (map (map_prod f g) l)\n     (map (map_prod f g) l)\n 2. \\<And>y z.\n       \\<lbrakk>cancels_to_1\\<^sup>*\\<^sup>* l y; cancels_to_1 y z;\n        cancels_to_1\\<^sup>*\\<^sup>* (map (map_prod f g) l)\n         (map (map_prod f g) y)\\<rbrakk>\n       \\<Longrightarrow> cancels_to_1\\<^sup>*\\<^sup>* (map (map_prod f g) l)\n                          (map (map_prod f g) z)", "case (step x z)"], ["proof (state)\nthis:\n  cancels_to_1\\<^sup>*\\<^sup>* l x\n  cancels_to_1 x z\n  cancels_to_1\\<^sup>*\\<^sup>* (map (map_prod f g) l) (map (map_prod f g) x)\n\ngoal (2 subgoals):\n 1. cancels_to_1\\<^sup>*\\<^sup>* (map (map_prod f g) l)\n     (map (map_prod f g) l)\n 2. \\<And>y z.\n       \\<lbrakk>cancels_to_1\\<^sup>*\\<^sup>* l y; cancels_to_1 y z;\n        cancels_to_1\\<^sup>*\\<^sup>* (map (map_prod f g) l)\n         (map (map_prod f g) y)\\<rbrakk>\n       \\<Longrightarrow> cancels_to_1\\<^sup>*\\<^sup>* (map (map_prod f g) l)\n                          (map (map_prod f g) z)", "from \\<open>cancels_to_1 x z\\<close> and \\<open>inj f\\<close>"], ["proof (chain)\npicking this:\n  cancels_to_1 x z\n  inj f", "have \"cancels_to_1 (map (map_prod f g) x) (map (map_prod f g) z)\""], ["proof (prove)\nusing this:\n  cancels_to_1 x z\n  inj f\n\ngoal (1 subgoal):\n 1. cancels_to_1 (map (map_prod f g) x) (map (map_prod f g) z)", "by -(rule rename_gens_cancels_to_1)"], ["proof (state)\nthis:\n  cancels_to_1 (map (map_prod f g) x) (map (map_prod f g) z)\n\ngoal (2 subgoals):\n 1. cancels_to_1\\<^sup>*\\<^sup>* (map (map_prod f g) l)\n     (map (map_prod f g) l)\n 2. \\<And>y z.\n       \\<lbrakk>cancels_to_1\\<^sup>*\\<^sup>* l y; cancels_to_1 y z;\n        cancels_to_1\\<^sup>*\\<^sup>* (map (map_prod f g) l)\n         (map (map_prod f g) y)\\<rbrakk>\n       \\<Longrightarrow> cancels_to_1\\<^sup>*\\<^sup>* (map (map_prod f g) l)\n                          (map (map_prod f g) z)", "with \\<open>cancels_to_1^** (map (map_prod f g) l) (map (map_prod f g) x)\\<close>"], ["proof (chain)\npicking this:\n  cancels_to_1\\<^sup>*\\<^sup>* (map (map_prod f g) l) (map (map_prod f g) x)\n  cancels_to_1 (map (map_prod f g) x) (map (map_prod f g) z)", "show \"cancels_to_1^** (map (map_prod f g) l) (map (map_prod f g) z)\""], ["proof (prove)\nusing this:\n  cancels_to_1\\<^sup>*\\<^sup>* (map (map_prod f g) l) (map (map_prod f g) x)\n  cancels_to_1 (map (map_prod f g) x) (map (map_prod f g) z)\n\ngoal (1 subgoal):\n 1. cancels_to_1\\<^sup>*\\<^sup>* (map (map_prod f g) l)\n     (map (map_prod f g) z)", "by auto"], ["proof (state)\nthis:\n  cancels_to_1\\<^sup>*\\<^sup>* (map (map_prod f g) l) (map (map_prod f g) z)\n\ngoal (1 subgoal):\n 1. cancels_to_1\\<^sup>*\\<^sup>* (map (map_prod f g) l)\n     (map (map_prod f g) l)", "qed(auto)"], ["", "lemma rename_gens_canceled:\n  assumes \"inj_on g (snd`set l)\"\n      and \"canceled l\"\n  shows \"canceled (map (map_prod f g) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. canceled (map (map_prod f g) l)", "unfolding canceled_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Domainp cancels_to_1 (map (map_prod f g) l)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Domainp cancels_to_1 (map (map_prod f g) l) \\<Longrightarrow> False", "(* This statement is needed explicitly later in this proof *)"], ["proof (state)\ngoal (1 subgoal):\n 1. Domainp cancels_to_1 (map (map_prod f g) l) \\<Longrightarrow> False", "have different_images: \"\\<And> f a b. f a \\<noteq> f b \\<Longrightarrow> a \\<noteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f a b. f a \\<noteq> f b \\<Longrightarrow> a \\<noteq> b", "by auto"], ["proof (state)\nthis:\n  ?f ?a \\<noteq> ?f ?b \\<Longrightarrow> ?a \\<noteq> ?b\n\ngoal (1 subgoal):\n 1. Domainp cancels_to_1 (map (map_prod f g) l) \\<Longrightarrow> False", "assume \"Domainp cancels_to_1 (map (map_prod f g) l)\""], ["proof (state)\nthis:\n  Domainp cancels_to_1 (map (map_prod f g) l)\n\ngoal (1 subgoal):\n 1. Domainp cancels_to_1 (map (map_prod f g) l) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Domainp cancels_to_1 (map (map_prod f g) l)", "obtain l' where \"cancels_to_1 (map (map_prod f g) l) l'\""], ["proof (prove)\nusing this:\n  Domainp cancels_to_1 (map (map_prod f g) l)\n\ngoal (1 subgoal):\n 1. (\\<And>l'.\n        cancels_to_1 (map (map_prod f g) l) l' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  cancels_to_1 (map (map_prod f g) l) l'\n\ngoal (1 subgoal):\n 1. Domainp cancels_to_1 (map (map_prod f g) l) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  cancels_to_1 (map (map_prod f g) l) l'", "obtain i where \"Suc i < length l\"\n    and \"canceling (map (map_prod f g) l ! i) (map (map_prod f g) l ! Suc i)\""], ["proof (prove)\nusing this:\n  cancels_to_1 (map (map_prod f g) l) l'\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>Suc i < length l;\n         canceling (map (map_prod f g) l ! i)\n          (map (map_prod f g) l ! Suc i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add:cancels_to_1_def cancels_to_1_at_def)"], ["proof (state)\nthis:\n  Suc i < length l\n  canceling (map (map_prod f g) l ! i) (map (map_prod f g) l ! Suc i)\n\ngoal (1 subgoal):\n 1. Domainp cancels_to_1 (map (map_prod f g) l) \\<Longrightarrow> False", "hence \"f (fst (l ! i)) \\<noteq> f (fst (l ! Suc i))\"\n    and \"g (snd (l ! i)) = g (snd (l ! Suc i))\""], ["proof (prove)\nusing this:\n  Suc i < length l\n  canceling (map (map_prod f g) l ! i) (map (map_prod f g) l ! Suc i)\n\ngoal (1 subgoal):\n 1. f (fst (l ! i)) \\<noteq> f (fst (l ! Suc i)) &&&\n    g (snd (l ! i)) = g (snd (l ! Suc i))", "by(auto simp add:canceling_def)"], ["proof (state)\nthis:\n  f (fst (l ! i)) \\<noteq> f (fst (l ! Suc i))\n  g (snd (l ! i)) = g (snd (l ! Suc i))\n\ngoal (1 subgoal):\n 1. Domainp cancels_to_1 (map (map_prod f g) l) \\<Longrightarrow> False", "from \\<open>f (fst (l ! i)) \\<noteq> f (fst (l ! Suc i))\\<close>"], ["proof (chain)\npicking this:\n  f (fst (l ! i)) \\<noteq> f (fst (l ! Suc i))", "have \"fst (l ! i) \\<noteq> fst (l ! Suc i)\""], ["proof (prove)\nusing this:\n  f (fst (l ! i)) \\<noteq> f (fst (l ! Suc i))\n\ngoal (1 subgoal):\n 1. fst (l ! i) \\<noteq> fst (l ! Suc i)", "by -(erule different_images)"], ["proof (state)\nthis:\n  fst (l ! i) \\<noteq> fst (l ! Suc i)\n\ngoal (1 subgoal):\n 1. Domainp cancels_to_1 (map (map_prod f g) l) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  fst (l ! i) \\<noteq> fst (l ! Suc i)\n\ngoal (1 subgoal):\n 1. Domainp cancels_to_1 (map (map_prod f g) l) \\<Longrightarrow> False", "from \\<open>Suc i < length l\\<close>"], ["proof (chain)\npicking this:\n  Suc i < length l", "have \"snd (l ! i) \\<in> snd ` set l\" and \"snd (l ! Suc i) \\<in> snd ` set l\""], ["proof (prove)\nusing this:\n  Suc i < length l\n\ngoal (1 subgoal):\n 1. snd (l ! i) \\<in> snd ` set l &&& snd (l ! Suc i) \\<in> snd ` set l", "by auto"], ["proof (state)\nthis:\n  snd (l ! i) \\<in> snd ` set l\n  snd (l ! Suc i) \\<in> snd ` set l\n\ngoal (1 subgoal):\n 1. Domainp cancels_to_1 (map (map_prod f g) l) \\<Longrightarrow> False", "with \\<open>g (snd (l ! i)) = g (snd (l ! Suc i))\\<close>"], ["proof (chain)\npicking this:\n  g (snd (l ! i)) = g (snd (l ! Suc i))\n  snd (l ! i) \\<in> snd ` set l\n  snd (l ! Suc i) \\<in> snd ` set l", "have \"snd (l ! i) = snd (l ! Suc i)\""], ["proof (prove)\nusing this:\n  g (snd (l ! i)) = g (snd (l ! Suc i))\n  snd (l ! i) \\<in> snd ` set l\n  snd (l ! Suc i) \\<in> snd ` set l\n\ngoal (1 subgoal):\n 1. snd (l ! i) = snd (l ! Suc i)", "using \\<open>inj_on g (image snd (set l))\\<close>"], ["proof (prove)\nusing this:\n  g (snd (l ! i)) = g (snd (l ! Suc i))\n  snd (l ! i) \\<in> snd ` set l\n  snd (l ! Suc i) \\<in> snd ` set l\n  inj_on g (snd ` set l)\n\ngoal (1 subgoal):\n 1. snd (l ! i) = snd (l ! Suc i)", "by (auto dest: inj_onD)"], ["proof (state)\nthis:\n  snd (l ! i) = snd (l ! Suc i)\n\ngoal (1 subgoal):\n 1. Domainp cancels_to_1 (map (map_prod f g) l) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  fst (l ! i) \\<noteq> fst (l ! Suc i)\n  snd (l ! i) = snd (l ! Suc i)", "have \"canceling (l ! i) (l ! Suc i)\""], ["proof (prove)\nusing this:\n  fst (l ! i) \\<noteq> fst (l ! Suc i)\n  snd (l ! i) = snd (l ! Suc i)\n\ngoal (1 subgoal):\n 1. canceling (l ! i) (l ! Suc i)", "unfolding canceling_def"], ["proof (prove)\nusing this:\n  fst (l ! i) \\<noteq> fst (l ! Suc i)\n  snd (l ! i) = snd (l ! Suc i)\n\ngoal (1 subgoal):\n 1. snd (l ! i) = snd (l ! Suc i) \\<and>\n    fst (l ! i) \\<noteq> fst (l ! Suc i)", "by simp"], ["proof (state)\nthis:\n  canceling (l ! i) (l ! Suc i)\n\ngoal (1 subgoal):\n 1. Domainp cancels_to_1 (map (map_prod f g) l) \\<Longrightarrow> False", "with \\<open>Suc i < length l\\<close>"], ["proof (chain)\npicking this:\n  Suc i < length l\n  canceling (l ! i) (l ! Suc i)", "have \"cancels_to_1_at i l (cancel_at i l)\""], ["proof (prove)\nusing this:\n  Suc i < length l\n  canceling (l ! i) (l ! Suc i)\n\ngoal (1 subgoal):\n 1. cancels_to_1_at i l (cancel_at i l)", "unfolding cancels_to_1_at_def"], ["proof (prove)\nusing this:\n  Suc i < length l\n  canceling (l ! i) (l ! Suc i)\n\ngoal (1 subgoal):\n 1. 0 \\<le> i \\<and>\n    1 + i < length l \\<and>\n    canceling (l ! i) (l ! (1 + i)) \\<and> cancel_at i l = cancel_at i l", "by auto"], ["proof (state)\nthis:\n  cancels_to_1_at i l (cancel_at i l)\n\ngoal (1 subgoal):\n 1. Domainp cancels_to_1 (map (map_prod f g) l) \\<Longrightarrow> False", "hence \"cancels_to_1 l (cancel_at i l)\""], ["proof (prove)\nusing this:\n  cancels_to_1_at i l (cancel_at i l)\n\ngoal (1 subgoal):\n 1. cancels_to_1 l (cancel_at i l)", "unfolding cancels_to_1_def"], ["proof (prove)\nusing this:\n  cancels_to_1_at i l (cancel_at i l)\n\ngoal (1 subgoal):\n 1. \\<exists>ia. cancels_to_1_at ia l (cancel_at i l)", "by auto"], ["proof (state)\nthis:\n  cancels_to_1 l (cancel_at i l)\n\ngoal (1 subgoal):\n 1. Domainp cancels_to_1 (map (map_prod f g) l) \\<Longrightarrow> False", "hence \"\\<not>canceled l\""], ["proof (prove)\nusing this:\n  cancels_to_1 l (cancel_at i l)\n\ngoal (1 subgoal):\n 1. \\<not> canceled l", "unfolding canceled_def"], ["proof (prove)\nusing this:\n  cancels_to_1 l (cancel_at i l)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> Domainp cancels_to_1 l", "by auto"], ["proof (state)\nthis:\n  \\<not> canceled l\n\ngoal (1 subgoal):\n 1. Domainp cancels_to_1 (map (map_prod f g) l) \\<Longrightarrow> False", "with \\<open>canceled l\\<close>"], ["proof (chain)\npicking this:\n  canceled l\n  \\<not> canceled l", "show False"], ["proof (prove)\nusing this:\n  canceled l\n  \\<not> canceled l\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rename_gens_normalize:\n  assumes \"inj f\"\n  and \"inj_on g (snd ` set l)\"\n  shows \"normalize (map (map_prod f g) l) = map (map_prod f g) (normalize l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cancelation.normalize (map (map_prod f g) l) =\n    map (map_prod f g) (Cancelation.normalize l)", "proof(rule normalize_discover)"], ["proof (state)\ngoal (2 subgoals):\n 1. canceled (map (map_prod f g) (Cancelation.normalize l))\n 2. cancels_to (map (map_prod f g) l)\n     (map (map_prod f g) (Cancelation.normalize l))", "from \\<open>inj_on g (image snd (set l))\\<close>"], ["proof (chain)\npicking this:\n  inj_on g (snd ` set l)", "have \"inj_on g (image snd (set (normalize l)))\""], ["proof (prove)\nusing this:\n  inj_on g (snd ` set l)\n\ngoal (1 subgoal):\n 1. inj_on g (snd ` set (Cancelation.normalize l))", "proof (rule subset_inj_on)"], ["proof (state)\ngoal (1 subgoal):\n 1. snd ` set (Cancelation.normalize l) \\<subseteq> snd ` set l", "have UNIV_snd: \"\\<And>A. A \\<subseteq> UNIV \\<times> snd ` A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A. A \\<subseteq> UNIV \\<times> snd ` A", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A x. x \\<in> A \\<Longrightarrow> x \\<in> UNIV \\<times> snd ` A", "fix A and x::\"'c\\<times>'d\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A x. x \\<in> A \\<Longrightarrow> x \\<in> UNIV \\<times> snd ` A", "assume \"x\\<in>A\""], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. \\<And>A x. x \\<in> A \\<Longrightarrow> x \\<in> UNIV \\<times> snd ` A", "hence \"(fst x,snd x)\\<in> (UNIV \\<times> snd ` A)\""], ["proof (prove)\nusing this:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. (fst x, snd x) \\<in> UNIV \\<times> snd ` A", "by -(rule, auto)"], ["proof (state)\nthis:\n  (fst x, snd x) \\<in> UNIV \\<times> snd ` A\n\ngoal (1 subgoal):\n 1. \\<And>A x. x \\<in> A \\<Longrightarrow> x \\<in> UNIV \\<times> snd ` A", "thus \"x\\<in> (UNIV \\<times> snd ` A)\""], ["proof (prove)\nusing this:\n  (fst x, snd x) \\<in> UNIV \\<times> snd ` A\n\ngoal (1 subgoal):\n 1. x \\<in> UNIV \\<times> snd ` A", "by simp"], ["proof (state)\nthis:\n  x \\<in> UNIV \\<times> snd ` A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?A \\<subseteq> UNIV \\<times> snd ` ?A\n\ngoal (1 subgoal):\n 1. snd ` set (Cancelation.normalize l) \\<subseteq> snd ` set l", "have \"l \\<in> lists (set l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> lists (set l)", "by auto"], ["proof (state)\nthis:\n  l \\<in> lists (set l)\n\ngoal (1 subgoal):\n 1. snd ` set (Cancelation.normalize l) \\<subseteq> snd ` set l", "hence \"l \\<in> lists (UNIV \\<times> snd ` set l)\""], ["proof (prove)\nusing this:\n  l \\<in> lists (set l)\n\ngoal (1 subgoal):\n 1. l \\<in> lists (UNIV \\<times> snd ` set l)", "by (rule subsetD[OF lists_mono[OF UNIV_snd], of l \"set l\"])"], ["proof (state)\nthis:\n  l \\<in> lists (UNIV \\<times> snd ` set l)\n\ngoal (1 subgoal):\n 1. snd ` set (Cancelation.normalize l) \\<subseteq> snd ` set l", "hence \"normalize l \\<in> lists (UNIV \\<times> snd ` set l)\""], ["proof (prove)\nusing this:\n  l \\<in> lists (UNIV \\<times> snd ` set l)\n\ngoal (1 subgoal):\n 1. Cancelation.normalize l \\<in> lists (UNIV \\<times> snd ` set l)", "by (rule normalize_preserves_generators[of _ \"snd ` set l\"])"], ["proof (state)\nthis:\n  Cancelation.normalize l \\<in> lists (UNIV \\<times> snd ` set l)\n\ngoal (1 subgoal):\n 1. snd ` set (Cancelation.normalize l) \\<subseteq> snd ` set l", "thus \"snd ` set (normalize l) \\<subseteq> snd ` set l\""], ["proof (prove)\nusing this:\n  Cancelation.normalize l \\<in> lists (UNIV \\<times> snd ` set l)\n\ngoal (1 subgoal):\n 1. snd ` set (Cancelation.normalize l) \\<subseteq> snd ` set l", "by (auto simp add: lists_eq_set)"], ["proof (state)\nthis:\n  snd ` set (Cancelation.normalize l) \\<subseteq> snd ` set l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on g (snd ` set (Cancelation.normalize l))\n\ngoal (2 subgoals):\n 1. canceled (map (map_prod f g) (Cancelation.normalize l))\n 2. cancels_to (map (map_prod f g) l)\n     (map (map_prod f g) (Cancelation.normalize l))", "thus \"canceled (map (map_prod f g) (normalize l))\""], ["proof (prove)\nusing this:\n  inj_on g (snd ` set (Cancelation.normalize l))\n\ngoal (1 subgoal):\n 1. canceled (map (map_prod f g) (Cancelation.normalize l))", "by(rule rename_gens_canceled,simp)"], ["proof (state)\nthis:\n  canceled (map (map_prod f g) (Cancelation.normalize l))\n\ngoal (1 subgoal):\n 1. cancels_to (map (map_prod f g) l)\n     (map (map_prod f g) (Cancelation.normalize l))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. cancels_to (map (map_prod f g) l)\n     (map (map_prod f g) (Cancelation.normalize l))", "from \\<open>inj f\\<close>"], ["proof (chain)\npicking this:\n  inj f", "show \"cancels_to (map (map_prod f g) l) (map (map_prod f g) (normalize l))\""], ["proof (prove)\nusing this:\n  inj f\n\ngoal (1 subgoal):\n 1. cancels_to (map (map_prod f g) l)\n     (map (map_prod f g) (Cancelation.normalize l))", "by (rule rename_gens_cancels_to, simp)"], ["proof (state)\nthis:\n  cancels_to (map (map_prod f g) l)\n   (map (map_prod f g) (Cancelation.normalize l))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}