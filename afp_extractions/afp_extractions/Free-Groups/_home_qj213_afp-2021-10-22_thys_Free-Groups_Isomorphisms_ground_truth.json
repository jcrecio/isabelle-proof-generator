{"file_name": "/home/qj213/afp-2021-10-22/thys/Free-Groups/Isomorphisms.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Free-Groups", "problem_names": ["lemma free_group_over_empty_set: \"\\<exists>h. h \\<in> iso \\<F>\\<^bsub>{}\\<^esub> unit_group\"", "lemma replicate_set_eq[simp]: \"\\<forall>x \\<in> set xs. x = y \\<Longrightarrow> xs = replicate (length xs) y\"", "lemma int_group_gen_by_one: \"\\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub> = carrier int_group\"", "lemma free_group_over_one_gen: \"\\<exists>h. h \\<in> iso \\<F>\\<^bsub>{()}\\<^esub> int_group\"", "theorem isomorphic_free_groups:\n  assumes \"bij_betw f gens1 gens2\"\n  shows \"lift_generator_function f \\<in> iso \\<F>\\<^bsub>gens1\\<^esub> \\<F>\\<^bsub>gens2\\<^esub>\"", "lemma (in group_hom) restrict_hom[intro!]:\n  shows \"restrict h (carrier G) \\<in> homr G H\"", "lemma hom_F_C2_Powerset:\n  \"\\<exists> f. bij_betw f (Pow X) (homr (\\<F>\\<^bsub>X\\<^esub>) C2)\"", "lemma group_iso_betw_hom:\n  assumes \"group G1\" and \"group G2\"\n      and iso: \"i \\<in> iso G1 G2\"\n  shows   \"\\<exists> f . bij_betw f (homr G2 H) (homr G1 H)\"", "lemma isomorphic_free_groups_bases_finite:\n  assumes iso: \"i \\<in> iso \\<F>\\<^bsub>X\\<^esub> \\<F>\\<^bsub>Y\\<^esub>\"\n      and finite: \"finite X\"\n  shows \"\\<exists>f. bij_betw f X Y\"", "lemma free_group_card_infinite:\n  assumes \"\\<not> finite X\"\n  shows \"|X| =o |carrier \\<F>\\<^bsub>X\\<^esub>|\"", "theorem isomorphic_free_groups_bases:\n  assumes iso: \"i \\<in> iso \\<F>\\<^bsub>X\\<^esub> \\<F>\\<^bsub>Y\\<^esub>\"\n  shows \"\\<exists>f. bij_betw f X Y\""], "translations": [["", "lemma free_group_over_empty_set: \"\\<exists>h. h \\<in> iso \\<F>\\<^bsub>{}\\<^esub> unit_group\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{}\\<^esub> unit_group", "proof(rule group.unit_group_unique)"], ["proof (state)\ngoal (2 subgoals):\n 1. Group.group \\<F>\\<^bsub>{}\\<^esub>\n 2. card (carrier \\<F>\\<^bsub>{}\\<^esub>) = 1", "show \"group \\<F>\\<^bsub>{}\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group \\<F>\\<^bsub>{}\\<^esub>", "by (rule free_group_is_group)"], ["proof (state)\nthis:\n  Group.group \\<F>\\<^bsub>{}\\<^esub>\n\ngoal (1 subgoal):\n 1. card (carrier \\<F>\\<^bsub>{}\\<^esub>) = 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. card (carrier \\<F>\\<^bsub>{}\\<^esub>) = 1", "have \"carrier \\<F>\\<^bsub>{}::'a set\\<^esub> = {[]}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier \\<F>\\<^bsub>{}\\<^esub> = {[]}", "by (auto simp add:free_group_def)"], ["proof (state)\nthis:\n  carrier \\<F>\\<^bsub>{}\\<^esub> = {[]}\n\ngoal (1 subgoal):\n 1. card (carrier \\<F>\\<^bsub>{}\\<^esub>) = 1", "thus \"card (carrier \\<F>\\<^bsub>{}::'a set\\<^esub>) = 1\""], ["proof (prove)\nusing this:\n  carrier \\<F>\\<^bsub>{}\\<^esub> = {[]}\n\ngoal (1 subgoal):\n 1. card (carrier \\<F>\\<^bsub>{}\\<^esub>) = 1", "by simp"], ["proof (state)\nthis:\n  card (carrier \\<F>\\<^bsub>{}\\<^esub>) = 1\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The Free Group over one generator\\<close>"], ["", "text \\<open>The Free Group over one generator is isomorphic to the free abelian group\nover one element, also known as the integers.\\<close>"], ["", "abbreviation \"int_group\"\n  where \"int_group \\<equiv> \\<lparr> carrier = carrier \\<Z>, monoid.mult = (+), one = 0::int \\<rparr>\""], ["", "lemma replicate_set_eq[simp]: \"\\<forall>x \\<in> set xs. x = y \\<Longrightarrow> xs = replicate (length xs) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set xs. x = y \\<Longrightarrow>\n    xs = replicate (length xs) y", "by(induct xs)auto"], ["", "lemma int_group_gen_by_one: \"\\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub> = carrier int_group\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub> = carrier int_group", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n    \\<subseteq> carrier int_group\n 2. carrier int_group\n    \\<subseteq> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "show \"\\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub> \\<subseteq> carrier int_group\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n    \\<subseteq> carrier int_group", "by auto"], ["proof (state)\nthis:\n  \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n  \\<subseteq> carrier int_group\n\ngoal (1 subgoal):\n 1. carrier int_group\n    \\<subseteq> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "show \"carrier int_group \\<subseteq> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier int_group\n    \\<subseteq> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier int_group \\<Longrightarrow>\n       x \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "interpret int: group int_group"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group int_group", "using int.a_group"], ["proof (prove)\nusing this:\n  Group.group\n   \\<lparr>carrier = UNIV, monoid.mult = (+), one = 0,\n      \\<dots> = undefined\\<rparr>\n\ngoal (1 subgoal):\n 1. Group.group int_group", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier int_group \\<Longrightarrow>\n       x \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier int_group \\<Longrightarrow>\n       x \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "have plus1: \"1 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "by (auto intro:gen_span.gen_gens)"], ["proof (state)\nthis:\n  1 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier int_group \\<Longrightarrow>\n       x \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "hence \"inv\\<^bsub>int_group\\<^esub> 1 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\""], ["proof (prove)\nusing this:\n  1 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n\ngoal (1 subgoal):\n 1. inv\\<^bsub>int_group\\<^esub> 1\n    \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "by (auto intro:gen_span.gen_inv)"], ["proof (state)\nthis:\n  inv\\<^bsub>int_group\\<^esub> 1\n  \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier int_group \\<Longrightarrow>\n       x \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "moreover"], ["proof (state)\nthis:\n  inv\\<^bsub>int_group\\<^esub> 1\n  \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier int_group \\<Longrightarrow>\n       x \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "have \"-1 = inv\\<^bsub>int_group\\<^esub> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - 1 = inv\\<^bsub>int_group\\<^esub> 1", "by (rule sym, rule int.inv_equality) simp_all"], ["proof (state)\nthis:\n  - 1 = inv\\<^bsub>int_group\\<^esub> 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier int_group \\<Longrightarrow>\n       x \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "ultimately"], ["proof (chain)\npicking this:\n  inv\\<^bsub>int_group\\<^esub> 1\n  \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n  - 1 = inv\\<^bsub>int_group\\<^esub> 1", "have minus1: \"-1 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\""], ["proof (prove)\nusing this:\n  inv\\<^bsub>int_group\\<^esub> 1\n  \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n  - 1 = inv\\<^bsub>int_group\\<^esub> 1\n\ngoal (1 subgoal):\n 1. - 1 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "by (simp)"], ["proof (state)\nthis:\n  - 1 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier int_group \\<Longrightarrow>\n       x \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "show \"x \\<in> \\<langle>{1::int}\\<rangle>\\<^bsub>int_group\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "(*\n    It does not work directly, unfortunately:\n    apply(induct x rule:int_induct[of _ \"0::int\"])\n    apply (auto simp add: int_arith_rules intro:gen_span.intros[of int_group])\n    *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "proof(induct x rule:int_induct[of _ \"0::int\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. 0 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n 2. \\<And>i.\n       \\<lbrakk>0 \\<le> i;\n        i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> i + 1\n                         \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n 3. \\<And>i.\n       \\<lbrakk>i \\<le> 0;\n        i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> i - 1\n                         \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "case base"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. 0 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n 2. \\<And>i.\n       \\<lbrakk>0 \\<le> i;\n        i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> i + 1\n                         \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n 3. \\<And>i.\n       \\<lbrakk>i \\<le> 0;\n        i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> i - 1\n                         \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "have \"\\<one>\\<^bsub>int_group\\<^esub> \\<in> \\<langle>{1::int}\\<rangle>\\<^bsub>int_group\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<one>\\<^bsub>int_group\\<^esub>\n    \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "by (rule gen_span.gen_one)"], ["proof (state)\nthis:\n  \\<one>\\<^bsub>int_group\\<^esub>\n  \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n\ngoal (3 subgoals):\n 1. 0 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n 2. \\<And>i.\n       \\<lbrakk>0 \\<le> i;\n        i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> i + 1\n                         \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n 3. \\<And>i.\n       \\<lbrakk>i \\<le> 0;\n        i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> i - 1\n                         \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "thus\"0 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<one>\\<^bsub>int_group\\<^esub>\n  \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n\ngoal (1 subgoal):\n 1. 0 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "by simp"], ["proof (state)\nthis:\n  0 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 \\<le> i;\n        i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> i + 1\n                         \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n 2. \\<And>i.\n       \\<lbrakk>i \\<le> 0;\n        i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> i - 1\n                         \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 \\<le> i;\n        i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> i + 1\n                         \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n 2. \\<And>i.\n       \\<lbrakk>i \\<le> 0;\n        i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> i - 1\n                         \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "case (step1 i)"], ["proof (state)\nthis:\n  0 \\<le> i\n  i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 \\<le> i;\n        i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> i + 1\n                         \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n 2. \\<And>i.\n       \\<lbrakk>i \\<le> 0;\n        i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> i - 1\n                         \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "from \\<open>i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\\<close> and plus1"], ["proof (chain)\npicking this:\n  i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n  1 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "have \"i \\<otimes>\\<^bsub>int_group\\<^esub> 1 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\""], ["proof (prove)\nusing this:\n  i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n  1 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n\ngoal (1 subgoal):\n 1. i \\<otimes>\\<^bsub>int_group\\<^esub> 1\n    \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "by (rule gen_span.gen_mult)"], ["proof (state)\nthis:\n  i \\<otimes>\\<^bsub>int_group\\<^esub> 1\n  \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>0 \\<le> i;\n        i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> i + 1\n                         \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n 2. \\<And>i.\n       \\<lbrakk>i \\<le> 0;\n        i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> i - 1\n                         \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "thus \"i + 1 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\""], ["proof (prove)\nusing this:\n  i \\<otimes>\\<^bsub>int_group\\<^esub> 1\n  \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n\ngoal (1 subgoal):\n 1. i + 1 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "by simp"], ["proof (state)\nthis:\n  i + 1 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> 0;\n        i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> i - 1\n                         \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> 0;\n        i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> i - 1\n                         \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "case (step2 i)"], ["proof (state)\nthis:\n  i \\<le> 0\n  i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> 0;\n        i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> i - 1\n                         \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "from \\<open>i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\\<close> and minus1"], ["proof (chain)\npicking this:\n  i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n  - 1 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "have \"i \\<otimes>\\<^bsub>int_group\\<^esub> -1 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\""], ["proof (prove)\nusing this:\n  i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n  - 1 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n\ngoal (1 subgoal):\n 1. i \\<otimes>\\<^bsub>int_group\\<^esub> - 1\n    \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "by (rule gen_span.gen_mult)"], ["proof (state)\nthis:\n  i \\<otimes>\\<^bsub>int_group\\<^esub> - 1\n  \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<le> 0;\n        i \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> i - 1\n                         \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "thus \"i - 1 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\""], ["proof (prove)\nusing this:\n  i \\<otimes>\\<^bsub>int_group\\<^esub> - 1\n  \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n\ngoal (1 subgoal):\n 1. i - 1 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "by simp"], ["proof (state)\nthis:\n  i - 1 \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  carrier int_group\n  \\<subseteq> \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma free_group_over_one_gen: \"\\<exists>h. h \\<in> iso \\<F>\\<^bsub>{()}\\<^esub> int_group\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "interpret int: group int_group"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group int_group", "using int.a_group"], ["proof (prove)\nusing this:\n  Group.group\n   \\<lparr>carrier = UNIV, monoid.mult = (+), one = 0,\n      \\<dots> = undefined\\<rparr>\n\ngoal (1 subgoal):\n 1. Group.group int_group", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "define f :: \"unit \\<Rightarrow> int\" where \"f x = 1\" for x"], ["proof (state)\nthis:\n  f ?x = 1\n\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "have \"f \\<in> {()} \\<rightarrow> carrier int_group\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> {()} \\<rightarrow> carrier int_group", "by auto"], ["proof (state)\nthis:\n  f \\<in> {()} \\<rightarrow> carrier int_group\n\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "hence \"int.lift f \\<in> hom \\<F>\\<^bsub>{()}\\<^esub> int_group\""], ["proof (prove)\nusing this:\n  f \\<in> {()} \\<rightarrow> carrier int_group\n\ngoal (1 subgoal):\n 1. int.lift f \\<in> hom \\<F>\\<^bsub>{()}\\<^esub> int_group", "by (rule int.lift_is_hom)"], ["proof (state)\nthis:\n  int.lift f \\<in> hom \\<F>\\<^bsub>{()}\\<^esub> int_group\n\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "then"], ["proof (chain)\npicking this:\n  int.lift f \\<in> hom \\<F>\\<^bsub>{()}\\<^esub> int_group", "interpret hom: group_hom \"\\<F>\\<^bsub>{()}\\<^esub>\" int_group \"int.lift f\""], ["proof (prove)\nusing this:\n  int.lift f \\<in> hom \\<F>\\<^bsub>{()}\\<^esub> int_group\n\ngoal (1 subgoal):\n 1. group_hom \\<F>\\<^bsub>{()}\\<^esub> int_group (int.lift f)", "unfolding group_hom_def group_hom_axioms_def"], ["proof (prove)\nusing this:\n  int.lift f \\<in> hom \\<F>\\<^bsub>{()}\\<^esub> int_group\n\ngoal (1 subgoal):\n 1. Group.group \\<F>\\<^bsub>{()}\\<^esub> \\<and>\n    Group.group int_group \\<and>\n    int.lift f \\<in> hom \\<F>\\<^bsub>{()}\\<^esub> int_group", "using int.a_group"], ["proof (prove)\nusing this:\n  int.lift f \\<in> hom \\<F>\\<^bsub>{()}\\<^esub> int_group\n  Group.group\n   \\<lparr>carrier = UNIV, monoid.mult = (+), one = 0,\n      \\<dots> = undefined\\<rparr>\n\ngoal (1 subgoal):\n 1. Group.group \\<F>\\<^bsub>{()}\\<^esub> \\<and>\n    Group.group int_group \\<and>\n    int.lift f \\<in> hom \\<F>\\<^bsub>{()}\\<^esub> int_group", "by(auto intro: free_group_is_group)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "(* This shows injectiveness of the given map *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "assume \"x \\<in> carrier \\<F>\\<^bsub>{()}\\<^esub>\""], ["proof (state)\nthis:\n  x \\<in> carrier \\<F>\\<^bsub>{()}\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "hence \"canceled x\""], ["proof (prove)\nusing this:\n  x \\<in> carrier \\<F>\\<^bsub>{()}\\<^esub>\n\ngoal (1 subgoal):\n 1. canceled x", "by (auto simp add:free_group_def)"], ["proof (state)\nthis:\n  canceled x\n\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "assume \"int.lift f x = (0::int)\""], ["proof (state)\nthis:\n  int.lift f x = 0\n\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "have \"x = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = []", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> False", "assume \"x \\<noteq> []\""], ["proof (state)\nthis:\n  x \\<noteq> []\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> []", "obtain a and xs where \"x = a # xs\""], ["proof (prove)\nusing this:\n  x \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>a xs. x = a # xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases x, auto)"], ["proof (state)\nthis:\n  x = a # xs\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> False", "hence \"length (takeWhile (\\<lambda>y. y = a) x) > 0\""], ["proof (prove)\nusing this:\n  x = a # xs\n\ngoal (1 subgoal):\n 1. 0 < length (takeWhile (\\<lambda>y. y = a) x)", "by auto"], ["proof (state)\nthis:\n  0 < length (takeWhile (\\<lambda>y. y = a) x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  0 < length (takeWhile (\\<lambda>y. y = a) x)", "obtain i where i: \"length (takeWhile (\\<lambda>y. y = a) x) = Suc i\""], ["proof (prove)\nusing this:\n  0 < length (takeWhile (\\<lambda>y. y = a) x)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        length (takeWhile (\\<lambda>y. y = a) x) = Suc i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"length (takeWhile (\\<lambda>y. y = a) x)\", auto)"], ["proof (state)\nthis:\n  length (takeWhile (\\<lambda>y. y = a) x) = Suc i\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> False", "have \"Suc i \\<ge> length x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length x \\<le> Suc i", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length x \\<le> Suc i \\<Longrightarrow> False", "assume \"\\<not> length x \\<le> Suc i\""], ["proof (state)\nthis:\n  \\<not> length x \\<le> Suc i\n\ngoal (1 subgoal):\n 1. \\<not> length x \\<le> Suc i \\<Longrightarrow> False", "hence \"length (takeWhile (\\<lambda>y. y = a) x) < length x\""], ["proof (prove)\nusing this:\n  \\<not> length x \\<le> Suc i\n\ngoal (1 subgoal):\n 1. length (takeWhile (\\<lambda>y. y = a) x) < length x", "using i"], ["proof (prove)\nusing this:\n  \\<not> length x \\<le> Suc i\n  length (takeWhile (\\<lambda>y. y = a) x) = Suc i\n\ngoal (1 subgoal):\n 1. length (takeWhile (\\<lambda>y. y = a) x) < length x", "by simp"], ["proof (state)\nthis:\n  length (takeWhile (\\<lambda>y. y = a) x) < length x\n\ngoal (1 subgoal):\n 1. \\<not> length x \\<le> Suc i \\<Longrightarrow> False", "hence \"\\<not> (\\<lambda>y. y = a) (x ! length (takeWhile (\\<lambda>y. y = a) x))\""], ["proof (prove)\nusing this:\n  length (takeWhile (\\<lambda>y. y = a) x) < length x\n\ngoal (1 subgoal):\n 1. x ! length (takeWhile (\\<lambda>y. y = a) x) \\<noteq> a", "by (rule nth_length_takeWhile)"], ["proof (state)\nthis:\n  x ! length (takeWhile (\\<lambda>y. y = a) x) \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<not> length x \\<le> Suc i \\<Longrightarrow> False", "hence \"\\<not> (\\<lambda>y. y = a) (x ! Suc i)\""], ["proof (prove)\nusing this:\n  x ! length (takeWhile (\\<lambda>y. y = a) x) \\<noteq> a\n\ngoal (1 subgoal):\n 1. x ! Suc i \\<noteq> a", "using i"], ["proof (prove)\nusing this:\n  x ! length (takeWhile (\\<lambda>y. y = a) x) \\<noteq> a\n  length (takeWhile (\\<lambda>y. y = a) x) = Suc i\n\ngoal (1 subgoal):\n 1. x ! Suc i \\<noteq> a", "by simp"], ["proof (state)\nthis:\n  x ! Suc i \\<noteq> a\n\ngoal (1 subgoal):\n 1. \\<not> length x \\<le> Suc i \\<Longrightarrow> False", "hence \"fst (x ! Suc i) \\<noteq> fst a\""], ["proof (prove)\nusing this:\n  x ! Suc i \\<noteq> a\n\ngoal (1 subgoal):\n 1. fst (x ! Suc i) \\<noteq> fst a", "by (cases \"x ! Suc i\", cases \"a\", auto)"], ["proof (state)\nthis:\n  fst (x ! Suc i) \\<noteq> fst a\n\ngoal (1 subgoal):\n 1. \\<not> length x \\<le> Suc i \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  fst (x ! Suc i) \\<noteq> fst a\n\ngoal (1 subgoal):\n 1. \\<not> length x \\<le> Suc i \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  fst (x ! Suc i) \\<noteq> fst a\n\ngoal (1 subgoal):\n 1. \\<not> length x \\<le> Suc i \\<Longrightarrow> False", "have \"takeWhile (\\<lambda>y. y = a) x ! i = x ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. takeWhile (\\<lambda>y. y = a) x ! i = x ! i", "using i"], ["proof (prove)\nusing this:\n  length (takeWhile (\\<lambda>y. y = a) x) = Suc i\n\ngoal (1 subgoal):\n 1. takeWhile (\\<lambda>y. y = a) x ! i = x ! i", "by (auto intro: takeWhile_nth)"], ["proof (state)\nthis:\n  takeWhile (\\<lambda>y. y = a) x ! i = x ! i\n\ngoal (1 subgoal):\n 1. \\<not> length x \\<le> Suc i \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  takeWhile (\\<lambda>y. y = a) x ! i = x ! i\n\ngoal (1 subgoal):\n 1. \\<not> length x \\<le> Suc i \\<Longrightarrow> False", "have \"(takeWhile (\\<lambda>y. y = a) x) ! i \\<in> set (takeWhile (\\<lambda>y. y = a) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. takeWhile (\\<lambda>y. y = a) x ! i\n    \\<in> set (takeWhile (\\<lambda>y. y = a) x)", "using i"], ["proof (prove)\nusing this:\n  length (takeWhile (\\<lambda>y. y = a) x) = Suc i\n\ngoal (1 subgoal):\n 1. takeWhile (\\<lambda>y. y = a) x ! i\n    \\<in> set (takeWhile (\\<lambda>y. y = a) x)", "by auto"], ["proof (state)\nthis:\n  takeWhile (\\<lambda>y. y = a) x ! i\n  \\<in> set (takeWhile (\\<lambda>y. y = a) x)\n\ngoal (1 subgoal):\n 1. \\<not> length x \\<le> Suc i \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  takeWhile (\\<lambda>y. y = a) x ! i = x ! i\n  takeWhile (\\<lambda>y. y = a) x ! i\n  \\<in> set (takeWhile (\\<lambda>y. y = a) x)", "have \"(\\<lambda>y. y = a) (x ! i)\""], ["proof (prove)\nusing this:\n  takeWhile (\\<lambda>y. y = a) x ! i = x ! i\n  takeWhile (\\<lambda>y. y = a) x ! i\n  \\<in> set (takeWhile (\\<lambda>y. y = a) x)\n\ngoal (1 subgoal):\n 1. x ! i = a", "by (auto dest:set_takeWhileD)"], ["proof (state)\nthis:\n  x ! i = a\n\ngoal (1 subgoal):\n 1. \\<not> length x \\<le> Suc i \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  x ! i = a\n\ngoal (1 subgoal):\n 1. \\<not> length x \\<le> Suc i \\<Longrightarrow> False", "hence \"fst (x ! i) = fst a\""], ["proof (prove)\nusing this:\n  x ! i = a\n\ngoal (1 subgoal):\n 1. fst (x ! i) = fst a", "by auto"], ["proof (state)\nthis:\n  fst (x ! i) = fst a\n\ngoal (1 subgoal):\n 1. \\<not> length x \\<le> Suc i \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  fst (x ! i) = fst a\n\ngoal (1 subgoal):\n 1. \\<not> length x \\<le> Suc i \\<Longrightarrow> False", "have \"snd (x ! i) = snd (x ! Suc i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (x ! i) = snd (x ! Suc i)", "by simp"], ["proof (state)\nthis:\n  snd (x ! i) = snd (x ! Suc i)\n\ngoal (1 subgoal):\n 1. \\<not> length x \\<le> Suc i \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  fst (x ! Suc i) \\<noteq> fst a\n  fst (x ! i) = fst a\n  snd (x ! i) = snd (x ! Suc i)", "have \"canceling (x ! i) (x ! Suc i)\""], ["proof (prove)\nusing this:\n  fst (x ! Suc i) \\<noteq> fst a\n  fst (x ! i) = fst a\n  snd (x ! i) = snd (x ! Suc i)\n\ngoal (1 subgoal):\n 1. canceling (x ! i) (x ! Suc i)", "unfolding canceling_def"], ["proof (prove)\nusing this:\n  fst (x ! Suc i) \\<noteq> fst a\n  fst (x ! i) = fst a\n  snd (x ! i) = snd (x ! Suc i)\n\ngoal (1 subgoal):\n 1. snd (x ! i) = snd (x ! Suc i) \\<and>\n    fst (x ! i) \\<noteq> fst (x ! Suc i)", "by auto"], ["proof (state)\nthis:\n  canceling (x ! i) (x ! Suc i)\n\ngoal (1 subgoal):\n 1. \\<not> length x \\<le> Suc i \\<Longrightarrow> False", "hence \"cancels_to_1_at i x (cancel_at i x)\""], ["proof (prove)\nusing this:\n  canceling (x ! i) (x ! Suc i)\n\ngoal (1 subgoal):\n 1. cancels_to_1_at i x (cancel_at i x)", "using \\<open>\\<not> length x \\<le> Suc i\\<close>"], ["proof (prove)\nusing this:\n  canceling (x ! i) (x ! Suc i)\n  \\<not> length x \\<le> Suc i\n\ngoal (1 subgoal):\n 1. cancels_to_1_at i x (cancel_at i x)", "unfolding cancels_to_1_at_def"], ["proof (prove)\nusing this:\n  canceling (x ! i) (x ! Suc i)\n  \\<not> length x \\<le> Suc i\n\ngoal (1 subgoal):\n 1. 0 \\<le> i \\<and>\n    1 + i < length x \\<and>\n    canceling (x ! i) (x ! (1 + i)) \\<and> cancel_at i x = cancel_at i x", "by (auto simp add:length_takeWhile_le)"], ["proof (state)\nthis:\n  cancels_to_1_at i x (cancel_at i x)\n\ngoal (1 subgoal):\n 1. \\<not> length x \\<le> Suc i \\<Longrightarrow> False", "hence \"cancels_to_1 x (cancel_at i x)\""], ["proof (prove)\nusing this:\n  cancels_to_1_at i x (cancel_at i x)\n\ngoal (1 subgoal):\n 1. cancels_to_1 x (cancel_at i x)", "unfolding cancels_to_1_def"], ["proof (prove)\nusing this:\n  cancels_to_1_at i x (cancel_at i x)\n\ngoal (1 subgoal):\n 1. \\<exists>ia. cancels_to_1_at ia x (cancel_at i x)", "by auto"], ["proof (state)\nthis:\n  cancels_to_1 x (cancel_at i x)\n\ngoal (1 subgoal):\n 1. \\<not> length x \\<le> Suc i \\<Longrightarrow> False", "hence \"\\<not> canceled x\""], ["proof (prove)\nusing this:\n  cancels_to_1 x (cancel_at i x)\n\ngoal (1 subgoal):\n 1. \\<not> canceled x", "unfolding canceled_def"], ["proof (prove)\nusing this:\n  cancels_to_1 x (cancel_at i x)\n\ngoal (1 subgoal):\n 1. \\<not> \\<not> Domainp cancels_to_1 x", "by auto"], ["proof (state)\nthis:\n  \\<not> canceled x\n\ngoal (1 subgoal):\n 1. \\<not> length x \\<le> Suc i \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  \\<not> canceled x\n\ngoal (1 subgoal):\n 1. False", "using \\<open>canceled x\\<close>"], ["proof (prove)\nusing this:\n  \\<not> canceled x\n  canceled x\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length x \\<le> Suc i\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> False", "hence \"length (takeWhile (\\<lambda>y. y = a) x) = length x\""], ["proof (prove)\nusing this:\n  length x \\<le> Suc i\n\ngoal (1 subgoal):\n 1. length (takeWhile (\\<lambda>y. y = a) x) = length x", "using i[THEN sym]"], ["proof (prove)\nusing this:\n  length x \\<le> Suc i\n  Suc i = length (takeWhile (\\<lambda>y. y = a) x)\n\ngoal (1 subgoal):\n 1. length (takeWhile (\\<lambda>y. y = a) x) = length x", "by (auto dest:le_antisym simp add:length_takeWhile_le)"], ["proof (state)\nthis:\n  length (takeWhile (\\<lambda>y. y = a) x) = length x\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> False", "hence \"takeWhile (\\<lambda>y. y = a) x = x\""], ["proof (prove)\nusing this:\n  length (takeWhile (\\<lambda>y. y = a) x) = length x\n\ngoal (1 subgoal):\n 1. takeWhile (\\<lambda>y. y = a) x = x", "by (subst takeWhile_eq_take, simp)"], ["proof (state)\nthis:\n  takeWhile (\\<lambda>y. y = a) x = x\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  takeWhile (\\<lambda>y. y = a) x = x\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> False", "have \"\\<forall>y \\<in> set (takeWhile (\\<lambda>y. y = a) x). y = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set (takeWhile (\\<lambda>y. y = a) x). y = a", "by (auto dest: set_takeWhileD)"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set (takeWhile (\\<lambda>y. y = a) x). y = a\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  takeWhile (\\<lambda>y. y = a) x = x\n  \\<forall>y\\<in>set (takeWhile (\\<lambda>y. y = a) x). y = a", "have \"\\<forall>y \\<in> set x. y = a\""], ["proof (prove)\nusing this:\n  takeWhile (\\<lambda>y. y = a) x = x\n  \\<forall>y\\<in>set (takeWhile (\\<lambda>y. y = a) x). y = a\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set x. y = a", "by auto"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set x. y = a\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> False", "hence \"x = replicate (length x) a\""], ["proof (prove)\nusing this:\n  \\<forall>y\\<in>set x. y = a\n\ngoal (1 subgoal):\n 1. x = replicate (length x) a", "by simp"], ["proof (state)\nthis:\n  x = replicate (length x) a\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> False", "hence \"int.lift f x = int.lift f (replicate (length x) a)\""], ["proof (prove)\nusing this:\n  x = replicate (length x) a\n\ngoal (1 subgoal):\n 1. int.lift f x = int.lift f (replicate (length x) a)", "by simp"], ["proof (state)\nthis:\n  int.lift f x = int.lift f (replicate (length x) a)\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  int.lift f x = int.lift f (replicate (length x) a)\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> False", "have \"... = pow int_group (int.lift_gi f a) (length x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int.lift f (replicate (length x) a) =\n    int.lift_gi f a [^]\\<^bsub>int_group\\<^esub> length x", "apply (induct x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. int.lift f (replicate (length []) a) =\n    int.lift_gi f a [^]\\<^bsub>int_group\\<^esub> length []\n 2. \\<And>aa x.\n       int.lift f (replicate (length x) a) =\n       int.lift_gi f a [^]\\<^bsub>int_group\\<^esub>\n       length x \\<Longrightarrow>\n       int.lift f (replicate (length (aa # x)) a) =\n       int.lift_gi f a [^]\\<^bsub>int_group\\<^esub> length (aa # x)", "using local.int.nat_pow_Suc local.int.nat_pow_0"], ["proof (prove)\nusing this:\n  ?x [^]\\<^bsub>int_group\\<^esub> Suc ?n =\n  ?x [^]\\<^bsub>int_group\\<^esub> ?n \\<otimes>\\<^bsub>int_group\\<^esub> ?x\n  ?x [^]\\<^bsub>int_group\\<^esub> 0 = \\<one>\\<^bsub>int_group\\<^esub>\n\ngoal (2 subgoals):\n 1. int.lift f (replicate (length []) a) =\n    int.lift_gi f a [^]\\<^bsub>int_group\\<^esub> length []\n 2. \\<And>aa x.\n       int.lift f (replicate (length x) a) =\n       int.lift_gi f a [^]\\<^bsub>int_group\\<^esub>\n       length x \\<Longrightarrow>\n       int.lift f (replicate (length (aa # x)) a) =\n       int.lift_gi f a [^]\\<^bsub>int_group\\<^esub> length (aa # x)", "apply (auto simp: int.lift_def [simplified])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  int.lift f (replicate (length x) a) =\n  int.lift_gi f a [^]\\<^bsub>int_group\\<^esub> length x\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  int.lift f (replicate (length x) a) =\n  int.lift_gi f a [^]\\<^bsub>int_group\\<^esub> length x\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> False", "have \"... = (int.lift_gi f a) * int (length x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int.lift_gi f a [^]\\<^bsub>int_group\\<^esub> length x =\n    int.lift_gi f a * int (length x)", "apply (induct x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. int.lift_gi f a [^]\\<^bsub>int_group\\<^esub> length [] =\n    int.lift_gi f a * int (length [])\n 2. \\<And>aa x.\n       int.lift_gi f a [^]\\<^bsub>int_group\\<^esub> length x =\n       int.lift_gi f a * int (length x) \\<Longrightarrow>\n       int.lift_gi f a [^]\\<^bsub>int_group\\<^esub> length (aa # x) =\n       int.lift_gi f a * int (length (aa # x))", "using local.int.nat_pow_Suc local.int.nat_pow_0"], ["proof (prove)\nusing this:\n  ?x [^]\\<^bsub>int_group\\<^esub> Suc ?n =\n  ?x [^]\\<^bsub>int_group\\<^esub> ?n \\<otimes>\\<^bsub>int_group\\<^esub> ?x\n  ?x [^]\\<^bsub>int_group\\<^esub> 0 = \\<one>\\<^bsub>int_group\\<^esub>\n\ngoal (2 subgoals):\n 1. int.lift_gi f a [^]\\<^bsub>int_group\\<^esub> length [] =\n    int.lift_gi f a * int (length [])\n 2. \\<And>aa x.\n       int.lift_gi f a [^]\\<^bsub>int_group\\<^esub> length x =\n       int.lift_gi f a * int (length x) \\<Longrightarrow>\n       int.lift_gi f a [^]\\<^bsub>int_group\\<^esub> length (aa # x) =\n       int.lift_gi f a * int (length (aa # x))", "by (auto simp: int_distrib)"], ["proof (state)\nthis:\n  int.lift_gi f a [^]\\<^bsub>int_group\\<^esub> length x =\n  int.lift_gi f a * int (length x)\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  int.lift f x = int.lift_gi f a * int (length x)", "have \"\\<dots> = 0\""], ["proof (prove)\nusing this:\n  int.lift f x = int.lift_gi f a * int (length x)\n\ngoal (1 subgoal):\n 1. int.lift_gi f a * int (length x) = 0", "using \\<open>int.lift f x = 0\\<close>"], ["proof (prove)\nusing this:\n  int.lift f x = int.lift_gi f a * int (length x)\n  int.lift f x = 0\n\ngoal (1 subgoal):\n 1. int.lift_gi f a * int (length x) = 0", "by simp"], ["proof (state)\nthis:\n  int.lift_gi f a * int (length x) = 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> False", "hence \"nat (abs (group.lift_gi int_group f a * int (length x))) = 0\""], ["proof (prove)\nusing this:\n  int.lift_gi f a * int (length x) = 0\n\ngoal (1 subgoal):\n 1. nat \\<bar>int.lift_gi f a * int (length x)\\<bar> = 0", "by simp"], ["proof (state)\nthis:\n  nat \\<bar>int.lift_gi f a * int (length x)\\<bar> = 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> False", "hence \"nat (abs (group.lift_gi int_group f a)) * length x = 0\""], ["proof (prove)\nusing this:\n  nat \\<bar>int.lift_gi f a * int (length x)\\<bar> = 0\n\ngoal (1 subgoal):\n 1. nat \\<bar>int.lift_gi f a\\<bar> * length x = 0", "by simp"], ["proof (state)\nthis:\n  nat \\<bar>int.lift_gi f a\\<bar> * length x = 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> False", "hence \"nat (abs (group.lift_gi int_group f a)) = 0\""], ["proof (prove)\nusing this:\n  nat \\<bar>int.lift_gi f a\\<bar> * length x = 0\n\ngoal (1 subgoal):\n 1. nat \\<bar>int.lift_gi f a\\<bar> = 0", "using \\<open>x \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  nat \\<bar>int.lift_gi f a\\<bar> * length x = 0\n  x \\<noteq> []\n\ngoal (1 subgoal):\n 1. nat \\<bar>int.lift_gi f a\\<bar> = 0", "by auto"], ["proof (state)\nthis:\n  nat \\<bar>int.lift_gi f a\\<bar> = 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  nat \\<bar>int.lift_gi f a\\<bar> = 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> False", "have \"inv\\<^bsub>int_group\\<^esub> 1 = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv\\<^bsub>int_group\\<^esub> 1 = - 1", "using int.inv_equality"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y \\<otimes>\\<^bsub>int_group\\<^esub> ?x =\n           \\<one>\\<^bsub>int_group\\<^esub>;\n   ?x \\<in> carrier int_group; ?y \\<in> carrier int_group\\<rbrakk>\n  \\<Longrightarrow> inv\\<^bsub>int_group\\<^esub> ?x = ?y\n\ngoal (1 subgoal):\n 1. inv\\<^bsub>int_group\\<^esub> 1 = - 1", "by auto"], ["proof (state)\nthis:\n  inv\\<^bsub>int_group\\<^esub> 1 = - 1\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> False", "hence \"abs (group.lift_gi int_group f a) = 1\""], ["proof (prove)\nusing this:\n  inv\\<^bsub>int_group\\<^esub> 1 = - 1\n\ngoal (1 subgoal):\n 1. \\<bar>int.lift_gi f a\\<bar> = 1", "using int.is_group"], ["proof (prove)\nusing this:\n  inv\\<^bsub>int_group\\<^esub> 1 = - 1\n  Group.group int_group\n\ngoal (1 subgoal):\n 1. \\<bar>int.lift_gi f a\\<bar> = 1", "by(auto simp add: group.lift_gi_def f_def)"], ["proof (state)\nthis:\n  \\<bar>int.lift_gi f a\\<bar> = 1\n\ngoal (1 subgoal):\n 1. x \\<noteq> [] \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  nat \\<bar>int.lift_gi f a\\<bar> = 0\n  \\<bar>int.lift_gi f a\\<bar> = 1", "show False"], ["proof (prove)\nusing this:\n  nat \\<bar>int.lift_gi f a\\<bar> = 0\n  \\<bar>int.lift_gi f a\\<bar> = 1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = []\n\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x3 \\<in> carrier \\<F>\\<^bsub>{()}\\<^esub>;\n   int.lift f ?x3 = 0\\<rbrakk>\n  \\<Longrightarrow> ?x3 = []\n\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "hence \"\\<forall>x\\<in>carrier \\<F>\\<^bsub>{()}\\<^esub>. int.lift f x = \\<one>\\<^bsub>int_group\\<^esub> \\<longrightarrow> x = \\<one>\\<^bsub>\\<F>\\<^bsub>{()}\\<^esub>\\<^esub>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x3 \\<in> carrier \\<F>\\<^bsub>{()}\\<^esub>;\n   int.lift f ?x3 = 0\\<rbrakk>\n  \\<Longrightarrow> ?x3 = []\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>carrier \\<F>\\<^bsub>{()}\\<^esub>.\n       int.lift f x = \\<one>\\<^bsub>int_group\\<^esub> \\<longrightarrow>\n       x = \\<one>\\<^bsub>\\<F>\\<^bsub>{()}\\<^esub>\\<^esub>", "by (auto simp add:free_group_def)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>carrier \\<F>\\<^bsub>{()}\\<^esub>.\n     int.lift f x = \\<one>\\<^bsub>int_group\\<^esub> \\<longrightarrow>\n     x = \\<one>\\<^bsub>\\<F>\\<^bsub>{()}\\<^esub>\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<in>carrier \\<F>\\<^bsub>{()}\\<^esub>.\n     int.lift f x = \\<one>\\<^bsub>int_group\\<^esub> \\<longrightarrow>\n     x = \\<one>\\<^bsub>\\<F>\\<^bsub>{()}\\<^esub>\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "{"], ["proof (state)\nthis:\n  \\<forall>x\\<in>carrier \\<F>\\<^bsub>{()}\\<^esub>.\n     int.lift f x = \\<one>\\<^bsub>int_group\\<^esub> \\<longrightarrow>\n     x = \\<one>\\<^bsub>\\<F>\\<^bsub>{()}\\<^esub>\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "have \"carrier \\<F>\\<^bsub>{()}\\<^esub> = \\<langle>insert`{()}\\<rangle>\\<^bsub>\\<F>\\<^bsub>{()}\\<^esub>\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier \\<F>\\<^bsub>{()}\\<^esub> =\n    \\<langle>\\<iota> ` {()}\\<rangle>\\<^bsub>\\<F>\\<^bsub>{()}\\<^esub>\\<^esub>", "by (rule gens_span_free_group[THEN sym])"], ["proof (state)\nthis:\n  carrier \\<F>\\<^bsub>{()}\\<^esub> =\n  \\<langle>\\<iota> ` {()}\\<rangle>\\<^bsub>\\<F>\\<^bsub>{()}\\<^esub>\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "moreover"], ["proof (state)\nthis:\n  carrier \\<F>\\<^bsub>{()}\\<^esub> =\n  \\<langle>\\<iota> ` {()}\\<rangle>\\<^bsub>\\<F>\\<^bsub>{()}\\<^esub>\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "have \"carrier int_group = \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier int_group = \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>", "by (rule int_group_gen_by_one[THEN sym])"], ["proof (state)\nthis:\n  carrier int_group = \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "moreover"], ["proof (state)\nthis:\n  carrier int_group = \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "have \"int.lift f ` insert ` {()} = {1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int.lift f ` \\<iota> ` {()} = {1}", "by (auto simp add: int.lift_def [simplified] insert_def f_def int.lift_gi_def [simplified])"], ["proof (state)\nthis:\n  int.lift f ` \\<iota> ` {()} = {1}\n\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "moreover"], ["proof (state)\nthis:\n  int.lift f ` \\<iota> ` {()} = {1}\n\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "have  \"int.lift f ` \\<langle>insert`{()}\\<rangle>\\<^bsub>\\<F>\\<^bsub>{()}\\<^esub>\\<^esub> = \\<langle>int.lift f ` (insert `{()})\\<rangle>\\<^bsub>int_group\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int.lift f `\n    \\<langle>\\<iota> `\n             {()}\\<rangle>\\<^bsub>\\<F>\\<^bsub>{()}\\<^esub>\\<^esub> =\n    \\<langle>int.lift f ` \\<iota> ` {()}\\<rangle>\\<^bsub>int_group\\<^esub>", "by (rule hom.hom_span, auto intro:insert_closed)"], ["proof (state)\nthis:\n  int.lift f `\n  \\<langle>\\<iota> ` {()}\\<rangle>\\<^bsub>\\<F>\\<^bsub>{()}\\<^esub>\\<^esub> =\n  \\<langle>int.lift f ` \\<iota> ` {()}\\<rangle>\\<^bsub>int_group\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "ultimately"], ["proof (chain)\npicking this:\n  carrier \\<F>\\<^bsub>{()}\\<^esub> =\n  \\<langle>\\<iota> ` {()}\\<rangle>\\<^bsub>\\<F>\\<^bsub>{()}\\<^esub>\\<^esub>\n  carrier int_group = \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n  int.lift f ` \\<iota> ` {()} = {1}\n  int.lift f `\n  \\<langle>\\<iota> ` {()}\\<rangle>\\<^bsub>\\<F>\\<^bsub>{()}\\<^esub>\\<^esub> =\n  \\<langle>int.lift f ` \\<iota> ` {()}\\<rangle>\\<^bsub>int_group\\<^esub>", "have \"int.lift f ` carrier \\<F>\\<^bsub>{()}\\<^esub> = carrier int_group\""], ["proof (prove)\nusing this:\n  carrier \\<F>\\<^bsub>{()}\\<^esub> =\n  \\<langle>\\<iota> ` {()}\\<rangle>\\<^bsub>\\<F>\\<^bsub>{()}\\<^esub>\\<^esub>\n  carrier int_group = \\<langle>{1}\\<rangle>\\<^bsub>int_group\\<^esub>\n  int.lift f ` \\<iota> ` {()} = {1}\n  int.lift f `\n  \\<langle>\\<iota> ` {()}\\<rangle>\\<^bsub>\\<F>\\<^bsub>{()}\\<^esub>\\<^esub> =\n  \\<langle>int.lift f ` \\<iota> ` {()}\\<rangle>\\<^bsub>int_group\\<^esub>\n\ngoal (1 subgoal):\n 1. int.lift f ` carrier \\<F>\\<^bsub>{()}\\<^esub> = carrier int_group", "by simp"], ["proof (state)\nthis:\n  int.lift f ` carrier \\<F>\\<^bsub>{()}\\<^esub> = carrier int_group\n\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "}"], ["proof (state)\nthis:\n  int.lift f ` carrier \\<F>\\<^bsub>{()}\\<^esub> = carrier int_group\n\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>carrier \\<F>\\<^bsub>{()}\\<^esub>.\n     int.lift f x = \\<one>\\<^bsub>int_group\\<^esub> \\<longrightarrow>\n     x = \\<one>\\<^bsub>\\<F>\\<^bsub>{()}\\<^esub>\\<^esub>\n  int.lift f ` carrier \\<F>\\<^bsub>{()}\\<^esub> = carrier int_group", "have \"int.lift f \\<in> iso \\<F>\\<^bsub>{()}\\<^esub> int_group\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>carrier \\<F>\\<^bsub>{()}\\<^esub>.\n     int.lift f x = \\<one>\\<^bsub>int_group\\<^esub> \\<longrightarrow>\n     x = \\<one>\\<^bsub>\\<F>\\<^bsub>{()}\\<^esub>\\<^esub>\n  int.lift f ` carrier \\<F>\\<^bsub>{()}\\<^esub> = carrier int_group\n\ngoal (1 subgoal):\n 1. int.lift f \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "using \\<open>int.lift f \\<in> hom \\<F>\\<^bsub>{()}\\<^esub> int_group\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>carrier \\<F>\\<^bsub>{()}\\<^esub>.\n     int.lift f x = \\<one>\\<^bsub>int_group\\<^esub> \\<longrightarrow>\n     x = \\<one>\\<^bsub>\\<F>\\<^bsub>{()}\\<^esub>\\<^esub>\n  int.lift f ` carrier \\<F>\\<^bsub>{()}\\<^esub> = carrier int_group\n  int.lift f \\<in> hom \\<F>\\<^bsub>{()}\\<^esub> int_group\n\ngoal (1 subgoal):\n 1. int.lift f \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "using hom.hom_mult int.is_group"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>carrier \\<F>\\<^bsub>{()}\\<^esub>.\n     int.lift f x = \\<one>\\<^bsub>int_group\\<^esub> \\<longrightarrow>\n     x = \\<one>\\<^bsub>\\<F>\\<^bsub>{()}\\<^esub>\\<^esub>\n  int.lift f ` carrier \\<F>\\<^bsub>{()}\\<^esub> = carrier int_group\n  int.lift f \\<in> hom \\<F>\\<^bsub>{()}\\<^esub> int_group\n  \\<lbrakk>?x \\<in> carrier \\<F>\\<^bsub>{()}\\<^esub>;\n   ?y \\<in> carrier \\<F>\\<^bsub>{()}\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> int.lift f\n                     (?x \\<otimes>\\<^bsub>\\<F>\\<^bsub>{()}\\<^esub>\\<^esub>\n                      ?y) =\n                    int.lift f ?x \\<otimes>\\<^bsub>int_group\\<^esub>\n                    int.lift f ?y\n  Group.group int_group\n\ngoal (1 subgoal):\n 1. int.lift f \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "by (auto intro:group_isoI simp add: free_group_is_group)"], ["proof (state)\nthis:\n  int.lift f \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group\n\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "thus ?thesis"], ["proof (prove)\nusing this:\n  int.lift f \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group\n\ngoal (1 subgoal):\n 1. \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group", "by auto"], ["proof (state)\nthis:\n  \\<exists>h. h \\<in> Group.iso \\<F>\\<^bsub>{()}\\<^esub> int_group\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Free Groups over isomorphic sets of generators\\<close>"], ["", "text \\<open>Free Groups are isomorphic if their set of generators are isomorphic.\\<close>"], ["", "definition lift_generator_function :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> (bool \\<times> 'a) list \\<Rightarrow> (bool \\<times> 'b) list\"\nwhere \"lift_generator_function f = map (map_prod id f)\""], ["", "theorem isomorphic_free_groups:\n  assumes \"bij_betw f gens1 gens2\"\n  shows \"lift_generator_function f \\<in> iso \\<F>\\<^bsub>gens1\\<^esub> \\<F>\\<^bsub>gens2\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_generator_function f\n    \\<in> Group.iso \\<F>\\<^bsub>gens1\\<^esub> \\<F>\\<^bsub>gens2\\<^esub>", "unfolding lift_generator_function_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (map_prod id f)\n    \\<in> Group.iso \\<F>\\<^bsub>gens1\\<^esub> \\<F>\\<^bsub>gens2\\<^esub>", "proof(rule group_isoI)"], ["proof (state)\ngoal (5 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>\n 3. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       map (map_prod id f) x =\n       \\<one>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub> \\<longrightarrow>\n       x = \\<one>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub>\n 4. map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub> =\n    carrier \\<F>\\<^bsub>gens2\\<^esub>\n 5. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "show \"\\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       map (map_prod id f) x = \\<one>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub> \\<longrightarrow> x = \\<one>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       map (map_prod id f) x =\n       \\<one>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub> \\<longrightarrow>\n       x = \\<one>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub>", "by(auto simp add:free_group_def)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n     map (map_prod id f) x =\n     \\<one>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub> \\<longrightarrow>\n     x = \\<one>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub>\n\ngoal (4 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>\n 3. map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub> =\n    carrier \\<F>\\<^bsub>gens2\\<^esub>\n 4. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>\n 3. map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub> =\n    carrier \\<F>\\<^bsub>gens2\\<^esub>\n 4. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "from \\<open>bij_betw f gens1 gens2\\<close>"], ["proof (chain)\npicking this:\n  bij_betw f gens1 gens2", "have \"inj_on f gens1\""], ["proof (prove)\nusing this:\n  bij_betw f gens1 gens2\n\ngoal (1 subgoal):\n 1. inj_on f gens1", "by (auto simp:bij_betw_def)"], ["proof (state)\nthis:\n  inj_on f gens1\n\ngoal (4 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>\n 3. map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub> =\n    carrier \\<F>\\<^bsub>gens2\\<^esub>\n 4. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "show \"map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub> = carrier \\<F>\\<^bsub>gens2\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub> =\n    carrier \\<F>\\<^bsub>gens2\\<^esub>", "proof(rule Set.set_eqI,rule iffI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> map (map_prod id f) `\n               carrier \\<F>\\<^bsub>gens1\\<^esub> \\<Longrightarrow>\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub>\n 2. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "from \\<open>bij_betw f gens1 gens2\\<close>"], ["proof (chain)\npicking this:\n  bij_betw f gens1 gens2", "have \"f ` gens1 = gens2\""], ["proof (prove)\nusing this:\n  bij_betw f gens1 gens2\n\ngoal (1 subgoal):\n 1. f ` gens1 = gens2", "by (auto simp:bij_betw_def)"], ["proof (state)\nthis:\n  f ` gens1 = gens2\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> map (map_prod id f) `\n               carrier \\<F>\\<^bsub>gens1\\<^esub> \\<Longrightarrow>\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub>\n 2. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "fix x :: \"(bool \\<times> 'b) list\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> map (map_prod id f) `\n               carrier \\<F>\\<^bsub>gens1\\<^esub> \\<Longrightarrow>\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub>\n 2. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "assume \"x \\<in> image (map (map_prod id f)) (carrier \\<F>\\<^bsub>gens1\\<^esub>)\""], ["proof (state)\nthis:\n  x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> map (map_prod id f) `\n               carrier \\<F>\\<^bsub>gens1\\<^esub> \\<Longrightarrow>\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub>\n 2. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "then"], ["proof (chain)\npicking this:\n  x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "obtain y :: \"(bool \\<times> 'a) list\" where \"x = map (map_prod id f) y\"\n                    and \"y \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>\""], ["proof (prove)\nusing this:\n  x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>x = map (map_prod id f) y;\n         y \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x = map (map_prod id f) y\n  y \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> map (map_prod id f) `\n               carrier \\<F>\\<^bsub>gens1\\<^esub> \\<Longrightarrow>\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub>\n 2. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "from \\<open>y \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>", "have \"canceled y\" and \"y \\<in> lists(UNIV\\<times>gens1)\""], ["proof (prove)\nusing this:\n  y \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>\n\ngoal (1 subgoal):\n 1. canceled y &&& y \\<in> lists (UNIV \\<times> gens1)", "by (auto simp add:free_group_def)"], ["proof (state)\nthis:\n  canceled y\n  y \\<in> lists (UNIV \\<times> gens1)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> map (map_prod id f) `\n               carrier \\<F>\\<^bsub>gens1\\<^esub> \\<Longrightarrow>\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub>\n 2. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "from \\<open>y \\<in> lists (UNIV\\<times>gens1)\\<close>\n      and \\<open>x = map (map_prod id f) y\\<close>\n      and \\<open>image f gens1 = gens2\\<close>"], ["proof (chain)\npicking this:\n  y \\<in> lists (UNIV \\<times> gens1)\n  x = map (map_prod id f) y\n  f ` gens1 = gens2", "have \"x \\<in> lists (UNIV\\<times>gens2)\""], ["proof (prove)\nusing this:\n  y \\<in> lists (UNIV \\<times> gens1)\n  x = map (map_prod id f) y\n  f ` gens1 = gens2\n\ngoal (1 subgoal):\n 1. x \\<in> lists (UNIV \\<times> gens2)", "by (auto iff:lists_eq_set)"], ["proof (state)\nthis:\n  x \\<in> lists (UNIV \\<times> gens2)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> map (map_prod id f) `\n               carrier \\<F>\\<^bsub>gens1\\<^esub> \\<Longrightarrow>\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub>\n 2. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "moreover"], ["proof (state)\nthis:\n  x \\<in> lists (UNIV \\<times> gens2)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> map (map_prod id f) `\n               carrier \\<F>\\<^bsub>gens1\\<^esub> \\<Longrightarrow>\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub>\n 2. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "from \\<open>x = map (map_prod id f) y\\<close>\n     and \\<open>y \\<in> lists (UNIV\\<times>gens1)\\<close>\n     and \\<open>canceled y\\<close>\n     and \\<open>inj_on f gens1\\<close>"], ["proof (chain)\npicking this:\n  x = map (map_prod id f) y\n  y \\<in> lists (UNIV \\<times> gens1)\n  canceled y\n  inj_on f gens1", "have \"canceled x\""], ["proof (prove)\nusing this:\n  x = map (map_prod id f) y\n  y \\<in> lists (UNIV \\<times> gens1)\n  canceled y\n  inj_on f gens1\n\ngoal (1 subgoal):\n 1. canceled x", "by (auto intro!:rename_gens_canceled subset_inj_on[OF \\<open>inj_on f gens1\\<close>] iff:lists_eq_set)"], ["proof (state)\nthis:\n  canceled x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> map (map_prod id f) `\n               carrier \\<F>\\<^bsub>gens1\\<^esub> \\<Longrightarrow>\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub>\n 2. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> lists (UNIV \\<times> gens2)\n  canceled x", "show \"x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub>\""], ["proof (prove)\nusing this:\n  x \\<in> lists (UNIV \\<times> gens2)\n  canceled x\n\ngoal (1 subgoal):\n 1. x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub>", "by (simp add:free_group_def)"], ["proof (state)\nthis:\n  x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "assume \"x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub>\""], ["proof (state)\nthis:\n  x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "hence \"canceled x\" and \"x \\<in> lists (UNIV\\<times>gens2)\""], ["proof (prove)\nusing this:\n  x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub>\n\ngoal (1 subgoal):\n 1. canceled x &&& x \\<in> lists (UNIV \\<times> gens2)", "unfolding free_group_def"], ["proof (prove)\nusing this:\n  x \\<in> carrier\n           \\<lparr>carrier =\n                     {l \\<in> lists (UNIV \\<times> gens2). canceled l},\n              monoid.mult = \\<lambda>x y. Cancelation.normalize (x @ y),\n              one = []\\<rparr>\n\ngoal (1 subgoal):\n 1. canceled x &&& x \\<in> lists (UNIV \\<times> gens2)", "by auto"], ["proof (state)\nthis:\n  canceled x\n  x \\<in> lists (UNIV \\<times> gens2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "define y where \"y = map (map_prod id (the_inv_into gens1 f)) x\""], ["proof (state)\nthis:\n  y = map (map_prod id (the_inv_into gens1 f)) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "have \"map (map_prod id f) y =\n          map (map_prod id f) (map (map_prod id (the_inv_into gens1 f)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (map_prod id f) y =\n    map (map_prod id f) (map (map_prod id (the_inv_into gens1 f)) x)", "by (simp add:y_def)"], ["proof (state)\nthis:\n  map (map_prod id f) y =\n  map (map_prod id f) (map (map_prod id (the_inv_into gens1 f)) x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "also"], ["proof (state)\nthis:\n  map (map_prod id f) y =\n  map (map_prod id f) (map (map_prod id (the_inv_into gens1 f)) x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "have \"\\<dots> = map (map_prod id f \\<circ> map_prod id (the_inv_into gens1 f)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (map_prod id f) (map (map_prod id (the_inv_into gens1 f)) x) =\n    map (map_prod id f \\<circ> map_prod id (the_inv_into gens1 f)) x", "by simp"], ["proof (state)\nthis:\n  map (map_prod id f) (map (map_prod id (the_inv_into gens1 f)) x) =\n  map (map_prod id f \\<circ> map_prod id (the_inv_into gens1 f)) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "also"], ["proof (state)\nthis:\n  map (map_prod id f) (map (map_prod id (the_inv_into gens1 f)) x) =\n  map (map_prod id f \\<circ> map_prod id (the_inv_into gens1 f)) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "have \"\\<dots> = map (map_prod id (f \\<circ> the_inv_into gens1 f)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (map_prod id f \\<circ> map_prod id (the_inv_into gens1 f)) x =\n    map (map_prod id (f \\<circ> the_inv_into gens1 f)) x", "by auto"], ["proof (state)\nthis:\n  map (map_prod id f \\<circ> map_prod id (the_inv_into gens1 f)) x =\n  map (map_prod id (f \\<circ> the_inv_into gens1 f)) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "also"], ["proof (state)\nthis:\n  map (map_prod id f \\<circ> map_prod id (the_inv_into gens1 f)) x =\n  map (map_prod id (f \\<circ> the_inv_into gens1 f)) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "have \"\\<dots> = map id x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (map_prod id (f \\<circ> the_inv_into gens1 f)) x = map id x", "proof(rule map_ext, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set x \\<Longrightarrow>\n       map_prod id (f \\<circ> the_inv_into gens1 f) xa = id xa", "fix xa :: \"bool \\<times> 'b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set x \\<Longrightarrow>\n       map_prod id (f \\<circ> the_inv_into gens1 f) xa = id xa", "assume \"xa \\<in> set x\""], ["proof (state)\nthis:\n  xa \\<in> set x\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set x \\<Longrightarrow>\n       map_prod id (f \\<circ> the_inv_into gens1 f) xa = id xa", "from \\<open>x \\<in> lists (UNIV\\<times>gens2)\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> lists (UNIV \\<times> gens2)", "have \"set (map snd x) \\<subseteq> gens2\""], ["proof (prove)\nusing this:\n  x \\<in> lists (UNIV \\<times> gens2)\n\ngoal (1 subgoal):\n 1. set (map snd x) \\<subseteq> gens2", "by auto"], ["proof (state)\nthis:\n  set (map snd x) \\<subseteq> gens2\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set x \\<Longrightarrow>\n       map_prod id (f \\<circ> the_inv_into gens1 f) xa = id xa", "hence \"snd ` set x \\<subseteq> gens2\""], ["proof (prove)\nusing this:\n  set (map snd x) \\<subseteq> gens2\n\ngoal (1 subgoal):\n 1. snd ` set x \\<subseteq> gens2", "by (simp add: set_map)"], ["proof (state)\nthis:\n  snd ` set x \\<subseteq> gens2\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set x \\<Longrightarrow>\n       map_prod id (f \\<circ> the_inv_into gens1 f) xa = id xa", "with \\<open>xa \\<in> set x\\<close>"], ["proof (chain)\npicking this:\n  xa \\<in> set x\n  snd ` set x \\<subseteq> gens2", "have \"snd xa \\<in> gens2\""], ["proof (prove)\nusing this:\n  xa \\<in> set x\n  snd ` set x \\<subseteq> gens2\n\ngoal (1 subgoal):\n 1. snd xa \\<in> gens2", "by auto"], ["proof (state)\nthis:\n  snd xa \\<in> gens2\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set x \\<Longrightarrow>\n       map_prod id (f \\<circ> the_inv_into gens1 f) xa = id xa", "with \\<open>bij_betw f gens1 gens2\\<close>"], ["proof (chain)\npicking this:\n  bij_betw f gens1 gens2\n  snd xa \\<in> gens2", "have \"snd xa \\<in> f`gens1\""], ["proof (prove)\nusing this:\n  bij_betw f gens1 gens2\n  snd xa \\<in> gens2\n\ngoal (1 subgoal):\n 1. snd xa \\<in> f ` gens1", "by (auto simp add: bij_betw_def)"], ["proof (state)\nthis:\n  snd xa \\<in> f ` gens1\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set x \\<Longrightarrow>\n       map_prod id (f \\<circ> the_inv_into gens1 f) xa = id xa", "have \"map_prod id (f \\<circ> the_inv_into gens1 f) xa\n            = map_prod id (f \\<circ> the_inv_into gens1 f) (fst xa, snd xa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_prod id (f \\<circ> the_inv_into gens1 f) xa =\n    map_prod id (f \\<circ> the_inv_into gens1 f) (fst xa, snd xa)", "by simp"], ["proof (state)\nthis:\n  map_prod id (f \\<circ> the_inv_into gens1 f) xa =\n  map_prod id (f \\<circ> the_inv_into gens1 f) (fst xa, snd xa)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set x \\<Longrightarrow>\n       map_prod id (f \\<circ> the_inv_into gens1 f) xa = id xa", "also"], ["proof (state)\nthis:\n  map_prod id (f \\<circ> the_inv_into gens1 f) xa =\n  map_prod id (f \\<circ> the_inv_into gens1 f) (fst xa, snd xa)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set x \\<Longrightarrow>\n       map_prod id (f \\<circ> the_inv_into gens1 f) xa = id xa", "have \"\\<dots> = (fst xa, f (the_inv_into gens1 f (snd xa)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_prod id (f \\<circ> the_inv_into gens1 f) (fst xa, snd xa) =\n    (fst xa, f (the_inv_into gens1 f (snd xa)))", "by (auto simp del:prod.collapse)"], ["proof (state)\nthis:\n  map_prod id (f \\<circ> the_inv_into gens1 f) (fst xa, snd xa) =\n  (fst xa, f (the_inv_into gens1 f (snd xa)))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set x \\<Longrightarrow>\n       map_prod id (f \\<circ> the_inv_into gens1 f) xa = id xa", "also"], ["proof (state)\nthis:\n  map_prod id (f \\<circ> the_inv_into gens1 f) (fst xa, snd xa) =\n  (fst xa, f (the_inv_into gens1 f (snd xa)))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set x \\<Longrightarrow>\n       map_prod id (f \\<circ> the_inv_into gens1 f) xa = id xa", "from \\<open>snd xa \\<in> image f gens1\\<close> and \\<open>inj_on f gens1\\<close>"], ["proof (chain)\npicking this:\n  snd xa \\<in> f ` gens1\n  inj_on f gens1", "have \"\\<dots> = (fst xa, snd xa)\""], ["proof (prove)\nusing this:\n  snd xa \\<in> f ` gens1\n  inj_on f gens1\n\ngoal (1 subgoal):\n 1. (fst xa, f (the_inv_into gens1 f (snd xa))) = (fst xa, snd xa)", "by (auto elim:f_the_inv_into_f simp del:prod.collapse)"], ["proof (state)\nthis:\n  (fst xa, f (the_inv_into gens1 f (snd xa))) = (fst xa, snd xa)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set x \\<Longrightarrow>\n       map_prod id (f \\<circ> the_inv_into gens1 f) xa = id xa", "also"], ["proof (state)\nthis:\n  (fst xa, f (the_inv_into gens1 f (snd xa))) = (fst xa, snd xa)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set x \\<Longrightarrow>\n       map_prod id (f \\<circ> the_inv_into gens1 f) xa = id xa", "have \"\\<dots> = id xa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (fst xa, snd xa) = id xa", "by simp"], ["proof (state)\nthis:\n  (fst xa, snd xa) = id xa\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> set x \\<Longrightarrow>\n       map_prod id (f \\<circ> the_inv_into gens1 f) xa = id xa", "finally"], ["proof (chain)\npicking this:\n  map_prod id (f \\<circ> the_inv_into gens1 f) xa = id xa", "show \"map_prod id (f \\<circ> the_inv_into gens1 f) xa = id xa\""], ["proof (prove)\nusing this:\n  map_prod id (f \\<circ> the_inv_into gens1 f) xa = id xa\n\ngoal (1 subgoal):\n 1. map_prod id (f \\<circ> the_inv_into gens1 f) xa = id xa", "."], ["proof (state)\nthis:\n  map_prod id (f \\<circ> the_inv_into gens1 f) xa = id xa\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (map_prod id (f \\<circ> the_inv_into gens1 f)) x = map id x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "also"], ["proof (state)\nthis:\n  map (map_prod id (f \\<circ> the_inv_into gens1 f)) x = map id x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "have \"\\<dots> = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map id x = x", "unfolding id_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x. x) x = x", "by auto"], ["proof (state)\nthis:\n  map id x = x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "finally"], ["proof (chain)\npicking this:\n  map (map_prod id f) y = x", "have \"map (map_prod id f) y = x\""], ["proof (prove)\nusing this:\n  map (map_prod id f) y = x\n\ngoal (1 subgoal):\n 1. map (map_prod id f) y = x", "."], ["proof (state)\nthis:\n  map (map_prod id f) y = x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "moreover"], ["proof (state)\nthis:\n  map (map_prod id f) y = x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "{"], ["proof (state)\nthis:\n  map (map_prod id f) y = x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "from \\<open>bij_betw f gens1 gens2\\<close>"], ["proof (chain)\npicking this:\n  bij_betw f gens1 gens2", "have \"bij_betw (the_inv_into gens1 f) gens2 gens1\""], ["proof (prove)\nusing this:\n  bij_betw f gens1 gens2\n\ngoal (1 subgoal):\n 1. bij_betw (the_inv_into gens1 f) gens2 gens1", "by (rule bij_betw_the_inv_into)"], ["proof (state)\nthis:\n  bij_betw (the_inv_into gens1 f) gens2 gens1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "hence \"inj_on (the_inv_into gens1 f) gens2\""], ["proof (prove)\nusing this:\n  bij_betw (the_inv_into gens1 f) gens2 gens1\n\ngoal (1 subgoal):\n 1. inj_on (the_inv_into gens1 f) gens2", "by (rule bij_betw_imp_inj_on)"], ["proof (state)\nthis:\n  inj_on (the_inv_into gens1 f) gens2\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "with \\<open>canceled x\\<close>      \n       and \\<open>x \\<in> lists (UNIV\\<times>gens2)\\<close>"], ["proof (chain)\npicking this:\n  canceled x\n  x \\<in> lists (UNIV \\<times> gens2)\n  inj_on (the_inv_into gens1 f) gens2", "have \"canceled y\""], ["proof (prove)\nusing this:\n  canceled x\n  x \\<in> lists (UNIV \\<times> gens2)\n  inj_on (the_inv_into gens1 f) gens2\n\ngoal (1 subgoal):\n 1. canceled y", "by (auto intro!:rename_gens_canceled[OF subset_inj_on] simp add:y_def)"], ["proof (state)\nthis:\n  canceled y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "moreover"], ["proof (state)\nthis:\n  canceled y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "{"], ["proof (state)\nthis:\n  canceled y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "from \\<open>bij_betw (the_inv_into gens1 f) gens2 gens1\\<close>\n         and \\<open>x\\<in>lists(UNIV\\<times>gens2)\\<close>"], ["proof (chain)\npicking this:\n  bij_betw (the_inv_into gens1 f) gens2 gens1\n  x \\<in> lists (UNIV \\<times> gens2)", "have \"y \\<in> lists(UNIV\\<times>gens1)\""], ["proof (prove)\nusing this:\n  bij_betw (the_inv_into gens1 f) gens2 gens1\n  x \\<in> lists (UNIV \\<times> gens2)\n\ngoal (1 subgoal):\n 1. y \\<in> lists (UNIV \\<times> gens1)", "unfolding y_def and bij_betw_def"], ["proof (prove)\nusing this:\n  inj_on (the_inv_into gens1 f) gens2 \\<and>\n  the_inv_into gens1 f ` gens2 = gens1\n  x \\<in> lists (UNIV \\<times> gens2)\n\ngoal (1 subgoal):\n 1. map (map_prod id (the_inv_into gens1 f)) x\n    \\<in> lists (UNIV \\<times> gens1)", "by (auto iff:lists_eq_set dest!:subsetD)"], ["proof (state)\nthis:\n  y \\<in> lists (UNIV \\<times> gens1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "}"], ["proof (state)\nthis:\n  y \\<in> lists (UNIV \\<times> gens1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "ultimately"], ["proof (chain)\npicking this:\n  canceled y\n  y \\<in> lists (UNIV \\<times> gens1)", "have \"y \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>\""], ["proof (prove)\nusing this:\n  canceled y\n  y \\<in> lists (UNIV \\<times> gens1)\n\ngoal (1 subgoal):\n 1. y \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>", "by (simp add:free_group_def)"], ["proof (state)\nthis:\n  y \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "}"], ["proof (state)\nthis:\n  y \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> carrier \\<F>\\<^bsub>gens2\\<^esub> \\<Longrightarrow>\n       x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "ultimately"], ["proof (chain)\npicking this:\n  map (map_prod id f) y = x\n  y \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>", "show \"x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>\""], ["proof (prove)\nusing this:\n  map (map_prod id f) y = x\n  y \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>\n\ngoal (1 subgoal):\n 1. x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>", "by auto"], ["proof (state)\nthis:\n  x \\<in> map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (map_prod id f) ` carrier \\<F>\\<^bsub>gens1\\<^esub> =\n  carrier \\<F>\\<^bsub>gens2\\<^esub>\n\ngoal (3 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>\n 3. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>\n 3. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "from \\<open>bij_betw f gens1 gens2\\<close>"], ["proof (chain)\npicking this:\n  bij_betw f gens1 gens2", "have \"inj_on f gens1\""], ["proof (prove)\nusing this:\n  bij_betw f gens1 gens2\n\ngoal (1 subgoal):\n 1. inj_on f gens1", "by (auto simp:bij_betw_def)"], ["proof (state)\nthis:\n  inj_on f gens1\n\ngoal (3 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>\n 3. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "{"], ["proof (state)\nthis:\n  inj_on f gens1\n\ngoal (3 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>\n 3. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>\n 3. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "assume \"x \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>\""], ["proof (state)\nthis:\n  x \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>\n\ngoal (3 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>\n 3. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "fix y"], ["proof (state)\ngoal (3 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>\n 3. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "assume \"y \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>\""], ["proof (state)\nthis:\n  y \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>\n\ngoal (3 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>\n 3. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "from \\<open>x \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>\\<close> and \\<open>y \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>\n  y \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>", "have \"x \\<in> lists(UNIV\\<times>gens1)\" and \"y \\<in> lists(UNIV\\<times>gens1)\""], ["proof (prove)\nusing this:\n  x \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>\n  y \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>\n\ngoal (1 subgoal):\n 1. x \\<in> lists (UNIV \\<times> gens1) &&&\n    y \\<in> lists (UNIV \\<times> gens1)", "by (auto simp add:occuring_gens_in_element)"], ["proof (state)\nthis:\n  x \\<in> lists (UNIV \\<times> gens1)\n  y \\<in> lists (UNIV \\<times> gens1)\n\ngoal (3 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>\n 3. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "(*  hence \"occuring_generators (x@y) \\<subseteq> gens1\"\n    by(auto simp add:occuring_generators_def)\n  with `inj_on f gens1` have \"inj_on f (occuring_generators (x@y))\"\n    by (rule subset_inj_on) *)"], ["proof (state)\nthis:\n  x \\<in> lists (UNIV \\<times> gens1)\n  y \\<in> lists (UNIV \\<times> gens1)\n\ngoal (3 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>\n 3. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "have \"map (map_prod id f) (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y)\n       = map (map_prod id f) (normalize (x@y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (map_prod id f)\n     (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n    map (map_prod id f) (Cancelation.normalize (x @ y))", "by (simp add:free_group_def)"], ["proof (state)\nthis:\n  map (map_prod id f)\n   (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n  map (map_prod id f) (Cancelation.normalize (x @ y))\n\ngoal (3 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>\n 3. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "also"], ["proof (state)\nthis:\n  map (map_prod id f)\n   (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n  map (map_prod id f) (Cancelation.normalize (x @ y))\n\ngoal (3 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>\n 3. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "(* from `inj_on f (occuring_generators (x@y))` *)"], ["proof (state)\nthis:\n  map (map_prod id f)\n   (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n  map (map_prod id f) (Cancelation.normalize (x @ y))\n\ngoal (3 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>\n 3. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "from \\<open>x \\<in> lists(UNIV\\<times>gens1)\\<close> and \\<open>y \\<in> lists(UNIV\\<times>gens1)\\<close>\n        and \\<open>inj_on f gens1\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> lists (UNIV \\<times> gens1)\n  y \\<in> lists (UNIV \\<times> gens1)\n  inj_on f gens1", "have \"\\<dots> = normalize (map (map_prod id f) (x@y))\""], ["proof (prove)\nusing this:\n  x \\<in> lists (UNIV \\<times> gens1)\n  y \\<in> lists (UNIV \\<times> gens1)\n  inj_on f gens1\n\ngoal (1 subgoal):\n 1. map (map_prod id f) (Cancelation.normalize (x @ y)) =\n    Cancelation.normalize (map (map_prod id f) (x @ y))", "by -(rule rename_gens_normalize[THEN sym],\n              auto intro!: subset_inj_on[OF \\<open>inj_on f gens1\\<close>] iff:lists_eq_set)"], ["proof (state)\nthis:\n  map (map_prod id f) (Cancelation.normalize (x @ y)) =\n  Cancelation.normalize (map (map_prod id f) (x @ y))\n\ngoal (3 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>\n 3. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "also"], ["proof (state)\nthis:\n  map (map_prod id f) (Cancelation.normalize (x @ y)) =\n  Cancelation.normalize (map (map_prod id f) (x @ y))\n\ngoal (3 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>\n 3. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "have \"\\<dots> = normalize (map (map_prod id f) x @ map (map_prod id f) y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cancelation.normalize (map (map_prod id f) (x @ y)) =\n    Cancelation.normalize (map (map_prod id f) x @ map (map_prod id f) y)", "by (auto)"], ["proof (state)\nthis:\n  Cancelation.normalize (map (map_prod id f) (x @ y)) =\n  Cancelation.normalize (map (map_prod id f) x @ map (map_prod id f) y)\n\ngoal (3 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>\n 3. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "also"], ["proof (state)\nthis:\n  Cancelation.normalize (map (map_prod id f) (x @ y)) =\n  Cancelation.normalize (map (map_prod id f) x @ map (map_prod id f) y)\n\ngoal (3 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>\n 3. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "have \"\\<dots> = map (map_prod id f) x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub> map (map_prod id f) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cancelation.normalize (map (map_prod id f) x @ map (map_prod id f) y) =\n    map (map_prod id f) x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n    map (map_prod id f) y", "by (simp add:free_group_def)"], ["proof (state)\nthis:\n  Cancelation.normalize (map (map_prod id f) x @ map (map_prod id f) y) =\n  map (map_prod id f) x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n  map (map_prod id f) y\n\ngoal (3 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>\n 3. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "finally"], ["proof (chain)\npicking this:\n  map (map_prod id f)\n   (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n  map (map_prod id f) x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n  map (map_prod id f) y", "have \"map (map_prod id f) (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n                map (map_prod id f) x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub> map (map_prod id f) y\""], ["proof (prove)\nusing this:\n  map (map_prod id f)\n   (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n  map (map_prod id f) x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n  map (map_prod id f) y\n\ngoal (1 subgoal):\n 1. map (map_prod id f)\n     (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n    map (map_prod id f) x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n    map (map_prod id f) y", "."], ["proof (state)\nthis:\n  map (map_prod id f)\n   (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n  map (map_prod id f) x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n  map (map_prod id f) y\n\ngoal (3 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>\n 3. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?x2 \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>;\n   ?y2 \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> map (map_prod id f)\n                     (?x2 \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub>\n                      ?y2) =\n                    map (map_prod id f)\n                     ?x2 \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n                    map (map_prod id f) ?y2\n\ngoal (3 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>\n 3. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "thus \"\\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f) (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f) x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub> map (map_prod id f) y\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?x2 \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>;\n   ?y2 \\<in> carrier \\<F>\\<^bsub>gens1\\<^esub>\\<rbrakk>\n  \\<Longrightarrow> map (map_prod id f)\n                     (?x2 \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub>\n                      ?y2) =\n                    map (map_prod id f)\n                     ?x2 \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n                    map (map_prod id f) ?y2\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n       \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n          map (map_prod id f)\n           (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n          map (map_prod id f)\n           x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n          map (map_prod id f) y", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n     \\<forall>y\\<in>carrier \\<F>\\<^bsub>gens1\\<^esub>.\n        map (map_prod id f)\n         (x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens1\\<^esub>\\<^esub> y) =\n        map (map_prod id f)\n         x \\<otimes>\\<^bsub>\\<F>\\<^bsub>gens2\\<^esub>\\<^esub>\n        map (map_prod id f) y\n\ngoal (2 subgoals):\n 1. Group.group \\<F>\\<^bsub>gens1\\<^esub>\n 2. Group.group \\<F>\\<^bsub>gens2\\<^esub>", "qed (auto intro: free_group_is_group)"], ["", "subsection \\<open>Bases of isomorphic free groups\\<close>"], ["", "text \\<open>\nIsomorphic free groups have bases of same cardinality. The proof is very different\nfor infinite bases and for finite bases.\n\nThe proof for the finite case uses the set of of homomorphisms from the free\ngroup to the group with two elements, as suggested by Christian Sievers. The\ndefinition of @{term hom} is not suitable for proofs about the cardinality of that\nset, as its definition does not require extensionality. This is amended by the\nfollowing definition:\n\\<close>"], ["", "definition homr\n  where \"homr G H = {h. h \\<in> hom G H \\<and> h \\<in> extensional (carrier G)}\""], ["", "lemma (in group_hom) restrict_hom[intro!]:\n  shows \"restrict h (carrier G) \\<in> homr G H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict h (carrier G) \\<in> homr G H", "unfolding homr_def and hom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict h (carrier G)\n    \\<in> {h \\<in> {h \\<in> carrier G \\<rightarrow> carrier H.\n                    \\<forall>x\\<in>carrier G.\n                       \\<forall>y\\<in>carrier G.\n                          h (x \\<otimes> y) =\n                          h x \\<otimes>\\<^bsub>H\\<^esub> h y}.\n           h \\<in> extensional (carrier G)}", "by (auto)"], ["", "lemma hom_F_C2_Powerset:\n  \"\\<exists> f. bij_betw f (Pow X) (homr (\\<F>\\<^bsub>X\\<^esub>) C2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f (Pow X) (homr \\<F>\\<^bsub>X\\<^esub> C2)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. bij_betw ?f (Pow X) (homr \\<F>\\<^bsub>X\\<^esub> C2)", "interpret F: group \"\\<F>\\<^bsub>X\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group \\<F>\\<^bsub>X\\<^esub>", "by (rule free_group_is_group)"], ["proof (state)\ngoal (1 subgoal):\n 1. bij_betw ?f (Pow X) (homr \\<F>\\<^bsub>X\\<^esub> C2)", "interpret C2: group C2"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group C2", "by (rule C2_is_group)"], ["proof (state)\ngoal (1 subgoal):\n 1. bij_betw ?f (Pow X) (homr \\<F>\\<^bsub>X\\<^esub> C2)", "let ?f = \"\\<lambda>S . restrict (C2.lift (\\<lambda>x. x \\<in> S)) (carrier \\<F>\\<^bsub>X\\<^esub>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. bij_betw ?f (Pow X) (homr \\<F>\\<^bsub>X\\<^esub> C2)", "let ?f' = \"\\<lambda>h . X \\<inter> Collect(h \\<circ> insert)\""], ["proof (state)\ngoal (1 subgoal):\n 1. bij_betw ?f (Pow X) (homr \\<F>\\<^bsub>X\\<^esub> C2)", "show \"bij_betw ?f (Pow X) (homr (\\<F>\\<^bsub>X\\<^esub>) C2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw\n     (\\<lambda>S.\n         restrict (C2.lift (\\<lambda>x. x \\<in> S))\n          (carrier \\<F>\\<^bsub>X\\<^esub>))\n     (Pow X) (homr \\<F>\\<^bsub>X\\<^esub> C2)", "proof(induct rule: bij_betwI[of ?f _ _ ?f'])"], ["proof (state)\ngoal (4 subgoals):\n 1. (\\<lambda>S.\n        restrict (C2.lift (\\<lambda>x. x \\<in> S))\n         (carrier \\<F>\\<^bsub>X\\<^esub>))\n    \\<in> Pow X \\<rightarrow> homr \\<F>\\<^bsub>X\\<^esub> C2\n 2. (\\<lambda>h. X \\<inter> Collect (h \\<circ> \\<iota>))\n    \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2 \\<rightarrow> Pow X\n 3. \\<And>x.\n       x \\<in> Pow X \\<Longrightarrow>\n       X \\<inter>\n       Collect\n        (restrict (C2.lift (\\<lambda>xa. xa \\<in> x))\n          (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n         \\<iota>) =\n       x\n 4. \\<And>y.\n       y \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2 \\<Longrightarrow>\n       restrict\n        (C2.lift\n          (\\<lambda>x. x \\<in> X \\<inter> Collect (y \\<circ> \\<iota>)))\n        (carrier \\<F>\\<^bsub>X\\<^esub>) =\n       y", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. (\\<lambda>S.\n        restrict (C2.lift (\\<lambda>x. x \\<in> S))\n         (carrier \\<F>\\<^bsub>X\\<^esub>))\n    \\<in> Pow X \\<rightarrow> homr \\<F>\\<^bsub>X\\<^esub> C2\n 2. (\\<lambda>h. X \\<inter> Collect (h \\<circ> \\<iota>))\n    \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2 \\<rightarrow> Pow X\n 3. \\<And>x.\n       x \\<in> Pow X \\<Longrightarrow>\n       X \\<inter>\n       Collect\n        (restrict (C2.lift (\\<lambda>xa. xa \\<in> x))\n          (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n         \\<iota>) =\n       x\n 4. \\<And>y.\n       y \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2 \\<Longrightarrow>\n       restrict\n        (C2.lift\n          (\\<lambda>x. x \\<in> X \\<inter> Collect (y \\<circ> \\<iota>)))\n        (carrier \\<F>\\<^bsub>X\\<^esub>) =\n       y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>S.\n        restrict (C2.lift (\\<lambda>x. x \\<in> S))\n         (carrier \\<F>\\<^bsub>X\\<^esub>))\n    \\<in> Pow X \\<rightarrow> homr \\<F>\\<^bsub>X\\<^esub> C2", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Pow X \\<Longrightarrow>\n       restrict (C2.lift (\\<lambda>xa. xa \\<in> x))\n        (carrier \\<F>\\<^bsub>X\\<^esub>)\n       \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2", "fix S"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Pow X \\<Longrightarrow>\n       restrict (C2.lift (\\<lambda>xa. xa \\<in> x))\n        (carrier \\<F>\\<^bsub>X\\<^esub>)\n       \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2", "assume \"S \\<in> Pow X\""], ["proof (state)\nthis:\n  S \\<in> Pow X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Pow X \\<Longrightarrow>\n       restrict (C2.lift (\\<lambda>xa. xa \\<in> x))\n        (carrier \\<F>\\<^bsub>X\\<^esub>)\n       \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2", "interpret h: group_hom \"\\<F>\\<^bsub>X\\<^esub>\" C2 \"C2.lift (\\<lambda>x. x \\<in> S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. group_hom \\<F>\\<^bsub>X\\<^esub> C2 (C2.lift (\\<lambda>x. x \\<in> S))", "by unfold_locales (auto intro: C2.lift_is_hom)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Pow X \\<Longrightarrow>\n       restrict (C2.lift (\\<lambda>xa. xa \\<in> x))\n        (carrier \\<F>\\<^bsub>X\\<^esub>)\n       \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2", "show \"?f S \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (C2.lift (\\<lambda>x. x \\<in> S))\n     (carrier \\<F>\\<^bsub>X\\<^esub>)\n    \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2", "by (rule h.restrict_hom)"], ["proof (state)\nthis:\n  restrict (C2.lift (\\<lambda>x. x \\<in> S)) (carrier \\<F>\\<^bsub>X\\<^esub>)\n  \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>S.\n      restrict (C2.lift (\\<lambda>x. x \\<in> S))\n       (carrier \\<F>\\<^bsub>X\\<^esub>))\n  \\<in> Pow X \\<rightarrow> homr \\<F>\\<^bsub>X\\<^esub> C2\n\ngoal (3 subgoals):\n 1. (\\<lambda>h. X \\<inter> Collect (h \\<circ> \\<iota>))\n    \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2 \\<rightarrow> Pow X\n 2. \\<And>x.\n       x \\<in> Pow X \\<Longrightarrow>\n       X \\<inter>\n       Collect\n        (restrict (C2.lift (\\<lambda>xa. xa \\<in> x))\n          (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n         \\<iota>) =\n       x\n 3. \\<And>y.\n       y \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2 \\<Longrightarrow>\n       restrict\n        (C2.lift\n          (\\<lambda>x. x \\<in> X \\<inter> Collect (y \\<circ> \\<iota>)))\n        (carrier \\<F>\\<^bsub>X\\<^esub>) =\n       y", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lambda>h. X \\<inter> Collect (h \\<circ> \\<iota>))\n    \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2 \\<rightarrow> Pow X\n 2. \\<And>x.\n       x \\<in> Pow X \\<Longrightarrow>\n       X \\<inter>\n       Collect\n        (restrict (C2.lift (\\<lambda>xa. xa \\<in> x))\n          (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n         \\<iota>) =\n       x\n 3. \\<And>y.\n       y \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2 \\<Longrightarrow>\n       restrict\n        (C2.lift\n          (\\<lambda>x. x \\<in> X \\<inter> Collect (y \\<circ> \\<iota>)))\n        (carrier \\<F>\\<^bsub>X\\<^esub>) =\n       y", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. (\\<lambda>h. X \\<inter> Collect (h \\<circ> \\<iota>))\n    \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2 \\<rightarrow> Pow X\n 2. \\<And>x.\n       x \\<in> Pow X \\<Longrightarrow>\n       X \\<inter>\n       Collect\n        (restrict (C2.lift (\\<lambda>xa. xa \\<in> x))\n          (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n         \\<iota>) =\n       x\n 3. \\<And>y.\n       y \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2 \\<Longrightarrow>\n       restrict\n        (C2.lift\n          (\\<lambda>x. x \\<in> X \\<inter> Collect (y \\<circ> \\<iota>)))\n        (carrier \\<F>\\<^bsub>X\\<^esub>) =\n       y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>h. X \\<inter> Collect (h \\<circ> \\<iota>))\n    \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2 \\<rightarrow> Pow X", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>h. X \\<inter> Collect (h \\<circ> \\<iota>))\n  \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2 \\<rightarrow> Pow X\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Pow X \\<Longrightarrow>\n       X \\<inter>\n       Collect\n        (restrict (C2.lift (\\<lambda>xa. xa \\<in> x))\n          (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n         \\<iota>) =\n       x\n 2. \\<And>y.\n       y \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2 \\<Longrightarrow>\n       restrict\n        (C2.lift\n          (\\<lambda>x. x \\<in> X \\<inter> Collect (y \\<circ> \\<iota>)))\n        (carrier \\<F>\\<^bsub>X\\<^esub>) =\n       y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Pow X \\<Longrightarrow>\n       X \\<inter>\n       Collect\n        (restrict (C2.lift (\\<lambda>xa. xa \\<in> x))\n          (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n         \\<iota>) =\n       x\n 2. \\<And>y.\n       y \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2 \\<Longrightarrow>\n       restrict\n        (C2.lift\n          (\\<lambda>x. x \\<in> X \\<inter> Collect (y \\<circ> \\<iota>)))\n        (carrier \\<F>\\<^bsub>X\\<^esub>) =\n       y", "case (3 S)"], ["proof (state)\nthis:\n  S \\<in> Pow X\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> Pow X \\<Longrightarrow>\n       X \\<inter>\n       Collect\n        (restrict (C2.lift (\\<lambda>xa. xa \\<in> x))\n          (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n         \\<iota>) =\n       x\n 2. \\<And>y.\n       y \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2 \\<Longrightarrow>\n       restrict\n        (C2.lift\n          (\\<lambda>x. x \\<in> X \\<inter> Collect (y \\<circ> \\<iota>)))\n        (carrier \\<F>\\<^bsub>X\\<^esub>) =\n       y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<inter>\n    Collect\n     (restrict (C2.lift (\\<lambda>x. x \\<in> S))\n       (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n      \\<iota>) =\n    S", "proof (induct rule: Set.set_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> X \\<inter>\n                Collect\n                 (restrict (C2.lift (\\<lambda>x. x \\<in> S))\n                   (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n                  \\<iota>)) =\n       (x \\<in> S)", "case (1 x)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<in> X \\<inter>\n                Collect\n                 (restrict (C2.lift (\\<lambda>x. x \\<in> S))\n                   (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n                  \\<iota>)) =\n       (x \\<in> S)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in> X \\<inter>\n             Collect\n              (restrict (C2.lift (\\<lambda>x. x \\<in> S))\n                (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n               \\<iota>)) =\n    (x \\<in> S)", "proof(cases \"x \\<in> X\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> X \\<Longrightarrow>\n    (x \\<in> X \\<inter>\n             Collect\n              (restrict (C2.lift (\\<lambda>x. x \\<in> S))\n                (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n               \\<iota>)) =\n    (x \\<in> S)\n 2. x \\<notin> X \\<Longrightarrow>\n    (x \\<in> X \\<inter>\n             Collect\n              (restrict (C2.lift (\\<lambda>x. x \\<in> S))\n                (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n               \\<iota>)) =\n    (x \\<in> S)", "case True"], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (2 subgoals):\n 1. x \\<in> X \\<Longrightarrow>\n    (x \\<in> X \\<inter>\n             Collect\n              (restrict (C2.lift (\\<lambda>x. x \\<in> S))\n                (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n               \\<iota>)) =\n    (x \\<in> S)\n 2. x \\<notin> X \\<Longrightarrow>\n    (x \\<in> X \\<inter>\n             Collect\n              (restrict (C2.lift (\\<lambda>x. x \\<in> S))\n                (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n               \\<iota>)) =\n    (x \\<in> S)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. (x \\<in> X \\<inter>\n             Collect\n              (restrict (C2.lift (\\<lambda>x. x \\<in> S))\n                (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n               \\<iota>)) =\n    (x \\<in> S)", "using insert_closed[of x X]"], ["proof (prove)\nusing this:\n  x \\<in> X\n  x \\<in> X \\<Longrightarrow> \\<iota> x \\<in> carrier \\<F>\\<^bsub>X\\<^esub>\n\ngoal (1 subgoal):\n 1. (x \\<in> X \\<inter>\n             Collect\n              (restrict (C2.lift (\\<lambda>x. x \\<in> S))\n                (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n               \\<iota>)) =\n    (x \\<in> S)", "by (auto simp add:insert_def C2.lift_def C2.lift_gi_def)"], ["proof (state)\nthis:\n  (x \\<in> X \\<inter>\n           Collect\n            (restrict (C2.lift (\\<lambda>x. x \\<in> S))\n              (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n             \\<iota>)) =\n  (x \\<in> S)\n\ngoal (1 subgoal):\n 1. x \\<notin> X \\<Longrightarrow>\n    (x \\<in> X \\<inter>\n             Collect\n              (restrict (C2.lift (\\<lambda>x. x \\<in> S))\n                (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n               \\<iota>)) =\n    (x \\<in> S)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> X \\<Longrightarrow>\n    (x \\<in> X \\<inter>\n             Collect\n              (restrict (C2.lift (\\<lambda>x. x \\<in> S))\n                (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n               \\<iota>)) =\n    (x \\<in> S)", "case False"], ["proof (state)\nthis:\n  x \\<notin> X\n\ngoal (1 subgoal):\n 1. x \\<notin> X \\<Longrightarrow>\n    (x \\<in> X \\<inter>\n             Collect\n              (restrict (C2.lift (\\<lambda>x. x \\<in> S))\n                (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n               \\<iota>)) =\n    (x \\<in> S)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> X\n\ngoal (1 subgoal):\n 1. (x \\<in> X \\<inter>\n             Collect\n              (restrict (C2.lift (\\<lambda>x. x \\<in> S))\n                (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n               \\<iota>)) =\n    (x \\<in> S)", "using 3"], ["proof (prove)\nusing this:\n  x \\<notin> X\n  S \\<in> Pow X\n\ngoal (1 subgoal):\n 1. (x \\<in> X \\<inter>\n             Collect\n              (restrict (C2.lift (\\<lambda>x. x \\<in> S))\n                (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n               \\<iota>)) =\n    (x \\<in> S)", "by auto"], ["proof (state)\nthis:\n  (x \\<in> X \\<inter>\n           Collect\n            (restrict (C2.lift (\\<lambda>x. x \\<in> S))\n              (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n             \\<iota>)) =\n  (x \\<in> S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x \\<in> X \\<inter>\n           Collect\n            (restrict (C2.lift (\\<lambda>x. x \\<in> S))\n              (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n             \\<iota>)) =\n  (x \\<in> S)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  X \\<inter>\n  Collect\n   (restrict (C2.lift (\\<lambda>x. x \\<in> S))\n     (carrier \\<F>\\<^bsub>X\\<^esub>) \\<circ>\n    \\<iota>) =\n  S\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2 \\<Longrightarrow>\n       restrict\n        (C2.lift\n          (\\<lambda>x. x \\<in> X \\<inter> Collect (y \\<circ> \\<iota>)))\n        (carrier \\<F>\\<^bsub>X\\<^esub>) =\n       y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2 \\<Longrightarrow>\n       restrict\n        (C2.lift\n          (\\<lambda>x. x \\<in> X \\<inter> Collect (y \\<circ> \\<iota>)))\n        (carrier \\<F>\\<^bsub>X\\<^esub>) =\n       y", "case (4 h)"], ["proof (state)\nthis:\n  h \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2 \\<Longrightarrow>\n       restrict\n        (C2.lift\n          (\\<lambda>x. x \\<in> X \\<inter> Collect (y \\<circ> \\<iota>)))\n        (carrier \\<F>\\<^bsub>X\\<^esub>) =\n       y", "hence hom: \"h \\<in> hom \\<F>\\<^bsub>X\\<^esub> C2\"\n      and extn: \"h \\<in> extensional (carrier \\<F>\\<^bsub>X\\<^esub>)\""], ["proof (prove)\nusing this:\n  h \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2\n\ngoal (1 subgoal):\n 1. h \\<in> hom \\<F>\\<^bsub>X\\<^esub> C2 &&&\n    h \\<in> extensional (carrier \\<F>\\<^bsub>X\\<^esub>)", "unfolding homr_def"], ["proof (prove)\nusing this:\n  h \\<in> {h \\<in> hom \\<F>\\<^bsub>X\\<^esub> C2.\n           h \\<in> extensional (carrier \\<F>\\<^bsub>X\\<^esub>)}\n\ngoal (1 subgoal):\n 1. h \\<in> hom \\<F>\\<^bsub>X\\<^esub> C2 &&&\n    h \\<in> extensional (carrier \\<F>\\<^bsub>X\\<^esub>)", "by auto"], ["proof (state)\nthis:\n  h \\<in> hom \\<F>\\<^bsub>X\\<^esub> C2\n  h \\<in> extensional (carrier \\<F>\\<^bsub>X\\<^esub>)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2 \\<Longrightarrow>\n       restrict\n        (C2.lift\n          (\\<lambda>x. x \\<in> X \\<inter> Collect (y \\<circ> \\<iota>)))\n        (carrier \\<F>\\<^bsub>X\\<^esub>) =\n       y", "have \"\\<forall>x \\<in> carrier \\<F>\\<^bsub>X\\<^esub> . h x = group.lift C2 (\\<lambda>z. z \\<in> X & (h \\<circ> FreeGroups.insert) z) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>carrier \\<F>\\<^bsub>X\\<^esub>.\n       h x = C2.lift (\\<lambda>z. z \\<in> X \\<and> (h \\<circ> \\<iota>) z) x", "by (rule C2.lift_is_unique[OF C2_is_group _ hom, of \"(\\<lambda>z. z \\<in> X & (h \\<circ> FreeGroups.insert) z)\"],\n             auto)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>carrier \\<F>\\<^bsub>X\\<^esub>.\n     h x = C2.lift (\\<lambda>z. z \\<in> X \\<and> (h \\<circ> \\<iota>) z) x\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> homr \\<F>\\<^bsub>X\\<^esub> C2 \\<Longrightarrow>\n       restrict\n        (C2.lift\n          (\\<lambda>x. x \\<in> X \\<inter> Collect (y \\<circ> \\<iota>)))\n        (carrier \\<F>\\<^bsub>X\\<^esub>) =\n       y", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>carrier \\<F>\\<^bsub>X\\<^esub>.\n     h x = C2.lift (\\<lambda>z. z \\<in> X \\<and> (h \\<circ> \\<iota>) z) x\n\ngoal (1 subgoal):\n 1. restrict\n     (C2.lift (\\<lambda>x. x \\<in> X \\<inter> Collect (h \\<circ> \\<iota>)))\n     (carrier \\<F>\\<^bsub>X\\<^esub>) =\n    h", "by -(rule extensionalityI[OF restrict_extensional extn], auto)"], ["proof (state)\nthis:\n  restrict\n   (C2.lift (\\<lambda>x. x \\<in> X \\<inter> Collect (h \\<circ> \\<iota>)))\n   (carrier \\<F>\\<^bsub>X\\<^esub>) =\n  h\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bij_betw\n   (\\<lambda>S.\n       restrict (C2.lift (\\<lambda>x. x \\<in> S))\n        (carrier \\<F>\\<^bsub>X\\<^esub>))\n   (Pow X) (homr \\<F>\\<^bsub>X\\<^esub> C2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma group_iso_betw_hom:\n  assumes \"group G1\" and \"group G2\"\n      and iso: \"i \\<in> iso G1 G2\"\n  shows   \"\\<exists> f . bij_betw f (homr G2 H) (homr G1 H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f (homr G2 H) (homr G1 H)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f (homr G2 H) (homr G1 H)", "interpret G2: group G2"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group G2", "by (rule \\<open>group G2\\<close>)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f (homr G2 H) (homr G1 H)", "let ?i' = \"restrict (inv_into (carrier G1) i) (carrier G2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f (homr G2 H) (homr G1 H)", "have \"inv_into (carrier G1) i \\<in> iso G2 G1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_into (carrier G1) i \\<in> Group.iso G2 G1", "by (simp add: \\<open>group G1\\<close> group.iso_set_sym iso)"], ["proof (state)\nthis:\n  inv_into (carrier G1) i \\<in> Group.iso G2 G1\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f (homr G2 H) (homr G1 H)", "hence iso': \"?i' \\<in> iso G2 G1\""], ["proof (prove)\nusing this:\n  inv_into (carrier G1) i \\<in> Group.iso G2 G1\n\ngoal (1 subgoal):\n 1. restrict (inv_into (carrier G1) i) (carrier G2) \\<in> Group.iso G2 G1", "by (auto simp add:Group.iso_def hom_def G2.m_closed)"], ["proof (state)\nthis:\n  restrict (inv_into (carrier G1) i) (carrier G2) \\<in> Group.iso G2 G1\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f (homr G2 H) (homr G1 H)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f (homr G2 H) (homr G1 H)", "proof(rule, induct rule: bij_betwI[of \"(\\<lambda>h. compose (carrier G1) h i)\" _ _ \"(\\<lambda>h. compose (carrier G2) h ?i')\"])"], ["proof (state)\ngoal (4 subgoals):\n 1. (\\<lambda>h. compose (carrier G1) h i)\n    \\<in> homr G2 H \\<rightarrow> homr G1 H\n 2. (\\<lambda>h.\n        compose (carrier G2) h\n         (restrict (inv_into (carrier G1) i) (carrier G2)))\n    \\<in> homr G1 H \\<rightarrow> homr G2 H\n 3. \\<And>x.\n       x \\<in> homr G2 H \\<Longrightarrow>\n       compose (carrier G2) (compose (carrier G1) x i)\n        (restrict (inv_into (carrier G1) i) (carrier G2)) =\n       x\n 4. \\<And>y.\n       y \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G1)\n        (compose (carrier G2) y\n          (restrict (inv_into (carrier G1) i) (carrier G2)))\n        i =\n       y", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. (\\<lambda>h. compose (carrier G1) h i)\n    \\<in> homr G2 H \\<rightarrow> homr G1 H\n 2. (\\<lambda>h.\n        compose (carrier G2) h\n         (restrict (inv_into (carrier G1) i) (carrier G2)))\n    \\<in> homr G1 H \\<rightarrow> homr G2 H\n 3. \\<And>x.\n       x \\<in> homr G2 H \\<Longrightarrow>\n       compose (carrier G2) (compose (carrier G1) x i)\n        (restrict (inv_into (carrier G1) i) (carrier G2)) =\n       x\n 4. \\<And>y.\n       y \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G1)\n        (compose (carrier G2) y\n          (restrict (inv_into (carrier G1) i) (carrier G2)))\n        i =\n       y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>h. compose (carrier G1) h i)\n    \\<in> homr G2 H \\<rightarrow> homr G1 H", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> homr G2 H \\<Longrightarrow>\n       compose (carrier G1) x i \\<in> homr G1 H", "fix h"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> homr G2 H \\<Longrightarrow>\n       compose (carrier G1) x i \\<in> homr G1 H", "assume \"h \\<in> homr G2 H\""], ["proof (state)\nthis:\n  h \\<in> homr G2 H\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> homr G2 H \\<Longrightarrow>\n       compose (carrier G1) x i \\<in> homr G1 H", "hence \"compose (carrier G1) h i \\<in> hom G1 H\""], ["proof (prove)\nusing this:\n  h \\<in> homr G2 H\n\ngoal (1 subgoal):\n 1. compose (carrier G1) h i \\<in> hom G1 H", "using iso"], ["proof (prove)\nusing this:\n  h \\<in> homr G2 H\n  i \\<in> Group.iso G1 G2\n\ngoal (1 subgoal):\n 1. compose (carrier G1) h i \\<in> hom G1 H", "by (auto intro: group.hom_compose[OF \\<open>group G1\\<close>, of _ G2] simp add:Group.iso_def homr_def)"], ["proof (state)\nthis:\n  compose (carrier G1) h i \\<in> hom G1 H\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> homr G2 H \\<Longrightarrow>\n       compose (carrier G1) x i \\<in> homr G1 H", "thus \"compose (carrier G1) h i \\<in> homr G1 H\""], ["proof (prove)\nusing this:\n  compose (carrier G1) h i \\<in> hom G1 H\n\ngoal (1 subgoal):\n 1. compose (carrier G1) h i \\<in> homr G1 H", "unfolding homr_def"], ["proof (prove)\nusing this:\n  compose (carrier G1) h i \\<in> hom G1 H\n\ngoal (1 subgoal):\n 1. compose (carrier G1) h i\n    \\<in> {h \\<in> hom G1 H. h \\<in> extensional (carrier G1)}", "by simp"], ["proof (state)\nthis:\n  compose (carrier G1) h i \\<in> homr G1 H\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>h. compose (carrier G1) h i)\n  \\<in> homr G2 H \\<rightarrow> homr G1 H\n\ngoal (3 subgoals):\n 1. (\\<lambda>h.\n        compose (carrier G2) h\n         (restrict (inv_into (carrier G1) i) (carrier G2)))\n    \\<in> homr G1 H \\<rightarrow> homr G2 H\n 2. \\<And>x.\n       x \\<in> homr G2 H \\<Longrightarrow>\n       compose (carrier G2) (compose (carrier G1) x i)\n        (restrict (inv_into (carrier G1) i) (carrier G2)) =\n       x\n 3. \\<And>y.\n       y \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G1)\n        (compose (carrier G2) y\n          (restrict (inv_into (carrier G1) i) (carrier G2)))\n        i =\n       y", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<lambda>h.\n        compose (carrier G2) h\n         (restrict (inv_into (carrier G1) i) (carrier G2)))\n    \\<in> homr G1 H \\<rightarrow> homr G2 H\n 2. \\<And>x.\n       x \\<in> homr G2 H \\<Longrightarrow>\n       compose (carrier G2) (compose (carrier G1) x i)\n        (restrict (inv_into (carrier G1) i) (carrier G2)) =\n       x\n 3. \\<And>y.\n       y \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G1)\n        (compose (carrier G2) y\n          (restrict (inv_into (carrier G1) i) (carrier G2)))\n        i =\n       y", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. (\\<lambda>h.\n        compose (carrier G2) h\n         (restrict (inv_into (carrier G1) i) (carrier G2)))\n    \\<in> homr G1 H \\<rightarrow> homr G2 H\n 2. \\<And>x.\n       x \\<in> homr G2 H \\<Longrightarrow>\n       compose (carrier G2) (compose (carrier G1) x i)\n        (restrict (inv_into (carrier G1) i) (carrier G2)) =\n       x\n 3. \\<And>y.\n       y \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G1)\n        (compose (carrier G2) y\n          (restrict (inv_into (carrier G1) i) (carrier G2)))\n        i =\n       y", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>h.\n        compose (carrier G2) h\n         (restrict (inv_into (carrier G1) i) (carrier G2)))\n    \\<in> homr G1 H \\<rightarrow> homr G2 H", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G2) x\n        (restrict (inv_into (carrier G1) i) (carrier G2))\n       \\<in> homr G2 H", "fix h"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G2) x\n        (restrict (inv_into (carrier G1) i) (carrier G2))\n       \\<in> homr G2 H", "assume \"h \\<in> homr G1 H\""], ["proof (state)\nthis:\n  h \\<in> homr G1 H\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G2) x\n        (restrict (inv_into (carrier G1) i) (carrier G2))\n       \\<in> homr G2 H", "hence \"compose (carrier G2) h ?i' \\<in> hom G2 H\""], ["proof (prove)\nusing this:\n  h \\<in> homr G1 H\n\ngoal (1 subgoal):\n 1. compose (carrier G2) h (restrict (inv_into (carrier G1) i) (carrier G2))\n    \\<in> hom G2 H", "using iso'"], ["proof (prove)\nusing this:\n  h \\<in> homr G1 H\n  restrict (inv_into (carrier G1) i) (carrier G2) \\<in> Group.iso G2 G1\n\ngoal (1 subgoal):\n 1. compose (carrier G2) h (restrict (inv_into (carrier G1) i) (carrier G2))\n    \\<in> hom G2 H", "by (auto intro: group.hom_compose[OF \\<open>group G2\\<close>, of _ G1] simp add:Group.iso_def homr_def)"], ["proof (state)\nthis:\n  compose (carrier G2) h (restrict (inv_into (carrier G1) i) (carrier G2))\n  \\<in> hom G2 H\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G2) x\n        (restrict (inv_into (carrier G1) i) (carrier G2))\n       \\<in> homr G2 H", "thus \"compose (carrier G2) h ?i' \\<in> homr G2 H\""], ["proof (prove)\nusing this:\n  compose (carrier G2) h (restrict (inv_into (carrier G1) i) (carrier G2))\n  \\<in> hom G2 H\n\ngoal (1 subgoal):\n 1. compose (carrier G2) h (restrict (inv_into (carrier G1) i) (carrier G2))\n    \\<in> homr G2 H", "unfolding homr_def"], ["proof (prove)\nusing this:\n  compose (carrier G2) h (restrict (inv_into (carrier G1) i) (carrier G2))\n  \\<in> hom G2 H\n\ngoal (1 subgoal):\n 1. compose (carrier G2) h (restrict (inv_into (carrier G1) i) (carrier G2))\n    \\<in> {h \\<in> hom G2 H. h \\<in> extensional (carrier G2)}", "by simp"], ["proof (state)\nthis:\n  compose (carrier G2) h (restrict (inv_into (carrier G1) i) (carrier G2))\n  \\<in> homr G2 H\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>h.\n      compose (carrier G2) h\n       (restrict (inv_into (carrier G1) i) (carrier G2)))\n  \\<in> homr G1 H \\<rightarrow> homr G2 H\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> homr G2 H \\<Longrightarrow>\n       compose (carrier G2) (compose (carrier G1) x i)\n        (restrict (inv_into (carrier G1) i) (carrier G2)) =\n       x\n 2. \\<And>y.\n       y \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G1)\n        (compose (carrier G2) y\n          (restrict (inv_into (carrier G1) i) (carrier G2)))\n        i =\n       y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> homr G2 H \\<Longrightarrow>\n       compose (carrier G2) (compose (carrier G1) x i)\n        (restrict (inv_into (carrier G1) i) (carrier G2)) =\n       x\n 2. \\<And>y.\n       y \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G1)\n        (compose (carrier G2) y\n          (restrict (inv_into (carrier G1) i) (carrier G2)))\n        i =\n       y", "case (3 x)"], ["proof (state)\nthis:\n  x \\<in> homr G2 H\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> homr G2 H \\<Longrightarrow>\n       compose (carrier G2) (compose (carrier G1) x i)\n        (restrict (inv_into (carrier G1) i) (carrier G2)) =\n       x\n 2. \\<And>y.\n       y \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G1)\n        (compose (carrier G2) y\n          (restrict (inv_into (carrier G1) i) (carrier G2)))\n        i =\n       y", "hence \"compose (carrier G2) (compose (carrier G1) x i) ?i'\n          = compose (carrier G2) x (compose (carrier G2) i ?i')\""], ["proof (prove)\nusing this:\n  x \\<in> homr G2 H\n\ngoal (1 subgoal):\n 1. compose (carrier G2) (compose (carrier G1) x i)\n     (restrict (inv_into (carrier G1) i) (carrier G2)) =\n    compose (carrier G2) x\n     (compose (carrier G2) i\n       (restrict (inv_into (carrier G1) i) (carrier G2)))", "using iso iso'"], ["proof (prove)\nusing this:\n  x \\<in> homr G2 H\n  i \\<in> Group.iso G1 G2\n  restrict (inv_into (carrier G1) i) (carrier G2) \\<in> Group.iso G2 G1\n\ngoal (1 subgoal):\n 1. compose (carrier G2) (compose (carrier G1) x i)\n     (restrict (inv_into (carrier G1) i) (carrier G2)) =\n    compose (carrier G2) x\n     (compose (carrier G2) i\n       (restrict (inv_into (carrier G1) i) (carrier G2)))", "by (auto intro: compose_assoc[THEN sym]   simp add:Group.iso_def hom_def homr_def)"], ["proof (state)\nthis:\n  compose (carrier G2) (compose (carrier G1) x i)\n   (restrict (inv_into (carrier G1) i) (carrier G2)) =\n  compose (carrier G2) x\n   (compose (carrier G2) i\n     (restrict (inv_into (carrier G1) i) (carrier G2)))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> homr G2 H \\<Longrightarrow>\n       compose (carrier G2) (compose (carrier G1) x i)\n        (restrict (inv_into (carrier G1) i) (carrier G2)) =\n       x\n 2. \\<And>y.\n       y \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G1)\n        (compose (carrier G2) y\n          (restrict (inv_into (carrier G1) i) (carrier G2)))\n        i =\n       y", "also"], ["proof (state)\nthis:\n  compose (carrier G2) (compose (carrier G1) x i)\n   (restrict (inv_into (carrier G1) i) (carrier G2)) =\n  compose (carrier G2) x\n   (compose (carrier G2) i\n     (restrict (inv_into (carrier G1) i) (carrier G2)))\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> homr G2 H \\<Longrightarrow>\n       compose (carrier G2) (compose (carrier G1) x i)\n        (restrict (inv_into (carrier G1) i) (carrier G2)) =\n       x\n 2. \\<And>y.\n       y \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G1)\n        (compose (carrier G2) y\n          (restrict (inv_into (carrier G1) i) (carrier G2)))\n        i =\n       y", "have \"\\<dots> = compose (carrier G2) x (\\<lambda>y\\<in>carrier G2. y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compose (carrier G2) x\n     (compose (carrier G2) i\n       (restrict (inv_into (carrier G1) i) (carrier G2))) =\n    compose (carrier G2) x (\\<lambda>y\\<in>carrier G2. y)", "using iso"], ["proof (prove)\nusing this:\n  i \\<in> Group.iso G1 G2\n\ngoal (1 subgoal):\n 1. compose (carrier G2) x\n     (compose (carrier G2) i\n       (restrict (inv_into (carrier G1) i) (carrier G2))) =\n    compose (carrier G2) x (\\<lambda>y\\<in>carrier G2. y)", "by (subst compose_id_inv_into, auto simp add:Group.iso_def hom_def bij_betw_def)"], ["proof (state)\nthis:\n  compose (carrier G2) x\n   (compose (carrier G2) i\n     (restrict (inv_into (carrier G1) i) (carrier G2))) =\n  compose (carrier G2) x (\\<lambda>y\\<in>carrier G2. y)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> homr G2 H \\<Longrightarrow>\n       compose (carrier G2) (compose (carrier G1) x i)\n        (restrict (inv_into (carrier G1) i) (carrier G2)) =\n       x\n 2. \\<And>y.\n       y \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G1)\n        (compose (carrier G2) y\n          (restrict (inv_into (carrier G1) i) (carrier G2)))\n        i =\n       y", "also"], ["proof (state)\nthis:\n  compose (carrier G2) x\n   (compose (carrier G2) i\n     (restrict (inv_into (carrier G1) i) (carrier G2))) =\n  compose (carrier G2) x (\\<lambda>y\\<in>carrier G2. y)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> homr G2 H \\<Longrightarrow>\n       compose (carrier G2) (compose (carrier G1) x i)\n        (restrict (inv_into (carrier G1) i) (carrier G2)) =\n       x\n 2. \\<And>y.\n       y \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G1)\n        (compose (carrier G2) y\n          (restrict (inv_into (carrier G1) i) (carrier G2)))\n        i =\n       y", "have \"\\<dots> = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compose (carrier G2) x (\\<lambda>y\\<in>carrier G2. y) = x", "using 3"], ["proof (prove)\nusing this:\n  x \\<in> homr G2 H\n\ngoal (1 subgoal):\n 1. compose (carrier G2) x (\\<lambda>y\\<in>carrier G2. y) = x", "by (auto intro:compose_Id simp add:homr_def)"], ["proof (state)\nthis:\n  compose (carrier G2) x (\\<lambda>y\\<in>carrier G2. y) = x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> homr G2 H \\<Longrightarrow>\n       compose (carrier G2) (compose (carrier G1) x i)\n        (restrict (inv_into (carrier G1) i) (carrier G2)) =\n       x\n 2. \\<And>y.\n       y \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G1)\n        (compose (carrier G2) y\n          (restrict (inv_into (carrier G1) i) (carrier G2)))\n        i =\n       y", "finally"], ["proof (chain)\npicking this:\n  compose (carrier G2) (compose (carrier G1) x i)\n   (restrict (inv_into (carrier G1) i) (carrier G2)) =\n  x", "show ?case"], ["proof (prove)\nusing this:\n  compose (carrier G2) (compose (carrier G1) x i)\n   (restrict (inv_into (carrier G1) i) (carrier G2)) =\n  x\n\ngoal (1 subgoal):\n 1. compose (carrier G2) (compose (carrier G1) x i)\n     (restrict (inv_into (carrier G1) i) (carrier G2)) =\n    x", "."], ["proof (state)\nthis:\n  compose (carrier G2) (compose (carrier G1) x i)\n   (restrict (inv_into (carrier G1) i) (carrier G2)) =\n  x\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G1)\n        (compose (carrier G2) y\n          (restrict (inv_into (carrier G1) i) (carrier G2)))\n        i =\n       y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G1)\n        (compose (carrier G2) y\n          (restrict (inv_into (carrier G1) i) (carrier G2)))\n        i =\n       y", "case (4 y)"], ["proof (state)\nthis:\n  y \\<in> homr G1 H\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G1)\n        (compose (carrier G2) y\n          (restrict (inv_into (carrier G1) i) (carrier G2)))\n        i =\n       y", "hence \"compose (carrier G1) (compose (carrier G2) y ?i') i\n          = compose (carrier G1) y (compose (carrier G1) ?i' i)\""], ["proof (prove)\nusing this:\n  y \\<in> homr G1 H\n\ngoal (1 subgoal):\n 1. compose (carrier G1)\n     (compose (carrier G2) y\n       (restrict (inv_into (carrier G1) i) (carrier G2)))\n     i =\n    compose (carrier G1) y\n     (compose (carrier G1) (restrict (inv_into (carrier G1) i) (carrier G2))\n       i)", "using iso iso'"], ["proof (prove)\nusing this:\n  y \\<in> homr G1 H\n  i \\<in> Group.iso G1 G2\n  restrict (inv_into (carrier G1) i) (carrier G2) \\<in> Group.iso G2 G1\n\ngoal (1 subgoal):\n 1. compose (carrier G1)\n     (compose (carrier G2) y\n       (restrict (inv_into (carrier G1) i) (carrier G2)))\n     i =\n    compose (carrier G1) y\n     (compose (carrier G1) (restrict (inv_into (carrier G1) i) (carrier G2))\n       i)", "by (auto intro: compose_assoc[THEN sym] simp add:Group.iso_def hom_def homr_def)"], ["proof (state)\nthis:\n  compose (carrier G1)\n   (compose (carrier G2) y\n     (restrict (inv_into (carrier G1) i) (carrier G2)))\n   i =\n  compose (carrier G1) y\n   (compose (carrier G1) (restrict (inv_into (carrier G1) i) (carrier G2))\n     i)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G1)\n        (compose (carrier G2) y\n          (restrict (inv_into (carrier G1) i) (carrier G2)))\n        i =\n       y", "also"], ["proof (state)\nthis:\n  compose (carrier G1)\n   (compose (carrier G2) y\n     (restrict (inv_into (carrier G1) i) (carrier G2)))\n   i =\n  compose (carrier G1) y\n   (compose (carrier G1) (restrict (inv_into (carrier G1) i) (carrier G2))\n     i)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G1)\n        (compose (carrier G2) y\n          (restrict (inv_into (carrier G1) i) (carrier G2)))\n        i =\n       y", "have \"\\<dots> = compose (carrier G1) y (\\<lambda>x\\<in>carrier G1. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compose (carrier G1) y\n     (compose (carrier G1) (restrict (inv_into (carrier G1) i) (carrier G2))\n       i) =\n    compose (carrier G1) y (\\<lambda>x\\<in>carrier G1. x)", "using iso"], ["proof (prove)\nusing this:\n  i \\<in> Group.iso G1 G2\n\ngoal (1 subgoal):\n 1. compose (carrier G1) y\n     (compose (carrier G1) (restrict (inv_into (carrier G1) i) (carrier G2))\n       i) =\n    compose (carrier G1) y (\\<lambda>x\\<in>carrier G1. x)", "by (subst compose_inv_into_id, auto simp add:Group.iso_def hom_def bij_betw_def)"], ["proof (state)\nthis:\n  compose (carrier G1) y\n   (compose (carrier G1) (restrict (inv_into (carrier G1) i) (carrier G2))\n     i) =\n  compose (carrier G1) y (\\<lambda>x\\<in>carrier G1. x)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G1)\n        (compose (carrier G2) y\n          (restrict (inv_into (carrier G1) i) (carrier G2)))\n        i =\n       y", "also"], ["proof (state)\nthis:\n  compose (carrier G1) y\n   (compose (carrier G1) (restrict (inv_into (carrier G1) i) (carrier G2))\n     i) =\n  compose (carrier G1) y (\\<lambda>x\\<in>carrier G1. x)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G1)\n        (compose (carrier G2) y\n          (restrict (inv_into (carrier G1) i) (carrier G2)))\n        i =\n       y", "have \"\\<dots> = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compose (carrier G1) y (\\<lambda>x\\<in>carrier G1. x) = y", "using 4"], ["proof (prove)\nusing this:\n  y \\<in> homr G1 H\n\ngoal (1 subgoal):\n 1. compose (carrier G1) y (\\<lambda>x\\<in>carrier G1. x) = y", "by (auto intro:compose_Id simp add:homr_def)"], ["proof (state)\nthis:\n  compose (carrier G1) y (\\<lambda>x\\<in>carrier G1. x) = y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> homr G1 H \\<Longrightarrow>\n       compose (carrier G1)\n        (compose (carrier G2) y\n          (restrict (inv_into (carrier G1) i) (carrier G2)))\n        i =\n       y", "finally"], ["proof (chain)\npicking this:\n  compose (carrier G1)\n   (compose (carrier G2) y\n     (restrict (inv_into (carrier G1) i) (carrier G2)))\n   i =\n  y", "show ?case"], ["proof (prove)\nusing this:\n  compose (carrier G1)\n   (compose (carrier G2) y\n     (restrict (inv_into (carrier G1) i) (carrier G2)))\n   i =\n  y\n\ngoal (1 subgoal):\n 1. compose (carrier G1)\n     (compose (carrier G2) y\n       (restrict (inv_into (carrier G1) i) (carrier G2)))\n     i =\n    y", "."], ["proof (state)\nthis:\n  compose (carrier G1)\n   (compose (carrier G2) y\n     (restrict (inv_into (carrier G1) i) (carrier G2)))\n   i =\n  y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f. bij_betw f (homr G2 H) (homr G1 H)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isomorphic_free_groups_bases_finite:\n  assumes iso: \"i \\<in> iso \\<F>\\<^bsub>X\\<^esub> \\<F>\\<^bsub>Y\\<^esub>\"\n      and finite: \"finite X\"\n  shows \"\\<exists>f. bij_betw f X Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f X Y", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f X Y", "obtain f\n    where \"bij_betw f (homr \\<F>\\<^bsub>Y\\<^esub> C2) (homr \\<F>\\<^bsub>X\\<^esub> C2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        bij_betw f (homr \\<F>\\<^bsub>Y\\<^esub> C2)\n         (homr \\<F>\\<^bsub>X\\<^esub> C2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using group_iso_betw_hom[OF free_group_is_group free_group_is_group iso]"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     bij_betw f (homr \\<F>\\<^bsub>Y\\<^esub> ?H)\n      (homr \\<F>\\<^bsub>X\\<^esub> ?H)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        bij_betw f (homr \\<F>\\<^bsub>Y\\<^esub> C2)\n         (homr \\<F>\\<^bsub>X\\<^esub> C2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  bij_betw f (homr \\<F>\\<^bsub>Y\\<^esub> C2) (homr \\<F>\\<^bsub>X\\<^esub> C2)\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f X Y", "moreover"], ["proof (state)\nthis:\n  bij_betw f (homr \\<F>\\<^bsub>Y\\<^esub> C2) (homr \\<F>\\<^bsub>X\\<^esub> C2)\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f X Y", "obtain g'\n    where \"bij_betw g' (Pow X) (homr (\\<F>\\<^bsub>X\\<^esub>) C2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g'.\n        bij_betw g' (Pow X)\n         (homr \\<F>\\<^bsub>X\\<^esub> C2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using hom_F_C2_Powerset"], ["proof (prove)\nusing this:\n  \\<exists>f. bij_betw f (Pow ?X) (homr \\<F>\\<^bsub>?X\\<^esub> C2)\n\ngoal (1 subgoal):\n 1. (\\<And>g'.\n        bij_betw g' (Pow X)\n         (homr \\<F>\\<^bsub>X\\<^esub> C2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  bij_betw g' (Pow X) (homr \\<F>\\<^bsub>X\\<^esub> C2)\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f X Y", "then"], ["proof (chain)\npicking this:\n  bij_betw g' (Pow X) (homr \\<F>\\<^bsub>X\\<^esub> C2)", "obtain g\n    where \"bij_betw g (homr (\\<F>\\<^bsub>X\\<^esub>) C2) (Pow X)\""], ["proof (prove)\nusing this:\n  bij_betw g' (Pow X) (homr \\<F>\\<^bsub>X\\<^esub> C2)\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        bij_betw g (homr \\<F>\\<^bsub>X\\<^esub> C2) (Pow X) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto intro: bij_betw_inv_into)"], ["proof (state)\nthis:\n  bij_betw g (homr \\<F>\\<^bsub>X\\<^esub> C2) (Pow X)\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f X Y", "moreover"], ["proof (state)\nthis:\n  bij_betw g (homr \\<F>\\<^bsub>X\\<^esub> C2) (Pow X)\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f X Y", "obtain h\n    where \"bij_betw h (Pow Y) (homr (\\<F>\\<^bsub>Y\\<^esub>) C2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h.\n        bij_betw h (Pow Y) (homr \\<F>\\<^bsub>Y\\<^esub> C2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using hom_F_C2_Powerset"], ["proof (prove)\nusing this:\n  \\<exists>f. bij_betw f (Pow ?X) (homr \\<F>\\<^bsub>?X\\<^esub> C2)\n\ngoal (1 subgoal):\n 1. (\\<And>h.\n        bij_betw h (Pow Y) (homr \\<F>\\<^bsub>Y\\<^esub> C2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  bij_betw h (Pow Y) (homr \\<F>\\<^bsub>Y\\<^esub> C2)\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f X Y", "ultimately"], ["proof (chain)\npicking this:\n  bij_betw f (homr \\<F>\\<^bsub>Y\\<^esub> C2) (homr \\<F>\\<^bsub>X\\<^esub> C2)\n  bij_betw g (homr \\<F>\\<^bsub>X\\<^esub> C2) (Pow X)\n  bij_betw h (Pow Y) (homr \\<F>\\<^bsub>Y\\<^esub> C2)", "have \"bij_betw (g \\<circ> f \\<circ> h) (Pow Y) (Pow X)\""], ["proof (prove)\nusing this:\n  bij_betw f (homr \\<F>\\<^bsub>Y\\<^esub> C2) (homr \\<F>\\<^bsub>X\\<^esub> C2)\n  bij_betw g (homr \\<F>\\<^bsub>X\\<^esub> C2) (Pow X)\n  bij_betw h (Pow Y) (homr \\<F>\\<^bsub>Y\\<^esub> C2)\n\ngoal (1 subgoal):\n 1. bij_betw (g \\<circ> f \\<circ> h) (Pow Y) (Pow X)", "by (auto intro: bij_betw_trans)"], ["proof (state)\nthis:\n  bij_betw (g \\<circ> f \\<circ> h) (Pow Y) (Pow X)\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f X Y", "hence eq_card: \"card (Pow Y) = card (Pow X)\""], ["proof (prove)\nusing this:\n  bij_betw (g \\<circ> f \\<circ> h) (Pow Y) (Pow X)\n\ngoal (1 subgoal):\n 1. card (Pow Y) = card (Pow X)", "by (rule bij_betw_same_card)"], ["proof (state)\nthis:\n  card (Pow Y) = card (Pow X)\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f X Y", "with finite"], ["proof (chain)\npicking this:\n  finite X\n  card (Pow Y) = card (Pow X)", "have \"finite (Pow Y)\""], ["proof (prove)\nusing this:\n  finite X\n  card (Pow Y) = card (Pow X)\n\ngoal (1 subgoal):\n 1. finite (Pow Y)", "by -(rule card_ge_0_finite, auto simp add:card_Pow)"], ["proof (state)\nthis:\n  finite (Pow Y)\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f X Y", "hence finite': \"finite Y\""], ["proof (prove)\nusing this:\n  finite (Pow Y)\n\ngoal (1 subgoal):\n 1. finite Y", "by simp"], ["proof (state)\nthis:\n  finite Y\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f X Y", "with eq_card finite"], ["proof (chain)\npicking this:\n  card (Pow Y) = card (Pow X)\n  finite X\n  finite Y", "have \"card X = card Y\""], ["proof (prove)\nusing this:\n  card (Pow Y) = card (Pow X)\n  finite X\n  finite Y\n\ngoal (1 subgoal):\n 1. card X = card Y", "by (auto simp add:card_Pow)"], ["proof (state)\nthis:\n  card X = card Y\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f X Y", "with finite finite'"], ["proof (chain)\npicking this:\n  finite X\n  finite Y\n  card X = card Y", "show ?thesis"], ["proof (prove)\nusing this:\n  finite X\n  finite Y\n  card X = card Y\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f X Y", "by (rule finite_same_card_bij)"], ["proof (state)\nthis:\n  \\<exists>f. bij_betw f X Y\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThe proof for the infinite case is trivial once the fact that the free group\nover an infinite set has the same cardinality is established.\n\\<close>"], ["", "lemma free_group_card_infinite:\n  assumes \"\\<not> finite X\"\n  shows \"|X| =o |carrier \\<F>\\<^bsub>X\\<^esub>|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |X| =o |carrier \\<F>\\<^bsub>X\\<^esub>|", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. |X| =o |carrier \\<F>\\<^bsub>X\\<^esub>|", "have \"inj_on insert X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on \\<iota> X", "by (rule inj_onI) (auto simp add: insert_def)"], ["proof (state)\nthis:\n  inj_on \\<iota> X\n\ngoal (1 subgoal):\n 1. |X| =o |carrier \\<F>\\<^bsub>X\\<^esub>|", "moreover"], ["proof (state)\nthis:\n  inj_on \\<iota> X\n\ngoal (1 subgoal):\n 1. |X| =o |carrier \\<F>\\<^bsub>X\\<^esub>|", "have \"insert ` X \\<subseteq> carrier \\<F>\\<^bsub>X\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<iota> ` X \\<subseteq> carrier \\<F>\\<^bsub>X\\<^esub>", "by (auto intro: insert_closed)"], ["proof (state)\nthis:\n  \\<iota> ` X \\<subseteq> carrier \\<F>\\<^bsub>X\\<^esub>\n\ngoal (1 subgoal):\n 1. |X| =o |carrier \\<F>\\<^bsub>X\\<^esub>|", "ultimately"], ["proof (chain)\npicking this:\n  inj_on \\<iota> X\n  \\<iota> ` X \\<subseteq> carrier \\<F>\\<^bsub>X\\<^esub>", "have \"\\<exists>f. inj_on f X \\<and> f ` X \\<subseteq> carrier \\<F>\\<^bsub>X\\<^esub>\""], ["proof (prove)\nusing this:\n  inj_on \\<iota> X\n  \\<iota> ` X \\<subseteq> carrier \\<F>\\<^bsub>X\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       inj_on f X \\<and> f ` X \\<subseteq> carrier \\<F>\\<^bsub>X\\<^esub>", "by auto"], ["proof (state)\nthis:\n  \\<exists>f.\n     inj_on f X \\<and> f ` X \\<subseteq> carrier \\<F>\\<^bsub>X\\<^esub>\n\ngoal (1 subgoal):\n 1. |X| =o |carrier \\<F>\\<^bsub>X\\<^esub>|", "then"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     inj_on f X \\<and> f ` X \\<subseteq> carrier \\<F>\\<^bsub>X\\<^esub>", "have \"|X| \\<le>o |carrier \\<F>\\<^bsub>X\\<^esub>|\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     inj_on f X \\<and> f ` X \\<subseteq> carrier \\<F>\\<^bsub>X\\<^esub>\n\ngoal (1 subgoal):\n 1. |X| \\<le>o |carrier \\<F>\\<^bsub>X\\<^esub>|", "by (simp add: card_of_ordLeq)"], ["proof (state)\nthis:\n  |X| \\<le>o |carrier \\<F>\\<^bsub>X\\<^esub>|\n\ngoal (1 subgoal):\n 1. |X| =o |carrier \\<F>\\<^bsub>X\\<^esub>|", "moreover"], ["proof (state)\nthis:\n  |X| \\<le>o |carrier \\<F>\\<^bsub>X\\<^esub>|\n\ngoal (1 subgoal):\n 1. |X| =o |carrier \\<F>\\<^bsub>X\\<^esub>|", "have \"|carrier \\<F>\\<^bsub>X\\<^esub>| \\<le>o |lists ((UNIV::bool set)\\<times>X)|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |carrier \\<F>\\<^bsub>X\\<^esub>| \\<le>o |lists (UNIV \\<times> X)|", "by (auto intro!:card_of_mono1 simp add:free_group_def)"], ["proof (state)\nthis:\n  |carrier \\<F>\\<^bsub>X\\<^esub>| \\<le>o |lists (UNIV \\<times> X)|\n\ngoal (1 subgoal):\n 1. |X| =o |carrier \\<F>\\<^bsub>X\\<^esub>|", "moreover"], ["proof (state)\nthis:\n  |carrier \\<F>\\<^bsub>X\\<^esub>| \\<le>o |lists (UNIV \\<times> X)|\n\ngoal (1 subgoal):\n 1. |X| =o |carrier \\<F>\\<^bsub>X\\<^esub>|", "have \"|lists ((UNIV::bool set)\\<times>X)| =o |(UNIV::bool set)\\<times>X|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |lists (UNIV \\<times> X)| =o |UNIV \\<times> X|", "using \\<open>\\<not> finite X\\<close>"], ["proof (prove)\nusing this:\n  infinite X\n\ngoal (1 subgoal):\n 1. |lists (UNIV \\<times> X)| =o |UNIV \\<times> X|", "by (auto intro:card_of_lists_infinite dest!:finite_cartesian_productD2)"], ["proof (state)\nthis:\n  |lists (UNIV \\<times> X)| =o |UNIV \\<times> X|\n\ngoal (1 subgoal):\n 1. |X| =o |carrier \\<F>\\<^bsub>X\\<^esub>|", "moreover"], ["proof (state)\nthis:\n  |lists (UNIV \\<times> X)| =o |UNIV \\<times> X|\n\ngoal (1 subgoal):\n 1. |X| =o |carrier \\<F>\\<^bsub>X\\<^esub>|", "have  \"|(UNIV::bool set)\\<times>X| =o |X|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |UNIV \\<times> X| =o |X|", "using \\<open>\\<not> finite X\\<close>"], ["proof (prove)\nusing this:\n  infinite X\n\ngoal (1 subgoal):\n 1. |UNIV \\<times> X| =o |X|", "by (auto intro: card_of_Times_infinite[OF _ _ ordLess_imp_ordLeq[OF finite_ordLess_infinite2], THEN conjunct2])"], ["proof (state)\nthis:\n  |UNIV \\<times> X| =o |X|\n\ngoal (1 subgoal):\n 1. |X| =o |carrier \\<F>\\<^bsub>X\\<^esub>|", "ultimately"], ["proof (chain)\npicking this:\n  |X| \\<le>o |carrier \\<F>\\<^bsub>X\\<^esub>|\n  |carrier \\<F>\\<^bsub>X\\<^esub>| \\<le>o |lists (UNIV \\<times> X)|\n  |lists (UNIV \\<times> X)| =o |UNIV \\<times> X|\n  |UNIV \\<times> X| =o |X|", "show \"|X| =o |carrier \\<F>\\<^bsub>X\\<^esub>|\""], ["proof (prove)\nusing this:\n  |X| \\<le>o |carrier \\<F>\\<^bsub>X\\<^esub>|\n  |carrier \\<F>\\<^bsub>X\\<^esub>| \\<le>o |lists (UNIV \\<times> X)|\n  |lists (UNIV \\<times> X)| =o |UNIV \\<times> X|\n  |UNIV \\<times> X| =o |X|\n\ngoal (1 subgoal):\n 1. |X| =o |carrier \\<F>\\<^bsub>X\\<^esub>|", "by (subst ordIso_iff_ordLeq, auto intro: ord_trans)"], ["proof (state)\nthis:\n  |X| =o |carrier \\<F>\\<^bsub>X\\<^esub>|\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem isomorphic_free_groups_bases:\n  assumes iso: \"i \\<in> iso \\<F>\\<^bsub>X\\<^esub> \\<F>\\<^bsub>Y\\<^esub>\"\n  shows \"\\<exists>f. bij_betw f X Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f X Y", "proof(cases \"finite X\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow> \\<exists>f. bij_betw f X Y\n 2. infinite X \\<Longrightarrow> \\<exists>f. bij_betw f X Y", "case True"], ["proof (state)\nthis:\n  finite X\n\ngoal (2 subgoals):\n 1. finite X \\<Longrightarrow> \\<exists>f. bij_betw f X Y\n 2. infinite X \\<Longrightarrow> \\<exists>f. bij_betw f X Y", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f X Y", "using iso"], ["proof (prove)\nusing this:\n  finite X\n  i \\<in> Group.iso \\<F>\\<^bsub>X\\<^esub> \\<F>\\<^bsub>Y\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f X Y", "by -(rule isomorphic_free_groups_bases_finite)"], ["proof (state)\nthis:\n  \\<exists>f. bij_betw f X Y\n\ngoal (1 subgoal):\n 1. infinite X \\<Longrightarrow> \\<exists>f. bij_betw f X Y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite X \\<Longrightarrow> \\<exists>f. bij_betw f X Y", "case False"], ["proof (state)\nthis:\n  infinite X\n\ngoal (1 subgoal):\n 1. infinite X \\<Longrightarrow> \\<exists>f. bij_betw f X Y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f X Y", "proof(cases \"finite Y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. finite Y \\<Longrightarrow> \\<exists>f. bij_betw f X Y\n 2. infinite Y \\<Longrightarrow> \\<exists>f. bij_betw f X Y", "case True"], ["proof (state)\nthis:\n  finite Y\n\ngoal (2 subgoals):\n 1. finite Y \\<Longrightarrow> \\<exists>f. bij_betw f X Y\n 2. infinite Y \\<Longrightarrow> \\<exists>f. bij_betw f X Y", "from iso"], ["proof (chain)\npicking this:\n  i \\<in> Group.iso \\<F>\\<^bsub>X\\<^esub> \\<F>\\<^bsub>Y\\<^esub>", "obtain i' where \"i' \\<in> iso \\<F>\\<^bsub>Y\\<^esub> \\<F>\\<^bsub>X\\<^esub>\""], ["proof (prove)\nusing this:\n  i \\<in> Group.iso \\<F>\\<^bsub>X\\<^esub> \\<F>\\<^bsub>Y\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        i' \\<in> Group.iso \\<F>\\<^bsub>Y\\<^esub>\n                  \\<F>\\<^bsub>X\\<^esub> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using free_group_is_group group.iso_set_sym"], ["proof (prove)\nusing this:\n  i \\<in> Group.iso \\<F>\\<^bsub>X\\<^esub> \\<F>\\<^bsub>Y\\<^esub>\n  Group.group \\<F>\\<^bsub>?gens\\<^esub>\n  \\<lbrakk>Group.group ?G; ?h \\<in> Group.iso ?G ?H\\<rbrakk>\n  \\<Longrightarrow> inv_into (carrier ?G) ?h \\<in> Group.iso ?H ?G\n\ngoal (1 subgoal):\n 1. (\\<And>i'.\n        i' \\<in> Group.iso \\<F>\\<^bsub>Y\\<^esub>\n                  \\<F>\\<^bsub>X\\<^esub> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i' \\<in> Group.iso \\<F>\\<^bsub>Y\\<^esub> \\<F>\\<^bsub>X\\<^esub>\n\ngoal (2 subgoals):\n 1. finite Y \\<Longrightarrow> \\<exists>f. bij_betw f X Y\n 2. infinite Y \\<Longrightarrow> \\<exists>f. bij_betw f X Y", "with \\<open>finite Y\\<close>"], ["proof (chain)\npicking this:\n  finite Y\n  i' \\<in> Group.iso \\<F>\\<^bsub>Y\\<^esub> \\<F>\\<^bsub>X\\<^esub>", "have \"\\<exists>f. bij_betw f Y X\""], ["proof (prove)\nusing this:\n  finite Y\n  i' \\<in> Group.iso \\<F>\\<^bsub>Y\\<^esub> \\<F>\\<^bsub>X\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f Y X", "by -(rule isomorphic_free_groups_bases_finite)"], ["proof (state)\nthis:\n  \\<exists>f. bij_betw f Y X\n\ngoal (2 subgoals):\n 1. finite Y \\<Longrightarrow> \\<exists>f. bij_betw f X Y\n 2. infinite Y \\<Longrightarrow> \\<exists>f. bij_betw f X Y", "thus \"\\<exists>f. bij_betw f X Y\""], ["proof (prove)\nusing this:\n  \\<exists>f. bij_betw f Y X\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f X Y", "by (auto intro: bij_betw_the_inv_into)"], ["proof (state)\nthis:\n  \\<exists>f. bij_betw f X Y\n\ngoal (1 subgoal):\n 1. infinite Y \\<Longrightarrow> \\<exists>f. bij_betw f X Y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite Y \\<Longrightarrow> \\<exists>f. bij_betw f X Y", "case False"], ["proof (state)\nthis:\n  infinite Y\n\ngoal (1 subgoal):\n 1. infinite Y \\<Longrightarrow> \\<exists>f. bij_betw f X Y", "from \\<open>\\<not> finite X\\<close>"], ["proof (chain)\npicking this:\n  infinite X", "have \"|X| =o |carrier \\<F>\\<^bsub>X\\<^esub>|\""], ["proof (prove)\nusing this:\n  infinite X\n\ngoal (1 subgoal):\n 1. |X| =o |carrier \\<F>\\<^bsub>X\\<^esub>|", "by (rule free_group_card_infinite)"], ["proof (state)\nthis:\n  |X| =o |carrier \\<F>\\<^bsub>X\\<^esub>|\n\ngoal (1 subgoal):\n 1. infinite Y \\<Longrightarrow> \\<exists>f. bij_betw f X Y", "moreover"], ["proof (state)\nthis:\n  |X| =o |carrier \\<F>\\<^bsub>X\\<^esub>|\n\ngoal (1 subgoal):\n 1. infinite Y \\<Longrightarrow> \\<exists>f. bij_betw f X Y", "from \\<open>\\<not> finite Y\\<close>"], ["proof (chain)\npicking this:\n  infinite Y", "have \"|Y| =o |carrier \\<F>\\<^bsub>Y\\<^esub>|\""], ["proof (prove)\nusing this:\n  infinite Y\n\ngoal (1 subgoal):\n 1. |Y| =o |carrier \\<F>\\<^bsub>Y\\<^esub>|", "by (rule free_group_card_infinite)"], ["proof (state)\nthis:\n  |Y| =o |carrier \\<F>\\<^bsub>Y\\<^esub>|\n\ngoal (1 subgoal):\n 1. infinite Y \\<Longrightarrow> \\<exists>f. bij_betw f X Y", "moreover"], ["proof (state)\nthis:\n  |Y| =o |carrier \\<F>\\<^bsub>Y\\<^esub>|\n\ngoal (1 subgoal):\n 1. infinite Y \\<Longrightarrow> \\<exists>f. bij_betw f X Y", "from iso"], ["proof (chain)\npicking this:\n  i \\<in> Group.iso \\<F>\\<^bsub>X\\<^esub> \\<F>\\<^bsub>Y\\<^esub>", "have \"|carrier \\<F>\\<^bsub>X\\<^esub>| =o |carrier \\<F>\\<^bsub>Y\\<^esub>|\""], ["proof (prove)\nusing this:\n  i \\<in> Group.iso \\<F>\\<^bsub>X\\<^esub> \\<F>\\<^bsub>Y\\<^esub>\n\ngoal (1 subgoal):\n 1. |carrier \\<F>\\<^bsub>X\\<^esub>| =o |carrier \\<F>\\<^bsub>Y\\<^esub>|", "by (auto simp add:Group.iso_def iff:card_of_ordIso[THEN sym])"], ["proof (state)\nthis:\n  |carrier \\<F>\\<^bsub>X\\<^esub>| =o |carrier \\<F>\\<^bsub>Y\\<^esub>|\n\ngoal (1 subgoal):\n 1. infinite Y \\<Longrightarrow> \\<exists>f. bij_betw f X Y", "ultimately"], ["proof (chain)\npicking this:\n  |X| =o |carrier \\<F>\\<^bsub>X\\<^esub>|\n  |Y| =o |carrier \\<F>\\<^bsub>Y\\<^esub>|\n  |carrier \\<F>\\<^bsub>X\\<^esub>| =o |carrier \\<F>\\<^bsub>Y\\<^esub>|", "have \"|X| =o |Y|\""], ["proof (prove)\nusing this:\n  |X| =o |carrier \\<F>\\<^bsub>X\\<^esub>|\n  |Y| =o |carrier \\<F>\\<^bsub>Y\\<^esub>|\n  |carrier \\<F>\\<^bsub>X\\<^esub>| =o |carrier \\<F>\\<^bsub>Y\\<^esub>|\n\ngoal (1 subgoal):\n 1. |X| =o |Y|", "by (auto intro: ordIso_equivalence)"], ["proof (state)\nthis:\n  |X| =o |Y|\n\ngoal (1 subgoal):\n 1. infinite Y \\<Longrightarrow> \\<exists>f. bij_betw f X Y", "thus ?thesis"], ["proof (prove)\nusing this:\n  |X| =o |Y|\n\ngoal (1 subgoal):\n 1. \\<exists>f. bij_betw f X Y", "by (subst card_of_ordIso)"], ["proof (state)\nthis:\n  \\<exists>f. bij_betw f X Y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f. bij_betw f X Y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}