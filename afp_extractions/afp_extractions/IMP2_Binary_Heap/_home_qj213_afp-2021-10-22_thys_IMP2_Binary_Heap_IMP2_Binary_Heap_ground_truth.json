{"file_name": "/home/qj213/afp-2021-10-22/thys/IMP2_Binary_Heap/IMP2_Binary_Heap.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/IMP2_Binary_Heap", "problem_names": ["lemma parent_upper_bound: \"parent l c < c \\<longleftrightarrow> l \\<le> c\"", "lemma parent_upper_bound_alt: \"l \\<le> parent l c \\<Longrightarrow> parent l c < c\"", "lemma parent_lower_bound: \"l \\<le> parent l c \\<longleftrightarrow> l < c\"", "lemma grand_parent_upper_bound: \"parent l (parent l c) < c \\<longleftrightarrow> l \\<le> c\"", "lemma l_child_lower_bound: \" p < l_child l p \\<longleftrightarrow> l \\<le> p\"", "lemma parent_l_child[simp]: \"parent l (l_child l n) = n\"", "lemma r_child_lower_bound: \"l \\<le> p \\<Longrightarrow> p < r_child l p\"", "lemma parent_r_child[simp]: \"parent l (r_child l n) = n\"", "lemma smaller_l_child: \"l_child l x < r_child l x\"", "lemma parent_two_children: \n  \"(c = l_child l p \\<or> c = r_child l p) \\<longleftrightarrow> parent l c = p\"", "lemma empty_partial_heap[simp]: \"is_partial_heap cmp heap l r r\"", "lemma is_partial_heap_smaller_back: \n  \"is_partial_heap cmp heap l m r \\<Longrightarrow> r' \\<le> r \\<Longrightarrow> is_partial_heap cmp heap l m r'\"", "lemma is_partial_heap_smaller_front: \n  \"is_partial_heap cmp heap l m r \\<Longrightarrow> m \\<le> m' \\<Longrightarrow> is_partial_heap cmp heap l m' r\"", "lemma snd_half_is_partial_heap: \n  \"(l + r) div 2 \\<le> m \\<Longrightarrow> is_partial_heap cmp heap l m r\"", "lemma modify_outside_partial_heap: \n  assumes \n    \"heap = heap' on {m..<r}\" \n    \"is_partial_heap cmp heap l m r\"\n  shows \"is_partial_heap cmp heap' l m r\"", "lemma partial_heap_added_first_el: \n  assumes \n    \"l \\<le> m\" \"m \\<le> r\"\n    \"is_partial_heap cmp heap l (m + 1) r\"\n  shows \"is_partial_heap_except_down cmp heap l m r m\"", "lemma heap_changed_first_el: \n  assumes \"is_heap cmp heap l r\" \"l \\<le> r\"\n  shows \"is_heap_except_down cmp (heap(l := b)) l r l\"", "lemma heap_appended_el: \n  assumes \n    \"is_heap cmp heap l r\" \n    \"heap = heap' on {l..<r}\"\n  shows \"is_heap_except_up cmp heap' l (r+1) r\"", "lemma strong_int_gr_induct_helper: \n  assumes \"k < (i::int)\" \"(\\<And>i. k < i \\<Longrightarrow> (\\<And>j. k < j \\<Longrightarrow> j < i \\<Longrightarrow> P j) \\<Longrightarrow> P i)\"\n  shows \"\\<And>j. k < j \\<Longrightarrow> j < i \\<Longrightarrow> P j\"", "theorem strong_int_gr_induct:\n  assumes \n    \"k < (i::int)\" \n    \"(\\<And>i. k < i \\<Longrightarrow> (\\<And>j. k < j \\<Longrightarrow> j < i \\<Longrightarrow> P j) \\<Longrightarrow> P i)\" \n  shows \"P i\"", "theorem heap_first_el:\n  assumes \n    \"is_heap cmp heap l r\"\n    \"transp cmp\"\n    \"l < x\" \"x < r\"\n  shows \"cmp (heap l) (heap x)\"", "lemma in_mset_imp_in_array: \n  \"x \\<in># (arr_mset arr l r) \\<longleftrightarrow> (\\<exists>i. bounded l r i \\<and> arr i = x)\"", "lemma arr_mset_remove_last: \n  \"l \\<le> r \\<Longrightarrow> arr_mset arr l r = arr_mset arr l (r + 1) - {#arr r#}\"", "lemma arr_mset_append: \n  \"l \\<le> r \\<Longrightarrow> arr_mset arr l (r + 1) = arr_mset arr l r + {#arr r#}\"", "lemma arr_mset_remove_first: \n  \"i \\<le> r \\<Longrightarrow> arr_mset arr (i - 1) r = arr_mset arr i r + {#arr (i - 1)#}\"", "lemma arr_mset_split: \n  assumes \"l \\<le> m\" \"m \\<le> r\"\n  shows \"arr_mset arr l r = arr_mset arr l m + arr_mset arr m r\"", "lemma eq_on_subset: \n  \"arr1 = arr2 on R \\<Longrightarrow> S \\<subseteq> R \\<Longrightarrow> arr1 = arr2 on S\"", "lemma swap_swaps: \n  \"arr' = swap arr x y \\<Longrightarrow> arr' y = arr x \\<and> arr' x = arr y\"", "lemma swap_only_swaps: \n  \"arr' = swap arr x y \\<Longrightarrow> z \\<noteq> x \\<Longrightarrow> z \\<noteq> y \\<Longrightarrow> arr' z = arr z\"", "lemma swap_commute: \"swap arr x y = swap arr y x\"", "lemma swap_eq_on: \n  \"arr1 = arr2 on S \\<Longrightarrow> x \\<notin> S \\<Longrightarrow> y \\<notin> S \\<Longrightarrow> arr1 = swap arr2 x y on S\"", "lemma swap_child_mset: \n  assumes \n    \"arr_mset arr1 l r = arr_mset arr2 l r\" \n    \"c = l_child l p \\<or> c = r_child l p\" \n    \"l \\<le> p\" \"c < r\" \n  shows \"arr_mset arr1 l r = arr_mset (swap arr2 p c) l r\"", "lemma cmp_swapI: \n  fixes arr::\"'a::order \\<Rightarrow> 'a::order\"\n  assumes\n    \"m < n \\<and> x < y\"\n    \"m < n \\<and> x < y \\<Longrightarrow> x = m \\<Longrightarrow> y = n \\<Longrightarrow> P (arr n) (arr m)\"\n    \"m < n \\<and> x < y \\<Longrightarrow> x \\<noteq> m \\<Longrightarrow> x \\<noteq> n \\<Longrightarrow> y \\<noteq> m \\<Longrightarrow> y \\<noteq> n \\<Longrightarrow> P (arr m) (arr n)\"\n    \"m < n \\<and> x < y \\<Longrightarrow> x = m \\<Longrightarrow> y \\<noteq> m \\<Longrightarrow> y \\<noteq> n \\<Longrightarrow>  P (arr y) (arr n)\"\n    \"m < n \\<and> x < y \\<Longrightarrow> x = n \\<Longrightarrow> y \\<noteq> m \\<Longrightarrow> y \\<noteq> n \\<Longrightarrow>  P (arr m) (arr y)\"\n    \"m < n \\<and> x < y \\<Longrightarrow> x \\<noteq> m \\<Longrightarrow> x \\<noteq> n \\<Longrightarrow> y = n \\<Longrightarrow> P (arr m) (arr x)\"\n    \"m < n \\<and> x < y \\<Longrightarrow> x \\<noteq> m \\<Longrightarrow> x \\<noteq> n \\<Longrightarrow> y = m \\<Longrightarrow> P (arr x) (arr n)\"\n  shows \"P (swap arr x y m) (swap arr x y n)\"", "theorem heap_minimum: \n  assumes \n    \"l < r\" \n    \"is_heap (\\<le>) heap l r\"\n  shows \"heap l = Min_mset (arr_mset heap l r)\"", "lemma sift_up_step_aux1:\n  fixes heap::\"int \\<Rightarrow> int\"\n  assumes  \n    \"is_heap_except_up (\\<le>) heap l r x\"\n    \"parent l x \\<ge> l\" \n    \"(heap x) \\<le> (heap (parent l x))\" \n    \"bounded l r k\" \n    \"k \\<noteq> (parent l x)\" \n    \"bounded l r (parent l k)\"\n  shows \"(swap heap (parent l x) x (parent l k)) \\<le> (swap heap (parent l x) x k)\"", "lemma sift_up_step_aux2: \n  fixes heap::\"int \\<Rightarrow> int\"\n  assumes\n    \"is_heap_except_up (\\<le>) heap l r x\"\n    \"parent l x \\<ge> l\"\n    \"heap x \\<le> (heap (parent l x))\"\n    \"bounded l r k\"\n    \"parent l k = parent l x\"\n    \"bounded l r (parent l (parent l k))\"\n  shows \n    \"swap heap (parent l x) x (parent l (parent l k)) \\<le> swap heap (parent l x) x k\"", "lemma sift_up_step:\n  fixes heap::\"int \\<Rightarrow> int\"\n  assumes  \n    \"is_heap_except_up (\\<le>) heap l r x\"\n    \"parent l x \\<ge> l\" \n    \"(heap x) \\<le> (heap (parent l x))\"\n  shows \"is_heap_except_up (\\<le>) (swap heap (parent l x) x) l r (parent l x)\"", "lemma del_min_mset: \n  fixes heap::\"int \\<Rightarrow> int\"\n  assumes \n    \"l < r\"\n    \"is_heap (\\<le>) heap l r\"\n    \"mod_heap = heap(l := heap (r - 1))\"\n    \"arr_mset mod_heap l (r - 1) = arr_mset new_heap l (r - 1)\"\n  shows \n    \"arr_mset new_heap l (r - 1) = arr_mset heap l r - {#Min_mset (arr_mset heap l r)#}\"", "lemma heap_sort_mset_step:\n  fixes arr::\"int \\<Rightarrow> int\"\n  assumes \n    \"l < m\" \"m \\<le> r\"\n    \"arr_mset arr' l (m - 1) = arr_mset arr l m - {#Min_mset (arr_mset arr l m)#}\"\n    \"arr = arr' on - {l..<m}\"\n    \"mod_arr = arr'(m - 1 := Min_mset (arr_mset arr l m))\"\n  shows \"arr_mset arr l r = arr_mset mod_arr l r\"", "lemma heap_sort_second_half_sorted_step: \n  fixes arr::\"int \\<Rightarrow> int\"\n  assumes\n    \"l\\<^sub>0 < m\" \"m \\<le> r\\<^sub>0\"\n    \"arr = arr' on - {l\\<^sub>0..<m}\"\n    \"\\<forall>i. \\<forall>j. bounded m r\\<^sub>0 i \\<longrightarrow> bounded m r\\<^sub>0 j \\<longrightarrow>  i < j \\<longrightarrow> arr j \\<le> arr i\"\n    \"\\<forall>x\\<in>#arr_mset arr l\\<^sub>0 m. \\<forall>y\\<in>#arr_mset arr m r\\<^sub>0. \\<not> x < y\"\n    \"bounded (m - 1) r\\<^sub>0 i\" \n    \"bounded (m - 1) r\\<^sub>0 j\" \n    \"i < j\"\n    \"mod_arr = (arr'(m - 1 := Min_mset (arr_mset arr l\\<^sub>0 m)))\"\n  shows \"mod_arr j \\<le> mod_arr i\"", "lemma heap_sort_fst_part_bigger_snd_part_step:\n  fixes arr::\"int \\<Rightarrow> int\" \n  assumes\n    \"l\\<^sub>0 < m\"\n    \"m \\<le> r\\<^sub>0\"\n    \"arr_mset arr' l\\<^sub>0 (m - 1) = arr_mset arr l\\<^sub>0 m - {#Min_mset (arr_mset arr l\\<^sub>0 m)#}\"\n    \"arr = arr' on - {l\\<^sub>0..<m}\"\n    \"\\<forall>x\\<in>#arr_mset arr l\\<^sub>0 m. \\<forall>y\\<in>#arr_mset arr m r\\<^sub>0. \\<not> x < y\"\n    \"mod_arr = arr'(m - 1 := Min_mset (arr_mset arr l\\<^sub>0 m))\"\n    \"x\\<in>#arr_mset mod_arr l\\<^sub>0 (m - 1)\"\n    \"y\\<in>#arr_mset mod_arr (m - 1) r\\<^sub>0\"\n  shows \"\\<not> x < y\""], "translations": [["", "lemma parent_upper_bound: \"parent l c < c \\<longleftrightarrow> l \\<le> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (parent l c < c) = (l \\<le> c)", "unfolding parent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l + (c - l - 1) div 2 < c) = (l \\<le> c)", "by auto"], ["", "lemma parent_upper_bound_alt: \"l \\<le> parent l c \\<Longrightarrow> parent l c < c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> parent l c \\<Longrightarrow> parent l c < c", "unfolding parent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> l + (c - l - 1) div 2 \\<Longrightarrow>\n    l + (c - l - 1) div 2 < c", "by simp"], ["", "lemma parent_lower_bound: \"l \\<le> parent l c \\<longleftrightarrow> l < c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l \\<le> parent l c) = (l < c)", "unfolding parent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l \\<le> l + (c - l - 1) div 2) = (l < c)", "by linarith"], ["", "lemma grand_parent_upper_bound: \"parent l (parent l c) < c \\<longleftrightarrow> l \\<le> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (parent l (parent l c) < c) = (l \\<le> c)", "unfolding parent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l + (l + (c - l - 1) div 2 - l - 1) div 2 < c) = (l \\<le> c)", "by linarith"], ["", "corollary parent_bounds: \"l < x \\<Longrightarrow> x < r \\<Longrightarrow> bounded l r (parent l x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l < x; x < r\\<rbrakk>\n    \\<Longrightarrow> bounded l r (parent l x)", "using parent_lower_bound parent_upper_bound_alt"], ["proof (prove)\nusing this:\n  (?l \\<le> parent ?l ?c) = (?l < ?c)\n  ?l \\<le> parent ?l ?c \\<Longrightarrow> parent ?l ?c < ?c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l < x; x < r\\<rbrakk>\n    \\<Longrightarrow> bounded l r (parent l x)", "by fastforce"], ["", "lemma l_child_lower_bound: \" p < l_child l p \\<longleftrightarrow> l \\<le> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p < l_child l p) = (l \\<le> p)", "unfolding l_child_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (p < 2 * p - l + 1) = (l \\<le> p)", "by simp"], ["", "corollary l_child_lower_bound_alt: \"l \\<le> x \\<Longrightarrow> x \\<le> p \\<Longrightarrow> x < l_child l p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<le> x; x \\<le> p\\<rbrakk> \\<Longrightarrow> x < l_child l p", "using l_child_lower_bound[of p l]"], ["proof (prove)\nusing this:\n  (p < l_child l p) = (l \\<le> p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<le> x; x \\<le> p\\<rbrakk> \\<Longrightarrow> x < l_child l p", "by linarith"], ["", "lemma parent_l_child[simp]: \"parent l (l_child l n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parent l (l_child l n) = n", "unfolding parent_def l_child_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. l + (2 * n - l + 1 - l - 1) div 2 = n", "by simp"], ["", "lemma r_child_lower_bound: \"l \\<le> p \\<Longrightarrow> p < r_child l p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> p \\<Longrightarrow> p < r_child l p", "unfolding r_child_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> p \\<Longrightarrow> p < 2 * p - l + 2", "by simp"], ["", "corollary r_child_lower_bound_alt: \"l \\<le> x \\<Longrightarrow> x \\<le> p \\<Longrightarrow> x < r_child l p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<le> x; x \\<le> p\\<rbrakk> \\<Longrightarrow> x < r_child l p", "using r_child_lower_bound[of l p]"], ["proof (prove)\nusing this:\n  l \\<le> p \\<Longrightarrow> p < r_child l p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l \\<le> x; x \\<le> p\\<rbrakk> \\<Longrightarrow> x < r_child l p", "by linarith"], ["", "lemma parent_r_child[simp]: \"parent l (r_child l n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parent l (r_child l n) = n", "unfolding parent_def r_child_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. l + (2 * n - l + 2 - l - 1) div 2 = n", "by simp"], ["", "lemma smaller_l_child: \"l_child l x < r_child l x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l_child l x < r_child l x", "unfolding l_child_def r_child_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * x - l + 1 < 2 * x - l + 2", "by simp"], ["", "lemma parent_two_children: \n  \"(c = l_child l p \\<or> c = r_child l p) \\<longleftrightarrow> parent l c = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c = l_child l p \\<or> c = r_child l p) = (parent l c = p)", "unfolding parent_def l_child_def r_child_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (c = 2 * p - l + 1 \\<or> c = 2 * p - l + 2) =\n    (l + (c - l - 1) div 2 = p)", "by linarith"], ["", "subsection \\<open>Heap Invariants\\<close>"], ["", "subsubsection \\<open>Definitions\\<close>"], ["", "text \\<open>The following heap invariants and the following lemmas are parameterised with an arbitrary \n      (transitive) comparison function. For the concrete function implementations at the end of \n      this submission \\<open>\\<le>\\<close> on ints is used.\\<close>"], ["", "text \\<open>For the \\<open>make_heap\\<close> function, which transforms an unordered array into a valid heap,\n      the notion of a partial heap is needed. Here the heap invariant only holds for array indices\n      between a certain valid array index \\<open>m\\<close> and \\<open>r\\<close>. The standard heap invariant is then\n      simply the special case where \\<open>m = l\\<close>.\\<close>"], ["", "definition is_partial_heap \n  :: \"('a::order \\<Rightarrow> 'a::order \\<Rightarrow> bool) \\<Rightarrow> (int \\<Rightarrow> 'a::order) \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> bool\" where\n  \"is_partial_heap cmp heap l m r = (\\<forall> x. bounded m r x \\<longrightarrow> \n               bounded m r (parent l x) \\<longrightarrow> cmp (heap (parent l x)) (heap x))\""], ["", "abbreviation is_heap \n  :: \"('a::order \\<Rightarrow> 'a::order \\<Rightarrow> bool) \\<Rightarrow> (int \\<Rightarrow> 'a::order) \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> bool\" where\n  \"is_heap cmp heap l r \\<equiv> is_partial_heap cmp heap l l r\""], ["", "text \\<open>During all of the modifying heap functions the heap invariant is temporarily violated at\n      a single index \\<open>i\\<close> and it is then gradually restored by either \\<open>sift_down\\<close> or \n      \\<open>sift_up\\<close>. The following definitions formalize these weakened invariants.\n\n      The second part of the conjunction in the following definitions states, that the comparison \n      between the parent of \\<open>i\\<close> and each of the children of \\<open>i\\<close> evaluates to \\<open>True\\<close> without \n      explicitly using the child relations.\\<close>"], ["", "definition is_partial_heap_except_down \n  :: \"('a::order \\<Rightarrow> 'a::order \\<Rightarrow> bool) \\<Rightarrow> (int \\<Rightarrow> 'a::order) \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> bool\" where\n  \"is_partial_heap_except_down cmp heap l m r i = (\\<forall> x. bounded m r x \\<longrightarrow>\n    ((parent l x \\<noteq> i \\<longrightarrow> bounded m r (parent l x) \\<longrightarrow> cmp (heap (parent l x)) (heap x)) \\<and> \n     (parent l x = i \\<longrightarrow> bounded m r (parent l (parent l x))  \n                     \\<longrightarrow> cmp (heap (parent l (parent l x))) (heap x))))\""], ["", "abbreviation is_heap_except_down \n  :: \"('a::order \\<Rightarrow> 'a::order \\<Rightarrow> bool) \\<Rightarrow> (int \\<Rightarrow> 'a::order) \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> bool\" where\n  \"is_heap_except_down cmp heap l r i \\<equiv> is_partial_heap_except_down cmp heap l l r i\""], ["", "text \\<open>As mentioned the notion of a partial heap is only needed for \\<open>make_heap\\<close>, \n      which only uses \\<open>sift_down\\<close> internally, so there doesn't need to be an additional \n      definition for the partial heap version of the \\<open>sift_up\\<close> invariant.\\<close>"], ["", "definition is_heap_except_up \n  :: \"('a::order \\<Rightarrow> 'a::order \\<Rightarrow> bool) \\<Rightarrow> (int \\<Rightarrow> 'a::order) \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> bool\" where\n  \"is_heap_except_up cmp heap l r i = (\\<forall> x. bounded l r x \\<longrightarrow> \n    ((x \\<noteq> i \\<longrightarrow> bounded l r (parent l x) \\<longrightarrow> cmp (heap (parent l x)) (heap x)) \\<and> \n     (parent l x = i \\<longrightarrow> bounded l r (parent l (parent l x)) \n                     \\<longrightarrow> cmp (heap (parent l (parent l x))) (heap x))))\""], ["", "subsubsection \\<open>Lemmas\\<close>"], ["", "lemma empty_partial_heap[simp]: \"is_partial_heap cmp heap l r r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_partial_heap cmp heap l r r", "unfolding is_partial_heap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       bounded r r x \\<longrightarrow>\n       bounded r r (parent l x) \\<longrightarrow>\n       cmp (heap (parent l x)) (heap x)", "by linarith"], ["", "lemma is_partial_heap_smaller_back: \n  \"is_partial_heap cmp heap l m r \\<Longrightarrow> r' \\<le> r \\<Longrightarrow> is_partial_heap cmp heap l m r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_partial_heap cmp heap l m r; r' \\<le> r\\<rbrakk>\n    \\<Longrightarrow> is_partial_heap cmp heap l m r'", "unfolding is_partial_heap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                bounded m r x \\<longrightarrow>\n                bounded m r (parent l x) \\<longrightarrow>\n                cmp (heap (parent l x)) (heap x);\n     r' \\<le> r\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         bounded m r' x \\<longrightarrow>\n                         bounded m r' (parent l x) \\<longrightarrow>\n                         cmp (heap (parent l x)) (heap x)", "by simp"], ["", "lemma is_partial_heap_smaller_front: \n  \"is_partial_heap cmp heap l m r \\<Longrightarrow> m \\<le> m' \\<Longrightarrow> is_partial_heap cmp heap l m' r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_partial_heap cmp heap l m r; m \\<le> m'\\<rbrakk>\n    \\<Longrightarrow> is_partial_heap cmp heap l m' r", "unfolding is_partial_heap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                bounded m r x \\<longrightarrow>\n                bounded m r (parent l x) \\<longrightarrow>\n                cmp (heap (parent l x)) (heap x);\n     m \\<le> m'\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         bounded m' r x \\<longrightarrow>\n                         bounded m' r (parent l x) \\<longrightarrow>\n                         cmp (heap (parent l x)) (heap x)", "by simp"], ["", "text \\<open>The second half of each array is a is a partial binary heap, since it contains only leafs,\n      which are all trivial binary heaps.\\<close>"], ["", "lemma snd_half_is_partial_heap: \n  \"(l + r) div 2 \\<le> m \\<Longrightarrow> is_partial_heap cmp heap l m r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l + r) div 2 \\<le> m \\<Longrightarrow> is_partial_heap cmp heap l m r", "unfolding is_partial_heap_def parent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (l + r) div 2 \\<le> m \\<Longrightarrow>\n    \\<forall>x.\n       bounded m r x \\<longrightarrow>\n       bounded m r (l + (x - l - 1) div 2) \\<longrightarrow>\n       cmp (heap (l + (x - l - 1) div 2)) (heap x)", "by linarith"], ["", "lemma modify_outside_partial_heap: \n  assumes \n    \"heap = heap' on {m..<r}\" \n    \"is_partial_heap cmp heap l m r\"\n  shows \"is_partial_heap cmp heap' l m r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_partial_heap cmp heap' l m r", "using assms eq_onD"], ["proof (prove)\nusing this:\n  heap = heap' on {m..<r}\n  is_partial_heap cmp heap l m r\n  \\<lbrakk>?r = ?s on ?X; ?x \\<in> ?X\\<rbrakk>\n  \\<Longrightarrow> ?r ?x = ?s ?x\n\ngoal (1 subgoal):\n 1. is_partial_heap cmp heap' l m r", "unfolding is_partial_heap_def"], ["proof (prove)\nusing this:\n  heap = heap' on {m..<r}\n  \\<forall>x.\n     bounded m r x \\<longrightarrow>\n     bounded m r (parent l x) \\<longrightarrow>\n     cmp (heap (parent l x)) (heap x)\n  \\<lbrakk>?r = ?s on ?X; ?x \\<in> ?X\\<rbrakk>\n  \\<Longrightarrow> ?r ?x = ?s ?x\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       bounded m r x \\<longrightarrow>\n       bounded m r (parent l x) \\<longrightarrow>\n       cmp (heap' (parent l x)) (heap' x)", "by fastforce"], ["", "text \\<open>The next few lemmas formalize how the heap invariant is weakened, when the heap is modified\n      in a certain way.\\<close>"], ["", "text \\<open>This lemma is used by \\<open>make_heap\\<close>.\\<close>"], ["", "lemma partial_heap_added_first_el: \n  assumes \n    \"l \\<le> m\" \"m \\<le> r\"\n    \"is_partial_heap cmp heap l (m + 1) r\"\n  shows \"is_partial_heap_except_down cmp heap l m r m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_partial_heap_except_down cmp heap l m r m", "unfolding is_partial_heap_except_down_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       bounded m r x \\<longrightarrow>\n       (parent l x \\<noteq> m \\<longrightarrow>\n        bounded m r (parent l x) \\<longrightarrow>\n        cmp (heap (parent l x)) (heap x)) \\<and>\n       (parent l x = m \\<longrightarrow>\n        bounded m r (parent l (parent l x)) \\<longrightarrow>\n        cmp (heap (parent l (parent l x))) (heap x))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       bounded m r x \\<longrightarrow>\n       (parent l x \\<noteq> m \\<longrightarrow>\n        bounded m r (parent l x) \\<longrightarrow>\n        cmp (heap (parent l x)) (heap x)) \\<and>\n       (parent l x = m \\<longrightarrow>\n        bounded m r (parent l (parent l x)) \\<longrightarrow>\n        cmp (heap (parent l (parent l x))) (heap x))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       bounded m r x \\<longrightarrow>\n       (parent l x \\<noteq> m \\<longrightarrow>\n        bounded m r (parent l x) \\<longrightarrow>\n        cmp (heap (parent l x)) (heap x)) \\<and>\n       (parent l x = m \\<longrightarrow>\n        bounded m r (parent l (parent l x)) \\<longrightarrow>\n        cmp (heap (parent l (parent l x))) (heap x))", "let ?p_x = \"parent l x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       bounded m r x \\<longrightarrow>\n       (parent l x \\<noteq> m \\<longrightarrow>\n        bounded m r (parent l x) \\<longrightarrow>\n        cmp (heap (parent l x)) (heap x)) \\<and>\n       (parent l x = m \\<longrightarrow>\n        bounded m r (parent l (parent l x)) \\<longrightarrow>\n        cmp (heap (parent l (parent l x))) (heap x))", "let ?gp_x = \"parent l ?p_x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       bounded m r x \\<longrightarrow>\n       (parent l x \\<noteq> m \\<longrightarrow>\n        bounded m r (parent l x) \\<longrightarrow>\n        cmp (heap (parent l x)) (heap x)) \\<and>\n       (parent l x = m \\<longrightarrow>\n        bounded m r (parent l (parent l x)) \\<longrightarrow>\n        cmp (heap (parent l (parent l x))) (heap x))", "show \"bounded m r x \\<longrightarrow>\n        (?p_x \\<noteq> m \\<longrightarrow> bounded m r ?p_x \\<longrightarrow> cmp (heap ?p_x) (heap x)) \\<and>\n        (?p_x = m \\<longrightarrow> bounded m r ?gp_x \\<longrightarrow> cmp (heap ?gp_x) (heap x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded m r x \\<longrightarrow>\n    (parent l x \\<noteq> m \\<longrightarrow>\n     bounded m r (parent l x) \\<longrightarrow>\n     cmp (heap (parent l x)) (heap x)) \\<and>\n    (parent l x = m \\<longrightarrow>\n     bounded m r (parent l (parent l x)) \\<longrightarrow>\n     cmp (heap (parent l (parent l x))) (heap x))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. bounded m r x \\<Longrightarrow>\n    (parent l x \\<noteq> m \\<longrightarrow>\n     bounded m r (parent l x) \\<longrightarrow>\n     cmp (heap (parent l x)) (heap x)) \\<and>\n    (parent l x = m \\<longrightarrow>\n     bounded m r (parent l (parent l x)) \\<longrightarrow>\n     cmp (heap (parent l (parent l x))) (heap x))", "assume x_bound: \"bounded m r x\""], ["proof (state)\nthis:\n  bounded m r x\n\ngoal (1 subgoal):\n 1. bounded m r x \\<Longrightarrow>\n    (parent l x \\<noteq> m \\<longrightarrow>\n     bounded m r (parent l x) \\<longrightarrow>\n     cmp (heap (parent l x)) (heap x)) \\<and>\n    (parent l x = m \\<longrightarrow>\n     bounded m r (parent l (parent l x)) \\<longrightarrow>\n     cmp (heap (parent l (parent l x))) (heap x))", "have p_x_lower: \"?p_x \\<noteq> m \\<longrightarrow> bounded m r ?p_x \\<longrightarrow> ?p_x \\<ge> m + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parent l x \\<noteq> m \\<longrightarrow>\n    bounded m r (parent l x) \\<longrightarrow> m + 1 \\<le> parent l x", "by simp"], ["proof (state)\nthis:\n  parent l x \\<noteq> m \\<longrightarrow>\n  bounded m r (parent l x) \\<longrightarrow> m + 1 \\<le> parent l x\n\ngoal (1 subgoal):\n 1. bounded m r x \\<Longrightarrow>\n    (parent l x \\<noteq> m \\<longrightarrow>\n     bounded m r (parent l x) \\<longrightarrow>\n     cmp (heap (parent l x)) (heap x)) \\<and>\n    (parent l x = m \\<longrightarrow>\n     bounded m r (parent l (parent l x)) \\<longrightarrow>\n     cmp (heap (parent l (parent l x))) (heap x))", "hence \"?p_x \\<noteq> m \\<longrightarrow> bounded m r ?p_x \\<longrightarrow> x \\<ge> m + 1\""], ["proof (prove)\nusing this:\n  parent l x \\<noteq> m \\<longrightarrow>\n  bounded m r (parent l x) \\<longrightarrow> m + 1 \\<le> parent l x\n\ngoal (1 subgoal):\n 1. parent l x \\<noteq> m \\<longrightarrow>\n    bounded m r (parent l x) \\<longrightarrow> m + 1 \\<le> x", "using parent_upper_bound[of l x] x_bound assms(1)"], ["proof (prove)\nusing this:\n  parent l x \\<noteq> m \\<longrightarrow>\n  bounded m r (parent l x) \\<longrightarrow> m + 1 \\<le> parent l x\n  (parent l x < x) = (l \\<le> x)\n  bounded m r x\n  l \\<le> m\n\ngoal (1 subgoal):\n 1. parent l x \\<noteq> m \\<longrightarrow>\n    bounded m r (parent l x) \\<longrightarrow> m + 1 \\<le> x", "by linarith"], ["proof (state)\nthis:\n  parent l x \\<noteq> m \\<longrightarrow>\n  bounded m r (parent l x) \\<longrightarrow> m + 1 \\<le> x\n\ngoal (1 subgoal):\n 1. bounded m r x \\<Longrightarrow>\n    (parent l x \\<noteq> m \\<longrightarrow>\n     bounded m r (parent l x) \\<longrightarrow>\n     cmp (heap (parent l x)) (heap x)) \\<and>\n    (parent l x = m \\<longrightarrow>\n     bounded m r (parent l (parent l x)) \\<longrightarrow>\n     cmp (heap (parent l (parent l x))) (heap x))", "hence p_invariant: \"(?p_x \\<noteq> m \\<longrightarrow> bounded m r ?p_x \\<longrightarrow> cmp (heap ?p_x) (heap x))\""], ["proof (prove)\nusing this:\n  parent l x \\<noteq> m \\<longrightarrow>\n  bounded m r (parent l x) \\<longrightarrow> m + 1 \\<le> x\n\ngoal (1 subgoal):\n 1. parent l x \\<noteq> m \\<longrightarrow>\n    bounded m r (parent l x) \\<longrightarrow>\n    cmp (heap (parent l x)) (heap x)", "using assms(3) is_partial_heap_def p_x_lower x_bound"], ["proof (prove)\nusing this:\n  parent l x \\<noteq> m \\<longrightarrow>\n  bounded m r (parent l x) \\<longrightarrow> m + 1 \\<le> x\n  is_partial_heap cmp heap l (m + 1) r\n  is_partial_heap ?cmp ?heap ?l ?m ?r =\n  (\\<forall>x.\n      bounded ?m ?r x \\<longrightarrow>\n      bounded ?m ?r (parent ?l x) \\<longrightarrow>\n      ?cmp (?heap (parent ?l x)) (?heap x))\n  parent l x \\<noteq> m \\<longrightarrow>\n  bounded m r (parent l x) \\<longrightarrow> m + 1 \\<le> parent l x\n  bounded m r x\n\ngoal (1 subgoal):\n 1. parent l x \\<noteq> m \\<longrightarrow>\n    bounded m r (parent l x) \\<longrightarrow>\n    cmp (heap (parent l x)) (heap x)", "by blast"], ["proof (state)\nthis:\n  parent l x \\<noteq> m \\<longrightarrow>\n  bounded m r (parent l x) \\<longrightarrow>\n  cmp (heap (parent l x)) (heap x)\n\ngoal (1 subgoal):\n 1. bounded m r x \\<Longrightarrow>\n    (parent l x \\<noteq> m \\<longrightarrow>\n     bounded m r (parent l x) \\<longrightarrow>\n     cmp (heap (parent l x)) (heap x)) \\<and>\n    (parent l x = m \\<longrightarrow>\n     bounded m r (parent l (parent l x)) \\<longrightarrow>\n     cmp (heap (parent l (parent l x))) (heap x))", "have gp_up_bound: \"(?p_x = m \\<longrightarrow> ?gp_x < m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parent l x = m \\<longrightarrow> parent l (parent l x) < m", "by (simp add: assms(1) parent_upper_bound)"], ["proof (state)\nthis:\n  parent l x = m \\<longrightarrow> parent l (parent l x) < m\n\ngoal (1 subgoal):\n 1. bounded m r x \\<Longrightarrow>\n    (parent l x \\<noteq> m \\<longrightarrow>\n     bounded m r (parent l x) \\<longrightarrow>\n     cmp (heap (parent l x)) (heap x)) \\<and>\n    (parent l x = m \\<longrightarrow>\n     bounded m r (parent l (parent l x)) \\<longrightarrow>\n     cmp (heap (parent l (parent l x))) (heap x))", "show \"(?p_x \\<noteq> m \\<longrightarrow> bounded m r ?p_x \\<longrightarrow> cmp (heap ?p_x) (heap x)) \\<and>\n          (?p_x = m \\<longrightarrow> bounded m r ?gp_x \\<longrightarrow> cmp (heap ?gp_x) (heap x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (parent l x \\<noteq> m \\<longrightarrow>\n     bounded m r (parent l x) \\<longrightarrow>\n     cmp (heap (parent l x)) (heap x)) \\<and>\n    (parent l x = m \\<longrightarrow>\n     bounded m r (parent l (parent l x)) \\<longrightarrow>\n     cmp (heap (parent l (parent l x))) (heap x))", "using gp_up_bound p_invariant"], ["proof (prove)\nusing this:\n  parent l x = m \\<longrightarrow> parent l (parent l x) < m\n  parent l x \\<noteq> m \\<longrightarrow>\n  bounded m r (parent l x) \\<longrightarrow>\n  cmp (heap (parent l x)) (heap x)\n\ngoal (1 subgoal):\n 1. (parent l x \\<noteq> m \\<longrightarrow>\n     bounded m r (parent l x) \\<longrightarrow>\n     cmp (heap (parent l x)) (heap x)) \\<and>\n    (parent l x = m \\<longrightarrow>\n     bounded m r (parent l (parent l x)) \\<longrightarrow>\n     cmp (heap (parent l (parent l x))) (heap x))", "by linarith"], ["proof (state)\nthis:\n  (parent l x \\<noteq> m \\<longrightarrow>\n   bounded m r (parent l x) \\<longrightarrow>\n   cmp (heap (parent l x)) (heap x)) \\<and>\n  (parent l x = m \\<longrightarrow>\n   bounded m r (parent l (parent l x)) \\<longrightarrow>\n   cmp (heap (parent l (parent l x))) (heap x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bounded m r x \\<longrightarrow>\n  (parent l x \\<noteq> m \\<longrightarrow>\n   bounded m r (parent l x) \\<longrightarrow>\n   cmp (heap (parent l x)) (heap x)) \\<and>\n  (parent l x = m \\<longrightarrow>\n   bounded m r (parent l (parent l x)) \\<longrightarrow>\n   cmp (heap (parent l (parent l x))) (heap x))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This lemma is used by \\<open>del_min\\<close>.\\<close>"], ["", "lemma heap_changed_first_el: \n  assumes \"is_heap cmp heap l r\" \"l \\<le> r\"\n  shows \"is_heap_except_down cmp (heap(l := b)) l r l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap_except_down cmp (heap(l := b)) l r l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_heap_except_down cmp (heap(l := b)) l r l", "have \"is_partial_heap cmp heap l (l + 1) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_partial_heap cmp heap l (l + 1) r", "using assms(1) is_partial_heap_smaller_front"], ["proof (prove)\nusing this:\n  is_heap cmp heap l r\n  \\<lbrakk>is_partial_heap ?cmp ?heap ?l ?m ?r; ?m \\<le> ?m'\\<rbrakk>\n  \\<Longrightarrow> is_partial_heap ?cmp ?heap ?l ?m' ?r\n\ngoal (1 subgoal):\n 1. is_partial_heap cmp heap l (l + 1) r", "by fastforce"], ["proof (state)\nthis:\n  is_partial_heap cmp heap l (l + 1) r\n\ngoal (1 subgoal):\n 1. is_heap_except_down cmp (heap(l := b)) l r l", "hence \"is_partial_heap cmp (heap(l := b)) l (l + 1) r\""], ["proof (prove)\nusing this:\n  is_partial_heap cmp heap l (l + 1) r\n\ngoal (1 subgoal):\n 1. is_partial_heap cmp (heap(l := b)) l (l + 1) r", "using modify_outside_partial_heap[of heap]"], ["proof (prove)\nusing this:\n  is_partial_heap cmp heap l (l + 1) r\n  \\<lbrakk>heap = ?heap' on {?m..<?r};\n   is_partial_heap ?cmp heap ?l ?m ?r\\<rbrakk>\n  \\<Longrightarrow> is_partial_heap ?cmp ?heap' ?l ?m ?r\n\ngoal (1 subgoal):\n 1. is_partial_heap cmp (heap(l := b)) l (l + 1) r", "by simp"], ["proof (state)\nthis:\n  is_partial_heap cmp (heap(l := b)) l (l + 1) r\n\ngoal (1 subgoal):\n 1. is_heap_except_down cmp (heap(l := b)) l r l", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_partial_heap cmp (heap(l := b)) l (l + 1) r\n\ngoal (1 subgoal):\n 1. is_heap_except_down cmp (heap(l := b)) l r l", "by (simp add: assms(2) partial_heap_added_first_el)"], ["proof (state)\nthis:\n  is_heap_except_down cmp (heap(l := b)) l r l\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This lemma is used by \\<open>insert\\<close>.\\<close>"], ["", "lemma heap_appended_el: \n  assumes \n    \"is_heap cmp heap l r\" \n    \"heap = heap' on {l..<r}\"\n  shows \"is_heap_except_up cmp heap' l (r+1) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap_except_up cmp heap' l (r + 1) r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_heap_except_up cmp heap' l (r + 1) r", "have \"is_heap cmp heap' l r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap cmp heap' l r", "using assms(1,2) modify_outside_partial_heap"], ["proof (prove)\nusing this:\n  is_heap cmp heap l r\n  heap = heap' on {l..<r}\n  \\<lbrakk>?heap = ?heap' on {?m..<?r};\n   is_partial_heap ?cmp ?heap ?l ?m ?r\\<rbrakk>\n  \\<Longrightarrow> is_partial_heap ?cmp ?heap' ?l ?m ?r\n\ngoal (1 subgoal):\n 1. is_heap cmp heap' l r", "by blast"], ["proof (state)\nthis:\n  is_heap cmp heap' l r\n\ngoal (1 subgoal):\n 1. is_heap_except_up cmp heap' l (r + 1) r", "thus ?thesis"], ["proof (prove)\nusing this:\n  is_heap cmp heap' l r\n\ngoal (1 subgoal):\n 1. is_heap_except_up cmp heap' l (r + 1) r", "unfolding is_partial_heap_def is_heap_except_up_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     bounded l r x \\<longrightarrow>\n     bounded l r (parent l x) \\<longrightarrow>\n     cmp (heap' (parent l x)) (heap' x)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       bounded l (r + 1) x \\<longrightarrow>\n       (x \\<noteq> r \\<longrightarrow>\n        bounded l (r + 1) (parent l x) \\<longrightarrow>\n        cmp (heap' (parent l x)) (heap' x)) \\<and>\n       (parent l x = r \\<longrightarrow>\n        bounded l (r + 1) (parent l (parent l x)) \\<longrightarrow>\n        cmp (heap' (parent l (parent l x))) (heap' x))", "by (metis not_less_iff_gr_or_eq parent_upper_bound zless_add1_eq)"], ["proof (state)\nthis:\n  is_heap_except_up cmp heap' l (r + 1) r\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>First Heap Element\\<close>"], ["", "text \\<open>The next step is to show that the first element of the heap is always the ``smallest'' \n      according to the given comparison function. For the proof a rule for strong induction on lower\n      bounded integers is needed. Its proof is based on the proof of strong induction on natural \n      numbers found in \\cite{Str_Ind}.\\<close>"], ["", "lemma strong_int_gr_induct_helper: \n  assumes \"k < (i::int)\" \"(\\<And>i. k < i \\<Longrightarrow> (\\<And>j. k < j \\<Longrightarrow> j < i \\<Longrightarrow> P j) \\<Longrightarrow> P i)\"\n  shows \"\\<And>j. k < j \\<Longrightarrow> j < i \\<Longrightarrow> P j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j. \\<lbrakk>k < j; j < i\\<rbrakk> \\<Longrightarrow> P j", "using assms"], ["proof (prove)\nusing this:\n  k < i\n  \\<lbrakk>k < ?i;\n   \\<And>j. \\<lbrakk>k < j; j < ?i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n  \\<Longrightarrow> P ?i\n\ngoal (1 subgoal):\n 1. \\<And>j. \\<lbrakk>k < j; j < i\\<rbrakk> \\<Longrightarrow> P j", "proof(induction i rule: int_gr_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>k < j; j < k + 1;\n        \\<And>i.\n           \\<lbrakk>k < i;\n            \\<And>j.\n               \\<lbrakk>k < j; j < i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n           \\<Longrightarrow> P i\\<rbrakk>\n       \\<Longrightarrow> P j\n 2. \\<And>i j.\n       \\<lbrakk>k < i;\n        \\<And>j.\n           \\<lbrakk>k < j; j < i;\n            \\<And>i.\n               \\<lbrakk>k < i;\n                \\<And>j.\n                   \\<lbrakk>k < j; j < i\\<rbrakk>\n                   \\<Longrightarrow> P j\\<rbrakk>\n               \\<Longrightarrow> P i\\<rbrakk>\n           \\<Longrightarrow> P j;\n        k < j; j < i + 1;\n        \\<And>i.\n           \\<lbrakk>k < i;\n            \\<And>j.\n               \\<lbrakk>k < j; j < i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n           \\<Longrightarrow> P i\\<rbrakk>\n       \\<Longrightarrow> P j", "case base"], ["proof (state)\nthis:\n  k < j\n  j < k + 1\n  \\<lbrakk>k < ?i;\n   \\<And>j. \\<lbrakk>k < j; j < ?i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n  \\<Longrightarrow> P ?i\n\ngoal (2 subgoals):\n 1. \\<And>j.\n       \\<lbrakk>k < j; j < k + 1;\n        \\<And>i.\n           \\<lbrakk>k < i;\n            \\<And>j.\n               \\<lbrakk>k < j; j < i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n           \\<Longrightarrow> P i\\<rbrakk>\n       \\<Longrightarrow> P j\n 2. \\<And>i j.\n       \\<lbrakk>k < i;\n        \\<And>j.\n           \\<lbrakk>k < j; j < i;\n            \\<And>i.\n               \\<lbrakk>k < i;\n                \\<And>j.\n                   \\<lbrakk>k < j; j < i\\<rbrakk>\n                   \\<Longrightarrow> P j\\<rbrakk>\n               \\<Longrightarrow> P i\\<rbrakk>\n           \\<Longrightarrow> P j;\n        k < j; j < i + 1;\n        \\<And>i.\n           \\<lbrakk>k < i;\n            \\<And>j.\n               \\<lbrakk>k < j; j < i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n           \\<Longrightarrow> P i\\<rbrakk>\n       \\<Longrightarrow> P j", "then"], ["proof (chain)\npicking this:\n  k < j\n  j < k + 1\n  \\<lbrakk>k < ?i;\n   \\<And>j. \\<lbrakk>k < j; j < ?i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n  \\<Longrightarrow> P ?i", "show ?case"], ["proof (prove)\nusing this:\n  k < j\n  j < k + 1\n  \\<lbrakk>k < ?i;\n   \\<And>j. \\<lbrakk>k < j; j < ?i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n  \\<Longrightarrow> P ?i\n\ngoal (1 subgoal):\n 1. P j", "by linarith"], ["proof (state)\nthis:\n  P j\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>k < i;\n        \\<And>j.\n           \\<lbrakk>k < j; j < i;\n            \\<And>i.\n               \\<lbrakk>k < i;\n                \\<And>j.\n                   \\<lbrakk>k < j; j < i\\<rbrakk>\n                   \\<Longrightarrow> P j\\<rbrakk>\n               \\<Longrightarrow> P i\\<rbrakk>\n           \\<Longrightarrow> P j;\n        k < j; j < i + 1;\n        \\<And>i.\n           \\<lbrakk>k < i;\n            \\<And>j.\n               \\<lbrakk>k < j; j < i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n           \\<Longrightarrow> P i\\<rbrakk>\n       \\<Longrightarrow> P j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>k < i;\n        \\<And>j.\n           \\<lbrakk>k < j; j < i;\n            \\<And>i.\n               \\<lbrakk>k < i;\n                \\<And>j.\n                   \\<lbrakk>k < j; j < i\\<rbrakk>\n                   \\<Longrightarrow> P j\\<rbrakk>\n               \\<Longrightarrow> P i\\<rbrakk>\n           \\<Longrightarrow> P j;\n        k < j; j < i + 1;\n        \\<And>i.\n           \\<lbrakk>k < i;\n            \\<And>j.\n               \\<lbrakk>k < j; j < i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n           \\<Longrightarrow> P i\\<rbrakk>\n       \\<Longrightarrow> P j", "case (step i)"], ["proof (state)\nthis:\n  k < i\n  \\<lbrakk>k < ?j; ?j < i;\n   \\<And>i.\n      \\<lbrakk>k < i;\n       \\<And>j.\n          \\<lbrakk>k < j; j < i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n      \\<Longrightarrow> P i\\<rbrakk>\n  \\<Longrightarrow> P ?j\n  k < j\n  j < i + 1\n  \\<lbrakk>k < ?i;\n   \\<And>j. \\<lbrakk>k < j; j < ?i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n  \\<Longrightarrow> P ?i\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>k < i;\n        \\<And>j.\n           \\<lbrakk>k < j; j < i;\n            \\<And>i.\n               \\<lbrakk>k < i;\n                \\<And>j.\n                   \\<lbrakk>k < j; j < i\\<rbrakk>\n                   \\<Longrightarrow> P j\\<rbrakk>\n               \\<Longrightarrow> P i\\<rbrakk>\n           \\<Longrightarrow> P j;\n        k < j; j < i + 1;\n        \\<And>i.\n           \\<lbrakk>k < i;\n            \\<And>j.\n               \\<lbrakk>k < j; j < i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n           \\<Longrightarrow> P i\\<rbrakk>\n       \\<Longrightarrow> P j", "then"], ["proof (chain)\npicking this:\n  k < i\n  \\<lbrakk>k < ?j; ?j < i;\n   \\<And>i.\n      \\<lbrakk>k < i;\n       \\<And>j.\n          \\<lbrakk>k < j; j < i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n      \\<Longrightarrow> P i\\<rbrakk>\n  \\<Longrightarrow> P ?j\n  k < j\n  j < i + 1\n  \\<lbrakk>k < ?i;\n   \\<And>j. \\<lbrakk>k < j; j < ?i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n  \\<Longrightarrow> P ?i", "show ?case"], ["proof (prove)\nusing this:\n  k < i\n  \\<lbrakk>k < ?j; ?j < i;\n   \\<And>i.\n      \\<lbrakk>k < i;\n       \\<And>j.\n          \\<lbrakk>k < j; j < i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n      \\<Longrightarrow> P i\\<rbrakk>\n  \\<Longrightarrow> P ?j\n  k < j\n  j < i + 1\n  \\<lbrakk>k < ?i;\n   \\<And>j. \\<lbrakk>k < j; j < ?i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n  \\<Longrightarrow> P ?i\n\ngoal (1 subgoal):\n 1. P j", "proof(cases \"j = i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>k < i;\n     \\<And>j.\n        \\<lbrakk>k < j; j < i;\n         \\<And>i.\n            \\<lbrakk>k < i;\n             \\<And>j.\n                \\<lbrakk>k < j; j < i\\<rbrakk>\n                \\<Longrightarrow> P j\\<rbrakk>\n            \\<Longrightarrow> P i\\<rbrakk>\n        \\<Longrightarrow> P j;\n     k < j; j < i + 1;\n     \\<And>i.\n        \\<lbrakk>k < i;\n         \\<And>j.\n            \\<lbrakk>k < j; j < i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n        \\<Longrightarrow> P i;\n     j = i\\<rbrakk>\n    \\<Longrightarrow> P j\n 2. \\<lbrakk>k < i;\n     \\<And>j.\n        \\<lbrakk>k < j; j < i;\n         \\<And>i.\n            \\<lbrakk>k < i;\n             \\<And>j.\n                \\<lbrakk>k < j; j < i\\<rbrakk>\n                \\<Longrightarrow> P j\\<rbrakk>\n            \\<Longrightarrow> P i\\<rbrakk>\n        \\<Longrightarrow> P j;\n     k < j; j < i + 1;\n     \\<And>i.\n        \\<lbrakk>k < i;\n         \\<And>j.\n            \\<lbrakk>k < j; j < i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n        \\<Longrightarrow> P i;\n     j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> P j", "case True"], ["proof (state)\nthis:\n  j = i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>k < i;\n     \\<And>j.\n        \\<lbrakk>k < j; j < i;\n         \\<And>i.\n            \\<lbrakk>k < i;\n             \\<And>j.\n                \\<lbrakk>k < j; j < i\\<rbrakk>\n                \\<Longrightarrow> P j\\<rbrakk>\n            \\<Longrightarrow> P i\\<rbrakk>\n        \\<Longrightarrow> P j;\n     k < j; j < i + 1;\n     \\<And>i.\n        \\<lbrakk>k < i;\n         \\<And>j.\n            \\<lbrakk>k < j; j < i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n        \\<Longrightarrow> P i;\n     j = i\\<rbrakk>\n    \\<Longrightarrow> P j\n 2. \\<lbrakk>k < i;\n     \\<And>j.\n        \\<lbrakk>k < j; j < i;\n         \\<And>i.\n            \\<lbrakk>k < i;\n             \\<And>j.\n                \\<lbrakk>k < j; j < i\\<rbrakk>\n                \\<Longrightarrow> P j\\<rbrakk>\n            \\<Longrightarrow> P i\\<rbrakk>\n        \\<Longrightarrow> P j;\n     k < j; j < i + 1;\n     \\<And>i.\n        \\<lbrakk>k < i;\n         \\<And>j.\n            \\<lbrakk>k < j; j < i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n        \\<Longrightarrow> P i;\n     j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> P j", "then"], ["proof (chain)\npicking this:\n  j = i", "show ?thesis"], ["proof (prove)\nusing this:\n  j = i\n\ngoal (1 subgoal):\n 1. P j", "using step.IH step.prems(1,3)"], ["proof (prove)\nusing this:\n  j = i\n  \\<lbrakk>k < ?j; ?j < i;\n   \\<And>i.\n      \\<lbrakk>k < i;\n       \\<And>j.\n          \\<lbrakk>k < j; j < i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n      \\<Longrightarrow> P i\\<rbrakk>\n  \\<Longrightarrow> P ?j\n  k < j\n  \\<lbrakk>k < ?i;\n   \\<And>j. \\<lbrakk>k < j; j < ?i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n  \\<Longrightarrow> P ?i\n\ngoal (1 subgoal):\n 1. P j", "by blast"], ["proof (state)\nthis:\n  P j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < i;\n     \\<And>j.\n        \\<lbrakk>k < j; j < i;\n         \\<And>i.\n            \\<lbrakk>k < i;\n             \\<And>j.\n                \\<lbrakk>k < j; j < i\\<rbrakk>\n                \\<Longrightarrow> P j\\<rbrakk>\n            \\<Longrightarrow> P i\\<rbrakk>\n        \\<Longrightarrow> P j;\n     k < j; j < i + 1;\n     \\<And>i.\n        \\<lbrakk>k < i;\n         \\<And>j.\n            \\<lbrakk>k < j; j < i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n        \\<Longrightarrow> P i;\n     j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> P j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>k < i;\n     \\<And>j.\n        \\<lbrakk>k < j; j < i;\n         \\<And>i.\n            \\<lbrakk>k < i;\n             \\<And>j.\n                \\<lbrakk>k < j; j < i\\<rbrakk>\n                \\<Longrightarrow> P j\\<rbrakk>\n            \\<Longrightarrow> P i\\<rbrakk>\n        \\<Longrightarrow> P j;\n     k < j; j < i + 1;\n     \\<And>i.\n        \\<lbrakk>k < i;\n         \\<And>j.\n            \\<lbrakk>k < j; j < i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n        \\<Longrightarrow> P i;\n     j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> P j", "case False"], ["proof (state)\nthis:\n  j \\<noteq> i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < i;\n     \\<And>j.\n        \\<lbrakk>k < j; j < i;\n         \\<And>i.\n            \\<lbrakk>k < i;\n             \\<And>j.\n                \\<lbrakk>k < j; j < i\\<rbrakk>\n                \\<Longrightarrow> P j\\<rbrakk>\n            \\<Longrightarrow> P i\\<rbrakk>\n        \\<Longrightarrow> P j;\n     k < j; j < i + 1;\n     \\<And>i.\n        \\<lbrakk>k < i;\n         \\<And>j.\n            \\<lbrakk>k < j; j < i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n        \\<Longrightarrow> P i;\n     j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> P j", "hence \"j < i\""], ["proof (prove)\nusing this:\n  j \\<noteq> i\n\ngoal (1 subgoal):\n 1. j < i", "using step.prems(2)"], ["proof (prove)\nusing this:\n  j \\<noteq> i\n  j < i + 1\n\ngoal (1 subgoal):\n 1. j < i", "by simp"], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>k < i;\n     \\<And>j.\n        \\<lbrakk>k < j; j < i;\n         \\<And>i.\n            \\<lbrakk>k < i;\n             \\<And>j.\n                \\<lbrakk>k < j; j < i\\<rbrakk>\n                \\<Longrightarrow> P j\\<rbrakk>\n            \\<Longrightarrow> P i\\<rbrakk>\n        \\<Longrightarrow> P j;\n     k < j; j < i + 1;\n     \\<And>i.\n        \\<lbrakk>k < i;\n         \\<And>j.\n            \\<lbrakk>k < j; j < i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n        \\<Longrightarrow> P i;\n     j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> P j", "then"], ["proof (chain)\npicking this:\n  j < i", "show ?thesis"], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. P j", "using step.IH step.prems(1,3)"], ["proof (prove)\nusing this:\n  j < i\n  \\<lbrakk>k < ?j; ?j < i;\n   \\<And>i.\n      \\<lbrakk>k < i;\n       \\<And>j.\n          \\<lbrakk>k < j; j < i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n      \\<Longrightarrow> P i\\<rbrakk>\n  \\<Longrightarrow> P ?j\n  k < j\n  \\<lbrakk>k < ?i;\n   \\<And>j. \\<lbrakk>k < j; j < ?i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n  \\<Longrightarrow> P ?i\n\ngoal (1 subgoal):\n 1. P j", "by blast"], ["proof (state)\nthis:\n  P j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P j\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem strong_int_gr_induct:\n  assumes \n    \"k < (i::int)\" \n    \"(\\<And>i. k < i \\<Longrightarrow> (\\<And>j. k < j \\<Longrightarrow> j < i \\<Longrightarrow> P j) \\<Longrightarrow> P i)\" \n  shows \"P i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P i", "using assms less_induct strong_int_gr_induct_helper"], ["proof (prove)\nusing this:\n  k < i\n  \\<lbrakk>k < ?i;\n   \\<And>j. \\<lbrakk>k < j; j < ?i\\<rbrakk> \\<Longrightarrow> P j\\<rbrakk>\n  \\<Longrightarrow> P ?i\n  (\\<And>x.\n      (\\<And>y. y < x \\<Longrightarrow> ?P y) \\<Longrightarrow>\n      ?P x) \\<Longrightarrow>\n  ?P ?a\n  \\<lbrakk>?k < ?i;\n   \\<And>i.\n      \\<lbrakk>?k < i;\n       \\<And>j.\n          \\<lbrakk>?k < j; j < i\\<rbrakk> \\<Longrightarrow> ?P j\\<rbrakk>\n      \\<Longrightarrow> ?P i;\n   ?k < ?j; ?j < ?i\\<rbrakk>\n  \\<Longrightarrow> ?P ?j\n\ngoal (1 subgoal):\n 1. P i", "by blast"], ["", "text \\<open>Now the main theorem, that the first heap element is the ``smallest'' according to the\n      given comparison function, can be proven.\\<close>"], ["", "theorem heap_first_el:\n  assumes \n    \"is_heap cmp heap l r\"\n    \"transp cmp\"\n    \"l < x\" \"x < r\"\n  shows \"cmp (heap l) (heap x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmp (heap l) (heap x)", "using assms"], ["proof (prove)\nusing this:\n  is_heap cmp heap l r\n  transp cmp\n  l < x\n  x < r\n\ngoal (1 subgoal):\n 1. cmp (heap l) (heap x)", "unfolding is_partial_heap_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     bounded l r x \\<longrightarrow>\n     bounded l r (parent l x) \\<longrightarrow>\n     cmp (heap (parent l x)) (heap x)\n  transp cmp\n  l < x\n  x < r\n\ngoal (1 subgoal):\n 1. cmp (heap l) (heap x)", "proof(induction x rule: strong_int_gr_induct[of l])"], ["proof (state)\ngoal (2 subgoals):\n 1. l < x\n 2. \\<And>i.\n       \\<lbrakk>l < i;\n        \\<And>j.\n           \\<lbrakk>l < j; j < i;\n            \\<forall>x.\n               bounded l r x \\<longrightarrow>\n               bounded l r (parent l x) \\<longrightarrow>\n               cmp (heap (parent l x)) (heap x);\n            transp cmp; l < j; j < r\\<rbrakk>\n           \\<Longrightarrow> cmp (heap l) (heap j);\n        \\<forall>x.\n           bounded l r x \\<longrightarrow>\n           bounded l r (parent l x) \\<longrightarrow>\n           cmp (heap (parent l x)) (heap x);\n        transp cmp; l < i; i < r\\<rbrakk>\n       \\<Longrightarrow> cmp (heap l) (heap i)", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. l < x\n 2. \\<And>i.\n       \\<lbrakk>l < i;\n        \\<And>j.\n           \\<lbrakk>l < j; j < i;\n            \\<forall>x.\n               bounded l r x \\<longrightarrow>\n               bounded l r (parent l x) \\<longrightarrow>\n               cmp (heap (parent l x)) (heap x);\n            transp cmp; l < j; j < r\\<rbrakk>\n           \\<Longrightarrow> cmp (heap l) (heap j);\n        \\<forall>x.\n           bounded l r x \\<longrightarrow>\n           bounded l r (parent l x) \\<longrightarrow>\n           cmp (heap (parent l x)) (heap x);\n        transp cmp; l < i; i < r\\<rbrakk>\n       \\<Longrightarrow> cmp (heap l) (heap i)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. l < x", "using assms(3)"], ["proof (prove)\nusing this:\n  l < x\n\ngoal (1 subgoal):\n 1. l < x", "by simp"], ["proof (state)\nthis:\n  l < x\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>l < i;\n        \\<And>j.\n           \\<lbrakk>l < j; j < i;\n            \\<forall>x.\n               bounded l r x \\<longrightarrow>\n               bounded l r (parent l x) \\<longrightarrow>\n               cmp (heap (parent l x)) (heap x);\n            transp cmp; l < j; j < r\\<rbrakk>\n           \\<Longrightarrow> cmp (heap l) (heap j);\n        \\<forall>x.\n           bounded l r x \\<longrightarrow>\n           bounded l r (parent l x) \\<longrightarrow>\n           cmp (heap (parent l x)) (heap x);\n        transp cmp; l < i; i < r\\<rbrakk>\n       \\<Longrightarrow> cmp (heap l) (heap i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>l < i;\n        \\<And>j.\n           \\<lbrakk>l < j; j < i;\n            \\<forall>x.\n               bounded l r x \\<longrightarrow>\n               bounded l r (parent l x) \\<longrightarrow>\n               cmp (heap (parent l x)) (heap x);\n            transp cmp; l < j; j < r\\<rbrakk>\n           \\<Longrightarrow> cmp (heap l) (heap j);\n        \\<forall>x.\n           bounded l r x \\<longrightarrow>\n           bounded l r (parent l x) \\<longrightarrow>\n           cmp (heap (parent l x)) (heap x);\n        transp cmp; l < i; i < r\\<rbrakk>\n       \\<Longrightarrow> cmp (heap l) (heap i)", "case (2 i)"], ["proof (state)\nthis:\n  l < i\n  \\<lbrakk>l < ?j; ?j < i;\n   \\<forall>x.\n      bounded l r x \\<longrightarrow>\n      bounded l r (parent l x) \\<longrightarrow>\n      cmp (heap (parent l x)) (heap x);\n   transp cmp; l < ?j; ?j < r\\<rbrakk>\n  \\<Longrightarrow> cmp (heap l) (heap ?j)\n  \\<forall>x.\n     bounded l r x \\<longrightarrow>\n     bounded l r (parent l x) \\<longrightarrow>\n     cmp (heap (parent l x)) (heap x)\n  transp cmp\n  l < i\n  i < r\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>l < i;\n        \\<And>j.\n           \\<lbrakk>l < j; j < i;\n            \\<forall>x.\n               bounded l r x \\<longrightarrow>\n               bounded l r (parent l x) \\<longrightarrow>\n               cmp (heap (parent l x)) (heap x);\n            transp cmp; l < j; j < r\\<rbrakk>\n           \\<Longrightarrow> cmp (heap l) (heap j);\n        \\<forall>x.\n           bounded l r x \\<longrightarrow>\n           bounded l r (parent l x) \\<longrightarrow>\n           cmp (heap (parent l x)) (heap x);\n        transp cmp; l < i; i < r\\<rbrakk>\n       \\<Longrightarrow> cmp (heap l) (heap i)", "have cmp_pi_i: \"cmp (heap (parent l i)) (heap i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmp (heap (parent l i)) (heap i)", "using \"2.hyps\" \"2.prems\"(1,4) parent_bounds"], ["proof (prove)\nusing this:\n  l < i\n  \\<forall>x.\n     bounded l r x \\<longrightarrow>\n     bounded l r (parent l x) \\<longrightarrow>\n     cmp (heap (parent l x)) (heap x)\n  i < r\n  \\<lbrakk>?l < ?x; ?x < ?r\\<rbrakk>\n  \\<Longrightarrow> bounded ?l ?r (parent ?l ?x)\n\ngoal (1 subgoal):\n 1. cmp (heap (parent l i)) (heap i)", "by simp"], ["proof (state)\nthis:\n  cmp (heap (parent l i)) (heap i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>l < i;\n        \\<And>j.\n           \\<lbrakk>l < j; j < i;\n            \\<forall>x.\n               bounded l r x \\<longrightarrow>\n               bounded l r (parent l x) \\<longrightarrow>\n               cmp (heap (parent l x)) (heap x);\n            transp cmp; l < j; j < r\\<rbrakk>\n           \\<Longrightarrow> cmp (heap l) (heap j);\n        \\<forall>x.\n           bounded l r x \\<longrightarrow>\n           bounded l r (parent l x) \\<longrightarrow>\n           cmp (heap (parent l x)) (heap x);\n        transp cmp; l < i; i < r\\<rbrakk>\n       \\<Longrightarrow> cmp (heap l) (heap i)", "then"], ["proof (chain)\npicking this:\n  cmp (heap (parent l i)) (heap i)", "show ?case"], ["proof (prove)\nusing this:\n  cmp (heap (parent l i)) (heap i)\n\ngoal (1 subgoal):\n 1. cmp (heap l) (heap i)", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>cmp (heap (parent l i)) (heap i); ?P1\\<rbrakk>\n    \\<Longrightarrow> cmp (heap l) (heap i)\n 2. \\<lbrakk>cmp (heap (parent l i)) (heap i); \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> cmp (heap l) (heap i)", "assume \"parent l i > l\""], ["proof (state)\nthis:\n  l < parent l i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>cmp (heap (parent l i)) (heap i); ?P1\\<rbrakk>\n    \\<Longrightarrow> cmp (heap l) (heap i)\n 2. \\<lbrakk>cmp (heap (parent l i)) (heap i); \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> cmp (heap l) (heap i)", "then"], ["proof (chain)\npicking this:\n  l < parent l i", "have \"cmp (heap l) (heap (parent l i))\""], ["proof (prove)\nusing this:\n  l < parent l i\n\ngoal (1 subgoal):\n 1. cmp (heap l) (heap (parent l i))", "using \"2.IH\" \"2.prems\"(1,2,4) parent_upper_bound_alt"], ["proof (prove)\nusing this:\n  l < parent l i\n  \\<lbrakk>l < ?j; ?j < i;\n   \\<forall>x.\n      bounded l r x \\<longrightarrow>\n      bounded l r (parent l x) \\<longrightarrow>\n      cmp (heap (parent l x)) (heap x);\n   transp cmp; l < ?j; ?j < r\\<rbrakk>\n  \\<Longrightarrow> cmp (heap l) (heap ?j)\n  \\<forall>x.\n     bounded l r x \\<longrightarrow>\n     bounded l r (parent l x) \\<longrightarrow>\n     cmp (heap (parent l x)) (heap x)\n  transp cmp\n  i < r\n  ?l \\<le> parent ?l ?c \\<Longrightarrow> parent ?l ?c < ?c\n\ngoal (1 subgoal):\n 1. cmp (heap l) (heap (parent l i))", "by simp"], ["proof (state)\nthis:\n  cmp (heap l) (heap (parent l i))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>cmp (heap (parent l i)) (heap i); ?P1\\<rbrakk>\n    \\<Longrightarrow> cmp (heap l) (heap i)\n 2. \\<lbrakk>cmp (heap (parent l i)) (heap i); \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> cmp (heap l) (heap i)", "then"], ["proof (chain)\npicking this:\n  cmp (heap l) (heap (parent l i))", "show ?thesis"], ["proof (prove)\nusing this:\n  cmp (heap l) (heap (parent l i))\n\ngoal (1 subgoal):\n 1. cmp (heap l) (heap i)", "using \"2.prems\"(2) cmp_pi_i transpE"], ["proof (prove)\nusing this:\n  cmp (heap l) (heap (parent l i))\n  transp cmp\n  cmp (heap (parent l i)) (heap i)\n  \\<lbrakk>transp ?r; ?r ?x ?y; ?r ?y ?z;\n   ?r ?x ?z \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. cmp (heap l) (heap i)", "by metis"], ["proof (state)\nthis:\n  cmp (heap l) (heap i)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cmp (heap (parent l i)) (heap i);\n     \\<not> l < parent l i\\<rbrakk>\n    \\<Longrightarrow> cmp (heap l) (heap i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>cmp (heap (parent l i)) (heap i);\n     \\<not> l < parent l i\\<rbrakk>\n    \\<Longrightarrow> cmp (heap l) (heap i)", "assume \"\\<not> parent l i > l\""], ["proof (state)\nthis:\n  \\<not> l < parent l i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cmp (heap (parent l i)) (heap i);\n     \\<not> l < parent l i\\<rbrakk>\n    \\<Longrightarrow> cmp (heap l) (heap i)", "then"], ["proof (chain)\npicking this:\n  \\<not> l < parent l i", "have \"parent l i = l\""], ["proof (prove)\nusing this:\n  \\<not> l < parent l i\n\ngoal (1 subgoal):\n 1. parent l i = l", "using \"2.hyps\" dual_order.order_iff_strict parent_lower_bound"], ["proof (prove)\nusing this:\n  \\<not> l < parent l i\n  l < i\n  (?b \\<le> ?a) = (?b < ?a \\<or> ?a = ?b)\n  (?l \\<le> parent ?l ?c) = (?l < ?c)\n\ngoal (1 subgoal):\n 1. parent l i = l", "by metis"], ["proof (state)\nthis:\n  parent l i = l\n\ngoal (1 subgoal):\n 1. \\<lbrakk>cmp (heap (parent l i)) (heap i);\n     \\<not> l < parent l i\\<rbrakk>\n    \\<Longrightarrow> cmp (heap l) (heap i)", "then"], ["proof (chain)\npicking this:\n  parent l i = l", "show ?thesis"], ["proof (prove)\nusing this:\n  parent l i = l\n\ngoal (1 subgoal):\n 1. cmp (heap l) (heap i)", "using cmp_pi_i"], ["proof (prove)\nusing this:\n  parent l i = l\n  cmp (heap (parent l i)) (heap i)\n\ngoal (1 subgoal):\n 1. cmp (heap l) (heap i)", "by simp"], ["proof (state)\nthis:\n  cmp (heap l) (heap i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cmp (heap l) (heap i)\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>General Lemmas on Arrays\\<close>"], ["", "text \\<open>Some additional lemmas on @{const \"mset_ran\"}, @{const \"swap\"} and @{const \"eq_on\"} are needed\n      for the final proofs.\\<close>"], ["", "subsection \\<open>Lemmas on @{const \"mset_ran\"}\\<close>"], ["", "abbreviation arr_mset :: \"(int \\<Rightarrow> 'a) \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> 'a multiset\" where\n  \"arr_mset arr l r \\<equiv> mset_ran arr {l..<r}\""], ["", "lemma in_mset_imp_in_array: \n  \"x \\<in># (arr_mset arr l r) \\<longleftrightarrow> (\\<exists>i. bounded l r i \\<and> arr i = x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in># arr_mset arr l r) =\n    (\\<exists>i. bounded l r i \\<and> arr i = x)", "unfolding mset_ran_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<in># image_mset arr (mset_set {l..<r})) =\n    (\\<exists>i. bounded l r i \\<and> arr i = x)", "by fastforce"], ["", "lemma arr_mset_remove_last: \n  \"l \\<le> r \\<Longrightarrow> arr_mset arr l r = arr_mset arr l (r + 1) - {#arr r#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> r \\<Longrightarrow>\n    arr_mset arr l r = arr_mset arr l (r + 1) - {#arr r#}", "by (simp add: intvs_upper_decr mset_ran_def)"], ["", "lemma arr_mset_append: \n  \"l \\<le> r \\<Longrightarrow> arr_mset arr l (r + 1) = arr_mset arr l r + {#arr r#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> r \\<Longrightarrow>\n    arr_mset arr l (r + 1) = arr_mset arr l r + {#arr r#}", "using arr_mset_remove_last[of l r arr]"], ["proof (prove)\nusing this:\n  l \\<le> r \\<Longrightarrow>\n  arr_mset arr l r = arr_mset arr l (r + 1) - {#arr r#}\n\ngoal (1 subgoal):\n 1. l \\<le> r \\<Longrightarrow>\n    arr_mset arr l (r + 1) = arr_mset arr l r + {#arr r#}", "by simp"], ["", "corollary arr_mset_append_alt: \n  \"l \\<le> r \\<Longrightarrow> arr_mset (arr(r := b)) l (r + 1) = arr_mset arr l r + {#b#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<le> r \\<Longrightarrow>\n    arr_mset (arr(r := b)) l (r + 1) = arr_mset arr l r + {#b#}", "by (simp add: arr_mset_append mset_ran_subst_outside)"], ["", "lemma arr_mset_remove_first: \n  \"i \\<le> r \\<Longrightarrow> arr_mset arr (i - 1) r = arr_mset arr i r + {#arr (i - 1)#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> r \\<Longrightarrow>\n    arr_mset arr (i - 1) r = arr_mset arr i r + {#arr (i - 1)#}", "by(induction r rule: int_ge_induct) (auto simp add: arr_mset_append)"], ["", "lemma arr_mset_split: \n  assumes \"l \\<le> m\" \"m \\<le> r\"\n  shows \"arr_mset arr l r = arr_mset arr l m + arr_mset arr m r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr_mset arr l r = arr_mset arr l m + arr_mset arr m r", "using assms"], ["proof (prove)\nusing this:\n  l \\<le> m\n  m \\<le> r\n\ngoal (1 subgoal):\n 1. arr_mset arr l r = arr_mset arr l m + arr_mset arr m r", "proof(induction m rule: int_ge_induct[of l])"], ["proof (state)\ngoal (2 subgoals):\n 1. l \\<le> r \\<Longrightarrow>\n    arr_mset arr l r = arr_mset arr l l + arr_mset arr l r\n 2. \\<And>i.\n       \\<lbrakk>l \\<le> i;\n        i \\<le> r \\<Longrightarrow>\n        arr_mset arr l r = arr_mset arr l i + arr_mset arr i r;\n        i + 1 \\<le> r\\<rbrakk>\n       \\<Longrightarrow> arr_mset arr l r =\n                         arr_mset arr l (i + 1) + arr_mset arr (i + 1) r", "case (step i)"], ["proof (state)\nthis:\n  l \\<le> i\n  i \\<le> r \\<Longrightarrow>\n  arr_mset arr l r = arr_mset arr l i + arr_mset arr i r\n  i + 1 \\<le> r\n\ngoal (2 subgoals):\n 1. l \\<le> r \\<Longrightarrow>\n    arr_mset arr l r = arr_mset arr l l + arr_mset arr l r\n 2. \\<And>i.\n       \\<lbrakk>l \\<le> i;\n        i \\<le> r \\<Longrightarrow>\n        arr_mset arr l r = arr_mset arr l i + arr_mset arr i r;\n        i + 1 \\<le> r\\<rbrakk>\n       \\<Longrightarrow> arr_mset arr l r =\n                         arr_mset arr l (i + 1) + arr_mset arr (i + 1) r", "have add_last: \"arr_mset arr l (i + 1) = arr_mset arr l i + {#arr i#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr_mset arr l (i + 1) = arr_mset arr l i + {#arr i#}", "using step arr_mset_append"], ["proof (prove)\nusing this:\n  l \\<le> i\n  i \\<le> r \\<Longrightarrow>\n  arr_mset arr l r = arr_mset arr l i + arr_mset arr i r\n  i + 1 \\<le> r\n  ?l \\<le> ?r \\<Longrightarrow>\n  arr_mset ?arr ?l (?r + 1) = arr_mset ?arr ?l ?r + {#?arr ?r#}\n\ngoal (1 subgoal):\n 1. arr_mset arr l (i + 1) = arr_mset arr l i + {#arr i#}", "by blast"], ["proof (state)\nthis:\n  arr_mset arr l (i + 1) = arr_mset arr l i + {#arr i#}\n\ngoal (2 subgoals):\n 1. l \\<le> r \\<Longrightarrow>\n    arr_mset arr l r = arr_mset arr l l + arr_mset arr l r\n 2. \\<And>i.\n       \\<lbrakk>l \\<le> i;\n        i \\<le> r \\<Longrightarrow>\n        arr_mset arr l r = arr_mset arr l i + arr_mset arr i r;\n        i + 1 \\<le> r\\<rbrakk>\n       \\<Longrightarrow> arr_mset arr l r =\n                         arr_mset arr l (i + 1) + arr_mset arr (i + 1) r", "have rem_first: \"arr_mset arr (i+1) r = arr_mset arr i r - {#arr i#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr_mset arr (i + 1) r = arr_mset arr i r - {#arr i#}", "by (metis step.prems arr_mset_remove_first add_diff_cancel_right')"], ["proof (state)\nthis:\n  arr_mset arr (i + 1) r = arr_mset arr i r - {#arr i#}\n\ngoal (2 subgoals):\n 1. l \\<le> r \\<Longrightarrow>\n    arr_mset arr l r = arr_mset arr l l + arr_mset arr l r\n 2. \\<And>i.\n       \\<lbrakk>l \\<le> i;\n        i \\<le> r \\<Longrightarrow>\n        arr_mset arr l r = arr_mset arr l i + arr_mset arr i r;\n        i + 1 \\<le> r\\<rbrakk>\n       \\<Longrightarrow> arr_mset arr l r =\n                         arr_mset arr l (i + 1) + arr_mset arr (i + 1) r", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. arr_mset arr l r = arr_mset arr l (i + 1) + arr_mset arr (i + 1) r", "using step add_last rem_first"], ["proof (prove)\nusing this:\n  l \\<le> i\n  i \\<le> r \\<Longrightarrow>\n  arr_mset arr l r = arr_mset arr l i + arr_mset arr i r\n  i + 1 \\<le> r\n  arr_mset arr l (i + 1) = arr_mset arr l i + {#arr i#}\n  arr_mset arr (i + 1) r = arr_mset arr i r - {#arr i#}\n\ngoal (1 subgoal):\n 1. arr_mset arr l r = arr_mset arr l (i + 1) + arr_mset arr (i + 1) r", "by fastforce"], ["proof (state)\nthis:\n  arr_mset arr l r = arr_mset arr l (i + 1) + arr_mset arr (i + 1) r\n\ngoal (1 subgoal):\n 1. l \\<le> r \\<Longrightarrow>\n    arr_mset arr l r = arr_mset arr l l + arr_mset arr l r", "qed (simp)"], ["", "text \\<open>That the first element in a heap is the ``smallest'', can now be expressed using multisets.\\<close>"], ["", "corollary heap_first_el_alt:                                                   \n  assumes \n    \"transp cmp\" \n    \"is_heap cmp heap l r\" \n    \"x \\<in># (arr_mset heap l r)\" \n    \"heap l \\<noteq> x\"\n  shows \"cmp (heap l) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmp (heap l) x", "by(metis assms heap_first_el in_mset_imp_in_array le_less)"], ["", "subsection \\<open>Lemmas on @{term \"swap\"} and @{term \"eq_on\"}\\<close>"], ["", "lemma eq_on_subset: \n  \"arr1 = arr2 on R \\<Longrightarrow> S \\<subseteq> R \\<Longrightarrow> arr1 = arr2 on S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>arr1 = arr2 on R; S \\<subseteq> R\\<rbrakk>\n    \\<Longrightarrow> arr1 = arr2 on S", "by (simp add: eq_on_def set_mp)"], ["", "lemma swap_swaps: \n  \"arr' = swap arr x y \\<Longrightarrow> arr' y = arr x \\<and> arr' x = arr y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr' = swap arr x y \\<Longrightarrow>\n    arr' y = arr x \\<and> arr' x = arr y", "unfolding swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. arr' = arr(x := arr y, y := arr x) \\<Longrightarrow>\n    arr' y = arr x \\<and> arr' x = arr y", "by simp"], ["", "lemma swap_only_swaps: \n  \"arr' = swap arr x y \\<Longrightarrow> z \\<noteq> x \\<Longrightarrow> z \\<noteq> y \\<Longrightarrow> arr' z = arr z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>arr' = swap arr x y; z \\<noteq> x; z \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> arr' z = arr z", "unfolding swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>arr' = arr(x := arr y, y := arr x); z \\<noteq> x;\n     z \\<noteq> y\\<rbrakk>\n    \\<Longrightarrow> arr' z = arr z", "by simp"], ["", "lemma swap_commute: \"swap arr x y = swap arr y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap arr x y = swap arr y x", "unfolding swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. arr(x := arr y, y := arr x) = arr(y := arr x, x := arr y)", "by fastforce"], ["", "lemma swap_eq_on: \n  \"arr1 = arr2 on S \\<Longrightarrow> x \\<notin> S \\<Longrightarrow> y \\<notin> S \\<Longrightarrow> arr1 = swap arr2 x y on S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>arr1 = arr2 on S; x \\<notin> S; y \\<notin> S\\<rbrakk>\n    \\<Longrightarrow> arr1 = swap arr2 x y on S", "unfolding swap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>arr1 = arr2 on S; x \\<notin> S; y \\<notin> S\\<rbrakk>\n    \\<Longrightarrow> arr1 = arr2(x := arr2 y, y := arr2 x) on S", "by simp"], ["", "corollary swap_parent_eq_on: \n  assumes \n    \"arr1 = arr2 on - {l..<r}\" \n    \"l < c\" \"c < r\" \n  shows \"arr1 = swap arr2 (parent l c) c on - {l..<r} \""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr1 = swap arr2 (parent l c) c on - {l..<r}", "using parent_bounds swap_eq_on assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l < ?x; ?x < ?r\\<rbrakk>\n  \\<Longrightarrow> bounded ?l ?r (parent ?l ?x)\n  \\<lbrakk>?arr1.0 = ?arr2.0 on ?S; ?x \\<notin> ?S; ?y \\<notin> ?S\\<rbrakk>\n  \\<Longrightarrow> ?arr1.0 = swap ?arr2.0 ?x ?y on ?S\n  arr1 = arr2 on - {l..<r}\n  l < c\n  c < r\n\ngoal (1 subgoal):\n 1. arr1 = swap arr2 (parent l c) c on - {l..<r}", "by fastforce"], ["", "corollary swap_child_eq_on: \n  assumes \n    \"arr1 = arr2 on - {l..<r}\" \n    \"c = l_child l p \\<or> c = r_child l p\" \n    \"l \\<le> p\" \"c < r\" \n  shows \"arr1 = swap arr2 p c on - {l..<r} \""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr1 = swap arr2 p c on - {l..<r}", "by (metis assms parent_lower_bound parent_two_children swap_parent_eq_on)"], ["", "lemma swap_child_mset: \n  assumes \n    \"arr_mset arr1 l r = arr_mset arr2 l r\" \n    \"c = l_child l p \\<or> c = r_child l p\" \n    \"l \\<le> p\" \"c < r\" \n  shows \"arr_mset arr1 l r = arr_mset (swap arr2 p c) l r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr_mset arr1 l r = arr_mset (swap arr2 p c) l r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. arr_mset arr1 l r = arr_mset (swap arr2 p c) l r", "have child_bounded: \"l < c \\<and> c < r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l < c \\<and> c < r", "by (metis assms(2-4) parent_lower_bound parent_two_children)"], ["proof (state)\nthis:\n  l < c \\<and> c < r\n\ngoal (1 subgoal):\n 1. arr_mset arr1 l r = arr_mset (swap arr2 p c) l r", "have parent_bounded: \"bounded l r p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded l r p", "by (metis assms(2-4) dual_order.strict_trans parent_two_children parent_upper_bound_alt)"], ["proof (state)\nthis:\n  bounded l r p\n\ngoal (1 subgoal):\n 1. arr_mset arr1 l r = arr_mset (swap arr2 p c) l r", "thus ?thesis"], ["proof (prove)\nusing this:\n  bounded l r p\n\ngoal (1 subgoal):\n 1. arr_mset arr1 l r = arr_mset (swap arr2 p c) l r", "using assms(1) child_bounded mset_ran_swap[of p \"{l..<r}\" c arr2] atLeastLessThan_iff"], ["proof (prove)\nusing this:\n  bounded l r p\n  arr_mset arr1 l r = arr_mset arr2 l r\n  l < c \\<and> c < r\n  \\<lbrakk>p \\<in> {l..<r}; c \\<in> {l..<r}\\<rbrakk>\n  \\<Longrightarrow> arr_mset (swap arr2 p c) l r = arr_mset arr2 l r\n  (?i \\<in> {?l..<?u}) = (?l \\<le> ?i \\<and> ?i < ?u)\n\ngoal (1 subgoal):\n 1. arr_mset arr1 l r = arr_mset (swap arr2 p c) l r", "by simp"], ["proof (state)\nthis:\n  arr_mset arr1 l r = arr_mset (swap arr2 p c) l r\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The following lemma shows, which propositions have to hold on the pre-swap array, so that\n      a comparison between two elements holds on the post-swap array. This is useful for the \n      proofs of the loop invariants of \\<open>sift_up\\<close> and \\<open>sift_down\\<close>. The lemma is kept \n      quite general (except for the argument order) and could probably be more closely\n      related to the parent relation for more concise proofs.\\<close>"], ["", "lemma cmp_swapI: \n  fixes arr::\"'a::order \\<Rightarrow> 'a::order\"\n  assumes\n    \"m < n \\<and> x < y\"\n    \"m < n \\<and> x < y \\<Longrightarrow> x = m \\<Longrightarrow> y = n \\<Longrightarrow> P (arr n) (arr m)\"\n    \"m < n \\<and> x < y \\<Longrightarrow> x \\<noteq> m \\<Longrightarrow> x \\<noteq> n \\<Longrightarrow> y \\<noteq> m \\<Longrightarrow> y \\<noteq> n \\<Longrightarrow> P (arr m) (arr n)\"\n    \"m < n \\<and> x < y \\<Longrightarrow> x = m \\<Longrightarrow> y \\<noteq> m \\<Longrightarrow> y \\<noteq> n \\<Longrightarrow>  P (arr y) (arr n)\"\n    \"m < n \\<and> x < y \\<Longrightarrow> x = n \\<Longrightarrow> y \\<noteq> m \\<Longrightarrow> y \\<noteq> n \\<Longrightarrow>  P (arr m) (arr y)\"\n    \"m < n \\<and> x < y \\<Longrightarrow> x \\<noteq> m \\<Longrightarrow> x \\<noteq> n \\<Longrightarrow> y = n \\<Longrightarrow> P (arr m) (arr x)\"\n    \"m < n \\<and> x < y \\<Longrightarrow> x \\<noteq> m \\<Longrightarrow> x \\<noteq> n \\<Longrightarrow> y = m \\<Longrightarrow> P (arr x) (arr n)\"\n  shows \"P (swap arr x y m) (swap arr x y n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (swap arr x y m) (swap arr x y n)", "by (metis assms order.asym swap_only_swaps swap_swaps)"], ["", "section \\<open>Imperative Heap Implementation\\<close>"], ["", "text \\<open>The following imperative heap functions are based on \\cite{MS} and \\cite{CLRS}. All functions,\n      that are recursive in these books, are iterative in the following implementations. The \n      function definitions are done with IMP2 \\cite{IMP2-AFP}. From now on the heaps only contain \n      ints and only use \\<open>\\<le>\\<close> as comparison function. The auxiliary lemmas used from now on are \n      heavily modeled after the proof goals, that are generated by the vcg tool (also part of IMP2).\\<close>"], ["", "subsection \\<open>Simple Functions\\<close>"], ["", "subsubsection \\<open>Parent, Children and Swap\\<close>"], ["", "text \\<open>In this section the parent and children relations are expressed as IMP2 procedures. \n      Additionally a simple procedure, that swaps two array elements, is defined.\\<close>"], ["", "procedure_spec prnt (l, x) returns p\n  assumes True\n    ensures \"p = parent l\\<^sub>0 x\\<^sub>0\"\n  defines \\<open>p = ((x - l - 1) / 2 + l)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT' Map.empty (\\<lambda>\\<ss>. BB_PROTECT True)\n     (\\<lambda>\\<ss>\\<^sub>0.\n         ''p'' ::= Binop (+)\n                    (Binop (div)\n                      (Binop (-) (Binop (-) (V ''x'') (V ''l'')) (N 1))\n                      (N 2))\n                    (V ''l''))\n     (\\<lambda>\\<ss>\\<^sub>0 \\<ss>.\n         VAR (\\<ss> ''p'' 0)\n          (\\<lambda>p.\n              VAR (\\<ss>\\<^sub>0 ''x'' 0)\n               (\\<lambda>x\\<^sub>0.\n                   VAR (\\<ss>\\<^sub>0 ''l'' 0)\n                    (\\<lambda>l\\<^sub>0.\n                        BB_PROTECT (p = parent l\\<^sub>0 x\\<^sub>0)))))", "by vcg (simp add: parent_def)"], ["", "procedure_spec left_child (l, x) returns lc\n  assumes True \n    ensures \"lc = l_child l\\<^sub>0 x\\<^sub>0\"\n  defines \\<open>lc = 2 * x - l + 1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT' Map.empty (\\<lambda>\\<ss>. BB_PROTECT True)\n     (\\<lambda>\\<ss>\\<^sub>0.\n         ''lc'' ::= Binop (+)\n                     (Binop (-) (Binop (*) (N 2) (V ''x'')) (V ''l''))\n                     (N 1))\n     (\\<lambda>\\<ss>\\<^sub>0 \\<ss>.\n         VAR (\\<ss> ''lc'' 0)\n          (\\<lambda>lc.\n              VAR (\\<ss>\\<^sub>0 ''x'' 0)\n               (\\<lambda>x\\<^sub>0.\n                   VAR (\\<ss>\\<^sub>0 ''l'' 0)\n                    (\\<lambda>l\\<^sub>0.\n                        BB_PROTECT (lc = l_child l\\<^sub>0 x\\<^sub>0)))))", "by vcg (simp add: l_child_def)"], ["", "procedure_spec right_child (l, x) returns rc\n  assumes True\n    ensures \"rc = r_child l\\<^sub>0 x\\<^sub>0\"\n  defines \\<open>rc = 2 * x - l + 2\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT' Map.empty (\\<lambda>\\<ss>. BB_PROTECT True)\n     (\\<lambda>\\<ss>\\<^sub>0.\n         ''rc'' ::= Binop (+)\n                     (Binop (-) (Binop (*) (N 2) (V ''x'')) (V ''l''))\n                     (N 2))\n     (\\<lambda>\\<ss>\\<^sub>0 \\<ss>.\n         VAR (\\<ss> ''rc'' 0)\n          (\\<lambda>rc.\n              VAR (\\<ss>\\<^sub>0 ''x'' 0)\n               (\\<lambda>x\\<^sub>0.\n                   VAR (\\<ss>\\<^sub>0 ''l'' 0)\n                    (\\<lambda>l\\<^sub>0.\n                        BB_PROTECT (rc = r_child l\\<^sub>0 x\\<^sub>0)))))", "by vcg (simp add: r_child_def)"], ["", "procedure_spec swp (heap, x, y) returns heap\n  assumes True\n    ensures \"heap = swap heap\\<^sub>0 x\\<^sub>0 y\\<^sub>0 \"\n  defines \\<open>tmp = heap[x]; heap[x] = heap[y]; heap[y] = tmp\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT' Map.empty (\\<lambda>\\<ss>. BB_PROTECT True)\n     (\\<lambda>\\<ss>\\<^sub>0. ''tmp'' ::= Vidx ''heap'' (V ''x'');;\n         ''heap''[V ''x''] ::= Vidx ''heap'' (V ''y'');;\n         ''heap''[V ''y''] ::= V ''tmp'')\n     (\\<lambda>\\<ss>\\<^sub>0 \\<ss>.\n         VAR (\\<ss> ''heap'')\n          (\\<lambda>heap.\n              VAR (\\<ss>\\<^sub>0 ''heap'')\n               (\\<lambda>heap\\<^sub>0.\n                   VAR (\\<ss>\\<^sub>0 ''y'' 0)\n                    (\\<lambda>y\\<^sub>0.\n                        VAR (\\<ss>\\<^sub>0 ''x'' 0)\n                         (\\<lambda>x\\<^sub>0.\n                             BB_PROTECT\n                              (heap =\n                               swap heap\\<^sub>0 x\\<^sub>0 y\\<^sub>0))))))", "by vcg (simp add: swap_def)"], ["", "subsubsection \\<open>\\<open>get_min\\<close>\\<close>"], ["", "text \\<open>In this section \\<open>get_min\\<close> is defined, which simply returns the first element (the minimum) of \n      the heap. For this definition an additional theorem is proven, which enables the use of\n      @{const \"Min_mset\"} in the postcondition.\\<close>"], ["", "theorem heap_minimum: \n  assumes \n    \"l < r\" \n    \"is_heap (\\<le>) heap l r\"\n  shows \"heap l = Min_mset (arr_mset heap l r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap l = Min_mset (arr_mset heap l r)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. heap l = Min_mset (arr_mset heap l r)", "have \"(\\<forall>x \\<in># (arr_mset heap l r). (heap l) \\<le> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>#arr_mset heap l r. heap l \\<le> x", "using assms(2) heap_first_el_alt transp_le"], ["proof (prove)\nusing this:\n  is_heap (\\<le>) heap l r\n  \\<lbrakk>transp ?cmp; is_heap ?cmp ?heap ?l ?r;\n   ?x \\<in># arr_mset ?heap ?l ?r; ?heap ?l \\<noteq> ?x\\<rbrakk>\n  \\<Longrightarrow> ?cmp (?heap ?l) ?x\n  transp (\\<le>)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>#arr_mset heap l r. heap l \\<le> x", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>#arr_mset heap l r. heap l \\<le> x\n\ngoal (1 subgoal):\n 1. heap l = Min_mset (arr_mset heap l r)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>#arr_mset heap l r. heap l \\<le> x\n\ngoal (1 subgoal):\n 1. heap l = Min_mset (arr_mset heap l r)", "by (simp add: assms(1) dual_order.antisym)"], ["proof (state)\nthis:\n  heap l = Min_mset (arr_mset heap l r)\n\ngoal:\nNo subgoals!", "qed"], ["", "procedure_spec get_min (heap, l, r) returns min\n  assumes \"l < r \\<and> is_heap (\\<le>) heap l r\"  \n    ensures \"min = Min_mset (arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0)\"\n  for heap[] l r\n  defines \\<open>min = heap[l]\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT' Map.empty\n     (\\<lambda>\\<ss>.\n         VAR (\\<ss> ''heap'')\n          (\\<lambda>heap.\n              VAR (\\<ss> ''r'' 0)\n               (\\<lambda>r.\n                   VAR (\\<ss> ''l'' 0)\n                    (\\<lambda>l.\n                        BB_PROTECT\n                         (l < r \\<and> is_heap (\\<le>) heap l r)))))\n     (\\<lambda>\\<ss>\\<^sub>0. ''min'' ::= Vidx ''heap'' (V ''l''))\n     (\\<lambda>\\<ss>\\<^sub>0 \\<ss>.\n         VAR (\\<ss> ''min'' 0)\n          (\\<lambda>min.\n              VAR (\\<ss>\\<^sub>0 ''heap'')\n               (\\<lambda>heap\\<^sub>0.\n                   VAR (\\<ss>\\<^sub>0 ''r'' 0)\n                    (\\<lambda>r\\<^sub>0.\n                        VAR (\\<ss>\\<^sub>0 ''l'' 0)\n                         (\\<lambda>l\\<^sub>0.\n                             BB_PROTECT\n                              (min =\n                               Min_mset\n                                (arr_mset heap\\<^sub>0 l\\<^sub>0\n                                  r\\<^sub>0)))))))", "by vcg (simp add: heap_minimum)"], ["", "subsection \\<open>Modifying Functions\\<close>"], ["", "subsubsection \\<open>\\<open>sift_up\\<close> and \\<open>insert\\<close>\\<close>"], ["", "text \\<open>The next heap function is \\<open>insert\\<close>, which internally uses \\<open>sift_up\\<close>. In the beginning of \n      this section \\<open>sift_up_step\\<close> is proven, which states that each \\<open>sift_up\\<close> loop iteration \n      correctly transforms the weakened heap invariant. For its proof two additional\n      auxiliary lemmas are used. After \\<open>sift_up_step\\<close> \\<open>sift_up\\<close> and then \\<open>insert\\<close> are verified.\\<close>"], ["", "text \\<open>\\<open>sift_up_step\\<close> can be proven directly by the smt-solver without auxiliary lemmas, but they\n      were introduced to show the proof details. The analogous proofs for \\<open>sift_down\\<close> were \n      just solved with smt, since the proof structure should be very similar, even though the \n      \\<open>sift_down\\<close> proof goals are slightly more complex.\\<close>"], ["", "lemma sift_up_step_aux1:\n  fixes heap::\"int \\<Rightarrow> int\"\n  assumes  \n    \"is_heap_except_up (\\<le>) heap l r x\"\n    \"parent l x \\<ge> l\" \n    \"(heap x) \\<le> (heap (parent l x))\" \n    \"bounded l r k\" \n    \"k \\<noteq> (parent l x)\" \n    \"bounded l r (parent l k)\"\n  shows \"(swap heap (parent l x) x (parent l k)) \\<le> (swap heap (parent l x) x k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap heap (parent l x) x (parent l k) \\<le> swap heap (parent l x) x k", "apply(intro cmp_swapI[of \"(parent l k)\" k \"(parent l x)\" x \"(\\<le>)\" heap])"], ["proof (prove)\ngoal (7 subgoals):\n 1. parent l k < k \\<and> parent l x < x\n 2. \\<lbrakk>parent l k < k \\<and> parent l x < x; parent l x = parent l k;\n     x = k\\<rbrakk>\n    \\<Longrightarrow> heap k \\<le> heap (parent l k)\n 3. \\<lbrakk>parent l k < k \\<and> parent l x < x;\n     parent l x \\<noteq> parent l k; parent l x \\<noteq> k;\n     x \\<noteq> parent l k; x \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l k) \\<le> heap k\n 4. \\<lbrakk>parent l k < k \\<and> parent l x < x; parent l x = parent l k;\n     x \\<noteq> parent l k; x \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> heap x \\<le> heap k\n 5. \\<lbrakk>parent l k < k \\<and> parent l x < x; parent l x = k;\n     x \\<noteq> parent l k; x \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l k) \\<le> heap x\n 6. \\<lbrakk>parent l k < k \\<and> parent l x < x;\n     parent l x \\<noteq> parent l k; parent l x \\<noteq> k; x = k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l k) \\<le> heap (parent l x)\n 7. \\<lbrakk>parent l k < k \\<and> parent l x < x;\n     parent l x \\<noteq> parent l k; parent l x \\<noteq> k;\n     x = parent l k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l x) \\<le> heap k", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. parent l k < k \\<and> parent l x < x", "using assms(2,6) parent_upper_bound_alt"], ["proof (prove)\nusing this:\n  l \\<le> parent l x\n  bounded l r (parent l k)\n  ?l \\<le> parent ?l ?c \\<Longrightarrow> parent ?l ?c < ?c\n\ngoal (1 subgoal):\n 1. parent l k < k \\<and> parent l x < x", "by blast"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>parent l k < k \\<and> parent l x < x; parent l x = parent l k;\n     x = k\\<rbrakk>\n    \\<Longrightarrow> heap k \\<le> heap (parent l k)\n 2. \\<lbrakk>parent l k < k \\<and> parent l x < x;\n     parent l x \\<noteq> parent l k; parent l x \\<noteq> k;\n     x \\<noteq> parent l k; x \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l k) \\<le> heap k\n 3. \\<lbrakk>parent l k < k \\<and> parent l x < x; parent l x = parent l k;\n     x \\<noteq> parent l k; x \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> heap x \\<le> heap k\n 4. \\<lbrakk>parent l k < k \\<and> parent l x < x; parent l x = k;\n     x \\<noteq> parent l k; x \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l k) \\<le> heap x\n 5. \\<lbrakk>parent l k < k \\<and> parent l x < x;\n     parent l x \\<noteq> parent l k; parent l x \\<noteq> k; x = k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l k) \\<le> heap (parent l x)\n 6. \\<lbrakk>parent l k < k \\<and> parent l x < x;\n     parent l x \\<noteq> parent l k; parent l x \\<noteq> k;\n     x = parent l k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l x) \\<le> heap k", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>parent l k < k \\<and> parent l x < x; parent l x = parent l k;\n     x = k\\<rbrakk>\n    \\<Longrightarrow> heap k \\<le> heap (parent l k)", "using assms(3)"], ["proof (prove)\nusing this:\n  heap x \\<le> heap (parent l x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>parent l k < k \\<and> parent l x < x; parent l x = parent l k;\n     x = k\\<rbrakk>\n    \\<Longrightarrow> heap k \\<le> heap (parent l k)", "by blast"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>parent l k < k \\<and> parent l x < x;\n     parent l x \\<noteq> parent l k; parent l x \\<noteq> k;\n     x \\<noteq> parent l k; x \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l k) \\<le> heap k\n 2. \\<lbrakk>parent l k < k \\<and> parent l x < x; parent l x = parent l k;\n     x \\<noteq> parent l k; x \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> heap x \\<le> heap k\n 3. \\<lbrakk>parent l k < k \\<and> parent l x < x; parent l x = k;\n     x \\<noteq> parent l k; x \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l k) \\<le> heap x\n 4. \\<lbrakk>parent l k < k \\<and> parent l x < x;\n     parent l x \\<noteq> parent l k; parent l x \\<noteq> k; x = k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l k) \\<le> heap (parent l x)\n 5. \\<lbrakk>parent l k < k \\<and> parent l x < x;\n     parent l x \\<noteq> parent l k; parent l x \\<noteq> k;\n     x = parent l k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l x) \\<le> heap k", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>parent l k < k \\<and> parent l x < x;\n     parent l x \\<noteq> parent l k; parent l x \\<noteq> k;\n     x \\<noteq> parent l k; x \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l k) \\<le> heap k", "using assms(1,4,6)"], ["proof (prove)\nusing this:\n  is_heap_except_up (\\<le>) heap l r x\n  bounded l r k\n  bounded l r (parent l k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>parent l k < k \\<and> parent l x < x;\n     parent l x \\<noteq> parent l k; parent l x \\<noteq> k;\n     x \\<noteq> parent l k; x \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l k) \\<le> heap k", "unfolding is_heap_except_up_def"], ["proof (prove)\nusing this:\n  \\<forall>xa.\n     bounded l r xa \\<longrightarrow>\n     (xa \\<noteq> x \\<longrightarrow>\n      bounded l r (parent l xa) \\<longrightarrow>\n      heap (parent l xa) \\<le> heap xa) \\<and>\n     (parent l xa = x \\<longrightarrow>\n      bounded l r (parent l (parent l xa)) \\<longrightarrow>\n      heap (parent l (parent l xa)) \\<le> heap xa)\n  bounded l r k\n  bounded l r (parent l k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>parent l k < k \\<and> parent l x < x;\n     parent l x \\<noteq> parent l k; parent l x \\<noteq> k;\n     x \\<noteq> parent l k; x \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l k) \\<le> heap k", "by blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>parent l k < k \\<and> parent l x < x; parent l x = parent l k;\n     x \\<noteq> parent l k; x \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> heap x \\<le> heap k\n 2. \\<lbrakk>parent l k < k \\<and> parent l x < x; parent l x = k;\n     x \\<noteq> parent l k; x \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l k) \\<le> heap x\n 3. \\<lbrakk>parent l k < k \\<and> parent l x < x;\n     parent l x \\<noteq> parent l k; parent l x \\<noteq> k; x = k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l k) \\<le> heap (parent l x)\n 4. \\<lbrakk>parent l k < k \\<and> parent l x < x;\n     parent l x \\<noteq> parent l k; parent l x \\<noteq> k;\n     x = parent l k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l x) \\<le> heap k", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>parent l k < k \\<and> parent l x < x; parent l x = parent l k;\n     x \\<noteq> parent l k; x \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> heap x \\<le> heap k", "using assms(1,3,4,6)"], ["proof (prove)\nusing this:\n  is_heap_except_up (\\<le>) heap l r x\n  heap x \\<le> heap (parent l x)\n  bounded l r k\n  bounded l r (parent l k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>parent l k < k \\<and> parent l x < x; parent l x = parent l k;\n     x \\<noteq> parent l k; x \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> heap x \\<le> heap k", "unfolding is_heap_except_up_def"], ["proof (prove)\nusing this:\n  \\<forall>xa.\n     bounded l r xa \\<longrightarrow>\n     (xa \\<noteq> x \\<longrightarrow>\n      bounded l r (parent l xa) \\<longrightarrow>\n      heap (parent l xa) \\<le> heap xa) \\<and>\n     (parent l xa = x \\<longrightarrow>\n      bounded l r (parent l (parent l xa)) \\<longrightarrow>\n      heap (parent l (parent l xa)) \\<le> heap xa)\n  heap x \\<le> heap (parent l x)\n  bounded l r k\n  bounded l r (parent l k)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>parent l k < k \\<and> parent l x < x; parent l x = parent l k;\n     x \\<noteq> parent l k; x \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> heap x \\<le> heap k", "by fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>parent l k < k \\<and> parent l x < x; parent l x = k;\n     x \\<noteq> parent l k; x \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l k) \\<le> heap x\n 2. \\<lbrakk>parent l k < k \\<and> parent l x < x;\n     parent l x \\<noteq> parent l k; parent l x \\<noteq> k; x = k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l k) \\<le> heap (parent l x)\n 3. \\<lbrakk>parent l k < k \\<and> parent l x < x;\n     parent l x \\<noteq> parent l k; parent l x \\<noteq> k;\n     x = parent l k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l x) \\<le> heap k", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>parent l k < k \\<and> parent l x < x; parent l x = k;\n     x \\<noteq> parent l k; x \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l k) \\<le> heap x", "using assms(5)"], ["proof (prove)\nusing this:\n  k \\<noteq> parent l x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>parent l k < k \\<and> parent l x < x; parent l x = k;\n     x \\<noteq> parent l k; x \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l k) \\<le> heap x", "by blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>parent l k < k \\<and> parent l x < x;\n     parent l x \\<noteq> parent l k; parent l x \\<noteq> k; x = k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l k) \\<le> heap (parent l x)\n 2. \\<lbrakk>parent l k < k \\<and> parent l x < x;\n     parent l x \\<noteq> parent l k; parent l x \\<noteq> k;\n     x = parent l k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l x) \\<le> heap k", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>parent l k < k \\<and> parent l x < x;\n     parent l x \\<noteq> parent l k; parent l x \\<noteq> k; x = k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l k) \\<le> heap (parent l x)", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>parent l k < k \\<and> parent l x < x;\n     parent l x \\<noteq> parent l k; parent l x \\<noteq> k;\n     x = parent l k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l x) \\<le> heap k", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>parent l k < k \\<and> parent l x < x;\n     parent l x \\<noteq> parent l k; parent l x \\<noteq> k;\n     x = parent l k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l x) \\<le> heap k", "using assms(1,2,4)"], ["proof (prove)\nusing this:\n  is_heap_except_up (\\<le>) heap l r x\n  l \\<le> parent l x\n  bounded l r k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>parent l k < k \\<and> parent l x < x;\n     parent l x \\<noteq> parent l k; parent l x \\<noteq> k;\n     x = parent l k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l x) \\<le> heap k", "unfolding is_heap_except_up_def"], ["proof (prove)\nusing this:\n  \\<forall>xa.\n     bounded l r xa \\<longrightarrow>\n     (xa \\<noteq> x \\<longrightarrow>\n      bounded l r (parent l xa) \\<longrightarrow>\n      heap (parent l xa) \\<le> heap xa) \\<and>\n     (parent l xa = x \\<longrightarrow>\n      bounded l r (parent l (parent l xa)) \\<longrightarrow>\n      heap (parent l (parent l xa)) \\<le> heap xa)\n  l \\<le> parent l x\n  bounded l r k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>parent l k < k \\<and> parent l x < x;\n     parent l x \\<noteq> parent l k; parent l x \\<noteq> k;\n     x = parent l k\\<rbrakk>\n    \\<Longrightarrow> heap (parent l x) \\<le> heap k", "by simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma sift_up_step_aux2: \n  fixes heap::\"int \\<Rightarrow> int\"\n  assumes\n    \"is_heap_except_up (\\<le>) heap l r x\"\n    \"parent l x \\<ge> l\"\n    \"heap x \\<le> (heap (parent l x))\"\n    \"bounded l r k\"\n    \"parent l k = parent l x\"\n    \"bounded l r (parent l (parent l k))\"\n  shows \n    \"swap heap (parent l x) x (parent l (parent l k)) \\<le> swap heap (parent l x) x k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap heap (parent l x) x (parent l (parent l k))\n    \\<le> swap heap (parent l x) x k", "using assms"], ["proof (prove)\nusing this:\n  is_heap_except_up (\\<le>) heap l r x\n  l \\<le> parent l x\n  heap x \\<le> heap (parent l x)\n  bounded l r k\n  parent l k = parent l x\n  bounded l r (parent l (parent l k))\n\ngoal (1 subgoal):\n 1. swap heap (parent l x) x (parent l (parent l k))\n    \\<le> swap heap (parent l x) x k", "unfolding is_heap_except_up_def"], ["proof (prove)\nusing this:\n  \\<forall>xa.\n     bounded l r xa \\<longrightarrow>\n     (xa \\<noteq> x \\<longrightarrow>\n      bounded l r (parent l xa) \\<longrightarrow>\n      heap (parent l xa) \\<le> heap xa) \\<and>\n     (parent l xa = x \\<longrightarrow>\n      bounded l r (parent l (parent l xa)) \\<longrightarrow>\n      heap (parent l (parent l xa)) \\<le> heap xa)\n  l \\<le> parent l x\n  heap x \\<le> heap (parent l x)\n  bounded l r k\n  parent l k = parent l x\n  bounded l r (parent l (parent l k))\n\ngoal (1 subgoal):\n 1. swap heap (parent l x) x (parent l (parent l k))\n    \\<le> swap heap (parent l x) x k", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>xa.\n                bounded l r xa \\<longrightarrow>\n                (xa \\<noteq> x \\<longrightarrow>\n                 bounded l r (parent l xa) \\<longrightarrow>\n                 heap (parent l xa) \\<le> heap xa) \\<and>\n                (parent l xa = x \\<longrightarrow>\n                 bounded l r (parent l (parent l xa)) \\<longrightarrow>\n                 heap (parent l (parent l xa)) \\<le> heap xa);\n     l \\<le> parent l x; heap x \\<le> heap (parent l x); bounded l r k;\n     parent l k = parent l x; bounded l r (parent l (parent l k))\\<rbrakk>\n    \\<Longrightarrow> swap heap (parent l x) x (parent l (parent l k))\n                      \\<le> swap heap (parent l x) x k", "let ?gp_k = \"parent l (parent l k)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>xa.\n                bounded l r xa \\<longrightarrow>\n                (xa \\<noteq> x \\<longrightarrow>\n                 bounded l r (parent l xa) \\<longrightarrow>\n                 heap (parent l xa) \\<le> heap xa) \\<and>\n                (parent l xa = x \\<longrightarrow>\n                 bounded l r (parent l (parent l xa)) \\<longrightarrow>\n                 heap (parent l (parent l xa)) \\<le> heap xa);\n     l \\<le> parent l x; heap x \\<le> heap (parent l x); bounded l r k;\n     parent l k = parent l x; bounded l r (parent l (parent l k))\\<rbrakk>\n    \\<Longrightarrow> swap heap (parent l x) x (parent l (parent l k))\n                      \\<le> swap heap (parent l x) x k", "let ?gp_x = \"parent l (parent l x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>xa.\n                bounded l r xa \\<longrightarrow>\n                (xa \\<noteq> x \\<longrightarrow>\n                 bounded l r (parent l xa) \\<longrightarrow>\n                 heap (parent l xa) \\<le> heap xa) \\<and>\n                (parent l xa = x \\<longrightarrow>\n                 bounded l r (parent l (parent l xa)) \\<longrightarrow>\n                 heap (parent l (parent l xa)) \\<le> heap xa);\n     l \\<le> parent l x; heap x \\<le> heap (parent l x); bounded l r k;\n     parent l k = parent l x; bounded l r (parent l (parent l k))\\<rbrakk>\n    \\<Longrightarrow> swap heap (parent l x) x (parent l (parent l k))\n                      \\<le> swap heap (parent l x) x k", "have gp_k_eq_gp_x: \"swap heap (parent l x) x ?gp_k = heap ?gp_x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap heap (parent l x) x (parent l (parent l k)) =\n    heap (parent l (parent l x))", "by (metis assms(2,5) grand_parent_upper_bound less_irrefl swap_only_swaps)"], ["proof (state)\nthis:\n  swap heap (parent l x) x (parent l (parent l k)) =\n  heap (parent l (parent l x))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>xa.\n                bounded l r xa \\<longrightarrow>\n                (xa \\<noteq> x \\<longrightarrow>\n                 bounded l r (parent l xa) \\<longrightarrow>\n                 heap (parent l xa) \\<le> heap xa) \\<and>\n                (parent l xa = x \\<longrightarrow>\n                 bounded l r (parent l (parent l xa)) \\<longrightarrow>\n                 heap (parent l (parent l xa)) \\<le> heap xa);\n     l \\<le> parent l x; heap x \\<le> heap (parent l x); bounded l r k;\n     parent l k = parent l x; bounded l r (parent l (parent l k))\\<rbrakk>\n    \\<Longrightarrow> swap heap (parent l x) x (parent l (parent l k))\n                      \\<le> swap heap (parent l x) x k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. swap heap (parent l x) x (parent l (parent l k))\n    \\<le> swap heap (parent l x) x k", "using assms"], ["proof (prove)\nusing this:\n  is_heap_except_up (\\<le>) heap l r x\n  l \\<le> parent l x\n  heap x \\<le> heap (parent l x)\n  bounded l r k\n  parent l k = parent l x\n  bounded l r (parent l (parent l k))\n\ngoal (1 subgoal):\n 1. swap heap (parent l x) x (parent l (parent l k))\n    \\<le> swap heap (parent l x) x k", "unfolding is_heap_except_up_def"], ["proof (prove)\nusing this:\n  \\<forall>xa.\n     bounded l r xa \\<longrightarrow>\n     (xa \\<noteq> x \\<longrightarrow>\n      bounded l r (parent l xa) \\<longrightarrow>\n      heap (parent l xa) \\<le> heap xa) \\<and>\n     (parent l xa = x \\<longrightarrow>\n      bounded l r (parent l (parent l xa)) \\<longrightarrow>\n      heap (parent l (parent l xa)) \\<le> heap xa)\n  l \\<le> parent l x\n  heap x \\<le> heap (parent l x)\n  bounded l r k\n  parent l k = parent l x\n  bounded l r (parent l (parent l k))\n\ngoal (1 subgoal):\n 1. swap heap (parent l x) x (parent l (parent l k))\n    \\<le> swap heap (parent l x) x k", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>xa.\n                bounded l r xa \\<longrightarrow>\n                (xa \\<noteq> x \\<longrightarrow>\n                 bounded l r (parent l xa) \\<longrightarrow>\n                 heap (parent l xa) \\<le> heap xa) \\<and>\n                (parent l xa = x \\<longrightarrow>\n                 bounded l r (parent l (parent l xa)) \\<longrightarrow>\n                 heap (parent l (parent l xa)) \\<le> heap xa);\n     l \\<le> parent l x; heap x \\<le> heap (parent l x); bounded l r k;\n     parent l k = parent l x; bounded l r (parent l (parent l k));\n     ?P6\\<rbrakk>\n    \\<Longrightarrow> swap heap (parent l x) x (parent l (parent l k))\n                      \\<le> swap heap (parent l x) x k\n 2. \\<lbrakk>\\<forall>xa.\n                bounded l r xa \\<longrightarrow>\n                (xa \\<noteq> x \\<longrightarrow>\n                 bounded l r (parent l xa) \\<longrightarrow>\n                 heap (parent l xa) \\<le> heap xa) \\<and>\n                (parent l xa = x \\<longrightarrow>\n                 bounded l r (parent l (parent l xa)) \\<longrightarrow>\n                 heap (parent l (parent l xa)) \\<le> heap xa);\n     l \\<le> parent l x; heap x \\<le> heap (parent l x); bounded l r k;\n     parent l k = parent l x; bounded l r (parent l (parent l k));\n     \\<not> ?P6\\<rbrakk>\n    \\<Longrightarrow> swap heap (parent l x) x (parent l (parent l k))\n                      \\<le> swap heap (parent l x) x k", "assume k_eq_x: \"k = x\""], ["proof (state)\nthis:\n  k = x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>xa.\n                bounded l r xa \\<longrightarrow>\n                (xa \\<noteq> x \\<longrightarrow>\n                 bounded l r (parent l xa) \\<longrightarrow>\n                 heap (parent l xa) \\<le> heap xa) \\<and>\n                (parent l xa = x \\<longrightarrow>\n                 bounded l r (parent l (parent l xa)) \\<longrightarrow>\n                 heap (parent l (parent l xa)) \\<le> heap xa);\n     l \\<le> parent l x; heap x \\<le> heap (parent l x); bounded l r k;\n     parent l k = parent l x; bounded l r (parent l (parent l k));\n     ?P6\\<rbrakk>\n    \\<Longrightarrow> swap heap (parent l x) x (parent l (parent l k))\n                      \\<le> swap heap (parent l x) x k\n 2. \\<lbrakk>\\<forall>xa.\n                bounded l r xa \\<longrightarrow>\n                (xa \\<noteq> x \\<longrightarrow>\n                 bounded l r (parent l xa) \\<longrightarrow>\n                 heap (parent l xa) \\<le> heap xa) \\<and>\n                (parent l xa = x \\<longrightarrow>\n                 bounded l r (parent l (parent l xa)) \\<longrightarrow>\n                 heap (parent l (parent l xa)) \\<le> heap xa);\n     l \\<le> parent l x; heap x \\<le> heap (parent l x); bounded l r k;\n     parent l k = parent l x; bounded l r (parent l (parent l k));\n     \\<not> ?P6\\<rbrakk>\n    \\<Longrightarrow> swap heap (parent l x) x (parent l (parent l k))\n                      \\<le> swap heap (parent l x) x k", "have \"swap heap (parent l x) x k = heap (parent l x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap heap (parent l x) x k = heap (parent l x)", "by (metis k_eq_x swap_swaps)"], ["proof (state)\nthis:\n  swap heap (parent l x) x k = heap (parent l x)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>xa.\n                bounded l r xa \\<longrightarrow>\n                (xa \\<noteq> x \\<longrightarrow>\n                 bounded l r (parent l xa) \\<longrightarrow>\n                 heap (parent l xa) \\<le> heap xa) \\<and>\n                (parent l xa = x \\<longrightarrow>\n                 bounded l r (parent l (parent l xa)) \\<longrightarrow>\n                 heap (parent l (parent l xa)) \\<le> heap xa);\n     l \\<le> parent l x; heap x \\<le> heap (parent l x); bounded l r k;\n     parent l k = parent l x; bounded l r (parent l (parent l k));\n     ?P6\\<rbrakk>\n    \\<Longrightarrow> swap heap (parent l x) x (parent l (parent l k))\n                      \\<le> swap heap (parent l x) x k\n 2. \\<lbrakk>\\<forall>xa.\n                bounded l r xa \\<longrightarrow>\n                (xa \\<noteq> x \\<longrightarrow>\n                 bounded l r (parent l xa) \\<longrightarrow>\n                 heap (parent l xa) \\<le> heap xa) \\<and>\n                (parent l xa = x \\<longrightarrow>\n                 bounded l r (parent l (parent l xa)) \\<longrightarrow>\n                 heap (parent l (parent l xa)) \\<le> heap xa);\n     l \\<le> parent l x; heap x \\<le> heap (parent l x); bounded l r k;\n     parent l k = parent l x; bounded l r (parent l (parent l k));\n     \\<not> ?P6\\<rbrakk>\n    \\<Longrightarrow> swap heap (parent l x) x (parent l (parent l k))\n                      \\<le> swap heap (parent l x) x k", "then"], ["proof (chain)\npicking this:\n  swap heap (parent l x) x k = heap (parent l x)", "show ?thesis"], ["proof (prove)\nusing this:\n  swap heap (parent l x) x k = heap (parent l x)\n\ngoal (1 subgoal):\n 1. swap heap (parent l x) x (parent l (parent l k))\n    \\<le> swap heap (parent l x) x k", "using assms(1,2,4,6)"], ["proof (prove)\nusing this:\n  swap heap (parent l x) x k = heap (parent l x)\n  is_heap_except_up (\\<le>) heap l r x\n  l \\<le> parent l x\n  bounded l r k\n  bounded l r (parent l (parent l k))\n\ngoal (1 subgoal):\n 1. swap heap (parent l x) x (parent l (parent l k))\n    \\<le> swap heap (parent l x) x k", "unfolding is_heap_except_up_def"], ["proof (prove)\nusing this:\n  swap heap (parent l x) x k = heap (parent l x)\n  \\<forall>xa.\n     bounded l r xa \\<longrightarrow>\n     (xa \\<noteq> x \\<longrightarrow>\n      bounded l r (parent l xa) \\<longrightarrow>\n      heap (parent l xa) \\<le> heap xa) \\<and>\n     (parent l xa = x \\<longrightarrow>\n      bounded l r (parent l (parent l xa)) \\<longrightarrow>\n      heap (parent l (parent l xa)) \\<le> heap xa)\n  l \\<le> parent l x\n  bounded l r k\n  bounded l r (parent l (parent l k))\n\ngoal (1 subgoal):\n 1. swap heap (parent l x) x (parent l (parent l k))\n    \\<le> swap heap (parent l x) x k", "by (metis gp_k_eq_gp_x k_eq_x parent_bounds parent_lower_bound)"], ["proof (state)\nthis:\n  swap heap (parent l x) x (parent l (parent l k))\n  \\<le> swap heap (parent l x) x k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>xa.\n                bounded l r xa \\<longrightarrow>\n                (xa \\<noteq> x \\<longrightarrow>\n                 bounded l r (parent l xa) \\<longrightarrow>\n                 heap (parent l xa) \\<le> heap xa) \\<and>\n                (parent l xa = x \\<longrightarrow>\n                 bounded l r (parent l (parent l xa)) \\<longrightarrow>\n                 heap (parent l (parent l xa)) \\<le> heap xa);\n     l \\<le> parent l x; heap x \\<le> heap (parent l x); bounded l r k;\n     parent l k = parent l x; bounded l r (parent l (parent l k));\n     k \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> swap heap (parent l x) x (parent l (parent l k))\n                      \\<le> swap heap (parent l x) x k", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>xa.\n                bounded l r xa \\<longrightarrow>\n                (xa \\<noteq> x \\<longrightarrow>\n                 bounded l r (parent l xa) \\<longrightarrow>\n                 heap (parent l xa) \\<le> heap xa) \\<and>\n                (parent l xa = x \\<longrightarrow>\n                 bounded l r (parent l (parent l xa)) \\<longrightarrow>\n                 heap (parent l (parent l xa)) \\<le> heap xa);\n     l \\<le> parent l x; heap x \\<le> heap (parent l x); bounded l r k;\n     parent l k = parent l x; bounded l r (parent l (parent l k));\n     k \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> swap heap (parent l x) x (parent l (parent l k))\n                      \\<le> swap heap (parent l x) x k", "assume k_neq_x: \"k \\<noteq> x\""], ["proof (state)\nthis:\n  k \\<noteq> x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>xa.\n                bounded l r xa \\<longrightarrow>\n                (xa \\<noteq> x \\<longrightarrow>\n                 bounded l r (parent l xa) \\<longrightarrow>\n                 heap (parent l xa) \\<le> heap xa) \\<and>\n                (parent l xa = x \\<longrightarrow>\n                 bounded l r (parent l (parent l xa)) \\<longrightarrow>\n                 heap (parent l (parent l xa)) \\<le> heap xa);\n     l \\<le> parent l x; heap x \\<le> heap (parent l x); bounded l r k;\n     parent l k = parent l x; bounded l r (parent l (parent l k));\n     k \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> swap heap (parent l x) x (parent l (parent l k))\n                      \\<le> swap heap (parent l x) x k", "have \"swap heap (parent l x) x k = heap k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. swap heap (parent l x) x k = heap k", "by (metis assms(5) gp_k_eq_gp_x k_neq_x swap_only_swaps)"], ["proof (state)\nthis:\n  swap heap (parent l x) x k = heap k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>xa.\n                bounded l r xa \\<longrightarrow>\n                (xa \\<noteq> x \\<longrightarrow>\n                 bounded l r (parent l xa) \\<longrightarrow>\n                 heap (parent l xa) \\<le> heap xa) \\<and>\n                (parent l xa = x \\<longrightarrow>\n                 bounded l r (parent l (parent l xa)) \\<longrightarrow>\n                 heap (parent l (parent l xa)) \\<le> heap xa);\n     l \\<le> parent l x; heap x \\<le> heap (parent l x); bounded l r k;\n     parent l k = parent l x; bounded l r (parent l (parent l k));\n     k \\<noteq> x\\<rbrakk>\n    \\<Longrightarrow> swap heap (parent l x) x (parent l (parent l k))\n                      \\<le> swap heap (parent l x) x k", "then"], ["proof (chain)\npicking this:\n  swap heap (parent l x) x k = heap k", "show ?thesis"], ["proof (prove)\nusing this:\n  swap heap (parent l x) x k = heap k\n\ngoal (1 subgoal):\n 1. swap heap (parent l x) x (parent l (parent l k))\n    \\<le> swap heap (parent l x) x k", "using assms"], ["proof (prove)\nusing this:\n  swap heap (parent l x) x k = heap k\n  is_heap_except_up (\\<le>) heap l r x\n  l \\<le> parent l x\n  heap x \\<le> heap (parent l x)\n  bounded l r k\n  parent l k = parent l x\n  bounded l r (parent l (parent l k))\n\ngoal (1 subgoal):\n 1. swap heap (parent l x) x (parent l (parent l k))\n    \\<le> swap heap (parent l x) x k", "unfolding is_heap_except_up_def"], ["proof (prove)\nusing this:\n  swap heap (parent l x) x k = heap k\n  \\<forall>xa.\n     bounded l r xa \\<longrightarrow>\n     (xa \\<noteq> x \\<longrightarrow>\n      bounded l r (parent l xa) \\<longrightarrow>\n      heap (parent l xa) \\<le> heap xa) \\<and>\n     (parent l xa = x \\<longrightarrow>\n      bounded l r (parent l (parent l xa)) \\<longrightarrow>\n      heap (parent l (parent l xa)) \\<le> heap xa)\n  l \\<le> parent l x\n  heap x \\<le> heap (parent l x)\n  bounded l r k\n  parent l k = parent l x\n  bounded l r (parent l (parent l k))\n\ngoal (1 subgoal):\n 1. swap heap (parent l x) x (parent l (parent l k))\n    \\<le> swap heap (parent l x) x k", "by (metis gp_k_eq_gp_x k_neq_x order_trans parent_bounds parent_lower_bound)"], ["proof (state)\nthis:\n  swap heap (parent l x) x (parent l (parent l k))\n  \\<le> swap heap (parent l x) x k\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  swap heap (parent l x) x (parent l (parent l k))\n  \\<le> swap heap (parent l x) x k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sift_up_step:\n  fixes heap::\"int \\<Rightarrow> int\"\n  assumes  \n    \"is_heap_except_up (\\<le>) heap l r x\"\n    \"parent l x \\<ge> l\" \n    \"(heap x) \\<le> (heap (parent l x))\"\n  shows \"is_heap_except_up (\\<le>) (swap heap (parent l x) x) l r (parent l x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_heap_except_up (\\<le>) (swap heap (parent l x) x) l r (parent l x)", "using assms sift_up_step_aux1 sift_up_step_aux2"], ["proof (prove)\nusing this:\n  is_heap_except_up (\\<le>) heap l r x\n  l \\<le> parent l x\n  heap x \\<le> heap (parent l x)\n  \\<lbrakk>is_heap_except_up (\\<le>) ?heap ?l ?r ?x; ?l \\<le> parent ?l ?x;\n   ?heap ?x \\<le> ?heap (parent ?l ?x); bounded ?l ?r ?k;\n   ?k \\<noteq> parent ?l ?x; bounded ?l ?r (parent ?l ?k)\\<rbrakk>\n  \\<Longrightarrow> swap ?heap (parent ?l ?x) ?x (parent ?l ?k)\n                    \\<le> swap ?heap (parent ?l ?x) ?x ?k\n  \\<lbrakk>is_heap_except_up (\\<le>) ?heap ?l ?r ?x; ?l \\<le> parent ?l ?x;\n   ?heap ?x \\<le> ?heap (parent ?l ?x); bounded ?l ?r ?k;\n   parent ?l ?k = parent ?l ?x;\n   bounded ?l ?r (parent ?l (parent ?l ?k))\\<rbrakk>\n  \\<Longrightarrow> swap ?heap (parent ?l ?x) ?x (parent ?l (parent ?l ?k))\n                    \\<le> swap ?heap (parent ?l ?x) ?x ?k\n\ngoal (1 subgoal):\n 1. is_heap_except_up (\\<le>) (swap heap (parent l x) x) l r (parent l x)", "unfolding is_heap_except_up_def"], ["proof (prove)\nusing this:\n  \\<forall>xa.\n     bounded l r xa \\<longrightarrow>\n     (xa \\<noteq> x \\<longrightarrow>\n      bounded l r (parent l xa) \\<longrightarrow>\n      heap (parent l xa) \\<le> heap xa) \\<and>\n     (parent l xa = x \\<longrightarrow>\n      bounded l r (parent l (parent l xa)) \\<longrightarrow>\n      heap (parent l (parent l xa)) \\<le> heap xa)\n  l \\<le> parent l x\n  heap x \\<le> heap (parent l x)\n  \\<lbrakk>\\<forall>x.\n              bounded ?l ?r x \\<longrightarrow>\n              (x \\<noteq> ?x \\<longrightarrow>\n               bounded ?l ?r (parent ?l x) \\<longrightarrow>\n               ?heap (parent ?l x) \\<le> ?heap x) \\<and>\n              (parent ?l x = ?x \\<longrightarrow>\n               bounded ?l ?r (parent ?l (parent ?l x)) \\<longrightarrow>\n               ?heap (parent ?l (parent ?l x)) \\<le> ?heap x);\n   ?l \\<le> parent ?l ?x; ?heap ?x \\<le> ?heap (parent ?l ?x);\n   bounded ?l ?r ?k; ?k \\<noteq> parent ?l ?x;\n   bounded ?l ?r (parent ?l ?k)\\<rbrakk>\n  \\<Longrightarrow> swap ?heap (parent ?l ?x) ?x (parent ?l ?k)\n                    \\<le> swap ?heap (parent ?l ?x) ?x ?k\n  \\<lbrakk>\\<forall>x.\n              bounded ?l ?r x \\<longrightarrow>\n              (x \\<noteq> ?x \\<longrightarrow>\n               bounded ?l ?r (parent ?l x) \\<longrightarrow>\n               ?heap (parent ?l x) \\<le> ?heap x) \\<and>\n              (parent ?l x = ?x \\<longrightarrow>\n               bounded ?l ?r (parent ?l (parent ?l x)) \\<longrightarrow>\n               ?heap (parent ?l (parent ?l x)) \\<le> ?heap x);\n   ?l \\<le> parent ?l ?x; ?heap ?x \\<le> ?heap (parent ?l ?x);\n   bounded ?l ?r ?k; parent ?l ?k = parent ?l ?x;\n   bounded ?l ?r (parent ?l (parent ?l ?k))\\<rbrakk>\n  \\<Longrightarrow> swap ?heap (parent ?l ?x) ?x (parent ?l (parent ?l ?k))\n                    \\<le> swap ?heap (parent ?l ?x) ?x ?k\n\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       bounded l r xa \\<longrightarrow>\n       (xa \\<noteq> parent l x \\<longrightarrow>\n        bounded l r (parent l xa) \\<longrightarrow>\n        swap heap (parent l x) x (parent l xa)\n        \\<le> swap heap (parent l x) x xa) \\<and>\n       (parent l xa = parent l x \\<longrightarrow>\n        bounded l r (parent l (parent l xa)) \\<longrightarrow>\n        swap heap (parent l x) x (parent l (parent l xa))\n        \\<le> swap heap (parent l x) x xa)", "by blast"], ["", "text \\<open>\\<open>sift_up\\<close> restores the heap invariant, that is only violated at the current position, by \n      iteratively swapping the current element with its parent until the beginning of the array is \n      reached or the current element is bigger than its parent.\\<close>"], ["", "procedure_spec sift_up (heap, l, r, x) returns heap\n  assumes \"is_heap_except_up (\\<le>) heap l r x \\<and> bounded l r x\"\n    ensures \"is_heap (\\<le>) heap l\\<^sub>0 r\\<^sub>0 \\<and>\n             arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 = arr_mset heap l\\<^sub>0 r\\<^sub>0 \\<and>\n             heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\"\n  for heap[] l x r\n  defines \\<open>\n    p = prnt(l, x);\n    while (x > l \\<and> heap[x] \\<le> heap[p]) \n      @variant \\<open>x - l\\<close>\n      @invariant \\<open>is_heap_except_up (\\<le>) heap l r x \\<and> p = parent l x \\<and> \n                  bounded l r x \\<and> arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 = arr_mset heap l r \\<and>\n                  heap\\<^sub>0 = heap  on - {l..<r}\\<close> \n    {\n        heap = swp(heap, p, x);\n        x = p;\n        p = prnt(l, x)\n    }\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT' Map.empty\n     (\\<lambda>\\<ss>.\n         VAR (\\<ss> ''heap'')\n          (\\<lambda>heap.\n              VAR (\\<ss> ''x'' 0)\n               (\\<lambda>x.\n                   VAR (\\<ss> ''r'' 0)\n                    (\\<lambda>r.\n                        VAR (\\<ss> ''l'' 0)\n                         (\\<lambda>l.\n                             BB_PROTECT\n                              (is_heap_except_up (\\<le>) heap l r x \\<and>\n                               bounded l r x))))))\n     (\\<lambda>\\<ss>\\<^sub>0.\n         (''G_par_1''[] ::= ''l'';; ''G_par_2''[] ::= ''x'';; Params prnt;;\n          ArrayCpy_retv ''p'' ''G_ret_1'');;\n         WHILE {ANNOTATION\n                 (\\<lambda>\\<ss>.\n                     VAR (\\<ss> ''x'' 0)\n                      (\\<lambda>x.\n                          VAR (\\<ss> ''l'' 0)\n                           (\\<lambda>l.\n                               BB_PROTECT\n                                (x -\n                                 l))))} {ANNOTATION\n    (\\<lambda>\\<ss>.\n        VAR (\\<ss> ''heap'')\n         (\\<lambda>heap.\n             VAR (\\<ss> ''x'' 0)\n              (\\<lambda>x.\n                  VAR (\\<ss> ''r'' 0)\n                   (\\<lambda>r.\n                       VAR (\\<ss> ''p'' 0)\n                        (\\<lambda>p.\n                            VAR (\\<ss> ''l'' 0)\n                             (\\<lambda>l.\n                                 VAR (\\<ss>\\<^sub>0 ''heap'')\n                                  (\\<lambda>heap\\<^sub>0.\nVAR (\\<ss>\\<^sub>0 ''r'' 0)\n (\\<lambda>r\\<^sub>0.\n     VAR (\\<ss>\\<^sub>0 ''l'' 0)\n      (\\<lambda>l\\<^sub>0.\n          BB_PROTECT\n           (is_heap_except_up (\\<le>) heap l r x \\<and>\n            p = parent l x \\<and>\n            bounded l r x \\<and>\n            arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n            arr_mset heap l r \\<and>\n            heap\\<^sub>0 = heap on - {l..<r}))))))))))} BBinop (\\<and>)\n                   (Cmpop (\\<lambda>x y. y < x) (V ''x'') (V ''l''))\n                   (Cmpop (\\<le>) (Vidx ''heap'' (V ''x''))\n                     (Vidx ''heap'' (V ''p'')))\n         DO ((''G_par_1''[] ::= ''heap'';; ''G_par_2''[] ::= ''p'';;\n              ''G_par_3''[] ::= ''x'';; Params swp;;\n              ArrayCpy_retv ''heap'' ''G_ret_1'');;\n             ''x''[] ::= ''p'';; ''G_par_1''[] ::= ''l'';;\n             ''G_par_2''[] ::= ''x'';; Params prnt;;\n             ArrayCpy_retv ''p'' ''G_ret_1''))\n     (\\<lambda>\\<ss>\\<^sub>0 \\<ss>.\n         VAR (\\<ss> ''heap'')\n          (\\<lambda>heap.\n              VAR (\\<ss>\\<^sub>0 ''heap'')\n               (\\<lambda>heap\\<^sub>0.\n                   VAR (\\<ss>\\<^sub>0 ''r'' 0)\n                    (\\<lambda>r\\<^sub>0.\n                        VAR (\\<ss>\\<^sub>0 ''l'' 0)\n                         (\\<lambda>l\\<^sub>0.\n                             BB_PROTECT\n                              (is_heap (\\<le>) heap l\\<^sub>0\n                                r\\<^sub>0 \\<and>\n                               arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n                               arr_mset heap l\\<^sub>0 r\\<^sub>0 \\<and>\n                               heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}))))))", "apply vcg_cs"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''Invar pres'';\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x; l\\<^sub>0 < x;\n        heap x \\<le> heap (parent l\\<^sub>0 x); l\\<^sub>0 \\<le> x\\<^sub>0;\n        x\\<^sub>0 < r\\<^sub>0; x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_heap_except_up (\\<le>)\n                          (swap heap (parent l\\<^sub>0 x) x) l\\<^sub>0\n                          r\\<^sub>0 (parent l\\<^sub>0 x) \\<and>\n                         l\\<^sub>0 \\<le> parent l\\<^sub>0 x \\<and>\n                         parent l\\<^sub>0 x < r\\<^sub>0 \\<and>\n                         arr_mset heap l\\<^sub>0 r\\<^sub>0 =\n                         arr_mset (swap heap (parent l\\<^sub>0 x) x)\n                          l\\<^sub>0 r\\<^sub>0 \\<and>\n                         heap\\<^sub>0 = swap heap (parent l\\<^sub>0 x)\n   x on - {l\\<^sub>0..<r\\<^sub>0}\n 2. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''Var pres'';\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x; l\\<^sub>0 < x;\n        heap x \\<le> heap (parent l\\<^sub>0 x); l\\<^sub>0 \\<le> x\\<^sub>0;\n        x\\<^sub>0 < r\\<^sub>0; x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> parent l\\<^sub>0 x < x\n 3. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''invar-post'';\n        l\\<^sub>0 < x \\<longrightarrow>\n        \\<not> heap x \\<le> heap (parent l\\<^sub>0 x);\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x;\n        l\\<^sub>0 \\<le> x\\<^sub>0; x\\<^sub>0 < r\\<^sub>0; l\\<^sub>0 \\<le> x;\n        x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_heap (\\<le>) heap l\\<^sub>0 r\\<^sub>0", "apply(intro conjI)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''Invar pres'';\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x; l\\<^sub>0 < x;\n        heap x \\<le> heap (parent l\\<^sub>0 x); l\\<^sub>0 \\<le> x\\<^sub>0;\n        x\\<^sub>0 < r\\<^sub>0; x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_heap_except_up (\\<le>)\n                          (swap heap (parent l\\<^sub>0 x) x) l\\<^sub>0\n                          r\\<^sub>0 (parent l\\<^sub>0 x)\n 2. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''Invar pres'';\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x; l\\<^sub>0 < x;\n        heap x \\<le> heap (parent l\\<^sub>0 x); l\\<^sub>0 \\<le> x\\<^sub>0;\n        x\\<^sub>0 < r\\<^sub>0; x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> l\\<^sub>0 \\<le> parent l\\<^sub>0 x\n 3. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''Invar pres'';\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x; l\\<^sub>0 < x;\n        heap x \\<le> heap (parent l\\<^sub>0 x); l\\<^sub>0 \\<le> x\\<^sub>0;\n        x\\<^sub>0 < r\\<^sub>0; x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> parent l\\<^sub>0 x < r\\<^sub>0\n 4. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''Invar pres'';\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x; l\\<^sub>0 < x;\n        heap x \\<le> heap (parent l\\<^sub>0 x); l\\<^sub>0 \\<le> x\\<^sub>0;\n        x\\<^sub>0 < r\\<^sub>0; x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> arr_mset heap l\\<^sub>0 r\\<^sub>0 =\n                         arr_mset (swap heap (parent l\\<^sub>0 x) x)\n                          l\\<^sub>0 r\\<^sub>0\n 5. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''Invar pres'';\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x; l\\<^sub>0 < x;\n        heap x \\<le> heap (parent l\\<^sub>0 x); l\\<^sub>0 \\<le> x\\<^sub>0;\n        x\\<^sub>0 < r\\<^sub>0; x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> heap\\<^sub>0 = swap heap (parent l\\<^sub>0 x)\n   x on - {l\\<^sub>0..<r\\<^sub>0}\n 6. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''Var pres'';\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x; l\\<^sub>0 < x;\n        heap x \\<le> heap (parent l\\<^sub>0 x); l\\<^sub>0 \\<le> x\\<^sub>0;\n        x\\<^sub>0 < r\\<^sub>0; x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> parent l\\<^sub>0 x < x\n 7. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''invar-post'';\n        l\\<^sub>0 < x \\<longrightarrow>\n        \\<not> heap x \\<le> heap (parent l\\<^sub>0 x);\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x;\n        l\\<^sub>0 \\<le> x\\<^sub>0; x\\<^sub>0 < r\\<^sub>0; l\\<^sub>0 \\<le> x;\n        x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_heap (\\<le>) heap l\\<^sub>0 r\\<^sub>0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres'';\n     is_heap_except_up (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_\n      x\\<^sub>0_;\n     is_heap_except_up (\\<le>) heap_ l\\<^sub>0_ r\\<^sub>0_ x_;\n     l\\<^sub>0_ < x_; heap_ x_ \\<le> heap_ (parent l\\<^sub>0_ x_);\n     l\\<^sub>0_ \\<le> x\\<^sub>0_; x\\<^sub>0_ < r\\<^sub>0_; x_ < r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> is_heap_except_up (\\<le>)\n                       (swap heap_ (parent l\\<^sub>0_ x_) x_) l\\<^sub>0_\n                       r\\<^sub>0_ (parent l\\<^sub>0_ x_)", "using parent_lower_bound sift_up_step"], ["proof (prove)\nusing this:\n  (?l \\<le> parent ?l ?c) = (?l < ?c)\n  \\<lbrakk>is_heap_except_up (\\<le>) ?heap ?l ?r ?x; ?l \\<le> parent ?l ?x;\n   ?heap ?x \\<le> ?heap (parent ?l ?x)\\<rbrakk>\n  \\<Longrightarrow> is_heap_except_up (\\<le>) (swap ?heap (parent ?l ?x) ?x)\n                     ?l ?r (parent ?l ?x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres'';\n     is_heap_except_up (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_\n      x\\<^sub>0_;\n     is_heap_except_up (\\<le>) heap_ l\\<^sub>0_ r\\<^sub>0_ x_;\n     l\\<^sub>0_ < x_; heap_ x_ \\<le> heap_ (parent l\\<^sub>0_ x_);\n     l\\<^sub>0_ \\<le> x\\<^sub>0_; x\\<^sub>0_ < r\\<^sub>0_; x_ < r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> is_heap_except_up (\\<le>)\n                       (swap heap_ (parent l\\<^sub>0_ x_) x_) l\\<^sub>0_\n                       r\\<^sub>0_ (parent l\\<^sub>0_ x_)", "by blast"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''Invar pres'';\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x; l\\<^sub>0 < x;\n        heap x \\<le> heap (parent l\\<^sub>0 x); l\\<^sub>0 \\<le> x\\<^sub>0;\n        x\\<^sub>0 < r\\<^sub>0; x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> l\\<^sub>0 \\<le> parent l\\<^sub>0 x\n 2. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''Invar pres'';\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x; l\\<^sub>0 < x;\n        heap x \\<le> heap (parent l\\<^sub>0 x); l\\<^sub>0 \\<le> x\\<^sub>0;\n        x\\<^sub>0 < r\\<^sub>0; x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> parent l\\<^sub>0 x < r\\<^sub>0\n 3. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''Invar pres'';\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x; l\\<^sub>0 < x;\n        heap x \\<le> heap (parent l\\<^sub>0 x); l\\<^sub>0 \\<le> x\\<^sub>0;\n        x\\<^sub>0 < r\\<^sub>0; x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> arr_mset heap l\\<^sub>0 r\\<^sub>0 =\n                         arr_mset (swap heap (parent l\\<^sub>0 x) x)\n                          l\\<^sub>0 r\\<^sub>0\n 4. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''Invar pres'';\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x; l\\<^sub>0 < x;\n        heap x \\<le> heap (parent l\\<^sub>0 x); l\\<^sub>0 \\<le> x\\<^sub>0;\n        x\\<^sub>0 < r\\<^sub>0; x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> heap\\<^sub>0 = swap heap (parent l\\<^sub>0 x)\n   x on - {l\\<^sub>0..<r\\<^sub>0}\n 5. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''Var pres'';\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x; l\\<^sub>0 < x;\n        heap x \\<le> heap (parent l\\<^sub>0 x); l\\<^sub>0 \\<le> x\\<^sub>0;\n        x\\<^sub>0 < r\\<^sub>0; x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> parent l\\<^sub>0 x < x\n 6. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''invar-post'';\n        l\\<^sub>0 < x \\<longrightarrow>\n        \\<not> heap x \\<le> heap (parent l\\<^sub>0 x);\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x;\n        l\\<^sub>0 \\<le> x\\<^sub>0; x\\<^sub>0 < r\\<^sub>0; l\\<^sub>0 \\<le> x;\n        x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_heap (\\<le>) heap l\\<^sub>0 r\\<^sub>0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres'';\n     is_heap_except_up (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_\n      x\\<^sub>0_;\n     is_heap_except_up (\\<le>) heap_ l\\<^sub>0_ r\\<^sub>0_ x_;\n     l\\<^sub>0_ < x_; heap_ x_ \\<le> heap_ (parent l\\<^sub>0_ x_);\n     l\\<^sub>0_ \\<le> x\\<^sub>0_; x\\<^sub>0_ < r\\<^sub>0_; x_ < r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> l\\<^sub>0_ \\<le> parent l\\<^sub>0_ x_", "using parent_lower_bound"], ["proof (prove)\nusing this:\n  (?l \\<le> parent ?l ?c) = (?l < ?c)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres'';\n     is_heap_except_up (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_\n      x\\<^sub>0_;\n     is_heap_except_up (\\<le>) heap_ l\\<^sub>0_ r\\<^sub>0_ x_;\n     l\\<^sub>0_ < x_; heap_ x_ \\<le> heap_ (parent l\\<^sub>0_ x_);\n     l\\<^sub>0_ \\<le> x\\<^sub>0_; x\\<^sub>0_ < r\\<^sub>0_; x_ < r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> l\\<^sub>0_ \\<le> parent l\\<^sub>0_ x_", "by blast"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''Invar pres'';\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x; l\\<^sub>0 < x;\n        heap x \\<le> heap (parent l\\<^sub>0 x); l\\<^sub>0 \\<le> x\\<^sub>0;\n        x\\<^sub>0 < r\\<^sub>0; x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> parent l\\<^sub>0 x < r\\<^sub>0\n 2. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''Invar pres'';\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x; l\\<^sub>0 < x;\n        heap x \\<le> heap (parent l\\<^sub>0 x); l\\<^sub>0 \\<le> x\\<^sub>0;\n        x\\<^sub>0 < r\\<^sub>0; x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> arr_mset heap l\\<^sub>0 r\\<^sub>0 =\n                         arr_mset (swap heap (parent l\\<^sub>0 x) x)\n                          l\\<^sub>0 r\\<^sub>0\n 3. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''Invar pres'';\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x; l\\<^sub>0 < x;\n        heap x \\<le> heap (parent l\\<^sub>0 x); l\\<^sub>0 \\<le> x\\<^sub>0;\n        x\\<^sub>0 < r\\<^sub>0; x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> heap\\<^sub>0 = swap heap (parent l\\<^sub>0 x)\n   x on - {l\\<^sub>0..<r\\<^sub>0}\n 4. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''Var pres'';\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x; l\\<^sub>0 < x;\n        heap x \\<le> heap (parent l\\<^sub>0 x); l\\<^sub>0 \\<le> x\\<^sub>0;\n        x\\<^sub>0 < r\\<^sub>0; x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> parent l\\<^sub>0 x < x\n 5. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''invar-post'';\n        l\\<^sub>0 < x \\<longrightarrow>\n        \\<not> heap x \\<le> heap (parent l\\<^sub>0 x);\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x;\n        l\\<^sub>0 \\<le> x\\<^sub>0; x\\<^sub>0 < r\\<^sub>0; l\\<^sub>0 \\<le> x;\n        x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_heap (\\<le>) heap l\\<^sub>0 r\\<^sub>0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres'';\n     is_heap_except_up (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_\n      x\\<^sub>0_;\n     is_heap_except_up (\\<le>) heap_ l\\<^sub>0_ r\\<^sub>0_ x_;\n     l\\<^sub>0_ < x_; heap_ x_ \\<le> heap_ (parent l\\<^sub>0_ x_);\n     l\\<^sub>0_ \\<le> x\\<^sub>0_; x\\<^sub>0_ < r\\<^sub>0_; x_ < r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> parent l\\<^sub>0_ x_ < r\\<^sub>0_", "using parent_bounds"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l < ?x; ?x < ?r\\<rbrakk>\n  \\<Longrightarrow> bounded ?l ?r (parent ?l ?x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres'';\n     is_heap_except_up (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_\n      x\\<^sub>0_;\n     is_heap_except_up (\\<le>) heap_ l\\<^sub>0_ r\\<^sub>0_ x_;\n     l\\<^sub>0_ < x_; heap_ x_ \\<le> heap_ (parent l\\<^sub>0_ x_);\n     l\\<^sub>0_ \\<le> x\\<^sub>0_; x\\<^sub>0_ < r\\<^sub>0_; x_ < r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> parent l\\<^sub>0_ x_ < r\\<^sub>0_", "by blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''Invar pres'';\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x; l\\<^sub>0 < x;\n        heap x \\<le> heap (parent l\\<^sub>0 x); l\\<^sub>0 \\<le> x\\<^sub>0;\n        x\\<^sub>0 < r\\<^sub>0; x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> arr_mset heap l\\<^sub>0 r\\<^sub>0 =\n                         arr_mset (swap heap (parent l\\<^sub>0 x) x)\n                          l\\<^sub>0 r\\<^sub>0\n 2. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''Invar pres'';\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x; l\\<^sub>0 < x;\n        heap x \\<le> heap (parent l\\<^sub>0 x); l\\<^sub>0 \\<le> x\\<^sub>0;\n        x\\<^sub>0 < r\\<^sub>0; x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> heap\\<^sub>0 = swap heap (parent l\\<^sub>0 x)\n   x on - {l\\<^sub>0..<r\\<^sub>0}\n 3. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''Var pres'';\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x; l\\<^sub>0 < x;\n        heap x \\<le> heap (parent l\\<^sub>0 x); l\\<^sub>0 \\<le> x\\<^sub>0;\n        x\\<^sub>0 < r\\<^sub>0; x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> parent l\\<^sub>0 x < x\n 4. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''invar-post'';\n        l\\<^sub>0 < x \\<longrightarrow>\n        \\<not> heap x \\<le> heap (parent l\\<^sub>0 x);\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x;\n        l\\<^sub>0 \\<le> x\\<^sub>0; x\\<^sub>0 < r\\<^sub>0; l\\<^sub>0 \\<le> x;\n        x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_heap (\\<le>) heap l\\<^sub>0 r\\<^sub>0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres'';\n     is_heap_except_up (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_\n      x\\<^sub>0_;\n     is_heap_except_up (\\<le>) heap_ l\\<^sub>0_ r\\<^sub>0_ x_;\n     l\\<^sub>0_ < x_; heap_ x_ \\<le> heap_ (parent l\\<^sub>0_ x_);\n     l\\<^sub>0_ \\<le> x\\<^sub>0_; x\\<^sub>0_ < r\\<^sub>0_; x_ < r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_ =\n                      arr_mset (swap heap_ (parent l\\<^sub>0_ x_) x_)\n                       l\\<^sub>0_ r\\<^sub>0_", "using parent_bounds"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l < ?x; ?x < ?r\\<rbrakk>\n  \\<Longrightarrow> bounded ?l ?r (parent ?l ?x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres'';\n     is_heap_except_up (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_\n      x\\<^sub>0_;\n     is_heap_except_up (\\<le>) heap_ l\\<^sub>0_ r\\<^sub>0_ x_;\n     l\\<^sub>0_ < x_; heap_ x_ \\<le> heap_ (parent l\\<^sub>0_ x_);\n     l\\<^sub>0_ \\<le> x\\<^sub>0_; x\\<^sub>0_ < r\\<^sub>0_; x_ < r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_ =\n                      arr_mset (swap heap_ (parent l\\<^sub>0_ x_) x_)\n                       l\\<^sub>0_ r\\<^sub>0_", "by (simp add: mset_ran_swap)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''Invar pres'';\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x; l\\<^sub>0 < x;\n        heap x \\<le> heap (parent l\\<^sub>0 x); l\\<^sub>0 \\<le> x\\<^sub>0;\n        x\\<^sub>0 < r\\<^sub>0; x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> heap\\<^sub>0 = swap heap (parent l\\<^sub>0 x)\n   x on - {l\\<^sub>0..<r\\<^sub>0}\n 2. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''Var pres'';\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x; l\\<^sub>0 < x;\n        heap x \\<le> heap (parent l\\<^sub>0 x); l\\<^sub>0 \\<le> x\\<^sub>0;\n        x\\<^sub>0 < r\\<^sub>0; x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> parent l\\<^sub>0 x < x\n 3. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''invar-post'';\n        l\\<^sub>0 < x \\<longrightarrow>\n        \\<not> heap x \\<le> heap (parent l\\<^sub>0 x);\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x;\n        l\\<^sub>0 \\<le> x\\<^sub>0; x\\<^sub>0 < r\\<^sub>0; l\\<^sub>0 \\<le> x;\n        x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_heap (\\<le>) heap l\\<^sub>0 r\\<^sub>0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres'';\n     is_heap_except_up (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_\n      x\\<^sub>0_;\n     is_heap_except_up (\\<le>) heap_ l\\<^sub>0_ r\\<^sub>0_ x_;\n     l\\<^sub>0_ < x_; heap_ x_ \\<le> heap_ (parent l\\<^sub>0_ x_);\n     l\\<^sub>0_ \\<le> x\\<^sub>0_; x\\<^sub>0_ < r\\<^sub>0_; x_ < r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> heap\\<^sub>0_ = swap heap_ (parent l\\<^sub>0_ x_)\n x_ on - {l\\<^sub>0_..<r\\<^sub>0_}", "using swap_parent_eq_on"], ["proof (prove)\nusing this:\n  \\<lbrakk>?arr1.0 = ?arr2.0 on - {?l..<?r}; ?l < ?c; ?c < ?r\\<rbrakk>\n  \\<Longrightarrow> ?arr1.0 = swap ?arr2.0 (parent ?l ?c) ?c on - {?l..<?r}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres'';\n     is_heap_except_up (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_\n      x\\<^sub>0_;\n     is_heap_except_up (\\<le>) heap_ l\\<^sub>0_ r\\<^sub>0_ x_;\n     l\\<^sub>0_ < x_; heap_ x_ \\<le> heap_ (parent l\\<^sub>0_ x_);\n     l\\<^sub>0_ \\<le> x\\<^sub>0_; x\\<^sub>0_ < r\\<^sub>0_; x_ < r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> heap\\<^sub>0_ = swap heap_ (parent l\\<^sub>0_ x_)\n x_ on - {l\\<^sub>0_..<r\\<^sub>0_}", "by blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''Var pres'';\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x; l\\<^sub>0 < x;\n        heap x \\<le> heap (parent l\\<^sub>0 x); l\\<^sub>0 \\<le> x\\<^sub>0;\n        x\\<^sub>0 < r\\<^sub>0; x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> parent l\\<^sub>0 x < x\n 2. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''invar-post'';\n        l\\<^sub>0 < x \\<longrightarrow>\n        \\<not> heap x \\<le> heap (parent l\\<^sub>0 x);\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x;\n        l\\<^sub>0 \\<le> x\\<^sub>0; x\\<^sub>0 < r\\<^sub>0; l\\<^sub>0 \\<le> x;\n        x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_heap (\\<le>) heap l\\<^sub>0 r\\<^sub>0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Var pres'';\n     is_heap_except_up (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_\n      x\\<^sub>0_;\n     is_heap_except_up (\\<le>) heap_ l\\<^sub>0_ r\\<^sub>0_ x_;\n     l\\<^sub>0_ < x_; heap_ x_ \\<le> heap_ (parent l\\<^sub>0_ x_);\n     l\\<^sub>0_ \\<le> x\\<^sub>0_; x\\<^sub>0_ < r\\<^sub>0_; x_ < r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> parent l\\<^sub>0_ x_ < x_", "using parent_upper_bound"], ["proof (prove)\nusing this:\n  (parent ?l ?c < ?c) = (?l \\<le> ?c)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Var pres'';\n     is_heap_except_up (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_\n      x\\<^sub>0_;\n     is_heap_except_up (\\<le>) heap_ l\\<^sub>0_ r\\<^sub>0_ x_;\n     l\\<^sub>0_ < x_; heap_ x_ \\<le> heap_ (parent l\\<^sub>0_ x_);\n     l\\<^sub>0_ \\<le> x\\<^sub>0_; x\\<^sub>0_ < r\\<^sub>0_; x_ < r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> parent l\\<^sub>0_ x_ < x_", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''invar-post'';\n        l\\<^sub>0 < x \\<longrightarrow>\n        \\<not> heap x \\<le> heap (parent l\\<^sub>0 x);\n        is_heap_except_up (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\n         x\\<^sub>0;\n        is_heap_except_up (\\<le>) heap l\\<^sub>0 r\\<^sub>0 x;\n        l\\<^sub>0 \\<le> x\\<^sub>0; x\\<^sub>0 < r\\<^sub>0; l\\<^sub>0 \\<le> x;\n        x < r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_heap (\\<le>) heap l\\<^sub>0 r\\<^sub>0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''invar-post'';\n     l\\<^sub>0_ < x_ \\<longrightarrow>\n     \\<not> heap_ x_ \\<le> heap_ (parent l\\<^sub>0_ x_);\n     is_heap_except_up (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_\n      x\\<^sub>0_;\n     is_heap_except_up (\\<le>) heap_ l\\<^sub>0_ r\\<^sub>0_ x_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_; x\\<^sub>0_ < r\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x_; x_ < r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> is_heap (\\<le>) heap_ l\\<^sub>0_ r\\<^sub>0_", "unfolding is_heap_except_up_def is_partial_heap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''invar-post'';\n     l\\<^sub>0_ < x_ \\<longrightarrow>\n     \\<not> heap_ x_ \\<le> heap_ (parent l\\<^sub>0_ x_);\n     \\<forall>x.\n        bounded l\\<^sub>0_ r\\<^sub>0_ x \\<longrightarrow>\n        (x \\<noteq> x\\<^sub>0_ \\<longrightarrow>\n         bounded l\\<^sub>0_ r\\<^sub>0_\n          (parent l\\<^sub>0_ x) \\<longrightarrow>\n         heap\\<^sub>0_ (parent l\\<^sub>0_ x) \\<le> heap\\<^sub>0_ x) \\<and>\n        (parent l\\<^sub>0_ x = x\\<^sub>0_ \\<longrightarrow>\n         bounded l\\<^sub>0_ r\\<^sub>0_\n          (parent l\\<^sub>0_ (parent l\\<^sub>0_ x)) \\<longrightarrow>\n         heap\\<^sub>0_ (parent l\\<^sub>0_ (parent l\\<^sub>0_ x))\n         \\<le> heap\\<^sub>0_ x);\n     \\<forall>xa.\n        bounded l\\<^sub>0_ r\\<^sub>0_ xa \\<longrightarrow>\n        (xa \\<noteq> x_ \\<longrightarrow>\n         bounded l\\<^sub>0_ r\\<^sub>0_\n          (parent l\\<^sub>0_ xa) \\<longrightarrow>\n         heap_ (parent l\\<^sub>0_ xa) \\<le> heap_ xa) \\<and>\n        (parent l\\<^sub>0_ xa = x_ \\<longrightarrow>\n         bounded l\\<^sub>0_ r\\<^sub>0_\n          (parent l\\<^sub>0_ (parent l\\<^sub>0_ xa)) \\<longrightarrow>\n         heap_ (parent l\\<^sub>0_ (parent l\\<^sub>0_ xa)) \\<le> heap_ xa);\n     l\\<^sub>0_ \\<le> x\\<^sub>0_; x\\<^sub>0_ < r\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x_; x_ < r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         bounded l\\<^sub>0_ r\\<^sub>0_ x \\<longrightarrow>\n                         bounded l\\<^sub>0_ r\\<^sub>0_\n                          (parent l\\<^sub>0_ x) \\<longrightarrow>\n                         heap_ (parent l\\<^sub>0_ x) \\<le> heap_ x", "by (metis le_less not_less parent_lower_bound)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\\<open>insert\\<close> inserts an element into a heap by appending it to the heap and restoring the heap \n      invariant with @{const \"sift_up\"}.\\<close>"], ["", "procedure_spec insert (heap, l, r, el) returns (heap, l, r)\n  assumes \"is_heap (\\<le>) heap l r \\<and> l \\<le> r\"  \n    ensures \"is_heap (\\<le>) heap l r \\<and>\n             arr_mset heap l r = arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 + {#el\\<^sub>0#} \\<and>\n             l = l\\<^sub>0 \\<and> r = r\\<^sub>0 + 1  \\<and> heap\\<^sub>0 = heap on - {l..<r}\"\n  for heap l r el\n  defines \\<open>\n    heap[r] = el;\n    x = r;\n    r = r + 1;\n    heap = sift_up(heap, l, r, x)\n  \\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT' Map.empty\n     (\\<lambda>\\<ss>.\n         VAR (\\<ss> ''heap'')\n          (\\<lambda>heap.\n              VAR (\\<ss> ''r'' 0)\n               (\\<lambda>r.\n                   VAR (\\<ss> ''l'' 0)\n                    (\\<lambda>l.\n                        BB_PROTECT\n                         (is_heap (\\<le>) heap l r \\<and> l \\<le> r)))))\n     (\\<lambda>\\<ss>\\<^sub>0. ''heap''[V ''r''] ::= V ''el'';;\n         ''x''[] ::= ''r'';; ''r'' ::= Binop (+) (V ''r'') (N 1);;\n         ''G_par_1''[] ::= ''heap'';; ''G_par_2''[] ::= ''l'';;\n         ''G_par_3''[] ::= ''r'';; ''G_par_4''[] ::= ''x'';;\n         Params sift_up;; ArrayCpy_retv ''heap'' ''G_ret_1'')\n     (\\<lambda>\\<ss>\\<^sub>0 \\<ss>.\n         VAR (\\<ss> ''heap'')\n          (\\<lambda>heap.\n              VAR (\\<ss> ''r'' 0)\n               (\\<lambda>r.\n                   VAR (\\<ss> ''l'' 0)\n                    (\\<lambda>l.\n                        VAR (\\<ss>\\<^sub>0 ''heap'')\n                         (\\<lambda>heap\\<^sub>0.\n                             VAR (\\<ss>\\<^sub>0 ''el'' 0)\n                              (\\<lambda>el\\<^sub>0.\n                                  VAR (\\<ss>\\<^sub>0 ''r'' 0)\n                                   (\\<lambda>r\\<^sub>0.\n VAR (\\<ss>\\<^sub>0 ''l'' 0)\n  (\\<lambda>l\\<^sub>0.\n      BB_PROTECT\n       (is_heap (\\<le>) heap l r \\<and>\n        arr_mset heap l r =\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 + {#el\\<^sub>0#} \\<and>\n        l = l\\<^sub>0 \\<and>\n        r = r\\<^sub>0 + 1 \\<and> heap\\<^sub>0 = heap on - {l..<r})))))))))", "apply vcg_cs"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r\\<^sub>0 l\\<^sub>0 el\\<^sub>0 heap\\<^sub>0.\n       \\<lbrakk>is_heap (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0;\n        l\\<^sub>0 \\<le> r\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> is_heap_except_up (\\<le>)\n                          (heap\\<^sub>0(r\\<^sub>0 := el\\<^sub>0)) l\\<^sub>0\n                          (r\\<^sub>0 + 1) r\\<^sub>0\n 2. \\<And>r\\<^sub>0 l\\<^sub>0 el\\<^sub>0 heap\\<^sub>0 heap'.\n       \\<lbrakk>is_heap (\\<le>) heap\\<^sub>0 l\\<^sub>0 (r\\<^sub>0 0);\n        l\\<^sub>0 \\<le> r\\<^sub>0 0;\n        is_heap (\\<le>) heap' l\\<^sub>0 (r\\<^sub>0 0 + 1);\n        arr_mset (heap\\<^sub>0(r\\<^sub>0 0 := el\\<^sub>0)) l\\<^sub>0\n         (r\\<^sub>0 0 + 1) =\n        arr_mset heap' l\\<^sub>0 (r\\<^sub>0 0 + 1);\n        heap\\<^sub>0 = heap' on - {l\\<^sub>0..<r\\<^sub>0 0 + 1}\\<rbrakk>\n       \\<Longrightarrow> arr_mset heap' l\\<^sub>0 (r\\<^sub>0 0 + 1) =\n                         add_mset el\\<^sub>0\n                          (arr_mset heap\\<^sub>0 l\\<^sub>0 (r\\<^sub>0 0))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_heap (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_;\n     l\\<^sub>0_ \\<le> r\\<^sub>0_\\<rbrakk>\n    \\<Longrightarrow> is_heap_except_up (\\<le>)\n                       (heap\\<^sub>0_(r\\<^sub>0_ := el\\<^sub>0_)) l\\<^sub>0_\n                       (r\\<^sub>0_ + 1) r\\<^sub>0_", "by (simp add: heap_appended_el)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r\\<^sub>0 l\\<^sub>0 el\\<^sub>0 heap\\<^sub>0 heap'.\n       \\<lbrakk>is_heap (\\<le>) heap\\<^sub>0 l\\<^sub>0 (r\\<^sub>0 0);\n        l\\<^sub>0 \\<le> r\\<^sub>0 0;\n        is_heap (\\<le>) heap' l\\<^sub>0 (r\\<^sub>0 0 + 1);\n        arr_mset (heap\\<^sub>0(r\\<^sub>0 0 := el\\<^sub>0)) l\\<^sub>0\n         (r\\<^sub>0 0 + 1) =\n        arr_mset heap' l\\<^sub>0 (r\\<^sub>0 0 + 1);\n        heap\\<^sub>0 = heap' on - {l\\<^sub>0..<r\\<^sub>0 0 + 1}\\<rbrakk>\n       \\<Longrightarrow> arr_mset heap' l\\<^sub>0 (r\\<^sub>0 0 + 1) =\n                         add_mset el\\<^sub>0\n                          (arr_mset heap\\<^sub>0 l\\<^sub>0 (r\\<^sub>0 0))", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_heap (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ (r\\<^sub>0_ 0);\n     l\\<^sub>0_ \\<le> r\\<^sub>0_ 0;\n     is_heap (\\<le>) heap'_ l\\<^sub>0_ (r\\<^sub>0_ 0 + 1);\n     arr_mset (heap\\<^sub>0_(r\\<^sub>0_ 0 := el\\<^sub>0_)) l\\<^sub>0_\n      (r\\<^sub>0_ 0 + 1) =\n     arr_mset heap'_ l\\<^sub>0_ (r\\<^sub>0_ 0 + 1);\n     heap\\<^sub>0_ = heap'_ on - {l\\<^sub>0_..<r\\<^sub>0_ 0 + 1}\\<rbrakk>\n    \\<Longrightarrow> arr_mset heap'_ l\\<^sub>0_ (r\\<^sub>0_ 0 + 1) =\n                      add_mset el\\<^sub>0_\n                       (arr_mset heap\\<^sub>0_ l\\<^sub>0_ (r\\<^sub>0_ 0))", "by (metis arr_mset_append_alt add_mset_add_single)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>\\<open>sift_down\\<close>, \\<open>del_min\\<close> and \\<open>make_heap\\<close>\\<close>"], ["", "text \\<open>The next heap functions are \\<open>del_min\\<close> and \\<open>make_heap\\<close>, which both use \\<open>sift_down\\<close> to \n      restore/establish the heap invariant. \\<open>sift_down\\<close> is proven first (this time without \n      additional auxiliary lemmas) followed by \\<open>del_min\\<close> and \\<open>make_heap\\<close>.\\<close>"], ["", "text \\<open>\\<open>sift_down\\<close> restores the heap invariant, that is only violated at the current position, by \n      iteratively swapping the current element with its smallest child until the end of \n      the array is reached or the current element is smaller than its children.\\<close>"], ["", "procedure_spec sift_down(heap, l, r, x) returns heap \n  assumes \"is_partial_heap_except_down (\\<le>) heap l x r x \\<and> l \\<le> x \\<and> x \\<le> r\"\n    ensures \"is_partial_heap (\\<le>) heap l\\<^sub>0 x\\<^sub>0 r\\<^sub>0 \\<and> \n             arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 = arr_mset heap l\\<^sub>0 r\\<^sub>0 \\<and> \n             heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\"\n  defines \\<open>\n   lc = left_child(l, x);\n   rc = right_child(l, x);\n    while (lc < r \\<and> (heap[lc] < heap[x] \\<or> (rc < r \\<and> heap[rc] < heap[x]))) \n      @variant \\<open>r - x\\<close>\n      @invariant \\<open>is_partial_heap_except_down (\\<le>) heap l x\\<^sub>0 r x \\<and>\n                  x\\<^sub>0 \\<le> x \\<and> x \\<le> r \\<and> lc = l_child l x \\<and> rc = r_child l x \\<and>\n                  arr_mset heap\\<^sub>0 l r = arr_mset heap l r \\<and>\n                  heap\\<^sub>0 = heap on - {l..<r}\\<close>\n  { \n    smallest = lc;\n    if (rc < r \\<and> heap[rc] < heap[lc]) {\n      smallest = rc\n    };\n    heap = swp(heap, x, smallest);\n    x = smallest;\n    lc = left_child(l, x);\n    rc = right_child(l, x)\n  }\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT' Map.empty\n     (\\<lambda>\\<ss>.\n         VAR (\\<ss> ''heap'')\n          (\\<lambda>heap.\n              VAR (\\<ss> ''x'' 0)\n               (\\<lambda>x.\n                   VAR (\\<ss> ''r'' 0)\n                    (\\<lambda>r.\n                        VAR (\\<ss> ''l'' 0)\n                         (\\<lambda>l.\n                             BB_PROTECT\n                              (is_partial_heap_except_down (\\<le>) heap l x\n                                r x \\<and>\n                               l \\<le> x \\<and> x \\<le> r))))))\n     (\\<lambda>\\<ss>\\<^sub>0.\n         (''G_par_1''[] ::= ''l'';; ''G_par_2''[] ::= ''x'';;\n          Params left_child;; ArrayCpy_retv ''lc'' ''G_ret_1'');;\n         (''G_par_1''[] ::= ''l'';; ''G_par_2''[] ::= ''x'';;\n          Params right_child;; ArrayCpy_retv ''rc'' ''G_ret_1'');;\n         WHILE {ANNOTATION\n                 (\\<lambda>\\<ss>.\n                     VAR (\\<ss> ''x'' 0)\n                      (\\<lambda>x.\n                          VAR (\\<ss> ''r'' 0)\n                           (\\<lambda>r.\n                               BB_PROTECT\n                                (r -\n                                 x))))} {ANNOTATION\n    (\\<lambda>\\<ss>.\n        VAR (\\<ss> ''heap'')\n         (\\<lambda>heap.\n             VAR (\\<ss> ''rc'' 0)\n              (\\<lambda>rc.\n                  VAR (\\<ss> ''lc'' 0)\n                   (\\<lambda>lc.\n                       VAR (\\<ss> ''x'' 0)\n                        (\\<lambda>x.\n                            VAR (\\<ss> ''r'' 0)\n                             (\\<lambda>r.\n                                 VAR (\\<ss> ''l'' 0)\n                                  (\\<lambda>l.\nVAR (\\<ss>\\<^sub>0 ''heap'')\n (\\<lambda>heap\\<^sub>0.\n     VAR (\\<ss>\\<^sub>0 ''x'' 0)\n      (\\<lambda>x\\<^sub>0.\n          BB_PROTECT\n           (is_partial_heap_except_down (\\<le>) heap l x\\<^sub>0 r x \\<and>\n            x\\<^sub>0 \\<le> x \\<and>\n            x \\<le> r \\<and>\n            lc = l_child l x \\<and>\n            rc = r_child l x \\<and>\n            arr_mset heap\\<^sub>0 l r = arr_mset heap l r \\<and>\n            heap\\<^sub>0 = heap on - {l..<r}))))))))))} BBinop (\\<and>)\n                   (Cmpop (<) (V ''lc'') (V ''r''))\n                   (BBinop (\\<or>)\n                     (Cmpop (<) (Vidx ''heap'' (V ''lc''))\n                       (Vidx ''heap'' (V ''x'')))\n                     (BBinop (\\<and>) (Cmpop (<) (V ''rc'') (V ''r''))\n                       (Cmpop (<) (Vidx ''heap'' (V ''rc''))\n                         (Vidx ''heap'' (V ''x'')))))\n         DO (''smallest''[] ::= ''lc'';;\n             IF BBinop (\\<and>) (Cmpop (<) (V ''rc'') (V ''r''))\n                 (Cmpop (<) (Vidx ''heap'' (V ''rc''))\n                   (Vidx ''heap'' (V ''lc'')))\n             THEN ''smallest''[] ::= ''rc'' ELSE SKIP;;\n             (''G_par_1''[] ::= ''heap'';; ''G_par_2''[] ::= ''x'';;\n              ''G_par_3''[] ::= ''smallest'';; Params swp;;\n              ArrayCpy_retv ''heap'' ''G_ret_1'');;\n             ''x''[] ::= ''smallest'';;\n             (''G_par_1''[] ::= ''l'';; ''G_par_2''[] ::= ''x'';;\n              Params left_child;; ArrayCpy_retv ''lc'' ''G_ret_1'');;\n             ''G_par_1''[] ::= ''l'';; ''G_par_2''[] ::= ''x'';;\n             Params right_child;; ArrayCpy_retv ''rc'' ''G_ret_1''))\n     (\\<lambda>\\<ss>\\<^sub>0 \\<ss>.\n         VAR (\\<ss> ''heap'')\n          (\\<lambda>heap.\n              VAR (\\<ss>\\<^sub>0 ''heap'')\n               (\\<lambda>heap\\<^sub>0.\n                   VAR (\\<ss>\\<^sub>0 ''x'' 0)\n                    (\\<lambda>x\\<^sub>0.\n                        VAR (\\<ss>\\<^sub>0 ''r'' 0)\n                         (\\<lambda>r\\<^sub>0.\n                             VAR (\\<ss>\\<^sub>0 ''l'' 0)\n                              (\\<lambda>l\\<^sub>0.\n                                  BB_PROTECT\n                                   (is_partial_heap (\\<le>) heap l\\<^sub>0\n                                     x\\<^sub>0 r\\<^sub>0 \\<and>\n                                    arr_mset heap\\<^sub>0 l\\<^sub>0\n                                     r\\<^sub>0 =\n                                    arr_mset heap l\\<^sub>0 r\\<^sub>0 \\<and>\n                                    heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0})))))))", "apply vcg_cs"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''then''; \\<paragraph>''Invar pres'';\n        is_partial_heap_except_down (\\<le>) heap\\<^sub>0 l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x\\<^sub>0;\n        l\\<^sub>0 \\<le> x\\<^sub>0;\n        is_partial_heap_except_down (\\<le>) heap l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x;\n        l_child l\\<^sub>0 x < r\\<^sub>0;\n        heap (l_child l\\<^sub>0 x) < heap x \\<or>\n        heap (r_child l\\<^sub>0 x) < heap x;\n        r_child l\\<^sub>0 x < r\\<^sub>0;\n        heap (r_child l\\<^sub>0 x) < heap (l_child l\\<^sub>0 x);\n        x\\<^sub>0 \\<le> x; x \\<le> r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_partial_heap_except_down (\\<le>)\n                          (swap heap x (r_child l\\<^sub>0 x)) l\\<^sub>0\n                          x\\<^sub>0 r\\<^sub>0 (r_child l\\<^sub>0 x) \\<and>\n                         x\\<^sub>0 \\<le> r_child l\\<^sub>0 x \\<and>\n                         arr_mset heap l\\<^sub>0 r\\<^sub>0 =\n                         arr_mset (swap heap x (r_child l\\<^sub>0 x))\n                          l\\<^sub>0 r\\<^sub>0 \\<and>\n                         heap\\<^sub>0 = swap heap x\n   (r_child l\\<^sub>0 x) on - {l\\<^sub>0..<r\\<^sub>0}\n 2. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''then''; \\<paragraph>''Var pres'';\n        is_partial_heap_except_down (\\<le>) heap\\<^sub>0 l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x\\<^sub>0;\n        l\\<^sub>0 \\<le> x\\<^sub>0;\n        is_partial_heap_except_down (\\<le>) heap l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x;\n        l_child l\\<^sub>0 x < r\\<^sub>0;\n        heap (l_child l\\<^sub>0 x) < heap x \\<or>\n        heap (r_child l\\<^sub>0 x) < heap x;\n        r_child l\\<^sub>0 x < r\\<^sub>0;\n        heap (r_child l\\<^sub>0 x) < heap (l_child l\\<^sub>0 x);\n        x\\<^sub>0 \\<le> x; x \\<le> r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> x < r\\<^sub>0 \\<and> x < r_child l\\<^sub>0 x\n 3. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Invar pres'';\n        r_child l\\<^sub>0 x < r\\<^sub>0 \\<longrightarrow>\n        \\<not> heap (r_child l\\<^sub>0 x) < heap (l_child l\\<^sub>0 x);\n        is_partial_heap_except_down (\\<le>) heap\\<^sub>0 l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x\\<^sub>0;\n        l\\<^sub>0 \\<le> x\\<^sub>0;\n        is_partial_heap_except_down (\\<le>) heap l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x;\n        l_child l\\<^sub>0 x < r\\<^sub>0;\n        heap (l_child l\\<^sub>0 x) < heap x \\<or>\n        r_child l\\<^sub>0 x < r\\<^sub>0 \\<and>\n        heap (r_child l\\<^sub>0 x) < heap x;\n        x\\<^sub>0 \\<le> x; x \\<le> r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_partial_heap_except_down (\\<le>)\n                          (swap heap x (l_child l\\<^sub>0 x)) l\\<^sub>0\n                          x\\<^sub>0 r\\<^sub>0 (l_child l\\<^sub>0 x) \\<and>\n                         x\\<^sub>0 \\<le> l_child l\\<^sub>0 x \\<and>\n                         arr_mset heap l\\<^sub>0 r\\<^sub>0 =\n                         arr_mset (swap heap x (l_child l\\<^sub>0 x))\n                          l\\<^sub>0 r\\<^sub>0 \\<and>\n                         heap\\<^sub>0 = swap heap x\n   (l_child l\\<^sub>0 x) on - {l\\<^sub>0..<r\\<^sub>0}\n 4. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Var pres'';\n        r_child l\\<^sub>0 x < r\\<^sub>0 \\<longrightarrow>\n        \\<not> heap (r_child l\\<^sub>0 x) < heap (l_child l\\<^sub>0 x);\n        is_partial_heap_except_down (\\<le>) heap\\<^sub>0 l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x\\<^sub>0;\n        l\\<^sub>0 \\<le> x\\<^sub>0;\n        is_partial_heap_except_down (\\<le>) heap l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x;\n        l_child l\\<^sub>0 x < r\\<^sub>0;\n        heap (l_child l\\<^sub>0 x) < heap x \\<or>\n        r_child l\\<^sub>0 x < r\\<^sub>0 \\<and>\n        heap (r_child l\\<^sub>0 x) < heap x;\n        x\\<^sub>0 \\<le> x; x \\<le> r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> x < r\\<^sub>0 \\<and> x < l_child l\\<^sub>0 x\n 5. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''invar-post'';\n        l_child l\\<^sub>0 x < r\\<^sub>0 \\<longrightarrow>\n        \\<not> heap (l_child l\\<^sub>0 x) < heap x \\<and>\n        (r_child l\\<^sub>0 x < r\\<^sub>0 \\<longrightarrow>\n         \\<not> heap (r_child l\\<^sub>0 x) < heap x);\n        is_partial_heap_except_down (\\<le>) heap\\<^sub>0 l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x\\<^sub>0;\n        l\\<^sub>0 \\<le> x\\<^sub>0;\n        is_partial_heap_except_down (\\<le>) heap l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x;\n        x\\<^sub>0 \\<le> x; x \\<le> r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_partial_heap (\\<le>) heap l\\<^sub>0 x\\<^sub>0\n                          r\\<^sub>0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''then''; \\<paragraph>''Invar pres'';\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> is_partial_heap_except_down (\\<le>)\n                       (swap heap_ x_ (r_child l\\<^sub>0_ x_)) l\\<^sub>0_\n                       x\\<^sub>0_ r\\<^sub>0_ (r_child l\\<^sub>0_ x_) \\<and>\n                      x\\<^sub>0_ \\<le> r_child l\\<^sub>0_ x_ \\<and>\n                      arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_ =\n                      arr_mset (swap heap_ x_ (r_child l\\<^sub>0_ x_))\n                       l\\<^sub>0_ r\\<^sub>0_ \\<and>\n                      heap\\<^sub>0_ = swap heap_ x_\n (r_child l\\<^sub>0_ x_) on - {l\\<^sub>0_..<r\\<^sub>0_}", "apply(intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<paragraph>''then''; \\<paragraph>''Invar pres'';\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> is_partial_heap_except_down (\\<le>)\n                       (swap heap_ x_ (r_child l\\<^sub>0_ x_)) l\\<^sub>0_\n                       x\\<^sub>0_ r\\<^sub>0_ (r_child l\\<^sub>0_ x_)\n 2. \\<lbrakk>\\<paragraph>''then''; \\<paragraph>''Invar pres'';\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> x\\<^sub>0_ \\<le> r_child l\\<^sub>0_ x_\n 3. \\<lbrakk>\\<paragraph>''then''; \\<paragraph>''Invar pres'';\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_ =\n                      arr_mset (swap heap_ x_ (r_child l\\<^sub>0_ x_))\n                       l\\<^sub>0_ r\\<^sub>0_\n 4. \\<lbrakk>\\<paragraph>''then''; \\<paragraph>''Invar pres'';\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> heap\\<^sub>0_ = swap heap_ x_\n (r_child l\\<^sub>0_ x_) on - {l\\<^sub>0_..<r\\<^sub>0_}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''then''; \\<paragraph>''Invar pres'';\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> is_partial_heap_except_down (\\<le>)\n                       (swap heap_ x_ (r_child l\\<^sub>0_ x_)) l\\<^sub>0_\n                       x\\<^sub>0_ r\\<^sub>0_ (r_child l\\<^sub>0_ x_)", "unfolding is_partial_heap_except_down_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''then''; \\<paragraph>''Invar pres'';\n     \\<forall>x.\n        bounded x\\<^sub>0_ r\\<^sub>0_ x \\<longrightarrow>\n        (parent l\\<^sub>0_ x \\<noteq> x\\<^sub>0_ \\<longrightarrow>\n         bounded x\\<^sub>0_ r\\<^sub>0_\n          (parent l\\<^sub>0_ x) \\<longrightarrow>\n         heap\\<^sub>0_ (parent l\\<^sub>0_ x) \\<le> heap\\<^sub>0_ x) \\<and>\n        (parent l\\<^sub>0_ x = x\\<^sub>0_ \\<longrightarrow>\n         bounded x\\<^sub>0_ r\\<^sub>0_\n          (parent l\\<^sub>0_ (parent l\\<^sub>0_ x)) \\<longrightarrow>\n         heap\\<^sub>0_ (parent l\\<^sub>0_ (parent l\\<^sub>0_ x))\n         \\<le> heap\\<^sub>0_ x);\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     \\<forall>xa.\n        bounded x\\<^sub>0_ r\\<^sub>0_ xa \\<longrightarrow>\n        (parent l\\<^sub>0_ xa \\<noteq> x_ \\<longrightarrow>\n         bounded x\\<^sub>0_ r\\<^sub>0_\n          (parent l\\<^sub>0_ xa) \\<longrightarrow>\n         heap_ (parent l\\<^sub>0_ xa) \\<le> heap_ xa) \\<and>\n        (parent l\\<^sub>0_ xa = x_ \\<longrightarrow>\n         bounded x\\<^sub>0_ r\\<^sub>0_\n          (parent l\\<^sub>0_ (parent l\\<^sub>0_ xa)) \\<longrightarrow>\n         heap_ (parent l\\<^sub>0_ (parent l\\<^sub>0_ xa)) \\<le> heap_ xa);\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         bounded x\\<^sub>0_ r\\<^sub>0_ xa \\<longrightarrow>\n                         (parent l\\<^sub>0_ xa \\<noteq>\n                          r_child l\\<^sub>0_ x_ \\<longrightarrow>\n                          bounded x\\<^sub>0_ r\\<^sub>0_\n                           (parent l\\<^sub>0_ xa) \\<longrightarrow>\n                          swap heap_ x_ (r_child l\\<^sub>0_ x_)\n                           (parent l\\<^sub>0_ xa)\n                          \\<le> swap heap_ x_ (r_child l\\<^sub>0_ x_)\n                                 xa) \\<and>\n                         (parent l\\<^sub>0_ xa =\n                          r_child l\\<^sub>0_ x_ \\<longrightarrow>\n                          bounded x\\<^sub>0_ r\\<^sub>0_\n                           (parent l\\<^sub>0_\n                             (parent l\\<^sub>0_ xa)) \\<longrightarrow>\n                          swap heap_ x_ (r_child l\\<^sub>0_ x_)\n                           (parent l\\<^sub>0_ (parent l\\<^sub>0_ xa))\n                          \\<le> swap heap_ x_ (r_child l\\<^sub>0_ x_) xa)", "by (smt parent_two_children swap_swaps swap_only_swaps\n          swap_commute parent_upper_bound_alt)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<paragraph>''then''; \\<paragraph>''Invar pres'';\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> x\\<^sub>0_ \\<le> r_child l\\<^sub>0_ x_\n 2. \\<lbrakk>\\<paragraph>''then''; \\<paragraph>''Invar pres'';\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_ =\n                      arr_mset (swap heap_ x_ (r_child l\\<^sub>0_ x_))\n                       l\\<^sub>0_ r\\<^sub>0_\n 3. \\<lbrakk>\\<paragraph>''then''; \\<paragraph>''Invar pres'';\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> heap\\<^sub>0_ = swap heap_ x_\n (r_child l\\<^sub>0_ x_) on - {l\\<^sub>0_..<r\\<^sub>0_}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''then''; \\<paragraph>''Invar pres'';\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> x\\<^sub>0_ \\<le> r_child l\\<^sub>0_ x_", "using r_child_lower_bound_alt"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l \\<le> ?x; ?x \\<le> ?p\\<rbrakk>\n  \\<Longrightarrow> ?x < r_child ?l ?p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''then''; \\<paragraph>''Invar pres'';\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> x\\<^sub>0_ \\<le> r_child l\\<^sub>0_ x_", "by fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<paragraph>''then''; \\<paragraph>''Invar pres'';\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_ =\n                      arr_mset (swap heap_ x_ (r_child l\\<^sub>0_ x_))\n                       l\\<^sub>0_ r\\<^sub>0_\n 2. \\<lbrakk>\\<paragraph>''then''; \\<paragraph>''Invar pres'';\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> heap\\<^sub>0_ = swap heap_ x_\n (r_child l\\<^sub>0_ x_) on - {l\\<^sub>0_..<r\\<^sub>0_}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''then''; \\<paragraph>''Invar pres'';\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_ =\n                      arr_mset (swap heap_ x_ (r_child l\\<^sub>0_ x_))\n                       l\\<^sub>0_ r\\<^sub>0_", "using swap_child_mset order_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>arr_mset ?arr1.0 ?l ?r = arr_mset ?arr2.0 ?l ?r;\n   ?c = l_child ?l ?p \\<or> ?c = r_child ?l ?p; ?l \\<le> ?p;\n   ?c < ?r\\<rbrakk>\n  \\<Longrightarrow> arr_mset ?arr1.0 ?l ?r =\n                    arr_mset (swap ?arr2.0 ?p ?c) ?l ?r\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''then''; \\<paragraph>''Invar pres'';\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_ =\n                      arr_mset (swap heap_ x_ (r_child l\\<^sub>0_ x_))\n                       l\\<^sub>0_ r\\<^sub>0_", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''then''; \\<paragraph>''Invar pres'';\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> heap\\<^sub>0_ = swap heap_ x_\n (r_child l\\<^sub>0_ x_) on - {l\\<^sub>0_..<r\\<^sub>0_}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''then''; \\<paragraph>''Invar pres'';\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> heap\\<^sub>0_ = swap heap_ x_\n (r_child l\\<^sub>0_ x_) on - {l\\<^sub>0_..<r\\<^sub>0_}", "using swap_child_eq_on"], ["proof (prove)\nusing this:\n  \\<lbrakk>?arr1.0 = ?arr2.0 on - {?l..<?r};\n   ?c = l_child ?l ?p \\<or> ?c = r_child ?l ?p; ?l \\<le> ?p;\n   ?c < ?r\\<rbrakk>\n  \\<Longrightarrow> ?arr1.0 = swap ?arr2.0 ?p ?c on - {?l..<?r}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''then''; \\<paragraph>''Invar pres'';\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> heap\\<^sub>0_ = swap heap_ x_\n (r_child l\\<^sub>0_ x_) on - {l\\<^sub>0_..<r\\<^sub>0_}", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''then''; \\<paragraph>''Var pres'';\n        is_partial_heap_except_down (\\<le>) heap\\<^sub>0 l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x\\<^sub>0;\n        l\\<^sub>0 \\<le> x\\<^sub>0;\n        is_partial_heap_except_down (\\<le>) heap l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x;\n        l_child l\\<^sub>0 x < r\\<^sub>0;\n        heap (l_child l\\<^sub>0 x) < heap x \\<or>\n        heap (r_child l\\<^sub>0 x) < heap x;\n        r_child l\\<^sub>0 x < r\\<^sub>0;\n        heap (r_child l\\<^sub>0 x) < heap (l_child l\\<^sub>0 x);\n        x\\<^sub>0 \\<le> x; x \\<le> r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> x < r\\<^sub>0 \\<and> x < r_child l\\<^sub>0 x\n 2. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Invar pres'';\n        r_child l\\<^sub>0 x < r\\<^sub>0 \\<longrightarrow>\n        \\<not> heap (r_child l\\<^sub>0 x) < heap (l_child l\\<^sub>0 x);\n        is_partial_heap_except_down (\\<le>) heap\\<^sub>0 l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x\\<^sub>0;\n        l\\<^sub>0 \\<le> x\\<^sub>0;\n        is_partial_heap_except_down (\\<le>) heap l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x;\n        l_child l\\<^sub>0 x < r\\<^sub>0;\n        heap (l_child l\\<^sub>0 x) < heap x \\<or>\n        r_child l\\<^sub>0 x < r\\<^sub>0 \\<and>\n        heap (r_child l\\<^sub>0 x) < heap x;\n        x\\<^sub>0 \\<le> x; x \\<le> r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_partial_heap_except_down (\\<le>)\n                          (swap heap x (l_child l\\<^sub>0 x)) l\\<^sub>0\n                          x\\<^sub>0 r\\<^sub>0 (l_child l\\<^sub>0 x) \\<and>\n                         x\\<^sub>0 \\<le> l_child l\\<^sub>0 x \\<and>\n                         arr_mset heap l\\<^sub>0 r\\<^sub>0 =\n                         arr_mset (swap heap x (l_child l\\<^sub>0 x))\n                          l\\<^sub>0 r\\<^sub>0 \\<and>\n                         heap\\<^sub>0 = swap heap x\n   (l_child l\\<^sub>0 x) on - {l\\<^sub>0..<r\\<^sub>0}\n 3. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Var pres'';\n        r_child l\\<^sub>0 x < r\\<^sub>0 \\<longrightarrow>\n        \\<not> heap (r_child l\\<^sub>0 x) < heap (l_child l\\<^sub>0 x);\n        is_partial_heap_except_down (\\<le>) heap\\<^sub>0 l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x\\<^sub>0;\n        l\\<^sub>0 \\<le> x\\<^sub>0;\n        is_partial_heap_except_down (\\<le>) heap l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x;\n        l_child l\\<^sub>0 x < r\\<^sub>0;\n        heap (l_child l\\<^sub>0 x) < heap x \\<or>\n        r_child l\\<^sub>0 x < r\\<^sub>0 \\<and>\n        heap (r_child l\\<^sub>0 x) < heap x;\n        x\\<^sub>0 \\<le> x; x \\<le> r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> x < r\\<^sub>0 \\<and> x < l_child l\\<^sub>0 x\n 4. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''invar-post'';\n        l_child l\\<^sub>0 x < r\\<^sub>0 \\<longrightarrow>\n        \\<not> heap (l_child l\\<^sub>0 x) < heap x \\<and>\n        (r_child l\\<^sub>0 x < r\\<^sub>0 \\<longrightarrow>\n         \\<not> heap (r_child l\\<^sub>0 x) < heap x);\n        is_partial_heap_except_down (\\<le>) heap\\<^sub>0 l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x\\<^sub>0;\n        l\\<^sub>0 \\<le> x\\<^sub>0;\n        is_partial_heap_except_down (\\<le>) heap l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x;\n        x\\<^sub>0 \\<le> x; x \\<le> r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_partial_heap (\\<le>) heap l\\<^sub>0 x\\<^sub>0\n                          r\\<^sub>0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''then''; \\<paragraph>''Var pres'';\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> x_ < r\\<^sub>0_ \\<and> x_ < r_child l\\<^sub>0_ x_", "by (meson less_le_trans not_le order.asym r_child_lower_bound)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Invar pres'';\n        r_child l\\<^sub>0 x < r\\<^sub>0 \\<longrightarrow>\n        \\<not> heap (r_child l\\<^sub>0 x) < heap (l_child l\\<^sub>0 x);\n        is_partial_heap_except_down (\\<le>) heap\\<^sub>0 l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x\\<^sub>0;\n        l\\<^sub>0 \\<le> x\\<^sub>0;\n        is_partial_heap_except_down (\\<le>) heap l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x;\n        l_child l\\<^sub>0 x < r\\<^sub>0;\n        heap (l_child l\\<^sub>0 x) < heap x \\<or>\n        r_child l\\<^sub>0 x < r\\<^sub>0 \\<and>\n        heap (r_child l\\<^sub>0 x) < heap x;\n        x\\<^sub>0 \\<le> x; x \\<le> r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_partial_heap_except_down (\\<le>)\n                          (swap heap x (l_child l\\<^sub>0 x)) l\\<^sub>0\n                          x\\<^sub>0 r\\<^sub>0 (l_child l\\<^sub>0 x) \\<and>\n                         x\\<^sub>0 \\<le> l_child l\\<^sub>0 x \\<and>\n                         arr_mset heap l\\<^sub>0 r\\<^sub>0 =\n                         arr_mset (swap heap x (l_child l\\<^sub>0 x))\n                          l\\<^sub>0 r\\<^sub>0 \\<and>\n                         heap\\<^sub>0 = swap heap x\n   (l_child l\\<^sub>0 x) on - {l\\<^sub>0..<r\\<^sub>0}\n 2. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Var pres'';\n        r_child l\\<^sub>0 x < r\\<^sub>0 \\<longrightarrow>\n        \\<not> heap (r_child l\\<^sub>0 x) < heap (l_child l\\<^sub>0 x);\n        is_partial_heap_except_down (\\<le>) heap\\<^sub>0 l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x\\<^sub>0;\n        l\\<^sub>0 \\<le> x\\<^sub>0;\n        is_partial_heap_except_down (\\<le>) heap l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x;\n        l_child l\\<^sub>0 x < r\\<^sub>0;\n        heap (l_child l\\<^sub>0 x) < heap x \\<or>\n        r_child l\\<^sub>0 x < r\\<^sub>0 \\<and>\n        heap (r_child l\\<^sub>0 x) < heap x;\n        x\\<^sub>0 \\<le> x; x \\<le> r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> x < r\\<^sub>0 \\<and> x < l_child l\\<^sub>0 x\n 3. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''invar-post'';\n        l_child l\\<^sub>0 x < r\\<^sub>0 \\<longrightarrow>\n        \\<not> heap (l_child l\\<^sub>0 x) < heap x \\<and>\n        (r_child l\\<^sub>0 x < r\\<^sub>0 \\<longrightarrow>\n         \\<not> heap (r_child l\\<^sub>0 x) < heap x);\n        is_partial_heap_except_down (\\<le>) heap\\<^sub>0 l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x\\<^sub>0;\n        l\\<^sub>0 \\<le> x\\<^sub>0;\n        is_partial_heap_except_down (\\<le>) heap l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x;\n        x\\<^sub>0 \\<le> x; x \\<le> r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_partial_heap (\\<le>) heap l\\<^sub>0 x\\<^sub>0\n                          r\\<^sub>0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Invar pres'';\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<longrightarrow>\n     \\<not> heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<and>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> is_partial_heap_except_down (\\<le>)\n                       (swap heap_ x_ (l_child l\\<^sub>0_ x_)) l\\<^sub>0_\n                       x\\<^sub>0_ r\\<^sub>0_ (l_child l\\<^sub>0_ x_) \\<and>\n                      x\\<^sub>0_ \\<le> l_child l\\<^sub>0_ x_ \\<and>\n                      arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_ =\n                      arr_mset (swap heap_ x_ (l_child l\\<^sub>0_ x_))\n                       l\\<^sub>0_ r\\<^sub>0_ \\<and>\n                      heap\\<^sub>0_ = swap heap_ x_\n (l_child l\\<^sub>0_ x_) on - {l\\<^sub>0_..<r\\<^sub>0_}", "apply(intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Invar pres'';\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<longrightarrow>\n     \\<not> heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<and>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> is_partial_heap_except_down (\\<le>)\n                       (swap heap_ x_ (l_child l\\<^sub>0_ x_)) l\\<^sub>0_\n                       x\\<^sub>0_ r\\<^sub>0_ (l_child l\\<^sub>0_ x_)\n 2. \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Invar pres'';\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<longrightarrow>\n     \\<not> heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<and>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> x\\<^sub>0_ \\<le> l_child l\\<^sub>0_ x_\n 3. \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Invar pres'';\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<longrightarrow>\n     \\<not> heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<and>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_ =\n                      arr_mset (swap heap_ x_ (l_child l\\<^sub>0_ x_))\n                       l\\<^sub>0_ r\\<^sub>0_\n 4. \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Invar pres'';\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<longrightarrow>\n     \\<not> heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<and>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> heap\\<^sub>0_ = swap heap_ x_\n (l_child l\\<^sub>0_ x_) on - {l\\<^sub>0_..<r\\<^sub>0_}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Invar pres'';\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<longrightarrow>\n     \\<not> heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<and>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> is_partial_heap_except_down (\\<le>)\n                       (swap heap_ x_ (l_child l\\<^sub>0_ x_)) l\\<^sub>0_\n                       x\\<^sub>0_ r\\<^sub>0_ (l_child l\\<^sub>0_ x_)", "unfolding is_partial_heap_except_down_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Invar pres'';\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<longrightarrow>\n     \\<not> heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     \\<forall>x.\n        bounded x\\<^sub>0_ r\\<^sub>0_ x \\<longrightarrow>\n        (parent l\\<^sub>0_ x \\<noteq> x\\<^sub>0_ \\<longrightarrow>\n         bounded x\\<^sub>0_ r\\<^sub>0_\n          (parent l\\<^sub>0_ x) \\<longrightarrow>\n         heap\\<^sub>0_ (parent l\\<^sub>0_ x) \\<le> heap\\<^sub>0_ x) \\<and>\n        (parent l\\<^sub>0_ x = x\\<^sub>0_ \\<longrightarrow>\n         bounded x\\<^sub>0_ r\\<^sub>0_\n          (parent l\\<^sub>0_ (parent l\\<^sub>0_ x)) \\<longrightarrow>\n         heap\\<^sub>0_ (parent l\\<^sub>0_ (parent l\\<^sub>0_ x))\n         \\<le> heap\\<^sub>0_ x);\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     \\<forall>xa.\n        bounded x\\<^sub>0_ r\\<^sub>0_ xa \\<longrightarrow>\n        (parent l\\<^sub>0_ xa \\<noteq> x_ \\<longrightarrow>\n         bounded x\\<^sub>0_ r\\<^sub>0_\n          (parent l\\<^sub>0_ xa) \\<longrightarrow>\n         heap_ (parent l\\<^sub>0_ xa) \\<le> heap_ xa) \\<and>\n        (parent l\\<^sub>0_ xa = x_ \\<longrightarrow>\n         bounded x\\<^sub>0_ r\\<^sub>0_\n          (parent l\\<^sub>0_ (parent l\\<^sub>0_ xa)) \\<longrightarrow>\n         heap_ (parent l\\<^sub>0_ (parent l\\<^sub>0_ xa)) \\<le> heap_ xa);\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<and>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>xa.\n                         bounded x\\<^sub>0_ r\\<^sub>0_ xa \\<longrightarrow>\n                         (parent l\\<^sub>0_ xa \\<noteq>\n                          l_child l\\<^sub>0_ x_ \\<longrightarrow>\n                          bounded x\\<^sub>0_ r\\<^sub>0_\n                           (parent l\\<^sub>0_ xa) \\<longrightarrow>\n                          swap heap_ x_ (l_child l\\<^sub>0_ x_)\n                           (parent l\\<^sub>0_ xa)\n                          \\<le> swap heap_ x_ (l_child l\\<^sub>0_ x_)\n                                 xa) \\<and>\n                         (parent l\\<^sub>0_ xa =\n                          l_child l\\<^sub>0_ x_ \\<longrightarrow>\n                          bounded x\\<^sub>0_ r\\<^sub>0_\n                           (parent l\\<^sub>0_\n                             (parent l\\<^sub>0_ xa)) \\<longrightarrow>\n                          swap heap_ x_ (l_child l\\<^sub>0_ x_)\n                           (parent l\\<^sub>0_ (parent l\\<^sub>0_ xa))\n                          \\<le> swap heap_ x_ (l_child l\\<^sub>0_ x_) xa)", "by (smt parent_two_children swap_swaps swap_only_swaps\n          swap_commute parent_upper_bound_alt)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Invar pres'';\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<longrightarrow>\n     \\<not> heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<and>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> x\\<^sub>0_ \\<le> l_child l\\<^sub>0_ x_\n 2. \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Invar pres'';\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<longrightarrow>\n     \\<not> heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<and>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_ =\n                      arr_mset (swap heap_ x_ (l_child l\\<^sub>0_ x_))\n                       l\\<^sub>0_ r\\<^sub>0_\n 3. \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Invar pres'';\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<longrightarrow>\n     \\<not> heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<and>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> heap\\<^sub>0_ = swap heap_ x_\n (l_child l\\<^sub>0_ x_) on - {l\\<^sub>0_..<r\\<^sub>0_}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Invar pres'';\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<longrightarrow>\n     \\<not> heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<and>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> x\\<^sub>0_ \\<le> l_child l\\<^sub>0_ x_", "using l_child_lower_bound_alt"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l \\<le> ?x; ?x \\<le> ?p\\<rbrakk>\n  \\<Longrightarrow> ?x < l_child ?l ?p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Invar pres'';\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<longrightarrow>\n     \\<not> heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<and>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> x\\<^sub>0_ \\<le> l_child l\\<^sub>0_ x_", "by fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Invar pres'';\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<longrightarrow>\n     \\<not> heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<and>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_ =\n                      arr_mset (swap heap_ x_ (l_child l\\<^sub>0_ x_))\n                       l\\<^sub>0_ r\\<^sub>0_\n 2. \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Invar pres'';\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<longrightarrow>\n     \\<not> heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<and>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> heap\\<^sub>0_ = swap heap_ x_\n (l_child l\\<^sub>0_ x_) on - {l\\<^sub>0_..<r\\<^sub>0_}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Invar pres'';\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<longrightarrow>\n     \\<not> heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<and>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_ =\n                      arr_mset (swap heap_ x_ (l_child l\\<^sub>0_ x_))\n                       l\\<^sub>0_ r\\<^sub>0_", "using swap_child_mset order_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>arr_mset ?arr1.0 ?l ?r = arr_mset ?arr2.0 ?l ?r;\n   ?c = l_child ?l ?p \\<or> ?c = r_child ?l ?p; ?l \\<le> ?p;\n   ?c < ?r\\<rbrakk>\n  \\<Longrightarrow> arr_mset ?arr1.0 ?l ?r =\n                    arr_mset (swap ?arr2.0 ?p ?c) ?l ?r\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Invar pres'';\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<longrightarrow>\n     \\<not> heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<and>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_ =\n                      arr_mset (swap heap_ x_ (l_child l\\<^sub>0_ x_))\n                       l\\<^sub>0_ r\\<^sub>0_", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Invar pres'';\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<longrightarrow>\n     \\<not> heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<and>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> heap\\<^sub>0_ = swap heap_ x_\n (l_child l\\<^sub>0_ x_) on - {l\\<^sub>0_..<r\\<^sub>0_}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Invar pres'';\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<longrightarrow>\n     \\<not> heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<and>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> heap\\<^sub>0_ = swap heap_ x_\n (l_child l\\<^sub>0_ x_) on - {l\\<^sub>0_..<r\\<^sub>0_}", "using swap_child_eq_on"], ["proof (prove)\nusing this:\n  \\<lbrakk>?arr1.0 = ?arr2.0 on - {?l..<?r};\n   ?c = l_child ?l ?p \\<or> ?c = r_child ?l ?p; ?l \\<le> ?p;\n   ?c < ?r\\<rbrakk>\n  \\<Longrightarrow> ?arr1.0 = swap ?arr2.0 ?p ?c on - {?l..<?r}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Invar pres'';\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<longrightarrow>\n     \\<not> heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<and>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> heap\\<^sub>0_ = swap heap_ x_\n (l_child l\\<^sub>0_ x_) on - {l\\<^sub>0_..<r\\<^sub>0_}", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Var pres'';\n        r_child l\\<^sub>0 x < r\\<^sub>0 \\<longrightarrow>\n        \\<not> heap (r_child l\\<^sub>0 x) < heap (l_child l\\<^sub>0 x);\n        is_partial_heap_except_down (\\<le>) heap\\<^sub>0 l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x\\<^sub>0;\n        l\\<^sub>0 \\<le> x\\<^sub>0;\n        is_partial_heap_except_down (\\<le>) heap l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x;\n        l_child l\\<^sub>0 x < r\\<^sub>0;\n        heap (l_child l\\<^sub>0 x) < heap x \\<or>\n        r_child l\\<^sub>0 x < r\\<^sub>0 \\<and>\n        heap (r_child l\\<^sub>0 x) < heap x;\n        x\\<^sub>0 \\<le> x; x \\<le> r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> x < r\\<^sub>0 \\<and> x < l_child l\\<^sub>0 x\n 2. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''invar-post'';\n        l_child l\\<^sub>0 x < r\\<^sub>0 \\<longrightarrow>\n        \\<not> heap (l_child l\\<^sub>0 x) < heap x \\<and>\n        (r_child l\\<^sub>0 x < r\\<^sub>0 \\<longrightarrow>\n         \\<not> heap (r_child l\\<^sub>0 x) < heap x);\n        is_partial_heap_except_down (\\<le>) heap\\<^sub>0 l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x\\<^sub>0;\n        l\\<^sub>0 \\<le> x\\<^sub>0;\n        is_partial_heap_except_down (\\<le>) heap l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x;\n        x\\<^sub>0 \\<le> x; x \\<le> r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_partial_heap (\\<le>) heap l\\<^sub>0 x\\<^sub>0\n                          r\\<^sub>0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''else''; \\<paragraph>''Var pres'';\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<longrightarrow>\n     \\<not> heap_ (r_child l\\<^sub>0_ x_) < heap_ (l_child l\\<^sub>0_ x_);\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_;\n     heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<or>\n     r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<and>\n     heap_ (r_child l\\<^sub>0_ x_) < heap_ x_;\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> x_ < r\\<^sub>0_ \\<and> x_ < l_child l\\<^sub>0_ x_", "by (meson less_le_trans not_le order.asym l_child_lower_bound)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r\\<^sub>0 l\\<^sub>0 x\\<^sub>0 heap\\<^sub>0 x heap.\n       \\<lbrakk>\\<paragraph>''invar-post'';\n        l_child l\\<^sub>0 x < r\\<^sub>0 \\<longrightarrow>\n        \\<not> heap (l_child l\\<^sub>0 x) < heap x \\<and>\n        (r_child l\\<^sub>0 x < r\\<^sub>0 \\<longrightarrow>\n         \\<not> heap (r_child l\\<^sub>0 x) < heap x);\n        is_partial_heap_except_down (\\<le>) heap\\<^sub>0 l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x\\<^sub>0;\n        l\\<^sub>0 \\<le> x\\<^sub>0;\n        is_partial_heap_except_down (\\<le>) heap l\\<^sub>0 x\\<^sub>0\n         r\\<^sub>0 x;\n        x\\<^sub>0 \\<le> x; x \\<le> r\\<^sub>0;\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap l\\<^sub>0 r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_partial_heap (\\<le>) heap l\\<^sub>0 x\\<^sub>0\n                          r\\<^sub>0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''invar-post'';\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<longrightarrow>\n     \\<not> heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<and>\n     (r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<longrightarrow>\n      \\<not> heap_ (r_child l\\<^sub>0_ x_) < heap_ x_);\n     is_partial_heap_except_down (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x\\<^sub>0_;\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n      r\\<^sub>0_ x_;\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> is_partial_heap (\\<le>) heap_ l\\<^sub>0_ x\\<^sub>0_\n                       r\\<^sub>0_", "unfolding is_partial_heap_except_down_def is_partial_heap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''invar-post'';\n     l_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<longrightarrow>\n     \\<not> heap_ (l_child l\\<^sub>0_ x_) < heap_ x_ \\<and>\n     (r_child l\\<^sub>0_ x_ < r\\<^sub>0_ \\<longrightarrow>\n      \\<not> heap_ (r_child l\\<^sub>0_ x_) < heap_ x_);\n     \\<forall>x.\n        bounded x\\<^sub>0_ r\\<^sub>0_ x \\<longrightarrow>\n        (parent l\\<^sub>0_ x \\<noteq> x\\<^sub>0_ \\<longrightarrow>\n         bounded x\\<^sub>0_ r\\<^sub>0_\n          (parent l\\<^sub>0_ x) \\<longrightarrow>\n         heap\\<^sub>0_ (parent l\\<^sub>0_ x) \\<le> heap\\<^sub>0_ x) \\<and>\n        (parent l\\<^sub>0_ x = x\\<^sub>0_ \\<longrightarrow>\n         bounded x\\<^sub>0_ r\\<^sub>0_\n          (parent l\\<^sub>0_ (parent l\\<^sub>0_ x)) \\<longrightarrow>\n         heap\\<^sub>0_ (parent l\\<^sub>0_ (parent l\\<^sub>0_ x))\n         \\<le> heap\\<^sub>0_ x);\n     l\\<^sub>0_ \\<le> x\\<^sub>0_;\n     \\<forall>xa.\n        bounded x\\<^sub>0_ r\\<^sub>0_ xa \\<longrightarrow>\n        (parent l\\<^sub>0_ xa \\<noteq> x_ \\<longrightarrow>\n         bounded x\\<^sub>0_ r\\<^sub>0_\n          (parent l\\<^sub>0_ xa) \\<longrightarrow>\n         heap_ (parent l\\<^sub>0_ xa) \\<le> heap_ xa) \\<and>\n        (parent l\\<^sub>0_ xa = x_ \\<longrightarrow>\n         bounded x\\<^sub>0_ r\\<^sub>0_\n          (parent l\\<^sub>0_ (parent l\\<^sub>0_ xa)) \\<longrightarrow>\n         heap_ (parent l\\<^sub>0_ (parent l\\<^sub>0_ xa)) \\<le> heap_ xa);\n     x\\<^sub>0_ \\<le> x_; x_ \\<le> r\\<^sub>0_;\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         bounded x\\<^sub>0_ r\\<^sub>0_ x \\<longrightarrow>\n                         bounded x\\<^sub>0_ r\\<^sub>0_\n                          (parent l\\<^sub>0_ x) \\<longrightarrow>\n                         heap_ (parent l\\<^sub>0_ x) \\<le> heap_ x", "by (metis dual_order.strict_trans not_less parent_two_children smaller_l_child)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\\<open>del_min\\<close> needs an additional lemma which shows, that it actually removes (only) the minimum\n      from the heap.\\<close>"], ["", "lemma del_min_mset: \n  fixes heap::\"int \\<Rightarrow> int\"\n  assumes \n    \"l < r\"\n    \"is_heap (\\<le>) heap l r\"\n    \"mod_heap = heap(l := heap (r - 1))\"\n    \"arr_mset mod_heap l (r - 1) = arr_mset new_heap l (r - 1)\"\n  shows \n    \"arr_mset new_heap l (r - 1) = arr_mset heap l r - {#Min_mset (arr_mset heap l r)#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr_mset new_heap l (r - 1) =\n    arr_mset heap l r - {#Min_mset (arr_mset heap l r)#}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. arr_mset new_heap l (r - 1) =\n    arr_mset heap l r - {#Min_mset (arr_mset heap l r)#}", "let ?heap_mset = \"arr_mset heap l r\""], ["proof (state)\ngoal (1 subgoal):\n 1. arr_mset new_heap l (r - 1) =\n    arr_mset heap l r - {#Min_mset (arr_mset heap l r)#}", "have l_is_min: \"heap l = Min_mset ?heap_mset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. heap l = Min_mset (arr_mset heap l r)", "using assms(1,2) heap_minimum"], ["proof (prove)\nusing this:\n  l < r\n  is_heap (\\<le>) heap l r\n  \\<lbrakk>?l < ?r; is_heap (\\<le>) ?heap ?l ?r\\<rbrakk>\n  \\<Longrightarrow> ?heap ?l = Min_mset (arr_mset ?heap ?l ?r)\n\ngoal (1 subgoal):\n 1. heap l = Min_mset (arr_mset heap l r)", "by blast"], ["proof (state)\nthis:\n  heap l = Min_mset (arr_mset heap l r)\n\ngoal (1 subgoal):\n 1. arr_mset new_heap l (r - 1) =\n    arr_mset heap l r - {#Min_mset (arr_mset heap l r)#}", "have \"(arr_mset mod_heap l r) = ?heap_mset + {#heap (r-1)#} - {#heap l#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr_mset mod_heap l r =\n    arr_mset heap l r + {#heap (r - 1)#} - {#heap l#}", "by (simp add: assms(1,3) mset_ran_subst_inside)"], ["proof (state)\nthis:\n  arr_mset mod_heap l r = arr_mset heap l r + {#heap (r - 1)#} - {#heap l#}\n\ngoal (1 subgoal):\n 1. arr_mset new_heap l (r - 1) =\n    arr_mset heap l r - {#Min_mset (arr_mset heap l r)#}", "hence \"(arr_mset mod_heap l (r - 1)) = ?heap_mset - {#heap l#}\""], ["proof (prove)\nusing this:\n  arr_mset mod_heap l r = arr_mset heap l r + {#heap (r - 1)#} - {#heap l#}\n\ngoal (1 subgoal):\n 1. arr_mset mod_heap l (r - 1) = arr_mset heap l r - {#heap l#}", "by (simp add: assms(1,3) arr_mset_remove_last)"], ["proof (state)\nthis:\n  arr_mset mod_heap l (r - 1) = arr_mset heap l r - {#heap l#}\n\ngoal (1 subgoal):\n 1. arr_mset new_heap l (r - 1) =\n    arr_mset heap l r - {#Min_mset (arr_mset heap l r)#}", "thus ?thesis"], ["proof (prove)\nusing this:\n  arr_mset mod_heap l (r - 1) = arr_mset heap l r - {#heap l#}\n\ngoal (1 subgoal):\n 1. arr_mset new_heap l (r - 1) =\n    arr_mset heap l r - {#Min_mset (arr_mset heap l r)#}", "using assms(4) l_is_min"], ["proof (prove)\nusing this:\n  arr_mset mod_heap l (r - 1) = arr_mset heap l r - {#heap l#}\n  arr_mset mod_heap l (r - 1) = arr_mset new_heap l (r - 1)\n  heap l = Min_mset (arr_mset heap l r)\n\ngoal (1 subgoal):\n 1. arr_mset new_heap l (r - 1) =\n    arr_mset heap l r - {#Min_mset (arr_mset heap l r)#}", "by simp"], ["proof (state)\nthis:\n  arr_mset new_heap l (r - 1) =\n  arr_mset heap l r - {#Min_mset (arr_mset heap l r)#}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\\<open>del_min\\<close> removes the minimum element from the heap by replacing the first element with the \n      last element, shrinking the array by one and subsequently restoring the heap invariant \n      with @{const \"sift_down\"}.\\<close>"], ["", "procedure_spec del_min (heap, l, r) returns (heap, l, r)\n  assumes \"l < r \\<and> is_heap (\\<le>) heap l r\"  \n    ensures \"is_heap (\\<le>) heap l r \\<and> \n             arr_mset heap l r = arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 - {#Min_mset (arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0)#} \\<and> \n             l = l\\<^sub>0 \\<and> r = r\\<^sub>0 - 1 \\<and> \n             heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\"\n  for heap l r\n  defines \\<open>\n    r = r - 1;\n    heap[l] = heap[r];\n    heap = sift_down(heap, l, r, l)\n  \\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT' Map.empty\n     (\\<lambda>\\<ss>.\n         VAR (\\<ss> ''heap'')\n          (\\<lambda>heap.\n              VAR (\\<ss> ''r'' 0)\n               (\\<lambda>r.\n                   VAR (\\<ss> ''l'' 0)\n                    (\\<lambda>l.\n                        BB_PROTECT\n                         (l < r \\<and> is_heap (\\<le>) heap l r)))))\n     (\\<lambda>\\<ss>\\<^sub>0. ''r'' ::= Binop (-) (V ''r'') (N 1);;\n         ''heap''[V ''l''] ::= Vidx ''heap'' (V ''r'');;\n         ''G_par_1''[] ::= ''heap'';; ''G_par_2''[] ::= ''l'';;\n         ''G_par_3''[] ::= ''r'';; ''G_par_4''[] ::= ''l'';;\n         Params sift_down;; ArrayCpy_retv ''heap'' ''G_ret_1'')\n     (\\<lambda>\\<ss>\\<^sub>0 \\<ss>.\n         VAR (\\<ss> ''heap'')\n          (\\<lambda>heap.\n              VAR (\\<ss> ''r'' 0)\n               (\\<lambda>r.\n                   VAR (\\<ss> ''l'' 0)\n                    (\\<lambda>l.\n                        VAR (\\<ss>\\<^sub>0 ''heap'')\n                         (\\<lambda>heap\\<^sub>0.\n                             VAR (\\<ss>\\<^sub>0 ''r'' 0)\n                              (\\<lambda>r\\<^sub>0.\n                                  VAR (\\<ss>\\<^sub>0 ''l'' 0)\n                                   (\\<lambda>l\\<^sub>0.\n BB_PROTECT\n  (is_heap (\\<le>) heap l r \\<and>\n   arr_mset heap l r =\n   arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 -\n   {#Min_mset (arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0)#} \\<and>\n   l = l\\<^sub>0 \\<and>\n   r = r\\<^sub>0 - 1 \\<and>\n   heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}))))))))", "apply vcg_cs"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r\\<^sub>0 l\\<^sub>0 heap\\<^sub>0.\n       \\<lbrakk>l\\<^sub>0 < r\\<^sub>0;\n        is_heap (\\<le>) heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> is_heap_except_down (\\<le>)\n                          (heap\\<^sub>0\n                           (l\\<^sub>0 := heap\\<^sub>0 (r\\<^sub>0 - 1)))\n                          l\\<^sub>0 (r\\<^sub>0 - 1) l\\<^sub>0\n 2. \\<And>r\\<^sub>0 l\\<^sub>0 heap\\<^sub>0 heap'.\n       \\<lbrakk>l\\<^sub>0 < r\\<^sub>0 0;\n        is_heap (\\<le>) heap\\<^sub>0 l\\<^sub>0 (r\\<^sub>0 0);\n        is_heap (\\<le>) heap' l\\<^sub>0 (r\\<^sub>0 0 - 1);\n        arr_mset (heap\\<^sub>0(l\\<^sub>0 := heap\\<^sub>0 (r\\<^sub>0 0 - 1)))\n         l\\<^sub>0 (r\\<^sub>0 0 - 1) =\n        arr_mset heap' l\\<^sub>0 (r\\<^sub>0 0 - 1);\n        heap\\<^sub>0\n        (l\\<^sub>0 :=\n           heap\\<^sub>0\n            (r\\<^sub>0 0 -\n             1)) = heap' on - {l\\<^sub>0..<r\\<^sub>0 0 - 1}\\<rbrakk>\n       \\<Longrightarrow> arr_mset heap' l\\<^sub>0 (r\\<^sub>0 0 - 1) =\n                         arr_mset heap\\<^sub>0 l\\<^sub>0 (r\\<^sub>0 0) -\n                         {#Min_mset\n                            (arr_mset heap\\<^sub>0 l\\<^sub>0\n                              (r\\<^sub>0 0))#} \\<and>\n                         heap\\<^sub>0 = heap' on - {l\\<^sub>0..<r\\<^sub>0 0}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l\\<^sub>0_ < r\\<^sub>0_;\n     is_heap (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_\\<rbrakk>\n    \\<Longrightarrow> is_heap_except_down (\\<le>)\n                       (heap\\<^sub>0_\n                        (l\\<^sub>0_ := heap\\<^sub>0_ (r\\<^sub>0_ - 1)))\n                       l\\<^sub>0_ (r\\<^sub>0_ - 1) l\\<^sub>0_", "by (simp add: heap_changed_first_el is_partial_heap_smaller_back)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r\\<^sub>0 l\\<^sub>0 heap\\<^sub>0 heap'.\n       \\<lbrakk>l\\<^sub>0 < r\\<^sub>0 0;\n        is_heap (\\<le>) heap\\<^sub>0 l\\<^sub>0 (r\\<^sub>0 0);\n        is_heap (\\<le>) heap' l\\<^sub>0 (r\\<^sub>0 0 - 1);\n        arr_mset (heap\\<^sub>0(l\\<^sub>0 := heap\\<^sub>0 (r\\<^sub>0 0 - 1)))\n         l\\<^sub>0 (r\\<^sub>0 0 - 1) =\n        arr_mset heap' l\\<^sub>0 (r\\<^sub>0 0 - 1);\n        heap\\<^sub>0\n        (l\\<^sub>0 :=\n           heap\\<^sub>0\n            (r\\<^sub>0 0 -\n             1)) = heap' on - {l\\<^sub>0..<r\\<^sub>0 0 - 1}\\<rbrakk>\n       \\<Longrightarrow> arr_mset heap' l\\<^sub>0 (r\\<^sub>0 0 - 1) =\n                         arr_mset heap\\<^sub>0 l\\<^sub>0 (r\\<^sub>0 0) -\n                         {#Min_mset\n                            (arr_mset heap\\<^sub>0 l\\<^sub>0\n                              (r\\<^sub>0 0))#} \\<and>\n                         heap\\<^sub>0 = heap' on - {l\\<^sub>0..<r\\<^sub>0 0}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l\\<^sub>0_ < r\\<^sub>0_ 0;\n     is_heap (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ (r\\<^sub>0_ 0);\n     is_heap (\\<le>) heap'_ l\\<^sub>0_ (r\\<^sub>0_ 0 - 1);\n     arr_mset\n      (heap\\<^sub>0_(l\\<^sub>0_ := heap\\<^sub>0_ (r\\<^sub>0_ 0 - 1)))\n      l\\<^sub>0_ (r\\<^sub>0_ 0 - 1) =\n     arr_mset heap'_ l\\<^sub>0_ (r\\<^sub>0_ 0 - 1);\n     heap\\<^sub>0_\n     (l\\<^sub>0_ :=\n        heap\\<^sub>0_\n         (r\\<^sub>0_ 0 -\n          1)) = heap'_ on - {l\\<^sub>0_..<r\\<^sub>0_ 0 - 1}\\<rbrakk>\n    \\<Longrightarrow> arr_mset heap'_ l\\<^sub>0_ (r\\<^sub>0_ 0 - 1) =\n                      arr_mset heap\\<^sub>0_ l\\<^sub>0_ (r\\<^sub>0_ 0) -\n                      {#Min_mset\n                         (arr_mset heap\\<^sub>0_ l\\<^sub>0_\n                           (r\\<^sub>0_ 0))#} \\<and>\n                      heap\\<^sub>0_ = heap'_ on - {l\\<^sub>0_..<r\\<^sub>0_\n                           0}", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>l\\<^sub>0_ < r\\<^sub>0_ 0;\n     is_heap (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ (r\\<^sub>0_ 0);\n     is_heap (\\<le>) heap'_ l\\<^sub>0_ (r\\<^sub>0_ 0 - 1);\n     arr_mset\n      (heap\\<^sub>0_(l\\<^sub>0_ := heap\\<^sub>0_ (r\\<^sub>0_ 0 - 1)))\n      l\\<^sub>0_ (r\\<^sub>0_ 0 - 1) =\n     arr_mset heap'_ l\\<^sub>0_ (r\\<^sub>0_ 0 - 1);\n     heap\\<^sub>0_\n     (l\\<^sub>0_ :=\n        heap\\<^sub>0_\n         (r\\<^sub>0_ 0 -\n          1)) = heap'_ on - {l\\<^sub>0_..<r\\<^sub>0_ 0 - 1}\\<rbrakk>\n    \\<Longrightarrow> arr_mset heap'_ l\\<^sub>0_ (r\\<^sub>0_ 0 - 1) =\n                      arr_mset heap\\<^sub>0_ l\\<^sub>0_ (r\\<^sub>0_ 0) -\n                      {#Min_mset\n                         (arr_mset heap\\<^sub>0_ l\\<^sub>0_\n                           (r\\<^sub>0_ 0))#}\n 2. \\<lbrakk>l\\<^sub>0_ < r\\<^sub>0_ 0;\n     is_heap (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ (r\\<^sub>0_ 0);\n     is_heap (\\<le>) heap'_ l\\<^sub>0_ (r\\<^sub>0_ 0 - 1);\n     arr_mset\n      (heap\\<^sub>0_(l\\<^sub>0_ := heap\\<^sub>0_ (r\\<^sub>0_ 0 - 1)))\n      l\\<^sub>0_ (r\\<^sub>0_ 0 - 1) =\n     arr_mset heap'_ l\\<^sub>0_ (r\\<^sub>0_ 0 - 1);\n     heap\\<^sub>0_\n     (l\\<^sub>0_ :=\n        heap\\<^sub>0_\n         (r\\<^sub>0_ 0 -\n          1)) = heap'_ on - {l\\<^sub>0_..<r\\<^sub>0_ 0 - 1}\\<rbrakk>\n    \\<Longrightarrow> heap\\<^sub>0_ = heap'_ on - {l\\<^sub>0_..<r\\<^sub>0_\n                           0}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l\\<^sub>0_ < r\\<^sub>0_ 0;\n     is_heap (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ (r\\<^sub>0_ 0);\n     is_heap (\\<le>) heap'_ l\\<^sub>0_ (r\\<^sub>0_ 0 - 1);\n     arr_mset\n      (heap\\<^sub>0_(l\\<^sub>0_ := heap\\<^sub>0_ (r\\<^sub>0_ 0 - 1)))\n      l\\<^sub>0_ (r\\<^sub>0_ 0 - 1) =\n     arr_mset heap'_ l\\<^sub>0_ (r\\<^sub>0_ 0 - 1);\n     heap\\<^sub>0_\n     (l\\<^sub>0_ :=\n        heap\\<^sub>0_\n         (r\\<^sub>0_ 0 -\n          1)) = heap'_ on - {l\\<^sub>0_..<r\\<^sub>0_ 0 - 1}\\<rbrakk>\n    \\<Longrightarrow> arr_mset heap'_ l\\<^sub>0_ (r\\<^sub>0_ 0 - 1) =\n                      arr_mset heap\\<^sub>0_ l\\<^sub>0_ (r\\<^sub>0_ 0) -\n                      {#Min_mset\n                         (arr_mset heap\\<^sub>0_ l\\<^sub>0_\n                           (r\\<^sub>0_ 0))#}", "using del_min_mset"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l < ?r; is_heap (\\<le>) ?heap ?l ?r;\n   ?mod_heap = ?heap(?l := ?heap (?r - 1));\n   arr_mset ?mod_heap ?l (?r - 1) = arr_mset ?new_heap ?l (?r - 1)\\<rbrakk>\n  \\<Longrightarrow> arr_mset ?new_heap ?l (?r - 1) =\n                    arr_mset ?heap ?l ?r -\n                    {#Min_mset (arr_mset ?heap ?l ?r)#}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l\\<^sub>0_ < r\\<^sub>0_ 0;\n     is_heap (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ (r\\<^sub>0_ 0);\n     is_heap (\\<le>) heap'_ l\\<^sub>0_ (r\\<^sub>0_ 0 - 1);\n     arr_mset\n      (heap\\<^sub>0_(l\\<^sub>0_ := heap\\<^sub>0_ (r\\<^sub>0_ 0 - 1)))\n      l\\<^sub>0_ (r\\<^sub>0_ 0 - 1) =\n     arr_mset heap'_ l\\<^sub>0_ (r\\<^sub>0_ 0 - 1);\n     heap\\<^sub>0_\n     (l\\<^sub>0_ :=\n        heap\\<^sub>0_\n         (r\\<^sub>0_ 0 -\n          1)) = heap'_ on - {l\\<^sub>0_..<r\\<^sub>0_ 0 - 1}\\<rbrakk>\n    \\<Longrightarrow> arr_mset heap'_ l\\<^sub>0_ (r\\<^sub>0_ 0 - 1) =\n                      arr_mset heap\\<^sub>0_ l\\<^sub>0_ (r\\<^sub>0_ 0) -\n                      {#Min_mset\n                         (arr_mset heap\\<^sub>0_ l\\<^sub>0_\n                           (r\\<^sub>0_ 0))#}", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l\\<^sub>0_ < r\\<^sub>0_ 0;\n     is_heap (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ (r\\<^sub>0_ 0);\n     is_heap (\\<le>) heap'_ l\\<^sub>0_ (r\\<^sub>0_ 0 - 1);\n     arr_mset\n      (heap\\<^sub>0_(l\\<^sub>0_ := heap\\<^sub>0_ (r\\<^sub>0_ 0 - 1)))\n      l\\<^sub>0_ (r\\<^sub>0_ 0 - 1) =\n     arr_mset heap'_ l\\<^sub>0_ (r\\<^sub>0_ 0 - 1);\n     heap\\<^sub>0_\n     (l\\<^sub>0_ :=\n        heap\\<^sub>0_\n         (r\\<^sub>0_ 0 -\n          1)) = heap'_ on - {l\\<^sub>0_..<r\\<^sub>0_ 0 - 1}\\<rbrakk>\n    \\<Longrightarrow> heap\\<^sub>0_ = heap'_ on - {l\\<^sub>0_..<r\\<^sub>0_\n                           0}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l\\<^sub>0_ < r\\<^sub>0_ 0;\n     is_heap (\\<le>) heap\\<^sub>0_ l\\<^sub>0_ (r\\<^sub>0_ 0);\n     is_heap (\\<le>) heap'_ l\\<^sub>0_ (r\\<^sub>0_ 0 - 1);\n     arr_mset\n      (heap\\<^sub>0_(l\\<^sub>0_ := heap\\<^sub>0_ (r\\<^sub>0_ 0 - 1)))\n      l\\<^sub>0_ (r\\<^sub>0_ 0 - 1) =\n     arr_mset heap'_ l\\<^sub>0_ (r\\<^sub>0_ 0 - 1);\n     heap\\<^sub>0_\n     (l\\<^sub>0_ :=\n        heap\\<^sub>0_\n         (r\\<^sub>0_ 0 -\n          1)) = heap'_ on - {l\\<^sub>0_..<r\\<^sub>0_ 0 - 1}\\<rbrakk>\n    \\<Longrightarrow> heap\\<^sub>0_ = heap'_ on - {l\\<^sub>0_..<r\\<^sub>0_\n                           0}", "by (simp add: eq_on_def intvs_incdec(3) intvs_lower_incr)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>\\<open>make_heap\\<close> transforms an arbitrary array into a heap by iterating through all array \n      positions from the middle of the array up to the beginning of the array and calling \n      @{const \"sift_down\"} for each one.\\<close>"], ["", "procedure_spec make_heap (heap, l, r) returns heap\n  assumes \"l \\<le> r\"  \n    ensures \"is_heap (\\<le>) heap l\\<^sub>0 r\\<^sub>0 \\<and> \n             arr_mset heap l\\<^sub>0 r\\<^sub>0 = arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 \\<and> \n             heap\\<^sub>0 = heap on - {l\\<^sub>0..< r\\<^sub>0}\"\n  for heap[] l r\n  defines \\<open>\n    y = (r + l)/2 - 1;\n    while (y \\<ge> l)\n          @variant \\<open>y - l + 1\\<close>\n          @invariant \\<open>is_partial_heap (\\<le>) heap l (y + 1) r \\<and>\n                      arr_mset heap l r = arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 \\<and>\n                      l - 1 \\<le> y \\<and> y < r \\<and> heap\\<^sub>0 = heap on - {l..<r}\\<close>\n    {\n      heap = sift_down(heap, l, r, y);\n      y = y - 1\n    }\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT' Map.empty\n     (\\<lambda>\\<ss>.\n         VAR (\\<ss> ''r'' 0)\n          (\\<lambda>r.\n              VAR (\\<ss> ''l'' 0) (\\<lambda>l. BB_PROTECT (l \\<le> r))))\n     (\\<lambda>\\<ss>\\<^sub>0.\n         ''y'' ::= Binop (-)\n                    (Binop (div) (Binop (+) (V ''r'') (V ''l'')) (N 2))\n                    (N 1);;\n         WHILE {ANNOTATION\n                 (\\<lambda>\\<ss>.\n                     VAR (\\<ss> ''y'' 0)\n                      (\\<lambda>y.\n                          VAR (\\<ss> ''l'' 0)\n                           (\\<lambda>l.\n                               BB_PROTECT\n                                (y - l +\n                                 1))))} {ANNOTATION\n    (\\<lambda>\\<ss>.\n        VAR (\\<ss> ''heap'')\n         (\\<lambda>heap.\n             VAR (\\<ss> ''y'' 0)\n              (\\<lambda>y.\n                  VAR (\\<ss> ''r'' 0)\n                   (\\<lambda>r.\n                       VAR (\\<ss> ''l'' 0)\n                        (\\<lambda>l.\n                            VAR (\\<ss>\\<^sub>0 ''heap'')\n                             (\\<lambda>heap\\<^sub>0.\n                                 VAR (\\<ss>\\<^sub>0 ''r'' 0)\n                                  (\\<lambda>r\\<^sub>0.\nVAR (\\<ss>\\<^sub>0 ''l'' 0)\n (\\<lambda>l\\<^sub>0.\n     BB_PROTECT\n      (is_partial_heap (\\<le>) heap l (y + 1) r \\<and>\n       arr_mset heap l r = arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0 \\<and>\n       l - 1 \\<le> y \\<and>\n       y < r \\<and>\n       heap\\<^sub>0 = heap on - {l..<r})))))))))} Cmpop\n             (\\<lambda>x y. y \\<le> x) (V ''y'') (V ''l'')\n         DO ((''G_par_1''[] ::= ''heap'';; ''G_par_2''[] ::= ''l'';;\n              ''G_par_3''[] ::= ''r'';; ''G_par_4''[] ::= ''y'';;\n              Params sift_down;; ArrayCpy_retv ''heap'' ''G_ret_1'');;\n             ''y'' ::= Binop (-) (V ''y'') (N 1)))\n     (\\<lambda>\\<ss>\\<^sub>0 \\<ss>.\n         VAR (\\<ss> ''heap'')\n          (\\<lambda>heap.\n              VAR (\\<ss>\\<^sub>0 ''heap'')\n               (\\<lambda>heap\\<^sub>0.\n                   VAR (\\<ss>\\<^sub>0 ''r'' 0)\n                    (\\<lambda>r\\<^sub>0.\n                        VAR (\\<ss>\\<^sub>0 ''l'' 0)\n                         (\\<lambda>l\\<^sub>0.\n                             BB_PROTECT\n                              (is_heap (\\<le>) heap l\\<^sub>0\n                                r\\<^sub>0 \\<and>\n                               arr_mset heap l\\<^sub>0 r\\<^sub>0 =\n                               arr_mset heap\\<^sub>0 l\\<^sub>0\n                                r\\<^sub>0 \\<and>\n                               heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}))))))", "apply(vcg_cs)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>r\\<^sub>0 l\\<^sub>0 heap\\<^sub>0.\n       \\<lbrakk>\\<paragraph>''invar-initial'';\n        l\\<^sub>0 \\<le> r\\<^sub>0\\<rbrakk>\n       \\<Longrightarrow> is_partial_heap (\\<le>) heap\\<^sub>0 l\\<^sub>0\n                          ((r\\<^sub>0 + l\\<^sub>0) div 2) r\\<^sub>0 \\<and>\n                         l\\<^sub>0 - 1\n                         < (r\\<^sub>0 + l\\<^sub>0) div 2 \\<and>\n                         (r\\<^sub>0 + l\\<^sub>0) div 2 - 1 < r\\<^sub>0\n 2. \\<And>r\\<^sub>0 l\\<^sub>0 heap\\<^sub>0 y heap.\n       \\<lbrakk>l\\<^sub>0 \\<le> y;\n        is_partial_heap (\\<le>) heap l\\<^sub>0 (y + 1) r\\<^sub>0;\n        arr_mset heap l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0;\n        y < r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_partial_heap_except_down (\\<le>) heap l\\<^sub>0\n                          y r\\<^sub>0 y\n 3. \\<And>r\\<^sub>0 l\\<^sub>0 heap\\<^sub>0 y heap heap'.\n       \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0 \\<le> y;\n        is_partial_heap (\\<le>) heap l\\<^sub>0 (y + 1) r\\<^sub>0;\n        is_partial_heap (\\<le>) heap' l\\<^sub>0 y r\\<^sub>0;\n        arr_mset heap' l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0;\n        arr_mset heap l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0;\n        heap = heap' on - {l\\<^sub>0..<r\\<^sub>0}; y < r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> heap\\<^sub>0 = heap' on - {l\\<^sub>0..<r\\<^sub>0}\n 4. \\<And>r\\<^sub>0 l\\<^sub>0 heap\\<^sub>0 y heap.\n       \\<lbrakk>\\<paragraph>''invar-post''; \\<not> l\\<^sub>0 \\<le> y;\n        is_partial_heap (\\<le>) heap l\\<^sub>0 (y + 1) r\\<^sub>0;\n        arr_mset heap l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0;\n        l\\<^sub>0 - 1 \\<le> y; y < r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_heap (\\<le>) heap l\\<^sub>0 r\\<^sub>0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''invar-initial'';\n     l\\<^sub>0_ \\<le> r\\<^sub>0_\\<rbrakk>\n    \\<Longrightarrow> is_partial_heap (\\<le>) heap\\<^sub>0_ l\\<^sub>0_\n                       ((r\\<^sub>0_ + l\\<^sub>0_) div 2) r\\<^sub>0_ \\<and>\n                      l\\<^sub>0_ - 1\n                      < (r\\<^sub>0_ + l\\<^sub>0_) div 2 \\<and>\n                      (r\\<^sub>0_ + l\\<^sub>0_) div 2 - 1 < r\\<^sub>0_", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<paragraph>''invar-initial'';\n     l\\<^sub>0_ \\<le> r\\<^sub>0_\\<rbrakk>\n    \\<Longrightarrow> is_partial_heap (\\<le>) heap\\<^sub>0_ l\\<^sub>0_\n                       ((r\\<^sub>0_ + l\\<^sub>0_) div 2) r\\<^sub>0_\n 2. \\<lbrakk>\\<paragraph>''invar-initial'';\n     l\\<^sub>0_ \\<le> r\\<^sub>0_\\<rbrakk>\n    \\<Longrightarrow> l\\<^sub>0_ - 1\n                      < (r\\<^sub>0_ + l\\<^sub>0_) div 2 \\<and>\n                      (r\\<^sub>0_ + l\\<^sub>0_) div 2 - 1 < r\\<^sub>0_", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''invar-initial'';\n     l\\<^sub>0_ \\<le> r\\<^sub>0_\\<rbrakk>\n    \\<Longrightarrow> is_partial_heap (\\<le>) heap\\<^sub>0_ l\\<^sub>0_\n                       ((r\\<^sub>0_ + l\\<^sub>0_) div 2) r\\<^sub>0_", "by (simp add: snd_half_is_partial_heap add.commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''invar-initial'';\n     l\\<^sub>0_ \\<le> r\\<^sub>0_\\<rbrakk>\n    \\<Longrightarrow> l\\<^sub>0_ - 1\n                      < (r\\<^sub>0_ + l\\<^sub>0_) div 2 \\<and>\n                      (r\\<^sub>0_ + l\\<^sub>0_) div 2 - 1 < r\\<^sub>0_", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''invar-initial'';\n     l\\<^sub>0_ \\<le> r\\<^sub>0_\\<rbrakk>\n    \\<Longrightarrow> l\\<^sub>0_ - 1\n                      < (r\\<^sub>0_ + l\\<^sub>0_) div 2 \\<and>\n                      (r\\<^sub>0_ + l\\<^sub>0_) div 2 - 1 < r\\<^sub>0_", "by linarith"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>r\\<^sub>0 l\\<^sub>0 heap\\<^sub>0 y heap.\n       \\<lbrakk>l\\<^sub>0 \\<le> y;\n        is_partial_heap (\\<le>) heap l\\<^sub>0 (y + 1) r\\<^sub>0;\n        arr_mset heap l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0;\n        y < r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_partial_heap_except_down (\\<le>) heap l\\<^sub>0\n                          y r\\<^sub>0 y\n 2. \\<And>r\\<^sub>0 l\\<^sub>0 heap\\<^sub>0 y heap heap'.\n       \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0 \\<le> y;\n        is_partial_heap (\\<le>) heap l\\<^sub>0 (y + 1) r\\<^sub>0;\n        is_partial_heap (\\<le>) heap' l\\<^sub>0 y r\\<^sub>0;\n        arr_mset heap' l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0;\n        arr_mset heap l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0;\n        heap = heap' on - {l\\<^sub>0..<r\\<^sub>0}; y < r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> heap\\<^sub>0 = heap' on - {l\\<^sub>0..<r\\<^sub>0}\n 3. \\<And>r\\<^sub>0 l\\<^sub>0 heap\\<^sub>0 y heap.\n       \\<lbrakk>\\<paragraph>''invar-post''; \\<not> l\\<^sub>0 \\<le> y;\n        is_partial_heap (\\<le>) heap l\\<^sub>0 (y + 1) r\\<^sub>0;\n        arr_mset heap l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0;\n        l\\<^sub>0 - 1 \\<le> y; y < r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_heap (\\<le>) heap l\\<^sub>0 r\\<^sub>0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>l\\<^sub>0_ \\<le> y_;\n     is_partial_heap (\\<le>) heap_ l\\<^sub>0_ (y_ + 1) r\\<^sub>0_;\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_;\n     y_ < r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_\n                       y_ r\\<^sub>0_ y_", "using partial_heap_added_first_el le_less"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l \\<le> ?m; ?m \\<le> ?r;\n   is_partial_heap ?cmp ?heap ?l (?m + 1) ?r\\<rbrakk>\n  \\<Longrightarrow> is_partial_heap_except_down ?cmp ?heap ?l ?m ?r ?m\n  (?x \\<le> ?y) = (?x < ?y \\<or> ?x = ?y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>l\\<^sub>0_ \\<le> y_;\n     is_partial_heap (\\<le>) heap_ l\\<^sub>0_ (y_ + 1) r\\<^sub>0_;\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_;\n     y_ < r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> is_partial_heap_except_down (\\<le>) heap_ l\\<^sub>0_\n                       y_ r\\<^sub>0_ y_", "by blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r\\<^sub>0 l\\<^sub>0 heap\\<^sub>0 y heap heap'.\n       \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0 \\<le> y;\n        is_partial_heap (\\<le>) heap l\\<^sub>0 (y + 1) r\\<^sub>0;\n        is_partial_heap (\\<le>) heap' l\\<^sub>0 y r\\<^sub>0;\n        arr_mset heap' l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0;\n        arr_mset heap l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0;\n        heap = heap' on - {l\\<^sub>0..<r\\<^sub>0}; y < r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> heap\\<^sub>0 = heap' on - {l\\<^sub>0..<r\\<^sub>0}\n 2. \\<And>r\\<^sub>0 l\\<^sub>0 heap\\<^sub>0 y heap.\n       \\<lbrakk>\\<paragraph>''invar-post''; \\<not> l\\<^sub>0 \\<le> y;\n        is_partial_heap (\\<le>) heap l\\<^sub>0 (y + 1) r\\<^sub>0;\n        arr_mset heap l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0;\n        l\\<^sub>0 - 1 \\<le> y; y < r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_heap (\\<le>) heap l\\<^sub>0 r\\<^sub>0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ \\<le> y_;\n     is_partial_heap (\\<le>) heap_ l\\<^sub>0_ (y_ + 1) r\\<^sub>0_;\n     is_partial_heap (\\<le>) heap'_ l\\<^sub>0_ y_ r\\<^sub>0_;\n     arr_mset heap'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_;\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_;\n     heap_ = heap'_ on - {l\\<^sub>0_..<r\\<^sub>0_}; y_ < r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> heap\\<^sub>0_ = heap'_ on - {l\\<^sub>0_..<r\\<^sub>0_}", "using eq_on_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>?r = ?s on ?X; ?s = ?t on ?X\\<rbrakk>\n  \\<Longrightarrow> ?r = ?t on ?X\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ \\<le> y_;\n     is_partial_heap (\\<le>) heap_ l\\<^sub>0_ (y_ + 1) r\\<^sub>0_;\n     is_partial_heap (\\<le>) heap'_ l\\<^sub>0_ y_ r\\<^sub>0_;\n     arr_mset heap'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_;\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_;\n     heap_ = heap'_ on - {l\\<^sub>0_..<r\\<^sub>0_}; y_ < r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> heap\\<^sub>0_ = heap'_ on - {l\\<^sub>0_..<r\\<^sub>0_}", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r\\<^sub>0 l\\<^sub>0 heap\\<^sub>0 y heap.\n       \\<lbrakk>\\<paragraph>''invar-post''; \\<not> l\\<^sub>0 \\<le> y;\n        is_partial_heap (\\<le>) heap l\\<^sub>0 (y + 1) r\\<^sub>0;\n        arr_mset heap l\\<^sub>0 r\\<^sub>0 =\n        arr_mset heap\\<^sub>0 l\\<^sub>0 r\\<^sub>0;\n        l\\<^sub>0 - 1 \\<le> y; y < r\\<^sub>0;\n        heap\\<^sub>0 = heap on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_heap (\\<le>) heap l\\<^sub>0 r\\<^sub>0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''invar-post''; \\<not> l\\<^sub>0_ \\<le> y_;\n     is_partial_heap (\\<le>) heap_ l\\<^sub>0_ (y_ + 1) r\\<^sub>0_;\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_;\n     l\\<^sub>0_ - 1 \\<le> y_; y_ < r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> is_heap (\\<le>) heap_ l\\<^sub>0_ r\\<^sub>0_", "using dual_order.antisym"], ["proof (prove)\nusing this:\n  \\<lbrakk>?b \\<le> ?a; ?a \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?a = ?b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''invar-post''; \\<not> l\\<^sub>0_ \\<le> y_;\n     is_partial_heap (\\<le>) heap_ l\\<^sub>0_ (y_ + 1) r\\<^sub>0_;\n     arr_mset heap_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset heap\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_;\n     l\\<^sub>0_ - 1 \\<le> y_; y_ < r\\<^sub>0_;\n     heap\\<^sub>0_ = heap_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> is_heap (\\<le>) heap_ l\\<^sub>0_ r\\<^sub>0_", "by fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Heapsort Implementation\\<close>"], ["", "text \\<open>The final part of this submission is the implementation of the in-place heapsort. Firstly it \n      builds the \\<open>\\<le>\\<close>-heap and then it iteratively removes the minimum of the heap, which is put at \n      the now vacant end of the shrinking heap. This is done until the heap is empty, which leaves \n      the array sorted in descending order.\\<close>"], ["", "subsubsection \\<open>Auxiliary Lemmas\\<close>"], ["", "text \\<open>Firstly the notion of a sorted array is needed. This is more or less the same as \n      @{const \"ran_sorted\"} generalized for arbitrary comparison functions.\\<close>"], ["", "definition array_is_sorted :: \"(int \\<Rightarrow> int \\<Rightarrow> bool) \\<Rightarrow>  (int \\<Rightarrow> int) \\<Rightarrow> int \\<Rightarrow> int \\<Rightarrow> bool\" where\n  \"array_is_sorted cmp a l r \\<equiv> \\<forall>i. \\<forall>j. bounded l r i \\<longrightarrow> bounded l r j \\<longrightarrow> i < j \\<longrightarrow> cmp (a i) (a j)\""], ["", "text \\<open>This lemma states, that the heapsort doesn't change the elements contained in the array during\n      the loop iterations.\\<close>"], ["", "lemma heap_sort_mset_step:\n  fixes arr::\"int \\<Rightarrow> int\"\n  assumes \n    \"l < m\" \"m \\<le> r\"\n    \"arr_mset arr' l (m - 1) = arr_mset arr l m - {#Min_mset (arr_mset arr l m)#}\"\n    \"arr = arr' on - {l..<m}\"\n    \"mod_arr = arr'(m - 1 := Min_mset (arr_mset arr l m))\"\n  shows \"arr_mset arr l r = arr_mset mod_arr l r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr_mset arr l r = arr_mset mod_arr l r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. arr_mset arr l r = arr_mset mod_arr l r", "let ?min = \"{#Min_mset (arr_mset arr l m)#}\""], ["proof (state)\ngoal (1 subgoal):\n 1. arr_mset arr l r = arr_mset mod_arr l r", "let ?new_arr_mset = \"arr_mset mod_arr\""], ["proof (state)\ngoal (1 subgoal):\n 1. arr_mset arr l r = arr_mset mod_arr l r", "have middle: \"?new_arr_mset (m - 1) m = ?min\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr_mset mod_arr (m - 1) m = {#Min_mset (arr_mset arr l m)#}", "by (simp add: assms(5))"], ["proof (state)\nthis:\n  arr_mset mod_arr (m - 1) m = {#Min_mset (arr_mset arr l m)#}\n\ngoal (1 subgoal):\n 1. arr_mset arr l r = arr_mset mod_arr l r", "have first_half: \"?new_arr_mset l (m - 1) = arr_mset arr l m - ?min\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr_mset mod_arr l (m - 1) =\n    arr_mset arr l m - {#Min_mset (arr_mset arr l m)#}", "by (simp add: assms(3,5) mset_ran_subst_outside)"], ["proof (state)\nthis:\n  arr_mset mod_arr l (m - 1) =\n  arr_mset arr l m - {#Min_mset (arr_mset arr l m)#}\n\ngoal (1 subgoal):\n 1. arr_mset arr l r = arr_mset mod_arr l r", "hence \"?new_arr_mset l m = ?new_arr_mset l (m - 1) + ?new_arr_mset (m - 1) m\""], ["proof (prove)\nusing this:\n  arr_mset mod_arr l (m - 1) =\n  arr_mset arr l m - {#Min_mset (arr_mset arr l m)#}\n\ngoal (1 subgoal):\n 1. arr_mset mod_arr l m =\n    arr_mset mod_arr l (m - 1) + arr_mset mod_arr (m - 1) m", "by (metis assms(1,3,5) diff_add_cancel middle arr_mset_append_alt zle_diff1_eq)"], ["proof (state)\nthis:\n  arr_mset mod_arr l m =\n  arr_mset mod_arr l (m - 1) + arr_mset mod_arr (m - 1) m\n\ngoal (1 subgoal):\n 1. arr_mset arr l r = arr_mset mod_arr l r", "hence first_half_middle: \"?new_arr_mset l m = arr_mset arr l m\""], ["proof (prove)\nusing this:\n  arr_mset mod_arr l m =\n  arr_mset mod_arr l (m - 1) + arr_mset mod_arr (m - 1) m\n\ngoal (1 subgoal):\n 1. arr_mset mod_arr l m = arr_mset arr l m", "using middle first_half assms(1)"], ["proof (prove)\nusing this:\n  arr_mset mod_arr l m =\n  arr_mset mod_arr l (m - 1) + arr_mset mod_arr (m - 1) m\n  arr_mset mod_arr (m - 1) m = {#Min_mset (arr_mset arr l m)#}\n  arr_mset mod_arr l (m - 1) =\n  arr_mset arr l m - {#Min_mset (arr_mset arr l m)#}\n  l < m\n\ngoal (1 subgoal):\n 1. arr_mset mod_arr l m = arr_mset arr l m", "by simp"], ["proof (state)\nthis:\n  arr_mset mod_arr l m = arr_mset arr l m\n\ngoal (1 subgoal):\n 1. arr_mset arr l r = arr_mset mod_arr l r", "hence \"mod_arr = arr on - {l..<m}\""], ["proof (prove)\nusing this:\n  arr_mset mod_arr l m = arr_mset arr l m\n\ngoal (1 subgoal):\n 1. mod_arr = arr on - {l..<m}", "using assms(1,4,5) eq_on_sym eq_on_trans"], ["proof (prove)\nusing this:\n  arr_mset mod_arr l m = arr_mset arr l m\n  l < m\n  arr = arr' on - {l..<m}\n  mod_arr = arr'(m - 1 := Min_mset (arr_mset arr l m))\n  ?s = ?t on ?X \\<Longrightarrow> ?t = ?s on ?X\n  \\<lbrakk>?r = ?s on ?X; ?s = ?t on ?X\\<rbrakk>\n  \\<Longrightarrow> ?r = ?t on ?X\n\ngoal (1 subgoal):\n 1. mod_arr = arr on - {l..<m}", "by auto"], ["proof (state)\nthis:\n  mod_arr = arr on - {l..<m}\n\ngoal (1 subgoal):\n 1. arr_mset arr l r = arr_mset mod_arr l r", "then"], ["proof (chain)\npicking this:\n  mod_arr = arr on - {l..<m}", "have second_half: \"arr_mset arr m r = arr_mset mod_arr m r\""], ["proof (prove)\nusing this:\n  mod_arr = arr on - {l..<m}\n\ngoal (1 subgoal):\n 1. arr_mset arr m r = arr_mset mod_arr m r", "by (simp add: eq_on_def mset_ran_cong)"], ["proof (state)\nthis:\n  arr_mset arr m r = arr_mset mod_arr m r\n\ngoal (1 subgoal):\n 1. arr_mset arr l r = arr_mset mod_arr l r", "then"], ["proof (chain)\npicking this:\n  arr_mset arr m r = arr_mset mod_arr m r", "show ?thesis"], ["proof (prove)\nusing this:\n  arr_mset arr m r = arr_mset mod_arr m r\n\ngoal (1 subgoal):\n 1. arr_mset arr l r = arr_mset mod_arr l r", "by (metis arr_mset_split assms(1,2) first_half_middle le_less)"], ["proof (state)\nthis:\n  arr_mset arr l r = arr_mset mod_arr l r\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>This lemma states, that each loop iteration leaves the growing second half of the array \n      sorted in descending order.\\<close>"], ["", "lemma heap_sort_second_half_sorted_step: \n  fixes arr::\"int \\<Rightarrow> int\"\n  assumes\n    \"l\\<^sub>0 < m\" \"m \\<le> r\\<^sub>0\"\n    \"arr = arr' on - {l\\<^sub>0..<m}\"\n    \"\\<forall>i. \\<forall>j. bounded m r\\<^sub>0 i \\<longrightarrow> bounded m r\\<^sub>0 j \\<longrightarrow>  i < j \\<longrightarrow> arr j \\<le> arr i\"\n    \"\\<forall>x\\<in>#arr_mset arr l\\<^sub>0 m. \\<forall>y\\<in>#arr_mset arr m r\\<^sub>0. \\<not> x < y\"\n    \"bounded (m - 1) r\\<^sub>0 i\" \n    \"bounded (m - 1) r\\<^sub>0 j\" \n    \"i < j\"\n    \"mod_arr = (arr'(m - 1 := Min_mset (arr_mset arr l\\<^sub>0 m)))\"\n  shows \"mod_arr j \\<le> mod_arr i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_arr j \\<le> mod_arr i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mod_arr j \\<le> mod_arr i", "have second_half_eq: \"mod_arr = arr on {m..< r\\<^sub>0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mod_arr = arr on {m..<r\\<^sub>0}", "using assms(3, 9)"], ["proof (prove)\nusing this:\n  arr = arr' on - {l\\<^sub>0..<m}\n  mod_arr = arr'(m - 1 := Min_mset (arr_mset arr l\\<^sub>0 m))\n\ngoal (1 subgoal):\n 1. mod_arr = arr on {m..<r\\<^sub>0}", "unfolding eq_on_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>- {l\\<^sub>0..<m}. arr x = arr' x\n  mod_arr = arr'(m - 1 := Min_mset (arr_mset arr l\\<^sub>0 m))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{m..<r\\<^sub>0}. mod_arr x = arr x", "by simp"], ["proof (state)\nthis:\n  mod_arr = arr on {m..<r\\<^sub>0}\n\ngoal (1 subgoal):\n 1. mod_arr j \\<le> mod_arr i", "have j_stricter_bound: \"bounded m r\\<^sub>0 j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded m r\\<^sub>0 j", "using assms(6-8)"], ["proof (prove)\nusing this:\n  bounded (m - 1) r\\<^sub>0 i\n  bounded (m - 1) r\\<^sub>0 j\n  i < j\n\ngoal (1 subgoal):\n 1. bounded m r\\<^sub>0 j", "by simp"], ["proof (state)\nthis:\n  bounded m r\\<^sub>0 j\n\ngoal (1 subgoal):\n 1. mod_arr j \\<le> mod_arr i", "then"], ["proof (chain)\npicking this:\n  bounded m r\\<^sub>0 j", "have el_at_j: \"mod_arr j \\<in># arr_mset arr m r\\<^sub>0\""], ["proof (prove)\nusing this:\n  bounded m r\\<^sub>0 j\n\ngoal (1 subgoal):\n 1. mod_arr j \\<in># arr_mset arr m r\\<^sub>0", "using eq_onD second_half_eq"], ["proof (prove)\nusing this:\n  bounded m r\\<^sub>0 j\n  \\<lbrakk>?r = ?s on ?X; ?x \\<in> ?X\\<rbrakk>\n  \\<Longrightarrow> ?r ?x = ?s ?x\n  mod_arr = arr on {m..<r\\<^sub>0}\n\ngoal (1 subgoal):\n 1. mod_arr j \\<in># arr_mset arr m r\\<^sub>0", "by fastforce"], ["proof (state)\nthis:\n  mod_arr j \\<in># arr_mset arr m r\\<^sub>0\n\ngoal (1 subgoal):\n 1. mod_arr j \\<le> mod_arr i", "then"], ["proof (chain)\npicking this:\n  mod_arr j \\<in># arr_mset arr m r\\<^sub>0", "show ?thesis"], ["proof (prove)\nusing this:\n  mod_arr j \\<in># arr_mset arr m r\\<^sub>0\n\ngoal (1 subgoal):\n 1. mod_arr j \\<le> mod_arr i", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>mod_arr j \\<in># arr_mset arr m r\\<^sub>0; ?P1\\<rbrakk>\n    \\<Longrightarrow> mod_arr j \\<le> mod_arr i\n 2. \\<lbrakk>mod_arr j \\<in># arr_mset arr m r\\<^sub>0; \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> mod_arr j \\<le> mod_arr i", "assume \"i = (m-1)\""], ["proof (state)\nthis:\n  i = m - 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mod_arr j \\<in># arr_mset arr m r\\<^sub>0; ?P1\\<rbrakk>\n    \\<Longrightarrow> mod_arr j \\<le> mod_arr i\n 2. \\<lbrakk>mod_arr j \\<in># arr_mset arr m r\\<^sub>0; \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> mod_arr j \\<le> mod_arr i", "then"], ["proof (chain)\npicking this:\n  i = m - 1", "have \"mod_arr i \\<in># arr_mset arr l\\<^sub>0 m\""], ["proof (prove)\nusing this:\n  i = m - 1\n\ngoal (1 subgoal):\n 1. mod_arr i \\<in># arr_mset arr l\\<^sub>0 m", "by (simp add: assms(1, 9))"], ["proof (state)\nthis:\n  mod_arr i \\<in># arr_mset arr l\\<^sub>0 m\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mod_arr j \\<in># arr_mset arr m r\\<^sub>0; ?P1\\<rbrakk>\n    \\<Longrightarrow> mod_arr j \\<le> mod_arr i\n 2. \\<lbrakk>mod_arr j \\<in># arr_mset arr m r\\<^sub>0; \\<not> ?P1\\<rbrakk>\n    \\<Longrightarrow> mod_arr j \\<le> mod_arr i", "then"], ["proof (chain)\npicking this:\n  mod_arr i \\<in># arr_mset arr l\\<^sub>0 m", "show ?thesis"], ["proof (prove)\nusing this:\n  mod_arr i \\<in># arr_mset arr l\\<^sub>0 m\n\ngoal (1 subgoal):\n 1. mod_arr j \\<le> mod_arr i", "using assms(5) el_at_j not_less"], ["proof (prove)\nusing this:\n  mod_arr i \\<in># arr_mset arr l\\<^sub>0 m\n  \\<forall>x\\<in>#arr_mset arr l\\<^sub>0 m.\n     \\<forall>y\\<in>#arr_mset arr m r\\<^sub>0. \\<not> x < y\n  mod_arr j \\<in># arr_mset arr m r\\<^sub>0\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. mod_arr j \\<le> mod_arr i", "by blast"], ["proof (state)\nthis:\n  mod_arr j \\<le> mod_arr i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mod_arr j \\<in># arr_mset arr m r\\<^sub>0;\n     i \\<noteq> m - 1\\<rbrakk>\n    \\<Longrightarrow> mod_arr j \\<le> mod_arr i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>mod_arr j \\<in># arr_mset arr m r\\<^sub>0;\n     i \\<noteq> m - 1\\<rbrakk>\n    \\<Longrightarrow> mod_arr j \\<le> mod_arr i", "assume \"i \\<noteq> (m-1)\""], ["proof (state)\nthis:\n  i \\<noteq> m - 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mod_arr j \\<in># arr_mset arr m r\\<^sub>0;\n     i \\<noteq> m - 1\\<rbrakk>\n    \\<Longrightarrow> mod_arr j \\<le> mod_arr i", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> m - 1", "have \"bounded m r\\<^sub>0 i\""], ["proof (prove)\nusing this:\n  i \\<noteq> m - 1\n\ngoal (1 subgoal):\n 1. bounded m r\\<^sub>0 i", "using assms(6)"], ["proof (prove)\nusing this:\n  i \\<noteq> m - 1\n  bounded (m - 1) r\\<^sub>0 i\n\ngoal (1 subgoal):\n 1. bounded m r\\<^sub>0 i", "by simp"], ["proof (state)\nthis:\n  bounded m r\\<^sub>0 i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mod_arr j \\<in># arr_mset arr m r\\<^sub>0;\n     i \\<noteq> m - 1\\<rbrakk>\n    \\<Longrightarrow> mod_arr j \\<le> mod_arr i", "then"], ["proof (chain)\npicking this:\n  bounded m r\\<^sub>0 i", "show ?thesis"], ["proof (prove)\nusing this:\n  bounded m r\\<^sub>0 i\n\ngoal (1 subgoal):\n 1. mod_arr j \\<le> mod_arr i", "using assms(4, 8) eq_on_def j_stricter_bound second_half_eq"], ["proof (prove)\nusing this:\n  bounded m r\\<^sub>0 i\n  \\<forall>i j.\n     bounded m r\\<^sub>0 i \\<longrightarrow>\n     bounded m r\\<^sub>0 j \\<longrightarrow>\n     i < j \\<longrightarrow> arr j \\<le> arr i\n  i < j\n  (?s = ?t on ?X) = (\\<forall>x\\<in>?X. ?s x = ?t x)\n  bounded m r\\<^sub>0 j\n  mod_arr = arr on {m..<r\\<^sub>0}\n\ngoal (1 subgoal):\n 1. mod_arr j \\<le> mod_arr i", "by force"], ["proof (state)\nthis:\n  mod_arr j \\<le> mod_arr i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mod_arr j \\<le> mod_arr i\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The following lemma shows that all elements in the first part of the array (the binary heap) \n      are bigger than the elements in the second part (the sorted part) after every iteration. This \n      lemma and the invariant of the \\<open>heap_sort\\<close> loop use \\<open>\\<not> x < y\\<close> instead of \\<open>x \\<ge> y\\<close> since \n      \\<open>vcg_cs\\<close> doesn't terminate in the latter case.\\<close>"], ["", "lemma heap_sort_fst_part_bigger_snd_part_step:\n  fixes arr::\"int \\<Rightarrow> int\" \n  assumes\n    \"l\\<^sub>0 < m\"\n    \"m \\<le> r\\<^sub>0\"\n    \"arr_mset arr' l\\<^sub>0 (m - 1) = arr_mset arr l\\<^sub>0 m - {#Min_mset (arr_mset arr l\\<^sub>0 m)#}\"\n    \"arr = arr' on - {l\\<^sub>0..<m}\"\n    \"\\<forall>x\\<in>#arr_mset arr l\\<^sub>0 m. \\<forall>y\\<in>#arr_mset arr m r\\<^sub>0. \\<not> x < y\"\n    \"mod_arr = arr'(m - 1 := Min_mset (arr_mset arr l\\<^sub>0 m))\"\n    \"x\\<in>#arr_mset mod_arr l\\<^sub>0 (m - 1)\"\n    \"y\\<in>#arr_mset mod_arr (m - 1) r\\<^sub>0\"\n  shows \"\\<not> x < y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x < y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x < y", "have \"{m..<r\\<^sub>0} \\<subseteq> - {l\\<^sub>0..<m}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {m..<r\\<^sub>0} \\<subseteq> - {l\\<^sub>0..<m}", "by auto"], ["proof (state)\nthis:\n  {m..<r\\<^sub>0} \\<subseteq> - {l\\<^sub>0..<m}\n\ngoal (1 subgoal):\n 1. \\<not> x < y", "hence \"arr' = arr on {m..<r\\<^sub>0}\""], ["proof (prove)\nusing this:\n  {m..<r\\<^sub>0} \\<subseteq> - {l\\<^sub>0..<m}\n\ngoal (1 subgoal):\n 1. arr' = arr on {m..<r\\<^sub>0}", "using assms(4) eq_on_sym eq_on_subset"], ["proof (prove)\nusing this:\n  {m..<r\\<^sub>0} \\<subseteq> - {l\\<^sub>0..<m}\n  arr = arr' on - {l\\<^sub>0..<m}\n  ?s = ?t on ?X \\<Longrightarrow> ?t = ?s on ?X\n  \\<lbrakk>?arr1.0 = ?arr2.0 on ?R; ?S \\<subseteq> ?R\\<rbrakk>\n  \\<Longrightarrow> ?arr1.0 = ?arr2.0 on ?S\n\ngoal (1 subgoal):\n 1. arr' = arr on {m..<r\\<^sub>0}", "by blast"], ["proof (state)\nthis:\n  arr' = arr on {m..<r\\<^sub>0}\n\ngoal (1 subgoal):\n 1. \\<not> x < y", "hence arr_eq_on: \"mod_arr = arr on {m..<r\\<^sub>0}\""], ["proof (prove)\nusing this:\n  arr' = arr on {m..<r\\<^sub>0}\n\ngoal (1 subgoal):\n 1. mod_arr = arr on {m..<r\\<^sub>0}", "by (simp add: assms(6))"], ["proof (state)\nthis:\n  mod_arr = arr on {m..<r\\<^sub>0}\n\ngoal (1 subgoal):\n 1. \\<not> x < y", "hence same_mset: \"arr_mset mod_arr m r\\<^sub>0 = arr_mset arr m r\\<^sub>0\""], ["proof (prove)\nusing this:\n  mod_arr = arr on {m..<r\\<^sub>0}\n\ngoal (1 subgoal):\n 1. arr_mset mod_arr m r\\<^sub>0 = arr_mset arr m r\\<^sub>0", "using mset_ran_cong"], ["proof (prove)\nusing this:\n  mod_arr = arr on {m..<r\\<^sub>0}\n  ?a = ?b on ?r \\<Longrightarrow> mset_ran ?a ?r = mset_ran ?b ?r\n\ngoal (1 subgoal):\n 1. arr_mset mod_arr m r\\<^sub>0 = arr_mset arr m r\\<^sub>0", "by blast"], ["proof (state)\nthis:\n  arr_mset mod_arr m r\\<^sub>0 = arr_mset arr m r\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<not> x < y", "have \"x \\<in># arr_mset arr l\\<^sub>0 m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in># arr_mset arr l\\<^sub>0 m", "using same_mset assms"], ["proof (prove)\nusing this:\n  arr_mset mod_arr m r\\<^sub>0 = arr_mset arr m r\\<^sub>0\n  l\\<^sub>0 < m\n  m \\<le> r\\<^sub>0\n  arr_mset arr' l\\<^sub>0 (m - 1) =\n  arr_mset arr l\\<^sub>0 m - {#Min_mset (arr_mset arr l\\<^sub>0 m)#}\n  arr = arr' on - {l\\<^sub>0..<m}\n  \\<forall>x\\<in>#arr_mset arr l\\<^sub>0 m.\n     \\<forall>y\\<in>#arr_mset arr m r\\<^sub>0. \\<not> x < y\n  mod_arr = arr'(m - 1 := Min_mset (arr_mset arr l\\<^sub>0 m))\n  x \\<in># arr_mset mod_arr l\\<^sub>0 (m - 1)\n  y \\<in># arr_mset mod_arr (m - 1) r\\<^sub>0\n\ngoal (1 subgoal):\n 1. x \\<in># arr_mset arr l\\<^sub>0 m", "by (metis assms(3,6,7) add_mset_remove_trivial_eq lran_upd_outside(2)\n        mset_lran cancel_ab_semigroup_add_class.diff_right_commute\n        diff_single_trivial multi_self_add_other_not_self order_refl)"], ["proof (state)\nthis:\n  x \\<in># arr_mset arr l\\<^sub>0 m\n\ngoal (1 subgoal):\n 1. \\<not> x < y", "then"], ["proof (chain)\npicking this:\n  x \\<in># arr_mset arr l\\<^sub>0 m", "have x_bigger_min: \"x \\<ge> Min_mset (arr_mset arr l\\<^sub>0 m)\""], ["proof (prove)\nusing this:\n  x \\<in># arr_mset arr l\\<^sub>0 m\n\ngoal (1 subgoal):\n 1. Min_mset (arr_mset arr l\\<^sub>0 m) \\<le> x", "using Min_le"], ["proof (prove)\nusing this:\n  x \\<in># arr_mset arr l\\<^sub>0 m\n  \\<lbrakk>finite ?A; ?x \\<in> ?A\\<rbrakk> \\<Longrightarrow> Min ?A \\<le> ?x\n\ngoal (1 subgoal):\n 1. Min_mset (arr_mset arr l\\<^sub>0 m) \\<le> x", "by blast"], ["proof (state)\nthis:\n  Min_mset (arr_mset arr l\\<^sub>0 m) \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> x < y", "have y_smaller_min: \"y \\<le> Min_mset (arr_mset arr l\\<^sub>0 m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> Min_mset (arr_mset arr l\\<^sub>0 m)", "proof(cases \"y = mod_arr (m - 1)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y = mod_arr (m - 1) \\<Longrightarrow>\n    y \\<le> Min_mset (arr_mset arr l\\<^sub>0 m)\n 2. y \\<noteq> mod_arr (m - 1) \\<Longrightarrow>\n    y \\<le> Min_mset (arr_mset arr l\\<^sub>0 m)", "case False"], ["proof (state)\nthis:\n  y \\<noteq> mod_arr (m - 1)\n\ngoal (2 subgoals):\n 1. y = mod_arr (m - 1) \\<Longrightarrow>\n    y \\<le> Min_mset (arr_mset arr l\\<^sub>0 m)\n 2. y \\<noteq> mod_arr (m - 1) \\<Longrightarrow>\n    y \\<le> Min_mset (arr_mset arr l\\<^sub>0 m)", "hence \"y\\<in>#arr_mset mod_arr (m - 1) r\\<^sub>0 - {#mod_arr (m - 1)#}\""], ["proof (prove)\nusing this:\n  y \\<noteq> mod_arr (m - 1)\n\ngoal (1 subgoal):\n 1. y \\<in># arr_mset mod_arr (m - 1) r\\<^sub>0 - {#mod_arr (m - 1)#}", "by (metis assms(8) diff_single_trivial insert_DiffM insert_noteq_member)"], ["proof (state)\nthis:\n  y \\<in># arr_mset mod_arr (m - 1) r\\<^sub>0 - {#mod_arr (m - 1)#}\n\ngoal (2 subgoals):\n 1. y = mod_arr (m - 1) \\<Longrightarrow>\n    y \\<le> Min_mset (arr_mset arr l\\<^sub>0 m)\n 2. y \\<noteq> mod_arr (m - 1) \\<Longrightarrow>\n    y \\<le> Min_mset (arr_mset arr l\\<^sub>0 m)", "then"], ["proof (chain)\npicking this:\n  y \\<in># arr_mset mod_arr (m - 1) r\\<^sub>0 - {#mod_arr (m - 1)#}", "have \"y\\<in>#arr_mset arr m r\\<^sub>0\""], ["proof (prove)\nusing this:\n  y \\<in># arr_mset mod_arr (m - 1) r\\<^sub>0 - {#mod_arr (m - 1)#}\n\ngoal (1 subgoal):\n 1. y \\<in># arr_mset arr m r\\<^sub>0", "by (simp add: assms(2) intvs_decr_l mset_ran_insert same_mset)"], ["proof (state)\nthis:\n  y \\<in># arr_mset arr m r\\<^sub>0\n\ngoal (2 subgoals):\n 1. y = mod_arr (m - 1) \\<Longrightarrow>\n    y \\<le> Min_mset (arr_mset arr l\\<^sub>0 m)\n 2. y \\<noteq> mod_arr (m - 1) \\<Longrightarrow>\n    y \\<le> Min_mset (arr_mset arr l\\<^sub>0 m)", "then"], ["proof (chain)\npicking this:\n  y \\<in># arr_mset arr m r\\<^sub>0", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<in># arr_mset arr m r\\<^sub>0\n\ngoal (1 subgoal):\n 1. y \\<le> Min_mset (arr_mset arr l\\<^sub>0 m)", "using assms(1) assms(5)"], ["proof (prove)\nusing this:\n  y \\<in># arr_mset arr m r\\<^sub>0\n  l\\<^sub>0 < m\n  \\<forall>x\\<in>#arr_mset arr l\\<^sub>0 m.\n     \\<forall>y\\<in>#arr_mset arr m r\\<^sub>0. \\<not> x < y\n\ngoal (1 subgoal):\n 1. y \\<le> Min_mset (arr_mset arr l\\<^sub>0 m)", "by fastforce"], ["proof (state)\nthis:\n  y \\<le> Min_mset (arr_mset arr l\\<^sub>0 m)\n\ngoal (1 subgoal):\n 1. y = mod_arr (m - 1) \\<Longrightarrow>\n    y \\<le> Min_mset (arr_mset arr l\\<^sub>0 m)", "qed (simp add: assms(6))"], ["proof (state)\nthis:\n  y \\<le> Min_mset (arr_mset arr l\\<^sub>0 m)\n\ngoal (1 subgoal):\n 1. \\<not> x < y", "then"], ["proof (chain)\npicking this:\n  y \\<le> Min_mset (arr_mset arr l\\<^sub>0 m)", "show ?thesis"], ["proof (prove)\nusing this:\n  y \\<le> Min_mset (arr_mset arr l\\<^sub>0 m)\n\ngoal (1 subgoal):\n 1. \\<not> x < y", "using x_bigger_min"], ["proof (prove)\nusing this:\n  y \\<le> Min_mset (arr_mset arr l\\<^sub>0 m)\n  Min_mset (arr_mset arr l\\<^sub>0 m) \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> x < y", "by linarith"], ["proof (state)\nthis:\n  \\<not> x < y\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Implementation\\<close>"], ["", "text \\<open>Now finally the correctness of the \\<open>heap_sort\\<close> is shown. As mentioned, it starts by \n      transforming the array into a minimum heap using @{const \"make_heap\"}. Then in each \n      iteration it removes the first element from the heap with @{const \"del_min\"} after its value \n      was retrieved with @{const \"get_min\"}. This value is then put at the position freed by \n      @{const \"del_min\"}.\\<close>"], ["", "program_spec heap_sort\n  assumes \"l \\<le> r\"  \n    ensures \"array_is_sorted (\\<ge>) arr l\\<^sub>0 r\\<^sub>0 \\<and> \n             arr_mset arr\\<^sub>0 l\\<^sub>0 r\\<^sub>0 = arr_mset arr l\\<^sub>0 r\\<^sub>0 \\<and> \n             arr\\<^sub>0 = arr on - {l\\<^sub>0 ..<r\\<^sub>0 } \\<and> l = l\\<^sub>0 \\<and> r = r\\<^sub>0\"\n  for l r arr[]\n  defines \\<open>\n    arr = make_heap(arr, l, r);\n    m = r;\n    while (m > l)\n      @variant \\<open>m - l + 1\\<close> \n      @invariant \\<open>is_heap (\\<le>) arr l m \\<and>\n        array_is_sorted (\\<ge>) arr m r\\<^sub>0 \\<and>\n        (\\<forall>x \\<in># arr_mset arr l\\<^sub>0 m. \\<forall>y \\<in># arr_mset arr m r\\<^sub>0. \\<not> x < y) \\<and>\n        arr_mset arr\\<^sub>0 l\\<^sub>0 r\\<^sub>0 = arr_mset arr l\\<^sub>0 r\\<^sub>0 \\<and> \n        l \\<le> m \\<and> m \\<le> r\\<^sub>0 \\<and> l = l\\<^sub>0 \\<and> arr\\<^sub>0 = arr on - {l\\<^sub>0 ..<r\\<^sub>0}\\<close>\n    {\n      min = get_min(arr, l, m);\n      (arr, l, m) = del_min(arr, l, m);\n      arr[m] = min \n    }\n  \\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. HT' Map.empty\n     (\\<lambda>\\<ss>.\n         VAR (\\<ss> ''r'' 0)\n          (\\<lambda>r.\n              VAR (\\<ss> ''l'' 0) (\\<lambda>l. BB_PROTECT (l \\<le> r))))\n     (\\<lambda>\\<ss>\\<^sub>0.\n         (''G_par_1''[] ::= ''arr'';; ''G_par_2''[] ::= ''l'';;\n          ''G_par_3''[] ::= ''r'';; Params make_heap;;\n          ArrayCpy_retv ''arr'' ''G_ret_1'');;\n         ''m''[] ::= ''r'';;\n         WHILE {ANNOTATION\n                 (\\<lambda>\\<ss>.\n                     VAR (\\<ss> ''m'' 0)\n                      (\\<lambda>m.\n                          VAR (\\<ss> ''l'' 0)\n                           (\\<lambda>l.\n                               BB_PROTECT\n                                (m - l +\n                                 1))))} {ANNOTATION\n    (\\<lambda>\\<ss>.\n        VAR (\\<ss> ''arr'')\n         (\\<lambda>arr.\n             VAR (\\<ss> ''m'' 0)\n              (\\<lambda>m.\n                  VAR (\\<ss> ''l'' 0)\n                   (\\<lambda>l.\n                       VAR (\\<ss>\\<^sub>0 ''arr'')\n                        (\\<lambda>arr\\<^sub>0.\n                            VAR (\\<ss>\\<^sub>0 ''r'' 0)\n                             (\\<lambda>r\\<^sub>0.\n                                 VAR (\\<ss>\\<^sub>0 ''l'' 0)\n                                  (\\<lambda>l\\<^sub>0.\nBB_PROTECT\n (is_heap (\\<le>) arr l m \\<and>\n  array_is_sorted (\\<lambda>x y. y \\<le> x) arr m r\\<^sub>0 \\<and>\n  (\\<forall>x\\<in>#arr_mset arr l\\<^sub>0 m.\n      \\<forall>y\\<in>#arr_mset arr m r\\<^sub>0. \\<not> x < y) \\<and>\n  arr_mset arr\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n  arr_mset arr l\\<^sub>0 r\\<^sub>0 \\<and>\n  l \\<le> m \\<and>\n  m \\<le> r\\<^sub>0 \\<and>\n  l = l\\<^sub>0 \\<and>\n  arr\\<^sub>0 = arr on - {l\\<^sub>0..<r\\<^sub>0}))))))))} Cmpop\n                     (\\<lambda>x y. y < x) (V ''m'') (V ''l'')\n         DO ((''G_par_1''[] ::= ''arr'';; ''G_par_2''[] ::= ''l'';;\n              ''G_par_3''[] ::= ''m'';; Params get_min;;\n              ArrayCpy_retv ''min'' ''G_ret_1'');;\n             (''G_par_1''[] ::= ''arr'';; ''G_par_2''[] ::= ''l'';;\n              ''G_par_3''[] ::= ''m'';; Params del_min;;\n              ArrayCpy_retv ''arr'' ''G_ret_1'';;\n              ArrayCpy_retv ''l'' ''G_ret_2'';;\n              ArrayCpy_retv ''m'' ''G_ret_3'');;\n             ''arr''[V ''m''] ::= V ''min''))\n     (\\<lambda>\\<ss>\\<^sub>0 \\<ss>.\n         VAR (\\<ss> ''arr'')\n          (\\<lambda>arr.\n              VAR (\\<ss> ''r'' 0)\n               (\\<lambda>r.\n                   VAR (\\<ss> ''l'' 0)\n                    (\\<lambda>l.\n                        VAR (\\<ss>\\<^sub>0 ''arr'')\n                         (\\<lambda>arr\\<^sub>0.\n                             VAR (\\<ss>\\<^sub>0 ''r'' 0)\n                              (\\<lambda>r\\<^sub>0.\n                                  VAR (\\<ss>\\<^sub>0 ''l'' 0)\n                                   (\\<lambda>l\\<^sub>0.\n BB_PROTECT\n  (array_is_sorted (\\<lambda>x y. y \\<le> x) arr l\\<^sub>0 r\\<^sub>0 \\<and>\n   arr_mset arr\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n   arr_mset arr l\\<^sub>0 r\\<^sub>0 \\<and>\n   arr\\<^sub>0 = arr on - {l\\<^sub>0..<r\\<^sub>0} \\<and>\n   l = l\\<^sub>0 \\<and> r = r\\<^sub>0))))))))", "apply vcg_cs"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r\\<^sub>0 l\\<^sub>0 arr\\<^sub>0 arr'.\n       \\<lbrakk>\\<paragraph>''invar-initial''; l\\<^sub>0 \\<le> r\\<^sub>0;\n        is_heap (\\<le>) arr' l\\<^sub>0 r\\<^sub>0;\n        arr_mset arr' l\\<^sub>0 r\\<^sub>0 =\n        arr_mset arr\\<^sub>0 l\\<^sub>0 r\\<^sub>0;\n        arr\\<^sub>0 = arr' on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> array_is_sorted (\\<lambda>x y. y \\<le> x) arr'\n                          r\\<^sub>0 r\\<^sub>0\n 2. \\<And>r\\<^sub>0 l\\<^sub>0 arr\\<^sub>0 arr' m arr arr'b.\n       \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0 < m;\n        is_heap (\\<le>) arr' l\\<^sub>0 r\\<^sub>0;\n        is_heap (\\<le>) arr l\\<^sub>0 m;\n        is_heap (\\<le>) arr'b l\\<^sub>0 (m - 1);\n        arr_mset arr' l\\<^sub>0 r\\<^sub>0 =\n        arr_mset arr l\\<^sub>0 r\\<^sub>0;\n        arr\\<^sub>0 = arr' on - {l\\<^sub>0..<r\\<^sub>0};\n        array_is_sorted (\\<lambda>x y. y \\<le> x) arr m r\\<^sub>0;\n        arr_mset arr'b l\\<^sub>0 (m - 1) =\n        arr_mset arr l\\<^sub>0 m - {#Min_mset (arr_mset arr l\\<^sub>0 m)#};\n        arr = arr'b on - {l\\<^sub>0..<m};\n        \\<forall>x\\<in>#arr_mset arr l\\<^sub>0 m.\n           \\<forall>y\\<in>#arr_mset arr m r\\<^sub>0. \\<not> x < y;\n        arr_mset arr\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset arr l\\<^sub>0 r\\<^sub>0;\n        m \\<le> r\\<^sub>0;\n        arr\\<^sub>0 = arr on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_heap (\\<le>)\n                          (arr'b\n                           (m - 1 := Min_mset (arr_mset arr l\\<^sub>0 m)))\n                          l\\<^sub>0 (m - 1) \\<and>\n                         array_is_sorted (\\<lambda>x y. y \\<le> x)\n                          (arr'b\n                           (m - 1 := Min_mset (arr_mset arr l\\<^sub>0 m)))\n                          (m - 1) r\\<^sub>0 \\<and>\n                         (\\<forall>x\\<in>#arr_mset\n     (arr'b(m - 1 := Min_mset (arr_mset arr l\\<^sub>0 m))) l\\<^sub>0\n     (m - 1).\n                             \\<forall>y\\<in>#arr_mset\n        (arr'b(m - 1 := Min_mset (arr_mset arr l\\<^sub>0 m))) (m - 1)\n        r\\<^sub>0.\n                                \\<not> x < y) \\<and>\n                         arr_mset arr l\\<^sub>0 r\\<^sub>0 =\n                         arr_mset\n                          (arr'b\n                           (m - 1 := Min_mset (arr_mset arr l\\<^sub>0 m)))\n                          l\\<^sub>0 r\\<^sub>0 \\<and>\n                         arr\\<^sub>0 = arr'b on - {l\\<^sub>0..<r\\<^sub>0}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''invar-initial''; l\\<^sub>0_ \\<le> r\\<^sub>0_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> array_is_sorted (\\<lambda>x y. y \\<le> x) arr'_\n                       r\\<^sub>0_ r\\<^sub>0_", "unfolding array_is_sorted_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''invar-initial''; l\\<^sub>0_ \\<le> r\\<^sub>0_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i j.\n                         bounded r\\<^sub>0_ r\\<^sub>0_ i \\<longrightarrow>\n                         bounded r\\<^sub>0_ r\\<^sub>0_ j \\<longrightarrow>\n                         i < j \\<longrightarrow> arr'_ j \\<le> arr'_ i", "by simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r\\<^sub>0 l\\<^sub>0 arr\\<^sub>0 arr' m arr arr'b.\n       \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0 < m;\n        is_heap (\\<le>) arr' l\\<^sub>0 r\\<^sub>0;\n        is_heap (\\<le>) arr l\\<^sub>0 m;\n        is_heap (\\<le>) arr'b l\\<^sub>0 (m - 1);\n        arr_mset arr' l\\<^sub>0 r\\<^sub>0 =\n        arr_mset arr l\\<^sub>0 r\\<^sub>0;\n        arr\\<^sub>0 = arr' on - {l\\<^sub>0..<r\\<^sub>0};\n        array_is_sorted (\\<lambda>x y. y \\<le> x) arr m r\\<^sub>0;\n        arr_mset arr'b l\\<^sub>0 (m - 1) =\n        arr_mset arr l\\<^sub>0 m - {#Min_mset (arr_mset arr l\\<^sub>0 m)#};\n        arr = arr'b on - {l\\<^sub>0..<m};\n        \\<forall>x\\<in>#arr_mset arr l\\<^sub>0 m.\n           \\<forall>y\\<in>#arr_mset arr m r\\<^sub>0. \\<not> x < y;\n        arr_mset arr\\<^sub>0 l\\<^sub>0 r\\<^sub>0 =\n        arr_mset arr l\\<^sub>0 r\\<^sub>0;\n        m \\<le> r\\<^sub>0;\n        arr\\<^sub>0 = arr on - {l\\<^sub>0..<r\\<^sub>0}\\<rbrakk>\n       \\<Longrightarrow> is_heap (\\<le>)\n                          (arr'b\n                           (m - 1 := Min_mset (arr_mset arr l\\<^sub>0 m)))\n                          l\\<^sub>0 (m - 1) \\<and>\n                         array_is_sorted (\\<lambda>x y. y \\<le> x)\n                          (arr'b\n                           (m - 1 := Min_mset (arr_mset arr l\\<^sub>0 m)))\n                          (m - 1) r\\<^sub>0 \\<and>\n                         (\\<forall>x\\<in>#arr_mset\n     (arr'b(m - 1 := Min_mset (arr_mset arr l\\<^sub>0 m))) l\\<^sub>0\n     (m - 1).\n                             \\<forall>y\\<in>#arr_mset\n        (arr'b(m - 1 := Min_mset (arr_mset arr l\\<^sub>0 m))) (m - 1)\n        r\\<^sub>0.\n                                \\<not> x < y) \\<and>\n                         arr_mset arr l\\<^sub>0 r\\<^sub>0 =\n                         arr_mset\n                          (arr'b\n                           (m - 1 := Min_mset (arr_mset arr l\\<^sub>0 m)))\n                          l\\<^sub>0 r\\<^sub>0 \\<and>\n                         arr\\<^sub>0 = arr'b on - {l\\<^sub>0..<r\\<^sub>0}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> is_heap (\\<le>)\n                       (arr'b_\n                        (m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_)))\n                       l\\<^sub>0_ (m_ - 1) \\<and>\n                      array_is_sorted (\\<lambda>x y. y \\<le> x)\n                       (arr'b_\n                        (m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_)))\n                       (m_ - 1) r\\<^sub>0_ \\<and>\n                      (\\<forall>x\\<in>#arr_mset\n  (arr'b_(m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_))) l\\<^sub>0_\n  (m_ - 1).\n                          \\<forall>y\\<in>#arr_mset\n     (arr'b_(m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_))) (m_ - 1)\n     r\\<^sub>0_.\n                             \\<not> x < y) \\<and>\n                      arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_ =\n                      arr_mset\n                       (arr'b_\n                        (m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_)))\n                       l\\<^sub>0_ r\\<^sub>0_ \\<and>\n                      arr\\<^sub>0_ = arr'b_ on - {l\\<^sub>0_..<r\\<^sub>0_}", "apply(intro conjI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> is_heap (\\<le>)\n                       (arr'b_\n                        (m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_)))\n                       l\\<^sub>0_ (m_ - 1)\n 2. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> array_is_sorted (\\<lambda>x y. y \\<le> x)\n                       (arr'b_\n                        (m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_)))\n                       (m_ - 1) r\\<^sub>0_\n 3. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>#arr_mset\n (arr'b_(m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_))) l\\<^sub>0_\n (m_ - 1).\n                         \\<forall>y\\<in>#arr_mset\n    (arr'b_(m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_))) (m_ - 1)\n    r\\<^sub>0_.\n                            \\<not> x < y\n 4. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_ =\n                      arr_mset\n                       (arr'b_\n                        (m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_)))\n                       l\\<^sub>0_ r\\<^sub>0_\n 5. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> arr\\<^sub>0_ = arr'b_ on - {l\\<^sub>0_..<r\\<^sub>0_}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> is_heap (\\<le>)\n                       (arr'b_\n                        (m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_)))\n                       l\\<^sub>0_ (m_ - 1)", "unfolding is_partial_heap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     \\<forall>x.\n        bounded l\\<^sub>0_ r\\<^sub>0_ x \\<longrightarrow>\n        bounded l\\<^sub>0_ r\\<^sub>0_\n         (parent l\\<^sub>0_ x) \\<longrightarrow>\n        arr'_ (parent l\\<^sub>0_ x) \\<le> arr'_ x;\n     \\<forall>x.\n        bounded l\\<^sub>0_ m_ x \\<longrightarrow>\n        bounded l\\<^sub>0_ m_ (parent l\\<^sub>0_ x) \\<longrightarrow>\n        arr_ (parent l\\<^sub>0_ x) \\<le> arr_ x;\n     \\<forall>x.\n        bounded l\\<^sub>0_ (m_ - 1) x \\<longrightarrow>\n        bounded l\\<^sub>0_ (m_ - 1) (parent l\\<^sub>0_ x) \\<longrightarrow>\n        arr'b_ (parent l\\<^sub>0_ x) \\<le> arr'b_ x;\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x.\n                         bounded l\\<^sub>0_ (m_ - 1) x \\<longrightarrow>\n                         bounded l\\<^sub>0_ (m_ - 1)\n                          (parent l\\<^sub>0_ x) \\<longrightarrow>\n                         (arr'b_\n                          (m_ - 1 :=\n                             Min_mset (arr_mset arr_ l\\<^sub>0_ m_)))\n                          (parent l\\<^sub>0_ x)\n                         \\<le> (arr'b_\n                                (m_ - 1 :=\n                                   Min_mset (arr_mset arr_ l\\<^sub>0_ m_)))\n                                x", "by simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> array_is_sorted (\\<lambda>x y. y \\<le> x)\n                       (arr'b_\n                        (m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_)))\n                       (m_ - 1) r\\<^sub>0_\n 2. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>#arr_mset\n (arr'b_(m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_))) l\\<^sub>0_\n (m_ - 1).\n                         \\<forall>y\\<in>#arr_mset\n    (arr'b_(m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_))) (m_ - 1)\n    r\\<^sub>0_.\n                            \\<not> x < y\n 3. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_ =\n                      arr_mset\n                       (arr'b_\n                        (m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_)))\n                       l\\<^sub>0_ r\\<^sub>0_\n 4. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> arr\\<^sub>0_ = arr'b_ on - {l\\<^sub>0_..<r\\<^sub>0_}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> array_is_sorted (\\<lambda>x y. y \\<le> x)\n                       (arr'b_\n                        (m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_)))\n                       (m_ - 1) r\\<^sub>0_", "unfolding array_is_sorted_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     \\<forall>i j.\n        bounded m_ r\\<^sub>0_ i \\<longrightarrow>\n        bounded m_ r\\<^sub>0_ j \\<longrightarrow>\n        i < j \\<longrightarrow> arr_ j \\<le> arr_ i;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i j.\n                         bounded (m_ - 1) r\\<^sub>0_ i \\<longrightarrow>\n                         bounded (m_ - 1) r\\<^sub>0_ j \\<longrightarrow>\n                         i < j \\<longrightarrow>\n                         (arr'b_\n                          (m_ - 1 :=\n                             Min_mset (arr_mset arr_ l\\<^sub>0_ m_)))\n                          j\n                         \\<le> (arr'b_\n                                (m_ - 1 :=\n                                   Min_mset (arr_mset arr_ l\\<^sub>0_ m_)))\n                                i", "using heap_sort_second_half_sorted_step"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l\\<^sub>0 < ?m; ?m \\<le> ?r\\<^sub>0;\n   ?arr = ?arr' on - {?l\\<^sub>0..<?m};\n   \\<forall>i j.\n      bounded ?m ?r\\<^sub>0 i \\<longrightarrow>\n      bounded ?m ?r\\<^sub>0 j \\<longrightarrow>\n      i < j \\<longrightarrow> ?arr j \\<le> ?arr i;\n   \\<forall>x\\<in>#arr_mset ?arr ?l\\<^sub>0 ?m.\n      \\<forall>y\\<in>#arr_mset ?arr ?m ?r\\<^sub>0. \\<not> x < y;\n   bounded (?m - 1) ?r\\<^sub>0 ?i; bounded (?m - 1) ?r\\<^sub>0 ?j; ?i < ?j;\n   ?mod_arr = ?arr'\n   (?m - 1 := Min_mset (arr_mset ?arr ?l\\<^sub>0 ?m))\\<rbrakk>\n  \\<Longrightarrow> ?mod_arr ?j \\<le> ?mod_arr ?i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     \\<forall>i j.\n        bounded m_ r\\<^sub>0_ i \\<longrightarrow>\n        bounded m_ r\\<^sub>0_ j \\<longrightarrow>\n        i < j \\<longrightarrow> arr_ j \\<le> arr_ i;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>i j.\n                         bounded (m_ - 1) r\\<^sub>0_ i \\<longrightarrow>\n                         bounded (m_ - 1) r\\<^sub>0_ j \\<longrightarrow>\n                         i < j \\<longrightarrow>\n                         (arr'b_\n                          (m_ - 1 :=\n                             Min_mset (arr_mset arr_ l\\<^sub>0_ m_)))\n                          j\n                         \\<le> (arr'b_\n                                (m_ - 1 :=\n                                   Min_mset (arr_mset arr_ l\\<^sub>0_ m_)))\n                                i", "by blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>#arr_mset\n (arr'b_(m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_))) l\\<^sub>0_\n (m_ - 1).\n                         \\<forall>y\\<in>#arr_mset\n    (arr'b_(m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_))) (m_ - 1)\n    r\\<^sub>0_.\n                            \\<not> x < y\n 2. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_ =\n                      arr_mset\n                       (arr'b_\n                        (m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_)))\n                       l\\<^sub>0_ r\\<^sub>0_\n 3. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> arr\\<^sub>0_ = arr'b_ on - {l\\<^sub>0_..<r\\<^sub>0_}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>#arr_mset\n (arr'b_(m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_))) l\\<^sub>0_\n (m_ - 1).\n                         \\<forall>y\\<in>#arr_mset\n    (arr'b_(m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_))) (m_ - 1)\n    r\\<^sub>0_.\n                            \\<not> x < y", "using heap_sort_fst_part_bigger_snd_part_step"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l\\<^sub>0 < ?m; ?m \\<le> ?r\\<^sub>0;\n   arr_mset ?arr' ?l\\<^sub>0 (?m - 1) =\n   arr_mset ?arr ?l\\<^sub>0 ?m - {#Min_mset (arr_mset ?arr ?l\\<^sub>0 ?m)#};\n   ?arr = ?arr' on - {?l\\<^sub>0..<?m};\n   \\<forall>x\\<in>#arr_mset ?arr ?l\\<^sub>0 ?m.\n      \\<forall>y\\<in>#arr_mset ?arr ?m ?r\\<^sub>0. \\<not> x < y;\n   ?mod_arr = ?arr'(?m - 1 := Min_mset (arr_mset ?arr ?l\\<^sub>0 ?m));\n   ?x \\<in># arr_mset ?mod_arr ?l\\<^sub>0 (?m - 1);\n   ?y \\<in># arr_mset ?mod_arr (?m - 1) ?r\\<^sub>0\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?x < ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>#arr_mset\n (arr'b_(m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_))) l\\<^sub>0_\n (m_ - 1).\n                         \\<forall>y\\<in>#arr_mset\n    (arr'b_(m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_))) (m_ - 1)\n    r\\<^sub>0_.\n                            \\<not> x < y", "by blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_ =\n                      arr_mset\n                       (arr'b_\n                        (m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_)))\n                       l\\<^sub>0_ r\\<^sub>0_\n 2. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> arr\\<^sub>0_ = arr'b_ on - {l\\<^sub>0_..<r\\<^sub>0_}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_ =\n                      arr_mset\n                       (arr'b_\n                        (m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_)))\n                       l\\<^sub>0_ r\\<^sub>0_", "using heap_sort_mset_step"], ["proof (prove)\nusing this:\n  \\<lbrakk>?l < ?m; ?m \\<le> ?r;\n   arr_mset ?arr' ?l (?m - 1) =\n   arr_mset ?arr ?l ?m - {#Min_mset (arr_mset ?arr ?l ?m)#};\n   ?arr = ?arr' on - {?l..<?m};\n   ?mod_arr = ?arr'(?m - 1 := Min_mset (arr_mset ?arr ?l ?m))\\<rbrakk>\n  \\<Longrightarrow> arr_mset ?arr ?l ?r = arr_mset ?mod_arr ?l ?r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_ =\n                      arr_mset\n                       (arr'b_\n                        (m_ - 1 := Min_mset (arr_mset arr_ l\\<^sub>0_ m_)))\n                       l\\<^sub>0_ r\\<^sub>0_", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> arr\\<^sub>0_ = arr'b_ on - {l\\<^sub>0_..<r\\<^sub>0_}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     arr\\<^sub>0_ = arr'_ on - {l\\<^sub>0_..<r\\<^sub>0_};\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     arr_ = arr'b_ on - {l\\<^sub>0_..<m_};\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     arr\\<^sub>0_ = arr_ on - {l\\<^sub>0_..<r\\<^sub>0_}\\<rbrakk>\n    \\<Longrightarrow> arr\\<^sub>0_ = arr'b_ on - {l\\<^sub>0_..<r\\<^sub>0_}", "unfolding eq_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<paragraph>''Invar pres''; l\\<^sub>0_ < m_;\n     is_heap (\\<le>) arr'_ l\\<^sub>0_ r\\<^sub>0_;\n     is_heap (\\<le>) arr_ l\\<^sub>0_ m_;\n     is_heap (\\<le>) arr'b_ l\\<^sub>0_ (m_ - 1);\n     arr_mset arr'_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     \\<forall>x\\<in>- {l\\<^sub>0_..<r\\<^sub>0_}. arr\\<^sub>0_ x = arr'_ x;\n     array_is_sorted (\\<lambda>x y. y \\<le> x) arr_ m_ r\\<^sub>0_;\n     arr_mset arr'b_ l\\<^sub>0_ (m_ - 1) =\n     arr_mset arr_ l\\<^sub>0_ m_ -\n     {#Min_mset (arr_mset arr_ l\\<^sub>0_ m_)#};\n     \\<forall>x\\<in>- {l\\<^sub>0_..<m_}. arr_ x = arr'b_ x;\n     \\<forall>x\\<in>#arr_mset arr_ l\\<^sub>0_ m_.\n        \\<forall>y\\<in>#arr_mset arr_ m_ r\\<^sub>0_. \\<not> x < y;\n     arr_mset arr\\<^sub>0_ l\\<^sub>0_ r\\<^sub>0_ =\n     arr_mset arr_ l\\<^sub>0_ r\\<^sub>0_;\n     m_ \\<le> r\\<^sub>0_;\n     \\<forall>x\\<in>- {l\\<^sub>0_..<r\\<^sub>0_}.\n        arr\\<^sub>0_ x = arr_ x\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>- {l\\<^sub>0_..<r\\<^sub>0_}.\n                         arr\\<^sub>0_ x = arr'b_ x", "by (metis ComplD ComplI atLeastLessThan_iff less_le_trans)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}