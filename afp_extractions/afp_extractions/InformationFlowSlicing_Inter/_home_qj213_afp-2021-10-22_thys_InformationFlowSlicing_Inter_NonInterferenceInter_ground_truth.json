{"file_name": "/home/qj213/afp-2021-10-22/thys/InformationFlowSlicing_Inter/NonInterferenceInter.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/InformationFlowSlicing_Inter", "problem_names": ["lemma Low_neq_Exit: assumes \"L \\<noteq> {}\" shows \"(_Low_) \\<noteq> (_Exit_)\"", "lemma valid_node_High [simp]:\"valid_node (_High_)\"", "lemma valid_node_Low [simp]:\"valid_node (_Low_)\"", "lemma get_proc_Low:\n  \"get_proc (_Low_) = Main\"", "lemma get_proc_High:\n  \"get_proc (_High_) = Main\"", "lemma Entry_path_High_path:\n  assumes \"(_Entry_) -as\\<rightarrow>* n\" and \"inner_node n\"\n  obtains a' as' where \"as = a'#as'\" and \"(_High_) -as'\\<rightarrow>* n\" \n  and \"kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\"", "lemma Exit_path_Low_path:\n  assumes \"n -as\\<rightarrow>* (_Exit_)\" and \"inner_node n\"\n  obtains a' as' where \"as = as'@[a']\" and \"n -as'\\<rightarrow>* (_Low_)\"\n  and \"kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\"", "lemma not_Low_High: \"V \\<notin> L \\<Longrightarrow> V \\<in> H\"", "lemma not_High_Low: \"V \\<notin> H \\<Longrightarrow> V \\<in> L\"", "lemma relevant_vars_Entry:\n  assumes \"V \\<in> rv S (CFG_node (_Entry_))\" and \"(_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  shows \"V \\<in> L\"", "lemma lowEquivalence_relevant_nodes_Entry:\n  assumes \"s \\<approx>\\<^sub>L s'\" and \"(_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  shows \"\\<forall>V \\<in> rv S (CFG_node (_Entry_)). hd s V = hd s' V\"", "lemma slpa_rv_Low_Use_Low:\n  assumes \"CFG_node (_Low_) \\<in> S\"\n  shows \"\\<lbrakk>same_level_path_aux cs as; upd_cs cs as = []; same_level_path_aux cs as';\n    \\<forall>c \\<in> set cs. valid_edge c; m -as\\<rightarrow>* (_Low_); m -as'\\<rightarrow>* (_Low_);\n   \\<forall>i < length cs. \\<forall>V \\<in> rv S (CFG_node (sourcenode (cs!i))). \n    fst (s!Suc i) V = fst (s'!Suc i) V; \\<forall>i < Suc (length cs). snd (s!i) = snd (s'!i);\n   \\<forall>V \\<in> rv S (CFG_node m). state_val s V = state_val s' V;\n   preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n   length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n   \\<Longrightarrow> \\<forall>V \\<in> Use (_Low_). state_val (transfers(slice_kinds S as) s) V =\n                      state_val (transfers(slice_kinds S as') s') V\"", "lemma rv_Low_Use_Low:\n  assumes \"m -as\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\" and \"m -as'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\" and \"get_proc m = Main\"\n  and \"\\<forall>V \\<in> rv S (CFG_node m). cf V = cf' V\"\n  and \"preds (slice_kinds S as) [(cf,undefined)]\"\n  and \"preds (slice_kinds S as') [(cf',undefined)]\"\n  and \"CFG_node (_Low_) \\<in> S\"\n  shows \"\\<forall>V \\<in> Use (_Low_). \n    state_val (transfers(slice_kinds S as) [(cf,undefined)]) V =\n    state_val (transfers(slice_kinds S as') [(cf',undefined)]) V\"", "lemma nonInterference_path_to_Low:\n  assumes \"[cf] \\<approx>\\<^sub>L [cf']\" and \"(_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  and \"CFG_node (_Low_) \\<in> S\"\n  and \"(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\" and \"preds (kinds as) [(cf,undefined)]\"\n  and \"(_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\" and \"preds (kinds as') [(cf',undefined)]\"\n  shows \"map fst (transfers (kinds as) [(cf,undefined)]) \\<approx>\\<^sub>L \n         map fst (transfers (kinds as') [(cf',undefined)])\"", "theorem nonInterference_path:\n  assumes \"[cf] \\<approx>\\<^sub>L [cf']\" and \"(_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  and \"CFG_node (_Low_) \\<in> S\"\n  and \"(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\" and \"preds (kinds as) [(cf,undefined)]\"\n  and \"(_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\" and \"preds (kinds as') [(cf',undefined)]\"\n  shows \"map fst (transfers (kinds as) [(cf,undefined)]) \\<approx>\\<^sub>L \n  map fst (transfers (kinds as') [(cf',undefined)])\"", "theorem nonInterference:\n  assumes \"[cf\\<^sub>1] \\<approx>\\<^sub>L [cf\\<^sub>2]\" and \"(_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  and \"CFG_node (_Low_) \\<in> S\"\n  and \"valid_edge a\" and \"sourcenode a = (_High_)\" and \"targetnode a = n\" \n  and \"kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\" and \"n \\<triangleq> c\" and \"final c'\"\n  and \"\\<langle>c,[cf\\<^sub>1]\\<rangle> \\<Rightarrow> \\<langle>c',s\\<^sub>1\\<rangle>\" and \"\\<langle>c,[cf\\<^sub>2]\\<rangle> \\<Rightarrow> \\<langle>c',s\\<^sub>2\\<rangle>\"\n  shows \"s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2\""], "translations": [["", "lemma Low_neq_Exit: assumes \"L \\<noteq> {}\" shows \"(_Low_) \\<noteq> (_Exit_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (_Low_) \\<noteq> (_Exit_)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (_Low_) = (_Exit_) \\<Longrightarrow> False", "assume \"(_Low_) = (_Exit_)\""], ["proof (state)\nthis:\n  (_Low_) = (_Exit_)\n\ngoal (1 subgoal):\n 1. (_Low_) = (_Exit_) \\<Longrightarrow> False", "have \"Use (_Exit_) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Use (_Exit_) = {}", "by fastforce"], ["proof (state)\nthis:\n  Use (_Exit_) = {}\n\ngoal (1 subgoal):\n 1. (_Low_) = (_Exit_) \\<Longrightarrow> False", "with UseLow \\<open>L \\<noteq> {}\\<close> \\<open>(_Low_) = (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  Use (_Low_) = L\n  L \\<noteq> {}\n  (_Low_) = (_Exit_)\n  Use (_Exit_) = {}", "show False"], ["proof (prove)\nusing this:\n  Use (_Low_) = L\n  L \\<noteq> {}\n  (_Low_) = (_Exit_)\n  Use (_Exit_) = {}\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_node_High [simp]:\"valid_node (_High_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_node (_High_)", "using High_target_Entry_edge"], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_High_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. valid_node (_High_)", "by fastforce"], ["", "lemma valid_node_Low [simp]:\"valid_node (_Low_)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_node (_Low_)", "using Low_source_Exit_edge"], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Low_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. valid_node (_Low_)", "by fastforce"], ["", "lemma get_proc_Low:\n  \"get_proc (_Low_) = Main\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_proc (_Low_) = Main", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. get_proc (_Low_) = Main", "from Low_source_Exit_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Low_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>", "obtain a where \"valid_edge a\"\n    and \"sourcenode a = (_Low_)\" and \"targetnode a = (_Exit_)\"\n    and \"intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Low_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge a; sourcenode a = (_Low_);\n         targetnode a = (_Exit_); intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a = (_Low_)\n  targetnode a = (_Exit_)\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. get_proc (_Low_) = Main", "from \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)", "have \"get_proc (sourcenode a) = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a)", "by(rule get_proc_intra)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. get_proc (_Low_) = Main", "with \\<open>sourcenode a = (_Low_)\\<close> \\<open>targetnode a = (_Exit_)\\<close> get_proc_Exit"], ["proof (chain)\npicking this:\n  sourcenode a = (_Low_)\n  targetnode a = (_Exit_)\n  get_proc (_Exit_) = Main\n  get_proc (sourcenode a) = get_proc (targetnode a)", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a = (_Low_)\n  targetnode a = (_Exit_)\n  get_proc (_Exit_) = Main\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. get_proc (_Low_) = Main", "by simp"], ["proof (state)\nthis:\n  get_proc (_Low_) = Main\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma get_proc_High:\n  \"get_proc (_High_) = Main\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_proc (_High_) = Main", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. get_proc (_High_) = Main", "from High_target_Entry_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_High_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>", "obtain a where \"valid_edge a\"\n    and \"sourcenode a = (_Entry_)\" and \"targetnode a = (_High_)\"\n    and \"intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_High_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge a; sourcenode a = (_Entry_);\n         targetnode a = (_High_); intra_kind (kind a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a = (_Entry_)\n  targetnode a = (_High_)\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. get_proc (_High_) = Main", "from \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)", "have \"get_proc (sourcenode a) = get_proc (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = get_proc (targetnode a)", "by(rule get_proc_intra)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. get_proc (_High_) = Main", "with \\<open>sourcenode a = (_Entry_)\\<close> \\<open>targetnode a = (_High_)\\<close> get_proc_Entry"], ["proof (chain)\npicking this:\n  sourcenode a = (_Entry_)\n  targetnode a = (_High_)\n  get_proc (_Entry_) = Main\n  get_proc (sourcenode a) = get_proc (targetnode a)", "show ?thesis"], ["proof (prove)\nusing this:\n  sourcenode a = (_Entry_)\n  targetnode a = (_High_)\n  get_proc (_Entry_) = Main\n  get_proc (sourcenode a) = get_proc (targetnode a)\n\ngoal (1 subgoal):\n 1. get_proc (_High_) = Main", "by simp"], ["proof (state)\nthis:\n  get_proc (_High_) = Main\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Entry_path_High_path:\n  assumes \"(_Entry_) -as\\<rightarrow>* n\" and \"inner_node n\"\n  obtains a' as' where \"as = a'#as'\" and \"(_High_) -as'\\<rightarrow>* n\" \n  and \"kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a' as'.\n        \\<lbrakk>as = a' # as'; (_High_) -as'\\<rightarrow>* n;\n         kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and>\n       (_High_) -as'\\<rightarrow>* n \\<and>\n       kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "from \\<open>(_Entry_) -as\\<rightarrow>* n\\<close> \\<open>inner_node n\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>* n\n  inner_node n", "show \"\\<exists>a' as'. as = a'#as' \\<and> (_High_) -as'\\<rightarrow>* n \\<and> kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>* n\n  inner_node n\n\ngoal (1 subgoal):\n 1. \\<exists>a' as'.\n       as = a' # as' \\<and>\n       (_High_) -as'\\<rightarrow>* n \\<and>\n       kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "proof(induct n'\\<equiv>\"(_Entry_)\" as n rule:path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (_Entry_); inner_node (_Entry_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a' as'.\n                         [] = a' # as' \\<and>\n                         (_High_) -as'\\<rightarrow>* (_Entry_) \\<and>\n                         kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<lbrakk>n'' = (_Entry_); inner_node n'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             (_High_) -as'\\<rightarrow>* n' \\<and>\n                             kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        valid_edge a; sourcenode a = (_Entry_); targetnode a = n'';\n        inner_node n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a' as'.\n                            a # as = a' # as' \\<and>\n                            (_High_) -as'\\<rightarrow>* n' \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "case (Cons_path n'' as n' a)"], ["proof (state)\nthis:\n  n'' -as\\<rightarrow>* n'\n  \\<lbrakk>n'' = (_Entry_); inner_node n'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a' as'.\n                       as = a' # as' \\<and>\n                       (_High_) -as'\\<rightarrow>* n' \\<and>\n                       kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n  valid_edge a\n  sourcenode a = (_Entry_)\n  targetnode a = n''\n  inner_node n'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (_Entry_); inner_node (_Entry_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a' as'.\n                         [] = a' # as' \\<and>\n                         (_High_) -as'\\<rightarrow>* (_Entry_) \\<and>\n                         kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<lbrakk>n'' = (_Entry_); inner_node n'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             (_High_) -as'\\<rightarrow>* n' \\<and>\n                             kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        valid_edge a; sourcenode a = (_Entry_); targetnode a = n'';\n        inner_node n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a' as'.\n                            a # as = a' # as' \\<and>\n                            (_High_) -as'\\<rightarrow>* n' \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "from \\<open>n'' -as\\<rightarrow>* n'\\<close> \\<open>inner_node n'\\<close>"], ["proof (chain)\npicking this:\n  n'' -as\\<rightarrow>* n'\n  inner_node n'", "have \"n'' \\<noteq> (_Exit_)\""], ["proof (prove)\nusing this:\n  n'' -as\\<rightarrow>* n'\n  inner_node n'\n\ngoal (1 subgoal):\n 1. n'' \\<noteq> (_Exit_)", "by(fastforce simp:inner_node_def)"], ["proof (state)\nthis:\n  n'' \\<noteq> (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (_Entry_); inner_node (_Entry_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a' as'.\n                         [] = a' # as' \\<and>\n                         (_High_) -as'\\<rightarrow>* (_Entry_) \\<and>\n                         kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<lbrakk>n'' = (_Entry_); inner_node n'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             (_High_) -as'\\<rightarrow>* n' \\<and>\n                             kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        valid_edge a; sourcenode a = (_Entry_); targetnode a = n'';\n        inner_node n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a' as'.\n                            a # as = a' # as' \\<and>\n                            (_High_) -as'\\<rightarrow>* n' \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>valid_edge a\\<close> \\<open>sourcenode a = (_Entry_)\\<close> \\<open>targetnode a = n''\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = (_Entry_)\n  targetnode a = n''\n  n'' \\<noteq> (_Exit_)", "have \"n'' = (_High_)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = (_Entry_)\n  targetnode a = n''\n  n'' \\<noteq> (_Exit_)\n\ngoal (1 subgoal):\n 1. n'' = (_High_)", "by -(drule Entry_edge_Exit_or_High,auto)"], ["proof (state)\nthis:\n  n'' = (_High_)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (_Entry_); inner_node (_Entry_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a' as'.\n                         [] = a' # as' \\<and>\n                         (_High_) -as'\\<rightarrow>* (_Entry_) \\<and>\n                         kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<lbrakk>n'' = (_Entry_); inner_node n'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             (_High_) -as'\\<rightarrow>* n' \\<and>\n                             kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        valid_edge a; sourcenode a = (_Entry_); targetnode a = n'';\n        inner_node n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a' as'.\n                            a # as = a' # as' \\<and>\n                            (_High_) -as'\\<rightarrow>* n' \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "from High_target_Entry_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_High_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>", "obtain a' where \"valid_edge a'\" and \"sourcenode a' = (_Entry_)\"\n      and \"targetnode a' = (_High_)\" and \"kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_High_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>valid_edge a'; sourcenode a' = (_Entry_);\n         targetnode a' = (_High_);\n         kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_edge a'\n  sourcenode a' = (_Entry_)\n  targetnode a' = (_High_)\n  kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (_Entry_); inner_node (_Entry_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a' as'.\n                         [] = a' # as' \\<and>\n                         (_High_) -as'\\<rightarrow>* (_Entry_) \\<and>\n                         kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<lbrakk>n'' = (_Entry_); inner_node n'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             (_High_) -as'\\<rightarrow>* n' \\<and>\n                             kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        valid_edge a; sourcenode a = (_Entry_); targetnode a = n'';\n        inner_node n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a' as'.\n                            a # as = a' # as' \\<and>\n                            (_High_) -as'\\<rightarrow>* n' \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>valid_edge a\\<close> \\<open>sourcenode a = (_Entry_)\\<close> \\<open>targetnode a = n''\\<close>\n      \\<open>n'' = (_High_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = (_Entry_)\n  targetnode a = n''\n  n'' = (_High_)\n  valid_edge a'\n  sourcenode a' = (_Entry_)\n  targetnode a' = (_High_)\n  kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "have \"a = a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = (_Entry_)\n  targetnode a = n''\n  n'' = (_High_)\n  valid_edge a'\n  sourcenode a' = (_Entry_)\n  targetnode a' = (_High_)\n  kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. a = a'", "by(auto dest:edge_det)"], ["proof (state)\nthis:\n  a = a'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (_Entry_); inner_node (_Entry_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a' as'.\n                         [] = a' # as' \\<and>\n                         (_High_) -as'\\<rightarrow>* (_Entry_) \\<and>\n                         kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>n'' as n' a.\n       \\<lbrakk>n'' -as\\<rightarrow>* n';\n        \\<lbrakk>n'' = (_Entry_); inner_node n'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a' as'.\n                             as = a' # as' \\<and>\n                             (_High_) -as'\\<rightarrow>* n' \\<and>\n                             kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        valid_edge a; sourcenode a = (_Entry_); targetnode a = n'';\n        inner_node n'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a' as'.\n                            a # as = a' # as' \\<and>\n                            (_High_) -as'\\<rightarrow>* n' \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>n'' -as\\<rightarrow>* n'\\<close> \\<open>n'' = (_High_)\\<close> \\<open>kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  n'' -as\\<rightarrow>* n'\n  n'' = (_High_)\n  kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n  a = a'", "show ?case"], ["proof (prove)\nusing this:\n  n'' -as\\<rightarrow>* n'\n  n'' = (_High_)\n  kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n  a = a'\n\ngoal (1 subgoal):\n 1. \\<exists>a' as'.\n       a # as = a' # as' \\<and>\n       (_High_) -as'\\<rightarrow>* n' \\<and>\n       kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "by blast"], ["proof (state)\nthis:\n  \\<exists>a' as'.\n     a # as = a' # as' \\<and>\n     (_High_) -as'\\<rightarrow>* n' \\<and>\n     kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node (_Entry_); inner_node (_Entry_)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a' as'.\n                         [] = a' # as' \\<and>\n                         (_High_) -as'\\<rightarrow>* (_Entry_) \\<and>\n                         kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "qed fastforce"], ["proof (state)\nthis:\n  \\<exists>a' as'.\n     as = a' # as' \\<and>\n     (_High_) -as'\\<rightarrow>* n \\<and>\n     kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Exit_path_Low_path:\n  assumes \"n -as\\<rightarrow>* (_Exit_)\" and \"inner_node n\"\n  obtains a' as' where \"as = as'@[a']\" and \"n -as'\\<rightarrow>* (_Low_)\"\n  and \"kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as' a'.\n        \\<lbrakk>as = as' @ [a']; n -as'\\<rightarrow>* (_Low_);\n         kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(atomize_elim)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as' a'.\n       as = as' @ [a'] \\<and>\n       n -as'\\<rightarrow>* (_Low_) \\<and>\n       kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "from \\<open>n -as\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<rightarrow>* (_Exit_)", "show \"\\<exists>as' a'. as = as'@[a'] \\<and> n -as'\\<rightarrow>* (_Low_) \\<and> kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  n -as\\<rightarrow>* (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>as' a'.\n       as = as' @ [a'] \\<and>\n       n -as'\\<rightarrow>* (_Low_) \\<and>\n       kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "proof(induct as rule:rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. n -[]\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n    \\<exists>as' a'.\n       [] = as' @ [a'] \\<and>\n       n -as'\\<rightarrow>* (_Low_) \\<and>\n       kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "case Nil"], ["proof (state)\nthis:\n  n -[]\\<rightarrow>* (_Exit_)\n\ngoal (2 subgoals):\n 1. n -[]\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n    \\<exists>as' a'.\n       [] = as' @ [a'] \\<and>\n       n -as'\\<rightarrow>* (_Low_) \\<and>\n       kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>inner_node n\\<close>"], ["proof (chain)\npicking this:\n  inner_node n\n  n -[]\\<rightarrow>* (_Exit_)", "show ?case"], ["proof (prove)\nusing this:\n  inner_node n\n  n -[]\\<rightarrow>* (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<exists>as' a'.\n       [] = as' @ [a'] \\<and>\n       n -as'\\<rightarrow>* (_Low_) \\<and>\n       kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as' a'.\n     [] = as' @ [a'] \\<and>\n     n -as'\\<rightarrow>* (_Low_) \\<and>\n     kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "case (snoc a' as')"], ["proof (state)\nthis:\n  n -as'\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n  \\<exists>as'a a'.\n     as' = as'a @ [a'] \\<and>\n     n -as'a\\<rightarrow>* (_Low_) \\<and>\n     kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n  n -as' @ [a']\\<rightarrow>* (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "from \\<open>n -as'@[a']\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  n -as' @ [a']\\<rightarrow>* (_Exit_)", "have \"n -as'\\<rightarrow>* sourcenode a'\" and \"valid_edge a'\" and \"targetnode a' = (_Exit_)\""], ["proof (prove)\nusing this:\n  n -as' @ [a']\\<rightarrow>* (_Exit_)\n\ngoal (1 subgoal):\n 1. n -as'\\<rightarrow>* sourcenode a' &&&\n    valid_edge a' &&& targetnode a' = (_Exit_)", "by(auto elim:path_split_snoc)"], ["proof (state)\nthis:\n  n -as'\\<rightarrow>* sourcenode a'\n  valid_edge a'\n  targetnode a' = (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "{"], ["proof (state)\nthis:\n  n -as'\\<rightarrow>* sourcenode a'\n  valid_edge a'\n  targetnode a' = (_Exit_)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "assume \"sourcenode a' = (_Entry_)\""], ["proof (state)\nthis:\n  sourcenode a' = (_Entry_)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>n -as'\\<rightarrow>* sourcenode a'\\<close>"], ["proof (chain)\npicking this:\n  n -as'\\<rightarrow>* sourcenode a'\n  sourcenode a' = (_Entry_)", "have \"n = (_Entry_)\""], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>* sourcenode a'\n  sourcenode a' = (_Entry_)\n\ngoal (1 subgoal):\n 1. n = (_Entry_)", "by(blast intro!:path_Entry_target)"], ["proof (state)\nthis:\n  n = (_Entry_)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>inner_node n\\<close>"], ["proof (chain)\npicking this:\n  inner_node n\n  n = (_Entry_)", "have False"], ["proof (prove)\nusing this:\n  inner_node n\n  n = (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by(simp add:inner_node_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "}"], ["proof (state)\nthis:\n  sourcenode a' = (_Entry_) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>valid_edge a'\\<close> \\<open>targetnode a' = (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  targetnode a' = (_Exit_)\n  sourcenode a' = (_Entry_) \\<Longrightarrow> False", "have \"sourcenode a' = (_Low_)\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  targetnode a' = (_Exit_)\n  sourcenode a' = (_Entry_) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. sourcenode a' = (_Low_)", "by(blast dest!:Exit_edge_Entry_or_Low)"], ["proof (state)\nthis:\n  sourcenode a' = (_Low_)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "from Low_source_Exit_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Low_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>", "obtain ax where \"valid_edge ax\" and \"sourcenode ax = (_Low_)\"\n      and \"targetnode ax = (_Exit_)\" and \"kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Low_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>ax.\n        \\<lbrakk>valid_edge ax; sourcenode ax = (_Low_);\n         targetnode ax = (_Exit_);\n         kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_edge ax\n  sourcenode ax = (_Low_)\n  targetnode ax = (_Exit_)\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>valid_edge a'\\<close> \\<open>targetnode a' = (_Exit_)\\<close> \\<open>sourcenode a' = (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  targetnode a' = (_Exit_)\n  sourcenode a' = (_Low_)\n  valid_edge ax\n  sourcenode ax = (_Low_)\n  targetnode ax = (_Exit_)\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>", "have \"a' = ax\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  targetnode a' = (_Exit_)\n  sourcenode a' = (_Low_)\n  valid_edge ax\n  sourcenode ax = (_Low_)\n  targetnode ax = (_Exit_)\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. a' = ax", "by(fastforce intro:edge_det)"], ["proof (state)\nthis:\n  a' = ax\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>n -xs\\<rightarrow>* (_Exit_) \\<Longrightarrow>\n                \\<exists>as' a'.\n                   xs = as' @ [a'] \\<and>\n                   n -as'\\<rightarrow>* (_Low_) \\<and>\n                   kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        n -xs @ [x]\\<rightarrow>* (_Exit_)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as' a'.\n                            xs @ [x] = as' @ [a'] \\<and>\n                            n -as'\\<rightarrow>* (_Low_) \\<and>\n                            kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>", "with \\<open>n -as'\\<rightarrow>* sourcenode a'\\<close> \\<open>sourcenode a' = (_Low_)\\<close> \\<open>kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  n -as'\\<rightarrow>* sourcenode a'\n  sourcenode a' = (_Low_)\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n  a' = ax", "show ?case"], ["proof (prove)\nusing this:\n  n -as'\\<rightarrow>* sourcenode a'\n  sourcenode a' = (_Low_)\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n  a' = ax\n\ngoal (1 subgoal):\n 1. \\<exists>as'a a'a.\n       as' @ [a'] = as'a @ [a'a] \\<and>\n       n -as'a\\<rightarrow>* (_Low_) \\<and>\n       kind a'a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'a a'a.\n     as' @ [a'] = as'a @ [a'a] \\<and>\n     n -as'a\\<rightarrow>* (_Low_) \\<and>\n     kind a'a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as' a'.\n     as = as' @ [a'] \\<and>\n     n -as'\\<rightarrow>* (_Low_) \\<and>\n     kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma not_Low_High: \"V \\<notin> L \\<Longrightarrow> V \\<in> H\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<notin> L \\<Longrightarrow> V \\<in> H", "using HighLowUNIV"], ["proof (prove)\nusing this:\n  H \\<union> L = UNIV\n\ngoal (1 subgoal):\n 1. V \\<notin> L \\<Longrightarrow> V \\<in> H", "by fastforce"], ["", "lemma not_High_Low: \"V \\<notin> H \\<Longrightarrow> V \\<in> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<notin> H \\<Longrightarrow> V \\<in> L", "using HighLowUNIV"], ["proof (prove)\nusing this:\n  H \\<union> L = UNIV\n\ngoal (1 subgoal):\n 1. V \\<notin> H \\<Longrightarrow> V \\<in> L", "by fastforce"], ["", "subsection \\<open>Low Equivalence\\<close>"], ["", "text \\<open>\nIn classical noninterference, an external observer can only see public values,\nin our case the \\<open>L\\<close>-variables. If two states agree in the values of all \n\\<open>L\\<close>-variables, these states are indistinguishable for him. \n\\emph{Low equivalence} groups those states in an equivalence class using \nthe relation \\<open>\\<approx>\\<^sub>L\\<close>:\n\\<close>"], ["", "definition lowEquivalence :: \"('var \\<rightharpoonup> 'val) list \\<Rightarrow> ('var \\<rightharpoonup> 'val) list \\<Rightarrow> bool\" \n(infixl \"\\<approx>\\<^sub>L\" 50)\n  where \"s \\<approx>\\<^sub>L s' \\<equiv> \\<forall>V \\<in> L. hd s V = hd s' V\""], ["", "text \\<open>The following lemmas connect low equivalent states with\nrelevant variables as necessary in the correctness proof for slicing.\\<close>"], ["", "lemma relevant_vars_Entry:\n  assumes \"V \\<in> rv S (CFG_node (_Entry_))\" and \"(_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  shows \"V \\<in> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<in> L", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. V \\<in> L", "from \\<open>V \\<in> rv S (CFG_node (_Entry_))\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> rv S (CFG_node (_Entry_))", "obtain as n' \n    where \"(_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\" \n    and \"n' \\<in> HRB_slice S\" and \"V \\<in> Use\\<^bsub>SDG\\<^esub> n'\"\n    and \"\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes as) \n          \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\""], ["proof (prove)\nusing this:\n  V \\<in> rv S (CFG_node (_Entry_))\n\ngoal (1 subgoal):\n 1. (\\<And>as n'.\n        \\<lbrakk>(_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n';\n         n' \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> n';\n         \\<forall>n''.\n            valid_SDG_node n'' \\<and>\n            parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n            V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:rvE)"], ["proof (state)\nthis:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  n' \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> n'\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. V \\<in> L", "from \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "have \"valid_node (parent_node n')\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. valid_node (parent_node n')", "by(fastforce intro:path_valid_node simp:intra_path_def)"], ["proof (state)\nthis:\n  valid_node (parent_node n')\n\ngoal (1 subgoal):\n 1. V \\<in> L", "thus ?thesis"], ["proof (prove)\nusing this:\n  valid_node (parent_node n')\n\ngoal (1 subgoal):\n 1. V \\<in> L", "proof(cases \"parent_node n'\" rule:valid_node_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. parent_node n' = (_Entry_) \\<Longrightarrow> V \\<in> L\n 2. parent_node n' = (_Exit_) \\<Longrightarrow> V \\<in> L\n 3. inner_node (parent_node n') \\<Longrightarrow> V \\<in> L", "case Entry"], ["proof (state)\nthis:\n  parent_node n' = (_Entry_)\n\ngoal (3 subgoals):\n 1. parent_node n' = (_Entry_) \\<Longrightarrow> V \\<in> L\n 2. parent_node n' = (_Exit_) \\<Longrightarrow> V \\<in> L\n 3. inner_node (parent_node n') \\<Longrightarrow> V \\<in> L", "with \\<open>V \\<in> Use\\<^bsub>SDG\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> Use\\<^bsub>SDG\\<^esub> n'\n  parent_node n' = (_Entry_)", "have False"], ["proof (prove)\nusing this:\n  V \\<in> Use\\<^bsub>SDG\\<^esub> n'\n  parent_node n' = (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by -(drule SDG_Use_parent_Use,simp add:Entry_empty)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. parent_node n' = (_Entry_) \\<Longrightarrow> V \\<in> L\n 2. parent_node n' = (_Exit_) \\<Longrightarrow> V \\<in> L\n 3. inner_node (parent_node n') \\<Longrightarrow> V \\<in> L", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. V \\<in> L", "by simp"], ["proof (state)\nthis:\n  V \\<in> L\n\ngoal (2 subgoals):\n 1. parent_node n' = (_Exit_) \\<Longrightarrow> V \\<in> L\n 2. inner_node (parent_node n') \\<Longrightarrow> V \\<in> L", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. parent_node n' = (_Exit_) \\<Longrightarrow> V \\<in> L\n 2. inner_node (parent_node n') \\<Longrightarrow> V \\<in> L", "case Exit"], ["proof (state)\nthis:\n  parent_node n' = (_Exit_)\n\ngoal (2 subgoals):\n 1. parent_node n' = (_Exit_) \\<Longrightarrow> V \\<in> L\n 2. inner_node (parent_node n') \\<Longrightarrow> V \\<in> L", "with \\<open>V \\<in> Use\\<^bsub>SDG\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> Use\\<^bsub>SDG\\<^esub> n'\n  parent_node n' = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  V \\<in> Use\\<^bsub>SDG\\<^esub> n'\n  parent_node n' = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by -(drule SDG_Use_parent_Use,simp add:Exit_empty)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. parent_node n' = (_Exit_) \\<Longrightarrow> V \\<in> L\n 2. inner_node (parent_node n') \\<Longrightarrow> V \\<in> L", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. V \\<in> L", "by simp"], ["proof (state)\nthis:\n  V \\<in> L\n\ngoal (1 subgoal):\n 1. inner_node (parent_node n') \\<Longrightarrow> V \\<in> L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_node (parent_node n') \\<Longrightarrow> V \\<in> L", "case inner"], ["proof (state)\nthis:\n  inner_node (parent_node n')\n\ngoal (1 subgoal):\n 1. inner_node (parent_node n') \\<Longrightarrow> V \\<in> L", "with \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  inner_node (parent_node n')", "obtain a' as' where \"as = a'#as'\"\n      and \"(_High_) -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  inner_node (parent_node n')\n\ngoal (1 subgoal):\n 1. (\\<And>a' as'.\n        \\<lbrakk>as = a' # as';\n         (_High_) -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:Entry_path_High_path simp:intra_path_def)"], ["proof (state)\nthis:\n  as = a' # as'\n  (_High_) -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. inner_node (parent_node n') \\<Longrightarrow> V \\<in> L", "from \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\\<close> \\<open>as = a'#as'\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as = a' # as'", "have \"sourcenode a' = (_Entry_)\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as = a' # as'\n\ngoal (1 subgoal):\n 1. sourcenode a' = (_Entry_)", "by(fastforce elim:path.cases simp:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode a' = (_Entry_)\n\ngoal (1 subgoal):\n 1. inner_node (parent_node n') \\<Longrightarrow> V \\<in> L", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<in> L", "proof(cases \"as' = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow> V \\<in> L\n 2. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "case True"], ["proof (state)\nthis:\n  as' = []\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow> V \\<in> L\n 2. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "with \\<open>(_High_) -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\\<close>"], ["proof (chain)\npicking this:\n  (_High_) -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as' = []", "have \"parent_node n' = (_High_)\""], ["proof (prove)\nusing this:\n  (_High_) -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as' = []\n\ngoal (1 subgoal):\n 1. parent_node n' = (_High_)", "by(fastforce simp:intra_path_def)"], ["proof (state)\nthis:\n  parent_node n' = (_High_)\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow> V \\<in> L\n 2. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "with \\<open>n' \\<in> HRB_slice S\\<close> \\<open>(_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  n' \\<in> HRB_slice S\n  (_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  parent_node n' = (_High_)", "have False"], ["proof (prove)\nusing this:\n  n' \\<in> HRB_slice S\n  (_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  parent_node n' = (_High_)\n\ngoal (1 subgoal):\n 1. False", "by(fastforce dest:valid_SDG_node_in_slice_parent_node_in_slice \n                    simp:SDG_to_CFG_set_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow> V \\<in> L\n 2. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. V \\<in> L", "by simp"], ["proof (state)\nthis:\n  V \\<in> L\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "case False"], ["proof (state)\nthis:\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "with \\<open>(_High_) -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\\<close>"], ["proof (chain)\npicking this:\n  (_High_) -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as' \\<noteq> []", "have \"hd (sourcenodes as') = (_High_)\""], ["proof (prove)\nusing this:\n  (_High_) -as'\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (sourcenodes as') = (_High_)", "by(fastforce intro:path_sourcenode simp:intra_path_def)"], ["proof (state)\nthis:\n  hd (sourcenodes as') = (_High_)\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "from False"], ["proof (chain)\npicking this:\n  as' \\<noteq> []", "have \"hd (sourcenodes as') \\<in> set (sourcenodes as')\""], ["proof (prove)\nusing this:\n  as' \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (sourcenodes as') \\<in> set (sourcenodes as')", "by(fastforce intro:hd_in_set simp:sourcenodes_def)"], ["proof (state)\nthis:\n  hd (sourcenodes as') \\<in> set (sourcenodes as')\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "with \\<open>as = a'#as'\\<close>"], ["proof (chain)\npicking this:\n  as = a' # as'\n  hd (sourcenodes as') \\<in> set (sourcenodes as')", "have \"hd (sourcenodes as') \\<in> set (sourcenodes as)\""], ["proof (prove)\nusing this:\n  as = a' # as'\n  hd (sourcenodes as') \\<in> set (sourcenodes as')\n\ngoal (1 subgoal):\n 1. hd (sourcenodes as') \\<in> set (sourcenodes as)", "by(simp add:sourcenodes_def)"], ["proof (state)\nthis:\n  hd (sourcenodes as') \\<in> set (sourcenodes as)\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "from \\<open>hd (sourcenodes as') = (_High_)\\<close>"], ["proof (chain)\npicking this:\n  hd (sourcenodes as') = (_High_)", "have \"valid_node (hd (sourcenodes as'))\""], ["proof (prove)\nusing this:\n  hd (sourcenodes as') = (_High_)\n\ngoal (1 subgoal):\n 1. valid_node (hd (sourcenodes as'))", "by simp"], ["proof (state)\nthis:\n  valid_node (hd (sourcenodes as'))\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "have \"valid_SDG_node (CFG_node (_High_))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_SDG_node (CFG_node (_High_))", "by simp"], ["proof (state)\nthis:\n  valid_SDG_node (CFG_node (_High_))\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "with \\<open>hd (sourcenodes as') = (_High_)\\<close>\n        \\<open>hd (sourcenodes as') \\<in> set (sourcenodes as)\\<close>\n        \\<open>\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes as) \n        \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\\<close>"], ["proof (chain)\npicking this:\n  hd (sourcenodes as') = (_High_)\n  hd (sourcenodes as') \\<in> set (sourcenodes as)\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n  valid_SDG_node (CFG_node (_High_))", "have \"V \\<notin> Def (_High_)\""], ["proof (prove)\nusing this:\n  hd (sourcenodes as') = (_High_)\n  hd (sourcenodes as') \\<in> set (sourcenodes as)\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n  valid_SDG_node (CFG_node (_High_))\n\ngoal (1 subgoal):\n 1. V \\<notin> Def (_High_)", "by(fastforce dest:CFG_Def_SDG_Def[OF \\<open>valid_node (hd (sourcenodes as'))\\<close>])"], ["proof (state)\nthis:\n  V \\<notin> Def (_High_)\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "hence \"V \\<notin> H\""], ["proof (prove)\nusing this:\n  V \\<notin> Def (_High_)\n\ngoal (1 subgoal):\n 1. V \\<notin> H", "by(simp add:DefHigh)"], ["proof (state)\nthis:\n  V \\<notin> H\n\ngoal (1 subgoal):\n 1. as' \\<noteq> [] \\<Longrightarrow> V \\<in> L", "thus ?thesis"], ["proof (prove)\nusing this:\n  V \\<notin> H\n\ngoal (1 subgoal):\n 1. V \\<in> L", "by(rule not_High_Low)"], ["proof (state)\nthis:\n  V \\<in> L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  V \\<in> L\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  V \\<in> L\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lowEquivalence_relevant_nodes_Entry:\n  assumes \"s \\<approx>\\<^sub>L s'\" and \"(_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  shows \"\\<forall>V \\<in> rv S (CFG_node (_Entry_)). hd s V = hd s' V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node (_Entry_)). hd s V = hd s' V", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (_Entry_)) \\<Longrightarrow> hd s V = hd s' V", "fix V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (_Entry_)) \\<Longrightarrow> hd s V = hd s' V", "assume \"V \\<in> rv S (CFG_node (_Entry_))\""], ["proof (state)\nthis:\n  V \\<in> rv S (CFG_node (_Entry_))\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (_Entry_)) \\<Longrightarrow> hd s V = hd s' V", "with \\<open>(_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  (_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  V \\<in> rv S (CFG_node (_Entry_))", "have \"V \\<in> L\""], ["proof (prove)\nusing this:\n  (_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  V \\<in> rv S (CFG_node (_Entry_))\n\ngoal (1 subgoal):\n 1. V \\<in> L", "by -(rule relevant_vars_Entry)"], ["proof (state)\nthis:\n  V \\<in> L\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (_Entry_)) \\<Longrightarrow> hd s V = hd s' V", "with \\<open>s \\<approx>\\<^sub>L s'\\<close>"], ["proof (chain)\npicking this:\n  s \\<approx>\\<^sub>L s'\n  V \\<in> L", "show \"hd s V = hd s' V\""], ["proof (prove)\nusing this:\n  s \\<approx>\\<^sub>L s'\n  V \\<in> L\n\ngoal (1 subgoal):\n 1. hd s V = hd s' V", "by(simp add:lowEquivalence_def)"], ["proof (state)\nthis:\n  hd s V = hd s' V\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The Correctness Proofs\\<close>"], ["", "text \\<open>\nIn the following, we present two correctness proofs that slicing\nguarantees IFC noninterference. In both theorems, \\<open>CFG_node\n(_High_) \\<notin> HRB_slice S\\<close>, where \\<open>CFG_node (_Low_) \\<in> S\\<close>, makes\nsure that no high variable (which are all defined in \\<open>(_High_)\\<close>)\ncan influence a low variable (which are all used in \\<open>(_Low_)\\<close>).\n\n\nFirst, a theorem regarding \\<open>(_Entry_) -as\\<rightarrow>* (_Exit_)\\<close> paths in the \ncontrol flow graph (CFG), which agree to a complete program execution:\\<close>"], ["", "lemma slpa_rv_Low_Use_Low:\n  assumes \"CFG_node (_Low_) \\<in> S\"\n  shows \"\\<lbrakk>same_level_path_aux cs as; upd_cs cs as = []; same_level_path_aux cs as';\n    \\<forall>c \\<in> set cs. valid_edge c; m -as\\<rightarrow>* (_Low_); m -as'\\<rightarrow>* (_Low_);\n   \\<forall>i < length cs. \\<forall>V \\<in> rv S (CFG_node (sourcenode (cs!i))). \n    fst (s!Suc i) V = fst (s'!Suc i) V; \\<forall>i < Suc (length cs). snd (s!i) = snd (s'!i);\n   \\<forall>V \\<in> rv S (CFG_node m). state_val s V = state_val s' V;\n   preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n   length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n   \\<Longrightarrow> \\<forall>V \\<in> Use (_Low_). state_val (transfers(slice_kinds S as) s) V =\n                      state_val (transfers(slice_kinds S as') s') V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>same_level_path_aux cs as; upd_cs cs as = [];\n     same_level_path_aux cs as'; \\<forall>c\\<in>set cs. valid_edge c;\n     m -as\\<rightarrow>* (_Low_); m -as'\\<rightarrow>* (_Low_);\n     \\<forall>i<length cs.\n        \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n           fst (s ! Suc i) V = fst (s' ! Suc i) V;\n     \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n     \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n     preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n     length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                         state_val (transfers (slice_kinds S as) s) V =\n                         state_val (transfers (slice_kinds S as') s') V", "proof(induct arbitrary:m as' s s' rule:slpa_induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>cs m as' s s'.\n       \\<lbrakk>upd_cs cs [] = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -[]\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as m as' s s'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs as = []; same_level_path_aux cs as';\n            Ball (set cs) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 3. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 4. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "case (slpa_empty cs)"], ["proof (state)\nthis:\n  upd_cs cs [] = []\n  same_level_path_aux cs as'\n  \\<forall>a\\<in>set cs. valid_edge a\n  m -[]\\<rightarrow>* (_Low_)\n  m -as'\\<rightarrow>* (_Low_)\n  \\<forall>i<length cs.\n     \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n        fst (s ! Suc i) V = fst (s' ! Suc i) V\n  \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i)\n  \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V\n  preds (slice_kinds S []) s\n  preds (slice_kinds S as') s'\n  length s = Suc (length cs)\n  length s' = Suc (length cs)\n\ngoal (4 subgoals):\n 1. \\<And>cs m as' s s'.\n       \\<lbrakk>upd_cs cs [] = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -[]\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as m as' s s'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs as = []; same_level_path_aux cs as';\n            Ball (set cs) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 3. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 4. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "from \\<open>m -[]\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  m -[]\\<rightarrow>* (_Low_)", "have \"m = (_Low_)\""], ["proof (prove)\nusing this:\n  m -[]\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. m = (_Low_)", "by fastforce"], ["proof (state)\nthis:\n  m = (_Low_)\n\ngoal (4 subgoals):\n 1. \\<And>cs m as' s s'.\n       \\<lbrakk>upd_cs cs [] = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -[]\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as m as' s s'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs as = []; same_level_path_aux cs as';\n            Ball (set cs) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 3. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 4. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "from \\<open>m -[]\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  m -[]\\<rightarrow>* (_Low_)", "have \"valid_node m\""], ["proof (prove)\nusing this:\n  m -[]\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. valid_node m", "by(rule path_valid_node)+"], ["proof (state)\nthis:\n  valid_node m\n\ngoal (4 subgoals):\n 1. \\<And>cs m as' s s'.\n       \\<lbrakk>upd_cs cs [] = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -[]\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as m as' s s'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs as = []; same_level_path_aux cs as';\n            Ball (set cs) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 3. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 4. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "{"], ["proof (state)\nthis:\n  valid_node m\n\ngoal (4 subgoals):\n 1. \\<And>cs m as' s s'.\n       \\<lbrakk>upd_cs cs [] = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -[]\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as m as' s s'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs as = []; same_level_path_aux cs as';\n            Ball (set cs) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 3. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 4. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "fix V"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>cs m as' s s'.\n       \\<lbrakk>upd_cs cs [] = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -[]\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as m as' s s'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs as = []; same_level_path_aux cs as';\n            Ball (set cs) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 3. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 4. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "assume \"V \\<in> Use (_Low_)\""], ["proof (state)\nthis:\n  V \\<in> Use (_Low_)\n\ngoal (4 subgoals):\n 1. \\<And>cs m as' s s'.\n       \\<lbrakk>upd_cs cs [] = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -[]\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as m as' s s'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs as = []; same_level_path_aux cs as';\n            Ball (set cs) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 3. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 4. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "moreover"], ["proof (state)\nthis:\n  V \\<in> Use (_Low_)\n\ngoal (4 subgoals):\n 1. \\<And>cs m as' s s'.\n       \\<lbrakk>upd_cs cs [] = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -[]\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as m as' s s'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs as = []; same_level_path_aux cs as';\n            Ball (set cs) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 3. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 4. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "from \\<open>valid_node m\\<close> \\<open>m = (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  valid_node m\n  m = (_Low_)", "have \"(_Low_) -[]\\<rightarrow>\\<^sub>\\<iota>* (_Low_)\""], ["proof (prove)\nusing this:\n  valid_node m\n  m = (_Low_)\n\ngoal (1 subgoal):\n 1. (_Low_) -[]\\<rightarrow>\\<^sub>\\<iota>* (_Low_)", "by(fastforce intro:empty_path simp:intra_path_def)"], ["proof (state)\nthis:\n  (_Low_) -[]\\<rightarrow>\\<^sub>\\<iota>* (_Low_)\n\ngoal (4 subgoals):\n 1. \\<And>cs m as' s s'.\n       \\<lbrakk>upd_cs cs [] = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -[]\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as m as' s s'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs as = []; same_level_path_aux cs as';\n            Ball (set cs) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 3. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 4. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "moreover"], ["proof (state)\nthis:\n  (_Low_) -[]\\<rightarrow>\\<^sub>\\<iota>* (_Low_)\n\ngoal (4 subgoals):\n 1. \\<And>cs m as' s s'.\n       \\<lbrakk>upd_cs cs [] = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -[]\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as m as' s s'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs as = []; same_level_path_aux cs as';\n            Ball (set cs) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 3. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 4. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "from \\<open>valid_node m\\<close> \\<open>m = (_Low_)\\<close> \\<open>CFG_node (_Low_) \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  valid_node m\n  m = (_Low_)\n  CFG_node (_Low_) \\<in> S", "have \"CFG_node (_Low_) \\<in> HRB_slice S\""], ["proof (prove)\nusing this:\n  valid_node m\n  m = (_Low_)\n  CFG_node (_Low_) \\<in> S\n\ngoal (1 subgoal):\n 1. CFG_node (_Low_) \\<in> HRB_slice S", "by(fastforce intro:HRB_slice_refl)"], ["proof (state)\nthis:\n  CFG_node (_Low_) \\<in> HRB_slice S\n\ngoal (4 subgoals):\n 1. \\<And>cs m as' s s'.\n       \\<lbrakk>upd_cs cs [] = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -[]\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as m as' s s'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs as = []; same_level_path_aux cs as';\n            Ball (set cs) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 3. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 4. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "ultimately"], ["proof (chain)\npicking this:\n  V \\<in> Use (_Low_)\n  (_Low_) -[]\\<rightarrow>\\<^sub>\\<iota>* (_Low_)\n  CFG_node (_Low_) \\<in> HRB_slice S", "have \"V \\<in> rv S (CFG_node m)\""], ["proof (prove)\nusing this:\n  V \\<in> Use (_Low_)\n  (_Low_) -[]\\<rightarrow>\\<^sub>\\<iota>* (_Low_)\n  CFG_node (_Low_) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. V \\<in> rv S (CFG_node m)", "using \\<open>m = (_Low_)\\<close>"], ["proof (prove)\nusing this:\n  V \\<in> Use (_Low_)\n  (_Low_) -[]\\<rightarrow>\\<^sub>\\<iota>* (_Low_)\n  CFG_node (_Low_) \\<in> HRB_slice S\n  m = (_Low_)\n\ngoal (1 subgoal):\n 1. V \\<in> rv S (CFG_node m)", "by(auto intro!:rvI CFG_Use_SDG_Use simp:sourcenodes_def)"], ["proof (state)\nthis:\n  V \\<in> rv S (CFG_node m)\n\ngoal (4 subgoals):\n 1. \\<And>cs m as' s s'.\n       \\<lbrakk>upd_cs cs [] = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -[]\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as m as' s s'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs as = []; same_level_path_aux cs as';\n            Ball (set cs) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 3. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 4. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "}"], ["proof (state)\nthis:\n  ?V2 \\<in> Use (_Low_) \\<Longrightarrow> ?V2 \\<in> rv S (CFG_node m)\n\ngoal (4 subgoals):\n 1. \\<And>cs m as' s s'.\n       \\<lbrakk>upd_cs cs [] = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -[]\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as m as' s s'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs as = []; same_level_path_aux cs as';\n            Ball (set cs) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 3. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 4. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "hence \"\\<forall>V \\<in> Use (_Low_). V \\<in> rv S (CFG_node m)\""], ["proof (prove)\nusing this:\n  ?V2 \\<in> Use (_Low_) \\<Longrightarrow> ?V2 \\<in> rv S (CFG_node m)\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_). V \\<in> rv S (CFG_node m)", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_). V \\<in> rv S (CFG_node m)\n\ngoal (4 subgoals):\n 1. \\<And>cs m as' s s'.\n       \\<lbrakk>upd_cs cs [] = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -[]\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S []) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S []) s) V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as m as' s s'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs as = []; same_level_path_aux cs as';\n            Ball (set cs) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 3. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 4. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S []) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "proof(cases \"L = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. L = {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S []) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S []) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "case True"], ["proof (state)\nthis:\n  L = {}\n\ngoal (2 subgoals):\n 1. L = {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S []) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S []) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "with UseLow"], ["proof (chain)\npicking this:\n  Use (_Low_) = L\n  L = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  Use (_Low_) = L\n  L = {}\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S []) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S []) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S []) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S []) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "case False"], ["proof (state)\nthis:\n  L \\<noteq> {}\n\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S []) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>m -as'\\<rightarrow>* (_Low_)\\<close> \\<open>m = (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  m -as'\\<rightarrow>* (_Low_)\n  m = (_Low_)", "have \"as' = []\""], ["proof (prove)\nusing this:\n  m -as'\\<rightarrow>* (_Low_)\n  m = (_Low_)\n\ngoal (1 subgoal):\n 1. as' = []", "proof(induct m as' m'\\<equiv>\"(_Low_)\" rule:path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (_Low_); (_Low_) = (_Low_)\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>n'' as a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        n'' = (_Low_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = n; targetnode a = n''; n = (_Low_)\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "case (Cons_path m'' as a m)"], ["proof (state)\nthis:\n  m'' -as\\<rightarrow>* (_Low_)\n  m'' = (_Low_) \\<Longrightarrow> as = []\n  valid_edge a\n  sourcenode a = m\n  targetnode a = m''\n  m = (_Low_)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (_Low_); (_Low_) = (_Low_)\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>n'' as a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        n'' = (_Low_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = n; targetnode a = n''; n = (_Low_)\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "from \\<open>valid_edge a\\<close> \\<open>sourcenode a = m\\<close> \\<open>m = (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = m\n  m = (_Low_)", "have \"targetnode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = m\n  m = (_Low_)\n\ngoal (1 subgoal):\n 1. targetnode a = (_Exit_)", "by -(rule Exit_successor_of_Low,simp+)"], ["proof (state)\nthis:\n  targetnode a = (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (_Low_); (_Low_) = (_Low_)\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>n'' as a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        n'' = (_Low_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = n; targetnode a = n''; n = (_Low_)\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "with \\<open>targetnode a = m''\\<close> \\<open>m'' -as\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  targetnode a = m''\n  m'' -as\\<rightarrow>* (_Low_)\n  targetnode a = (_Exit_)", "have \"(_Low_) = (_Exit_)\""], ["proof (prove)\nusing this:\n  targetnode a = m''\n  m'' -as\\<rightarrow>* (_Low_)\n  targetnode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. (_Low_) = (_Exit_)", "by -(drule path_Exit_source,auto)"], ["proof (state)\nthis:\n  (_Low_) = (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (_Low_); (_Low_) = (_Low_)\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>n'' as a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        n'' = (_Low_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = n; targetnode a = n''; n = (_Low_)\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "with False"], ["proof (chain)\npicking this:\n  L \\<noteq> {}\n  (_Low_) = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  L \\<noteq> {}\n  (_Low_) = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by -(drule Low_neq_Exit,simp)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (_Low_); (_Low_) = (_Low_)\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>n'' as a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        n'' = (_Low_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = n; targetnode a = n''; n = (_Low_)\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. a # as = []", "by simp"], ["proof (state)\nthis:\n  a # as = []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node (_Low_); (_Low_) = (_Low_)\\<rbrakk>\n    \\<Longrightarrow> [] = []", "qed simp"], ["proof (state)\nthis:\n  as' = []\n\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S []) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "with \\<open>\\<forall>V \\<in> Use (_Low_). V \\<in> rv S (CFG_node m)\\<close>\n      \\<open>\\<forall>V \\<in> rv S (CFG_node m). state_val s V = state_val s' V\\<close> Nil"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use (_Low_). V \\<in> rv S (CFG_node m)\n  \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V\n  ([], []) \\<in> listrel ?r\n  as' = []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use (_Low_). V \\<in> rv S (CFG_node m)\n  \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V\n  ([], []) \\<in> listrel ?r\n  as' = []\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S []) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "by(auto simp:slice_kinds_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S []) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S []) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal (3 subgoals):\n 1. \\<And>cs a as m as' s s'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs as = []; same_level_path_aux cs as';\n            Ball (set cs) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 3. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs a as m as' s s'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs as = []; same_level_path_aux cs as';\n            Ball (set cs) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 3. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "case (slpa_intra cs a as)"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  same_level_path_aux cs as\n  \\<lbrakk>upd_cs cs as = []; same_level_path_aux cs ?as';\n   \\<forall>a\\<in>set cs. valid_edge a; ?m -as\\<rightarrow>* (_Low_);\n   ?m -?as'\\<rightarrow>* (_Low_);\n   \\<forall>i<length cs.\n      \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n         fst (?s ! Suc i) V = fst (?s' ! Suc i) V;\n   \\<forall>i<Suc (length cs). snd (?s ! i) = snd (?s' ! i);\n   \\<forall>V\\<in>rv S (CFG_node ?m). state_val ?s V = state_val ?s' V;\n   preds (slice_kinds S as) ?s; preds (slice_kinds S ?as') ?s';\n   length ?s = Suc (length cs); length ?s' = Suc (length cs)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                       state_val (transfers (slice_kinds S as) ?s) V =\n                       state_val (transfers (slice_kinds S ?as') ?s') V\n  upd_cs cs (a # as) = []\n  same_level_path_aux cs as'\n  \\<forall>a\\<in>set cs. valid_edge a\n  m -a # as\\<rightarrow>* (_Low_)\n  m -as'\\<rightarrow>* (_Low_)\n  \\<forall>i<length cs.\n     \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n        fst (s ! Suc i) V = fst (s' ! Suc i) V\n  \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i)\n  \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V\n  preds (slice_kinds S (a # as)) s\n  preds (slice_kinds S as') s'\n  length s = Suc (length cs)\n  length s' = Suc (length cs)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as m as' s s'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs as = []; same_level_path_aux cs as';\n            Ball (set cs) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 3. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "note IH = \\<open>\\<And>m as' s s'. \\<lbrakk>upd_cs cs as = []; same_level_path_aux cs as'; \n    \\<forall>a\\<in>set cs. valid_edge a; m -as\\<rightarrow>* (_Low_); m -as'\\<rightarrow>* (_Low_);\n    \\<forall>i<length cs. \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n    fst (s ! Suc i) V = fst (s' ! Suc i) V; \n    \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n    \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n    preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n    length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_). state_val (transfers(slice_kinds S as) s) V =\n    state_val (transfers(slice_kinds S as') s') V\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>upd_cs cs as = []; same_level_path_aux cs ?as';\n   \\<forall>a\\<in>set cs. valid_edge a; ?m -as\\<rightarrow>* (_Low_);\n   ?m -?as'\\<rightarrow>* (_Low_);\n   \\<forall>i<length cs.\n      \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n         fst (?s ! Suc i) V = fst (?s' ! Suc i) V;\n   \\<forall>i<Suc (length cs). snd (?s ! i) = snd (?s' ! i);\n   \\<forall>V\\<in>rv S (CFG_node ?m). state_val ?s V = state_val ?s' V;\n   preds (slice_kinds S as) ?s; preds (slice_kinds S ?as') ?s';\n   length ?s = Suc (length cs); length ?s' = Suc (length cs)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                       state_val (transfers (slice_kinds S as) ?s) V =\n                       state_val (transfers (slice_kinds S ?as') ?s') V\n\ngoal (3 subgoals):\n 1. \\<And>cs a as m as' s s'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs as = []; same_level_path_aux cs as';\n            Ball (set cs) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 3. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "note rvs = \\<open>\\<forall>i<length cs. \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n    fst (s ! Suc i) V = fst (s' ! Suc i) V\\<close>"], ["proof (state)\nthis:\n  \\<forall>i<length cs.\n     \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n        fst (s ! Suc i) V = fst (s' ! Suc i) V\n\ngoal (3 subgoals):\n 1. \\<And>cs a as m as' s s'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs as = []; same_level_path_aux cs as';\n            Ball (set cs) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 3. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "from \\<open>m -a # as\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  m -a # as\\<rightarrow>* (_Low_)", "have \"sourcenode a = m\" and \"valid_edge a\"\n    and \"targetnode a -as\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  m -a # as\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. sourcenode a = m &&&\n    valid_edge a &&& targetnode a -as\\<rightarrow>* (_Low_)", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  sourcenode a = m\n  valid_edge a\n  targetnode a -as\\<rightarrow>* (_Low_)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as m as' s s'.\n       \\<lbrakk>intra_kind (kind a); same_level_path_aux cs as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs as = []; same_level_path_aux cs as';\n            Ball (set cs) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 3. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "proof(cases \"L = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. L = {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "case True"], ["proof (state)\nthis:\n  L = {}\n\ngoal (2 subgoals):\n 1. L = {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "with UseLow"], ["proof (chain)\npicking this:\n  Use (_Low_) = L\n  L = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  Use (_Low_) = L\n  L = {}\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "case False"], ["proof (state)\nthis:\n  L \\<noteq> {}\n\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "proof(cases as')"], ["proof (state)\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "case Nil"], ["proof (state)\nthis:\n  as' = []\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>m -as'\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  m -as'\\<rightarrow>* (_Low_)\n  as' = []", "have \"m = (_Low_)\""], ["proof (prove)\nusing this:\n  m -as'\\<rightarrow>* (_Low_)\n  as' = []\n\ngoal (1 subgoal):\n 1. m = (_Low_)", "by fastforce"], ["proof (state)\nthis:\n  m = (_Low_)\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>valid_edge a\\<close> \\<open>sourcenode a = m\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = m\n  m = (_Low_)", "have \"targetnode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = m\n  m = (_Low_)\n\ngoal (1 subgoal):\n 1. targetnode a = (_Exit_)", "by -(rule Exit_successor_of_Low,simp+)"], ["proof (state)\nthis:\n  targetnode a = (_Exit_)\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from Low_source_Exit_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Low_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>", "obtain a' where \"valid_edge a'\"\n        and \"sourcenode a' = (_Low_)\" and \"targetnode a' = (_Exit_)\"\n        and \"kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Low_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>valid_edge a'; sourcenode a' = (_Low_);\n         targetnode a' = (_Exit_);\n         kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_edge a'\n  sourcenode a' = (_Low_)\n  targetnode a' = (_Exit_)\n  kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>valid_edge a\\<close> \\<open>sourcenode a = m\\<close> \\<open>m = (_Low_)\\<close> \n        \\<open>targetnode a = (_Exit_)\\<close> \\<open>valid_edge a'\\<close> \\<open>sourcenode a' = (_Low_)\\<close> \n        \\<open>targetnode a' = (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = m\n  m = (_Low_)\n  targetnode a = (_Exit_)\n  valid_edge a'\n  sourcenode a' = (_Low_)\n  targetnode a' = (_Exit_)", "have \"a = a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = m\n  m = (_Low_)\n  targetnode a = (_Exit_)\n  valid_edge a'\n  sourcenode a' = (_Low_)\n  targetnode a' = (_Exit_)\n\ngoal (1 subgoal):\n 1. a = a'", "by(fastforce dest:edge_det)"], ["proof (state)\nthis:\n  a = a'\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n  a = a'", "have \"kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n  a = a'\n\ngoal (1 subgoal):\n 1. kind a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by simp"], ["proof (state)\nthis:\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>targetnode a = (_Exit_)\\<close> \\<open>targetnode a -as\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  targetnode a = (_Exit_)\n  targetnode a -as\\<rightarrow>* (_Low_)\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>", "have \"(_Low_) = (_Exit_)\""], ["proof (prove)\nusing this:\n  targetnode a = (_Exit_)\n  targetnode a -as\\<rightarrow>* (_Low_)\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (_Low_) = (_Exit_)", "by -(drule path_Exit_source,auto)"], ["proof (state)\nthis:\n  (_Low_) = (_Exit_)\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with False"], ["proof (chain)\npicking this:\n  L \\<noteq> {}\n  (_Low_) = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  L \\<noteq> {}\n  (_Low_) = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by -(drule Low_neq_Exit,simp)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "case (Cons ax asx)"], ["proof (state)\nthis:\n  as' = ax # asx\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>m -as'\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  m -as'\\<rightarrow>* (_Low_)\n  as' = ax # asx", "have \"sourcenode ax = m\" and \"valid_edge ax\"\n        and \"targetnode ax -asx\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  m -as'\\<rightarrow>* (_Low_)\n  as' = ax # asx\n\ngoal (1 subgoal):\n 1. sourcenode ax = m &&&\n    valid_edge ax &&& targetnode ax -asx\\<rightarrow>* (_Low_)", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  sourcenode ax = m\n  valid_edge ax\n  targetnode ax -asx\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>preds (slice_kinds S (a # as)) s\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S (a # as)) s", "obtain cf cfs where [simp]:\"s = cf#cfs\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S (a # as)) s\n\ngoal (1 subgoal):\n 1. (\\<And>cf cfs. s = cf # cfs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s)(auto simp:slice_kinds_def)"], ["proof (state)\nthis:\n  s = cf # cfs\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>preds (slice_kinds S as') s'\\<close> \\<open>as' = ax # asx\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S as') s'\n  as' = ax # asx", "obtain cf' cfs' where [simp]:\"s' = cf'#cfs'\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S as') s'\n  as' = ax # asx\n\ngoal (1 subgoal):\n 1. (\\<And>cf' cfs'.\n        s' = cf' # cfs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s')(auto simp:slice_kinds_def)"], ["proof (state)\nthis:\n  s' = cf' # cfs'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "have \"intra_kind (kind ax)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intra_kind (kind ax)", "proof(cases \"kind ax\" rule:edge_kind_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. intra_kind (kind ax) \\<Longrightarrow> intra_kind (kind ax)\n 2. \\<And>Q r p fs.\n       kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       intra_kind (kind ax)\n 3. \\<And>Q p f.\n       kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind ax)", "case (Call Q r p fs)"], ["proof (state)\nthis:\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (3 subgoals):\n 1. intra_kind (kind ax) \\<Longrightarrow> intra_kind (kind ax)\n 2. \\<And>Q r p fs.\n       kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       intra_kind (kind ax)\n 3. \\<And>Q p f.\n       kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind ax)", "have False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "case True"], ["proof (state)\nthis:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"slice_kind S a = kind a\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. slice_kind S a = kind a", "by -(rule slice_intra_kind_in_slice)"], ["proof (state)\nthis:\n  slice_kind S a = kind a\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "from \\<open>valid_edge ax\\<close> \\<open>kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have unique:\"\\<exists>!a'. valid_edge a' \\<and> sourcenode a' = sourcenode ax \\<and> \n            intra_kind(kind a')\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       valid_edge a' \\<and>\n       sourcenode a' = sourcenode ax \\<and> intra_kind (kind a')", "by(rule call_only_one_intra_edge)"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     valid_edge a' \\<and>\n     sourcenode a' = sourcenode ax \\<and> intra_kind (kind a')\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "from \\<open>valid_edge ax\\<close> \\<open>kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain x \n            where \"x \\<in> get_return_edges ax\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> get_return_edges ax \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:get_return_edge_call)"], ["proof (state)\nthis:\n  x \\<in> get_return_edges ax\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>valid_edge ax\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  x \\<in> get_return_edges ax", "obtain a' where \"valid_edge a'\" \n            and \"sourcenode a' = sourcenode ax\" and \"kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  x \\<in> get_return_edges ax\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>valid_edge a'; sourcenode a' = sourcenode ax;\n         kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:call_return_node_edge)"], ["proof (state)\nthis:\n  valid_edge a'\n  sourcenode a' = sourcenode ax\n  kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>valid_edge a\\<close> \\<open>sourcenode a = m\\<close> \\<open>sourcenode ax = m\\<close>\n            \\<open>intra_kind (kind a)\\<close> unique"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = m\n  sourcenode ax = m\n  intra_kind (kind a)\n  \\<exists>!a'.\n     valid_edge a' \\<and>\n     sourcenode a' = sourcenode ax \\<and> intra_kind (kind a')\n  valid_edge a'\n  sourcenode a' = sourcenode ax\n  kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "have \"a' = a\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = m\n  sourcenode ax = m\n  intra_kind (kind a)\n  \\<exists>!a'.\n     valid_edge a' \\<and>\n     sourcenode a' = sourcenode ax \\<and> intra_kind (kind a')\n  valid_edge a'\n  sourcenode a' = sourcenode ax\n  kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. a' = a", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  a' = a\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<close> \\<open>slice_kind S a = kind a\\<close>\n            \\<open>preds (slice_kinds S (a#as)) s\\<close>"], ["proof (chain)\npicking this:\n  kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  slice_kind S a = kind a\n  preds (slice_kinds S (a # as)) s\n  a' = a", "have False"], ["proof (prove)\nusing this:\n  kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  slice_kind S a = kind a\n  preds (slice_kinds S (a # as)) s\n  a' = a\n\ngoal (1 subgoal):\n 1. False", "by(cases s)(auto simp:slice_kinds_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "case False"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>sourcenode a = m\\<close> \\<open>sourcenode ax = m\\<close>"], ["proof (chain)\npicking this:\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a = m\n  sourcenode ax = m\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"slice_kind S ax = (\\<lambda>cf. False):r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a = m\n  sourcenode ax = m\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. slice_kind S ax =\n    \\<lambda>cf. False:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "by(fastforce intro:slice_kind_Call)"], ["proof (state)\nthis:\n  slice_kind S ax = \\<lambda>cf. False:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>as' = ax # asx\\<close> \\<open>preds (slice_kinds S as') s'\\<close>"], ["proof (chain)\npicking this:\n  as' = ax # asx\n  preds (slice_kinds S as') s'\n  slice_kind S ax = \\<lambda>cf. False:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have False"], ["proof (prove)\nusing this:\n  as' = ax # asx\n  preds (slice_kinds S as') s'\n  slice_kind S ax = \\<lambda>cf. False:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. False", "by(cases s')(auto simp:slice_kinds_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. intra_kind (kind ax) \\<Longrightarrow> intra_kind (kind ax)\n 2. \\<And>Q r p fs.\n       kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       intra_kind (kind ax)\n 3. \\<And>Q p f.\n       kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind ax)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. intra_kind (kind ax)", "by simp"], ["proof (state)\nthis:\n  intra_kind (kind ax)\n\ngoal (2 subgoals):\n 1. intra_kind (kind ax) \\<Longrightarrow> intra_kind (kind ax)\n 2. \\<And>Q p f.\n       kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind ax)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. intra_kind (kind ax) \\<Longrightarrow> intra_kind (kind ax)\n 2. \\<And>Q p f.\n       kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind ax)", "case (Return Q p f)"], ["proof (state)\nthis:\n  kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (2 subgoals):\n 1. intra_kind (kind ax) \\<Longrightarrow> intra_kind (kind ax)\n 2. \\<And>Q p f.\n       kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind ax)", "from \\<open>valid_edge ax\\<close> \\<open>kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>\n          \\<open>sourcenode a = m\\<close> \\<open>sourcenode ax = m\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_edge a\n  intra_kind (kind a)\n  sourcenode a = m\n  sourcenode ax = m", "have False"], ["proof (prove)\nusing this:\n  valid_edge ax\n  kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  valid_edge a\n  intra_kind (kind a)\n  sourcenode a = m\n  sourcenode ax = m\n\ngoal (1 subgoal):\n 1. False", "by -(drule return_edges_only,auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. intra_kind (kind ax) \\<Longrightarrow> intra_kind (kind ax)\n 2. \\<And>Q p f.\n       kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       intra_kind (kind ax)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. intra_kind (kind ax)", "by simp"], ["proof (state)\nthis:\n  intra_kind (kind ax)\n\ngoal (1 subgoal):\n 1. intra_kind (kind ax) \\<Longrightarrow> intra_kind (kind ax)", "qed simp"], ["proof (state)\nthis:\n  intra_kind (kind ax)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>same_level_path_aux cs as'\\<close> \\<open>as' = ax#asx\\<close>"], ["proof (chain)\npicking this:\n  same_level_path_aux cs as'\n  as' = ax # asx\n  intra_kind (kind ax)", "have \"same_level_path_aux cs asx\""], ["proof (prove)\nusing this:\n  same_level_path_aux cs as'\n  as' = ax # asx\n  intra_kind (kind ax)\n\ngoal (1 subgoal):\n 1. same_level_path_aux cs asx", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  same_level_path_aux cs asx\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "proof(cases \"targetnode a = targetnode ax\")"], ["proof (state)\ngoal (2 subgoals):\n 1. targetnode a = targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "case True"], ["proof (state)\nthis:\n  targetnode a = targetnode ax\n\ngoal (2 subgoals):\n 1. targetnode a = targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "with \\<open>valid_edge a\\<close> \\<open>valid_edge ax\\<close> \\<open>sourcenode a = m\\<close> \\<open>sourcenode ax = m\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge ax\n  sourcenode a = m\n  sourcenode ax = m\n  targetnode a = targetnode ax", "have \"a = ax\""], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge ax\n  sourcenode a = m\n  sourcenode ax = m\n  targetnode a = targetnode ax\n\ngoal (1 subgoal):\n 1. a = ax", "by(fastforce intro:edge_det)"], ["proof (state)\nthis:\n  a = ax\n\ngoal (2 subgoals):\n 1. targetnode a = targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "with \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close> \\<open>sourcenode a = m\\<close>\n          \\<open>\\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V\\<close>\n          \\<open>preds (slice_kinds S (a # as)) s\\<close>\n          \\<open>preds (slice_kinds S as') s'\\<close> \\<open>as' = ax # asx\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)\n  sourcenode a = m\n  \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V\n  preds (slice_kinds S (a # as)) s\n  preds (slice_kinds S as') s'\n  as' = ax # asx\n  a = ax", "have rv:\"\\<forall>V\\<in>rv S (CFG_node (targetnode a)). \n          state_val (transfer (slice_kind S a) s) V =\n          state_val (transfer (slice_kind S a) s') V\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n  sourcenode a = m\n  \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V\n  preds (slice_kinds S (a # as)) s\n  preds (slice_kinds S as') s'\n  as' = ax # asx\n  a = ax\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n       state_val (transfer (slice_kind S a) s) V =\n       state_val (transfer (slice_kind S a) s') V", "by -(rule rv_edge_slice_kinds,auto)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n     state_val (transfer (slice_kind S a) s) V =\n     state_val (transfer (slice_kind S a) s') V\n\ngoal (2 subgoals):\n 1. targetnode a = targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>upd_cs cs (a # as) = []\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs (a # as) = []\n  intra_kind (kind a)", "have \"upd_cs cs as = []\""], ["proof (prove)\nusing this:\n  upd_cs cs (a # as) = []\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. upd_cs cs as = []", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  upd_cs cs as = []\n\ngoal (2 subgoals):\n 1. targetnode a = targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>targetnode ax -asx\\<rightarrow>* (_Low_)\\<close> \\<open>a = ax\\<close>"], ["proof (chain)\npicking this:\n  targetnode ax -asx\\<rightarrow>* (_Low_)\n  a = ax", "have \"targetnode a -asx\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  targetnode ax -asx\\<rightarrow>* (_Low_)\n  a = ax\n\ngoal (1 subgoal):\n 1. targetnode a -asx\\<rightarrow>* (_Low_)", "by simp"], ["proof (state)\nthis:\n  targetnode a -asx\\<rightarrow>* (_Low_)\n\ngoal (2 subgoals):\n 1. targetnode a = targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)", "obtain cfx \n          where cfx:\"transfer (slice_kind S a) s = cfx#cfs \\<and> snd cfx = snd cf\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. (\\<And>cfx.\n        transfer (slice_kind S a) s = cfx # cfs \\<and>\n        snd cfx = snd cf \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply(cases cf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>cfx.\n                   transfer (slice_kind S a) s = cfx # cfs \\<and>\n                   snd cfx = snd cf \\<Longrightarrow>\n                   thesis;\n        valid_edge a; intra_kind (kind a); cf = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>cfx.\n                   transfer (slice_kind S a) s = cfx # cfs \\<and>\n                   snd cfx = snd cf \\<Longrightarrow>\n                   thesis;\n        valid_edge a; intra_kind (kind a); cf = (aa, b);\n        sourcenode a\n        \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>aa b.\n       \\<lbrakk>\\<And>cfx.\n                   transfer (slice_kind S a) s = cfx # cfs \\<and>\n                   snd cfx = snd cf \\<Longrightarrow>\n                   thesis;\n        valid_edge a; intra_kind (kind a); cf = (aa, b);\n        sourcenode a\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>ab.\n                   transfer (slice_kind S a) ((aa, b) # cfs) =\n                   (ab, b) # cfs \\<Longrightarrow>\n                   thesis;\n        valid_edge a; intra_kind (kind a); cf = (aa, b);\n        sourcenode a\n        \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>aa b.\n       \\<lbrakk>\\<And>ab.\n                   transfer (slice_kind S a) ((aa, b) # cfs) =\n                   (ab, b) # cfs \\<Longrightarrow>\n                   thesis;\n        valid_edge a; intra_kind (kind a); cf = (aa, b);\n        sourcenode a\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(fastforce dest:slice_intra_kind_in_slice simp:intra_kind_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>ab.\n                   transfer (slice_kind S a) ((aa, b) # cfs) =\n                   (ab, b) # cfs \\<Longrightarrow>\n                   thesis;\n        valid_edge a; intra_kind (kind a); cf = (aa, b);\n        sourcenode a\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto simp:intra_kind_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b f.\n       \\<lbrakk>\\<And>ab.\n                   transfer (slice_kind S a) ((aa, b) # cfs) =\n                   (ab, b) # cfs \\<Longrightarrow>\n                   thesis;\n        valid_edge a; cf = (aa, b);\n        sourcenode a\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        kind a = \\<Up>f\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>aa b Q.\n       \\<lbrakk>\\<And>ab.\n                   transfer (slice_kind S a) ((aa, b) # cfs) =\n                   (ab, b) # cfs \\<Longrightarrow>\n                   thesis;\n        valid_edge a; cf = (aa, b);\n        sourcenode a\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        kind a = (Q)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(drule slice_kind_Upd)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b f.\n       \\<lbrakk>\\<And>ab.\n                   transfer (slice_kind S a) ((aa, b) # cfs) =\n                   (ab, b) # cfs \\<Longrightarrow>\n                   thesis;\n        valid_edge a; cf = (aa, b); kind a = \\<Up>f\\<rbrakk>\n       \\<Longrightarrow> kind a = \\<Up>?f24 aa b f\n 2. \\<And>aa b f.\n       \\<lbrakk>\\<And>ab.\n                   transfer (slice_kind S a) ((aa, b) # cfs) =\n                   (ab, b) # cfs \\<Longrightarrow>\n                   thesis;\n        valid_edge a; cf = (aa, b); kind a = \\<Up>f;\n        slice_kind S a = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>aa b Q.\n       \\<lbrakk>\\<And>ab.\n                   transfer (slice_kind S a) ((aa, b) # cfs) =\n                   (ab, b) # cfs \\<Longrightarrow>\n                   thesis;\n        valid_edge a; cf = (aa, b);\n        sourcenode a\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        kind a = (Q)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b Q.\n       \\<lbrakk>\\<And>ab.\n                   transfer (slice_kind S a) ((aa, b) # cfs) =\n                   (ab, b) # cfs \\<Longrightarrow>\n                   thesis;\n        valid_edge a; cf = (aa, b);\n        sourcenode a\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        kind a = (Q)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(erule kind_Predicate_notin_slice_slice_kind_Predicate) auto"], ["proof (state)\nthis:\n  transfer (slice_kind S a) s = cfx # cfs \\<and> snd cfx = snd cf\n\ngoal (2 subgoals):\n 1. targetnode a = targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)", "obtain cfx' \n          where cfx':\"transfer (slice_kind S a) s' = cfx'#cfs' \\<and> snd cfx' = snd cf'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. (\\<And>cfx'.\n        transfer (slice_kind S a) s' = cfx' # cfs' \\<and>\n        snd cfx' = snd cf' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "apply(cases cf')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>cfx'.\n                   transfer (slice_kind S a) s' = cfx' # cfs' \\<and>\n                   snd cfx' = snd cf' \\<Longrightarrow>\n                   thesis;\n        valid_edge a; intra_kind (kind a); cf' = (aa, b)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(cases \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>cfx'.\n                   transfer (slice_kind S a) s' = cfx' # cfs' \\<and>\n                   snd cfx' = snd cf' \\<Longrightarrow>\n                   thesis;\n        valid_edge a; intra_kind (kind a); cf' = (aa, b);\n        sourcenode a\n        \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>aa b.\n       \\<lbrakk>\\<And>cfx'.\n                   transfer (slice_kind S a) s' = cfx' # cfs' \\<and>\n                   snd cfx' = snd cf' \\<Longrightarrow>\n                   thesis;\n        valid_edge a; intra_kind (kind a); cf' = (aa, b);\n        sourcenode a\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>ab.\n                   transfer (slice_kind S a) ((aa, b) # cfs') =\n                   (ab, b) # cfs' \\<Longrightarrow>\n                   thesis;\n        valid_edge a; intra_kind (kind a); cf' = (aa, b);\n        sourcenode a\n        \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>aa b.\n       \\<lbrakk>\\<And>ab.\n                   transfer (slice_kind S a) ((aa, b) # cfs') =\n                   (ab, b) # cfs' \\<Longrightarrow>\n                   thesis;\n        valid_edge a; intra_kind (kind a); cf' = (aa, b);\n        sourcenode a\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(fastforce dest:slice_intra_kind_in_slice simp:intra_kind_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b.\n       \\<lbrakk>\\<And>ab.\n                   transfer (slice_kind S a) ((aa, b) # cfs') =\n                   (ab, b) # cfs' \\<Longrightarrow>\n                   thesis;\n        valid_edge a; intra_kind (kind a); cf' = (aa, b);\n        sourcenode a\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(auto simp:intra_kind_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>aa b f.\n       \\<lbrakk>\\<And>ab.\n                   transfer (slice_kind S a) ((aa, b) # cfs') =\n                   (ab, b) # cfs' \\<Longrightarrow>\n                   thesis;\n        valid_edge a; cf' = (aa, b);\n        sourcenode a\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        kind a = \\<Up>f\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>aa b Q.\n       \\<lbrakk>\\<And>ab.\n                   transfer (slice_kind S a) ((aa, b) # cfs') =\n                   (ab, b) # cfs' \\<Longrightarrow>\n                   thesis;\n        valid_edge a; cf' = (aa, b);\n        sourcenode a\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        kind a = (Q)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply(drule slice_kind_Upd)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa b f.\n       \\<lbrakk>\\<And>ab.\n                   transfer (slice_kind S a) ((aa, b) # cfs') =\n                   (ab, b) # cfs' \\<Longrightarrow>\n                   thesis;\n        valid_edge a; cf' = (aa, b); kind a = \\<Up>f\\<rbrakk>\n       \\<Longrightarrow> kind a = \\<Up>?f24 aa b f\n 2. \\<And>aa b f.\n       \\<lbrakk>\\<And>ab.\n                   transfer (slice_kind S a) ((aa, b) # cfs') =\n                   (ab, b) # cfs' \\<Longrightarrow>\n                   thesis;\n        valid_edge a; cf' = (aa, b); kind a = \\<Up>f;\n        slice_kind S a = \\<Up>id\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>aa b Q.\n       \\<lbrakk>\\<And>ab.\n                   transfer (slice_kind S a) ((aa, b) # cfs') =\n                   (ab, b) # cfs' \\<Longrightarrow>\n                   thesis;\n        valid_edge a; cf' = (aa, b);\n        sourcenode a\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        kind a = (Q)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa b Q.\n       \\<lbrakk>\\<And>ab.\n                   transfer (slice_kind S a) ((aa, b) # cfs') =\n                   (ab, b) # cfs' \\<Longrightarrow>\n                   thesis;\n        valid_edge a; cf' = (aa, b);\n        sourcenode a\n        \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>;\n        kind a = (Q)\\<^sub>\\<surd>\\<rbrakk>\n       \\<Longrightarrow> thesis", "by(erule kind_Predicate_notin_slice_slice_kind_Predicate) auto"], ["proof (state)\nthis:\n  transfer (slice_kind S a) s' = cfx' # cfs' \\<and> snd cfx' = snd cf'\n\ngoal (2 subgoals):\n 1. targetnode a = targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "with cfx \\<open>\\<forall>i < Suc (length cs). snd (s!i) = snd (s'!i)\\<close>"], ["proof (chain)\npicking this:\n  transfer (slice_kind S a) s = cfx # cfs \\<and> snd cfx = snd cf\n  \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i)\n  transfer (slice_kind S a) s' = cfx' # cfs' \\<and> snd cfx' = snd cf'", "have snds:\"\\<forall>i<Suc(length cs).\n          snd (transfer (slice_kind S a) s ! i) = \n          snd (transfer (slice_kind S a) s' ! i)\""], ["proof (prove)\nusing this:\n  transfer (slice_kind S a) s = cfx # cfs \\<and> snd cfx = snd cf\n  \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i)\n  transfer (slice_kind S a) s' = cfx' # cfs' \\<and> snd cfx' = snd cf'\n\ngoal (1 subgoal):\n 1. \\<forall>i<Suc (length cs).\n       snd (transfer (slice_kind S a) s ! i) =\n       snd (transfer (slice_kind S a) s' ! i)", "by auto(case_tac i,auto)"], ["proof (state)\nthis:\n  \\<forall>i<Suc (length cs).\n     snd (transfer (slice_kind S a) s ! i) =\n     snd (transfer (slice_kind S a) s' ! i)\n\ngoal (2 subgoals):\n 1. targetnode a = targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from rvs cfx cfx'"], ["proof (chain)\npicking this:\n  \\<forall>i<length cs.\n     \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n        fst (s ! Suc i) V = fst (s' ! Suc i) V\n  transfer (slice_kind S a) s = cfx # cfs \\<and> snd cfx = snd cf\n  transfer (slice_kind S a) s' = cfx' # cfs' \\<and> snd cfx' = snd cf'", "have rvs':\"\\<forall>i<length cs.\n          \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n          fst (transfer (slice_kind S a) s ! Suc i) V =\n          fst (transfer (slice_kind S a) s' ! Suc i) V\""], ["proof (prove)\nusing this:\n  \\<forall>i<length cs.\n     \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n        fst (s ! Suc i) V = fst (s' ! Suc i) V\n  transfer (slice_kind S a) s = cfx # cfs \\<and> snd cfx = snd cf\n  transfer (slice_kind S a) s' = cfx' # cfs' \\<and> snd cfx' = snd cf'\n\ngoal (1 subgoal):\n 1. \\<forall>i<length cs.\n       \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n          fst (transfer (slice_kind S a) s ! Suc i) V =\n          fst (transfer (slice_kind S a) s' ! Suc i) V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>i<length cs.\n     \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n        fst (transfer (slice_kind S a) s ! Suc i) V =\n        fst (transfer (slice_kind S a) s' ! Suc i) V\n\ngoal (2 subgoals):\n 1. targetnode a = targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>preds (slice_kinds S (a # as)) s\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S (a # as)) s", "have \"preds (slice_kinds S as) \n          (transfer (slice_kind S a) s)\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S (a # as)) s\n\ngoal (1 subgoal):\n 1. preds (slice_kinds S as) (transfer (slice_kind S a) s)", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  preds (slice_kinds S as) (transfer (slice_kind S a) s)\n\ngoal (2 subgoals):\n 1. targetnode a = targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "moreover"], ["proof (state)\nthis:\n  preds (slice_kinds S as) (transfer (slice_kind S a) s)\n\ngoal (2 subgoals):\n 1. targetnode a = targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>preds (slice_kinds S as') s'\\<close> \\<open>as' = ax # asx\\<close> \\<open>a = ax\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S as') s'\n  as' = ax # asx\n  a = ax", "have \"preds (slice_kinds S asx) (transfer (slice_kind S a) s')\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S as') s'\n  as' = ax # asx\n  a = ax\n\ngoal (1 subgoal):\n 1. preds (slice_kinds S asx) (transfer (slice_kind S a) s')", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  preds (slice_kinds S asx) (transfer (slice_kind S a) s')\n\ngoal (2 subgoals):\n 1. targetnode a = targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "moreover"], ["proof (state)\nthis:\n  preds (slice_kinds S asx) (transfer (slice_kind S a) s')\n\ngoal (2 subgoals):\n 1. targetnode a = targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  intra_kind (kind a)", "have \"length (transfer (slice_kind S a) s) = length s\""], ["proof (prove)\nusing this:\n  valid_edge a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. length (transfer (slice_kind S a) s) = length s", "by(cases \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")\n        (auto dest:slice_intra_kind_in_slice slice_kind_Upd\n          elim:kind_Predicate_notin_slice_slice_kind_Predicate simp:intra_kind_def)"], ["proof (state)\nthis:\n  length (transfer (slice_kind S a) s) = length s\n\ngoal (2 subgoals):\n 1. targetnode a = targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "with \\<open>length s = Suc (length cs)\\<close>"], ["proof (chain)\npicking this:\n  length s = Suc (length cs)\n  length (transfer (slice_kind S a) s) = length s", "have \"length (transfer (slice_kind S a) s) = Suc (length cs)\""], ["proof (prove)\nusing this:\n  length s = Suc (length cs)\n  length (transfer (slice_kind S a) s) = length s\n\ngoal (1 subgoal):\n 1. length (transfer (slice_kind S a) s) = Suc (length cs)", "by simp"], ["proof (state)\nthis:\n  length (transfer (slice_kind S a) s) = Suc (length cs)\n\ngoal (2 subgoals):\n 1. targetnode a = targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "moreover"], ["proof (state)\nthis:\n  length (transfer (slice_kind S a) s) = Suc (length cs)\n\ngoal (2 subgoals):\n 1. targetnode a = targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>a = ax\\<close> \\<open>valid_edge a\\<close> \\<open>intra_kind (kind a)\\<close>"], ["proof (chain)\npicking this:\n  a = ax\n  valid_edge a\n  intra_kind (kind a)", "have \"length (transfer (slice_kind S a) s') = length s'\""], ["proof (prove)\nusing this:\n  a = ax\n  valid_edge a\n  intra_kind (kind a)\n\ngoal (1 subgoal):\n 1. length (transfer (slice_kind S a) s') = length s'", "by(cases \"sourcenode ax \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")\n        (auto dest:slice_intra_kind_in_slice slice_kind_Upd\n          elim:kind_Predicate_notin_slice_slice_kind_Predicate simp:intra_kind_def)"], ["proof (state)\nthis:\n  length (transfer (slice_kind S a) s') = length s'\n\ngoal (2 subgoals):\n 1. targetnode a = targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "with \\<open>length s' = Suc (length cs)\\<close>"], ["proof (chain)\npicking this:\n  length s' = Suc (length cs)\n  length (transfer (slice_kind S a) s') = length s'", "have \"length (transfer (slice_kind S a) s') = Suc (length cs)\""], ["proof (prove)\nusing this:\n  length s' = Suc (length cs)\n  length (transfer (slice_kind S a) s') = length s'\n\ngoal (1 subgoal):\n 1. length (transfer (slice_kind S a) s') = Suc (length cs)", "by simp"], ["proof (state)\nthis:\n  length (transfer (slice_kind S a) s') = Suc (length cs)\n\ngoal (2 subgoals):\n 1. targetnode a = targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "moreover"], ["proof (state)\nthis:\n  length (transfer (slice_kind S a) s') = Suc (length cs)\n\ngoal (2 subgoals):\n 1. targetnode a = targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from IH[OF \\<open>upd_cs cs as = []\\<close> \\<open>same_level_path_aux cs asx\\<close> \n          \\<open>\\<forall>c\\<in>set cs. valid_edge c\\<close> \\<open>targetnode a -as\\<rightarrow>* (_Low_)\\<close> \n          \\<open>targetnode a -asx\\<rightarrow>* (_Low_)\\<close> rvs' snds rv calculation]\n          \\<open>as' = ax # asx\\<close> \\<open>a = ax\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S as) (transfer (slice_kind S a) s))\n      V =\n     state_val\n      (transfers (slice_kinds S asx) (transfer (slice_kind S a) s')) V\n  as' = ax # asx\n  a = ax", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S as) (transfer (slice_kind S a) s))\n      V =\n     state_val\n      (transfers (slice_kinds S asx) (transfer (slice_kind S a) s')) V\n  as' = ax # asx\n  a = ax\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "case False"], ["proof (state)\nthis:\n  targetnode a \\<noteq> targetnode ax\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>\\<forall>i < Suc(length cs). snd (s!i) = snd (s'!i)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i)", "have \"snd (hd s) = snd (hd s')\""], ["proof (prove)\nusing this:\n  \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i)\n\ngoal (1 subgoal):\n 1. snd (hd s) = snd (hd s')", "by(erule_tac x=\"0\" in allE) fastforce"], ["proof (state)\nthis:\n  snd (hd s) = snd (hd s')\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "with \\<open>valid_edge a\\<close> \\<open>valid_edge ax\\<close> \\<open>sourcenode a = m\\<close>\n          \\<open>sourcenode ax = m\\<close> \\<open>as' = ax # asx\\<close> False\n          \\<open>intra_kind (kind a)\\<close> \\<open>intra_kind (kind ax)\\<close>\n          \\<open>preds (slice_kinds S (a # as)) s\\<close>\n          \\<open>preds (slice_kinds S as') s'\\<close>\n          \\<open>\\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V\\<close>\n          \\<open>length s = Suc (length cs)\\<close> \\<open>length s' = Suc (length cs)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge ax\n  sourcenode a = m\n  sourcenode ax = m\n  as' = ax # asx\n  targetnode a \\<noteq> targetnode ax\n  intra_kind (kind a)\n  intra_kind (kind ax)\n  preds (slice_kinds S (a # as)) s\n  preds (slice_kinds S as') s'\n  \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V\n  length s = Suc (length cs)\n  length s' = Suc (length cs)\n  snd (hd s) = snd (hd s')", "have False"], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge ax\n  sourcenode a = m\n  sourcenode ax = m\n  as' = ax # asx\n  targetnode a \\<noteq> targetnode ax\n  intra_kind (kind a)\n  intra_kind (kind ax)\n  preds (slice_kinds S (a # as)) s\n  preds (slice_kinds S as') s'\n  \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V\n  length s = Suc (length cs)\n  length s' = Suc (length cs)\n  snd (hd s) = snd (hd s')\n\ngoal (1 subgoal):\n 1. False", "by(fastforce intro!:rv_branching_edges_slice_kinds_False[of a ax])"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> targetnode ax \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "case (slpa_Call cs a as Q r p fs)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  same_level_path_aux (a # cs) as\n  \\<lbrakk>upd_cs (a # cs) as = []; same_level_path_aux (a # cs) ?as';\n   \\<forall>a\\<in>set (a # cs). valid_edge a; ?m -as\\<rightarrow>* (_Low_);\n   ?m -?as'\\<rightarrow>* (_Low_);\n   \\<forall>i<length (a # cs).\n      \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n         fst (?s ! Suc i) V = fst (?s' ! Suc i) V;\n   \\<forall>i<Suc (length (a # cs)). snd (?s ! i) = snd (?s' ! i);\n   \\<forall>V\\<in>rv S (CFG_node ?m). state_val ?s V = state_val ?s' V;\n   preds (slice_kinds S as) ?s; preds (slice_kinds S ?as') ?s';\n   length ?s = Suc (length (a # cs));\n   length ?s' = Suc (length (a # cs))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                       state_val (transfers (slice_kinds S as) ?s) V =\n                       state_val (transfers (slice_kinds S ?as') ?s') V\n  upd_cs cs (a # as) = []\n  same_level_path_aux cs as'\n  \\<forall>a\\<in>set cs. valid_edge a\n  m -a # as\\<rightarrow>* (_Low_)\n  m -as'\\<rightarrow>* (_Low_)\n  \\<forall>i<length cs.\n     \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n        fst (s ! Suc i) V = fst (s' ! Suc i) V\n  \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i)\n  \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V\n  preds (slice_kinds S (a # as)) s\n  preds (slice_kinds S as') s'\n  length s = Suc (length cs)\n  length s' = Suc (length cs)\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "note IH = \\<open>\\<And>m as' s s'. \n    \\<lbrakk>upd_cs (a # cs) as = []; same_level_path_aux (a # cs) as';\n    \\<forall>c\\<in>set (a # cs). valid_edge c; m -as\\<rightarrow>* (_Low_); m -as'\\<rightarrow>* (_Low_);\n    \\<forall>i<length (a # cs). \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n    fst (s ! Suc i) V = fst (s' ! Suc i) V;\n    \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n    \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n    preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n    length s = Suc (length (a # cs)); length s' = Suc (length (a # cs))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_). state_val (transfers(slice_kinds S as) s) V =\n    state_val (transfers(slice_kinds S as') s') V\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>upd_cs (a # cs) as = []; same_level_path_aux (a # cs) ?as';\n   \\<forall>c\\<in>set (a # cs). valid_edge c; ?m -as\\<rightarrow>* (_Low_);\n   ?m -?as'\\<rightarrow>* (_Low_);\n   \\<forall>i<length (a # cs).\n      \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n         fst (?s ! Suc i) V = fst (?s' ! Suc i) V;\n   \\<forall>i<Suc (length (a # cs)). snd (?s ! i) = snd (?s' ! i);\n   \\<forall>V\\<in>rv S (CFG_node ?m). state_val ?s V = state_val ?s' V;\n   preds (slice_kinds S as) ?s; preds (slice_kinds S ?as') ?s';\n   length ?s = Suc (length (a # cs));\n   length ?s' = Suc (length (a # cs))\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                       state_val (transfers (slice_kinds S as) ?s) V =\n                       state_val (transfers (slice_kinds S ?as') ?s') V\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "note rvs = \\<open>\\<forall>i<length cs. \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n    fst (s ! Suc i) V = fst (s' ! Suc i) V\\<close>"], ["proof (state)\nthis:\n  \\<forall>i<length cs.\n     \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n        fst (s ! Suc i) V = fst (s' ! Suc i) V\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "from \\<open>m -a # as\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  m -a # as\\<rightarrow>* (_Low_)", "have \"sourcenode a = m\" and \"valid_edge a\"\n    and \"targetnode a -as\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  m -a # as\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. sourcenode a = m &&&\n    valid_edge a &&& targetnode a -as\\<rightarrow>* (_Low_)", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  sourcenode a = m\n  valid_edge a\n  targetnode a -as\\<rightarrow>* (_Low_)\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "from \\<open>\\<forall>c\\<in>set cs. valid_edge c\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>c\\<in>set cs. valid_edge c\n  valid_edge a", "have \"\\<forall>c\\<in>set (a # cs). valid_edge c\""], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>set cs. valid_edge c\n  valid_edge a\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set (a # cs). valid_edge c", "by simp"], ["proof (state)\nthis:\n  \\<forall>c\\<in>set (a # cs). valid_edge c\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q r p fs m as' s s'.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        same_level_path_aux (a # cs) as;\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs (a # cs) as = [];\n            same_level_path_aux (a # cs) as';\n            Ball (set (a # cs)) valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length (a # cs).\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length (a # cs));\n            length s' = Suc (length (a # cs))\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "proof(cases \"L = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. L = {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "case True"], ["proof (state)\nthis:\n  L = {}\n\ngoal (2 subgoals):\n 1. L = {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "with UseLow"], ["proof (chain)\npicking this:\n  Use (_Low_) = L\n  L = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  Use (_Low_) = L\n  L = {}\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "case False"], ["proof (state)\nthis:\n  L \\<noteq> {}\n\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "proof(cases as')"], ["proof (state)\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "case Nil"], ["proof (state)\nthis:\n  as' = []\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>m -as'\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  m -as'\\<rightarrow>* (_Low_)\n  as' = []", "have \"m = (_Low_)\""], ["proof (prove)\nusing this:\n  m -as'\\<rightarrow>* (_Low_)\n  as' = []\n\ngoal (1 subgoal):\n 1. m = (_Low_)", "by fastforce"], ["proof (state)\nthis:\n  m = (_Low_)\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>valid_edge a\\<close> \\<open>sourcenode a = m\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = m\n  m = (_Low_)", "have \"targetnode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = m\n  m = (_Low_)\n\ngoal (1 subgoal):\n 1. targetnode a = (_Exit_)", "by -(rule Exit_successor_of_Low,simp+)"], ["proof (state)\nthis:\n  targetnode a = (_Exit_)\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from Low_source_Exit_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Low_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>", "obtain a' where \"valid_edge a'\"\n        and \"sourcenode a' = (_Low_)\" and \"targetnode a' = (_Exit_)\"\n        and \"kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Low_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>valid_edge a'; sourcenode a' = (_Low_);\n         targetnode a' = (_Exit_);\n         kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_edge a'\n  sourcenode a' = (_Low_)\n  targetnode a' = (_Exit_)\n  kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>valid_edge a\\<close> \\<open>sourcenode a = m\\<close> \\<open>m = (_Low_)\\<close> \n        \\<open>targetnode a = (_Exit_)\\<close> \\<open>valid_edge a'\\<close> \\<open>sourcenode a' = (_Low_)\\<close> \n        \\<open>targetnode a' = (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = m\n  m = (_Low_)\n  targetnode a = (_Exit_)\n  valid_edge a'\n  sourcenode a' = (_Low_)\n  targetnode a' = (_Exit_)", "have \"a = a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = m\n  m = (_Low_)\n  targetnode a = (_Exit_)\n  valid_edge a'\n  sourcenode a' = (_Low_)\n  targetnode a' = (_Exit_)\n\ngoal (1 subgoal):\n 1. a = a'", "by(fastforce dest:edge_det)"], ["proof (state)\nthis:\n  a = a'\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n  a = a'", "have \"kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n  a = a'\n\ngoal (1 subgoal):\n 1. kind a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by simp"], ["proof (state)\nthis:\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>targetnode a = (_Exit_)\\<close> \\<open>targetnode a -as\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  targetnode a = (_Exit_)\n  targetnode a -as\\<rightarrow>* (_Low_)\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>", "have \"(_Low_) = (_Exit_)\""], ["proof (prove)\nusing this:\n  targetnode a = (_Exit_)\n  targetnode a -as\\<rightarrow>* (_Low_)\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (_Low_) = (_Exit_)", "by -(drule path_Exit_source,auto)"], ["proof (state)\nthis:\n  (_Low_) = (_Exit_)\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with False"], ["proof (chain)\npicking this:\n  L \\<noteq> {}\n  (_Low_) = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  L \\<noteq> {}\n  (_Low_) = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by -(drule Low_neq_Exit,simp)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "case (Cons ax asx)"], ["proof (state)\nthis:\n  as' = ax # asx\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>m -as'\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  m -as'\\<rightarrow>* (_Low_)\n  as' = ax # asx", "have \"sourcenode ax = m\" and \"valid_edge ax\"\n        and \"targetnode ax -asx\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  m -as'\\<rightarrow>* (_Low_)\n  as' = ax # asx\n\ngoal (1 subgoal):\n 1. sourcenode ax = m &&&\n    valid_edge ax &&& targetnode ax -asx\\<rightarrow>* (_Low_)", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  sourcenode ax = m\n  valid_edge ax\n  targetnode ax -asx\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>preds (slice_kinds S (a # as)) s\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S (a # as)) s", "obtain cf cfs where [simp]:\"s = cf#cfs\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S (a # as)) s\n\ngoal (1 subgoal):\n 1. (\\<And>cf cfs. s = cf # cfs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s)(auto simp:slice_kinds_def)"], ["proof (state)\nthis:\n  s = cf # cfs\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>preds (slice_kinds S as') s'\\<close> \\<open>as' = ax # asx\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S as') s'\n  as' = ax # asx", "obtain cf' cfs' where [simp]:\"s' = cf'#cfs'\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S as') s'\n  as' = ax # asx\n\ngoal (1 subgoal):\n 1. (\\<And>cf' cfs'.\n        s' = cf' # cfs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s')(auto simp:slice_kinds_def)"], ["proof (state)\nthis:\n  s' = cf' # cfs'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "have \"\\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "proof(cases \"kind ax\" rule:edge_kind_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. intra_kind (kind ax) \\<Longrightarrow>\n    \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 2. \\<And>Q r p fs.\n       kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 3. \\<And>Q p f.\n       kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "case Intra"], ["proof (state)\nthis:\n  intra_kind (kind ax)\n\ngoal (3 subgoals):\n 1. intra_kind (kind ax) \\<Longrightarrow>\n    \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 2. \\<And>Q r p fs.\n       kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 3. \\<And>Q p f.\n       kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases \"sourcenode ax \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode ax\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode ax\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "case True"], ["proof (state)\nthis:\n  sourcenode ax \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. sourcenode ax\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode ax\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>intra_kind (kind ax)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind ax)\n  sourcenode ax \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"slice_kind S ax = kind ax\""], ["proof (prove)\nusing this:\n  intra_kind (kind ax)\n  sourcenode ax \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. slice_kind S ax = kind ax", "by -(rule slice_intra_kind_in_slice)"], ["proof (state)\nthis:\n  slice_kind S ax = kind ax\n\ngoal (2 subgoals):\n 1. sourcenode ax\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode ax\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have unique:\"\\<exists>!a'. valid_edge a' \\<and> sourcenode a' = sourcenode a \\<and> \n            intra_kind(kind a')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       valid_edge a' \\<and>\n       sourcenode a' = sourcenode a \\<and> intra_kind (kind a')", "by(rule call_only_one_intra_edge)"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     valid_edge a' \\<and>\n     sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\n\ngoal (2 subgoals):\n 1. sourcenode ax\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode ax\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain x \n            where \"x \\<in> get_return_edges a\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> get_return_edges a \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:get_return_edge_call)"], ["proof (state)\nthis:\n  x \\<in> get_return_edges a\n\ngoal (2 subgoals):\n 1. sourcenode ax\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode ax\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  x \\<in> get_return_edges a", "obtain a' where \"valid_edge a'\" \n            and \"sourcenode a' = sourcenode a\" and \"kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  valid_edge a\n  x \\<in> get_return_edges a\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>valid_edge a'; sourcenode a' = sourcenode a;\n         kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:call_return_node_edge)"], ["proof (state)\nthis:\n  valid_edge a'\n  sourcenode a' = sourcenode a\n  kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. sourcenode ax\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode ax\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>valid_edge ax\\<close> \\<open>sourcenode ax = m\\<close> \\<open>sourcenode a = m\\<close>\n            \\<open>intra_kind (kind ax)\\<close> unique"], ["proof (chain)\npicking this:\n  valid_edge ax\n  sourcenode ax = m\n  sourcenode a = m\n  intra_kind (kind ax)\n  \\<exists>!a'.\n     valid_edge a' \\<and>\n     sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\n  valid_edge a'\n  sourcenode a' = sourcenode a\n  kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "have \"a' = ax\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  sourcenode ax = m\n  sourcenode a = m\n  intra_kind (kind ax)\n  \\<exists>!a'.\n     valid_edge a' \\<and>\n     sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\n  valid_edge a'\n  sourcenode a' = sourcenode a\n  kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. a' = ax", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  a' = ax\n\ngoal (2 subgoals):\n 1. sourcenode ax\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode ax\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<close> \n            \\<open>slice_kind S ax = kind ax\\<close> \\<open>as' = ax # asx\\<close>\n            \\<open>preds (slice_kinds S as') s'\\<close>"], ["proof (chain)\npicking this:\n  kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  slice_kind S ax = kind ax\n  as' = ax # asx\n  preds (slice_kinds S as') s'\n  a' = ax", "have False"], ["proof (prove)\nusing this:\n  kind a' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  slice_kind S ax = kind ax\n  as' = ax # asx\n  preds (slice_kinds S as') s'\n  a' = ax\n\ngoal (1 subgoal):\n 1. False", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. sourcenode ax\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False\n 2. sourcenode ax\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. sourcenode ax\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode ax\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "case False"], ["proof (state)\nthis:\n  sourcenode ax \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode ax\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>sourcenode ax = m\\<close> \\<open>sourcenode a = m\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode ax = m\n  sourcenode a = m\n  sourcenode ax \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"slice_kind S a = (\\<lambda>cf. False):r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode ax = m\n  sourcenode a = m\n  sourcenode ax \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. slice_kind S a =\n    \\<lambda>cf. False:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "by(fastforce intro:slice_kind_Call)"], ["proof (state)\nthis:\n  slice_kind S a = \\<lambda>cf. False:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. sourcenode ax\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>preds (slice_kinds S (a # as)) s\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S (a # as)) s\n  slice_kind S a = \\<lambda>cf. False:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have False"], ["proof (prove)\nusing this:\n  preds (slice_kinds S (a # as)) s\n  slice_kind S a = \\<lambda>cf. False:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. False", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. sourcenode ax\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. intra_kind (kind ax) \\<Longrightarrow>\n    \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 2. \\<And>Q r p fs.\n       kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 3. \\<And>Q p f.\n       kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 2. \\<And>Q p f.\n       kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 2. \\<And>Q p f.\n       kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "case (Return Q' p' f')"], ["proof (state)\nthis:\n  kind ax = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 2. \\<And>Q p f.\n       kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "from \\<open>valid_edge ax\\<close> \\<open>kind ax = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\\<close> \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>\n          \\<open>sourcenode a = m\\<close> \\<open>sourcenode ax = m\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  kind ax = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a = m\n  sourcenode ax = m", "have False"], ["proof (prove)\nusing this:\n  valid_edge ax\n  kind ax = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a = m\n  sourcenode ax = m\n\ngoal (1 subgoal):\n 1. False", "by -(drule return_edges_only,auto)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>Q r p fs.\n       kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 2. \\<And>Q p f.\n       kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f \\<Longrightarrow>\n       \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<And>Q r p fs.\n       kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n       \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "qed simp"], ["proof (state)\nthis:\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "have \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "assume \"sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "from this \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"slice_kind S a = (\\<lambda>cf. False):r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. slice_kind S a =\n    \\<lambda>cf. False:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "by(rule slice_kind_Call)"], ["proof (state)\nthis:\n  slice_kind S a = \\<lambda>cf. False:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    False", "with \\<open>preds (slice_kinds S (a # as)) s\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S (a # as)) s\n  slice_kind S a = \\<lambda>cf. False:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "show False"], ["proof (prove)\nusing this:\n  preds (slice_kinds S (a # as)) s\n  slice_kind S a = \\<lambda>cf. False:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. False", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>preds (slice_kinds S (a # as)) s\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S (a # as)) s\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"pred (kind a) s\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S (a # as)) s\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. pred (kind a) s", "by(fastforce dest:slice_kind_Call_in_slice simp:slice_kinds_def)"], ["proof (state)\nthis:\n  pred (kind a) s\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n        \\<open>sourcenode a = m\\<close> \\<open>sourcenode ax = m\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  sourcenode a = m\n  sourcenode ax = m", "have \"sourcenode ax \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  sourcenode a = m\n  sourcenode ax = m\n\ngoal (1 subgoal):\n 1. sourcenode ax \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "by simp"], ["proof (state)\nthis:\n  sourcenode ax \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>as' = ax # asx\\<close> \\<open>preds (slice_kinds S as') s'\\<close> \n        \\<open>\\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  as' = ax # asx\n  preds (slice_kinds S as') s'\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode ax \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"pred (kind ax) s'\""], ["proof (prove)\nusing this:\n  as' = ax # asx\n  preds (slice_kinds S as') s'\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode ax \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. pred (kind ax) s'", "by(fastforce dest:slice_kind_Call_in_slice simp:slice_kinds_def)"], ["proof (state)\nthis:\n  pred (kind ax) s'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "{"], ["proof (state)\nthis:\n  pred (kind ax) s'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "fix V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "assume \"V \\<in> Use (sourcenode a)\""], ["proof (state)\nthis:\n  V \\<in> Use (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a", "by(fastforce intro:empty_path simp:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n          \\<open>valid_edge a\\<close> \\<open>V \\<in> Use (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_edge a\n  V \\<in> Use (sourcenode a)\n  sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a", "have \"V \\<in> rv S (CFG_node (sourcenode a))\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_edge a\n  V \\<in> Use (sourcenode a)\n  sourcenode a -[]\\<rightarrow>\\<^sub>\\<iota>* sourcenode a\n\ngoal (1 subgoal):\n 1. V \\<in> rv S (CFG_node (sourcenode a))", "by(auto intro!:rvI CFG_Use_SDG_Use simp:SDG_to_CFG_set_def sourcenodes_def)"], ["proof (state)\nthis:\n  V \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "}"], ["proof (state)\nthis:\n  ?V2 \\<in> Use (sourcenode a) \\<Longrightarrow>\n  ?V2 \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>\\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V\\<close>\n        \\<open>sourcenode a = m\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V\n  sourcenode a = m\n  ?V2 \\<in> Use (sourcenode a) \\<Longrightarrow>\n  ?V2 \\<in> rv S (CFG_node (sourcenode a))", "have Use:\"\\<forall>V \\<in> Use (sourcenode a). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V\n  sourcenode a = m\n  ?V2 \\<in> Use (sourcenode a) \\<Longrightarrow>\n  ?V2 \\<in> rv S (CFG_node (sourcenode a))\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>\\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i)", "have \"snd (hd s) = snd (hd s')\""], ["proof (prove)\nusing this:\n  \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i)\n\ngoal (1 subgoal):\n 1. snd (hd s) = snd (hd s')", "by fastforce"], ["proof (state)\nthis:\n  snd (hd s) = snd (hd s')\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>valid_edge ax\\<close>\n        \\<open>\\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>sourcenode a = m\\<close> \\<open>sourcenode ax = m\\<close>\n        \\<open>pred (kind a) s\\<close> \\<open>pred (kind ax) s'\\<close> Use \\<open>length s = Suc (length cs)\\<close>\n        \\<open>length s' = Suc (length cs)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge ax\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a = m\n  sourcenode ax = m\n  pred (kind a) s\n  pred (kind ax) s'\n  \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V\n  length s = Suc (length cs)\n  length s' = Suc (length cs)\n  snd (hd s) = snd (hd s')", "have [simp]:\"ax = a\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge ax\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a = m\n  sourcenode ax = m\n  pred (kind a) s\n  pred (kind ax) s'\n  \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V\n  length s = Suc (length cs)\n  length s' = Suc (length cs)\n  snd (hd s) = snd (hd s')\n\ngoal (1 subgoal):\n 1. ax = a", "by(fastforce intro!:CFG_equal_Use_equal_call)"], ["proof (state)\nthis:\n  ax = a\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>same_level_path_aux cs as'\\<close> \\<open>as' = ax#asx\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>\n        \\<open>\\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  same_level_path_aux cs as'\n  as' = ax # asx\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"same_level_path_aux (a # cs) asx\""], ["proof (prove)\nusing this:\n  same_level_path_aux cs as'\n  as' = ax # asx\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. same_level_path_aux (a # cs) asx", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux (a # cs) asx\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>targetnode ax -asx\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  targetnode ax -asx\\<rightarrow>* (_Low_)", "have \"targetnode a -asx\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  targetnode ax -asx\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. targetnode a -asx\\<rightarrow>* (_Low_)", "by simp"], ["proof (state)\nthis:\n  targetnode a -asx\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>upd_cs cs (a # as) = []\\<close>"], ["proof (chain)\npicking this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_cs cs (a # as) = []", "have \"upd_cs (a # cs) as = []\""], ["proof (prove)\nusing this:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  upd_cs cs (a # as) = []\n\ngoal (1 subgoal):\n 1. upd_cs (a # cs) as = []", "by simp"], ["proof (state)\nthis:\n  upd_cs (a # cs) as = []\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have slice_kind:\"slice_kind S a = \n        Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>(cspp (targetnode a) (HRB_slice S) fs)\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. slice_kind S a =\n    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>cspp (targetnode a) (HRB_slice S)\n    fs", "by(rule slice_kind_Call_in_slice)"], ["proof (state)\nthis:\n  slice_kind S a =\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>cspp (targetnode a) (HRB_slice S) fs\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>\\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i)\\<close> slice_kind"], ["proof (chain)\npicking this:\n  \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i)\n  slice_kind S a =\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>cspp (targetnode a) (HRB_slice S) fs", "have snds:\"\\<forall>i<Suc (length (a # cs)).\n        snd (transfer (slice_kind S a) s ! i) =\n        snd (transfer (slice_kind S a) s' ! i)\""], ["proof (prove)\nusing this:\n  \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i)\n  slice_kind S a =\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>cspp (targetnode a) (HRB_slice S) fs\n\ngoal (1 subgoal):\n 1. \\<forall>i<Suc (length (a # cs)).\n       snd (transfer (slice_kind S a) s ! i) =\n       snd (transfer (slice_kind S a) s' ! i)", "by auto(case_tac i,auto)"], ["proof (state)\nthis:\n  \\<forall>i<Suc (length (a # cs)).\n     snd (transfer (slice_kind S a) s ! i) =\n     snd (transfer (slice_kind S a) s' ! i)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain ins outs \n        where \"(p,ins,outs) \\<in> set procs\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>ins outs.\n        (p, ins, outs) \\<in> set procs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:callee_in_procs)"], ["proof (state)\nthis:\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs", "have \"length (ParamUses (sourcenode a)) = length ins\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. length (ParamUses (sourcenode a)) = length ins", "by(fastforce intro:ParamUses_call_source_length)"], ["proof (state)\nthis:\n  length (ParamUses (sourcenode a)) = length ins\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  length (ParamUses (sourcenode a)) = length ins", "have \"\\<forall>i < length ins. \\<forall>V \\<in> (ParamUses (sourcenode a))!i. V \\<in> Use (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  length (ParamUses (sourcenode a)) = length ins\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ins.\n       \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n          V \\<in> Use (sourcenode a)", "by(fastforce intro:ParamUses_in_Use)"], ["proof (state)\nthis:\n  \\<forall>i<length ins.\n     \\<forall>V\\<in>ParamUses (sourcenode a) ! i. V \\<in> Use (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>\\<forall>V \\<in> Use (sourcenode a). state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V\n  \\<forall>i<length ins.\n     \\<forall>V\\<in>ParamUses (sourcenode a) ! i. V \\<in> Use (sourcenode a)", "have \"\\<forall>i < length ins. \\<forall>V \\<in> (ParamUses (sourcenode a))!i. \n        state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V\n  \\<forall>i<length ins.\n     \\<forall>V\\<in>ParamUses (sourcenode a) ! i. V \\<in> Use (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ins.\n       \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n          state_val s V = state_val s' V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>i<length ins.\n     \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n        state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>\n        \\<open>pred (kind a) s\\<close> \\<open>pred (kind ax) s'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n  pred (kind a) s\n  pred (kind ax) s'\n  \\<forall>i<length ins.\n     \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n        state_val s V = state_val s' V", "have \"\\<forall>i < length ins. (params fs (fst (hd s)))!i = (params fs (fst (hd s')))!i\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n  pred (kind a) s\n  pred (kind ax) s'\n  \\<forall>i<length ins.\n     \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n        state_val s V = state_val s' V\n\ngoal (1 subgoal):\n 1. \\<forall>i<length ins.\n       params fs (state_val s) ! i = params fs (state_val s') ! i", "by(fastforce intro!:CFG_call_edge_params)"], ["proof (state)\nthis:\n  \\<forall>i<length ins.\n     params fs (state_val s) ! i = params fs (state_val s') ! i\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs", "have \"length fs = length ins\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. length fs = length ins", "by(rule CFG_call_edge_length)"], ["proof (state)\nthis:\n  length fs = length ins\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "{"], ["proof (state)\nthis:\n  length fs = length ins\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "assume \"i < length fs\""], ["proof (state)\nthis:\n  i < length fs\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>length fs = length ins\\<close>"], ["proof (chain)\npicking this:\n  length fs = length ins\n  i < length fs", "have \"i < length ins\""], ["proof (prove)\nusing this:\n  length fs = length ins\n  i < length fs\n\ngoal (1 subgoal):\n 1. i < length ins", "by simp"], ["proof (state)\nthis:\n  i < length ins\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>i < length fs\\<close>"], ["proof (chain)\npicking this:\n  i < length fs", "have \"(params fs (fst cf))!i = (fs!i) (fst cf)\""], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. params fs (fst cf) ! i = (fs ! i) (fst cf)", "by(rule params_nth)"], ["proof (state)\nthis:\n  params fs (fst cf) ! i = (fs ! i) (fst cf)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "moreover"], ["proof (state)\nthis:\n  params fs (fst cf) ! i = (fs ! i) (fst cf)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>i < length fs\\<close>"], ["proof (chain)\npicking this:\n  i < length fs", "have \"(params fs (fst cf'))!i = (fs!i) (fst cf')\""], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. params fs (fst cf') ! i = (fs ! i) (fst cf')", "by(rule params_nth)"], ["proof (state)\nthis:\n  params fs (fst cf') ! i = (fs ! i) (fst cf')\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "ultimately"], ["proof (chain)\npicking this:\n  params fs (fst cf) ! i = (fs ! i) (fst cf)\n  params fs (fst cf') ! i = (fs ! i) (fst cf')", "have \"(fs!i) (fst (hd s)) = (fs!i) (fst (hd s'))\""], ["proof (prove)\nusing this:\n  params fs (fst cf) ! i = (fs ! i) (fst cf)\n  params fs (fst cf') ! i = (fs ! i) (fst cf')\n\ngoal (1 subgoal):\n 1. (fs ! i) (state_val s) = (fs ! i) (state_val s')", "using \\<open>i < length ins\\<close>\n            \\<open>\\<forall>i < length ins. (params fs (fst (hd s)))!i = (params fs (fst (hd s')))!i\\<close>"], ["proof (prove)\nusing this:\n  params fs (fst cf) ! i = (fs ! i) (fst cf)\n  params fs (fst cf') ! i = (fs ! i) (fst cf')\n  i < length ins\n  \\<forall>i<length ins.\n     params fs (state_val s) ! i = params fs (state_val s') ! i\n\ngoal (1 subgoal):\n 1. (fs ! i) (state_val s) = (fs ! i) (state_val s')", "by simp"], ["proof (state)\nthis:\n  (fs ! i) (state_val s) = (fs ! i) (state_val s')\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "}"], ["proof (state)\nthis:\n  ?i2 < length fs \\<Longrightarrow>\n  (fs ! ?i2) (state_val s) = (fs ! ?i2) (state_val s')\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "hence \"\\<forall>i < length fs. (fs ! i) (fst cf) = (fs ! i) (fst cf')\""], ["proof (prove)\nusing this:\n  ?i2 < length fs \\<Longrightarrow>\n  (fs ! ?i2) (state_val s) = (fs ! ?i2) (state_val s')\n\ngoal (1 subgoal):\n 1. \\<forall>i<length fs. (fs ! i) (fst cf) = (fs ! i) (fst cf')", "by simp"], ["proof (state)\nthis:\n  \\<forall>i<length fs. (fs ! i) (fst cf) = (fs ! i) (fst cf')\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "{"], ["proof (state)\nthis:\n  \\<forall>i<length fs. (fs ! i) (fst cf) = (fs ! i) (fst cf')\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "assume \"i < length fs\""], ["proof (state)\nthis:\n  i < length fs\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>\\<forall>i < length fs. (fs ! i) (fst cf) = (fs ! i) (fst cf')\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length fs. (fs ! i) (fst cf) = (fs ! i) (fst cf')\n  i < length fs", "have \"(fs ! i) (fst cf) = (fs ! i) (fst cf')\""], ["proof (prove)\nusing this:\n  \\<forall>i<length fs. (fs ! i) (fst cf) = (fs ! i) (fst cf')\n  i < length fs\n\ngoal (1 subgoal):\n 1. (fs ! i) (fst cf) = (fs ! i) (fst cf')", "by simp"], ["proof (state)\nthis:\n  (fs ! i) (fst cf) = (fs ! i) (fst cf')\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "have \"((csppa (targetnode a) (HRB_slice S) 0 fs)!i)(fst cf) =\n          ((csppa (targetnode a) (HRB_slice S) 0 fs)!i)(fst cf')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf) =\n    (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf')", "proof(cases \"Formal_in(targetnode a,i + 0) \\<in>  HRB_slice S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Formal_in (targetnode a, i + 0) \\<in> HRB_slice S \\<Longrightarrow>\n    (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf) =\n    (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf')\n 2. Formal_in (targetnode a, i + 0) \\<notin> HRB_slice S \\<Longrightarrow>\n    (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf) =\n    (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf')", "case True"], ["proof (state)\nthis:\n  Formal_in (targetnode a, i + 0) \\<in> HRB_slice S\n\ngoal (2 subgoals):\n 1. Formal_in (targetnode a, i + 0) \\<in> HRB_slice S \\<Longrightarrow>\n    (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf) =\n    (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf')\n 2. Formal_in (targetnode a, i + 0) \\<notin> HRB_slice S \\<Longrightarrow>\n    (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf) =\n    (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf')", "with \\<open>i < length fs\\<close>"], ["proof (chain)\npicking this:\n  i < length fs\n  Formal_in (targetnode a, i + 0) \\<in> HRB_slice S", "have \"(csppa (targetnode a) (HRB_slice S) 0 fs)!i = fs!i\""], ["proof (prove)\nusing this:\n  i < length fs\n  Formal_in (targetnode a, i + 0) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. csppa (targetnode a) (HRB_slice S) 0 fs ! i = fs ! i", "by(rule csppa_Formal_in_in_slice)"], ["proof (state)\nthis:\n  csppa (targetnode a) (HRB_slice S) 0 fs ! i = fs ! i\n\ngoal (2 subgoals):\n 1. Formal_in (targetnode a, i + 0) \\<in> HRB_slice S \\<Longrightarrow>\n    (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf) =\n    (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf')\n 2. Formal_in (targetnode a, i + 0) \\<notin> HRB_slice S \\<Longrightarrow>\n    (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf) =\n    (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf')", "with \\<open>(fs ! i) (fst cf) = (fs ! i) (fst cf')\\<close>"], ["proof (chain)\npicking this:\n  (fs ! i) (fst cf) = (fs ! i) (fst cf')\n  csppa (targetnode a) (HRB_slice S) 0 fs ! i = fs ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  (fs ! i) (fst cf) = (fs ! i) (fst cf')\n  csppa (targetnode a) (HRB_slice S) 0 fs ! i = fs ! i\n\ngoal (1 subgoal):\n 1. (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf) =\n    (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf')", "by simp"], ["proof (state)\nthis:\n  (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf) =\n  (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf')\n\ngoal (1 subgoal):\n 1. Formal_in (targetnode a, i + 0) \\<notin> HRB_slice S \\<Longrightarrow>\n    (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf) =\n    (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Formal_in (targetnode a, i + 0) \\<notin> HRB_slice S \\<Longrightarrow>\n    (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf) =\n    (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf')", "case False"], ["proof (state)\nthis:\n  Formal_in (targetnode a, i + 0) \\<notin> HRB_slice S\n\ngoal (1 subgoal):\n 1. Formal_in (targetnode a, i + 0) \\<notin> HRB_slice S \\<Longrightarrow>\n    (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf) =\n    (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf')", "with \\<open>i < length fs\\<close>"], ["proof (chain)\npicking this:\n  i < length fs\n  Formal_in (targetnode a, i + 0) \\<notin> HRB_slice S", "have \"(csppa (targetnode a) (HRB_slice S) 0 fs)!i = Map.empty\""], ["proof (prove)\nusing this:\n  i < length fs\n  Formal_in (targetnode a, i + 0) \\<notin> HRB_slice S\n\ngoal (1 subgoal):\n 1. csppa (targetnode a) (HRB_slice S) 0 fs ! i = Map.empty", "by(rule csppa_Formal_in_notin_slice)"], ["proof (state)\nthis:\n  csppa (targetnode a) (HRB_slice S) 0 fs ! i = Map.empty\n\ngoal (1 subgoal):\n 1. Formal_in (targetnode a, i + 0) \\<notin> HRB_slice S \\<Longrightarrow>\n    (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf) =\n    (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf')", "thus ?thesis"], ["proof (prove)\nusing this:\n  csppa (targetnode a) (HRB_slice S) 0 fs ! i = Map.empty\n\ngoal (1 subgoal):\n 1. (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf) =\n    (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf')", "by simp"], ["proof (state)\nthis:\n  (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf) =\n  (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf) =\n  (csppa (targetnode a) (HRB_slice S) 0 fs ! i) (fst cf')\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "}"], ["proof (state)\nthis:\n  ?i2 < length fs \\<Longrightarrow>\n  (csppa (targetnode a) (HRB_slice S) 0 fs ! ?i2) (fst cf) =\n  (csppa (targetnode a) (HRB_slice S) 0 fs ! ?i2) (fst cf')\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "hence eq:\"\\<forall>i < length fs.\n        ((cspp (targetnode a) (HRB_slice S) fs)!i)(fst cf) =\n        ((cspp (targetnode a) (HRB_slice S) fs)!i)(fst cf')\""], ["proof (prove)\nusing this:\n  ?i2 < length fs \\<Longrightarrow>\n  (csppa (targetnode a) (HRB_slice S) 0 fs ! ?i2) (fst cf) =\n  (csppa (targetnode a) (HRB_slice S) 0 fs ! ?i2) (fst cf')\n\ngoal (1 subgoal):\n 1. \\<forall>i<length fs.\n       (cspp (targetnode a) (HRB_slice S) fs ! i) (fst cf) =\n       (cspp (targetnode a) (HRB_slice S) fs ! i) (fst cf')", "by(simp add:cspp_def)"], ["proof (state)\nthis:\n  \\<forall>i<length fs.\n     (cspp (targetnode a) (HRB_slice S) fs ! i) (fst cf) =\n     (cspp (targetnode a) (HRB_slice S) fs ! i) (fst cf')\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "{"], ["proof (state)\nthis:\n  \\<forall>i<length fs.\n     (cspp (targetnode a) (HRB_slice S) fs ! i) (fst cf) =\n     (cspp (targetnode a) (HRB_slice S) fs ! i) (fst cf')\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "assume \"i < length fs\""], ["proof (state)\nthis:\n  i < length fs\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "hence \"(params (cspp (targetnode a) (HRB_slice S) fs)\n          (fst cf))!i =\n          ((cspp (targetnode a) (HRB_slice S) fs)!i)(fst cf)\""], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. params (cspp (targetnode a) (HRB_slice S) fs) (fst cf) ! i =\n    (cspp (targetnode a) (HRB_slice S) fs ! i) (fst cf)", "by(fastforce intro:params_nth)"], ["proof (state)\nthis:\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf) ! i =\n  (cspp (targetnode a) (HRB_slice S) fs ! i) (fst cf)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "moreover"], ["proof (state)\nthis:\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf) ! i =\n  (cspp (targetnode a) (HRB_slice S) fs ! i) (fst cf)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>i < length fs\\<close>"], ["proof (chain)\npicking this:\n  i < length fs", "have \"(params (cspp (targetnode a) (HRB_slice S) fs)\n          (fst cf'))!i =\n          ((cspp (targetnode a) (HRB_slice S) fs)!i)(fst cf')\""], ["proof (prove)\nusing this:\n  i < length fs\n\ngoal (1 subgoal):\n 1. params (cspp (targetnode a) (HRB_slice S) fs) (fst cf') ! i =\n    (cspp (targetnode a) (HRB_slice S) fs ! i) (fst cf')", "by(fastforce intro:params_nth)"], ["proof (state)\nthis:\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf') ! i =\n  (cspp (targetnode a) (HRB_slice S) fs ! i) (fst cf')\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "ultimately"], ["proof (chain)\npicking this:\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf) ! i =\n  (cspp (targetnode a) (HRB_slice S) fs ! i) (fst cf)\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf') ! i =\n  (cspp (targetnode a) (HRB_slice S) fs ! i) (fst cf')", "have \"(params (cspp (targetnode a) (HRB_slice S) fs)\n          (fst cf))!i =\n          (params (cspp (targetnode a) (HRB_slice S) fs)(fst cf'))!i\""], ["proof (prove)\nusing this:\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf) ! i =\n  (cspp (targetnode a) (HRB_slice S) fs ! i) (fst cf)\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf') ! i =\n  (cspp (targetnode a) (HRB_slice S) fs ! i) (fst cf')\n\ngoal (1 subgoal):\n 1. params (cspp (targetnode a) (HRB_slice S) fs) (fst cf) ! i =\n    params (cspp (targetnode a) (HRB_slice S) fs) (fst cf') ! i", "using eq \\<open>i < length fs\\<close>"], ["proof (prove)\nusing this:\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf) ! i =\n  (cspp (targetnode a) (HRB_slice S) fs ! i) (fst cf)\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf') ! i =\n  (cspp (targetnode a) (HRB_slice S) fs ! i) (fst cf')\n  \\<forall>i<length fs.\n     (cspp (targetnode a) (HRB_slice S) fs ! i) (fst cf) =\n     (cspp (targetnode a) (HRB_slice S) fs ! i) (fst cf')\n  i < length fs\n\ngoal (1 subgoal):\n 1. params (cspp (targetnode a) (HRB_slice S) fs) (fst cf) ! i =\n    params (cspp (targetnode a) (HRB_slice S) fs) (fst cf') ! i", "by simp"], ["proof (state)\nthis:\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf) ! i =\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf') ! i\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "}"], ["proof (state)\nthis:\n  ?i2 < length fs \\<Longrightarrow>\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf) ! ?i2 =\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf') ! ?i2\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "hence \"params (cspp (targetnode a) (HRB_slice S) fs)(fst cf) =\n        params (cspp (targetnode a) (HRB_slice S) fs)(fst cf')\""], ["proof (prove)\nusing this:\n  ?i2 < length fs \\<Longrightarrow>\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf) ! ?i2 =\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf') ! ?i2\n\ngoal (1 subgoal):\n 1. params (cspp (targetnode a) (HRB_slice S) fs) (fst cf) =\n    params (cspp (targetnode a) (HRB_slice S) fs) (fst cf')", "by(simp add:list_eq_iff_nth_eq)"], ["proof (state)\nthis:\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf) =\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf')\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with slice_kind \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  slice_kind S a =\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>cspp (targetnode a) (HRB_slice S) fs\n  (p, ins, outs) \\<in> set procs\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf) =\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf')", "obtain cfx where [simp]:\n        \"transfer (slice_kind S a) (cf#cfs) = cfx#cf#cfs\"\n        \"transfer (slice_kind S a) (cf'#cfs') = cfx#cf'#cfs'\""], ["proof (prove)\nusing this:\n  slice_kind S a =\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>cspp (targetnode a) (HRB_slice S) fs\n  (p, ins, outs) \\<in> set procs\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf) =\n  params (cspp (targetnode a) (HRB_slice S) fs) (fst cf')\n\ngoal (1 subgoal):\n 1. (\\<And>cfx.\n        \\<lbrakk>transfer (slice_kind S a) (cf # cfs) = cfx # cf # cfs;\n         transfer (slice_kind S a) (cf' # cfs') = cfx # cf' # cfs'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  transfer (slice_kind S a) (cf # cfs) = cfx # cf # cfs\n  transfer (slice_kind S a) (cf' # cfs') = cfx # cf' # cfs'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "hence rv:\"\\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n        state_val (transfer (slice_kind S a) s) V = \n        state_val (transfer (slice_kind S a) s') V\""], ["proof (prove)\nusing this:\n  transfer (slice_kind S a) (cf # cfs) = cfx # cf # cfs\n  transfer (slice_kind S a) (cf' # cfs') = cfx # cf' # cfs'\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n       state_val (transfer (slice_kind S a) s) V =\n       state_val (transfer (slice_kind S a) s') V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n     state_val (transfer (slice_kind S a) s) V =\n     state_val (transfer (slice_kind S a) s') V\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from rvs \\<open>\\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V\\<close> \n        \\<open>sourcenode a = m\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length cs.\n     \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n        fst (s ! Suc i) V = fst (s' ! Suc i) V\n  \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V\n  sourcenode a = m", "have rvs':\"\\<forall>i<length (a # cs). \n        \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n        fst ((transfer (slice_kind S a) s) ! Suc i) V = \n        fst ((transfer (slice_kind S a) s') ! Suc i) V\""], ["proof (prove)\nusing this:\n  \\<forall>i<length cs.\n     \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n        fst (s ! Suc i) V = fst (s' ! Suc i) V\n  \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V\n  sourcenode a = m\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (a # cs).\n       \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n          fst (transfer (slice_kind S a) s ! Suc i) V =\n          fst (transfer (slice_kind S a) s' ! Suc i) V", "by auto(case_tac i,auto)"], ["proof (state)\nthis:\n  \\<forall>i<length (a # cs).\n     \\<forall>V\\<in>rv S (CFG_node (sourcenode ((a # cs) ! i))).\n        fst (transfer (slice_kind S a) s ! Suc i) V =\n        fst (transfer (slice_kind S a) s' ! Suc i) V\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>preds (slice_kinds S (a # as)) s\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S (a # as)) s", "have \"preds (slice_kinds S as)\n        (transfer (slice_kind S a) s)\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S (a # as)) s\n\ngoal (1 subgoal):\n 1. preds (slice_kinds S as) (transfer (slice_kind S a) s)", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  preds (slice_kinds S as) (transfer (slice_kind S a) s)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "moreover"], ["proof (state)\nthis:\n  preds (slice_kinds S as) (transfer (slice_kind S a) s)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>preds (slice_kinds S as') s'\\<close> \\<open>as' = ax#asx\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S as') s'\n  as' = ax # asx", "have \"preds (slice_kinds S asx)\n        (transfer (slice_kind S a) s')\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S as') s'\n  as' = ax # asx\n\ngoal (1 subgoal):\n 1. preds (slice_kinds S asx) (transfer (slice_kind S a) s')", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  preds (slice_kinds S asx) (transfer (slice_kind S a) s')\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "moreover"], ["proof (state)\nthis:\n  preds (slice_kinds S asx) (transfer (slice_kind S a) s')\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>length s = Suc (length cs)\\<close>"], ["proof (chain)\npicking this:\n  length s = Suc (length cs)", "have \"length (transfer (slice_kind S a) s) = \n        Suc (length (a # cs))\""], ["proof (prove)\nusing this:\n  length s = Suc (length cs)\n\ngoal (1 subgoal):\n 1. length (transfer (slice_kind S a) s) = Suc (length (a # cs))", "by simp"], ["proof (state)\nthis:\n  length (transfer (slice_kind S a) s) = Suc (length (a # cs))\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "moreover"], ["proof (state)\nthis:\n  length (transfer (slice_kind S a) s) = Suc (length (a # cs))\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>length s' = Suc (length cs)\\<close>"], ["proof (chain)\npicking this:\n  length s' = Suc (length cs)", "have \"length (transfer (slice_kind S a) s') = \n        Suc (length (a # cs))\""], ["proof (prove)\nusing this:\n  length s' = Suc (length cs)\n\ngoal (1 subgoal):\n 1. length (transfer (slice_kind S a) s') = Suc (length (a # cs))", "by simp"], ["proof (state)\nthis:\n  length (transfer (slice_kind S a) s') = Suc (length (a # cs))\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "moreover"], ["proof (state)\nthis:\n  length (transfer (slice_kind S a) s') = Suc (length (a # cs))\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from IH[OF \\<open>upd_cs (a # cs) as = []\\<close> \\<open>same_level_path_aux (a # cs) asx\\<close>\n        \\<open>\\<forall>c\\<in>set (a # cs). valid_edge c\\<close> \\<open>targetnode a -as\\<rightarrow>* (_Low_)\\<close>\n        \\<open>targetnode a -asx\\<rightarrow>* (_Low_)\\<close> rvs' snds rv calculation] \\<open>as' = ax#asx\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S as) (transfer (slice_kind S a) s))\n      V =\n     state_val\n      (transfers (slice_kinds S asx) (transfer (slice_kind S a) s')) V\n  as' = ax # asx", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S as) (transfer (slice_kind S a) s))\n      V =\n     state_val\n      (transfers (slice_kinds S asx) (transfer (slice_kind S a) s')) V\n  as' = ax # asx\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "case (slpa_Return cs a as Q p f c' cs')"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  same_level_path_aux cs' as\n  a \\<in> get_return_edges c'\n  \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' ?as';\n   \\<forall>a\\<in>set cs'. valid_edge a; ?m -as\\<rightarrow>* (_Low_);\n   ?m -?as'\\<rightarrow>* (_Low_);\n   \\<forall>i<length cs'.\n      \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n         fst (?s ! Suc i) V = fst (?s' ! Suc i) V;\n   \\<forall>i<Suc (length cs'). snd (?s ! i) = snd (?s' ! i);\n   \\<forall>V\\<in>rv S (CFG_node ?m). state_val ?s V = state_val ?s' V;\n   preds (slice_kinds S as) ?s; preds (slice_kinds S ?as') ?s';\n   length ?s = Suc (length cs'); length ?s' = Suc (length cs')\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                       state_val (transfers (slice_kinds S as) ?s) V =\n                       state_val (transfers (slice_kinds S ?as') ?s') V\n  upd_cs cs (a # as) = []\n  same_level_path_aux cs as'\n  \\<forall>a\\<in>set cs. valid_edge a\n  m -a # as\\<rightarrow>* (_Low_)\n  m -as'\\<rightarrow>* (_Low_)\n  \\<forall>i<length cs.\n     \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n        fst (s ! Suc i) V = fst (s' ! Suc i) V\n  \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i)\n  \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V\n  preds (slice_kinds S (a # as)) s\n  preds (slice_kinds S as') s'\n  length s = Suc (length cs)\n  length s' = Suc (length cs)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "note IH = \\<open>\\<And>m as' s s'. \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as'; \n    \\<forall>c\\<in>set cs'. valid_edge c; m -as\\<rightarrow>* (_Low_); m -as'\\<rightarrow>* (_Low_);\n    \\<forall>i<length cs'. \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n    fst (s ! Suc i) V = fst (s' ! Suc i) V; \n    \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n    \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n    preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n    length s = Suc (length cs'); length s' = Suc (length cs')\\<rbrakk>\n    \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_). state_val (transfers(slice_kinds S as) s) V =\n                       state_val (transfers(slice_kinds S as') s') V\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' ?as';\n   \\<forall>c\\<in>set cs'. valid_edge c; ?m -as\\<rightarrow>* (_Low_);\n   ?m -?as'\\<rightarrow>* (_Low_);\n   \\<forall>i<length cs'.\n      \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n         fst (?s ! Suc i) V = fst (?s' ! Suc i) V;\n   \\<forall>i<Suc (length cs'). snd (?s ! i) = snd (?s' ! i);\n   \\<forall>V\\<in>rv S (CFG_node ?m). state_val ?s V = state_val ?s' V;\n   preds (slice_kinds S as) ?s; preds (slice_kinds S ?as') ?s';\n   length ?s = Suc (length cs'); length ?s' = Suc (length cs')\\<rbrakk>\n  \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                       state_val (transfers (slice_kinds S as) ?s) V =\n                       state_val (transfers (slice_kinds S ?as') ?s') V\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "note rvs = \\<open> \\<forall>i<length cs. \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n    fst (s ! Suc i) V = fst (s' ! Suc i) V\\<close>"], ["proof (state)\nthis:\n  \\<forall>i<length cs.\n     \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n        fst (s ! Suc i) V = fst (s' ! Suc i) V\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "from \\<open>m -a # as\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  m -a # as\\<rightarrow>* (_Low_)", "have \"sourcenode a = m\" and \"valid_edge a\"\n    and \"targetnode a -as\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  m -a # as\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. sourcenode a = m &&&\n    valid_edge a &&& targetnode a -as\\<rightarrow>* (_Low_)", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  sourcenode a = m\n  valid_edge a\n  targetnode a -as\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "from \\<open>\\<forall>c\\<in>set cs. valid_edge c\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>c\\<in>set cs. valid_edge c\n  cs = c' # cs'", "have \"valid_edge c'\" and \"\\<forall>c\\<in>set cs'. valid_edge c\""], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>set cs. valid_edge c\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. valid_edge c' &&& \\<forall>c\\<in>set cs'. valid_edge c", "by simp_all"], ["proof (state)\nthis:\n  valid_edge c'\n  \\<forall>c\\<in>set cs'. valid_edge c\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m as' s s'.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        same_level_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m as' s s'.\n           \\<lbrakk>upd_cs cs' as = []; same_level_path_aux cs' as';\n            Ball (set cs') valid_edge; m -as\\<rightarrow>* (_Low_);\n            m -as'\\<rightarrow>* (_Low_);\n            \\<forall>i<length cs'.\n               \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n                  fst (s ! Suc i) V = fst (s' ! Suc i) V;\n            \\<forall>i<Suc (length cs'). snd (s ! i) = snd (s' ! i);\n            \\<forall>V\\<in>rv S (CFG_node m).\n               state_val s V = state_val s' V;\n            preds (slice_kinds S as) s; preds (slice_kinds S as') s';\n            length s = Suc (length cs');\n            length s' = Suc (length cs')\\<rbrakk>\n           \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                                state_val (transfers (slice_kinds S as) s)\n                                 V =\n                                state_val (transfers (slice_kinds S as') s')\n                                 V;\n        upd_cs cs (a # as) = []; same_level_path_aux cs as';\n        Ball (set cs) valid_edge; m -a # as\\<rightarrow>* (_Low_);\n        m -as'\\<rightarrow>* (_Low_);\n        \\<forall>i<length cs.\n           \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n              fst (s ! Suc i) V = fst (s' ! Suc i) V;\n        \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i);\n        \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V;\n        preds (slice_kinds S (a # as)) s; preds (slice_kinds S as') s';\n        length s = Suc (length cs); length s' = Suc (length cs)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>Use (_Low_).\n                            state_val (transfers (slice_kinds S (a # as)) s)\n                             V =\n                            state_val (transfers (slice_kinds S as') s') V", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "proof(cases \"L = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. L = {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "case True"], ["proof (state)\nthis:\n  L = {}\n\ngoal (2 subgoals):\n 1. L = {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "with UseLow"], ["proof (chain)\npicking this:\n  Use (_Low_) = L\n  L = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  Use (_Low_) = L\n  L = {}\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "case False"], ["proof (state)\nthis:\n  L \\<noteq> {}\n\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "proof(cases as')"], ["proof (state)\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "case Nil"], ["proof (state)\nthis:\n  as' = []\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>m -as'\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  m -as'\\<rightarrow>* (_Low_)\n  as' = []", "have \"m = (_Low_)\""], ["proof (prove)\nusing this:\n  m -as'\\<rightarrow>* (_Low_)\n  as' = []\n\ngoal (1 subgoal):\n 1. m = (_Low_)", "by fastforce"], ["proof (state)\nthis:\n  m = (_Low_)\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>valid_edge a\\<close> \\<open>sourcenode a = m\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = m\n  m = (_Low_)", "have \"targetnode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = m\n  m = (_Low_)\n\ngoal (1 subgoal):\n 1. targetnode a = (_Exit_)", "by -(rule Exit_successor_of_Low,simp+)"], ["proof (state)\nthis:\n  targetnode a = (_Exit_)\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from Low_source_Exit_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Low_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>", "obtain a' where \"valid_edge a'\"\n        and \"sourcenode a' = (_Low_)\" and \"targetnode a' = (_Exit_)\"\n        and \"kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Low_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>valid_edge a'; sourcenode a' = (_Low_);\n         targetnode a' = (_Exit_);\n         kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_edge a'\n  sourcenode a' = (_Low_)\n  targetnode a' = (_Exit_)\n  kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>valid_edge a\\<close> \\<open>sourcenode a = m\\<close> \\<open>m = (_Low_)\\<close> \n        \\<open>targetnode a = (_Exit_)\\<close> \\<open>valid_edge a'\\<close> \\<open>sourcenode a' = (_Low_)\\<close> \n        \\<open>targetnode a' = (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = m\n  m = (_Low_)\n  targetnode a = (_Exit_)\n  valid_edge a'\n  sourcenode a' = (_Low_)\n  targetnode a' = (_Exit_)", "have \"a = a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = m\n  m = (_Low_)\n  targetnode a = (_Exit_)\n  valid_edge a'\n  sourcenode a' = (_Low_)\n  targetnode a' = (_Exit_)\n\ngoal (1 subgoal):\n 1. a = a'", "by(fastforce dest:edge_det)"], ["proof (state)\nthis:\n  a = a'\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n  a = a'", "have \"kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n  a = a'\n\ngoal (1 subgoal):\n 1. kind a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by simp"], ["proof (state)\nthis:\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>targetnode a = (_Exit_)\\<close> \\<open>targetnode a -as\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  targetnode a = (_Exit_)\n  targetnode a -as\\<rightarrow>* (_Low_)\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>", "have \"(_Low_) = (_Exit_)\""], ["proof (prove)\nusing this:\n  targetnode a = (_Exit_)\n  targetnode a -as\\<rightarrow>* (_Low_)\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (_Low_) = (_Exit_)", "by -(drule path_Exit_source,auto)"], ["proof (state)\nthis:\n  (_Low_) = (_Exit_)\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with False"], ["proof (chain)\npicking this:\n  L \\<noteq> {}\n  (_Low_) = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  L \\<noteq> {}\n  (_Low_) = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by -(drule Low_neq_Exit,simp)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "case (Cons ax asx)"], ["proof (state)\nthis:\n  as' = ax # asx\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>m -as'\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  m -as'\\<rightarrow>* (_Low_)\n  as' = ax # asx", "have \"sourcenode ax = m\" and \"valid_edge ax\"\n        and \"targetnode ax -asx\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  m -as'\\<rightarrow>* (_Low_)\n  as' = ax # asx\n\ngoal (1 subgoal):\n 1. sourcenode ax = m &&&\n    valid_edge ax &&& targetnode ax -asx\\<rightarrow>* (_Low_)", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  sourcenode ax = m\n  valid_edge ax\n  targetnode ax -asx\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>valid_edge a\\<close> \\<open>valid_edge ax\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>\n        \\<open>sourcenode a = m\\<close> \\<open>sourcenode ax = m\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge ax\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  sourcenode a = m\n  sourcenode ax = m", "have \"\\<exists>Q f. kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\""], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge ax\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  sourcenode a = m\n  sourcenode ax = m\n\ngoal (1 subgoal):\n 1. \\<exists>Q f. kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "by(auto dest:return_edges_only)"], ["proof (state)\nthis:\n  \\<exists>Q f. kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "with \\<open>same_level_path_aux cs as'\\<close> \\<open>as' = ax#asx\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  same_level_path_aux cs as'\n  as' = ax # asx\n  cs = c' # cs'\n  \\<exists>Q f. kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"ax \\<in> get_return_edges c'\" and \"same_level_path_aux cs' asx\""], ["proof (prove)\nusing this:\n  same_level_path_aux cs as'\n  as' = ax # asx\n  cs = c' # cs'\n  \\<exists>Q f. kind ax = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. ax \\<in> get_return_edges c' &&& same_level_path_aux cs' asx", "by auto"], ["proof (state)\nthis:\n  ax \\<in> get_return_edges c'\n  same_level_path_aux cs' asx\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>valid_edge c'\\<close> \\<open>ax \\<in> get_return_edges c'\\<close> \\<open>a \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  ax \\<in> get_return_edges c'\n  a \\<in> get_return_edges c'", "have [simp]:\"ax = a\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  ax \\<in> get_return_edges c'\n  a \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. ax = a", "by(rule get_return_edges_unique)"], ["proof (state)\nthis:\n  ax = a\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>targetnode ax -asx\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  targetnode ax -asx\\<rightarrow>* (_Low_)", "have \"targetnode a -asx\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  targetnode ax -asx\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. targetnode a -asx\\<rightarrow>* (_Low_)", "by simp"], ["proof (state)\nthis:\n  targetnode a -asx\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>upd_cs cs (a # as) = []\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>cs = c' # cs'\\<close>\n        \\<open>a \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  upd_cs cs (a # as) = []\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  a \\<in> get_return_edges c'", "have \"upd_cs cs' as = []\""], ["proof (prove)\nusing this:\n  upd_cs cs (a # as) = []\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  a \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. upd_cs cs' as = []", "by simp"], ["proof (state)\nthis:\n  upd_cs cs' as = []\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>length s = Suc (length cs)\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  length s = Suc (length cs)\n  cs = c' # cs'", "obtain cf cfx cfs where \"s = cf#cfx#cfs\""], ["proof (prove)\nusing this:\n  length s = Suc (length cs)\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. (\\<And>cf cfx cfs.\n        s = cf # cfx # cfs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s,auto,case_tac list,fastforce+)"], ["proof (state)\nthis:\n  s = cf # cfx # cfs\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>length s' = Suc (length cs)\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  length s' = Suc (length cs)\n  cs = c' # cs'", "obtain cf' cfx' cfs' where \"s' = cf'#cfx'#cfs'\""], ["proof (prove)\nusing this:\n  length s' = Suc (length cs)\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. (\\<And>cf' cfx' cfs'.\n        s' = cf' # cfx' # cfs' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s',auto,case_tac list,fastforce+)"], ["proof (state)\nthis:\n  s' = cf' # cfx' # cfs'\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from rvs \\<open>cs = c' # cs'\\<close> \\<open>s = cf#cfx#cfs\\<close> \\<open>s' = cf'#cfx'#cfs'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<length cs.\n     \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n        fst (s ! Suc i) V = fst (s' ! Suc i) V\n  cs = c' # cs'\n  s = cf # cfx # cfs\n  s' = cf' # cfx' # cfs'", "have rvs1:\"\\<forall>i<length cs'. \n        \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n        fst ((cfx#cfs) ! Suc i) V = fst ((cfx'#cfs') ! Suc i) V\"\n        and \"\\<forall>V\\<in>rv S (CFG_node (sourcenode c')). \n        (fst cfx) V = (fst cfx') V\""], ["proof (prove)\nusing this:\n  \\<forall>i<length cs.\n     \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs ! i))).\n        fst (s ! Suc i) V = fst (s' ! Suc i) V\n  cs = c' # cs'\n  s = cf # cfx # cfs\n  s' = cf' # cfx' # cfs'\n\ngoal (1 subgoal):\n 1. \\<forall>i<length cs'.\n       \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n          fst ((cfx # cfs) ! Suc i) V = fst ((cfx' # cfs') ! Suc i) V &&&\n    \\<forall>V\\<in>rv S (CFG_node (sourcenode c')). fst cfx V = fst cfx' V", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length cs'.\n     \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n        fst ((cfx # cfs) ! Suc i) V = fst ((cfx' # cfs') ! Suc i) V\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode c')). fst cfx V = fst cfx' V\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "from \\<open>valid_edge c'\\<close> \\<open>a \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  a \\<in> get_return_edges c'", "obtain Qx rx px fsx where \"kind c' = Qx:rx\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  a \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. (\\<And>Qx rx px fsx.\n        kind c' =\n        Qx:rx\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:only_call_get_return_edges)"], ["proof (state)\nthis:\n  kind c' = Qx:rx\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "have \"\\<forall>V \\<in> rv S (CFG_node (targetnode a)).\n        V \\<in> rv S (CFG_node (sourcenode c'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n       V \\<in> rv S (CFG_node (sourcenode c'))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       V \\<in> rv S (CFG_node (sourcenode c'))", "fix V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       V \\<in> rv S (CFG_node (sourcenode c'))", "assume \"V \\<in> rv S (CFG_node (targetnode a))\""], ["proof (state)\nthis:\n  V \\<in> rv S (CFG_node (targetnode a))\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       V \\<in> rv S (CFG_node (sourcenode c'))", "from \\<open>valid_edge c'\\<close> \\<open>a \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  a \\<in> get_return_edges c'", "obtain a' where edge:\"valid_edge a'\" \"sourcenode a' = sourcenode c'\"\n          \"targetnode a' = targetnode a\" \"intra_kind (kind a')\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  a \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>valid_edge a'; sourcenode a' = sourcenode c';\n         targetnode a' = targetnode a; intra_kind (kind a')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by -(drule call_return_node_edge,auto simp:intra_kind_def)"], ["proof (state)\nthis:\n  valid_edge a'\n  sourcenode a' = sourcenode c'\n  targetnode a' = targetnode a\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       V \\<in> rv S (CFG_node (sourcenode c'))", "from \\<open>V \\<in> rv S (CFG_node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> rv S (CFG_node (targetnode a))", "obtain as n' where \"targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\"\n          and \"n' \\<in> HRB_slice S\" and \"V \\<in> Use\\<^bsub>SDG\\<^esub> n'\"\n          and all:\"\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes as) \n          \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\""], ["proof (prove)\nusing this:\n  V \\<in> rv S (CFG_node (targetnode a))\n\ngoal (1 subgoal):\n 1. (\\<And>as n'.\n        \\<lbrakk>targetnode\n                  a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n';\n         n' \\<in> HRB_slice S; V \\<in> Use\\<^bsub>SDG\\<^esub> n';\n         \\<forall>n''.\n            valid_SDG_node n'' \\<and>\n            parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n            V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:rvE)"], ["proof (state)\nthis:\n  targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  n' \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> n'\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       V \\<in> rv S (CFG_node (sourcenode c'))", "from \\<open>targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\\<close> edge"], ["proof (chain)\npicking this:\n  targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  valid_edge a'\n  sourcenode a' = sourcenode c'\n  targetnode a' = targetnode a\n  intra_kind (kind a')", "have \"sourcenode c' -a'#as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\""], ["proof (prove)\nusing this:\n  targetnode a -as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  valid_edge a'\n  sourcenode a' = sourcenode c'\n  targetnode a' = targetnode a\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. sourcenode c' -a' # as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'", "by(fastforce intro:Cons_path simp:intra_path_def)"], ["proof (state)\nthis:\n  sourcenode c' -a' # as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       V \\<in> rv S (CFG_node (sourcenode c'))", "from \\<open>valid_edge c'\\<close> \\<open>kind c' = Qx:rx\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  kind c' = Qx:rx\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx", "have \"Def (sourcenode c') = {}\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  kind c' = Qx:rx\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx\n\ngoal (1 subgoal):\n 1. Def (sourcenode c') = {}", "by(rule call_source_Def_empty)"], ["proof (state)\nthis:\n  Def (sourcenode c') = {}\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       V \\<in> rv S (CFG_node (sourcenode c'))", "hence \"\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' = sourcenode c'\n          \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\""], ["proof (prove)\nusing this:\n  Def (sourcenode c') = {}\n\ngoal (1 subgoal):\n 1. \\<forall>n''.\n       valid_SDG_node n'' \\<and>\n       parent_node n'' = sourcenode c' \\<longrightarrow>\n       V \\<notin> Def\\<^bsub>SDG\\<^esub> n''", "by(fastforce dest:SDG_Def_parent_Def)"], ["proof (state)\nthis:\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' = sourcenode c' \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       V \\<in> rv S (CFG_node (sourcenode c'))", "with all \\<open>sourcenode a' = sourcenode c'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n  sourcenode a' = sourcenode c'\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' = sourcenode c' \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''", "have \"\\<forall>n''. valid_SDG_node n'' \\<and> parent_node n'' \\<in> set (sourcenodes (a'#as)) \n          \\<longrightarrow> V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\""], ["proof (prove)\nusing this:\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes as) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n  sourcenode a' = sourcenode c'\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' = sourcenode c' \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. \\<forall>n''.\n       valid_SDG_node n'' \\<and>\n       parent_node n'' \\<in> set (sourcenodes (a' # as)) \\<longrightarrow>\n       V \\<notin> Def\\<^bsub>SDG\\<^esub> n''", "by(fastforce simp:sourcenodes_def)"], ["proof (state)\nthis:\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes (a' # as)) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       V \\<in> rv S (CFG_node (sourcenode c'))", "with \\<open>sourcenode c' -a'#as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\\<close> \n          \\<open>n' \\<in> HRB_slice S\\<close> \\<open>V \\<in> Use\\<^bsub>SDG\\<^esub> n'\\<close>"], ["proof (chain)\npicking this:\n  sourcenode c' -a' # as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  n' \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> n'\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes (a' # as)) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''", "show \"V \\<in> rv S (CFG_node (sourcenode c'))\""], ["proof (prove)\nusing this:\n  sourcenode c' -a' # as\\<rightarrow>\\<^sub>\\<iota>* parent_node n'\n  n' \\<in> HRB_slice S\n  V \\<in> Use\\<^bsub>SDG\\<^esub> n'\n  \\<forall>n''.\n     valid_SDG_node n'' \\<and>\n     parent_node n'' \\<in> set (sourcenodes (a' # as)) \\<longrightarrow>\n     V \\<notin> Def\\<^bsub>SDG\\<^esub> n''\n\ngoal (1 subgoal):\n 1. V \\<in> rv S (CFG_node (sourcenode c'))", "by(fastforce intro:rvI)"], ["proof (state)\nthis:\n  V \\<in> rv S (CFG_node (sourcenode c'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n     V \\<in> rv S (CFG_node (sourcenode c'))\n\ngoal (1 subgoal):\n 1. \\<And>aa list.\n       as' = aa # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S (a # as)) s) V =\n          state_val (transfers (slice_kinds S as') s') V", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "proof(cases \"sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "case True"], ["proof (state)\nthis:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>valid_edge c'\\<close> \\<open>a \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  a \\<in> get_return_edges c'", "have \"get_proc (targetnode c') = get_proc (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  a \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. get_proc (targetnode c') = get_proc (sourcenode a)", "by -(drule intra_proc_additional_edge,\n            auto dest:get_proc_intra simp:intra_kind_def)"], ["proof (state)\nthis:\n  get_proc (targetnode c') = get_proc (sourcenode a)\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "moreover"], ["proof (state)\nthis:\n  get_proc (targetnode c') = get_proc (sourcenode a)\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>valid_edge c'\\<close> \\<open>kind c' = Qx:rx\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  kind c' = Qx:rx\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx", "have \"get_proc (targetnode c') = px\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  kind c' = Qx:rx\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx\n\ngoal (1 subgoal):\n 1. get_proc (targetnode c') = px", "by(rule get_proc_call)"], ["proof (state)\nthis:\n  get_proc (targetnode c') = px\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "moreover"], ["proof (state)\nthis:\n  get_proc (targetnode c') = px\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"get_proc (sourcenode a) = p\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a) = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a) = p\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "ultimately"], ["proof (chain)\npicking this:\n  get_proc (targetnode c') = get_proc (sourcenode a)\n  get_proc (targetnode c') = px\n  get_proc (sourcenode a) = p", "have [simp]:\"px = p\""], ["proof (prove)\nusing this:\n  get_proc (targetnode c') = get_proc (sourcenode a)\n  get_proc (targetnode c') = px\n  get_proc (sourcenode a) = p\n\ngoal (1 subgoal):\n 1. px = p", "by simp"], ["proof (state)\nthis:\n  px = p\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>valid_edge c'\\<close> \\<open>kind c' = Qx:rx\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  kind c' = Qx:rx\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx", "obtain ins outs where \"(p,ins,outs) \\<in> set procs\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  kind c' = Qx:rx\\<hookrightarrow>\\<^bsub>px\\<^esub>fsx\n\ngoal (1 subgoal):\n 1. (\\<And>ins outs.\n        (p, ins, outs) \\<in> set procs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:callee_in_procs)"], ["proof (state)\nthis:\n  (p, ins, outs) \\<in> set procs\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "with \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>\n          \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set procs", "have slice_kind:\"slice_kind S a = \n          Q\\<hookleftarrow>\\<^bsub>p\\<^esub>(\\<lambda>cf cf'. rspp (targetnode a) (HRB_slice S) outs cf' cf)\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. slice_kind S a =\n    Q\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n   rspp (targetnode a) (HRB_slice S) outs cf' cf", "by(rule slice_kind_Return_in_slice)"], ["proof (state)\nthis:\n  slice_kind S a =\n  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n rspp (targetnode a) (HRB_slice S) outs cf' cf\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "with \\<open>s = cf#cfx#cfs\\<close> \\<open>s' = cf'#cfx'#cfs'\\<close>"], ["proof (chain)\npicking this:\n  s = cf # cfx # cfs\n  s' = cf' # cfx' # cfs'\n  slice_kind S a =\n  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n rspp (targetnode a) (HRB_slice S) outs cf' cf", "have sx:\"transfer (slice_kind S a) s = \n          (rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf),\n          snd cfx)#cfs\"\n          and sx':\"transfer (slice_kind S a) s' = \n          (rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf'),\n          snd cfx')#cfs'\""], ["proof (prove)\nusing this:\n  s = cf # cfx # cfs\n  s' = cf' # cfx' # cfs'\n  slice_kind S a =\n  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n rspp (targetnode a) (HRB_slice S) outs cf' cf\n\ngoal (1 subgoal):\n 1. transfer (slice_kind S a) s =\n    (rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf), snd cfx) #\n    cfs &&&\n    transfer (slice_kind S a) s' =\n    (rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf'),\n     snd cfx') #\n    cfs'", "by simp_all"], ["proof (state)\nthis:\n  transfer (slice_kind S a) s =\n  (rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf), snd cfx) # cfs\n  transfer (slice_kind S a) s' =\n  (rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf'), snd cfx') #\n  cfs'\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "with rvs1"], ["proof (chain)\npicking this:\n  \\<forall>i<length cs'.\n     \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n        fst ((cfx # cfs) ! Suc i) V = fst ((cfx' # cfs') ! Suc i) V\n  transfer (slice_kind S a) s =\n  (rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf), snd cfx) # cfs\n  transfer (slice_kind S a) s' =\n  (rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf'), snd cfx') #\n  cfs'", "have rvs':\"\\<forall>i<length cs'. \n          \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n          fst ((transfer (slice_kind S a) s) ! Suc i) V = \n          fst ((transfer (slice_kind S a) s') ! Suc i) V\""], ["proof (prove)\nusing this:\n  \\<forall>i<length cs'.\n     \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n        fst ((cfx # cfs) ! Suc i) V = fst ((cfx' # cfs') ! Suc i) V\n  transfer (slice_kind S a) s =\n  (rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf), snd cfx) # cfs\n  transfer (slice_kind S a) s' =\n  (rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf'), snd cfx') #\n  cfs'\n\ngoal (1 subgoal):\n 1. \\<forall>i<length cs'.\n       \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n          fst (transfer (slice_kind S a) s ! Suc i) V =\n          fst (transfer (slice_kind S a) s' ! Suc i) V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>i<length cs'.\n     \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n        fst (transfer (slice_kind S a) s ! Suc i) V =\n        fst (transfer (slice_kind S a) s' ! Suc i) V\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from slice_kind \\<open>\\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i)\\<close> \\<open>cs = c' # cs'\\<close>\n          \\<open>s = cf#cfx#cfs\\<close> \\<open>s' = cf'#cfx'#cfs'\\<close>"], ["proof (chain)\npicking this:\n  slice_kind S a =\n  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n rspp (targetnode a) (HRB_slice S) outs cf' cf\n  \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i)\n  cs = c' # cs'\n  s = cf # cfx # cfs\n  s' = cf' # cfx' # cfs'", "have snds:\"\\<forall>i<Suc (length cs').\n          snd (transfer (slice_kind S a) s ! i) =\n          snd (transfer (slice_kind S a) s' ! i)\""], ["proof (prove)\nusing this:\n  slice_kind S a =\n  Q\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n rspp (targetnode a) (HRB_slice S) outs cf' cf\n  \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i)\n  cs = c' # cs'\n  s = cf # cfx # cfs\n  s' = cf' # cfx' # cfs'\n\ngoal (1 subgoal):\n 1. \\<forall>i<Suc (length cs').\n       snd (transfer (slice_kind S a) s ! i) =\n       snd (transfer (slice_kind S a) s' ! i)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>slice_kind S a =\n                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n               rspp (targetnode a) (HRB_slice S) outs cf' cf;\n        \\<forall>i<Suc (Suc (length cs')).\n           snd ((cf # cfx # cfs) ! i) = snd ((cf' # cfx' # cfs') ! i);\n        cs = c' # cs'; s = cf # cfx # cfs; s' = cf' # cfx' # cfs';\n        i < Suc (length cs')\\<rbrakk>\n       \\<Longrightarrow> snd (((rspp (targetnode a) (HRB_slice S) outs\n                                 (fst cfx) (fst cf),\n                                snd cfx) #\n                               cfs) !\n                              i) =\n                         snd (((rspp (targetnode a) (HRB_slice S) outs\n                                 (fst cfx') (fst cf'),\n                                snd cfx') #\n                               cfs') !\n                              i)", "apply(case_tac i)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>slice_kind S a =\n                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n               rspp (targetnode a) (HRB_slice S) outs cf' cf;\n        \\<forall>i<Suc (Suc (length cs')).\n           snd ((cf # cfx # cfs) ! i) = snd ((cf' # cfx' # cfs') ! i);\n        cs = c' # cs'; s = cf # cfx # cfs; s' = cf' # cfx' # cfs';\n        i < Suc (length cs'); i = 0\\<rbrakk>\n       \\<Longrightarrow> snd (((rspp (targetnode a) (HRB_slice S) outs\n                                 (fst cfx) (fst cf),\n                                snd cfx) #\n                               cfs) !\n                              i) =\n                         snd (((rspp (targetnode a) (HRB_slice S) outs\n                                 (fst cfx') (fst cf'),\n                                snd cfx') #\n                               cfs') !\n                              i)\n 2. \\<And>i nat.\n       \\<lbrakk>slice_kind S a =\n                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n               rspp (targetnode a) (HRB_slice S) outs cf' cf;\n        \\<forall>i<Suc (Suc (length cs')).\n           snd ((cf # cfx # cfs) ! i) = snd ((cf' # cfx' # cfs') ! i);\n        cs = c' # cs'; s = cf # cfx # cfs; s' = cf' # cfx' # cfs';\n        i < Suc (length cs'); i = Suc nat\\<rbrakk>\n       \\<Longrightarrow> snd (((rspp (targetnode a) (HRB_slice S) outs\n                                 (fst cfx) (fst cf),\n                                snd cfx) #\n                               cfs) !\n                              i) =\n                         snd (((rspp (targetnode a) (HRB_slice S) outs\n                                 (fst cfx') (fst cf'),\n                                snd cfx') #\n                               cfs') !\n                              i)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>slice_kind S a =\n                Q\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'.\n               rspp (targetnode a) (HRB_slice S) outs cf' cf;\n        \\<forall>i<Suc (Suc (length cs')).\n           snd ((cf # cfx # cfs) ! i) = snd ((cf' # cfx' # cfs') ! i);\n        cs = c' # cs'; s = cf # cfx # cfs; s' = cf' # cfx' # cfs';\n        nat < length cs'\\<rbrakk>\n       \\<Longrightarrow> snd (cfs ! nat) = snd (cfs' ! nat)", "by(erule_tac x=\"Suc (Suc nat)\" in allE) auto"], ["proof (state)\nthis:\n  \\<forall>i<Suc (length cs').\n     snd (transfer (slice_kind S a) s ! i) =\n     snd (transfer (slice_kind S a) s' ! i)\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "have \"\\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n          (rspp (targetnode a) (HRB_slice S) outs \n          (fst cfx) (fst cf)) V =\n          (rspp (targetnode a) (HRB_slice S) outs \n          (fst cfx') (fst cf')) V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n       rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n       rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n       rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "fix V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n       rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "assume \"V \\<in> rv S (CFG_node (targetnode a))\""], ["proof (state)\nthis:\n  V \\<in> rv S (CFG_node (targetnode a))\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> rv S (CFG_node (targetnode a)) \\<Longrightarrow>\n       rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n       rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "show \"(rspp (targetnode a) (HRB_slice S) outs \n            (fst cfx) (fst cf)) V =\n            (rspp (targetnode a) (HRB_slice S) outs \n            (fst cfx') (fst cf')) V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "proof(cases \"V \\<in> set (ParamDefs (targetnode a))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "case True"], ["proof (state)\nthis:\n  V \\<in> set (ParamDefs (targetnode a))\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "then"], ["proof (chain)\npicking this:\n  V \\<in> set (ParamDefs (targetnode a))", "obtain i where \"i < length (ParamDefs (targetnode a))\"\n              and \"(ParamDefs (targetnode a))!i = V\""], ["proof (prove)\nusing this:\n  V \\<in> set (ParamDefs (targetnode a))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < length (ParamDefs (targetnode a));\n         ParamDefs (targetnode a) ! i = V\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp:in_set_conv_nth)"], ["proof (state)\nthis:\n  i < length (ParamDefs (targetnode a))\n  ParamDefs (targetnode a) ! i = V\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set procs", "have \"length(ParamDefs (targetnode a)) = length outs\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. length (ParamDefs (targetnode a)) = length outs", "by(fastforce intro:ParamDefs_return_target_length)"], ["proof (state)\nthis:\n  length (ParamDefs (targetnode a)) = length outs\n\ngoal (2 subgoals):\n 1. V \\<in> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V\n 2. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "proof(cases \"Actual_out(targetnode a,i) \\<in> HRB_slice S\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Actual_out (targetnode a, i) \\<in> HRB_slice S \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V\n 2. Actual_out (targetnode a, i) \\<notin> HRB_slice S \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "case True"], ["proof (state)\nthis:\n  Actual_out (targetnode a, i) \\<in> HRB_slice S\n\ngoal (2 subgoals):\n 1. Actual_out (targetnode a, i) \\<in> HRB_slice S \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V\n 2. Actual_out (targetnode a, i) \\<notin> HRB_slice S \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "with \\<open>i < length (ParamDefs (targetnode a))\\<close> \\<open>valid_edge a\\<close>\n                \\<open>length(ParamDefs (targetnode a)) = length outs\\<close>\n                \\<open>(ParamDefs (targetnode a))!i = V\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  i < length (ParamDefs (targetnode a))\n  valid_edge a\n  length (ParamDefs (targetnode a)) = length outs\n  V = ParamDefs (targetnode a) ! i\n  Actual_out (targetnode a, i) \\<in> HRB_slice S", "have rspp_eq:\"(rspp (targetnode a) \n                (HRB_slice S) outs (fst cfx) (fst cf)) V = \n                (fst cf)(outs!i)\"\n                \"(rspp (targetnode a) \n                (HRB_slice S) outs (fst cfx') (fst cf')) V = \n                (fst cf')(outs!i)\""], ["proof (prove)\nusing this:\n  i < length (ParamDefs (targetnode a))\n  valid_edge a\n  length (ParamDefs (targetnode a)) = length outs\n  V = ParamDefs (targetnode a) ! i\n  Actual_out (targetnode a, i) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    fst cf (outs ! i) &&&\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V =\n    fst cf' (outs ! i)", "by(auto intro:rspp_Actual_out_in_slice)"], ["proof (state)\nthis:\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n  fst cf (outs ! i)\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V =\n  fst cf' (outs ! i)\n\ngoal (2 subgoals):\n 1. Actual_out (targetnode a, i) \\<in> HRB_slice S \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V\n 2. Actual_out (targetnode a, i) \\<notin> HRB_slice S \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set procs", "have \"\\<forall>V \\<in> set outs. V \\<in> Use (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>set outs. V \\<in> Use (sourcenode a)", "by(fastforce dest:outs_in_Use)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>set outs. V \\<in> Use (sourcenode a)\n\ngoal (2 subgoals):\n 1. Actual_out (targetnode a, i) \\<in> HRB_slice S \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V\n 2. Actual_out (targetnode a, i) \\<notin> HRB_slice S \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "have \"\\<forall>V \\<in> Use (sourcenode a). V \\<in> rv S (CFG_node m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (sourcenode a). V \\<in> rv S (CFG_node m)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> Use (sourcenode a) \\<Longrightarrow>\n       V \\<in> rv S (CFG_node m)", "fix V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> Use (sourcenode a) \\<Longrightarrow>\n       V \\<in> rv S (CFG_node m)", "assume \"V \\<in> Use (sourcenode a)\""], ["proof (state)\nthis:\n  V \\<in> Use (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> Use (sourcenode a) \\<Longrightarrow>\n       V \\<in> rv S (CFG_node m)", "from \\<open>valid_edge a\\<close> \\<open>sourcenode a = m\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = m", "have \"parent_node (CFG_node m) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node (CFG_node m)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = m\n\ngoal (1 subgoal):\n 1. parent_node\n     (CFG_node m) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node (CFG_node m)", "by(fastforce intro:empty_path simp:intra_path_def)"], ["proof (state)\nthis:\n  parent_node\n   (CFG_node m) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node (CFG_node m)\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> Use (sourcenode a) \\<Longrightarrow>\n       V \\<in> rv S (CFG_node m)", "with \\<open>sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \n                  \\<open>V \\<in> Use (sourcenode a)\\<close> \\<open>sourcenode a = m\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  V \\<in> Use (sourcenode a)\n  sourcenode a = m\n  valid_edge a\n  parent_node\n   (CFG_node m) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node (CFG_node m)", "show \"V \\<in> rv S (CFG_node m)\""], ["proof (prove)\nusing this:\n  sourcenode a \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  V \\<in> Use (sourcenode a)\n  sourcenode a = m\n  valid_edge a\n  parent_node\n   (CFG_node m) -[]\\<rightarrow>\\<^sub>\\<iota>* parent_node (CFG_node m)\n\ngoal (1 subgoal):\n 1. V \\<in> rv S (CFG_node m)", "by -(rule rvI,\n                    auto intro!:CFG_Use_SDG_Use simp:SDG_to_CFG_set_def sourcenodes_def)"], ["proof (state)\nthis:\n  V \\<in> rv S (CFG_node m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (sourcenode a). V \\<in> rv S (CFG_node m)\n\ngoal (2 subgoals):\n 1. Actual_out (targetnode a, i) \\<in> HRB_slice S \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V\n 2. Actual_out (targetnode a, i) \\<notin> HRB_slice S \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "with \\<open>\\<forall>V \\<in> set outs. V \\<in> Use (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>set outs. V \\<in> Use (sourcenode a)\n  \\<forall>V\\<in>Use (sourcenode a). V \\<in> rv S (CFG_node m)", "have \"\\<forall>V \\<in> set outs. V \\<in> rv S (CFG_node m)\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>set outs. V \\<in> Use (sourcenode a)\n  \\<forall>V\\<in>Use (sourcenode a). V \\<in> rv S (CFG_node m)\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>set outs. V \\<in> rv S (CFG_node m)", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>set outs. V \\<in> rv S (CFG_node m)\n\ngoal (2 subgoals):\n 1. Actual_out (targetnode a, i) \\<in> HRB_slice S \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V\n 2. Actual_out (targetnode a, i) \\<notin> HRB_slice S \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "with \\<open>\\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V\\<close>\n                \\<open>s = cf#cfx#cfs\\<close> \\<open>s' = cf'#cfx'#cfs'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V\n  s = cf # cfx # cfs\n  s' = cf' # cfx' # cfs'\n  \\<forall>V\\<in>set outs. V \\<in> rv S (CFG_node m)", "have \"\\<forall>V \\<in> set outs. (fst cf) V = (fst cf') V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S (CFG_node m). state_val s V = state_val s' V\n  s = cf # cfx # cfs\n  s' = cf' # cfx' # cfs'\n  \\<forall>V\\<in>set outs. V \\<in> rv S (CFG_node m)\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>set outs. fst cf V = fst cf' V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>set outs. fst cf V = fst cf' V\n\ngoal (2 subgoals):\n 1. Actual_out (targetnode a, i) \\<in> HRB_slice S \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V\n 2. Actual_out (targetnode a, i) \\<notin> HRB_slice S \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "with \\<open>i < length (ParamDefs (targetnode a))\\<close>\n                \\<open>length(ParamDefs (targetnode a)) = length outs\\<close>"], ["proof (chain)\npicking this:\n  i < length (ParamDefs (targetnode a))\n  length (ParamDefs (targetnode a)) = length outs\n  \\<forall>V\\<in>set outs. fst cf V = fst cf' V", "have \"(fst cf)(outs!i) = (fst cf')(outs!i)\""], ["proof (prove)\nusing this:\n  i < length (ParamDefs (targetnode a))\n  length (ParamDefs (targetnode a)) = length outs\n  \\<forall>V\\<in>set outs. fst cf V = fst cf' V\n\ngoal (1 subgoal):\n 1. fst cf (outs ! i) = fst cf' (outs ! i)", "by fastforce"], ["proof (state)\nthis:\n  fst cf (outs ! i) = fst cf' (outs ! i)\n\ngoal (2 subgoals):\n 1. Actual_out (targetnode a, i) \\<in> HRB_slice S \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V\n 2. Actual_out (targetnode a, i) \\<notin> HRB_slice S \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "with rspp_eq"], ["proof (chain)\npicking this:\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n  fst cf (outs ! i)\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V =\n  fst cf' (outs ! i)\n  fst cf (outs ! i) = fst cf' (outs ! i)", "show ?thesis"], ["proof (prove)\nusing this:\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n  fst cf (outs ! i)\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V =\n  fst cf' (outs ! i)\n  fst cf (outs ! i) = fst cf' (outs ! i)\n\ngoal (1 subgoal):\n 1. rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "by simp"], ["proof (state)\nthis:\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V\n\ngoal (1 subgoal):\n 1. Actual_out (targetnode a, i) \\<notin> HRB_slice S \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Actual_out (targetnode a, i) \\<notin> HRB_slice S \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "case False"], ["proof (state)\nthis:\n  Actual_out (targetnode a, i) \\<notin> HRB_slice S\n\ngoal (1 subgoal):\n 1. Actual_out (targetnode a, i) \\<notin> HRB_slice S \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "with \\<open>i < length (ParamDefs (targetnode a))\\<close> \\<open>valid_edge a\\<close>\n                \\<open>length(ParamDefs (targetnode a)) = length outs\\<close>\n                \\<open>(ParamDefs (targetnode a))!i = V\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  i < length (ParamDefs (targetnode a))\n  valid_edge a\n  length (ParamDefs (targetnode a)) = length outs\n  V = ParamDefs (targetnode a) ! i\n  Actual_out (targetnode a, i) \\<notin> HRB_slice S", "have rspp_eq:\"(rspp (targetnode a) \n                (HRB_slice S) outs (fst cfx) (fst cf)) V = \n                (fst cfx)((ParamDefs (targetnode a))!i)\"\n                \"(rspp (targetnode a) \n                (HRB_slice S) outs (fst cfx') (fst cf')) V = \n                (fst cfx')((ParamDefs (targetnode a))!i)\""], ["proof (prove)\nusing this:\n  i < length (ParamDefs (targetnode a))\n  valid_edge a\n  length (ParamDefs (targetnode a)) = length outs\n  V = ParamDefs (targetnode a) ! i\n  Actual_out (targetnode a, i) \\<notin> HRB_slice S\n\ngoal (1 subgoal):\n 1. rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    fst cfx (ParamDefs (targetnode a) ! i) &&&\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V =\n    fst cfx' (ParamDefs (targetnode a) ! i)", "by(auto intro:rspp_Actual_out_notin_slice)"], ["proof (state)\nthis:\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n  fst cfx (ParamDefs (targetnode a) ! i)\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V =\n  fst cfx' (ParamDefs (targetnode a) ! i)\n\ngoal (1 subgoal):\n 1. Actual_out (targetnode a, i) \\<notin> HRB_slice S \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "from \\<open>\\<forall>V\\<in>rv S (CFG_node (sourcenode c')). \n                (fst cfx) V = (fst cfx') V\\<close>\n                \\<open>V \\<in> rv S (CFG_node (targetnode a))\\<close>\n                \\<open>\\<forall>V \\<in> rv S (CFG_node (targetnode a)).\n                V \\<in> rv S (CFG_node (sourcenode c'))\\<close>\n                \\<open>(ParamDefs (targetnode a))!i = V\\<close>[THEN sym]"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode c')). fst cfx V = fst cfx' V\n  V \\<in> rv S (CFG_node (targetnode a))\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n     V \\<in> rv S (CFG_node (sourcenode c'))\n  V = ParamDefs (targetnode a) ! i", "have \"(fst cfx) (ParamDefs (targetnode a) ! i) =\n                (fst cfx') (ParamDefs (targetnode a) ! i)\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode c')). fst cfx V = fst cfx' V\n  V \\<in> rv S (CFG_node (targetnode a))\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n     V \\<in> rv S (CFG_node (sourcenode c'))\n  V = ParamDefs (targetnode a) ! i\n\ngoal (1 subgoal):\n 1. fst cfx (ParamDefs (targetnode a) ! i) =\n    fst cfx' (ParamDefs (targetnode a) ! i)", "by fastforce"], ["proof (state)\nthis:\n  fst cfx (ParamDefs (targetnode a) ! i) =\n  fst cfx' (ParamDefs (targetnode a) ! i)\n\ngoal (1 subgoal):\n 1. Actual_out (targetnode a, i) \\<notin> HRB_slice S \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "with rspp_eq"], ["proof (chain)\npicking this:\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n  fst cfx (ParamDefs (targetnode a) ! i)\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V =\n  fst cfx' (ParamDefs (targetnode a) ! i)\n  fst cfx (ParamDefs (targetnode a) ! i) =\n  fst cfx' (ParamDefs (targetnode a) ! i)", "show ?thesis"], ["proof (prove)\nusing this:\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n  fst cfx (ParamDefs (targetnode a) ! i)\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V =\n  fst cfx' (ParamDefs (targetnode a) ! i)\n  fst cfx (ParamDefs (targetnode a) ! i) =\n  fst cfx' (ParamDefs (targetnode a) ! i)\n\ngoal (1 subgoal):\n 1. rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "by fastforce"], ["proof (state)\nthis:\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V\n\ngoal (1 subgoal):\n 1. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "case False"], ["proof (state)\nthis:\n  V \\<notin> set (ParamDefs (targetnode a))\n\ngoal (1 subgoal):\n 1. V \\<notin> set (ParamDefs (targetnode a)) \\<Longrightarrow>\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "with \\<open>\\<forall>V\\<in>rv S (CFG_node (sourcenode c')). \n              (fst cfx) V = (fst cfx') V\\<close>\n              \\<open>V \\<in> rv S (CFG_node (targetnode a))\\<close>\n              \\<open>\\<forall>V \\<in> rv S (CFG_node (targetnode a)).\n              V \\<in> rv S (CFG_node (sourcenode c'))\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode c')). fst cfx V = fst cfx' V\n  V \\<in> rv S (CFG_node (targetnode a))\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n     V \\<in> rv S (CFG_node (sourcenode c'))\n  V \\<notin> set (ParamDefs (targetnode a))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode c')). fst cfx V = fst cfx' V\n  V \\<in> rv S (CFG_node (targetnode a))\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n     V \\<in> rv S (CFG_node (sourcenode c'))\n  V \\<notin> set (ParamDefs (targetnode a))\n\ngoal (1 subgoal):\n 1. rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n    rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "by(fastforce simp:rspp_def map_merge_def)"], ["proof (state)\nthis:\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n  rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n     rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n     rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "with sx sx'"], ["proof (chain)\npicking this:\n  transfer (slice_kind S a) s =\n  (rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf), snd cfx) # cfs\n  transfer (slice_kind S a) s' =\n  (rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf'), snd cfx') #\n  cfs'\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n     rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n     rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V", "have rv':\"\\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n          state_val (transfer (slice_kind S a) s) V =\n          state_val (transfer (slice_kind S a) s') V\""], ["proof (prove)\nusing this:\n  transfer (slice_kind S a) s =\n  (rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf), snd cfx) # cfs\n  transfer (slice_kind S a) s' =\n  (rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf'), snd cfx') #\n  cfs'\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n     rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf) V =\n     rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf') V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n       state_val (transfer (slice_kind S a) s) V =\n       state_val (transfer (slice_kind S a) s') V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n     state_val (transfer (slice_kind S a) s) V =\n     state_val (transfer (slice_kind S a) s') V\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>preds (slice_kinds S (a # as)) s\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S (a # as)) s", "have \"preds (slice_kinds S as) \n          (transfer (slice_kind S a) s)\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S (a # as)) s\n\ngoal (1 subgoal):\n 1. preds (slice_kinds S as) (transfer (slice_kind S a) s)", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  preds (slice_kinds S as) (transfer (slice_kind S a) s)\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "moreover"], ["proof (state)\nthis:\n  preds (slice_kinds S as) (transfer (slice_kind S a) s)\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>preds (slice_kinds S as') s'\\<close> \\<open>as' = ax#asx\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S as') s'\n  as' = ax # asx", "have \"preds (slice_kinds S asx) \n          (transfer (slice_kind S a) s')\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S as') s'\n  as' = ax # asx\n\ngoal (1 subgoal):\n 1. preds (slice_kinds S asx) (transfer (slice_kind S a) s')", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  preds (slice_kinds S asx) (transfer (slice_kind S a) s')\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "moreover"], ["proof (state)\nthis:\n  preds (slice_kinds S asx) (transfer (slice_kind S a) s')\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>length s = Suc (length cs)\\<close> \\<open>cs = c' # cs'\\<close> sx"], ["proof (chain)\npicking this:\n  length s = Suc (length cs)\n  cs = c' # cs'\n  transfer (slice_kind S a) s =\n  (rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf), snd cfx) # cfs", "have \"length (transfer (slice_kind S a) s) = Suc (length cs')\""], ["proof (prove)\nusing this:\n  length s = Suc (length cs)\n  cs = c' # cs'\n  transfer (slice_kind S a) s =\n  (rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf), snd cfx) # cfs\n\ngoal (1 subgoal):\n 1. length (transfer (slice_kind S a) s) = Suc (length cs')", "by(simp,simp add:\\<open>s = cf#cfx#cfs\\<close>)"], ["proof (state)\nthis:\n  length (transfer (slice_kind S a) s) = Suc (length cs')\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "moreover"], ["proof (state)\nthis:\n  length (transfer (slice_kind S a) s) = Suc (length cs')\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>length s' = Suc (length cs)\\<close> \\<open>cs = c' # cs'\\<close> sx'"], ["proof (chain)\npicking this:\n  length s' = Suc (length cs)\n  cs = c' # cs'\n  transfer (slice_kind S a) s' =\n  (rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf'), snd cfx') #\n  cfs'", "have \"length (transfer (slice_kind S a) s') = Suc (length cs')\""], ["proof (prove)\nusing this:\n  length s' = Suc (length cs)\n  cs = c' # cs'\n  transfer (slice_kind S a) s' =\n  (rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf'), snd cfx') #\n  cfs'\n\ngoal (1 subgoal):\n 1. length (transfer (slice_kind S a) s') = Suc (length cs')", "by(simp,simp add:\\<open>s' = cf'#cfx'#cfs'\\<close>)"], ["proof (state)\nthis:\n  length (transfer (slice_kind S a) s') = Suc (length cs')\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "moreover"], ["proof (state)\nthis:\n  length (transfer (slice_kind S a) s') = Suc (length cs')\n\ngoal (2 subgoals):\n 1. sourcenode a\n    \\<in> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V\n 2. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from IH[OF \\<open>upd_cs cs' as = []\\<close> \\<open>same_level_path_aux cs' asx\\<close> \n          \\<open>\\<forall>c\\<in>set cs'. valid_edge c\\<close> \\<open>targetnode a -as\\<rightarrow>* (_Low_)\\<close> \n          \\<open>targetnode a -asx\\<rightarrow>* (_Low_)\\<close> rvs' snds rv' calculation] \\<open>as' = ax#asx\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S as) (transfer (slice_kind S a) s))\n      V =\n     state_val\n      (transfers (slice_kinds S asx) (transfer (slice_kind S a) s')) V\n  as' = ax # asx", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S as) (transfer (slice_kind S a) s))\n      V =\n     state_val\n      (transfers (slice_kinds S asx) (transfer (slice_kind S a) s')) V\n  as' = ax # asx\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "case False"], ["proof (state)\nthis:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from this \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have slice_kind:\"slice_kind S a = (\\<lambda>cf. True)\\<hookleftarrow>\\<^bsub>p\\<^esub>(\\<lambda>cf cf'. cf')\""], ["proof (prove)\nusing this:\n  sourcenode a \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. slice_kind S a =\n    \\<lambda>cf. True\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'", "by(rule slice_kind_Return)"], ["proof (state)\nthis:\n  slice_kind S a =\n  \\<lambda>cf. True\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "with \\<open>s = cf#cfx#cfs\\<close> \\<open>s' = cf'#cfx'#cfs'\\<close>"], ["proof (chain)\npicking this:\n  s = cf # cfx # cfs\n  s' = cf' # cfx' # cfs'\n  slice_kind S a =\n  \\<lambda>cf. True\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'", "have [simp]:\"transfer (slice_kind S a) s = cfx#cfs\"\n          \"transfer (slice_kind S a) s' = cfx'#cfs'\""], ["proof (prove)\nusing this:\n  s = cf # cfx # cfs\n  s' = cf' # cfx' # cfs'\n  slice_kind S a =\n  \\<lambda>cf. True\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'\n\ngoal (1 subgoal):\n 1. transfer (slice_kind S a) s = cfx # cfs &&&\n    transfer (slice_kind S a) s' = cfx' # cfs'", "by simp_all"], ["proof (state)\nthis:\n  transfer (slice_kind S a) s = cfx # cfs\n  transfer (slice_kind S a) s' = cfx' # cfs'\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from slice_kind \\<open>\\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i)\\<close> \n          \\<open>cs = c' # cs'\\<close> \\<open>s = cf#cfx#cfs\\<close> \\<open>s' = cf'#cfx'#cfs'\\<close>"], ["proof (chain)\npicking this:\n  slice_kind S a =\n  \\<lambda>cf. True\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'\n  \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i)\n  cs = c' # cs'\n  s = cf # cfx # cfs\n  s' = cf' # cfx' # cfs'", "have snds:\"\\<forall>i<Suc (length cs').\n          snd (transfer (slice_kind S a) s ! i) =\n          snd (transfer (slice_kind S a) s' ! i)\""], ["proof (prove)\nusing this:\n  slice_kind S a =\n  \\<lambda>cf. True\\<hookleftarrow>\\<^bsub>p\\<^esub>\\<lambda>cf cf'. cf'\n  \\<forall>i<Suc (length cs). snd (s ! i) = snd (s' ! i)\n  cs = c' # cs'\n  s = cf # cfx # cfs\n  s' = cf' # cfx' # cfs'\n\ngoal (1 subgoal):\n 1. \\<forall>i<Suc (length cs').\n       snd (transfer (slice_kind S a) s ! i) =\n       snd (transfer (slice_kind S a) s' ! i)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>i<Suc (length cs').\n     snd (transfer (slice_kind S a) s ! i) =\n     snd (transfer (slice_kind S a) s' ! i)\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from rvs1"], ["proof (chain)\npicking this:\n  \\<forall>i<length cs'.\n     \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n        fst ((cfx # cfs) ! Suc i) V = fst ((cfx' # cfs') ! Suc i) V", "have rvs':\"\\<forall>i<length cs'. \n          \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n          fst ((transfer (slice_kind S a) s) ! Suc i) V = \n          fst ((transfer (slice_kind S a) s') ! Suc i) V\""], ["proof (prove)\nusing this:\n  \\<forall>i<length cs'.\n     \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n        fst ((cfx # cfs) ! Suc i) V = fst ((cfx' # cfs') ! Suc i) V\n\ngoal (1 subgoal):\n 1. \\<forall>i<length cs'.\n       \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n          fst (transfer (slice_kind S a) s ! Suc i) V =\n          fst (transfer (slice_kind S a) s' ! Suc i) V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>i<length cs'.\n     \\<forall>V\\<in>rv S (CFG_node (sourcenode (cs' ! i))).\n        fst (transfer (slice_kind S a) s ! Suc i) V =\n        fst (transfer (slice_kind S a) s' ! Suc i) V\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>\\<forall>V \\<in> rv S (CFG_node (targetnode a)).\n          V \\<in> rv S (CFG_node (sourcenode c'))\\<close>\n          \\<open>\\<forall>V\\<in>rv S (CFG_node (sourcenode c')). \n          (fst cfx) V = (fst cfx') V\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n     V \\<in> rv S (CFG_node (sourcenode c'))\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode c')). fst cfx V = fst cfx' V", "have rv':\"\\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n          state_val (transfer (slice_kind S a) s) V =\n          state_val (transfer (slice_kind S a) s') V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n     V \\<in> rv S (CFG_node (sourcenode c'))\n  \\<forall>V\\<in>rv S (CFG_node (sourcenode c')). fst cfx V = fst cfx' V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n       state_val (transfer (slice_kind S a) s) V =\n       state_val (transfer (slice_kind S a) s') V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node (targetnode a)).\n     state_val (transfer (slice_kind S a) s) V =\n     state_val (transfer (slice_kind S a) s') V\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>preds (slice_kinds S (a # as)) s\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S (a # as)) s", "have \"preds (slice_kinds S as) \n          (transfer (slice_kind S a) s)\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S (a # as)) s\n\ngoal (1 subgoal):\n 1. preds (slice_kinds S as) (transfer (slice_kind S a) s)", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  preds (slice_kinds S as) (transfer (slice_kind S a) s)\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "moreover"], ["proof (state)\nthis:\n  preds (slice_kinds S as) (transfer (slice_kind S a) s)\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>preds (slice_kinds S as') s'\\<close> \\<open>as' = ax#asx\\<close>"], ["proof (chain)\npicking this:\n  preds (slice_kinds S as') s'\n  as' = ax # asx", "have \"preds (slice_kinds S asx) \n          (transfer (slice_kind S a) s')\""], ["proof (prove)\nusing this:\n  preds (slice_kinds S as') s'\n  as' = ax # asx\n\ngoal (1 subgoal):\n 1. preds (slice_kinds S asx) (transfer (slice_kind S a) s')", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  preds (slice_kinds S asx) (transfer (slice_kind S a) s')\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "moreover"], ["proof (state)\nthis:\n  preds (slice_kinds S asx) (transfer (slice_kind S a) s')\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>length s = Suc (length cs)\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  length s = Suc (length cs)\n  cs = c' # cs'", "have \"length (transfer (slice_kind S a) s) = Suc (length cs')\""], ["proof (prove)\nusing this:\n  length s = Suc (length cs)\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. length (transfer (slice_kind S a) s) = Suc (length cs')", "by(simp,simp add:\\<open>s = cf#cfx#cfs\\<close>)"], ["proof (state)\nthis:\n  length (transfer (slice_kind S a) s) = Suc (length cs')\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "moreover"], ["proof (state)\nthis:\n  length (transfer (slice_kind S a) s) = Suc (length cs')\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from \\<open>length s' = Suc (length cs)\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  length s' = Suc (length cs)\n  cs = c' # cs'", "have \"length (transfer (slice_kind S a) s') = Suc (length cs')\""], ["proof (prove)\nusing this:\n  length s' = Suc (length cs)\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. length (transfer (slice_kind S a) s') = Suc (length cs')", "by(simp,simp add:\\<open>s' = cf'#cfx'#cfs'\\<close>)"], ["proof (state)\nthis:\n  length (transfer (slice_kind S a) s') = Suc (length cs')\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "moreover"], ["proof (state)\nthis:\n  length (transfer (slice_kind S a) s') = Suc (length cs')\n\ngoal (1 subgoal):\n 1. sourcenode a\n    \\<notin> \\<lfloor>HRB_slice\n                       S\\<rfloor>\\<^bsub>CFG\\<^esub> \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "from IH[OF \\<open>upd_cs cs' as = []\\<close> \\<open>same_level_path_aux cs' asx\\<close> \n          \\<open>\\<forall>c\\<in>set cs'. valid_edge c\\<close> \\<open>targetnode a -as\\<rightarrow>* (_Low_)\\<close> \n          \\<open>targetnode a -asx\\<rightarrow>* (_Low_)\\<close> rvs' snds rv' calculation] \\<open>as' = ax#asx\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S as) (transfer (slice_kind S a) s))\n      V =\n     state_val\n      (transfers (slice_kinds S asx) (transfer (slice_kind S a) s')) V\n  as' = ax # asx", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S as) (transfer (slice_kind S a) s))\n      V =\n     state_val\n      (transfers (slice_kinds S asx) (transfer (slice_kind S a) s')) V\n  as' = ax # asx\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S (a # as)) s) V =\n       state_val (transfers (slice_kinds S as') s') V", "by(simp add:slice_kinds_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S (a # as)) s) V =\n     state_val (transfers (slice_kinds S as') s') V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rv_Low_Use_Low:\n  assumes \"m -as\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\" and \"m -as'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\" and \"get_proc m = Main\"\n  and \"\\<forall>V \\<in> rv S (CFG_node m). cf V = cf' V\"\n  and \"preds (slice_kinds S as) [(cf,undefined)]\"\n  and \"preds (slice_kinds S as') [(cf',undefined)]\"\n  and \"CFG_node (_Low_) \\<in> S\"\n  shows \"\\<forall>V \\<in> Use (_Low_). \n    state_val (transfers(slice_kinds S as) [(cf,undefined)]) V =\n    state_val (transfers(slice_kinds S as') [(cf',undefined)]) V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "proof(cases as)"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "case Nil"], ["proof (state)\nthis:\n  as = []\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "with \\<open>m -as\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  m -as\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n  as = []", "have \"valid_node m\" and \"m = (_Low_)\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n  as = []\n\ngoal (1 subgoal):\n 1. valid_node m &&& m = (_Low_)", "by(auto intro:path_valid_node simp:vp_def)"], ["proof (state)\nthis:\n  valid_node m\n  m = (_Low_)\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "{"], ["proof (state)\nthis:\n  valid_node m\n  m = (_Low_)\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "fix V"], ["proof (state)\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "assume \"V \\<in> Use (_Low_)\""], ["proof (state)\nthis:\n  V \\<in> Use (_Low_)\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "moreover"], ["proof (state)\nthis:\n  V \\<in> Use (_Low_)\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "from \\<open>valid_node m\\<close> \\<open>m = (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  valid_node m\n  m = (_Low_)", "have \"(_Low_) -[]\\<rightarrow>\\<^sub>\\<iota>* (_Low_)\""], ["proof (prove)\nusing this:\n  valid_node m\n  m = (_Low_)\n\ngoal (1 subgoal):\n 1. (_Low_) -[]\\<rightarrow>\\<^sub>\\<iota>* (_Low_)", "by(fastforce intro:empty_path simp:intra_path_def)"], ["proof (state)\nthis:\n  (_Low_) -[]\\<rightarrow>\\<^sub>\\<iota>* (_Low_)\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "moreover"], ["proof (state)\nthis:\n  (_Low_) -[]\\<rightarrow>\\<^sub>\\<iota>* (_Low_)\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "from \\<open>valid_node m\\<close> \\<open>m = (_Low_)\\<close> \\<open>CFG_node (_Low_) \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  valid_node m\n  m = (_Low_)\n  CFG_node (_Low_) \\<in> S", "have \"CFG_node (_Low_) \\<in> HRB_slice S\""], ["proof (prove)\nusing this:\n  valid_node m\n  m = (_Low_)\n  CFG_node (_Low_) \\<in> S\n\ngoal (1 subgoal):\n 1. CFG_node (_Low_) \\<in> HRB_slice S", "by(fastforce intro:HRB_slice_refl)"], ["proof (state)\nthis:\n  CFG_node (_Low_) \\<in> HRB_slice S\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "ultimately"], ["proof (chain)\npicking this:\n  V \\<in> Use (_Low_)\n  (_Low_) -[]\\<rightarrow>\\<^sub>\\<iota>* (_Low_)\n  CFG_node (_Low_) \\<in> HRB_slice S", "have \"V \\<in> rv S (CFG_node m)\""], ["proof (prove)\nusing this:\n  V \\<in> Use (_Low_)\n  (_Low_) -[]\\<rightarrow>\\<^sub>\\<iota>* (_Low_)\n  CFG_node (_Low_) \\<in> HRB_slice S\n\ngoal (1 subgoal):\n 1. V \\<in> rv S (CFG_node m)", "using \\<open>m = (_Low_)\\<close>"], ["proof (prove)\nusing this:\n  V \\<in> Use (_Low_)\n  (_Low_) -[]\\<rightarrow>\\<^sub>\\<iota>* (_Low_)\n  CFG_node (_Low_) \\<in> HRB_slice S\n  m = (_Low_)\n\ngoal (1 subgoal):\n 1. V \\<in> rv S (CFG_node m)", "by(auto intro!:rvI CFG_Use_SDG_Use simp:sourcenodes_def)"], ["proof (state)\nthis:\n  V \\<in> rv S (CFG_node m)\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "}"], ["proof (state)\nthis:\n  ?V2 \\<in> Use (_Low_) \\<Longrightarrow> ?V2 \\<in> rv S (CFG_node m)\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "hence \"\\<forall>V \\<in> Use (_Low_). V \\<in> rv S (CFG_node m)\""], ["proof (prove)\nusing this:\n  ?V2 \\<in> Use (_Low_) \\<Longrightarrow> ?V2 \\<in> rv S (CFG_node m)\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_). V \\<in> rv S (CFG_node m)", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_). V \\<in> rv S (CFG_node m)\n\ngoal (2 subgoals):\n 1. as = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "proof(cases \"L = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. L = {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "case True"], ["proof (state)\nthis:\n  L = {}\n\ngoal (2 subgoals):\n 1. L = {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "with UseLow"], ["proof (chain)\npicking this:\n  Use (_Low_) = L\n  L = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  Use (_Low_) = L\n  L = {}\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n     state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "case False"], ["proof (state)\nthis:\n  L \\<noteq> {}\n\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "from \\<open>m -as'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  m -as'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)", "have \"m -as'\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  m -as'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n\ngoal (1 subgoal):\n 1. m -as'\\<rightarrow>* (_Low_)", "by(simp add:vp_def)"], ["proof (state)\nthis:\n  m -as'\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "from \\<open>m -as'\\<rightarrow>* (_Low_)\\<close> \\<open>m = (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  m -as'\\<rightarrow>* (_Low_)\n  m = (_Low_)", "have \"as' = []\""], ["proof (prove)\nusing this:\n  m -as'\\<rightarrow>* (_Low_)\n  m = (_Low_)\n\ngoal (1 subgoal):\n 1. as' = []", "proof(induct m as' m'\\<equiv>\"(_Low_)\" rule:path.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (_Low_); (_Low_) = (_Low_)\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>n'' as a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        n'' = (_Low_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = n; targetnode a = n''; n = (_Low_)\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "case (Cons_path m'' as a m)"], ["proof (state)\nthis:\n  m'' -as\\<rightarrow>* (_Low_)\n  m'' = (_Low_) \\<Longrightarrow> as = []\n  valid_edge a\n  sourcenode a = m\n  targetnode a = m''\n  m = (_Low_)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (_Low_); (_Low_) = (_Low_)\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>n'' as a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        n'' = (_Low_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = n; targetnode a = n''; n = (_Low_)\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "from \\<open>valid_edge a\\<close> \\<open>sourcenode a = m\\<close> \\<open>m = (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = m\n  m = (_Low_)", "have \"targetnode a = (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = m\n  m = (_Low_)\n\ngoal (1 subgoal):\n 1. targetnode a = (_Exit_)", "by -(rule Exit_successor_of_Low,simp+)"], ["proof (state)\nthis:\n  targetnode a = (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (_Low_); (_Low_) = (_Low_)\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>n'' as a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        n'' = (_Low_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = n; targetnode a = n''; n = (_Low_)\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "with \\<open>targetnode a = m''\\<close> \\<open>m'' -as\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  targetnode a = m''\n  m'' -as\\<rightarrow>* (_Low_)\n  targetnode a = (_Exit_)", "have \"(_Low_) = (_Exit_)\""], ["proof (prove)\nusing this:\n  targetnode a = m''\n  m'' -as\\<rightarrow>* (_Low_)\n  targetnode a = (_Exit_)\n\ngoal (1 subgoal):\n 1. (_Low_) = (_Exit_)", "by -(drule path_Exit_source,auto)"], ["proof (state)\nthis:\n  (_Low_) = (_Exit_)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (_Low_); (_Low_) = (_Low_)\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>n'' as a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        n'' = (_Low_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = n; targetnode a = n''; n = (_Low_)\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "with False"], ["proof (chain)\npicking this:\n  L \\<noteq> {}\n  (_Low_) = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  L \\<noteq> {}\n  (_Low_) = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by -(drule Low_neq_Exit,simp)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid_node (_Low_); (_Low_) = (_Low_)\\<rbrakk>\n    \\<Longrightarrow> [] = []\n 2. \\<And>n'' as a n.\n       \\<lbrakk>n'' -as\\<rightarrow>* (_Low_);\n        n'' = (_Low_) \\<Longrightarrow> as = []; valid_edge a;\n        sourcenode a = n; targetnode a = n''; n = (_Low_)\\<rbrakk>\n       \\<Longrightarrow> a # as = []", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. a # as = []", "by simp"], ["proof (state)\nthis:\n  a # as = []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node (_Low_); (_Low_) = (_Low_)\\<rbrakk>\n    \\<Longrightarrow> [] = []", "qed simp"], ["proof (state)\nthis:\n  as' = []\n\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "with Nil \\<open>\\<forall>V \\<in> rv S (CFG_node m). cf V = cf' V\\<close>\n      \\<open>\\<forall>V \\<in> Use (_Low_). V \\<in> rv S (CFG_node m)\\<close>"], ["proof (chain)\npicking this:\n  as = []\n  \\<forall>V\\<in>rv S (CFG_node m). cf V = cf' V\n  \\<forall>V\\<in>Use (_Low_). V \\<in> rv S (CFG_node m)\n  as' = []", "show ?thesis"], ["proof (prove)\nusing this:\n  as = []\n  \\<forall>V\\<in>rv S (CFG_node m). cf V = cf' V\n  \\<forall>V\\<in>Use (_Low_). V \\<in> rv S (CFG_node m)\n  as' = []\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "by(fastforce simp:slice_kinds_def)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n     state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n     state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "case (Cons ax asx)"], ["proof (state)\nthis:\n  as = ax # asx\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "with \\<open>m -as\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  m -as\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n  as = ax # asx", "have \"sourcenode ax = m\" and \"valid_edge ax\"\n    and \"targetnode ax -asx\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n  as = ax # asx\n\ngoal (1 subgoal):\n 1. sourcenode ax = m &&&\n    valid_edge ax &&& targetnode ax -asx\\<rightarrow>* (_Low_)", "by(auto elim:path_split_Cons simp:vp_def)"], ["proof (state)\nthis:\n  sourcenode ax = m\n  valid_edge ax\n  targetnode ax -asx\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "proof(cases \"L = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. L = {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "case True"], ["proof (state)\nthis:\n  L = {}\n\ngoal (2 subgoals):\n 1. L = {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "with UseLow"], ["proof (chain)\npicking this:\n  Use (_Low_) = L\n  L = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  Use (_Low_) = L\n  L = {}\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n     state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "case False"], ["proof (state)\nthis:\n  L \\<noteq> {}\n\ngoal (1 subgoal):\n 1. L \\<noteq> {} \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "proof(cases as')"], ["proof (state)\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. \\<And>a list.\n       as' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "case Nil"], ["proof (state)\nthis:\n  as' = []\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. \\<And>a list.\n       as' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "with \\<open>m -as'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  m -as'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n  as' = []", "have \"m = (_Low_)\""], ["proof (prove)\nusing this:\n  m -as'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n  as' = []\n\ngoal (1 subgoal):\n 1. m = (_Low_)", "by(fastforce simp:vp_def)"], ["proof (state)\nthis:\n  m = (_Low_)\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. \\<And>a list.\n       as' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "with \\<open>valid_edge ax\\<close> \\<open>sourcenode ax = m\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  sourcenode ax = m\n  m = (_Low_)", "have \"targetnode ax = (_Exit_)\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  sourcenode ax = m\n  m = (_Low_)\n\ngoal (1 subgoal):\n 1. targetnode ax = (_Exit_)", "by -(rule Exit_successor_of_Low,simp+)"], ["proof (state)\nthis:\n  targetnode ax = (_Exit_)\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. \\<And>a list.\n       as' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "from Low_source_Exit_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Low_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>", "obtain a' where \"valid_edge a'\"\n        and \"sourcenode a' = (_Low_)\" and \"targetnode a' = (_Exit_)\"\n        and \"kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Low_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>valid_edge a'; sourcenode a' = (_Low_);\n         targetnode a' = (_Exit_);\n         kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_edge a'\n  sourcenode a' = (_Low_)\n  targetnode a' = (_Exit_)\n  kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. \\<And>a list.\n       as' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "from \\<open>valid_edge ax\\<close> \\<open>sourcenode ax = m\\<close> \\<open>m = (_Low_)\\<close> \n        \\<open>targetnode ax = (_Exit_)\\<close> \\<open>valid_edge a'\\<close> \\<open>sourcenode a' = (_Low_)\\<close> \n        \\<open>targetnode a' = (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  sourcenode ax = m\n  m = (_Low_)\n  targetnode ax = (_Exit_)\n  valid_edge a'\n  sourcenode a' = (_Low_)\n  targetnode a' = (_Exit_)", "have \"ax = a'\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  sourcenode ax = m\n  m = (_Low_)\n  targetnode ax = (_Exit_)\n  valid_edge a'\n  sourcenode a' = (_Low_)\n  targetnode a' = (_Exit_)\n\ngoal (1 subgoal):\n 1. ax = a'", "by(fastforce dest:edge_det)"], ["proof (state)\nthis:\n  ax = a'\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. \\<And>a list.\n       as' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "with \\<open>kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n  ax = a'", "have \"kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  kind a' = (\\<lambda>s. True)\\<^sub>\\<surd>\n  ax = a'\n\ngoal (1 subgoal):\n 1. kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>", "by simp"], ["proof (state)\nthis:\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. \\<And>a list.\n       as' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "with \\<open>targetnode ax = (_Exit_)\\<close> \\<open>targetnode ax -asx\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  targetnode ax = (_Exit_)\n  targetnode ax -asx\\<rightarrow>* (_Low_)\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>", "have \"(_Low_) = (_Exit_)\""], ["proof (prove)\nusing this:\n  targetnode ax = (_Exit_)\n  targetnode ax -asx\\<rightarrow>* (_Low_)\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (_Low_) = (_Exit_)", "by -(drule path_Exit_source,auto)"], ["proof (state)\nthis:\n  (_Low_) = (_Exit_)\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. \\<And>a list.\n       as' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "with False"], ["proof (chain)\npicking this:\n  L \\<noteq> {}\n  (_Low_) = (_Exit_)", "have False"], ["proof (prove)\nusing this:\n  L \\<noteq> {}\n  (_Low_) = (_Exit_)\n\ngoal (1 subgoal):\n 1. False", "by -(drule Low_neq_Exit,simp)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. as' = [] \\<Longrightarrow>\n    \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n 2. \\<And>a list.\n       as' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n     state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "case (Cons ax' asx')"], ["proof (state)\nthis:\n  as' = ax' # asx'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "from \\<open>m -as\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  m -as\\<rightarrow>\\<^sub>\\<surd>* (_Low_)", "have \"valid_path_aux [] as\" and \"m -as\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  m -as\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n\ngoal (1 subgoal):\n 1. valid_path_aux [] as &&& m -as\\<rightarrow>* (_Low_)", "by(simp_all add:vp_def valid_path_def)"], ["proof (state)\nthis:\n  valid_path_aux [] as\n  m -as\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "from this \\<open>as = ax#asx\\<close> \\<open>get_proc m = Main\\<close>"], ["proof (chain)\npicking this:\n  valid_path_aux [] as\n  m -as\\<rightarrow>* (_Low_)\n  as = ax # asx\n  get_proc m = Main", "have \"same_level_path_aux [] as \\<and> upd_cs [] as = []\""], ["proof (prove)\nusing this:\n  valid_path_aux [] as\n  m -as\\<rightarrow>* (_Low_)\n  as = ax # asx\n  get_proc m = Main\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] as \\<and> upd_cs [] as = []", "by -(rule vpa_Main_slpa[of _ _ m \"(_Low_)\"],\n        (fastforce intro!:get_proc_Low simp:valid_call_list_def)+)"], ["proof (state)\nthis:\n  same_level_path_aux [] as \\<and> upd_cs [] as = []\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "hence \"same_level_path_aux [] as\" and \"upd_cs [] as = []\""], ["proof (prove)\nusing this:\n  same_level_path_aux [] as \\<and> upd_cs [] as = []\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] as &&& upd_cs [] as = []", "by simp_all"], ["proof (state)\nthis:\n  same_level_path_aux [] as\n  upd_cs [] as = []\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "from \\<open>m -as'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  m -as'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)", "have \"valid_path_aux [] as'\" and \"m -as'\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  m -as'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n\ngoal (1 subgoal):\n 1. valid_path_aux [] as' &&& m -as'\\<rightarrow>* (_Low_)", "by(simp_all add:vp_def valid_path_def)"], ["proof (state)\nthis:\n  valid_path_aux [] as'\n  m -as'\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "from this \\<open>as' = ax'#asx'\\<close> \\<open>get_proc m = Main\\<close>"], ["proof (chain)\npicking this:\n  valid_path_aux [] as'\n  m -as'\\<rightarrow>* (_Low_)\n  as' = ax' # asx'\n  get_proc m = Main", "have \"same_level_path_aux [] as' \\<and> upd_cs [] as' = []\""], ["proof (prove)\nusing this:\n  valid_path_aux [] as'\n  m -as'\\<rightarrow>* (_Low_)\n  as' = ax' # asx'\n  get_proc m = Main\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] as' \\<and> upd_cs [] as' = []", "by -(rule vpa_Main_slpa[of _ _ m \"(_Low_)\"],\n        (fastforce intro!:get_proc_Low simp:valid_call_list_def)+)"], ["proof (state)\nthis:\n  same_level_path_aux [] as' \\<and> upd_cs [] as' = []\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "hence \"same_level_path_aux [] as'\""], ["proof (prove)\nusing this:\n  same_level_path_aux [] as' \\<and> upd_cs [] as' = []\n\ngoal (1 subgoal):\n 1. same_level_path_aux [] as'", "by simp"], ["proof (state)\nthis:\n  same_level_path_aux [] as'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       as' = a # list \\<Longrightarrow>\n       \\<forall>V\\<in>Use (_Low_).\n          state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n          state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "from \\<open>same_level_path_aux [] as\\<close> \\<open>upd_cs [] as = []\\<close>\n        \\<open>same_level_path_aux [] as'\\<close> \\<open>m -as\\<rightarrow>* (_Low_)\\<close> \\<open>m -as'\\<rightarrow>* (_Low_)\\<close>\n        \\<open>\\<forall>V \\<in> rv S (CFG_node m). cf V = cf' V\\<close> \\<open>CFG_node (_Low_) \\<in> S\\<close>\n        \\<open>preds (slice_kinds S as) [(cf,undefined)]\\<close>\n        \\<open>preds (slice_kinds S as') [(cf',undefined)]\\<close>"], ["proof (chain)\npicking this:\n  same_level_path_aux [] as\n  upd_cs [] as = []\n  same_level_path_aux [] as'\n  m -as\\<rightarrow>* (_Low_)\n  m -as'\\<rightarrow>* (_Low_)\n  \\<forall>V\\<in>rv S (CFG_node m). cf V = cf' V\n  CFG_node (_Low_) \\<in> S\n  preds (slice_kinds S as) [(cf, undefined)]\n  preds (slice_kinds S as') [(cf', undefined)]", "show ?thesis"], ["proof (prove)\nusing this:\n  same_level_path_aux [] as\n  upd_cs [] as = []\n  same_level_path_aux [] as'\n  m -as\\<rightarrow>* (_Low_)\n  m -as'\\<rightarrow>* (_Low_)\n  \\<forall>V\\<in>rv S (CFG_node m). cf V = cf' V\n  CFG_node (_Low_) \\<in> S\n  preds (slice_kinds S as) [(cf, undefined)]\n  preds (slice_kinds S as') [(cf', undefined)]\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S as') [(cf', undefined)]) V", "by -(erule slpa_rv_Low_Use_Low,auto)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n     state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n     state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S as) [(cf, undefined)]) V =\n     state_val (transfers (slice_kinds S as') [(cf', undefined)]) V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nonInterference_path_to_Low:\n  assumes \"[cf] \\<approx>\\<^sub>L [cf']\" and \"(_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  and \"CFG_node (_Low_) \\<in> S\"\n  and \"(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\" and \"preds (kinds as) [(cf,undefined)]\"\n  and \"(_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\" and \"preds (kinds as') [(cf',undefined)]\"\n  shows \"map fst (transfers (kinds as) [(cf,undefined)]) \\<approx>\\<^sub>L \n         map fst (transfers (kinds as') [(cf',undefined)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "from \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\\<close> \\<open>preds (kinds as) [(cf,undefined)]\\<close>\n    \\<open>CFG_node (_Low_) \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n  preds (kinds as) [(cf, undefined)]\n  CFG_node (_Low_) \\<in> S", "obtain asx where \"preds (slice_kinds S asx) [(cf,undefined)]\"\n    and \"\\<forall>V \\<in> Use (_Low_). \n    state_val (transfers (slice_kinds S asx) [(cf,undefined)]) V = \n    state_val (transfers (kinds as) [(cf,undefined)]) V\"\n    and \"slice_edges S [] as = slice_edges S [] asx\"\n    and \"transfers (kinds as) [(cf,undefined)] \\<noteq> []\"\n    and \"(_Entry_) -asx\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n  preds (kinds as) [(cf, undefined)]\n  CFG_node (_Low_) \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        \\<lbrakk>preds (slice_kinds S asx) [(cf, undefined)];\n         \\<forall>V\\<in>Use (_Low_).\n            state_val (transfers (slice_kinds S asx) [(cf, undefined)]) V =\n            state_val (transfers (kinds as) [(cf, undefined)]) V;\n         slice_edges S [] as = slice_edges S [] asx;\n         transfers (kinds as) [(cf, undefined)] \\<noteq> [];\n         (_Entry_) -asx\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule fundamental_property_of_static_slicing)"], ["proof (state)\nthis:\n  preds (slice_kinds S asx) [(cf, undefined)]\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S asx) [(cf, undefined)]) V =\n     state_val (transfers (kinds as) [(cf, undefined)]) V\n  slice_edges S [] as = slice_edges S [] asx\n  transfers (kinds as) [(cf, undefined)] \\<noteq> []\n  (_Entry_) -asx\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "from \\<open>(_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\\<close> \\<open>preds (kinds as') [(cf',undefined)]\\<close>\n    \\<open>CFG_node (_Low_) \\<in> S\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n  preds (kinds as') [(cf', undefined)]\n  CFG_node (_Low_) \\<in> S", "obtain asx' where \"preds (slice_kinds S asx') [(cf',undefined)]\"\n    and \"\\<forall>V \\<in> Use (_Low_). \n    state_val (transfers(slice_kinds S asx') [(cf',undefined)]) V = \n    state_val (transfers(kinds as') [(cf',undefined)]) V\"\n    and \"slice_edges S [] as' = \n    slice_edges S [] asx'\"\n    and \"transfers (kinds as') [(cf',undefined)] \\<noteq> []\"\n    and \"(_Entry_) -asx'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\""], ["proof (prove)\nusing this:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n  preds (kinds as') [(cf', undefined)]\n  CFG_node (_Low_) \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>asx'.\n        \\<lbrakk>preds (slice_kinds S asx') [(cf', undefined)];\n         \\<forall>V\\<in>Use (_Low_).\n            state_val (transfers (slice_kinds S asx') [(cf', undefined)])\n             V =\n            state_val (transfers (kinds as') [(cf', undefined)]) V;\n         slice_edges S [] as' = slice_edges S [] asx';\n         transfers (kinds as') [(cf', undefined)] \\<noteq> [];\n         (_Entry_) -asx'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule fundamental_property_of_static_slicing)"], ["proof (state)\nthis:\n  preds (slice_kinds S asx') [(cf', undefined)]\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S asx') [(cf', undefined)]) V =\n     state_val (transfers (kinds as') [(cf', undefined)]) V\n  slice_edges S [] as' = slice_edges S [] asx'\n  transfers (kinds as') [(cf', undefined)] \\<noteq> []\n  (_Entry_) -asx'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "from \\<open>[cf] \\<approx>\\<^sub>L [cf']\\<close> \\<open>(_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close>"], ["proof (chain)\npicking this:\n  [cf] \\<approx>\\<^sub>L [cf']\n  (_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>", "have \"\\<forall>V \\<in> rv S (CFG_node (_Entry_)). cf V = cf' V\""], ["proof (prove)\nusing this:\n  [cf] \\<approx>\\<^sub>L [cf']\n  (_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>rv S (CFG_node (_Entry_)). cf V = cf' V", "by(fastforce dest:lowEquivalence_relevant_nodes_Entry)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>rv S (CFG_node (_Entry_)). cf V = cf' V\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "with \\<open>(_Entry_) -asx \\<rightarrow>\\<^sub>\\<surd>*(_Low_)\\<close> \\<open>(_Entry_) -asx'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\\<close>\n    \\<open>CFG_node (_Low_) \\<in> S\\<close> \\<open>preds (slice_kinds S asx) [(cf,undefined)]\\<close>\n    \\<open>preds (slice_kinds S asx') [(cf',undefined)]\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -asx\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n  (_Entry_) -asx'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n  CFG_node (_Low_) \\<in> S\n  preds (slice_kinds S asx) [(cf, undefined)]\n  preds (slice_kinds S asx') [(cf', undefined)]\n  \\<forall>V\\<in>rv S (CFG_node (_Entry_)). cf V = cf' V", "have \"\\<forall>V \\<in> Use (_Low_). \n    state_val (transfers(slice_kinds S asx) [(cf,undefined)]) V =\n    state_val (transfers(slice_kinds S asx') [(cf',undefined)]) V\""], ["proof (prove)\nusing this:\n  (_Entry_) -asx\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n  (_Entry_) -asx'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n  CFG_node (_Low_) \\<in> S\n  preds (slice_kinds S asx) [(cf, undefined)]\n  preds (slice_kinds S asx') [(cf', undefined)]\n  \\<forall>V\\<in>rv S (CFG_node (_Entry_)). cf V = cf' V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (_Low_).\n       state_val (transfers (slice_kinds S asx) [(cf, undefined)]) V =\n       state_val (transfers (slice_kinds S asx') [(cf', undefined)]) V", "by -(rule rv_Low_Use_Low,auto intro:get_proc_Entry)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S asx) [(cf, undefined)]) V =\n     state_val (transfers (slice_kinds S asx') [(cf', undefined)]) V\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "with \\<open>\\<forall>V \\<in> Use (_Low_). \n    state_val (transfers (slice_kinds S asx) [(cf,undefined)]) V = \n    state_val (transfers (kinds as) [(cf,undefined)]) V\\<close>\n    \\<open>\\<forall>V \\<in> Use (_Low_). \n    state_val (transfers(slice_kinds S asx') [(cf',undefined)]) V = \n    state_val (transfers(kinds as') [(cf',undefined)]) V\\<close>\n    \\<open>transfers (kinds as) [(cf,undefined)] \\<noteq> []\\<close> \n    \\<open>transfers (kinds as') [(cf',undefined)] \\<noteq> []\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S asx) [(cf, undefined)]) V =\n     state_val (transfers (kinds as) [(cf, undefined)]) V\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S asx') [(cf', undefined)]) V =\n     state_val (transfers (kinds as') [(cf', undefined)]) V\n  transfers (kinds as) [(cf, undefined)] \\<noteq> []\n  transfers (kinds as') [(cf', undefined)] \\<noteq> []\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S asx) [(cf, undefined)]) V =\n     state_val (transfers (slice_kinds S asx') [(cf', undefined)]) V", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S asx) [(cf, undefined)]) V =\n     state_val (transfers (kinds as) [(cf, undefined)]) V\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S asx') [(cf', undefined)]) V =\n     state_val (transfers (kinds as') [(cf', undefined)]) V\n  transfers (kinds as) [(cf, undefined)] \\<noteq> []\n  transfers (kinds as') [(cf', undefined)] \\<noteq> []\n  \\<forall>V\\<in>Use (_Low_).\n     state_val (transfers (slice_kinds S asx) [(cf, undefined)]) V =\n     state_val (transfers (slice_kinds S asx') [(cf', undefined)]) V\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "by(fastforce simp:lowEquivalence_def UseLow neq_Nil_conv)"], ["proof (state)\nthis:\n  map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n  map fst (transfers (kinds as') [(cf', undefined)])\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem nonInterference_path:\n  assumes \"[cf] \\<approx>\\<^sub>L [cf']\" and \"(_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  and \"CFG_node (_Low_) \\<in> S\"\n  and \"(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\" and \"preds (kinds as) [(cf,undefined)]\"\n  and \"(_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\" and \"preds (kinds as') [(cf',undefined)]\"\n  shows \"map fst (transfers (kinds as) [(cf,undefined)]) \\<approx>\\<^sub>L \n  map fst (transfers (kinds as') [(cf',undefined)])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "from \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "obtain x xs where \"as = x#xs\"\n    and \"(_Entry_) = sourcenode x\" and \"valid_edge x\" \n    and \"targetnode x -xs\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<And>x xs.\n        \\<lbrakk>as = x # xs; (_Entry_) = sourcenode x; valid_edge x;\n         targetnode x -xs\\<rightarrow>* (_Exit_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(cases \"as = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>x xs.\n                \\<lbrakk>as = x # xs; (_Entry_) = sourcenode x;\n                 valid_edge x;\n                 targetnode x -xs\\<rightarrow>* (_Exit_)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_); as = []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>x xs.\n                \\<lbrakk>as = x # xs; (_Entry_) = sourcenode x;\n                 valid_edge x;\n                 targetnode x -xs\\<rightarrow>* (_Exit_)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_);\n     as \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(clarsimp simp:vp_def,drule empty_path_nodes,drule Entry_noteq_Exit,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x xs.\n                \\<lbrakk>as = x # xs; (_Entry_) = sourcenode x;\n                 valid_edge x;\n                 targetnode x -xs\\<rightarrow>* (_Exit_)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_);\n     as \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(fastforce elim:path_split_Cons simp:vp_def)"], ["proof (state)\nthis:\n  as = x # xs\n  (_Entry_) = sourcenode x\n  valid_edge x\n  targetnode x -xs\\<rightarrow>* (_Exit_)\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "from \\<open>(_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "have \"valid_path as\""], ["proof (prove)\nusing this:\n  (_Entry_) -as\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. valid_path as", "by(simp add:vp_def)"], ["proof (state)\nthis:\n  valid_path as\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "from \\<open>valid_edge x\\<close>"], ["proof (chain)\npicking this:\n  valid_edge x", "have \"valid_node (targetnode x)\""], ["proof (prove)\nusing this:\n  valid_edge x\n\ngoal (1 subgoal):\n 1. valid_node (targetnode x)", "by simp"], ["proof (state)\nthis:\n  valid_node (targetnode x)\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "hence \"inner_node (targetnode x)\""], ["proof (prove)\nusing this:\n  valid_node (targetnode x)\n\ngoal (1 subgoal):\n 1. inner_node (targetnode x)", "proof(cases rule:valid_node_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. targetnode x = (_Entry_) \\<Longrightarrow> inner_node (targetnode x)\n 2. targetnode x = (_Exit_) \\<Longrightarrow> inner_node (targetnode x)\n 3. inner_node (targetnode x) \\<Longrightarrow> inner_node (targetnode x)", "case Entry"], ["proof (state)\nthis:\n  targetnode x = (_Entry_)\n\ngoal (3 subgoals):\n 1. targetnode x = (_Entry_) \\<Longrightarrow> inner_node (targetnode x)\n 2. targetnode x = (_Exit_) \\<Longrightarrow> inner_node (targetnode x)\n 3. inner_node (targetnode x) \\<Longrightarrow> inner_node (targetnode x)", "with \\<open>valid_edge x\\<close>"], ["proof (chain)\npicking this:\n  valid_edge x\n  targetnode x = (_Entry_)", "have False"], ["proof (prove)\nusing this:\n  valid_edge x\n  targetnode x = (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by(rule Entry_target)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. targetnode x = (_Entry_) \\<Longrightarrow> inner_node (targetnode x)\n 2. targetnode x = (_Exit_) \\<Longrightarrow> inner_node (targetnode x)\n 3. inner_node (targetnode x) \\<Longrightarrow> inner_node (targetnode x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. inner_node (targetnode x)", "by simp"], ["proof (state)\nthis:\n  inner_node (targetnode x)\n\ngoal (2 subgoals):\n 1. targetnode x = (_Exit_) \\<Longrightarrow> inner_node (targetnode x)\n 2. inner_node (targetnode x) \\<Longrightarrow> inner_node (targetnode x)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. targetnode x = (_Exit_) \\<Longrightarrow> inner_node (targetnode x)\n 2. inner_node (targetnode x) \\<Longrightarrow> inner_node (targetnode x)", "case Exit"], ["proof (state)\nthis:\n  targetnode x = (_Exit_)\n\ngoal (2 subgoals):\n 1. targetnode x = (_Exit_) \\<Longrightarrow> inner_node (targetnode x)\n 2. inner_node (targetnode x) \\<Longrightarrow> inner_node (targetnode x)", "with \\<open>targetnode x -xs\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  targetnode x -xs\\<rightarrow>* (_Exit_)\n  targetnode x = (_Exit_)", "have \"xs = []\""], ["proof (prove)\nusing this:\n  targetnode x -xs\\<rightarrow>* (_Exit_)\n  targetnode x = (_Exit_)\n\ngoal (1 subgoal):\n 1. xs = []", "by -(drule path_Exit_source,auto)"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. targetnode x = (_Exit_) \\<Longrightarrow> inner_node (targetnode x)\n 2. inner_node (targetnode x) \\<Longrightarrow> inner_node (targetnode x)", "from Entry_Exit_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "obtain z where \"valid_edge z\"\n      and \"sourcenode z = (_Entry_)\" and \"targetnode z = (_Exit_)\"\n      and \"kind z = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>valid_edge z; sourcenode z = (_Entry_);\n         targetnode z = (_Exit_);\n         kind z = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_edge z\n  sourcenode z = (_Entry_)\n  targetnode z = (_Exit_)\n  kind z = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. targetnode x = (_Exit_) \\<Longrightarrow> inner_node (targetnode x)\n 2. inner_node (targetnode x) \\<Longrightarrow> inner_node (targetnode x)", "from \\<open>valid_edge x\\<close> \\<open>valid_edge z\\<close> \\<open>(_Entry_) = sourcenode x\\<close> \n      \\<open>sourcenode z = (_Entry_)\\<close> Exit \\<open>targetnode z = (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge x\n  valid_edge z\n  (_Entry_) = sourcenode x\n  sourcenode z = (_Entry_)\n  targetnode x = (_Exit_)\n  targetnode z = (_Exit_)", "have \"x = z\""], ["proof (prove)\nusing this:\n  valid_edge x\n  valid_edge z\n  (_Entry_) = sourcenode x\n  sourcenode z = (_Entry_)\n  targetnode x = (_Exit_)\n  targetnode z = (_Exit_)\n\ngoal (1 subgoal):\n 1. x = z", "by(fastforce intro:edge_det)"], ["proof (state)\nthis:\n  x = z\n\ngoal (2 subgoals):\n 1. targetnode x = (_Exit_) \\<Longrightarrow> inner_node (targetnode x)\n 2. inner_node (targetnode x) \\<Longrightarrow> inner_node (targetnode x)", "with \\<open>preds (kinds as) [(cf,undefined)]\\<close> \\<open>as = x#xs\\<close> \\<open>xs = []\\<close>\n      \\<open>kind z = (\\<lambda>s. False)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  preds (kinds as) [(cf, undefined)]\n  as = x # xs\n  xs = []\n  kind z = (\\<lambda>s. False)\\<^sub>\\<surd>\n  x = z", "have False"], ["proof (prove)\nusing this:\n  preds (kinds as) [(cf, undefined)]\n  as = x # xs\n  xs = []\n  kind z = (\\<lambda>s. False)\\<^sub>\\<surd>\n  x = z\n\ngoal (1 subgoal):\n 1. False", "by(simp add:kinds_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. targetnode x = (_Exit_) \\<Longrightarrow> inner_node (targetnode x)\n 2. inner_node (targetnode x) \\<Longrightarrow> inner_node (targetnode x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. inner_node (targetnode x)", "by simp"], ["proof (state)\nthis:\n  inner_node (targetnode x)\n\ngoal (1 subgoal):\n 1. inner_node (targetnode x) \\<Longrightarrow> inner_node (targetnode x)", "qed simp"], ["proof (state)\nthis:\n  inner_node (targetnode x)\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "with \\<open>targetnode x -xs\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  targetnode x -xs\\<rightarrow>* (_Exit_)\n  inner_node (targetnode x)", "obtain x' xs' where \"xs = xs'@[x']\"\n    and \"targetnode x -xs'\\<rightarrow>* (_Low_)\" and \"kind x' = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  targetnode x -xs\\<rightarrow>* (_Exit_)\n  inner_node (targetnode x)\n\ngoal (1 subgoal):\n 1. (\\<And>xs' x'.\n        \\<lbrakk>xs = xs' @ [x']; targetnode x -xs'\\<rightarrow>* (_Low_);\n         kind x' = (\\<lambda>s. True)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:Exit_path_Low_path)"], ["proof (state)\nthis:\n  xs = xs' @ [x']\n  targetnode x -xs'\\<rightarrow>* (_Low_)\n  kind x' = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "with \\<open>(_Entry_) = sourcenode x\\<close> \\<open>valid_edge x\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) = sourcenode x\n  valid_edge x\n  xs = xs' @ [x']\n  targetnode x -xs'\\<rightarrow>* (_Low_)\n  kind x' = (\\<lambda>s. True)\\<^sub>\\<surd>", "have \"(_Entry_) -x#xs'\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  (_Entry_) = sourcenode x\n  valid_edge x\n  xs = xs' @ [x']\n  targetnode x -xs'\\<rightarrow>* (_Low_)\n  kind x' = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (_Entry_) -x # xs'\\<rightarrow>* (_Low_)", "by(fastforce intro:Cons_path)"], ["proof (state)\nthis:\n  (_Entry_) -x # xs'\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "from \\<open>valid_path as\\<close> \\<open>as = x#xs\\<close> \\<open>xs = xs'@[x']\\<close>"], ["proof (chain)\npicking this:\n  valid_path as\n  as = x # xs\n  xs = xs' @ [x']", "have \"valid_path (x#xs')\""], ["proof (prove)\nusing this:\n  valid_path as\n  as = x # xs\n  xs = xs' @ [x']\n\ngoal (1 subgoal):\n 1. valid_path (x # xs')", "by(simp add:valid_path_def del:valid_path_aux.simps)\n      (rule valid_path_aux_split,simp)"], ["proof (state)\nthis:\n  valid_path (x # xs')\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "with \\<open>(_Entry_) -x#xs'\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -x # xs'\\<rightarrow>* (_Low_)\n  valid_path (x # xs')", "have \"(_Entry_) -x#xs'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\""], ["proof (prove)\nusing this:\n  (_Entry_) -x # xs'\\<rightarrow>* (_Low_)\n  valid_path (x # xs')\n\ngoal (1 subgoal):\n 1. (_Entry_) -x # xs'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)", "by(simp add:vp_def)"], ["proof (state)\nthis:\n  (_Entry_) -x # xs'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "from \\<open>as = x#xs\\<close> \\<open>xs = xs'@[x']\\<close>"], ["proof (chain)\npicking this:\n  as = x # xs\n  xs = xs' @ [x']", "have \"as = (x#xs')@[x']\""], ["proof (prove)\nusing this:\n  as = x # xs\n  xs = xs' @ [x']\n\ngoal (1 subgoal):\n 1. as = (x # xs') @ [x']", "by simp"], ["proof (state)\nthis:\n  as = (x # xs') @ [x']\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "with \\<open>preds (kinds as) [(cf,undefined)]\\<close>"], ["proof (chain)\npicking this:\n  preds (kinds as) [(cf, undefined)]\n  as = (x # xs') @ [x']", "have \"preds (kinds (x#xs')) [(cf,undefined)]\""], ["proof (prove)\nusing this:\n  preds (kinds as) [(cf, undefined)]\n  as = (x # xs') @ [x']\n\ngoal (1 subgoal):\n 1. preds (kinds (x # xs')) [(cf, undefined)]", "by(simp add:kinds_def preds_split)"], ["proof (state)\nthis:\n  preds (kinds (x # xs')) [(cf, undefined)]\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "from \\<open>(_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "obtain y ys where \"as' = y#ys\"\n    and \"(_Entry_) = sourcenode y\" and \"valid_edge y\" \n    and \"targetnode y -ys\\<rightarrow>* (_Exit_)\""], ["proof (prove)\nusing this:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. (\\<And>y ys.\n        \\<lbrakk>as' = y # ys; (_Entry_) = sourcenode y; valid_edge y;\n         targetnode y -ys\\<rightarrow>* (_Exit_)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(cases \"as' = []\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>y ys.\n                \\<lbrakk>as' = y # ys; (_Entry_) = sourcenode y;\n                 valid_edge y;\n                 targetnode y -ys\\<rightarrow>* (_Exit_)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_); as' = []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>y ys.\n                \\<lbrakk>as' = y # ys; (_Entry_) = sourcenode y;\n                 valid_edge y;\n                 targetnode y -ys\\<rightarrow>* (_Exit_)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_);\n     as' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(clarsimp simp:vp_def,drule empty_path_nodes,drule Entry_noteq_Exit,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>y ys.\n                \\<lbrakk>as' = y # ys; (_Entry_) = sourcenode y;\n                 valid_edge y;\n                 targetnode y -ys\\<rightarrow>* (_Exit_)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_);\n     as' \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(fastforce elim:path_split_Cons simp:vp_def)"], ["proof (state)\nthis:\n  as' = y # ys\n  (_Entry_) = sourcenode y\n  valid_edge y\n  targetnode y -ys\\<rightarrow>* (_Exit_)\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "from \\<open>(_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)", "have \"valid_path as'\""], ["proof (prove)\nusing this:\n  (_Entry_) -as'\\<rightarrow>\\<^sub>\\<surd>* (_Exit_)\n\ngoal (1 subgoal):\n 1. valid_path as'", "by(simp add:vp_def)"], ["proof (state)\nthis:\n  valid_path as'\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "from \\<open>valid_edge y\\<close>"], ["proof (chain)\npicking this:\n  valid_edge y", "have \"valid_node (targetnode y)\""], ["proof (prove)\nusing this:\n  valid_edge y\n\ngoal (1 subgoal):\n 1. valid_node (targetnode y)", "by simp"], ["proof (state)\nthis:\n  valid_node (targetnode y)\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "hence \"inner_node (targetnode y)\""], ["proof (prove)\nusing this:\n  valid_node (targetnode y)\n\ngoal (1 subgoal):\n 1. inner_node (targetnode y)", "proof(cases rule:valid_node_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. targetnode y = (_Entry_) \\<Longrightarrow> inner_node (targetnode y)\n 2. targetnode y = (_Exit_) \\<Longrightarrow> inner_node (targetnode y)\n 3. inner_node (targetnode y) \\<Longrightarrow> inner_node (targetnode y)", "case Entry"], ["proof (state)\nthis:\n  targetnode y = (_Entry_)\n\ngoal (3 subgoals):\n 1. targetnode y = (_Entry_) \\<Longrightarrow> inner_node (targetnode y)\n 2. targetnode y = (_Exit_) \\<Longrightarrow> inner_node (targetnode y)\n 3. inner_node (targetnode y) \\<Longrightarrow> inner_node (targetnode y)", "with \\<open>valid_edge y\\<close>"], ["proof (chain)\npicking this:\n  valid_edge y\n  targetnode y = (_Entry_)", "have False"], ["proof (prove)\nusing this:\n  valid_edge y\n  targetnode y = (_Entry_)\n\ngoal (1 subgoal):\n 1. False", "by(rule Entry_target)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. targetnode y = (_Entry_) \\<Longrightarrow> inner_node (targetnode y)\n 2. targetnode y = (_Exit_) \\<Longrightarrow> inner_node (targetnode y)\n 3. inner_node (targetnode y) \\<Longrightarrow> inner_node (targetnode y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. inner_node (targetnode y)", "by simp"], ["proof (state)\nthis:\n  inner_node (targetnode y)\n\ngoal (2 subgoals):\n 1. targetnode y = (_Exit_) \\<Longrightarrow> inner_node (targetnode y)\n 2. inner_node (targetnode y) \\<Longrightarrow> inner_node (targetnode y)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. targetnode y = (_Exit_) \\<Longrightarrow> inner_node (targetnode y)\n 2. inner_node (targetnode y) \\<Longrightarrow> inner_node (targetnode y)", "case Exit"], ["proof (state)\nthis:\n  targetnode y = (_Exit_)\n\ngoal (2 subgoals):\n 1. targetnode y = (_Exit_) \\<Longrightarrow> inner_node (targetnode y)\n 2. inner_node (targetnode y) \\<Longrightarrow> inner_node (targetnode y)", "with \\<open>targetnode y -ys\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  targetnode y -ys\\<rightarrow>* (_Exit_)\n  targetnode y = (_Exit_)", "have \"ys = []\""], ["proof (prove)\nusing this:\n  targetnode y -ys\\<rightarrow>* (_Exit_)\n  targetnode y = (_Exit_)\n\ngoal (1 subgoal):\n 1. ys = []", "by -(drule path_Exit_source,auto)"], ["proof (state)\nthis:\n  ys = []\n\ngoal (2 subgoals):\n 1. targetnode y = (_Exit_) \\<Longrightarrow> inner_node (targetnode y)\n 2. inner_node (targetnode y) \\<Longrightarrow> inner_node (targetnode y)", "from Entry_Exit_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "obtain z where \"valid_edge z\"\n      and \"sourcenode z = (_Entry_)\" and \"targetnode z = (_Exit_)\"\n      and \"kind z = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_Exit_) \\<and>\n     kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        \\<lbrakk>valid_edge z; sourcenode z = (_Entry_);\n         targetnode z = (_Exit_);\n         kind z = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_edge z\n  sourcenode z = (_Entry_)\n  targetnode z = (_Exit_)\n  kind z = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. targetnode y = (_Exit_) \\<Longrightarrow> inner_node (targetnode y)\n 2. inner_node (targetnode y) \\<Longrightarrow> inner_node (targetnode y)", "from \\<open>valid_edge y\\<close> \\<open>valid_edge z\\<close> \\<open>(_Entry_) = sourcenode y\\<close> \n      \\<open>sourcenode z = (_Entry_)\\<close> Exit \\<open>targetnode z = (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge y\n  valid_edge z\n  (_Entry_) = sourcenode y\n  sourcenode z = (_Entry_)\n  targetnode y = (_Exit_)\n  targetnode z = (_Exit_)", "have \"y = z\""], ["proof (prove)\nusing this:\n  valid_edge y\n  valid_edge z\n  (_Entry_) = sourcenode y\n  sourcenode z = (_Entry_)\n  targetnode y = (_Exit_)\n  targetnode z = (_Exit_)\n\ngoal (1 subgoal):\n 1. y = z", "by(fastforce intro:edge_det)"], ["proof (state)\nthis:\n  y = z\n\ngoal (2 subgoals):\n 1. targetnode y = (_Exit_) \\<Longrightarrow> inner_node (targetnode y)\n 2. inner_node (targetnode y) \\<Longrightarrow> inner_node (targetnode y)", "with \\<open>preds (kinds as') [(cf',undefined)]\\<close> \\<open>as' = y#ys\\<close> \\<open>ys = []\\<close>\n      \\<open>kind z = (\\<lambda>s. False)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  preds (kinds as') [(cf', undefined)]\n  as' = y # ys\n  ys = []\n  kind z = (\\<lambda>s. False)\\<^sub>\\<surd>\n  y = z", "have False"], ["proof (prove)\nusing this:\n  preds (kinds as') [(cf', undefined)]\n  as' = y # ys\n  ys = []\n  kind z = (\\<lambda>s. False)\\<^sub>\\<surd>\n  y = z\n\ngoal (1 subgoal):\n 1. False", "by(simp add:kinds_def)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. targetnode y = (_Exit_) \\<Longrightarrow> inner_node (targetnode y)\n 2. inner_node (targetnode y) \\<Longrightarrow> inner_node (targetnode y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. inner_node (targetnode y)", "by simp"], ["proof (state)\nthis:\n  inner_node (targetnode y)\n\ngoal (1 subgoal):\n 1. inner_node (targetnode y) \\<Longrightarrow> inner_node (targetnode y)", "qed simp"], ["proof (state)\nthis:\n  inner_node (targetnode y)\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "with \\<open>targetnode y -ys\\<rightarrow>* (_Exit_)\\<close>"], ["proof (chain)\npicking this:\n  targetnode y -ys\\<rightarrow>* (_Exit_)\n  inner_node (targetnode y)", "obtain y' ys' where \"ys = ys'@[y']\"\n    and \"targetnode y -ys'\\<rightarrow>* (_Low_)\" and \"kind y' = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  targetnode y -ys\\<rightarrow>* (_Exit_)\n  inner_node (targetnode y)\n\ngoal (1 subgoal):\n 1. (\\<And>ys' y'.\n        \\<lbrakk>ys = ys' @ [y']; targetnode y -ys'\\<rightarrow>* (_Low_);\n         kind y' = (\\<lambda>s. True)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:Exit_path_Low_path)"], ["proof (state)\nthis:\n  ys = ys' @ [y']\n  targetnode y -ys'\\<rightarrow>* (_Low_)\n  kind y' = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "with \\<open>(_Entry_) = sourcenode y\\<close> \\<open>valid_edge y\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) = sourcenode y\n  valid_edge y\n  ys = ys' @ [y']\n  targetnode y -ys'\\<rightarrow>* (_Low_)\n  kind y' = (\\<lambda>s. True)\\<^sub>\\<surd>", "have \"(_Entry_) -y#ys'\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  (_Entry_) = sourcenode y\n  valid_edge y\n  ys = ys' @ [y']\n  targetnode y -ys'\\<rightarrow>* (_Low_)\n  kind y' = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (_Entry_) -y # ys'\\<rightarrow>* (_Low_)", "by(fastforce intro:Cons_path)"], ["proof (state)\nthis:\n  (_Entry_) -y # ys'\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "from \\<open>valid_path as'\\<close> \\<open>as' = y#ys\\<close> \\<open>ys = ys'@[y']\\<close>"], ["proof (chain)\npicking this:\n  valid_path as'\n  as' = y # ys\n  ys = ys' @ [y']", "have \"valid_path (y#ys')\""], ["proof (prove)\nusing this:\n  valid_path as'\n  as' = y # ys\n  ys = ys' @ [y']\n\ngoal (1 subgoal):\n 1. valid_path (y # ys')", "by(simp add:valid_path_def del:valid_path_aux.simps)\n      (rule valid_path_aux_split,simp)"], ["proof (state)\nthis:\n  valid_path (y # ys')\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "with \\<open>(_Entry_) -y#ys'\\<rightarrow>* (_Low_)\\<close>"], ["proof (chain)\npicking this:\n  (_Entry_) -y # ys'\\<rightarrow>* (_Low_)\n  valid_path (y # ys')", "have \"(_Entry_) -y#ys'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\""], ["proof (prove)\nusing this:\n  (_Entry_) -y # ys'\\<rightarrow>* (_Low_)\n  valid_path (y # ys')\n\ngoal (1 subgoal):\n 1. (_Entry_) -y # ys'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)", "by(simp add:vp_def)"], ["proof (state)\nthis:\n  (_Entry_) -y # ys'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "from \\<open>as' = y#ys\\<close> \\<open>ys = ys'@[y']\\<close>"], ["proof (chain)\npicking this:\n  as' = y # ys\n  ys = ys' @ [y']", "have \"as' = (y#ys')@[y']\""], ["proof (prove)\nusing this:\n  as' = y # ys\n  ys = ys' @ [y']\n\ngoal (1 subgoal):\n 1. as' = (y # ys') @ [y']", "by simp"], ["proof (state)\nthis:\n  as' = (y # ys') @ [y']\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "with \\<open>preds (kinds as') [(cf',undefined)]\\<close>"], ["proof (chain)\npicking this:\n  preds (kinds as') [(cf', undefined)]\n  as' = (y # ys') @ [y']", "have \"preds (kinds (y#ys')) [(cf',undefined)]\""], ["proof (prove)\nusing this:\n  preds (kinds as') [(cf', undefined)]\n  as' = (y # ys') @ [y']\n\ngoal (1 subgoal):\n 1. preds (kinds (y # ys')) [(cf', undefined)]", "by(simp add:kinds_def preds_split)"], ["proof (state)\nthis:\n  preds (kinds (y # ys')) [(cf', undefined)]\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "from \\<open>[cf] \\<approx>\\<^sub>L [cf']\\<close> \\<open>(_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>CFG_node (_Low_) \\<in> S\\<close>\n    \\<open>(_Entry_) -x#xs'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\\<close> \\<open>preds (kinds (x#xs')) [(cf,undefined)]\\<close>\n    \\<open>(_Entry_) -y#ys'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\\<close> \\<open>preds (kinds (y#ys')) [(cf',undefined)]\\<close>"], ["proof (chain)\npicking this:\n  [cf] \\<approx>\\<^sub>L [cf']\n  (_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  CFG_node (_Low_) \\<in> S\n  (_Entry_) -x # xs'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n  preds (kinds (x # xs')) [(cf, undefined)]\n  (_Entry_) -y # ys'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n  preds (kinds (y # ys')) [(cf', undefined)]", "have \"map fst (transfers (kinds (x#xs')) [(cf,undefined)]) \\<approx>\\<^sub>L \n    map fst (transfers (kinds (y#ys')) [(cf',undefined)])\""], ["proof (prove)\nusing this:\n  [cf] \\<approx>\\<^sub>L [cf']\n  (_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  CFG_node (_Low_) \\<in> S\n  (_Entry_) -x # xs'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n  preds (kinds (x # xs')) [(cf, undefined)]\n  (_Entry_) -y # ys'\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n  preds (kinds (y # ys')) [(cf', undefined)]\n\ngoal (1 subgoal):\n 1. map fst\n     (transfers (kinds (x # xs')) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds (y # ys')) [(cf', undefined)])", "by(rule nonInterference_path_to_Low)"], ["proof (state)\nthis:\n  map fst (transfers (kinds (x # xs')) [(cf, undefined)]) \\<approx>\\<^sub>L\n  map fst (transfers (kinds (y # ys')) [(cf', undefined)])\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "with \\<open>as = x#xs\\<close> \\<open>xs = xs'@[x']\\<close> \\<open>kind x' = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close>\n    \\<open>as' = y#ys\\<close> \\<open>ys = ys'@[y']\\<close> \\<open>kind y' = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  as = x # xs\n  xs = xs' @ [x']\n  kind x' = (\\<lambda>s. True)\\<^sub>\\<surd>\n  as' = y # ys\n  ys = ys' @ [y']\n  kind y' = (\\<lambda>s. True)\\<^sub>\\<surd>\n  map fst (transfers (kinds (x # xs')) [(cf, undefined)]) \\<approx>\\<^sub>L\n  map fst (transfers (kinds (y # ys')) [(cf', undefined)])", "show ?thesis"], ["proof (prove)\nusing this:\n  as = x # xs\n  xs = xs' @ [x']\n  kind x' = (\\<lambda>s. True)\\<^sub>\\<surd>\n  as' = y # ys\n  ys = ys' @ [y']\n  kind y' = (\\<lambda>s. True)\\<^sub>\\<surd>\n  map fst (transfers (kinds (x # xs')) [(cf, undefined)]) \\<approx>\\<^sub>L\n  map fst (transfers (kinds (y # ys')) [(cf', undefined)])\n\ngoal (1 subgoal):\n 1. map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n    map fst (transfers (kinds as') [(cf', undefined)])", "apply(cases \"transfers (map kind xs') (transfer (kind x) [(cf,undefined)])\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>as = x # xs; xs = xs' @ [x'];\n     kind x' = (\\<lambda>s. True)\\<^sub>\\<surd>; as' = y # ys;\n     ys = ys' @ [y']; kind y' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n     map fst\n      (transfers (kinds (x # xs')) [(cf, undefined)]) \\<approx>\\<^sub>L\n     map fst (transfers (kinds (y # ys')) [(cf', undefined)]);\n     transfers (map kind xs') (transfer (kind x) [(cf, undefined)]) =\n     []\\<rbrakk>\n    \\<Longrightarrow> map fst\n                       (transfers (kinds as)\n                         [(cf, undefined)]) \\<approx>\\<^sub>L\n                      map fst (transfers (kinds as') [(cf', undefined)])\n 2. \\<And>a list.\n       \\<lbrakk>as = x # xs; xs = xs' @ [x'];\n        kind x' = (\\<lambda>s. True)\\<^sub>\\<surd>; as' = y # ys;\n        ys = ys' @ [y']; kind y' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        map fst\n         (transfers (kinds (x # xs')) [(cf, undefined)]) \\<approx>\\<^sub>L\n        map fst (transfers (kinds (y # ys')) [(cf', undefined)]);\n        transfers (map kind xs') (transfer (kind x) [(cf, undefined)]) =\n        a # list\\<rbrakk>\n       \\<Longrightarrow> map fst\n                          (transfers (kinds as)\n                            [(cf, undefined)]) \\<approx>\\<^sub>L\n                         map fst (transfers (kinds as') [(cf', undefined)])", "apply (auto simp add:kinds_def transfers_split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>as = x # xs' @ [x']; xs = xs' @ [x'];\n     kind x' = (\\<lambda>s. True)\\<^sub>\\<surd>; as' = y # ys' @ [y'];\n     ys = ys' @ [y']; kind y' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n     [] \\<approx>\\<^sub>L\n     map fst\n      (transfers (map kind ys') (transfer (kind y) [(cf', undefined)]));\n     transfers (map kind xs') (transfer (kind x) [(cf, undefined)]) =\n     []\\<rbrakk>\n    \\<Longrightarrow> [] \\<approx>\\<^sub>L\n                      map fst\n                       (transfer (\\<lambda>s. True)\\<^sub>\\<surd>\n                         (transfers (map kind ys')\n                           (transfer (kind y) [(cf', undefined)])))\n 2. \\<And>a b list.\n       \\<lbrakk>as = x # xs' @ [x']; xs = xs' @ [x'];\n        kind x' = (\\<lambda>s. True)\\<^sub>\\<surd>; as' = y # ys' @ [y'];\n        ys = ys' @ [y']; kind y' = (\\<lambda>s. True)\\<^sub>\\<surd>;\n        a # map fst list \\<approx>\\<^sub>L\n        map fst\n         (transfers (map kind ys') (transfer (kind y) [(cf', undefined)]));\n        transfers (map kind xs') (transfer (kind x) [(cf, undefined)]) =\n        (a, b) # list\\<rbrakk>\n       \\<Longrightarrow> a # map fst list \\<approx>\\<^sub>L\n                         map fst\n                          (transfer (\\<lambda>s. True)\\<^sub>\\<surd>\n                            (transfers (map kind ys')\n                              (transfer (kind y) [(cf', undefined)])))", "by((cases \"transfers (map kind ys') (transfer (kind y) [(cf',undefined)])\"),\n       (auto simp add:kinds_def transfers_split))+"], ["proof (state)\nthis:\n  map fst (transfers (kinds as) [(cf, undefined)]) \\<approx>\\<^sub>L\n  map fst (transfers (kinds as') [(cf', undefined)])\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>The second theorem assumes that we have a operational semantics,\nwhose evaluations are written \\<open>\\<langle>c,s\\<rangle> \\<Rightarrow> \\<langle>c',s'\\<rangle>\\<close> and which conforms \nto the CFG. The correctness theorem then states that if no high variable\ninfluenced a low variable and the initial states were low equivalent, the\nreulting states are again low equivalent:\\<close>"], ["", "locale NonInterferenceInter = \n  NonInterferenceInterGraph sourcenode targetnode kind valid_edge Entry \n    get_proc get_return_edges procs Main Exit Def Use ParamDefs ParamUses \n    H L High Low +\n  SemanticsProperty sourcenode targetnode kind valid_edge Entry get_proc\n    get_return_edges procs Main Exit Def Use ParamDefs ParamUses sem identifies\n  for sourcenode :: \"'edge \\<Rightarrow> 'node\" and targetnode :: \"'edge \\<Rightarrow> 'node\"\n  and kind :: \"'edge \\<Rightarrow> ('var,'val,'ret,'pname) edge_kind\" \n  and valid_edge :: \"'edge \\<Rightarrow> bool\"\n  and Entry :: \"'node\" (\"'('_Entry'_')\")  and get_proc :: \"'node \\<Rightarrow> 'pname\"\n  and get_return_edges :: \"'edge \\<Rightarrow> 'edge set\"\n  and procs :: \"('pname \\<times> 'var list \\<times> 'var list) list\" and Main :: \"'pname\"\n  and Exit::\"'node\"  (\"'('_Exit'_')\") \n  and Def :: \"'node \\<Rightarrow> 'var set\" and Use :: \"'node \\<Rightarrow> 'var set\"\n  and ParamDefs :: \"'node \\<Rightarrow> 'var list\" and ParamUses :: \"'node \\<Rightarrow> 'var set list\"\n  and sem :: \"'com \\<Rightarrow> ('var \\<rightharpoonup> 'val) list \\<Rightarrow> 'com \\<Rightarrow> ('var \\<rightharpoonup> 'val) list \\<Rightarrow> bool\" \n    (\"((1\\<langle>_,/_\\<rangle>) \\<Rightarrow>/ (1\\<langle>_,/_\\<rangle>))\" [0,0,0,0] 81)\n  and identifies :: \"'node \\<Rightarrow> 'com \\<Rightarrow> bool\" (\"_ \\<triangleq> _\" [51,0] 80)\n  and H :: \"'var set\" and L :: \"'var set\" \n  and High :: \"'node\"  (\"'('_High'_')\") and Low :: \"'node\" (\"'('_Low'_')\") +\n  fixes final :: \"'com \\<Rightarrow> bool\"\n  assumes final_edge_Low: \"\\<lbrakk>final c; n \\<triangleq> c\\<rbrakk> \n    \\<Longrightarrow> \\<exists>a. valid_edge a \\<and> sourcenode a = n \\<and> targetnode a = (_Low_) \\<and> kind a = \\<Up>id\"\nbegin"], ["", "text\\<open>The following theorem needs the explicit edge from \\<open>(_High_)\\<close>\n  to \\<open>n\\<close>. An approach using a \\<open>init\\<close> predicate for initial statements,\n  being reachable from \\<open>(_High_)\\<close> via a \\<open>(\\<lambda>s. True)\\<^sub>\\<surd>\\<close> edge,\n  does not work as the same statement could be identified by several nodes, some\n  initial, some not. E.g., in the program \\texttt{while (True) Skip;;Skip}\n  two nodes identify this inital statement: the initial node and the node\n  within the loop (because of loop unrolling).\\<close>"], ["", "theorem nonInterference:\n  assumes \"[cf\\<^sub>1] \\<approx>\\<^sub>L [cf\\<^sub>2]\" and \"(_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\"\n  and \"CFG_node (_Low_) \\<in> S\"\n  and \"valid_edge a\" and \"sourcenode a = (_High_)\" and \"targetnode a = n\" \n  and \"kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\" and \"n \\<triangleq> c\" and \"final c'\"\n  and \"\\<langle>c,[cf\\<^sub>1]\\<rangle> \\<Rightarrow> \\<langle>c',s\\<^sub>1\\<rangle>\" and \"\\<langle>c,[cf\\<^sub>2]\\<rangle> \\<Rightarrow> \\<langle>c',s\\<^sub>2\\<rangle>\"\n  shows \"s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "from High_target_Entry_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_High_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>", "obtain ax where \"valid_edge ax\"\n    and \"sourcenode ax = (_Entry_)\" and \"targetnode ax = (_High_)\"\n    and \"kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = (_Entry_) \\<and>\n     targetnode a = (_High_) \\<and>\n     kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>ax.\n        \\<lbrakk>valid_edge ax; sourcenode ax = (_Entry_);\n         targetnode ax = (_High_);\n         kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_edge ax\n  sourcenode ax = (_Entry_)\n  targetnode ax = (_High_)\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "from \\<open>n \\<triangleq> c\\<close> \\<open>\\<langle>c,[cf\\<^sub>1]\\<rangle> \\<Rightarrow> \\<langle>c',s\\<^sub>1\\<rangle>\\<close>"], ["proof (chain)\npicking this:\n  n \\<triangleq> c\n  \\<langle>c,[cf\\<^sub>1]\\<rangle> \\<Rightarrow>\n  \\<langle>c',s\\<^sub>1\\<rangle>", "obtain n\\<^sub>1 as\\<^sub>1 cfs\\<^sub>1 where \"n -as\\<^sub>1\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>1\" and \"n\\<^sub>1 \\<triangleq> c'\"\n    and \"preds (kinds as\\<^sub>1) [(cf\\<^sub>1,undefined)]\" \n    and \"transfers (kinds as\\<^sub>1) [(cf\\<^sub>1,undefined)] = cfs\\<^sub>1\" and \"map fst cfs\\<^sub>1 = s\\<^sub>1\""], ["proof (prove)\nusing this:\n  n \\<triangleq> c\n  \\<langle>c,[cf\\<^sub>1]\\<rangle> \\<Rightarrow>\n  \\<langle>c',s\\<^sub>1\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>as\\<^sub>1 n\\<^sub>1 cfs\\<^sub>1.\n        \\<lbrakk>n -as\\<^sub>1\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>1;\n         n\\<^sub>1 \\<triangleq> c';\n         preds (kinds as\\<^sub>1) [(cf\\<^sub>1, undefined)];\n         transfers (kinds as\\<^sub>1) [(cf\\<^sub>1, undefined)] =\n         cfs\\<^sub>1;\n         map fst cfs\\<^sub>1 = s\\<^sub>1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:fundamental_property)"], ["proof (state)\nthis:\n  n -as\\<^sub>1\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>1\n  n\\<^sub>1 \\<triangleq> c'\n  preds (kinds as\\<^sub>1) [(cf\\<^sub>1, undefined)]\n  transfers (kinds as\\<^sub>1) [(cf\\<^sub>1, undefined)] = cfs\\<^sub>1\n  map fst cfs\\<^sub>1 = s\\<^sub>1\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "from \\<open>n -as\\<^sub>1\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>1\\<close> \\<open>valid_edge a\\<close> \\<open>sourcenode a = (_High_)\\<close> \\<open>targetnode a = n\\<close>\n    \\<open>kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<^sub>1\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>1\n  valid_edge a\n  sourcenode a = (_High_)\n  targetnode a = n\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>", "have \"(_High_) -a#as\\<^sub>1\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>1\""], ["proof (prove)\nusing this:\n  n -as\\<^sub>1\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>1\n  valid_edge a\n  sourcenode a = (_High_)\n  targetnode a = n\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (_High_) -a # as\\<^sub>1\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>1", "by(fastforce intro:Cons_path simp:vp_def valid_path_def)"], ["proof (state)\nthis:\n  (_High_) -a # as\\<^sub>1\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>1\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "from \\<open>final c'\\<close> \\<open>n\\<^sub>1 \\<triangleq> c'\\<close>"], ["proof (chain)\npicking this:\n  final c'\n  n\\<^sub>1 \\<triangleq> c'", "obtain a\\<^sub>1 where \"valid_edge a\\<^sub>1\" and \"sourcenode a\\<^sub>1 = n\\<^sub>1\" \n    and \"targetnode a\\<^sub>1 = (_Low_)\" and \"kind a\\<^sub>1 = \\<Up>id\""], ["proof (prove)\nusing this:\n  final c'\n  n\\<^sub>1 \\<triangleq> c'\n\ngoal (1 subgoal):\n 1. (\\<And>a\\<^sub>1.\n        \\<lbrakk>valid_edge a\\<^sub>1; sourcenode a\\<^sub>1 = n\\<^sub>1;\n         targetnode a\\<^sub>1 = (_Low_); kind a\\<^sub>1 = \\<Up>id\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:final_edge_Low)"], ["proof (state)\nthis:\n  valid_edge a\\<^sub>1\n  sourcenode a\\<^sub>1 = n\\<^sub>1\n  targetnode a\\<^sub>1 = (_Low_)\n  kind a\\<^sub>1 = \\<Up>id\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "hence \"n\\<^sub>1 -[a\\<^sub>1]\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  valid_edge a\\<^sub>1\n  sourcenode a\\<^sub>1 = n\\<^sub>1\n  targetnode a\\<^sub>1 = (_Low_)\n  kind a\\<^sub>1 = \\<Up>id\n\ngoal (1 subgoal):\n 1. n\\<^sub>1 -[a\\<^sub>1]\\<rightarrow>* (_Low_)", "by(fastforce intro:path_edge)"], ["proof (state)\nthis:\n  n\\<^sub>1 -[a\\<^sub>1]\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "with \\<open>(_High_) -a#as\\<^sub>1\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  (_High_) -a # as\\<^sub>1\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>1\n  n\\<^sub>1 -[a\\<^sub>1]\\<rightarrow>* (_Low_)", "have \"(_High_) -(a#as\\<^sub>1)@[a\\<^sub>1]\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  (_High_) -a # as\\<^sub>1\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>1\n  n\\<^sub>1 -[a\\<^sub>1]\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. (_High_) -(a # as\\<^sub>1) @ [a\\<^sub>1]\\<rightarrow>* (_Low_)", "by(fastforce intro!:path_Append simp:vp_def)"], ["proof (state)\nthis:\n  (_High_) -(a # as\\<^sub>1) @ [a\\<^sub>1]\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "with \\<open>valid_edge ax\\<close> \\<open>sourcenode ax = (_Entry_)\\<close> \\<open>targetnode ax = (_High_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  sourcenode ax = (_Entry_)\n  targetnode ax = (_High_)\n  (_High_) -(a # as\\<^sub>1) @ [a\\<^sub>1]\\<rightarrow>* (_Low_)", "have \"(_Entry_) -ax#((a#as\\<^sub>1)@[a\\<^sub>1])\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  sourcenode ax = (_Entry_)\n  targetnode ax = (_High_)\n  (_High_) -(a # as\\<^sub>1) @ [a\\<^sub>1]\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. (_Entry_) -ax # (a # as\\<^sub>1) @ [a\\<^sub>1]\\<rightarrow>* (_Low_)", "by -(rule Cons_path)"], ["proof (state)\nthis:\n  (_Entry_) -ax # (a # as\\<^sub>1) @ [a\\<^sub>1]\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  (_Entry_) -ax # (a # as\\<^sub>1) @ [a\\<^sub>1]\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "from \\<open>(_High_) -a#as\\<^sub>1\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  (_High_) -a # as\\<^sub>1\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>1", "have \"valid_path_aux [] (a#as\\<^sub>1)\""], ["proof (prove)\nusing this:\n  (_High_) -a # as\\<^sub>1\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>1\n\ngoal (1 subgoal):\n 1. valid_path_aux [] (a # as\\<^sub>1)", "by(simp add:vp_def valid_path_def)"], ["proof (state)\nthis:\n  valid_path_aux [] (a # as\\<^sub>1)\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "with \\<open>kind a\\<^sub>1 = \\<Up>id\\<close>"], ["proof (chain)\npicking this:\n  kind a\\<^sub>1 = \\<Up>id\n  valid_path_aux [] (a # as\\<^sub>1)", "have \"valid_path_aux [] ((a#as\\<^sub>1)@[a\\<^sub>1])\""], ["proof (prove)\nusing this:\n  kind a\\<^sub>1 = \\<Up>id\n  valid_path_aux [] (a # as\\<^sub>1)\n\ngoal (1 subgoal):\n 1. valid_path_aux [] ((a # as\\<^sub>1) @ [a\\<^sub>1])", "by(fastforce intro:valid_path_aux_Append)"], ["proof (state)\nthis:\n  valid_path_aux [] ((a # as\\<^sub>1) @ [a\\<^sub>1])\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "with \\<open>kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n  valid_path_aux [] ((a # as\\<^sub>1) @ [a\\<^sub>1])", "have \"valid_path_aux [] (ax#((a#as\\<^sub>1)@[a\\<^sub>1]))\""], ["proof (prove)\nusing this:\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n  valid_path_aux [] ((a # as\\<^sub>1) @ [a\\<^sub>1])\n\ngoal (1 subgoal):\n 1. valid_path_aux [] (ax # (a # as\\<^sub>1) @ [a\\<^sub>1])", "by simp"], ["proof (state)\nthis:\n  valid_path_aux [] (ax # (a # as\\<^sub>1) @ [a\\<^sub>1])\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "ultimately"], ["proof (chain)\npicking this:\n  (_Entry_) -ax # (a # as\\<^sub>1) @ [a\\<^sub>1]\\<rightarrow>* (_Low_)\n  valid_path_aux [] (ax # (a # as\\<^sub>1) @ [a\\<^sub>1])", "have \"(_Entry_) -ax#((a#as\\<^sub>1)@[a\\<^sub>1])\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\""], ["proof (prove)\nusing this:\n  (_Entry_) -ax # (a # as\\<^sub>1) @ [a\\<^sub>1]\\<rightarrow>* (_Low_)\n  valid_path_aux [] (ax # (a # as\\<^sub>1) @ [a\\<^sub>1])\n\ngoal (1 subgoal):\n 1. (_Entry_) -ax #\n               (a # as\\<^sub>1) @\n               [a\\<^sub>1]\\<rightarrow>\\<^sub>\\<surd>* (_Low_)", "by(simp add:vp_def valid_path_def)"], ["proof (state)\nthis:\n  (_Entry_) -ax #\n             (a # as\\<^sub>1) @\n             [a\\<^sub>1]\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "from \\<open>valid_edge a\\<close> \\<open>kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close> \\<open>sourcenode a = (_High_)\\<close>\n    \\<open>targetnode a = n\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  sourcenode a = (_High_)\n  targetnode a = n", "have \"get_proc n = get_proc (_High_)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  sourcenode a = (_High_)\n  targetnode a = n\n\ngoal (1 subgoal):\n 1. get_proc n = get_proc (_High_)", "by(fastforce dest:get_proc_intra simp:intra_kind_def)"], ["proof (state)\nthis:\n  get_proc n = get_proc (_High_)\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "with get_proc_High"], ["proof (chain)\npicking this:\n  get_proc (_High_) = Main\n  get_proc n = get_proc (_High_)", "have \"get_proc n = Main\""], ["proof (prove)\nusing this:\n  get_proc (_High_) = Main\n  get_proc n = get_proc (_High_)\n\ngoal (1 subgoal):\n 1. get_proc n = Main", "by simp"], ["proof (state)\nthis:\n  get_proc n = Main\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "from \\<open>valid_edge a\\<^sub>1\\<close> \\<open>sourcenode a\\<^sub>1 = n\\<^sub>1\\<close> \\<open>targetnode a\\<^sub>1 = (_Low_)\\<close> \\<open>kind a\\<^sub>1 = \\<Up>id\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\\<^sub>1\n  sourcenode a\\<^sub>1 = n\\<^sub>1\n  targetnode a\\<^sub>1 = (_Low_)\n  kind a\\<^sub>1 = \\<Up>id", "have \"get_proc n\\<^sub>1 = get_proc (_Low_)\""], ["proof (prove)\nusing this:\n  valid_edge a\\<^sub>1\n  sourcenode a\\<^sub>1 = n\\<^sub>1\n  targetnode a\\<^sub>1 = (_Low_)\n  kind a\\<^sub>1 = \\<Up>id\n\ngoal (1 subgoal):\n 1. get_proc n\\<^sub>1 = get_proc (_Low_)", "by(fastforce dest:get_proc_intra simp:intra_kind_def)"], ["proof (state)\nthis:\n  get_proc n\\<^sub>1 = get_proc (_Low_)\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "with get_proc_Low"], ["proof (chain)\npicking this:\n  get_proc (_Low_) = Main\n  get_proc n\\<^sub>1 = get_proc (_Low_)", "have \"get_proc n\\<^sub>1 = Main\""], ["proof (prove)\nusing this:\n  get_proc (_Low_) = Main\n  get_proc n\\<^sub>1 = get_proc (_Low_)\n\ngoal (1 subgoal):\n 1. get_proc n\\<^sub>1 = Main", "by simp"], ["proof (state)\nthis:\n  get_proc n\\<^sub>1 = Main\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "from \\<open>n -as\\<^sub>1\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>1\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<^sub>1\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>1", "have \"n -as\\<^sub>1\\<rightarrow>\\<^bsub>sl\\<^esub>* n\\<^sub>1\""], ["proof (prove)\nusing this:\n  n -as\\<^sub>1\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>1\n\ngoal (1 subgoal):\n 1. n -as\\<^sub>1\\<rightarrow>\\<^bsub>sl\\<^esub>* n\\<^sub>1", "by(cases as\\<^sub>1)\n      (auto dest!:vpa_Main_slpa intro:\\<open>get_proc n\\<^sub>1 = Main\\<close> \\<open>get_proc n = Main\\<close>\n             simp:vp_def valid_path_def valid_call_list_def slp_def \n                  same_level_path_def simp del:valid_path_aux.simps)"], ["proof (state)\nthis:\n  n -as\\<^sub>1\\<rightarrow>\\<^bsub>sl\\<^esub>* n\\<^sub>1\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "then"], ["proof (chain)\npicking this:\n  n -as\\<^sub>1\\<rightarrow>\\<^bsub>sl\\<^esub>* n\\<^sub>1", "obtain cfx r where cfx:\"transfers (map kind as\\<^sub>1) [(cf\\<^sub>1,undefined)] = [(cfx,r)]\""], ["proof (prove)\nusing this:\n  n -as\\<^sub>1\\<rightarrow>\\<^bsub>sl\\<^esub>* n\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>cfx r.\n        transfers (map kind as\\<^sub>1) [(cf\\<^sub>1, undefined)] =\n        [(cfx, r)] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:slp_callstack_length_equal simp:kinds_def)"], ["proof (state)\nthis:\n  transfers (map kind as\\<^sub>1) [(cf\\<^sub>1, undefined)] = [(cfx, r)]\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "from \\<open>kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close> \\<open>kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close> \n    \\<open>preds (kinds as\\<^sub>1) [(cf\\<^sub>1,undefined)]\\<close> \\<open>kind a\\<^sub>1 = \\<Up>id\\<close> cfx"], ["proof (chain)\npicking this:\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  preds (kinds as\\<^sub>1) [(cf\\<^sub>1, undefined)]\n  kind a\\<^sub>1 = \\<Up>id\n  transfers (map kind as\\<^sub>1) [(cf\\<^sub>1, undefined)] = [(cfx, r)]", "have \"preds (kinds (ax#((a#as\\<^sub>1)@[a\\<^sub>1]))) [(cf\\<^sub>1,undefined)]\""], ["proof (prove)\nusing this:\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  preds (kinds as\\<^sub>1) [(cf\\<^sub>1, undefined)]\n  kind a\\<^sub>1 = \\<Up>id\n  transfers (map kind as\\<^sub>1) [(cf\\<^sub>1, undefined)] = [(cfx, r)]\n\ngoal (1 subgoal):\n 1. preds (kinds (ax # (a # as\\<^sub>1) @ [a\\<^sub>1]))\n     [(cf\\<^sub>1, undefined)]", "by(auto simp:kinds_def preds_split)"], ["proof (state)\nthis:\n  preds (kinds (ax # (a # as\\<^sub>1) @ [a\\<^sub>1]))\n   [(cf\\<^sub>1, undefined)]\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "from \\<open>n \\<triangleq> c\\<close> \\<open>\\<langle>c,[cf\\<^sub>2]\\<rangle> \\<Rightarrow> \\<langle>c',s\\<^sub>2\\<rangle>\\<close>"], ["proof (chain)\npicking this:\n  n \\<triangleq> c\n  \\<langle>c,[cf\\<^sub>2]\\<rangle> \\<Rightarrow>\n  \\<langle>c',s\\<^sub>2\\<rangle>", "obtain n\\<^sub>2 as\\<^sub>2 cfs\\<^sub>2 where \"n -as\\<^sub>2\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>2\" and \"n\\<^sub>2 \\<triangleq> c'\"\n    and \"preds (kinds as\\<^sub>2) [(cf\\<^sub>2,undefined)]\" \n    and \"transfers (kinds as\\<^sub>2) [(cf\\<^sub>2,undefined)] = cfs\\<^sub>2\" and \"map fst cfs\\<^sub>2 = s\\<^sub>2\""], ["proof (prove)\nusing this:\n  n \\<triangleq> c\n  \\<langle>c,[cf\\<^sub>2]\\<rangle> \\<Rightarrow>\n  \\<langle>c',s\\<^sub>2\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>as\\<^sub>2 n\\<^sub>2 cfs\\<^sub>2.\n        \\<lbrakk>n -as\\<^sub>2\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>2;\n         n\\<^sub>2 \\<triangleq> c';\n         preds (kinds as\\<^sub>2) [(cf\\<^sub>2, undefined)];\n         transfers (kinds as\\<^sub>2) [(cf\\<^sub>2, undefined)] =\n         cfs\\<^sub>2;\n         map fst cfs\\<^sub>2 = s\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:fundamental_property)"], ["proof (state)\nthis:\n  n -as\\<^sub>2\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>2\n  n\\<^sub>2 \\<triangleq> c'\n  preds (kinds as\\<^sub>2) [(cf\\<^sub>2, undefined)]\n  transfers (kinds as\\<^sub>2) [(cf\\<^sub>2, undefined)] = cfs\\<^sub>2\n  map fst cfs\\<^sub>2 = s\\<^sub>2\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "from \\<open>n -as\\<^sub>2\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>2\\<close> \\<open>valid_edge a\\<close> \\<open>sourcenode a = (_High_)\\<close> \\<open>targetnode a = n\\<close>\n    \\<open>kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<^sub>2\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>2\n  valid_edge a\n  sourcenode a = (_High_)\n  targetnode a = n\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>", "have \"(_High_) -a#as\\<^sub>2\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>2\""], ["proof (prove)\nusing this:\n  n -as\\<^sub>2\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>2\n  valid_edge a\n  sourcenode a = (_High_)\n  targetnode a = n\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (_High_) -a # as\\<^sub>2\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>2", "by(fastforce intro:Cons_path simp:vp_def valid_path_def)"], ["proof (state)\nthis:\n  (_High_) -a # as\\<^sub>2\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>2\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "from \\<open>final c'\\<close> \\<open>n\\<^sub>2 \\<triangleq> c'\\<close>"], ["proof (chain)\npicking this:\n  final c'\n  n\\<^sub>2 \\<triangleq> c'", "obtain a\\<^sub>2 where \"valid_edge a\\<^sub>2\" and \"sourcenode a\\<^sub>2 = n\\<^sub>2\" \n    and \"targetnode a\\<^sub>2 = (_Low_)\" and \"kind a\\<^sub>2 = \\<Up>id\""], ["proof (prove)\nusing this:\n  final c'\n  n\\<^sub>2 \\<triangleq> c'\n\ngoal (1 subgoal):\n 1. (\\<And>a\\<^sub>2.\n        \\<lbrakk>valid_edge a\\<^sub>2; sourcenode a\\<^sub>2 = n\\<^sub>2;\n         targetnode a\\<^sub>2 = (_Low_); kind a\\<^sub>2 = \\<Up>id\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:final_edge_Low)"], ["proof (state)\nthis:\n  valid_edge a\\<^sub>2\n  sourcenode a\\<^sub>2 = n\\<^sub>2\n  targetnode a\\<^sub>2 = (_Low_)\n  kind a\\<^sub>2 = \\<Up>id\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "hence \"n\\<^sub>2 -[a\\<^sub>2]\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  valid_edge a\\<^sub>2\n  sourcenode a\\<^sub>2 = n\\<^sub>2\n  targetnode a\\<^sub>2 = (_Low_)\n  kind a\\<^sub>2 = \\<Up>id\n\ngoal (1 subgoal):\n 1. n\\<^sub>2 -[a\\<^sub>2]\\<rightarrow>* (_Low_)", "by(fastforce intro:path_edge)"], ["proof (state)\nthis:\n  n\\<^sub>2 -[a\\<^sub>2]\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "with \\<open>(_High_) -a#as\\<^sub>2\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  (_High_) -a # as\\<^sub>2\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>2\n  n\\<^sub>2 -[a\\<^sub>2]\\<rightarrow>* (_Low_)", "have \"(_High_) -(a#as\\<^sub>2)@[a\\<^sub>2]\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  (_High_) -a # as\\<^sub>2\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>2\n  n\\<^sub>2 -[a\\<^sub>2]\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. (_High_) -(a # as\\<^sub>2) @ [a\\<^sub>2]\\<rightarrow>* (_Low_)", "by(fastforce intro!:path_Append simp:vp_def)"], ["proof (state)\nthis:\n  (_High_) -(a # as\\<^sub>2) @ [a\\<^sub>2]\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "with \\<open>valid_edge ax\\<close> \\<open>sourcenode ax = (_Entry_)\\<close> \\<open>targetnode ax = (_High_)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  sourcenode ax = (_Entry_)\n  targetnode ax = (_High_)\n  (_High_) -(a # as\\<^sub>2) @ [a\\<^sub>2]\\<rightarrow>* (_Low_)", "have \"(_Entry_) -ax#((a#as\\<^sub>2)@[a\\<^sub>2])\\<rightarrow>* (_Low_)\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  sourcenode ax = (_Entry_)\n  targetnode ax = (_High_)\n  (_High_) -(a # as\\<^sub>2) @ [a\\<^sub>2]\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. (_Entry_) -ax # (a # as\\<^sub>2) @ [a\\<^sub>2]\\<rightarrow>* (_Low_)", "by -(rule Cons_path)"], ["proof (state)\nthis:\n  (_Entry_) -ax # (a # as\\<^sub>2) @ [a\\<^sub>2]\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "moreover"], ["proof (state)\nthis:\n  (_Entry_) -ax # (a # as\\<^sub>2) @ [a\\<^sub>2]\\<rightarrow>* (_Low_)\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "from \\<open>(_High_) -a#as\\<^sub>2\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  (_High_) -a # as\\<^sub>2\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>2", "have \"valid_path_aux [] (a#as\\<^sub>2)\""], ["proof (prove)\nusing this:\n  (_High_) -a # as\\<^sub>2\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>2\n\ngoal (1 subgoal):\n 1. valid_path_aux [] (a # as\\<^sub>2)", "by(simp add:vp_def valid_path_def)"], ["proof (state)\nthis:\n  valid_path_aux [] (a # as\\<^sub>2)\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "with \\<open>kind a\\<^sub>2 = \\<Up>id\\<close>"], ["proof (chain)\npicking this:\n  kind a\\<^sub>2 = \\<Up>id\n  valid_path_aux [] (a # as\\<^sub>2)", "have \"valid_path_aux [] ((a#as\\<^sub>2)@[a\\<^sub>2])\""], ["proof (prove)\nusing this:\n  kind a\\<^sub>2 = \\<Up>id\n  valid_path_aux [] (a # as\\<^sub>2)\n\ngoal (1 subgoal):\n 1. valid_path_aux [] ((a # as\\<^sub>2) @ [a\\<^sub>2])", "by(fastforce intro:valid_path_aux_Append)"], ["proof (state)\nthis:\n  valid_path_aux [] ((a # as\\<^sub>2) @ [a\\<^sub>2])\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "with \\<open>kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n  valid_path_aux [] ((a # as\\<^sub>2) @ [a\\<^sub>2])", "have \"valid_path_aux [] (ax#((a#as\\<^sub>2)@[a\\<^sub>2]))\""], ["proof (prove)\nusing this:\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n  valid_path_aux [] ((a # as\\<^sub>2) @ [a\\<^sub>2])\n\ngoal (1 subgoal):\n 1. valid_path_aux [] (ax # (a # as\\<^sub>2) @ [a\\<^sub>2])", "by simp"], ["proof (state)\nthis:\n  valid_path_aux [] (ax # (a # as\\<^sub>2) @ [a\\<^sub>2])\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "ultimately"], ["proof (chain)\npicking this:\n  (_Entry_) -ax # (a # as\\<^sub>2) @ [a\\<^sub>2]\\<rightarrow>* (_Low_)\n  valid_path_aux [] (ax # (a # as\\<^sub>2) @ [a\\<^sub>2])", "have \"(_Entry_) -ax#((a#as\\<^sub>2)@[a\\<^sub>2])\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\""], ["proof (prove)\nusing this:\n  (_Entry_) -ax # (a # as\\<^sub>2) @ [a\\<^sub>2]\\<rightarrow>* (_Low_)\n  valid_path_aux [] (ax # (a # as\\<^sub>2) @ [a\\<^sub>2])\n\ngoal (1 subgoal):\n 1. (_Entry_) -ax #\n               (a # as\\<^sub>2) @\n               [a\\<^sub>2]\\<rightarrow>\\<^sub>\\<surd>* (_Low_)", "by(simp add:vp_def valid_path_def)"], ["proof (state)\nthis:\n  (_Entry_) -ax #\n             (a # as\\<^sub>2) @\n             [a\\<^sub>2]\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "from \\<open>valid_edge a\\<close> \\<open>kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close> \\<open>sourcenode a = (_High_)\\<close>\n    \\<open>targetnode a = n\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  sourcenode a = (_High_)\n  targetnode a = n", "have \"get_proc n = get_proc (_High_)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  sourcenode a = (_High_)\n  targetnode a = n\n\ngoal (1 subgoal):\n 1. get_proc n = get_proc (_High_)", "by(fastforce dest:get_proc_intra simp:intra_kind_def)"], ["proof (state)\nthis:\n  get_proc n = get_proc (_High_)\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "with get_proc_High"], ["proof (chain)\npicking this:\n  get_proc (_High_) = Main\n  get_proc n = get_proc (_High_)", "have \"get_proc n = Main\""], ["proof (prove)\nusing this:\n  get_proc (_High_) = Main\n  get_proc n = get_proc (_High_)\n\ngoal (1 subgoal):\n 1. get_proc n = Main", "by simp"], ["proof (state)\nthis:\n  get_proc n = Main\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "from \\<open>valid_edge a\\<^sub>2\\<close> \\<open>sourcenode a\\<^sub>2 = n\\<^sub>2\\<close> \\<open>targetnode a\\<^sub>2 = (_Low_)\\<close> \\<open>kind a\\<^sub>2 = \\<Up>id\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\\<^sub>2\n  sourcenode a\\<^sub>2 = n\\<^sub>2\n  targetnode a\\<^sub>2 = (_Low_)\n  kind a\\<^sub>2 = \\<Up>id", "have \"get_proc n\\<^sub>2 = get_proc (_Low_)\""], ["proof (prove)\nusing this:\n  valid_edge a\\<^sub>2\n  sourcenode a\\<^sub>2 = n\\<^sub>2\n  targetnode a\\<^sub>2 = (_Low_)\n  kind a\\<^sub>2 = \\<Up>id\n\ngoal (1 subgoal):\n 1. get_proc n\\<^sub>2 = get_proc (_Low_)", "by(fastforce dest:get_proc_intra simp:intra_kind_def)"], ["proof (state)\nthis:\n  get_proc n\\<^sub>2 = get_proc (_Low_)\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "with get_proc_Low"], ["proof (chain)\npicking this:\n  get_proc (_Low_) = Main\n  get_proc n\\<^sub>2 = get_proc (_Low_)", "have \"get_proc n\\<^sub>2 = Main\""], ["proof (prove)\nusing this:\n  get_proc (_Low_) = Main\n  get_proc n\\<^sub>2 = get_proc (_Low_)\n\ngoal (1 subgoal):\n 1. get_proc n\\<^sub>2 = Main", "by simp"], ["proof (state)\nthis:\n  get_proc n\\<^sub>2 = Main\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "from \\<open>n -as\\<^sub>2\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  n -as\\<^sub>2\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>2", "have \"n -as\\<^sub>2\\<rightarrow>\\<^bsub>sl\\<^esub>* n\\<^sub>2\""], ["proof (prove)\nusing this:\n  n -as\\<^sub>2\\<rightarrow>\\<^sub>\\<surd>* n\\<^sub>2\n\ngoal (1 subgoal):\n 1. n -as\\<^sub>2\\<rightarrow>\\<^bsub>sl\\<^esub>* n\\<^sub>2", "by(cases as\\<^sub>2)\n      (auto dest!:vpa_Main_slpa intro:\\<open>get_proc n\\<^sub>2 = Main\\<close> \\<open>get_proc n = Main\\<close>\n             simp:vp_def valid_path_def valid_call_list_def slp_def \n                  same_level_path_def simp del:valid_path_aux.simps)"], ["proof (state)\nthis:\n  n -as\\<^sub>2\\<rightarrow>\\<^bsub>sl\\<^esub>* n\\<^sub>2\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "then"], ["proof (chain)\npicking this:\n  n -as\\<^sub>2\\<rightarrow>\\<^bsub>sl\\<^esub>* n\\<^sub>2", "obtain cfx' r' \n    where cfx':\"transfers (map kind as\\<^sub>2) [(cf\\<^sub>2,undefined)] = [(cfx',r')]\""], ["proof (prove)\nusing this:\n  n -as\\<^sub>2\\<rightarrow>\\<^bsub>sl\\<^esub>* n\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>cfx' r'.\n        transfers (map kind as\\<^sub>2) [(cf\\<^sub>2, undefined)] =\n        [(cfx', r')] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:slp_callstack_length_equal simp:kinds_def)"], ["proof (state)\nthis:\n  transfers (map kind as\\<^sub>2) [(cf\\<^sub>2, undefined)] = [(cfx', r')]\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "from \\<open>kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close> \\<open>kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close> \n    \\<open>preds (kinds as\\<^sub>2) [(cf\\<^sub>2,undefined)]\\<close> \\<open>kind a\\<^sub>2 = \\<Up>id\\<close> cfx'"], ["proof (chain)\npicking this:\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  preds (kinds as\\<^sub>2) [(cf\\<^sub>2, undefined)]\n  kind a\\<^sub>2 = \\<Up>id\n  transfers (map kind as\\<^sub>2) [(cf\\<^sub>2, undefined)] = [(cfx', r')]", "have \"preds (kinds (ax#((a#as\\<^sub>2)@[a\\<^sub>2]))) [(cf\\<^sub>2,undefined)]\""], ["proof (prove)\nusing this:\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  preds (kinds as\\<^sub>2) [(cf\\<^sub>2, undefined)]\n  kind a\\<^sub>2 = \\<Up>id\n  transfers (map kind as\\<^sub>2) [(cf\\<^sub>2, undefined)] = [(cfx', r')]\n\ngoal (1 subgoal):\n 1. preds (kinds (ax # (a # as\\<^sub>2) @ [a\\<^sub>2]))\n     [(cf\\<^sub>2, undefined)]", "by(auto simp:kinds_def preds_split)"], ["proof (state)\nthis:\n  preds (kinds (ax # (a # as\\<^sub>2) @ [a\\<^sub>2]))\n   [(cf\\<^sub>2, undefined)]\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "from \\<open>[cf\\<^sub>1] \\<approx>\\<^sub>L [cf\\<^sub>2]\\<close> \\<open>(_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\\<close> \\<open>CFG_node (_Low_) \\<in> S\\<close>\n    \\<open>(_Entry_) -ax#((a#as\\<^sub>1)@[a\\<^sub>1])\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\\<close> \n    \\<open>preds (kinds (ax#((a#as\\<^sub>1)@[a\\<^sub>1]))) [(cf\\<^sub>1,undefined)]\\<close>\n    \\<open>(_Entry_) -ax#((a#as\\<^sub>2)@[a\\<^sub>2])\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\\<close> \n    \\<open>preds (kinds (ax#((a#as\\<^sub>2)@[a\\<^sub>2]))) [(cf\\<^sub>2,undefined)]\\<close>"], ["proof (chain)\npicking this:\n  [cf\\<^sub>1] \\<approx>\\<^sub>L [cf\\<^sub>2]\n  (_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  CFG_node (_Low_) \\<in> S\n  (_Entry_) -ax #\n             (a # as\\<^sub>1) @\n             [a\\<^sub>1]\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n  preds (kinds (ax # (a # as\\<^sub>1) @ [a\\<^sub>1]))\n   [(cf\\<^sub>1, undefined)]\n  (_Entry_) -ax #\n             (a # as\\<^sub>2) @\n             [a\\<^sub>2]\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n  preds (kinds (ax # (a # as\\<^sub>2) @ [a\\<^sub>2]))\n   [(cf\\<^sub>2, undefined)]", "have \"map fst (transfers (kinds (ax#((a#as\\<^sub>1)@[a\\<^sub>1]))) [(cf\\<^sub>1,undefined)]) \\<approx>\\<^sub>L \n        map fst (transfers (kinds (ax#((a#as\\<^sub>2)@[a\\<^sub>2]))) [(cf\\<^sub>2,undefined)])\""], ["proof (prove)\nusing this:\n  [cf\\<^sub>1] \\<approx>\\<^sub>L [cf\\<^sub>2]\n  (_High_) \\<notin> \\<lfloor>HRB_slice S\\<rfloor>\\<^bsub>CFG\\<^esub>\n  CFG_node (_Low_) \\<in> S\n  (_Entry_) -ax #\n             (a # as\\<^sub>1) @\n             [a\\<^sub>1]\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n  preds (kinds (ax # (a # as\\<^sub>1) @ [a\\<^sub>1]))\n   [(cf\\<^sub>1, undefined)]\n  (_Entry_) -ax #\n             (a # as\\<^sub>2) @\n             [a\\<^sub>2]\\<rightarrow>\\<^sub>\\<surd>* (_Low_)\n  preds (kinds (ax # (a # as\\<^sub>2) @ [a\\<^sub>2]))\n   [(cf\\<^sub>2, undefined)]\n\ngoal (1 subgoal):\n 1. map fst\n     (transfers (kinds (ax # (a # as\\<^sub>1) @ [a\\<^sub>1]))\n       [(cf\\<^sub>1, undefined)]) \\<approx>\\<^sub>L\n    map fst\n     (transfers (kinds (ax # (a # as\\<^sub>2) @ [a\\<^sub>2]))\n       [(cf\\<^sub>2, undefined)])", "by(rule nonInterference_path_to_Low)"], ["proof (state)\nthis:\n  map fst\n   (transfers (kinds (ax # (a # as\\<^sub>1) @ [a\\<^sub>1]))\n     [(cf\\<^sub>1, undefined)]) \\<approx>\\<^sub>L\n  map fst\n   (transfers (kinds (ax # (a # as\\<^sub>2) @ [a\\<^sub>2]))\n     [(cf\\<^sub>2, undefined)])\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "with \\<open>kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close> \\<open>kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\\<close> \\<open>kind a\\<^sub>1 = \\<Up>id\\<close> \\<open>kind a\\<^sub>2 = \\<Up>id\\<close>\n    \\<open>transfers (kinds as\\<^sub>1) [(cf\\<^sub>1,undefined)] = cfs\\<^sub>1\\<close> \\<open>map fst cfs\\<^sub>1 = s\\<^sub>1\\<close>\n    \\<open>transfers (kinds as\\<^sub>2) [(cf\\<^sub>2,undefined)] = cfs\\<^sub>2\\<close> \\<open>map fst cfs\\<^sub>2 = s\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a\\<^sub>1 = \\<Up>id\n  kind a\\<^sub>2 = \\<Up>id\n  transfers (kinds as\\<^sub>1) [(cf\\<^sub>1, undefined)] = cfs\\<^sub>1\n  map fst cfs\\<^sub>1 = s\\<^sub>1\n  transfers (kinds as\\<^sub>2) [(cf\\<^sub>2, undefined)] = cfs\\<^sub>2\n  map fst cfs\\<^sub>2 = s\\<^sub>2\n  map fst\n   (transfers (kinds (ax # (a # as\\<^sub>1) @ [a\\<^sub>1]))\n     [(cf\\<^sub>1, undefined)]) \\<approx>\\<^sub>L\n  map fst\n   (transfers (kinds (ax # (a # as\\<^sub>2) @ [a\\<^sub>2]))\n     [(cf\\<^sub>2, undefined)])", "show ?thesis"], ["proof (prove)\nusing this:\n  kind ax = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a = (\\<lambda>s. True)\\<^sub>\\<surd>\n  kind a\\<^sub>1 = \\<Up>id\n  kind a\\<^sub>2 = \\<Up>id\n  transfers (kinds as\\<^sub>1) [(cf\\<^sub>1, undefined)] = cfs\\<^sub>1\n  map fst cfs\\<^sub>1 = s\\<^sub>1\n  transfers (kinds as\\<^sub>2) [(cf\\<^sub>2, undefined)] = cfs\\<^sub>2\n  map fst cfs\\<^sub>2 = s\\<^sub>2\n  map fst\n   (transfers (kinds (ax # (a # as\\<^sub>1) @ [a\\<^sub>1]))\n     [(cf\\<^sub>1, undefined)]) \\<approx>\\<^sub>L\n  map fst\n   (transfers (kinds (ax # (a # as\\<^sub>2) @ [a\\<^sub>2]))\n     [(cf\\<^sub>2, undefined)])\n\ngoal (1 subgoal):\n 1. s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2", "by(cases s\\<^sub>1)(cases s\\<^sub>2,(fastforce simp:kinds_def transfers_split)+)+"], ["proof (state)\nthis:\n  s\\<^sub>1 \\<approx>\\<^sub>L s\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}