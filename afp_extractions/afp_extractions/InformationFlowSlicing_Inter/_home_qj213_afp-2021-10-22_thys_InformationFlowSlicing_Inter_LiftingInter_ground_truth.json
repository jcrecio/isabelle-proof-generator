{"file_name": "/home/qj213/afp-2021-10-22/thys/InformationFlowSlicing_Inter/LiftingInter.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/InformationFlowSlicing_Inter", "problem_names": ["lemma [simp]:\"\\<not> lift_valid_edge valid_edge src trg knd E X (Node E,et,Node X)\"", "lemma lift_CFG:\n  assumes wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc \n  get_return_edges procs Main Exit Def Use ParamDefs ParamUses\"\n  and pd:\"Postdomination sourcenode targetnode kind valid_edge Entry get_proc \n  get_return_edges procs Main Exit\"\n  shows \"CFG src trg knd\n  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\n  (lift_get_proc get_proc Main) \n  (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind) \n  procs Main\"", "lemma lift_CFG_wf:\n  assumes wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc \n  get_return_edges procs Main Exit Def Use ParamDefs ParamUses\"\n  and pd:\"Postdomination sourcenode targetnode kind valid_edge Entry get_proc \n  get_return_edges procs Main Exit\"\n  shows \"CFG_wf src trg knd\n  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\n  (lift_get_proc get_proc Main) \n  (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind) \n  procs Main (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n  (lift_ParamDefs ParamDefs) (lift_ParamUses ParamUses)\"", "lemma lift_CFGExit:\n  assumes wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc \n  get_return_edges procs Main Exit Def Use ParamDefs ParamUses\"\n  and pd:\"Postdomination sourcenode targetnode kind valid_edge Entry get_proc \n  get_return_edges procs Main Exit\"\n  shows \"CFGExit src trg knd\n  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\n  (lift_get_proc get_proc Main) \n  (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind) \n  procs Main NewExit\"", "lemma lift_CFGExit_wf:\n  assumes wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc \n  get_return_edges procs Main Exit Def Use ParamDefs ParamUses\"\n  and pd:\"Postdomination sourcenode targetnode kind valid_edge Entry get_proc \n  get_return_edges procs Main Exit\"\n  shows \"CFGExit_wf src trg knd\n  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\n  (lift_get_proc get_proc Main) \n  (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind) \n  procs Main NewExit (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n  (lift_ParamDefs ParamDefs) (lift_ParamUses ParamUses)\"", "lemma lift_Postdomination:\n  assumes wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc \n  get_return_edges procs Main Exit Def Use ParamDefs ParamUses\"\n  and pd:\"Postdomination sourcenode targetnode kind valid_edge Entry get_proc \n  get_return_edges procs Main Exit\"\n  and inner:\"CFGExit.inner_node sourcenode targetnode valid_edge Entry Exit nx\"\n  shows \"Postdomination src trg knd\n  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\n  (lift_get_proc get_proc Main) \n  (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind) \n  procs Main NewExit\"", "lemma lift_SDG:\n  assumes SDG:\"SDG sourcenode targetnode kind valid_edge Entry get_proc \n  get_return_edges procs Main Exit Def Use ParamDefs ParamUses\"\n  and inner:\"CFGExit.inner_node sourcenode targetnode valid_edge Entry Exit nx\"\n  shows \"SDG src trg knd\n  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\n  (lift_get_proc get_proc Main) \n  (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind) \n  procs Main NewExit (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n  (lift_ParamDefs ParamDefs) (lift_ParamUses ParamUses)\"", "lemma Lift_NonInterferenceGraph:\n  fixes valid_edge and sourcenode and targetnode and kind and Entry and Exit\n  and get_proc and get_return_edges and procs and Main\n  and Def and Use and ParamDefs and ParamUses and H and L\n  defines lve:\"lve \\<equiv> lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\"\n  and lget_proc:\"lget_proc \\<equiv> lift_get_proc get_proc Main\"\n  and lget_return_edges:\"lget_return_edges \\<equiv> \n  lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind\"\n  and lDef:\"lDef \\<equiv> lift_Def Def Entry Exit H L\" \n  and lUse:\"lUse \\<equiv> lift_Use Use Entry Exit H L\"\n  and lParamDefs:\"lParamDefs \\<equiv> lift_ParamDefs ParamDefs\"\n  and lParamUses:\"lParamUses \\<equiv> lift_ParamUses ParamUses\"\n  assumes SDG:\"SDG sourcenode targetnode kind valid_edge Entry get_proc \n  get_return_edges procs Main Exit Def Use ParamDefs ParamUses\"\n  and inner:\"CFGExit.inner_node sourcenode targetnode valid_edge Entry Exit nx\"\n  and \"H \\<inter> L = {}\" and \"H \\<union> L = UNIV\"\n  shows \"NonInterferenceInterGraph src trg knd lve NewEntry lget_proc \n  lget_return_edges procs Main NewExit lDef lUse lParamDefs lParamUses H L \n  (Node Entry) (Node Exit)\""], "translations": [["", "lemma [simp]:\"\\<not> lift_valid_edge valid_edge src trg knd E X (Node E,et,Node X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> lift_valid_edge valid_edge src trg knd E X (Node E, et, Node X)", "by(auto elim:lift_valid_edge.cases)"], ["", "fun lift_get_proc :: \"('node \\<Rightarrow> 'pname) \\<Rightarrow> 'pname \\<Rightarrow> 'node LDCFG_node \\<Rightarrow> 'pname\"\n  where \"lift_get_proc get_proc Main (Node n) = get_proc n\"\n  | \"lift_get_proc get_proc Main NewEntry = Main\"\n  | \"lift_get_proc get_proc Main NewExit = Main\""], ["", "inductive_set lift_get_return_edges :: \"('edge \\<Rightarrow> 'edge set) \\<Rightarrow> ('edge \\<Rightarrow> bool) \\<Rightarrow> \n  ('edge \\<Rightarrow> 'node) \\<Rightarrow> ('edge \\<Rightarrow> 'node) \\<Rightarrow> ('edge \\<Rightarrow> ('var,'val,'ret,'pname) edge_kind) \n  \\<Rightarrow> ('edge,'node,'var,'val,'ret,'pname) LDCFG_edge \n  \\<Rightarrow> ('edge,'node,'var,'val,'ret,'pname) LDCFG_edge set\"\nfor get_return_edges :: \"'edge \\<Rightarrow> 'edge set\" and valid_edge :: \"'edge \\<Rightarrow> bool\"\n  and src::\"'edge \\<Rightarrow> 'node\" and trg::\"'edge \\<Rightarrow> 'node\" \n  and knd::\"'edge \\<Rightarrow> ('var,'val,'ret,'pname) edge_kind\" \n  and e::\"('edge,'node,'var,'val,'ret,'pname) LDCFG_edge\"\nwhere lift_get_return_edgesI:\n  \"\\<lbrakk>e = (Node (src a),knd a,Node (trg a)); valid_edge a; a' \\<in> get_return_edges a; \n  e' = (Node (src a'),knd a',Node (trg a'))\\<rbrakk>\n  \\<Longrightarrow> e' \\<in> lift_get_return_edges get_return_edges valid_edge src trg knd e\""], ["", "subsubsection \\<open>Lifting the Def and Use sets\\<close>"], ["", "inductive_set lift_Def_set :: \"('node \\<Rightarrow> 'var set) \\<Rightarrow> 'node \\<Rightarrow> 'node \\<Rightarrow> \n                       'var set \\<Rightarrow> 'var set \\<Rightarrow> ('node LDCFG_node \\<times> 'var) set\"\nfor Def::\"('node \\<Rightarrow> 'var set)\" and E::'node and X::'node \n  and H::\"'var set\" and L::\"'var set\"\n\nwhere lift_Def_node: \n  \"V \\<in> Def n \\<Longrightarrow> (Node n,V) \\<in> lift_Def_set Def E X H L\"\n\n  | lift_Def_High:\n  \"V \\<in> H \\<Longrightarrow> (Node E,V) \\<in> lift_Def_set Def E X H L\""], ["", "abbreviation lift_Def :: \"('node \\<Rightarrow> 'var set) \\<Rightarrow> 'node \\<Rightarrow> 'node \\<Rightarrow> \n                       'var set \\<Rightarrow> 'var set \\<Rightarrow> 'node LDCFG_node \\<Rightarrow> 'var set\"\n  where \"lift_Def Def E X H L n \\<equiv> {V. (n,V) \\<in> lift_Def_set Def E X H L}\""], ["", "inductive_set lift_Use_set :: \"('node \\<Rightarrow> 'var set) \\<Rightarrow> 'node \\<Rightarrow> 'node \\<Rightarrow> \n                       'var set \\<Rightarrow> 'var set \\<Rightarrow> ('node LDCFG_node \\<times> 'var) set\"\nfor Use::\"'node \\<Rightarrow> 'var set\" and E::'node and X::'node \n  and H::\"'var set\" and L::\"'var set\"\n\nwhere \n  lift_Use_node: \n  \"V \\<in> Use n \\<Longrightarrow> (Node n,V) \\<in> lift_Use_set Use E X H L\"\n\n  | lift_Use_High:\n  \"V \\<in> H \\<Longrightarrow> (Node E,V) \\<in> lift_Use_set Use E X H L\"\n\n  | lift_Use_Low:\n  \"V \\<in> L \\<Longrightarrow> (Node X,V) \\<in> lift_Use_set Use E X H L\""], ["", "abbreviation lift_Use :: \"('node \\<Rightarrow> 'var set) \\<Rightarrow> 'node \\<Rightarrow> 'node \\<Rightarrow> \n                       'var set \\<Rightarrow> 'var set \\<Rightarrow> 'node LDCFG_node \\<Rightarrow> 'var set\"\n  where \"lift_Use Use E X H L n \\<equiv> {V. (n,V) \\<in> lift_Use_set Use E X H L}\""], ["", "fun lift_ParamUses :: \"('node \\<Rightarrow> 'var set list) \\<Rightarrow> 'node LDCFG_node \\<Rightarrow> 'var set list\"\n  where \"lift_ParamUses ParamUses (Node n) =  ParamUses n\"\n  | \"lift_ParamUses ParamUses NewEntry = []\"\n  | \"lift_ParamUses ParamUses NewExit = []\""], ["", "fun lift_ParamDefs :: \"('node \\<Rightarrow> 'var list) \\<Rightarrow> 'node LDCFG_node \\<Rightarrow> 'var list\"\n  where \"lift_ParamDefs ParamDefs (Node n) =  ParamDefs n\"\n  | \"lift_ParamDefs ParamDefs NewEntry = []\"\n  | \"lift_ParamDefs ParamDefs NewExit = []\""], ["", "subsection \\<open>The lifting lemmas\\<close>"], ["", "subsubsection \\<open>Lifting the CFG locales\\<close>"], ["", "abbreviation src :: \"('edge,'node,'var,'val,'ret,'pname) LDCFG_edge \\<Rightarrow> 'node LDCFG_node\"\n  where \"src a \\<equiv> fst a\""], ["", "abbreviation trg :: \"('edge,'node,'var,'val,'ret,'pname) LDCFG_edge \\<Rightarrow> 'node LDCFG_node\"\n  where \"trg a \\<equiv> snd(snd a)\""], ["", "abbreviation knd :: \"('edge,'node,'var,'val,'ret,'pname) LDCFG_edge \\<Rightarrow> \n  ('var,'val,'ret,'pname) edge_kind\"\n  where \"knd a \\<equiv> fst(snd a)\""], ["", "lemma lift_CFG:\n  assumes wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc \n  get_return_edges procs Main Exit Def Use ParamDefs ParamUses\"\n  and pd:\"Postdomination sourcenode targetnode kind valid_edge Entry get_proc \n  get_return_edges procs Main Exit\"\n  shows \"CFG src trg knd\n  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\n  (lift_get_proc get_proc Main) \n  (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind) \n  procs Main\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main", "interpret CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc \n    get_return_edges procs Main Exit Def Use ParamDefs ParamUses"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc\n     get_return_edges procs Main Exit Def Use ParamDefs ParamUses", "by(rule wf)"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main", "interpret Postdomination sourcenode targetnode kind valid_edge Entry get_proc \n    get_return_edges procs Main Exit"], ["proof (prove)\ngoal (1 subgoal):\n 1. Postdomination sourcenode targetnode kind valid_edge Entry get_proc\n     get_return_edges procs Main Exit", "by(rule pd)"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main", "proof"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        trg a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> False\n 2. lift_get_proc get_proc Main NewEntry = Main\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>a Q r f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q' f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 8. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\nA total of 25 subgoals...", "fix a"], ["proof (state)\ngoal (25 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        trg a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> False\n 2. lift_get_proc get_proc Main NewEntry = Main\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>a Q r f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q' f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 8. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\nA total of 25 subgoals...", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"trg a = NewEntry\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  trg a = NewEntry\n\ngoal (25 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        trg a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> False\n 2. lift_get_proc get_proc Main NewEntry = Main\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>a Q r f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q' f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 8. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\nA total of 25 subgoals...", "thus False"], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  trg a = NewEntry\n\ngoal (1 subgoal):\n 1. False", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  False\n\ngoal (24 subgoals):\n 1. lift_get_proc get_proc Main NewEntry = Main\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>a Q r f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q' f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 7. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<forall>a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             trg a' = trg a \\<longrightarrow>\n                             (\\<exists>Qx rx fsx.\n                                 knd a' =\n                                 Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\nA total of 24 subgoals...", "next"], ["proof (state)\ngoal (24 subgoals):\n 1. lift_get_proc get_proc Main NewEntry = Main\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>a Q r f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q' f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 7. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<forall>a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             trg a' = trg a \\<longrightarrow>\n                             (\\<exists>Qx rx fsx.\n                                 knd a' =\n                                 Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\nA total of 24 subgoals...", "show \"lift_get_proc get_proc Main NewEntry = Main\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_get_proc get_proc Main NewEntry = Main", "by simp"], ["proof (state)\nthis:\n  lift_get_proc get_proc Main NewEntry = Main\n\ngoal (23 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>a Q r f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q' f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 6. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<forall>a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             src a' = src a \\<longrightarrow>\n                             (\\<exists>Qx fx.\n                                 knd a' =\n                                 Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\nA total of 23 subgoals...", "next"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>a Q r f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q' f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 6. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<forall>a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             src a' = src a \\<longrightarrow>\n                             (\\<exists>Qx fx.\n                                 knd a' =\n                                 Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\nA total of 23 subgoals...", "fix a Q r p fs"], ["proof (state)\ngoal (23 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>a Q r f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q' f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 6. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<forall>a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             src a' = src a \\<longrightarrow>\n                             (\\<exists>Qx fx.\n                                 knd a' =\n                                 Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\nA total of 23 subgoals...", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"src a = NewEntry\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  src a = NewEntry\n\ngoal (23 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>a Q r f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q' f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 6. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<forall>a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             src a' = src a \\<longrightarrow>\n                             (\\<exists>Qx fx.\n                                 knd a' =\n                                 Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\nA total of 23 subgoals...", "thus False"], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  src a = NewEntry\n\ngoal (1 subgoal):\n 1. False", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  False\n\ngoal (22 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q' f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 5. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                           sourcenode targetnode kind a \\<noteq>\n                          {}\nA total of 22 subgoals...", "next"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q' f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 5. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                           sourcenode targetnode kind a \\<noteq>\n                          {}\nA total of 22 subgoals...", "fix a a'"], ["proof (state)\ngoal (22 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q' f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 5. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                           sourcenode targetnode kind a \\<noteq>\n                          {}\nA total of 22 subgoals...", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\"\n      and \"src a = src a'\" and \"trg a = trg a'\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src a = src a'\n  trg a = trg a'\n\ngoal (22 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a = trg a'\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q' f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 5. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                           sourcenode targetnode kind a \\<noteq>\n                          {}\nA total of 22 subgoals...", "thus \"a = a'\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src a = src a'\n  trg a = trg a'\n\ngoal (1 subgoal):\n 1. a = a'", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e = trg a'\\<rbrakk>\n       \\<Longrightarrow> e = a'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e = trg a'\\<rbrakk>\n       \\<Longrightarrow> e = a'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e = trg a'\\<rbrakk>\n       \\<Longrightarrow> e = a'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e = trg a'\\<rbrakk>\n       \\<Longrightarrow> e = a'", "case lve_edge"], ["proof (state)\nthis:\n  valid_edge a_\n  sourcenode a_ \\<noteq> Entry \\<or> targetnode a_ \\<noteq> Exit\n  e_ = (Node (sourcenode a_), kind a_, Node (targetnode a_))\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src e_ = src a'\n  trg e_ = trg a'\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e = trg a'\\<rbrakk>\n       \\<Longrightarrow> e = a'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e = trg a'\\<rbrakk>\n       \\<Longrightarrow> e = a'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e = trg a'\\<rbrakk>\n       \\<Longrightarrow> e = a'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e = trg a'\\<rbrakk>\n       \\<Longrightarrow> e = a'", "thus ?case"], ["proof (prove)\nusing this:\n  valid_edge a_\n  sourcenode a_ \\<noteq> Entry \\<or> targetnode a_ \\<noteq> Exit\n  e_ = (Node (sourcenode a_), kind a_, Node (targetnode a_))\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src e_ = src a'\n  trg e_ = trg a'\n\ngoal (1 subgoal):\n 1. e_ = a'", "by -(erule lift_valid_edge.cases,auto dest:edge_det)"], ["proof (state)\nthis:\n  e_ = a'\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e = trg a'\\<rbrakk>\n       \\<Longrightarrow> e = a'\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e = trg a'\\<rbrakk>\n       \\<Longrightarrow> e = a'\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e = trg a'\\<rbrakk>\n       \\<Longrightarrow> e = a'", "qed(auto elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  a = a'\n\ngoal (21 subgoals):\n 1. \\<And>a Q r f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q' f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 4. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 10. \\<And>a a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                   sourcenode targetnode kind a\\<rbrakk>\n        \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                           kind Entry Exit a'\nA total of 21 subgoals...", "next"], ["proof (state)\ngoal (21 subgoals):\n 1. \\<And>a Q r f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q' f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 4. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 10. \\<And>a a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                   sourcenode targetnode kind a\\<rbrakk>\n        \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                           kind Entry Exit a'\nA total of 21 subgoals...", "fix a Q r f"], ["proof (state)\ngoal (21 subgoals):\n 1. \\<And>a Q r f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q' f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 4. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 10. \\<And>a a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                   sourcenode targetnode kind a\\<rbrakk>\n        \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                           kind Entry Exit a'\nA total of 21 subgoals...", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"knd a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\n\ngoal (21 subgoals):\n 1. \\<And>a Q r f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q' f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 4. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 10. \\<And>a a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                   sourcenode targetnode kind a\\<rbrakk>\n        \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                           kind Entry Exit a'\nA total of 21 subgoals...", "thus False"], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>Main\\<^esub>f\n\ngoal (1 subgoal):\n 1. False", "by(fastforce elim:lift_valid_edge.cases dest:Main_no_call_target)"], ["proof (state)\nthis:\n  False\n\ngoal (20 subgoals):\n 1. \\<And>a Q' f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 3. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 10. \\<And>a a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                   sourcenode targetnode kind a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q r p fs.\n                             knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\nA total of 20 subgoals...", "next"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>a Q' f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 3. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 10. \\<And>a a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                   sourcenode targetnode kind a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q r p fs.\n                             knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\nA total of 20 subgoals...", "fix a Q' f'"], ["proof (state)\ngoal (20 subgoals):\n 1. \\<And>a Q' f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 3. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 10. \\<And>a a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                   sourcenode targetnode kind a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q r p fs.\n                             knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\nA total of 20 subgoals...", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"knd a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\n\ngoal (20 subgoals):\n 1. \\<And>a Q' f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 3. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 10. \\<And>a a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                   sourcenode targetnode kind a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q r p fs.\n                             knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\nA total of 20 subgoals...", "thus False"], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\n\ngoal (1 subgoal):\n 1. False", "by(fastforce elim:lift_valid_edge.cases dest:Main_no_return_source)"], ["proof (state)\nthis:\n  False\n\ngoal (19 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 2. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 10. \\<And>a Q r p fs a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                   sourcenode targetnode kind a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q' f'.\n                             knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\nA total of 19 subgoals...", "next"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 2. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 10. \\<And>a Q r p fs a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                   sourcenode targetnode kind a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q' f'.\n                             knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\nA total of 19 subgoals...", "fix a Q r p fs"], ["proof (state)\ngoal (19 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 2. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 10. \\<And>a Q r p fs a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                   sourcenode targetnode kind a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q' f'.\n                             knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\nA total of 19 subgoals...", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (19 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n 2. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 10. \\<And>a Q r p fs a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                   sourcenode targetnode kind a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q' f'.\n                             knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\nA total of 19 subgoals...", "thus \"\\<exists>ins outs. (p, ins, outs) \\<in> set procs\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<exists>ins outs. (p, ins, outs) \\<in> set procs", "by(fastforce elim:lift_valid_edge.cases intro:callee_in_procs)"], ["proof (state)\nthis:\n  \\<exists>ins outs. (p, ins, outs) \\<in> set procs\n\ngoal (18 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 9. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             (\\<exists>Q r fs.\n                                 knd a' =\n                                 Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                             a \\<in> lift_get_return_edges get_return_edges\nvalid_edge sourcenode targetnode kind a'\nA total of 18 subgoals...", "next"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 9. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             (\\<exists>Q r fs.\n                                 knd a' =\n                                 Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                             a \\<in> lift_get_return_edges get_return_edges\nvalid_edge sourcenode targetnode kind a'\nA total of 18 subgoals...", "fix a"], ["proof (state)\ngoal (18 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 9. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             (\\<exists>Q r fs.\n                                 knd a' =\n                                 Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                             a \\<in> lift_get_return_edges get_return_edges\nvalid_edge sourcenode targetnode kind a'\nA total of 18 subgoals...", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"intra_kind (knd a)\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  intra_kind (knd a)\n\ngoal (18 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        intra_kind (knd a)\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) =\n                         lift_get_proc get_proc Main (trg a)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 9. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             (\\<exists>Q r fs.\n                                 knd a' =\n                                 Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                             a \\<in> lift_get_return_edges get_return_edges\nvalid_edge sourcenode targetnode kind a'\nA total of 18 subgoals...", "thus \"lift_get_proc get_proc Main (src a) = lift_get_proc get_proc Main (trg a)\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  intra_kind (knd a)\n\ngoal (1 subgoal):\n 1. lift_get_proc get_proc Main (src a) =\n    lift_get_proc get_proc Main (trg a)", "by(fastforce elim:lift_valid_edge.cases intro:get_proc_intra \n                  simp:get_proc_Entry get_proc_Exit)"], ["proof (state)\nthis:\n  lift_get_proc get_proc Main (src a) = lift_get_proc get_proc Main (trg a)\n\ngoal (17 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 8. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 10. \\<And>a a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                   sourcenode targetnode kind a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a''.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a'' \\<and>\n                             src a'' = trg a \\<and>\n                             trg a'' = src a' \\<and>\n                             knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\nA total of 17 subgoals...", "next"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 8. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 10. \\<And>a a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                   sourcenode targetnode kind a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a''.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a'' \\<and>\n                             src a'' = trg a \\<and>\n                             trg a'' = src a' \\<and>\n                             knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\nA total of 17 subgoals...", "fix a Q r p fs"], ["proof (state)\ngoal (17 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 8. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 10. \\<And>a a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                   sourcenode targetnode kind a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a''.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a'' \\<and>\n                             src a'' = trg a \\<and>\n                             trg a'' = src a' \\<and>\n                             knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\nA total of 17 subgoals...", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (17 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (trg a) = p\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 8. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 10. \\<And>a a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                   sourcenode targetnode kind a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a''.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a'' \\<and>\n                             src a'' = trg a \\<and>\n                             trg a'' = src a' \\<and>\n                             knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\nA total of 17 subgoals...", "thus \"lift_get_proc get_proc Main (trg a) = p\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. lift_get_proc get_proc Main (trg a) = p", "by(fastforce elim:lift_valid_edge.cases intro:get_proc_call)"], ["proof (state)\nthis:\n  lift_get_proc get_proc Main (trg a) = p\n\ngoal (16 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 7. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                   sourcenode targetnode kind a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a''.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a'' \\<and>\n                             src a'' = src a \\<and>\n                             trg a'' = trg a' \\<and>\n                             knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 7. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                   sourcenode targetnode kind a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a''.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a'' \\<and>\n                             src a'' = src a \\<and>\n                             trg a'' = trg a' \\<and>\n                             knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\nA total of 16 subgoals...", "fix a Q' p f'"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 7. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                   sourcenode targetnode kind a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a''.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a'' \\<and>\n                             src a'' = src a \\<and>\n                             trg a'' = trg a' \\<and>\n                             knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\nA total of 16 subgoals...", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (16 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> lift_get_proc get_proc Main (src a) = p\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 7. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                   sourcenode targetnode kind a\\<rbrakk>\n        \\<Longrightarrow> \\<exists>a''.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a'' \\<and>\n                             src a'' = src a \\<and>\n                             trg a'' = trg a' \\<and>\n                             knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\nA total of 16 subgoals...", "thus \"lift_get_proc get_proc Main (src a) = p\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. lift_get_proc get_proc Main (src a) = p", "by(fastforce elim:lift_valid_edge.cases intro:get_proc_return)"], ["proof (state)\nthis:\n  lift_get_proc get_proc Main (src a) = p\n\ngoal (15 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 6. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             src a' = src a \\<and> intra_kind (knd a')\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 6. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             src a' = src a \\<and> intra_kind (knd a')\nA total of 15 subgoals...", "fix a Q r p fs"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 6. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             src a' = src a \\<and> intra_kind (knd a')\nA total of 15 subgoals...", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (15 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 6. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             src a' = src a \\<and> intra_kind (knd a')\nA total of 15 subgoals...", "then"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain ax where \"valid_edge ax\" and \"kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n      and \"sourcenode ax \\<noteq> Entry \\<or> targetnode ax \\<noteq> Exit\"\n      and \"src a = Node (sourcenode ax)\" and \"trg a = Node (targetnode ax)\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>ax.\n        \\<lbrakk>valid_edge ax;\n         kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         sourcenode ax \\<noteq> Entry \\<or> targetnode ax \\<noteq> Exit;\n         src a = Node (sourcenode ax); trg a = Node (targetnode ax)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  valid_edge ax\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode ax \\<noteq> Entry \\<or> targetnode ax \\<noteq> Exit\n  src a = Node (sourcenode ax)\n  trg a = Node (targetnode ax)\n\ngoal (15 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 6. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             src a' = src a \\<and> intra_kind (knd a')\nA total of 15 subgoals...", "from \\<open>valid_edge ax\\<close> \\<open>kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have all:\"\\<forall>a'. valid_edge a' \\<and> targetnode a' = targetnode ax \\<longrightarrow> \n               (\\<exists>Qx rx fsx. kind a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<forall>a'.\n       valid_edge a' \\<and> targetnode a' = targetnode ax \\<longrightarrow>\n       (\\<exists>Qx rx fsx.\n           kind a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)", "by(auto dest:call_edges_only)"], ["proof (state)\nthis:\n  \\<forall>a'.\n     valid_edge a' \\<and> targetnode a' = targetnode ax \\<longrightarrow>\n     (\\<exists>Qx rx fsx.\n         kind a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n\ngoal (15 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 6. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             src a' = src a \\<and> intra_kind (knd a')\nA total of 15 subgoals...", "{"], ["proof (state)\nthis:\n  \\<forall>a'.\n     valid_edge a' \\<and> targetnode a' = targetnode ax \\<longrightarrow>\n     (\\<exists>Qx rx fsx.\n         kind a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n\ngoal (15 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 6. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             src a' = src a \\<and> intra_kind (knd a')\nA total of 15 subgoals...", "fix a'"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 6. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             src a' = src a \\<and> intra_kind (knd a')\nA total of 15 subgoals...", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\"\n        and \"trg a' = trg a\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  trg a' = trg a\n\ngoal (15 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 6. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             src a' = src a \\<and> intra_kind (knd a')\nA total of 15 subgoals...", "hence \"\\<exists>Qx rx fsx. knd a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  trg a' = trg a\n\ngoal (1 subgoal):\n 1. \\<exists>Qx rx fsx. knd a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>aa e.\n       \\<lbrakk>valid_edge aa;\n        sourcenode aa \\<noteq> Entry \\<or> targetnode aa \\<noteq> Exit;\n        e = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "case (lve_edge ax' e)"], ["proof (state)\nthis:\n  valid_edge ax'\n  sourcenode ax' \\<noteq> Entry \\<or> targetnode ax' \\<noteq> Exit\n  e = (Node (sourcenode ax'), kind ax', Node (targetnode ax'))\n  trg e = trg a\n\ngoal (4 subgoals):\n 1. \\<And>aa e.\n       \\<lbrakk>valid_edge aa;\n        sourcenode aa \\<noteq> Entry \\<or> targetnode aa \\<noteq> Exit;\n        e = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "note [simp] = \\<open>e = (Node (sourcenode ax'), kind ax', Node (targetnode ax'))\\<close>"], ["proof (state)\nthis:\n  e = (Node (sourcenode ax'), kind ax', Node (targetnode ax'))\n\ngoal (4 subgoals):\n 1. \\<And>aa e.\n       \\<lbrakk>valid_edge aa;\n        sourcenode aa \\<noteq> Entry \\<or> targetnode aa \\<noteq> Exit;\n        e = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "from \\<open>trg e = trg a\\<close> \\<open>trg a = Node (targetnode ax)\\<close>"], ["proof (chain)\npicking this:\n  trg e = trg a\n  trg a = Node (targetnode ax)", "have \"targetnode ax' = targetnode ax\""], ["proof (prove)\nusing this:\n  trg e = trg a\n  trg a = Node (targetnode ax)\n\ngoal (1 subgoal):\n 1. targetnode ax' = targetnode ax", "by simp"], ["proof (state)\nthis:\n  targetnode ax' = targetnode ax\n\ngoal (4 subgoals):\n 1. \\<And>aa e.\n       \\<lbrakk>valid_edge aa;\n        sourcenode aa \\<noteq> Entry \\<or> targetnode aa \\<noteq> Exit;\n        e = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "with \\<open>valid_edge ax'\\<close> all"], ["proof (chain)\npicking this:\n  valid_edge ax'\n  \\<forall>a'.\n     valid_edge a' \\<and> targetnode a' = targetnode ax \\<longrightarrow>\n     (\\<exists>Qx rx fsx.\n         kind a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n  targetnode ax' = targetnode ax", "have \"\\<exists>Qx rx fsx. kind ax' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\""], ["proof (prove)\nusing this:\n  valid_edge ax'\n  \\<forall>a'.\n     valid_edge a' \\<and> targetnode a' = targetnode ax \\<longrightarrow>\n     (\\<exists>Qx rx fsx.\n         kind a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n  targetnode ax' = targetnode ax\n\ngoal (1 subgoal):\n 1. \\<exists>Qx rx fsx.\n       kind ax' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "by blast"], ["proof (state)\nthis:\n  \\<exists>Qx rx fsx. kind ax' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n\ngoal (4 subgoals):\n 1. \\<And>aa e.\n       \\<lbrakk>valid_edge aa;\n        sourcenode aa \\<noteq> Entry \\<or> targetnode aa \\<noteq> Exit;\n        e = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "thus ?case"], ["proof (prove)\nusing this:\n  \\<exists>Qx rx fsx. kind ax' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n\ngoal (1 subgoal):\n 1. \\<exists>Qx rx fsx. knd e = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "by simp"], ["proof (state)\nthis:\n  \\<exists>Qx rx fsx. knd e = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "case (lve_Entry_edge e)"], ["proof (state)\nthis:\n  e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n  trg e = trg a\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "from \\<open>e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\\<close> \\<open>trg e = trg a\\<close>\n          \\<open>trg a = Node (targetnode ax)\\<close>"], ["proof (chain)\npicking this:\n  e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n  trg e = trg a\n  trg a = Node (targetnode ax)", "have \"targetnode ax = Entry\""], ["proof (prove)\nusing this:\n  e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n  trg e = trg a\n  trg a = Node (targetnode ax)\n\ngoal (1 subgoal):\n 1. targetnode ax = Entry", "by simp"], ["proof (state)\nthis:\n  targetnode ax = Entry\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "with \\<open>valid_edge ax\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  targetnode ax = Entry", "have False"], ["proof (prove)\nusing this:\n  valid_edge ax\n  targetnode ax = Entry\n\ngoal (1 subgoal):\n 1. False", "by(rule Entry_target)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>Qx rx fsx. knd e = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "by simp"], ["proof (state)\nthis:\n  \\<exists>Qx rx fsx. knd e = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 2. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 2. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "case (lve_Exit_edge e)"], ["proof (state)\nthis:\n  e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n  trg e = trg a\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 2. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "from \\<open>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<close> \\<open>trg e = trg a\\<close>\n          \\<open>trg a = Node (targetnode ax)\\<close>"], ["proof (chain)\npicking this:\n  e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n  trg e = trg a\n  trg a = Node (targetnode ax)", "have False"], ["proof (prove)\nusing this:\n  e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n  trg e = trg a\n  trg a = Node (targetnode ax)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n 2. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>Qx rx fsx. knd e = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "by simp"], ["proof (state)\nthis:\n  \\<exists>Qx rx fsx. knd e = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "case (lve_Entry_Exit_edge e)"], ["proof (state)\nthis:\n  e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n  trg e = trg a\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "from \\<open>e = (NewEntry,(\\<lambda>s. False)\\<^sub>\\<surd>,NewExit)\\<close> \\<open>trg e = trg a\\<close>\n          \\<open>trg a = Node (targetnode ax)\\<close>"], ["proof (chain)\npicking this:\n  e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n  trg e = trg a\n  trg a = Node (targetnode ax)", "have False"], ["proof (prove)\nusing this:\n  e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n  trg e = trg a\n  trg a = Node (targetnode ax)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        trg e = trg a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx rx fsx.\n                            knd e =\n                            Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>Qx rx fsx. knd e = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx", "by simp"], ["proof (state)\nthis:\n  \\<exists>Qx rx fsx. knd e = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Qx rx fsx. knd a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n\ngoal (15 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 6. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             src a' = src a \\<and> intra_kind (knd a')\nA total of 15 subgoals...", "}"], ["proof (state)\nthis:\n  \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n            ?a'2;\n   trg ?a'2 = trg a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Qx rx fsx.\n                       knd ?a'2 = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n\ngoal (15 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<longrightarrow>\n                            (\\<exists>Qx rx fsx.\n                                knd a' =\n                                Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 6. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 10. \\<And>a Q r p fs.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             src a' = src a \\<and> intra_kind (knd a')\nA total of 15 subgoals...", "thus \"\\<forall>a'. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a' \\<and>\n               trg a' = trg a \\<longrightarrow> (\\<exists>Qx rx fsx. knd a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n            ?a'2;\n   trg ?a'2 = trg a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Qx rx fsx.\n                       knd ?a'2 = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx\n\ngoal (1 subgoal):\n 1. \\<forall>a'.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a' \\<and>\n       trg a' = trg a \\<longrightarrow>\n       (\\<exists>Qx rx fsx.\n           knd a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)", "by simp"], ["proof (state)\nthis:\n  \\<forall>a'.\n     lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n      a' \\<and>\n     trg a' = trg a \\<longrightarrow>\n     (\\<exists>Qx rx fsx.\n         knd a' = Qx:rx\\<hookrightarrow>\\<^bsub>p\\<^esub>fsx)\n\ngoal (14 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 5. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             trg a' = trg a \\<and> intra_kind (knd a')\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 5. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             trg a' = trg a \\<and> intra_kind (knd a')\nA total of 14 subgoals...", "fix a Q' p f'"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 5. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             trg a' = trg a \\<and> intra_kind (knd a')\nA total of 14 subgoals...", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (14 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 5. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             trg a' = trg a \\<and> intra_kind (knd a')\nA total of 14 subgoals...", "then"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "obtain ax where \"valid_edge ax\" and \"kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\"\n      and \"sourcenode ax \\<noteq> Entry \\<or> targetnode ax \\<noteq> Exit\"\n      and \"src a = Node (sourcenode ax)\" and \"trg a = Node (targetnode ax)\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. (\\<And>ax.\n        \\<lbrakk>valid_edge ax;\n         kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n         sourcenode ax \\<noteq> Entry \\<or> targetnode ax \\<noteq> Exit;\n         src a = Node (sourcenode ax); trg a = Node (targetnode ax)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  valid_edge ax\n  kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  sourcenode ax \\<noteq> Entry \\<or> targetnode ax \\<noteq> Exit\n  src a = Node (sourcenode ax)\n  trg a = Node (targetnode ax)\n\ngoal (14 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 5. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             trg a' = trg a \\<and> intra_kind (knd a')\nA total of 14 subgoals...", "from \\<open>valid_edge ax\\<close> \\<open>kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have all:\"\\<forall>a'. valid_edge a' \\<and> sourcenode a' = sourcenode ax \\<longrightarrow> \n            (\\<exists>Qx fx. kind a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  kind ax = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<forall>a'.\n       valid_edge a' \\<and> sourcenode a' = sourcenode ax \\<longrightarrow>\n       (\\<exists>Qx fx. kind a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)", "by(auto dest:return_edges_only)"], ["proof (state)\nthis:\n  \\<forall>a'.\n     valid_edge a' \\<and> sourcenode a' = sourcenode ax \\<longrightarrow>\n     (\\<exists>Qx fx. kind a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n\ngoal (14 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 5. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             trg a' = trg a \\<and> intra_kind (knd a')\nA total of 14 subgoals...", "{"], ["proof (state)\nthis:\n  \\<forall>a'.\n     valid_edge a' \\<and> sourcenode a' = sourcenode ax \\<longrightarrow>\n     (\\<exists>Qx fx. kind a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n\ngoal (14 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 5. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             trg a' = trg a \\<and> intra_kind (knd a')\nA total of 14 subgoals...", "fix a'"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 5. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             trg a' = trg a \\<and> intra_kind (knd a')\nA total of 14 subgoals...", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\"\n        and \"src a' = src a\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src a' = src a\n\ngoal (14 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 5. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             trg a' = trg a \\<and> intra_kind (knd a')\nA total of 14 subgoals...", "hence \"\\<exists>Qx fx. knd a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src a' = src a\n\ngoal (1 subgoal):\n 1. \\<exists>Qx fx. knd a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>aa e.\n       \\<lbrakk>valid_edge aa;\n        sourcenode aa \\<noteq> Entry \\<or> targetnode aa \\<noteq> Exit;\n        e = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "case (lve_edge ax' e)"], ["proof (state)\nthis:\n  valid_edge ax'\n  sourcenode ax' \\<noteq> Entry \\<or> targetnode ax' \\<noteq> Exit\n  e = (Node (sourcenode ax'), kind ax', Node (targetnode ax'))\n  src e = src a\n\ngoal (4 subgoals):\n 1. \\<And>aa e.\n       \\<lbrakk>valid_edge aa;\n        sourcenode aa \\<noteq> Entry \\<or> targetnode aa \\<noteq> Exit;\n        e = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "note [simp] = \\<open>e = (Node (sourcenode ax'), kind ax', Node (targetnode ax'))\\<close>"], ["proof (state)\nthis:\n  e = (Node (sourcenode ax'), kind ax', Node (targetnode ax'))\n\ngoal (4 subgoals):\n 1. \\<And>aa e.\n       \\<lbrakk>valid_edge aa;\n        sourcenode aa \\<noteq> Entry \\<or> targetnode aa \\<noteq> Exit;\n        e = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "from \\<open>src e = src a\\<close> \\<open>src a = Node (sourcenode ax)\\<close>"], ["proof (chain)\npicking this:\n  src e = src a\n  src a = Node (sourcenode ax)", "have \"sourcenode ax' = sourcenode ax\""], ["proof (prove)\nusing this:\n  src e = src a\n  src a = Node (sourcenode ax)\n\ngoal (1 subgoal):\n 1. sourcenode ax' = sourcenode ax", "by simp"], ["proof (state)\nthis:\n  sourcenode ax' = sourcenode ax\n\ngoal (4 subgoals):\n 1. \\<And>aa e.\n       \\<lbrakk>valid_edge aa;\n        sourcenode aa \\<noteq> Entry \\<or> targetnode aa \\<noteq> Exit;\n        e = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "with \\<open>valid_edge ax'\\<close> all"], ["proof (chain)\npicking this:\n  valid_edge ax'\n  \\<forall>a'.\n     valid_edge a' \\<and> sourcenode a' = sourcenode ax \\<longrightarrow>\n     (\\<exists>Qx fx. kind a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n  sourcenode ax' = sourcenode ax", "have \"\\<exists>Qx fx. kind ax' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\""], ["proof (prove)\nusing this:\n  valid_edge ax'\n  \\<forall>a'.\n     valid_edge a' \\<and> sourcenode a' = sourcenode ax \\<longrightarrow>\n     (\\<exists>Qx fx. kind a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n  sourcenode ax' = sourcenode ax\n\ngoal (1 subgoal):\n 1. \\<exists>Qx fx. kind ax' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "by blast"], ["proof (state)\nthis:\n  \\<exists>Qx fx. kind ax' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n\ngoal (4 subgoals):\n 1. \\<And>aa e.\n       \\<lbrakk>valid_edge aa;\n        sourcenode aa \\<noteq> Entry \\<or> targetnode aa \\<noteq> Exit;\n        e = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "thus ?case"], ["proof (prove)\nusing this:\n  \\<exists>Qx fx. kind ax' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n\ngoal (1 subgoal):\n 1. \\<exists>Qx fx. knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "by simp"], ["proof (state)\nthis:\n  \\<exists>Qx fx. knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "case (lve_Entry_edge e)"], ["proof (state)\nthis:\n  e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n  src e = src a\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "from \\<open>e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\\<close> \\<open>src e = src a\\<close>\n          \\<open>src a = Node (sourcenode ax)\\<close>"], ["proof (chain)\npicking this:\n  e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n  src e = src a\n  src a = Node (sourcenode ax)", "have False"], ["proof (prove)\nusing this:\n  e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n  src e = src a\n  src a = Node (sourcenode ax)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>Qx fx. knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "by simp"], ["proof (state)\nthis:\n  \\<exists>Qx fx. knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 2. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 2. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "case (lve_Exit_edge e)"], ["proof (state)\nthis:\n  e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n  src e = src a\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 2. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "from \\<open>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<close> \\<open>src e = src a\\<close>\n          \\<open>src a = Node (sourcenode ax)\\<close>"], ["proof (chain)\npicking this:\n  e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n  src e = src a\n  src a = Node (sourcenode ax)", "have \"sourcenode ax = Exit\""], ["proof (prove)\nusing this:\n  e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n  src e = src a\n  src a = Node (sourcenode ax)\n\ngoal (1 subgoal):\n 1. sourcenode ax = Exit", "by simp"], ["proof (state)\nthis:\n  sourcenode ax = Exit\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 2. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "with \\<open>valid_edge ax\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  sourcenode ax = Exit", "have False"], ["proof (prove)\nusing this:\n  valid_edge ax\n  sourcenode ax = Exit\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n 2. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>Qx fx. knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "by simp"], ["proof (state)\nthis:\n  \\<exists>Qx fx. knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "case (lve_Entry_Exit_edge e)"], ["proof (state)\nthis:\n  e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n  src e = src a\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "from \\<open>e = (NewEntry,(\\<lambda>s. False)\\<^sub>\\<surd>,NewExit)\\<close> \\<open>src e = src a\\<close>\n          \\<open>src a = Node (sourcenode ax)\\<close>"], ["proof (chain)\npicking this:\n  e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n  src e = src a\n  src a = Node (sourcenode ax)", "have False"], ["proof (prove)\nusing this:\n  e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n  src e = src a\n  src a = Node (sourcenode ax)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        src e = src a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Qx fx.\n                            knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>Qx fx. knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx", "by simp"], ["proof (state)\nthis:\n  \\<exists>Qx fx. knd e = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Qx fx. knd a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n\ngoal (14 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 5. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             trg a' = trg a \\<and> intra_kind (knd a')\nA total of 14 subgoals...", "}"], ["proof (state)\nthis:\n  \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n            ?a'2;\n   src ?a'2 = src a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Qx fx.\n                       knd ?a'2 = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n\ngoal (14 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<longrightarrow>\n                            (\\<exists>Qx fx.\n                                knd a' =\n                                Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 5. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 9. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 10. \\<And>a Q' p f'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> \\<exists>!a'.\n                             lift_valid_edge valid_edge sourcenode\n                              targetnode kind Entry Exit a' \\<and>\n                             trg a' = trg a \\<and> intra_kind (knd a')\nA total of 14 subgoals...", "thus \"\\<forall>a'. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a' \\<and>\n               src a' = src a \\<longrightarrow> (\\<exists>Qx fx. knd a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n            ?a'2;\n   src ?a'2 = src a\\<rbrakk>\n  \\<Longrightarrow> \\<exists>Qx fx.\n                       knd ?a'2 = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx\n\ngoal (1 subgoal):\n 1. \\<forall>a'.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a' \\<and>\n       src a' = src a \\<longrightarrow>\n       (\\<exists>Qx fx. knd a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)", "by simp"], ["proof (state)\nthis:\n  \\<forall>a'.\n     lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n      a' \\<and>\n     src a' = src a \\<longrightarrow>\n     (\\<exists>Qx fx. knd a' = Qx\\<hookleftarrow>\\<^bsub>p\\<^esub>fx)\n\ngoal (13 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 4. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 10. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n        fs\\<^sub>2.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a';\n         knd a =\n         Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n         knd a' =\n         Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> trg a = trg a'\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 4. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 10. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n        fs\\<^sub>2.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a';\n         knd a =\n         Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n         knd a' =\n         Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> trg a = trg a'\nA total of 13 subgoals...", "fix a Q r p fs"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 4. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 10. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n        fs\\<^sub>2.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a';\n         knd a =\n         Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n         knd a' =\n         Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> trg a = trg a'\nA total of 13 subgoals...", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (13 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind a \\<noteq>\n                         {}\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 4. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 8. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 9. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 10. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n        fs\\<^sub>2.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a';\n         knd a =\n         Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n         knd a' =\n         Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> trg a = trg a'\nA total of 13 subgoals...", "thus \"lift_get_return_edges get_return_edges valid_edge \n      sourcenode targetnode kind a \\<noteq> {}\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. lift_get_return_edges get_return_edges valid_edge sourcenode targetnode\n     kind a \\<noteq>\n    {}", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}", "case (lve_edge ax e)"], ["proof (state)\nthis:\n  valid_edge ax\n  sourcenode ax \\<noteq> Entry \\<or> targetnode ax \\<noteq> Exit\n  e = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}", "from \\<open>e = (Node (sourcenode ax), kind ax, Node (targetnode ax))\\<close> \n        \\<open>knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "by simp"], ["proof (state)\nthis:\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}", "with \\<open>valid_edge ax\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"get_return_edges ax \\<noteq> {}\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. get_return_edges ax \\<noteq> {}", "by(rule get_return_edge_call)"], ["proof (state)\nthis:\n  get_return_edges ax \\<noteq> {}\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}", "then"], ["proof (chain)\npicking this:\n  get_return_edges ax \\<noteq> {}", "obtain ax' where \"ax' \\<in> get_return_edges ax\""], ["proof (prove)\nusing this:\n  get_return_edges ax \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>ax'.\n        ax' \\<in> get_return_edges ax \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ax' \\<in> get_return_edges ax\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}", "with \\<open>e = (Node (sourcenode ax), kind ax, Node (targetnode ax))\\<close> \\<open>valid_edge ax\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  valid_edge ax\n  ax' \\<in> get_return_edges ax", "have \"(Node (sourcenode ax'),kind ax',Node (targetnode ax')) \\<in> \n        lift_get_return_edges get_return_edges valid_edge \n        sourcenode targetnode kind e\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  valid_edge ax\n  ax' \\<in> get_return_edges ax\n\ngoal (1 subgoal):\n 1. (Node (sourcenode ax'), kind ax', Node (targetnode ax'))\n    \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n           targetnode kind e", "by(fastforce intro:lift_get_return_edgesI)"], ["proof (state)\nthis:\n  (Node (sourcenode ax'), kind ax', Node (targetnode ax'))\n  \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n         targetnode kind e\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}", "thus ?case"], ["proof (prove)\nusing this:\n  (Node (sourcenode ax'), kind ax', Node (targetnode ax'))\n  \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n         targetnode kind e\n\ngoal (1 subgoal):\n 1. lift_get_return_edges get_return_edges valid_edge sourcenode targetnode\n     kind e \\<noteq>\n    {}", "by fastforce"], ["proof (state)\nthis:\n  lift_get_return_edges get_return_edges valid_edge sourcenode targetnode\n   kind e \\<noteq>\n  {}\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_get_return_edges get_return_edges valid_edge\n                          sourcenode targetnode kind e \\<noteq>\n                         {}", "qed simp_all"], ["proof (state)\nthis:\n  lift_get_return_edges get_return_edges valid_edge sourcenode targetnode\n   kind a \\<noteq>\n  {}\n\ngoal (12 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 3. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 9. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 10. distinct_fst procs\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 3. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 9. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 10. distinct_fst procs\nA total of 12 subgoals...", "fix a a'"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 3. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 9. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 10. distinct_fst procs\nA total of 12 subgoals...", "assume \"a' \\<in> lift_get_return_edges get_return_edges valid_edge \n      sourcenode targetnode kind a\"\n      and \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\""], ["proof (state)\nthis:\n  a' \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n            targetnode kind a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n\ngoal (12 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit a'\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 3. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 8. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 9. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 10. distinct_fst procs\nA total of 12 subgoals...", "thus \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\""], ["proof (prove)\nusing this:\n  a' \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n            targetnode kind a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'", "proof (induct rule:lift_get_return_edges.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit e'", "case (lift_get_return_edgesI ax a' e')"], ["proof (state)\nthis:\n  a = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  valid_edge ax\n  a' \\<in> get_return_edges ax\n  e' = (Node (sourcenode a'), kind a', Node (targetnode a'))\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit e'", "from \\<open>valid_edge ax\\<close> \\<open>a' \\<in> get_return_edges ax\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  a' \\<in> get_return_edges ax", "have \"valid_edge a'\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  a' \\<in> get_return_edges ax\n\ngoal (1 subgoal):\n 1. valid_edge a'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge a'\n\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit e'", "from \\<open>valid_edge ax\\<close> \\<open>a' \\<in> get_return_edges ax\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  a' \\<in> get_return_edges ax", "obtain Q r p fs \n        where \"kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  a' \\<in> get_return_edges ax\n\ngoal (1 subgoal):\n 1. (\\<And>Q r p fs.\n        kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:only_call_get_return_edges)"], ["proof (state)\nthis:\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit e'", "with \\<open>valid_edge ax\\<close> \\<open>a' \\<in> get_return_edges ax\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  a' \\<in> get_return_edges ax\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain Q' f' \n        where \"kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  a' \\<in> get_return_edges ax\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>Q' f'.\n        kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:call_return_edges)"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit e'", "from \\<open>valid_edge a'\\<close> \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"get_proc(sourcenode a') = p\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. get_proc (sourcenode a') = p", "by(rule get_proc_return)"], ["proof (state)\nthis:\n  get_proc (sourcenode a') = p\n\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit e'", "have \"sourcenode a' \\<noteq> Entry\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sourcenode a' \\<noteq> Entry", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a' = Entry \\<Longrightarrow> False", "assume \"sourcenode a' = Entry\""], ["proof (state)\nthis:\n  sourcenode a' = Entry\n\ngoal (1 subgoal):\n 1. sourcenode a' = Entry \\<Longrightarrow> False", "with get_proc_Entry \\<open>get_proc(sourcenode a') = p\\<close>"], ["proof (chain)\npicking this:\n  get_proc Entry = Main\n  get_proc (sourcenode a') = p\n  sourcenode a' = Entry", "have \"p = Main\""], ["proof (prove)\nusing this:\n  get_proc Entry = Main\n  get_proc (sourcenode a') = p\n  sourcenode a' = Entry\n\ngoal (1 subgoal):\n 1. p = Main", "by simp"], ["proof (state)\nthis:\n  p = Main\n\ngoal (1 subgoal):\n 1. sourcenode a' = Entry \\<Longrightarrow> False", "with \\<open>kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  p = Main", "have \"kind a' = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\""], ["proof (prove)\nusing this:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  p = Main\n\ngoal (1 subgoal):\n 1. kind a' = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'", "by simp"], ["proof (state)\nthis:\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\n\ngoal (1 subgoal):\n 1. sourcenode a' = Entry \\<Longrightarrow> False", "with \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'", "show False"], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q'\\<hookleftarrow>\\<^bsub>Main\\<^esub>f'\n\ngoal (1 subgoal):\n 1. False", "by(rule Main_no_return_source)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sourcenode a' \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> lift_valid_edge valid_edge sourcenode targetnode\n                          kind Entry Exit e'", "with \\<open>e' = (Node (sourcenode a'), kind a', Node (targetnode a'))\\<close> \n        \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  e' = (Node (sourcenode a'), kind a', Node (targetnode a'))\n  valid_edge a'\n  sourcenode a' \\<noteq> Entry", "show ?case"], ["proof (prove)\nusing this:\n  e' = (Node (sourcenode a'), kind a', Node (targetnode a'))\n  valid_edge a'\n  sourcenode a' \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit e'", "by(fastforce intro:lve_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit e'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n\ngoal (11 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 2. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 8. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 9. distinct_fst procs\n 10. \\<And>p ins outs.\n        (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 2. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 8. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 9. distinct_fst procs\n 10. \\<And>p ins outs.\n        (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\nA total of 11 subgoals...", "fix a a'"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 2. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 8. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 9. distinct_fst procs\n 10. \\<And>p ins outs.\n        (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\nA total of 11 subgoals...", "assume \"a' \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n      targetnode kind a\"\n      and \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\""], ["proof (state)\nthis:\n  a' \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n            targetnode kind a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n\ngoal (11 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n 2. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 7. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 8. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 9. distinct_fst procs\n 10. \\<And>p ins outs.\n        (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\nA total of 11 subgoals...", "thus \"\\<exists>Q r p fs. knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  a' \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n            targetnode kind a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n\ngoal (1 subgoal):\n 1. \\<exists>Q r p fs. knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "proof (induct rule:lift_get_return_edges.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "case (lift_get_return_edgesI ax a' e')"], ["proof (state)\nthis:\n  a = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  valid_edge ax\n  a' \\<in> get_return_edges ax\n  e' = (Node (sourcenode a'), kind a', Node (targetnode a'))\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "from \\<open>valid_edge ax\\<close> \\<open>a' \\<in> get_return_edges ax\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  a' \\<in> get_return_edges ax", "have \"\\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  a' \\<in> get_return_edges ax\n\ngoal (1 subgoal):\n 1. \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "by(rule only_call_get_return_edges)"], ["proof (state)\nthis:\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q r p fs.\n                            knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "with \\<open>a = (Node (sourcenode ax), kind ax, Node (targetnode ax))\\<close>"], ["proof (chain)\npicking this:\n  a = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "show ?case"], ["proof (prove)\nusing this:\n  a = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  \\<exists>Q r p fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<exists>Q r p fs. knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q r p fs. knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q r p fs. knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (10 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 7. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 8. distinct_fst procs\n 9. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 10. \\<And>p ins outs.\n        (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 7. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 8. distinct_fst procs\n 9. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 10. \\<And>p ins outs.\n        (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "fix a Q r p fs a'"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 7. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 8. distinct_fst procs\n 9. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 10. \\<And>p ins outs.\n        (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "assume \"a' \\<in> lift_get_return_edges get_return_edges \n      valid_edge sourcenode targetnode kind a\" and \"knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n      and \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\""], ["proof (state)\nthis:\n  a' \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n            targetnode kind a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n\ngoal (10 subgoals):\n 1. \\<And>a Q r p fs a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 6. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 7. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 8. distinct_fst procs\n 9. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 10. \\<And>p ins outs.\n        (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "thus \"\\<exists>Q' f'. knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  a' \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n            targetnode kind a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n\ngoal (1 subgoal):\n 1. \\<exists>Q' f'. knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "proof (induct rule:lift_get_return_edges.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd e' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "case (lift_get_return_edgesI ax a' e')"], ["proof (state)\nthis:\n  a = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  valid_edge ax\n  a' \\<in> get_return_edges ax\n  e' = (Node (sourcenode a'), kind a', Node (targetnode a'))\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd e' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "from \\<open>a = (Node (sourcenode ax), kind ax, Node (targetnode ax))\\<close>\n        \\<open>knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  a = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  a = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "by simp"], ["proof (state)\nthis:\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd e' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "with \\<open>valid_edge ax\\<close> \\<open>a' \\<in> get_return_edges ax\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  a' \\<in> get_return_edges ax\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"\\<exists>Q' f'. kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  a' \\<in> get_return_edges ax\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<exists>Q' f'. kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "by -(rule call_return_edges)"], ["proof (state)\nthis:\n  \\<exists>Q' f'. kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q' f'.\n                            knd e' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "with \\<open>e' = (Node (sourcenode a'), kind a', Node (targetnode a'))\\<close>"], ["proof (chain)\npicking this:\n  e' = (Node (sourcenode a'), kind a', Node (targetnode a'))\n  \\<exists>Q' f'. kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "show ?case"], ["proof (prove)\nusing this:\n  e' = (Node (sourcenode a'), kind a', Node (targetnode a'))\n  \\<exists>Q' f'. kind a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<exists>Q' f'. knd e' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q' f'. knd e' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q' f'. knd a' = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (9 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 6. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 7. distinct_fst procs\n 8. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 9. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 6. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 7. distinct_fst procs\n 8. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 9. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "fix a Q' p f'"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 6. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 7. distinct_fst procs\n 8. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 9. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (9 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            a \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 5. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 6. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 7. distinct_fst procs\n 8. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 9. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "thus \"\\<exists>!a'. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a' \\<and>\n      (\\<exists>Q r fs. knd a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and> a \\<in> lift_get_return_edges get_return_edges \n      valid_edge sourcenode targetnode kind a'\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a' \\<and>\n       (\\<exists>Q r fs.\n           knd a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       a \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n                targetnode kind a'", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'", "case (lve_edge a e)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'", "from \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>\n        \\<open>knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "by simp"], ["proof (state)\nthis:\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"\\<exists>!a'. valid_edge a' \\<and> (\\<exists>Q r fs. kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and> \n        a \\<in> get_return_edges a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       valid_edge a' \\<and>\n       (\\<exists>Q r fs.\n           kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       a \\<in> get_return_edges a'", "by(rule return_needs_call)"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     valid_edge a' \\<and>\n     (\\<exists>Q r fs.\n         kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     a \\<in> get_return_edges a'\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'", "then"], ["proof (chain)\npicking this:\n  \\<exists>!a'.\n     valid_edge a' \\<and>\n     (\\<exists>Q r fs.\n         kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     a \\<in> get_return_edges a'", "obtain a' Q r fs where \"valid_edge a'\" and \"kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\"\n        and \"a \\<in> get_return_edges a'\"\n        and imp:\"\\<forall>x. valid_edge x \\<and> (\\<exists>Q r fs. kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and> \n        a \\<in> get_return_edges x \\<longrightarrow> x = a'\""], ["proof (prove)\nusing this:\n  \\<exists>!a'.\n     valid_edge a' \\<and>\n     (\\<exists>Q r fs.\n         kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     a \\<in> get_return_edges a'\n\ngoal (1 subgoal):\n 1. (\\<And>a' Q r fs.\n        \\<lbrakk>valid_edge a';\n         kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         a \\<in> get_return_edges a';\n         \\<forall>x.\n            valid_edge x \\<and>\n            (\\<exists>Q r fs.\n                kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n            a \\<in> get_return_edges x \\<longrightarrow>\n            x = a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:ex1E)"], ["proof (state)\nthis:\n  valid_edge a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  a \\<in> get_return_edges a'\n  \\<forall>x.\n     valid_edge x \\<and>\n     (\\<exists>Q r fs.\n         kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     a \\<in> get_return_edges x \\<longrightarrow>\n     x = a'\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'", "let ?e' = \"(Node (sourcenode a'),kind a',Node (targetnode a'))\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'", "have \"sourcenode a' \\<noteq> Entry\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sourcenode a' \\<noteq> Entry", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a' = Entry \\<Longrightarrow> False", "assume \"sourcenode a' = Entry\""], ["proof (state)\nthis:\n  sourcenode a' = Entry\n\ngoal (1 subgoal):\n 1. sourcenode a' = Entry \\<Longrightarrow> False", "with \\<open>valid_edge a'\\<close> \\<open>kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a' = Entry", "show False"], ["proof (prove)\nusing this:\n  valid_edge a'\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a' = Entry\n\ngoal (1 subgoal):\n 1. False", "by(rule Entry_no_call_source)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sourcenode a' \\<noteq> Entry\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'", "with \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  sourcenode a' \\<noteq> Entry", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?e'\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  sourcenode a' \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node (sourcenode a'), kind a', Node (targetnode a'))", "by(fastforce intro:lift_valid_edge.lve_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'", "moreover"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'", "from \\<open>kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"knd ?e' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  kind a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. knd (Node (sourcenode a'), kind a', Node (targetnode a')) =\n    Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "by simp"], ["proof (state)\nthis:\n  knd (Node (sourcenode a'), kind a', Node (targetnode a')) =\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'", "moreover"], ["proof (state)\nthis:\n  knd (Node (sourcenode a'), kind a', Node (targetnode a')) =\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'", "from \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close> \n        \\<open>valid_edge a'\\<close> \\<open>a \\<in> get_return_edges a'\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  valid_edge a'\n  a \\<in> get_return_edges a'", "have \"e \\<in> lift_get_return_edges get_return_edges valid_edge\n        sourcenode targetnode kind ?e'\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  valid_edge a'\n  a \\<in> get_return_edges a'\n\ngoal (1 subgoal):\n 1. e \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n             targetnode kind\n             (Node (sourcenode a'), kind a', Node (targetnode a'))", "by(fastforce intro:lift_get_return_edgesI)"], ["proof (state)\nthis:\n  e \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n           targetnode kind\n           (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'", "moreover"], ["proof (state)\nthis:\n  e \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n           targetnode kind\n           (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'", "{"], ["proof (state)\nthis:\n  e \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n           targetnode kind\n           (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'", "fix x"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit x\"\n          and \"\\<exists>Q r fs. knd x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" \n          and \"e \\<in> lift_get_return_edges get_return_edges valid_edge\n          sourcenode targetnode kind x\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit x\n  \\<exists>Q r fs. knd x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  e \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n           targetnode kind x\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'", "from \\<open>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit x\\<close>\n          \\<open>\\<exists>Q r fs. knd x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit x\n  \\<exists>Q r fs. knd x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "obtain y where \"valid_edge y\" \n          and \"x = (Node (sourcenode y), kind y, Node (targetnode y))\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit x\n  \\<exists>Q r fs. knd x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>valid_edge y;\n         x = (Node (sourcenode y), kind y, Node (targetnode y))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  valid_edge y\n  x = (Node (sourcenode y), kind y, Node (targetnode y))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'", "with \\<open>e \\<in> lift_get_return_edges get_return_edges valid_edge\n          sourcenode targetnode kind x\\<close> \\<open>valid_edge a\\<close>\n          \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  e \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n           targetnode kind x\n  valid_edge a\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  valid_edge y\n  x = (Node (sourcenode y), kind y, Node (targetnode y))", "have \"x = ?e'\""], ["proof (prove)\nusing this:\n  e \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n           targetnode kind x\n  valid_edge a\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  valid_edge y\n  x = (Node (sourcenode y), kind y, Node (targetnode y))\n\ngoal (1 subgoal):\n 1. x = (Node (sourcenode a'), kind a', Node (targetnode a'))", "proof(induct rule:lift_get_return_edges.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'a e'.\n       \\<lbrakk>x = (Node (sourcenode a), kind a, Node (targetnode a));\n        valid_edge a; a'a \\<in> get_return_edges a;\n        e' = (Node (sourcenode a'a), kind a'a, Node (targetnode a'a));\n        valid_edge a;\n        e' = (Node (sourcenode a), kind a, Node (targetnode a));\n        valid_edge y;\n        x = (Node (sourcenode y), kind y, Node (targetnode y))\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "case (lift_get_return_edgesI ax ax' e)"], ["proof (state)\nthis:\n  x = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  valid_edge ax\n  ax' \\<in> get_return_edges ax\n  e = (Node (sourcenode ax'), kind ax', Node (targetnode ax'))\n  valid_edge a\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  valid_edge y\n  x = (Node (sourcenode y), kind y, Node (targetnode y))\n\ngoal (1 subgoal):\n 1. \\<And>a a'a e'.\n       \\<lbrakk>x = (Node (sourcenode a), kind a, Node (targetnode a));\n        valid_edge a; a'a \\<in> get_return_edges a;\n        e' = (Node (sourcenode a'a), kind a'a, Node (targetnode a'a));\n        valid_edge a;\n        e' = (Node (sourcenode a), kind a, Node (targetnode a));\n        valid_edge y;\n        x = (Node (sourcenode y), kind y, Node (targetnode y))\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "from \\<open>valid_edge ax\\<close> \\<open>ax' \\<in> get_return_edges ax\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  ax' \\<in> get_return_edges ax", "have \"valid_edge ax'\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  ax' \\<in> get_return_edges ax\n\ngoal (1 subgoal):\n 1. valid_edge ax'", "by(rule get_return_edges_valid)"], ["proof (state)\nthis:\n  valid_edge ax'\n\ngoal (1 subgoal):\n 1. \\<And>a a'a e'.\n       \\<lbrakk>x = (Node (sourcenode a), kind a, Node (targetnode a));\n        valid_edge a; a'a \\<in> get_return_edges a;\n        e' = (Node (sourcenode a'a), kind a'a, Node (targetnode a'a));\n        valid_edge a;\n        e' = (Node (sourcenode a), kind a, Node (targetnode a));\n        valid_edge y;\n        x = (Node (sourcenode y), kind y, Node (targetnode y))\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "from \\<open>e = (Node (sourcenode ax'), kind ax', Node (targetnode ax'))\\<close>\n            \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode ax'), kind ax', Node (targetnode ax'))\n  e = (Node (sourcenode a), kind a, Node (targetnode a))", "have \"sourcenode a = sourcenode ax'\" and \"targetnode a = targetnode ax'\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode ax'), kind ax', Node (targetnode ax'))\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n\ngoal (1 subgoal):\n 1. sourcenode a = sourcenode ax' &&& targetnode a = targetnode ax'", "by simp_all"], ["proof (state)\nthis:\n  sourcenode a = sourcenode ax'\n  targetnode a = targetnode ax'\n\ngoal (1 subgoal):\n 1. \\<And>a a'a e'.\n       \\<lbrakk>x = (Node (sourcenode a), kind a, Node (targetnode a));\n        valid_edge a; a'a \\<in> get_return_edges a;\n        e' = (Node (sourcenode a'a), kind a'a, Node (targetnode a'a));\n        valid_edge a;\n        e' = (Node (sourcenode a), kind a, Node (targetnode a));\n        valid_edge y;\n        x = (Node (sourcenode y), kind y, Node (targetnode y))\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "with \\<open>valid_edge a\\<close> \\<open>valid_edge ax'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge ax'\n  sourcenode a = sourcenode ax'\n  targetnode a = targetnode ax'", "have [simp]:\"a = ax'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge ax'\n  sourcenode a = sourcenode ax'\n  targetnode a = targetnode ax'\n\ngoal (1 subgoal):\n 1. a = ax'", "by(rule edge_det)"], ["proof (state)\nthis:\n  a = ax'\n\ngoal (1 subgoal):\n 1. \\<And>a a'a e'.\n       \\<lbrakk>x = (Node (sourcenode a), kind a, Node (targetnode a));\n        valid_edge a; a'a \\<in> get_return_edges a;\n        e' = (Node (sourcenode a'a), kind a'a, Node (targetnode a'a));\n        valid_edge a;\n        e' = (Node (sourcenode a), kind a, Node (targetnode a));\n        valid_edge y;\n        x = (Node (sourcenode y), kind y, Node (targetnode y))\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "from \\<open>x = (Node (sourcenode ax), kind ax, Node (targetnode ax))\\<close>\n            \\<open>\\<exists>Q r fs. knd x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  x = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  \\<exists>Q r fs. knd x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"\\<exists>Q r fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  x = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  \\<exists>Q r fs. knd x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<exists>Q r fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q r fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<And>a a'a e'.\n       \\<lbrakk>x = (Node (sourcenode a), kind a, Node (targetnode a));\n        valid_edge a; a'a \\<in> get_return_edges a;\n        e' = (Node (sourcenode a'a), kind a'a, Node (targetnode a'a));\n        valid_edge a;\n        e' = (Node (sourcenode a), kind a, Node (targetnode a));\n        valid_edge y;\n        x = (Node (sourcenode y), kind y, Node (targetnode y))\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "with \\<open>valid_edge ax\\<close> \\<open>ax' \\<in> get_return_edges ax\\<close> imp"], ["proof (chain)\npicking this:\n  valid_edge ax\n  ax' \\<in> get_return_edges ax\n  \\<forall>x.\n     valid_edge x \\<and>\n     (\\<exists>Q r fs.\n         kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     a \\<in> get_return_edges x \\<longrightarrow>\n     x = a'\n  \\<exists>Q r fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"ax = a'\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  ax' \\<in> get_return_edges ax\n  \\<forall>x.\n     valid_edge x \\<and>\n     (\\<exists>Q r fs.\n         kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     a \\<in> get_return_edges x \\<longrightarrow>\n     x = a'\n  \\<exists>Q r fs. kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. ax = a'", "by fastforce"], ["proof (state)\nthis:\n  ax = a'\n\ngoal (1 subgoal):\n 1. \\<And>a a'a e'.\n       \\<lbrakk>x = (Node (sourcenode a), kind a, Node (targetnode a));\n        valid_edge a; a'a \\<in> get_return_edges a;\n        e' = (Node (sourcenode a'a), kind a'a, Node (targetnode a'a));\n        valid_edge a;\n        e' = (Node (sourcenode a), kind a, Node (targetnode a));\n        valid_edge y;\n        x = (Node (sourcenode y), kind y, Node (targetnode y))\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "with \\<open>x = (Node (sourcenode ax), kind ax, Node (targetnode ax))\\<close>"], ["proof (chain)\npicking this:\n  x = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  ax = a'", "show ?thesis"], ["proof (prove)\nusing this:\n  x = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  ax = a'\n\ngoal (1 subgoal):\n 1. x = (Node (sourcenode a'), kind a', Node (targetnode a'))", "by simp"], ["proof (state)\nthis:\n  x = (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'", "}"], ["proof (state)\nthis:\n  \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n            ?x2;\n   \\<exists>Q r fs. knd ?x2 = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n   e \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n            targetnode kind ?x2\\<rbrakk>\n  \\<Longrightarrow> ?x2 =\n                    (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'", "ultimately"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a'), kind a', Node (targetnode a'))\n  knd (Node (sourcenode a'), kind a', Node (targetnode a')) =\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  e \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n           targetnode kind\n           (Node (sourcenode a'), kind a', Node (targetnode a'))\n  \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n            ?x2;\n   \\<exists>Q r fs. knd ?x2 = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n   e \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n            targetnode kind ?x2\\<rbrakk>\n  \\<Longrightarrow> ?x2 =\n                    (Node (sourcenode a'), kind a', Node (targetnode a'))", "show ?case"], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a'), kind a', Node (targetnode a'))\n  knd (Node (sourcenode a'), kind a', Node (targetnode a')) =\n  Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  e \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n           targetnode kind\n           (Node (sourcenode a'), kind a', Node (targetnode a'))\n  \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n            ?x2;\n   \\<exists>Q r fs. knd ?x2 = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n   e \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n            targetnode kind ?x2\\<rbrakk>\n  \\<Longrightarrow> ?x2 =\n                    (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a' \\<and>\n       (\\<exists>Q r fs.\n           knd a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n       e \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n                targetnode kind a'", "by(blast intro:ex1I)"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n      a' \\<and>\n     (\\<exists>Q r fs.\n         knd a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     e \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n              targetnode kind a'\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            (\\<exists>Q r fs.\n                                knd a' =\n                                Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n                            e \\<in> lift_get_return_edges get_return_edges\n                                     valid_edge sourcenode targetnode kind\n                                     a'", "qed simp_all"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n      a' \\<and>\n     (\\<exists>Q r fs.\n         knd a' = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs) \\<and>\n     a \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n              targetnode kind a'\n\ngoal (8 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 5. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 6. distinct_fst procs\n 7. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 8. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 5. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 6. distinct_fst procs\n 7. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 8. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "fix a a'"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 5. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 6. distinct_fst procs\n 7. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 8. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "assume \"a' \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n      targetnode kind a\" \n      and \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\""], ["proof (state)\nthis:\n  a' \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n            targetnode kind a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n\ngoal (8 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 4. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 5. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 6. distinct_fst procs\n 7. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 8. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "thus \"\\<exists>a''. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'' \\<and>\n      src a'' = trg a \\<and> trg a'' = src a' \\<and> knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  a' \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n            targetnode kind a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n\ngoal (1 subgoal):\n 1. \\<exists>a''.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a'' \\<and>\n       src a'' = trg a \\<and>\n       trg a'' = src a' \\<and> knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "proof(induct rule:lift_get_return_edges.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src e' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "case (lift_get_return_edgesI ax a' e')"], ["proof (state)\nthis:\n  a = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  valid_edge ax\n  a' \\<in> get_return_edges ax\n  e' = (Node (sourcenode a'), kind a', Node (targetnode a'))\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src e' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "from \\<open>valid_edge ax\\<close> \\<open>a' \\<in> get_return_edges ax\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  a' \\<in> get_return_edges ax", "obtain ax' where \"valid_edge ax'\" and \"sourcenode ax' = targetnode ax\"\n        and \"targetnode ax' = sourcenode a'\" and \"kind ax' = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  a' \\<in> get_return_edges ax\n\ngoal (1 subgoal):\n 1. (\\<And>ax'.\n        \\<lbrakk>valid_edge ax'; sourcenode ax' = targetnode ax;\n         targetnode ax' = sourcenode a';\n         kind ax' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:intra_proc_additional_edge)"], ["proof (state)\nthis:\n  valid_edge ax'\n  sourcenode ax' = targetnode ax\n  targetnode ax' = sourcenode a'\n  kind ax' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src e' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "let ?ex = \"(Node (sourcenode ax'), kind ax', Node (targetnode ax'))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src e' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "have \"targetnode ax \\<noteq> Entry\""], ["proof (prove)\ngoal (1 subgoal):\n 1. targetnode ax \\<noteq> Entry", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. targetnode ax = Entry \\<Longrightarrow> False", "assume \"targetnode ax = Entry\""], ["proof (state)\nthis:\n  targetnode ax = Entry\n\ngoal (1 subgoal):\n 1. targetnode ax = Entry \\<Longrightarrow> False", "with \\<open>valid_edge ax\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  targetnode ax = Entry", "show False"], ["proof (prove)\nusing this:\n  valid_edge ax\n  targetnode ax = Entry\n\ngoal (1 subgoal):\n 1. False", "by(rule Entry_target)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  targetnode ax \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src e' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "with \\<open>sourcenode ax' = targetnode ax\\<close>"], ["proof (chain)\npicking this:\n  sourcenode ax' = targetnode ax\n  targetnode ax \\<noteq> Entry", "have \"sourcenode ax' \\<noteq> Entry\""], ["proof (prove)\nusing this:\n  sourcenode ax' = targetnode ax\n  targetnode ax \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. sourcenode ax' \\<noteq> Entry", "by simp"], ["proof (state)\nthis:\n  sourcenode ax' \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src e' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "with \\<open>valid_edge ax'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax'\n  sourcenode ax' \\<noteq> Entry", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?ex\""], ["proof (prove)\nusing this:\n  valid_edge ax'\n  sourcenode ax' \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node (sourcenode ax'), kind ax', Node (targetnode ax'))", "by(fastforce intro:lve_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode ax'), kind ax', Node (targetnode ax'))\n\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = trg a \\<and>\n                            trg a'' = src e' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "with \\<open>e' = (Node (sourcenode a'), kind a', Node (targetnode a'))\\<close>\n        \\<open>a = (Node (sourcenode ax), kind ax, Node (targetnode ax))\\<close>\n        \\<open>e' = (Node (sourcenode a'), kind a', Node (targetnode a'))\\<close>\n        \\<open>sourcenode ax' = targetnode ax\\<close> \\<open>targetnode ax' = sourcenode a'\\<close>\n        \\<open>kind ax' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  e' = (Node (sourcenode a'), kind a', Node (targetnode a'))\n  a = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  e' = (Node (sourcenode a'), kind a', Node (targetnode a'))\n  sourcenode ax' = targetnode ax\n  targetnode ax' = sourcenode a'\n  kind ax' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode ax'), kind ax', Node (targetnode ax'))", "show ?case"], ["proof (prove)\nusing this:\n  e' = (Node (sourcenode a'), kind a', Node (targetnode a'))\n  a = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  e' = (Node (sourcenode a'), kind a', Node (targetnode a'))\n  sourcenode ax' = targetnode ax\n  targetnode ax' = sourcenode a'\n  kind ax' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode ax'), kind ax', Node (targetnode ax'))\n\ngoal (1 subgoal):\n 1. \\<exists>a''.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a'' \\<and>\n       src a'' = trg a \\<and>\n       trg a'' = src e' \\<and> knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "by simp"], ["proof (state)\nthis:\n  \\<exists>a''.\n     lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n      a'' \\<and>\n     src a'' = trg a \\<and>\n     trg a'' = src e' \\<and> knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a''.\n     lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n      a'' \\<and>\n     src a'' = trg a \\<and>\n     trg a'' = src a' \\<and> knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (7 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 4. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 5. distinct_fst procs\n 6. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 7. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 4. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 5. distinct_fst procs\n 6. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 7. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "fix a a'"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 4. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 5. distinct_fst procs\n 6. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 7. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "assume \"a' \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n      targetnode kind a\" \n      and \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\""], ["proof (state)\nthis:\n  a' \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n            targetnode kind a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n\ngoal (7 subgoals):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        a' \\<in> lift_get_return_edges get_return_edges valid_edge\n                  sourcenode targetnode kind a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg a' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 3. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 4. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 5. distinct_fst procs\n 6. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 7. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "thus \"\\<exists>a''. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'' \\<and>\n      src a'' = src a \\<and> trg a'' = trg a' \\<and> knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  a' \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n            targetnode kind a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n\ngoal (1 subgoal):\n 1. \\<exists>a''.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a'' \\<and>\n       src a'' = src a \\<and>\n       trg a'' = trg a' \\<and> knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "proof(induct rule:lift_get_return_edges.induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg e' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "case (lift_get_return_edgesI ax a' e')"], ["proof (state)\nthis:\n  a = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  valid_edge ax\n  a' \\<in> get_return_edges ax\n  e' = (Node (sourcenode a'), kind a', Node (targetnode a'))\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg e' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "from \\<open>valid_edge ax\\<close> \\<open>a' \\<in> get_return_edges ax\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  a' \\<in> get_return_edges ax", "obtain ax' where \"valid_edge ax'\" and \"sourcenode ax' = sourcenode ax\"\n        and \"targetnode ax' = targetnode a'\" and \"kind ax' = (\\<lambda>cf. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  a' \\<in> get_return_edges ax\n\ngoal (1 subgoal):\n 1. (\\<And>ax'.\n        \\<lbrakk>valid_edge ax'; sourcenode ax' = sourcenode ax;\n         targetnode ax' = targetnode a';\n         kind ax' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:call_return_node_edge)"], ["proof (state)\nthis:\n  valid_edge ax'\n  sourcenode ax' = sourcenode ax\n  targetnode ax' = targetnode a'\n  kind ax' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg e' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "let ?ex = \"(Node (sourcenode ax'), kind ax', Node (targetnode ax'))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg e' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "from \\<open>valid_edge ax\\<close> \\<open>a' \\<in> get_return_edges ax\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  a' \\<in> get_return_edges ax", "obtain Q r p fs where \"kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  a' \\<in> get_return_edges ax\n\ngoal (1 subgoal):\n 1. (\\<And>Q r p fs.\n        kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest!:only_call_get_return_edges)"], ["proof (state)\nthis:\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg e' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "have \"sourcenode ax \\<noteq> Entry\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sourcenode ax \\<noteq> Entry", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode ax = Entry \\<Longrightarrow> False", "assume \"sourcenode ax = Entry\""], ["proof (state)\nthis:\n  sourcenode ax = Entry\n\ngoal (1 subgoal):\n 1. sourcenode ax = Entry \\<Longrightarrow> False", "with \\<open>valid_edge ax\\<close> \\<open>kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode ax = Entry", "show False"], ["proof (prove)\nusing this:\n  valid_edge ax\n  kind ax = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode ax = Entry\n\ngoal (1 subgoal):\n 1. False", "by(rule Entry_no_call_source)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sourcenode ax \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg e' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "with \\<open>sourcenode ax' = sourcenode ax\\<close>"], ["proof (chain)\npicking this:\n  sourcenode ax' = sourcenode ax\n  sourcenode ax \\<noteq> Entry", "have \"sourcenode ax' \\<noteq> Entry\""], ["proof (prove)\nusing this:\n  sourcenode ax' = sourcenode ax\n  sourcenode ax \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. sourcenode ax' \\<noteq> Entry", "by simp"], ["proof (state)\nthis:\n  sourcenode ax' \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg e' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "with \\<open>valid_edge ax'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax'\n  sourcenode ax' \\<noteq> Entry", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?ex\""], ["proof (prove)\nusing this:\n  valid_edge ax'\n  sourcenode ax' \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node (sourcenode ax'), kind ax', Node (targetnode ax'))", "by(fastforce intro:lve_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode ax'), kind ax', Node (targetnode ax'))\n\ngoal (1 subgoal):\n 1. \\<And>aa a' e'.\n       \\<lbrakk>a = (Node (sourcenode aa), kind aa, Node (targetnode aa));\n        valid_edge aa; a' \\<in> get_return_edges aa;\n        e' = (Node (sourcenode a'), kind a', Node (targetnode a'));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n         a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a''.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a'' \\<and>\n                            src a'' = src a \\<and>\n                            trg a'' = trg e' \\<and>\n                            knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "with \\<open>e' = (Node (sourcenode a'), kind a', Node (targetnode a'))\\<close>\n        \\<open>a = (Node (sourcenode ax), kind ax, Node (targetnode ax))\\<close>\n        \\<open>e' = (Node (sourcenode a'), kind a', Node (targetnode a'))\\<close>\n        \\<open>sourcenode ax' = sourcenode ax\\<close> \\<open>targetnode ax' = targetnode a'\\<close>\n        \\<open>kind ax' = (\\<lambda>cf. False)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  e' = (Node (sourcenode a'), kind a', Node (targetnode a'))\n  a = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  e' = (Node (sourcenode a'), kind a', Node (targetnode a'))\n  sourcenode ax' = sourcenode ax\n  targetnode ax' = targetnode a'\n  kind ax' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode ax'), kind ax', Node (targetnode ax'))", "show ?case"], ["proof (prove)\nusing this:\n  e' = (Node (sourcenode a'), kind a', Node (targetnode a'))\n  a = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  e' = (Node (sourcenode a'), kind a', Node (targetnode a'))\n  sourcenode ax' = sourcenode ax\n  targetnode ax' = targetnode a'\n  kind ax' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode ax'), kind ax', Node (targetnode ax'))\n\ngoal (1 subgoal):\n 1. \\<exists>a''.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a'' \\<and>\n       src a'' = src a \\<and>\n       trg a'' = trg e' \\<and> knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>", "by simp"], ["proof (state)\nthis:\n  \\<exists>a''.\n     lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n      a'' \\<and>\n     src a'' = src a \\<and>\n     trg a'' = trg e' \\<and> knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a''.\n     lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n      a'' \\<and>\n     src a'' = src a \\<and>\n     trg a'' = trg a' \\<and> knd a'' = (\\<lambda>cf. False)\\<^sub>\\<surd>\n\ngoal (6 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 3. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 4. distinct_fst procs\n 5. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 6. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 3. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 4. distinct_fst procs\n 5. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 6. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "fix a Q r p fs"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 3. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 4. distinct_fst procs\n 5. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 6. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (6 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src a \\<and> intra_kind (knd a')\n 2. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 3. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 4. distinct_fst procs\n 5. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 6. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "thus \"\\<exists>!a'. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a' \\<and>\n      src a' = src a \\<and> intra_kind (knd a')\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a' \\<and>\n       src a' = src a \\<and> intra_kind (knd a')", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')", "case (lve_edge a e)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')", "from \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close> \\<open>knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "by simp"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"\\<exists>!a'. valid_edge a' \\<and> sourcenode a' = sourcenode a \\<and>\n        intra_kind(kind a')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       valid_edge a' \\<and>\n       sourcenode a' = sourcenode a \\<and> intra_kind (kind a')", "by(rule call_only_one_intra_edge)"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     valid_edge a' \\<and>\n     sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')", "then"], ["proof (chain)\npicking this:\n  \\<exists>!a'.\n     valid_edge a' \\<and>\n     sourcenode a' = sourcenode a \\<and> intra_kind (kind a')", "obtain a' where \"valid_edge a'\" and \"sourcenode a' = sourcenode a\"\n        and \"intra_kind(kind a')\" \n        and imp:\"\\<forall>x. valid_edge x \\<and> sourcenode x = sourcenode a \\<and> intra_kind(kind x)\n        \\<longrightarrow> x = a'\""], ["proof (prove)\nusing this:\n  \\<exists>!a'.\n     valid_edge a' \\<and>\n     sourcenode a' = sourcenode a \\<and> intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>valid_edge a'; sourcenode a' = sourcenode a;\n         intra_kind (kind a');\n         \\<forall>x.\n            valid_edge x \\<and>\n            sourcenode x = sourcenode a \\<and>\n            intra_kind (kind x) \\<longrightarrow>\n            x = a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:ex1E)"], ["proof (state)\nthis:\n  valid_edge a'\n  sourcenode a' = sourcenode a\n  intra_kind (kind a')\n  \\<forall>x.\n     valid_edge x \\<and>\n     sourcenode x = sourcenode a \\<and>\n     intra_kind (kind x) \\<longrightarrow>\n     x = a'\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')", "let ?e' = \"(Node (sourcenode a'), kind a', Node (targetnode a'))\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')", "have \"sourcenode a \\<noteq> Entry\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sourcenode a \\<noteq> Entry", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a = Entry \\<Longrightarrow> False", "assume \"sourcenode a = Entry\""], ["proof (state)\nthis:\n  sourcenode a = Entry\n\ngoal (1 subgoal):\n 1. sourcenode a = Entry \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a = Entry", "show False"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a = Entry\n\ngoal (1 subgoal):\n 1. False", "by(rule Entry_no_call_source)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sourcenode a \\<noteq> Entry\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')", "with \\<open>sourcenode a' = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  sourcenode a' = sourcenode a\n  sourcenode a \\<noteq> Entry", "have \"sourcenode a' \\<noteq> Entry\""], ["proof (prove)\nusing this:\n  sourcenode a' = sourcenode a\n  sourcenode a \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. sourcenode a' \\<noteq> Entry", "by simp"], ["proof (state)\nthis:\n  sourcenode a' \\<noteq> Entry\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')", "with \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  sourcenode a' \\<noteq> Entry", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?e'\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  sourcenode a' \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node (sourcenode a'), kind a', Node (targetnode a'))", "by(fastforce intro:lift_valid_edge.lve_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')", "moreover"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')", "from \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>\n        \\<open>sourcenode a' = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  sourcenode a' = sourcenode a", "have \"src ?e' = src e\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  sourcenode a' = sourcenode a\n\ngoal (1 subgoal):\n 1. src (Node (sourcenode a'), kind a', Node (targetnode a')) = src e", "by simp"], ["proof (state)\nthis:\n  src (Node (sourcenode a'), kind a', Node (targetnode a')) = src e\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')", "moreover"], ["proof (state)\nthis:\n  src (Node (sourcenode a'), kind a', Node (targetnode a')) = src e\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')", "from \\<open>intra_kind(kind a')\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a')", "have \"intra_kind (knd ?e')\""], ["proof (prove)\nusing this:\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. intra_kind (knd (Node (sourcenode a'), kind a', Node (targetnode a')))", "by simp"], ["proof (state)\nthis:\n  intra_kind (knd (Node (sourcenode a'), kind a', Node (targetnode a')))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')", "moreover"], ["proof (state)\nthis:\n  intra_kind (knd (Node (sourcenode a'), kind a', Node (targetnode a')))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')", "{"], ["proof (state)\nthis:\n  intra_kind (knd (Node (sourcenode a'), kind a', Node (targetnode a')))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')", "fix x"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit x\"\n          and \"src x = src e\" and \"intra_kind (knd x)\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit x\n  src x = src e\n  intra_kind (knd x)\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')", "from \\<open>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit x\\<close>"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit x", "have \"x = ?e'\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit x\n\ngoal (1 subgoal):\n 1. x = (Node (sourcenode a'), kind a', Node (targetnode a'))", "proof(induct rule:lift_valid_edge.cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>x = e; valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a))\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e =\n        (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 3. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 4. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "case (lve_edge ax ex)"], ["proof (state)\nthis:\n  x = ex\n  valid_edge ax\n  sourcenode ax \\<noteq> Entry \\<or> targetnode ax \\<noteq> Exit\n  ex = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>x = e; valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a))\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e =\n        (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 3. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 4. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "from \\<open>intra_kind (knd x)\\<close> \\<open>x = ex\\<close> \\<open>src x = src e\\<close>\n            \\<open>ex = (Node (sourcenode ax), kind ax, Node (targetnode ax))\\<close>\n            \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (knd x)\n  x = ex\n  src x = src e\n  ex = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  e = (Node (sourcenode a), kind a, Node (targetnode a))", "have \"intra_kind (kind ax)\" and \"sourcenode ax = sourcenode a\""], ["proof (prove)\nusing this:\n  intra_kind (knd x)\n  x = ex\n  src x = src e\n  ex = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n\ngoal (1 subgoal):\n 1. intra_kind (kind ax) &&& sourcenode ax = sourcenode a", "by simp_all"], ["proof (state)\nthis:\n  intra_kind (kind ax)\n  sourcenode ax = sourcenode a\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>x = e; valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a))\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e =\n        (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 3. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 4. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "with \\<open>valid_edge ax\\<close> imp"], ["proof (chain)\npicking this:\n  valid_edge ax\n  \\<forall>x.\n     valid_edge x \\<and>\n     sourcenode x = sourcenode a \\<and>\n     intra_kind (kind x) \\<longrightarrow>\n     x = a'\n  intra_kind (kind ax)\n  sourcenode ax = sourcenode a", "have \"ax = a'\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  \\<forall>x.\n     valid_edge x \\<and>\n     sourcenode x = sourcenode a \\<and>\n     intra_kind (kind x) \\<longrightarrow>\n     x = a'\n  intra_kind (kind ax)\n  sourcenode ax = sourcenode a\n\ngoal (1 subgoal):\n 1. ax = a'", "by fastforce"], ["proof (state)\nthis:\n  ax = a'\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>x = e; valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a))\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e =\n        (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 3. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 4. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "with \\<open>x = ex\\<close> \\<open>ex = (Node (sourcenode ax), kind ax, Node (targetnode ax))\\<close>"], ["proof (chain)\npicking this:\n  x = ex\n  ex = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  ax = a'", "show ?case"], ["proof (prove)\nusing this:\n  x = ex\n  ex = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  ax = a'\n\ngoal (1 subgoal):\n 1. x = (Node (sourcenode a'), kind a', Node (targetnode a'))", "by simp"], ["proof (state)\nthis:\n  x = (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e =\n        (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 3. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e =\n        (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 3. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "case (lve_Entry_edge ex)"], ["proof (state)\nthis:\n  x = ex\n  ex = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e =\n        (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 3. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "with \\<open>src x = src e\\<close> \n            \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  src x = src e\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  x = ex\n  ex = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)", "have False"], ["proof (prove)\nusing this:\n  src x = src e\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  x = ex\n  ex = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e =\n        (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 3. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. x = (Node (sourcenode a'), kind a', Node (targetnode a'))", "by simp"], ["proof (state)\nthis:\n  x = (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "case (lve_Exit_edge ex)"], ["proof (state)\nthis:\n  x = ex\n  ex = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "with \\<open>src x = src e\\<close> \n            \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  src x = src e\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  x = ex\n  ex = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)", "have \"sourcenode a = Exit\""], ["proof (prove)\nusing this:\n  src x = src e\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  x = ex\n  ex = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n\ngoal (1 subgoal):\n 1. sourcenode a = Exit", "by simp"], ["proof (state)\nthis:\n  sourcenode a = Exit\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = Exit", "have False"], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = Exit\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. x = (Node (sourcenode a'), kind a', Node (targetnode a'))", "by simp"], ["proof (state)\nthis:\n  x = (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "case (lve_Entry_Exit_edge ex)"], ["proof (state)\nthis:\n  x = ex\n  ex = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "with \\<open>src x = src e\\<close> \n            \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  src x = src e\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  x = ex\n  ex = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)", "have False"], ["proof (prove)\nusing this:\n  src x = src e\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  x = ex\n  ex = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. x = (Node (sourcenode a'), kind a', Node (targetnode a'))", "by simp"], ["proof (state)\nthis:\n  x = (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')", "}"], ["proof (state)\nthis:\n  \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n            ?x2;\n   src ?x2 = src e; intra_kind (knd ?x2)\\<rbrakk>\n  \\<Longrightarrow> ?x2 =\n                    (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')", "ultimately"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a'), kind a', Node (targetnode a'))\n  src (Node (sourcenode a'), kind a', Node (targetnode a')) = src e\n  intra_kind (knd (Node (sourcenode a'), kind a', Node (targetnode a')))\n  \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n            ?x2;\n   src ?x2 = src e; intra_kind (knd ?x2)\\<rbrakk>\n  \\<Longrightarrow> ?x2 =\n                    (Node (sourcenode a'), kind a', Node (targetnode a'))", "show ?case"], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a'), kind a', Node (targetnode a'))\n  src (Node (sourcenode a'), kind a', Node (targetnode a')) = src e\n  intra_kind (knd (Node (sourcenode a'), kind a', Node (targetnode a')))\n  \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n            ?x2;\n   src ?x2 = src e; intra_kind (knd ?x2)\\<rbrakk>\n  \\<Longrightarrow> ?x2 =\n                    (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a' \\<and>\n       src a' = src e \\<and> intra_kind (knd a')", "by(blast intro:ex1I)"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n      a' \\<and>\n     src a' = src e \\<and> intra_kind (knd a')\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            src a' = src e \\<and> intra_kind (knd a')", "qed simp_all"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n      a' \\<and>\n     src a' = src a \\<and> intra_kind (knd a')\n\ngoal (5 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 2. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 3. distinct_fst procs\n 4. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 5. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 2. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 3. distinct_fst procs\n 4. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 5. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "fix a Q' p f'"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 2. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 3. distinct_fst procs\n 4. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 5. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (5 subgoals):\n 1. \\<And>a Q' p f'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg a \\<and> intra_kind (knd a')\n 2. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 3. distinct_fst procs\n 4. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 5. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "thus \"\\<exists>!a'. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a' \\<and>\n      trg a' = trg a \\<and> intra_kind (knd a')\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a' \\<and>\n       trg a' = trg a \\<and> intra_kind (knd a')", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')", "case (lve_edge a e)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')", "from \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close> \\<open>knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "by simp"], ["proof (state)\nthis:\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"\\<exists>!a'. valid_edge a' \\<and> targetnode a' = targetnode a \\<and>\n        intra_kind(kind a')\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       valid_edge a' \\<and>\n       targetnode a' = targetnode a \\<and> intra_kind (kind a')", "by(rule return_only_one_intra_edge)"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     valid_edge a' \\<and>\n     targetnode a' = targetnode a \\<and> intra_kind (kind a')\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')", "then"], ["proof (chain)\npicking this:\n  \\<exists>!a'.\n     valid_edge a' \\<and>\n     targetnode a' = targetnode a \\<and> intra_kind (kind a')", "obtain a' where \"valid_edge a'\" and \"targetnode a' = targetnode a\"\n        and \"intra_kind(kind a')\" \n        and imp:\"\\<forall>x. valid_edge x \\<and> targetnode x = targetnode a \\<and> intra_kind(kind x)\n        \\<longrightarrow> x = a'\""], ["proof (prove)\nusing this:\n  \\<exists>!a'.\n     valid_edge a' \\<and>\n     targetnode a' = targetnode a \\<and> intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>valid_edge a'; targetnode a' = targetnode a;\n         intra_kind (kind a');\n         \\<forall>x.\n            valid_edge x \\<and>\n            targetnode x = targetnode a \\<and>\n            intra_kind (kind x) \\<longrightarrow>\n            x = a'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:ex1E)"], ["proof (state)\nthis:\n  valid_edge a'\n  targetnode a' = targetnode a\n  intra_kind (kind a')\n  \\<forall>x.\n     valid_edge x \\<and>\n     targetnode x = targetnode a \\<and>\n     intra_kind (kind x) \\<longrightarrow>\n     x = a'\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')", "let ?e' = \"(Node (sourcenode a'), kind a', Node (targetnode a'))\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')", "have \"targetnode a \\<noteq> Exit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> Exit", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. targetnode a = Exit \\<Longrightarrow> False", "assume \"targetnode a = Exit\""], ["proof (state)\nthis:\n  targetnode a = Exit\n\ngoal (1 subgoal):\n 1. targetnode a = Exit \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  targetnode a = Exit", "show False"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  targetnode a = Exit\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_no_return_target)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  targetnode a \\<noteq> Exit\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')", "with \\<open>targetnode a' = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  targetnode a' = targetnode a\n  targetnode a \\<noteq> Exit", "have \"targetnode a' \\<noteq> Exit\""], ["proof (prove)\nusing this:\n  targetnode a' = targetnode a\n  targetnode a \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. targetnode a' \\<noteq> Exit", "by simp"], ["proof (state)\nthis:\n  targetnode a' \\<noteq> Exit\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')", "with \\<open>valid_edge a'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a'\n  targetnode a' \\<noteq> Exit", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?e'\""], ["proof (prove)\nusing this:\n  valid_edge a'\n  targetnode a' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node (sourcenode a'), kind a', Node (targetnode a'))", "by(fastforce intro:lift_valid_edge.lve_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')", "moreover"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')", "from \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>\n        \\<open>targetnode a' = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  targetnode a' = targetnode a", "have \"trg ?e' = trg e\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  targetnode a' = targetnode a\n\ngoal (1 subgoal):\n 1. trg (Node (sourcenode a'), kind a', Node (targetnode a')) = trg e", "by simp"], ["proof (state)\nthis:\n  trg (Node (sourcenode a'), kind a', Node (targetnode a')) = trg e\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')", "moreover"], ["proof (state)\nthis:\n  trg (Node (sourcenode a'), kind a', Node (targetnode a')) = trg e\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')", "from \\<open>intra_kind(kind a')\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind a')", "have \"intra_kind (knd ?e')\""], ["proof (prove)\nusing this:\n  intra_kind (kind a')\n\ngoal (1 subgoal):\n 1. intra_kind (knd (Node (sourcenode a'), kind a', Node (targetnode a')))", "by simp"], ["proof (state)\nthis:\n  intra_kind (knd (Node (sourcenode a'), kind a', Node (targetnode a')))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')", "moreover"], ["proof (state)\nthis:\n  intra_kind (knd (Node (sourcenode a'), kind a', Node (targetnode a')))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')", "{"], ["proof (state)\nthis:\n  intra_kind (knd (Node (sourcenode a'), kind a', Node (targetnode a')))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')", "fix x"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit x\"\n          and \"trg x = trg e\" and \"intra_kind (knd x)\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit x\n  trg x = trg e\n  intra_kind (knd x)\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')", "from \\<open>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit x\\<close>"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit x", "have \"x = ?e'\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit x\n\ngoal (1 subgoal):\n 1. x = (Node (sourcenode a'), kind a', Node (targetnode a'))", "proof(induct rule:lift_valid_edge.cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>x = e; valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a))\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e =\n        (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 3. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 4. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "case (lve_edge ax ex)"], ["proof (state)\nthis:\n  x = ex\n  valid_edge ax\n  sourcenode ax \\<noteq> Entry \\<or> targetnode ax \\<noteq> Exit\n  ex = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>x = e; valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a))\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e =\n        (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 3. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 4. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "from \\<open>intra_kind (knd x)\\<close> \\<open>x = ex\\<close> \\<open>trg x = trg e\\<close>\n            \\<open>ex = (Node (sourcenode ax), kind ax, Node (targetnode ax))\\<close>\n            \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (knd x)\n  x = ex\n  trg x = trg e\n  ex = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  e = (Node (sourcenode a), kind a, Node (targetnode a))", "have \"intra_kind (kind ax)\" and \"targetnode ax = targetnode a\""], ["proof (prove)\nusing this:\n  intra_kind (knd x)\n  x = ex\n  trg x = trg e\n  ex = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n\ngoal (1 subgoal):\n 1. intra_kind (kind ax) &&& targetnode ax = targetnode a", "by simp_all"], ["proof (state)\nthis:\n  intra_kind (kind ax)\n  targetnode ax = targetnode a\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>x = e; valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a))\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e =\n        (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 3. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 4. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "with \\<open>valid_edge ax\\<close> imp"], ["proof (chain)\npicking this:\n  valid_edge ax\n  \\<forall>x.\n     valid_edge x \\<and>\n     targetnode x = targetnode a \\<and>\n     intra_kind (kind x) \\<longrightarrow>\n     x = a'\n  intra_kind (kind ax)\n  targetnode ax = targetnode a", "have \"ax = a'\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  \\<forall>x.\n     valid_edge x \\<and>\n     targetnode x = targetnode a \\<and>\n     intra_kind (kind x) \\<longrightarrow>\n     x = a'\n  intra_kind (kind ax)\n  targetnode ax = targetnode a\n\ngoal (1 subgoal):\n 1. ax = a'", "by fastforce"], ["proof (state)\nthis:\n  ax = a'\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>x = e; valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a))\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e =\n        (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 3. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 4. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "with \\<open>x = ex\\<close> \\<open>ex = (Node (sourcenode ax), kind ax, Node (targetnode ax))\\<close>"], ["proof (chain)\npicking this:\n  x = ex\n  ex = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  ax = a'", "show ?case"], ["proof (prove)\nusing this:\n  x = ex\n  ex = (Node (sourcenode ax), kind ax, Node (targetnode ax))\n  ax = a'\n\ngoal (1 subgoal):\n 1. x = (Node (sourcenode a'), kind a', Node (targetnode a'))", "by simp"], ["proof (state)\nthis:\n  x = (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e =\n        (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 3. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e =\n        (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 3. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "case (lve_Entry_edge ex)"], ["proof (state)\nthis:\n  x = ex\n  ex = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e =\n        (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 3. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "with \\<open>trg x = trg e\\<close> \n            \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  trg x = trg e\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  x = ex\n  ex = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)", "have \"targetnode a = Entry\""], ["proof (prove)\nusing this:\n  trg x = trg e\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  x = ex\n  ex = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n\ngoal (1 subgoal):\n 1. targetnode a = Entry", "by simp"], ["proof (state)\nthis:\n  targetnode a = Entry\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e =\n        (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 3. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  targetnode a = Entry", "have False"], ["proof (prove)\nusing this:\n  valid_edge a\n  targetnode a = Entry\n\ngoal (1 subgoal):\n 1. False", "by(rule Entry_target)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e =\n        (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 3. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. x = (Node (sourcenode a'), kind a', Node (targetnode a'))", "by simp"], ["proof (state)\nthis:\n  x = (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "case (lve_Exit_edge ex)"], ["proof (state)\nthis:\n  x = ex\n  ex = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "with \\<open>trg x = trg e\\<close> \n            \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  trg x = trg e\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  x = ex\n  ex = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)", "have False"], ["proof (prove)\nusing this:\n  trg x = trg e\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  x = ex\n  ex = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))\n 2. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. x = (Node (sourcenode a'), kind a', Node (targetnode a'))", "by simp"], ["proof (state)\nthis:\n  x = (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "case (lve_Entry_Exit_edge ex)"], ["proof (state)\nthis:\n  x = ex\n  ex = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "with \\<open>trg x = trg e\\<close> \n            \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  trg x = trg e\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  x = ex\n  ex = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)", "have False"], ["proof (prove)\nusing this:\n  trg x = trg e\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  x = ex\n  ex = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>x = e;\n        e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<rbrakk>\n       \\<Longrightarrow> x =\n                         (Node (sourcenode a'), kind a',\n                          Node (targetnode a'))", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. x = (Node (sourcenode a'), kind a', Node (targetnode a'))", "by simp"], ["proof (state)\nthis:\n  x = (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')", "}"], ["proof (state)\nthis:\n  \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n            ?x2;\n   trg ?x2 = trg e; intra_kind (knd ?x2)\\<rbrakk>\n  \\<Longrightarrow> ?x2 =\n                    (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')", "ultimately"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a'), kind a', Node (targetnode a'))\n  trg (Node (sourcenode a'), kind a', Node (targetnode a')) = trg e\n  intra_kind (knd (Node (sourcenode a'), kind a', Node (targetnode a')))\n  \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n            ?x2;\n   trg ?x2 = trg e; intra_kind (knd ?x2)\\<rbrakk>\n  \\<Longrightarrow> ?x2 =\n                    (Node (sourcenode a'), kind a', Node (targetnode a'))", "show ?case"], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a'), kind a', Node (targetnode a'))\n  trg (Node (sourcenode a'), kind a', Node (targetnode a')) = trg e\n  intra_kind (knd (Node (sourcenode a'), kind a', Node (targetnode a')))\n  \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n            ?x2;\n   trg ?x2 = trg e; intra_kind (knd ?x2)\\<rbrakk>\n  \\<Longrightarrow> ?x2 =\n                    (Node (sourcenode a'), kind a', Node (targetnode a'))\n\ngoal (1 subgoal):\n 1. \\<exists>!a'.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a' \\<and>\n       trg a' = trg e \\<and> intra_kind (knd a')", "by(blast intro:ex1I)"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n      a' \\<and>\n     trg a' = trg e \\<and> intra_kind (knd a')\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!a'.\n                            lift_valid_edge valid_edge sourcenode targetnode\n                             kind Entry Exit a' \\<and>\n                            trg a' = trg e \\<and> intra_kind (knd a')", "qed simp_all"], ["proof (state)\nthis:\n  \\<exists>!a'.\n     lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n      a' \\<and>\n     trg a' = trg a \\<and> intra_kind (knd a')\n\ngoal (4 subgoals):\n 1. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 2. distinct_fst procs\n 3. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 4. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 2. distinct_fst procs\n 3. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 4. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "fix a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2 fs\\<^sub>2"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 2. distinct_fst procs\n 3. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 4. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\"\n      and \"knd a = Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1\" and \"knd a' = Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  knd a = Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1\n  knd a' = Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\n\ngoal (4 subgoals):\n 1. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 2. distinct_fst procs\n 3. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 4. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "then"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  knd a = Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1\n  knd a' = Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2", "obtain x x' where \"valid_edge x\" \n      and a:\"a = (Node (sourcenode x),kind x,Node (targetnode x))\" and \"valid_edge x'\"\n      and a':\"a' = (Node (sourcenode x'),kind x',Node (targetnode x'))\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  knd a = Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1\n  knd a' = Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>x x'.\n        \\<lbrakk>valid_edge x;\n         a = (Node (sourcenode x), kind x, Node (targetnode x));\n         valid_edge x';\n         a' = (Node (sourcenode x'), kind x', Node (targetnode x'))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto elim!:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  valid_edge x\n  a = (Node (sourcenode x), kind x, Node (targetnode x))\n  valid_edge x'\n  a' = (Node (sourcenode x'), kind x', Node (targetnode x'))\n\ngoal (4 subgoals):\n 1. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 2. distinct_fst procs\n 3. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 4. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "with \\<open>knd a = Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1\\<close> \\<open>knd a' = Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<close>"], ["proof (chain)\npicking this:\n  knd a = Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1\n  knd a' = Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\n  valid_edge x\n  a = (Node (sourcenode x), kind x, Node (targetnode x))\n  valid_edge x'\n  a' = (Node (sourcenode x'), kind x', Node (targetnode x'))", "have \"kind x = Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1\" and \"kind x' = Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\""], ["proof (prove)\nusing this:\n  knd a = Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1\n  knd a' = Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\n  valid_edge x\n  a = (Node (sourcenode x), kind x, Node (targetnode x))\n  valid_edge x'\n  a' = (Node (sourcenode x'), kind x', Node (targetnode x'))\n\ngoal (1 subgoal):\n 1. kind x =\n    Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1 &&&\n    kind x' =\n    Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2", "by simp_all"], ["proof (state)\nthis:\n  kind x = Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1\n  kind x' = Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\n\ngoal (4 subgoals):\n 1. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 2. distinct_fst procs\n 3. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 4. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "with \\<open>valid_edge x\\<close> \\<open>valid_edge x'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge x\n  valid_edge x'\n  kind x = Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1\n  kind x' = Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2", "have \"targetnode x = targetnode x'\""], ["proof (prove)\nusing this:\n  valid_edge x\n  valid_edge x'\n  kind x = Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1\n  kind x' = Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\n\ngoal (1 subgoal):\n 1. targetnode x = targetnode x'", "by(rule same_proc_call_unique_target)"], ["proof (state)\nthis:\n  targetnode x = targetnode x'\n\ngoal (4 subgoals):\n 1. \\<And>a a' Q\\<^sub>1 r\\<^sub>1 p fs\\<^sub>1 Q\\<^sub>2 r\\<^sub>2\n       fs\\<^sub>2.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a =\n        Q\\<^sub>1:r\\<^sub>1\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>1;\n        knd a' =\n        Q\\<^sub>2:r\\<^sub>2\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> trg a = trg a'\n 2. distinct_fst procs\n 3. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 4. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "with a a'"], ["proof (chain)\npicking this:\n  a = (Node (sourcenode x), kind x, Node (targetnode x))\n  a' = (Node (sourcenode x'), kind x', Node (targetnode x'))\n  targetnode x = targetnode x'", "show \"trg a = trg a'\""], ["proof (prove)\nusing this:\n  a = (Node (sourcenode x), kind x, Node (targetnode x))\n  a' = (Node (sourcenode x'), kind x', Node (targetnode x'))\n  targetnode x = targetnode x'\n\ngoal (1 subgoal):\n 1. trg a = trg a'", "by simp"], ["proof (state)\nthis:\n  trg a = trg a'\n\ngoal (3 subgoals):\n 1. distinct_fst procs\n 2. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 3. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. distinct_fst procs\n 2. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 3. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "from unique_callers"], ["proof (chain)\npicking this:\n  distinct_fst procs", "show \"distinct_fst procs\""], ["proof (prove)\nusing this:\n  distinct_fst procs\n\ngoal (1 subgoal):\n 1. distinct_fst procs", "."], ["proof (state)\nthis:\n  distinct_fst procs\n\ngoal (2 subgoals):\n 1. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 2. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 2. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "fix p ins outs"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 2. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "assume \"(p, ins, outs) \\<in> set procs\""], ["proof (state)\nthis:\n  (p, ins, outs) \\<in> set procs\n\ngoal (2 subgoals):\n 1. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct ins\n 2. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "from distinct_formal_ins[OF this]"], ["proof (chain)\npicking this:\n  distinct ins", "show \"distinct ins\""], ["proof (prove)\nusing this:\n  distinct ins\n\ngoal (1 subgoal):\n 1. distinct ins", "."], ["proof (state)\nthis:\n  distinct ins\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "fix p ins outs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "assume \"(p, ins, outs) \\<in> set procs\""], ["proof (state)\nthis:\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. \\<And>p ins outs.\n       (p, ins, outs) \\<in> set procs \\<Longrightarrow> distinct outs", "from distinct_formal_outs[OF this]"], ["proof (chain)\npicking this:\n  distinct outs", "show \"distinct outs\""], ["proof (prove)\nusing this:\n  distinct outs\n\ngoal (1 subgoal):\n 1. distinct outs", "."], ["proof (state)\nthis:\n  distinct outs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CFG src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_get_proc get_proc Main)\n   (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode\n     kind)\n   procs Main\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_CFG_wf:\n  assumes wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc \n  get_return_edges procs Main Exit Def Use ParamDefs ParamUses\"\n  and pd:\"Postdomination sourcenode targetnode kind valid_edge Entry get_proc \n  get_return_edges procs Main Exit\"\n  shows \"CFG_wf src trg knd\n  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\n  (lift_get_proc get_proc Main) \n  (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind) \n  procs Main (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n  (lift_ParamDefs ParamDefs) (lift_ParamUses ParamUses)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     (lift_ParamDefs ParamDefs) (lift_ParamUses ParamUses)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     (lift_ParamDefs ParamDefs) (lift_ParamUses ParamUses)", "interpret CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc \n    get_return_edges procs Main Exit Def Use ParamDefs ParamUses"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc\n     get_return_edges procs Main Exit Def Use ParamDefs ParamUses", "by(rule wf)"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     (lift_ParamDefs ParamDefs) (lift_ParamUses ParamUses)", "interpret Postdomination sourcenode targetnode kind valid_edge Entry get_proc \n    get_return_edges procs Main Exit"], ["proof (prove)\ngoal (1 subgoal):\n 1. Postdomination sourcenode targetnode kind valid_edge Entry get_proc\n     get_return_edges procs Main Exit", "by(rule pd)"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     (lift_ParamDefs ParamDefs) (lift_ParamUses ParamUses)", "interpret CFG:CFG src trg knd\n    \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\" NewEntry\n    \"lift_get_proc get_proc Main\" \n    \"lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind\"\n    procs Main"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main", "by(fastforce intro:lift_CFG wf pd)"], ["proof (state)\ngoal (1 subgoal):\n 1. CFG_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     (lift_ParamDefs ParamDefs) (lift_ParamUses ParamUses)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     (lift_ParamDefs ParamDefs) (lift_ParamUses ParamUses)", "proof"], ["proof (state)\ngoal (17 subgoals):\n 1. lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n    lift_Use Use Entry Exit H L NewEntry = {}\n 2. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamUses ParamUses (src a)) =\n                         length ins\n 3. \\<And>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg a))\n 4. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg a)) =\n                         length outs\n 5. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> set (lift_ParamDefs ParamDefs n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 6. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg a)\n 7. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 8. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 9. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 10. \\<And>a V s.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n         local.CFG.pred (knd a) s\\<rbrakk>\n        \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                           V =\n                          local.CFG.state_val s V\nA total of 17 subgoals...", "show \"lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n          lift_Use Use Entry Exit H L NewEntry = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n    lift_Use Use Entry Exit H L NewEntry = {}", "by(fastforce elim:lift_Use_set.cases lift_Def_set.cases)"], ["proof (state)\nthis:\n  lift_Def Def Entry Exit H L NewEntry = {} \\<and>\n  lift_Use Use Entry Exit H L NewEntry = {}\n\ngoal (16 subgoals):\n 1. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamUses ParamUses (src a)) =\n                         length ins\n 2. \\<And>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg a))\n 3. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg a)) =\n                         length outs\n 4. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> set (lift_ParamDefs ParamDefs n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 5. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg a)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 7. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 8. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 9. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 10. \\<And>a s s'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n            local.CFG.state_val s V = local.CFG.state_val s' V;\n         intra_kind (knd a); local.CFG.pred (knd a) s;\n         local.CFG.pred (knd a) s'\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L\n    (src a).\n                             local.CFG.state_val\n                              (local.CFG.transfer (knd a) s) V =\n                             local.CFG.state_val\n                              (local.CFG.transfer (knd a) s') V\nA total of 16 subgoals...", "next"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamUses ParamUses (src a)) =\n                         length ins\n 2. \\<And>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg a))\n 3. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg a)) =\n                         length outs\n 4. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> set (lift_ParamDefs ParamDefs n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 5. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg a)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 7. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 8. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 9. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 10. \\<And>a s s'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n            local.CFG.state_val s V = local.CFG.state_val s' V;\n         intra_kind (knd a); local.CFG.pred (knd a) s;\n         local.CFG.pred (knd a) s'\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L\n    (src a).\n                             local.CFG.state_val\n                              (local.CFG.transfer (knd a) s) V =\n                             local.CFG.state_val\n                              (local.CFG.transfer (knd a) s') V\nA total of 16 subgoals...", "fix a Q r p fs ins outs"], ["proof (state)\ngoal (16 subgoals):\n 1. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamUses ParamUses (src a)) =\n                         length ins\n 2. \\<And>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg a))\n 3. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg a)) =\n                         length outs\n 4. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> set (lift_ParamDefs ParamDefs n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 5. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg a)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 7. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 8. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 9. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 10. \\<And>a s s'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n            local.CFG.state_val s V = local.CFG.state_val s' V;\n         intra_kind (knd a); local.CFG.pred (knd a) s;\n         local.CFG.pred (knd a) s'\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L\n    (src a).\n                             local.CFG.state_val\n                              (local.CFG.transfer (knd a) s) V =\n                             local.CFG.state_val\n                              (local.CFG.transfer (knd a) s') V\nA total of 16 subgoals...", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"(p, ins, outs) \\<in> set procs\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n\ngoal (16 subgoals):\n 1. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamUses ParamUses (src a)) =\n                         length ins\n 2. \\<And>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg a))\n 3. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg a)) =\n                         length outs\n 4. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> set (lift_ParamDefs ParamDefs n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 5. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg a)\n 6. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 7. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 8. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 9. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 10. \\<And>a s s'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n            local.CFG.state_val s V = local.CFG.state_val s' V;\n         intra_kind (knd a); local.CFG.pred (knd a) s;\n         local.CFG.pred (knd a) s'\\<rbrakk>\n        \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L\n    (src a).\n                             local.CFG.state_val\n                              (local.CFG.transfer (knd a) s) V =\n                             local.CFG.state_val\n                              (local.CFG.transfer (knd a) s') V\nA total of 16 subgoals...", "thus \"length (lift_ParamUses ParamUses (src a)) = length ins\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. length (lift_ParamUses ParamUses (src a)) = length ins", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamUses ParamUses (src e)) =\n                         length ins\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamUses ParamUses (src e)) =\n                         length ins\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamUses ParamUses (src e)) =\n                         length ins\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamUses ParamUses (src e)) =\n                         length ins", "case (lve_edge a e)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamUses ParamUses (src e)) =\n                         length ins\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamUses ParamUses (src e)) =\n                         length ins\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamUses ParamUses (src e)) =\n                         length ins\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamUses ParamUses (src e)) =\n                         length ins", "from \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close> \\<open>knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"src e = Node (sourcenode a)\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs &&&\n    src e = Node (sourcenode a)", "by simp_all"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  src e = Node (sourcenode a)\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamUses ParamUses (src e)) =\n                         length ins\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamUses ParamUses (src e)) =\n                         length ins\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamUses ParamUses (src e)) =\n                         length ins\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamUses ParamUses (src e)) =\n                         length ins", "with \\<open>valid_edge a\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  (p, ins, outs) \\<in> set procs\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  src e = Node (sourcenode a)", "have \"length(ParamUses (sourcenode a)) = length ins\""], ["proof (prove)\nusing this:\n  valid_edge a\n  (p, ins, outs) \\<in> set procs\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  src e = Node (sourcenode a)\n\ngoal (1 subgoal):\n 1. length (ParamUses (sourcenode a)) = length ins", "by -(rule ParamUses_call_source_length)"], ["proof (state)\nthis:\n  length (ParamUses (sourcenode a)) = length ins\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamUses ParamUses (src e)) =\n                         length ins\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamUses ParamUses (src e)) =\n                         length ins\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamUses ParamUses (src e)) =\n                         length ins\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamUses ParamUses (src e)) =\n                         length ins", "with \\<open>src e = Node (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  src e = Node (sourcenode a)\n  length (ParamUses (sourcenode a)) = length ins", "show ?case"], ["proof (prove)\nusing this:\n  src e = Node (sourcenode a)\n  length (ParamUses (sourcenode a)) = length ins\n\ngoal (1 subgoal):\n 1. length (lift_ParamUses ParamUses (src e)) = length ins", "by simp"], ["proof (state)\nthis:\n  length (lift_ParamUses ParamUses (src e)) = length ins\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamUses ParamUses (src e)) =\n                         length ins\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamUses ParamUses (src e)) =\n                         length ins\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamUses ParamUses (src e)) =\n                         length ins", "qed simp_all"], ["proof (state)\nthis:\n  length (lift_ParamUses ParamUses (src a)) = length ins\n\ngoal (15 subgoals):\n 1. \\<And>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg a))\n 2. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg a)) =\n                         length outs\n 3. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> set (lift_ParamDefs ParamDefs n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 4. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg a)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 6. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 7. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 8. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 9. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 10. \\<And>a s s'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n         \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n            local.CFG.state_val s V = local.CFG.state_val s' V;\n         length s = length s'\\<rbrakk>\n        \\<Longrightarrow> local.CFG.pred (knd a) s'\nA total of 15 subgoals...", "next"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg a))\n 2. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg a)) =\n                         length outs\n 3. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> set (lift_ParamDefs ParamDefs n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 4. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg a)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 6. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 7. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 8. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 9. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 10. \\<And>a s s'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n         \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n            local.CFG.state_val s V = local.CFG.state_val s' V;\n         length s = length s'\\<rbrakk>\n        \\<Longrightarrow> local.CFG.pred (knd a) s'\nA total of 15 subgoals...", "fix a"], ["proof (state)\ngoal (15 subgoals):\n 1. \\<And>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg a))\n 2. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg a)) =\n                         length outs\n 3. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> set (lift_ParamDefs ParamDefs n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 4. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg a)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 6. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 7. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 8. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 9. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 10. \\<And>a s s'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n         \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n            local.CFG.state_val s V = local.CFG.state_val s' V;\n         length s = length s'\\<rbrakk>\n        \\<Longrightarrow> local.CFG.pred (knd a) s'\nA total of 15 subgoals...", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n\ngoal (15 subgoals):\n 1. \\<And>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg a))\n 2. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg a)) =\n                         length outs\n 3. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> set (lift_ParamDefs ParamDefs n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 4. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg a)\n 5. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 6. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 7. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 8. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 9. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 10. \\<And>a s s'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n         \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n            local.CFG.state_val s V = local.CFG.state_val s' V;\n         length s = length s'\\<rbrakk>\n        \\<Longrightarrow> local.CFG.pred (knd a) s'\nA total of 15 subgoals...", "thus \"distinct (lift_ParamDefs ParamDefs (trg a))\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n\ngoal (1 subgoal):\n 1. distinct (lift_ParamDefs ParamDefs (trg a))", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a))\\<rbrakk>\n       \\<Longrightarrow> distinct (lift_ParamDefs ParamDefs (trg e))\n 2. \\<And>e.\n       e =\n       (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>,\n        Node Entry) \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg e))\n 3. \\<And>e.\n       e =\n       (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>,\n        NewExit) \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg e))\n 4. \\<And>e.\n       e =\n       (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>,\n        NewExit) \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg e))", "case (lve_edge a e)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a))\\<rbrakk>\n       \\<Longrightarrow> distinct (lift_ParamDefs ParamDefs (trg e))\n 2. \\<And>e.\n       e =\n       (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>,\n        Node Entry) \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg e))\n 3. \\<And>e.\n       e =\n       (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>,\n        NewExit) \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg e))\n 4. \\<And>e.\n       e =\n       (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>,\n        NewExit) \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg e))", "from \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a", "have \"distinct (ParamDefs (targetnode a))\""], ["proof (prove)\nusing this:\n  valid_edge a\n\ngoal (1 subgoal):\n 1. distinct (ParamDefs (targetnode a))", "by(rule distinct_ParamDefs)"], ["proof (state)\nthis:\n  distinct (ParamDefs (targetnode a))\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a))\\<rbrakk>\n       \\<Longrightarrow> distinct (lift_ParamDefs ParamDefs (trg e))\n 2. \\<And>e.\n       e =\n       (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>,\n        Node Entry) \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg e))\n 3. \\<And>e.\n       e =\n       (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>,\n        NewExit) \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg e))\n 4. \\<And>e.\n       e =\n       (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>,\n        NewExit) \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg e))", "with \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  distinct (ParamDefs (targetnode a))", "show ?case"], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  distinct (ParamDefs (targetnode a))\n\ngoal (1 subgoal):\n 1. distinct (lift_ParamDefs ParamDefs (trg e))", "by simp"], ["proof (state)\nthis:\n  distinct (lift_ParamDefs ParamDefs (trg e))\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       e =\n       (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>,\n        Node Entry) \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg e))\n 2. \\<And>e.\n       e =\n       (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>,\n        NewExit) \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg e))\n 3. \\<And>e.\n       e =\n       (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>,\n        NewExit) \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg e))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e.\n       e =\n       (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>,\n        Node Entry) \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg e))\n 2. \\<And>e.\n       e =\n       (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>,\n        NewExit) \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg e))\n 3. \\<And>e.\n       e =\n       (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>,\n        NewExit) \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg e))", "case (lve_Entry_edge e)"], ["proof (state)\nthis:\n  e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       e =\n       (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>,\n        Node Entry) \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg e))\n 2. \\<And>e.\n       e =\n       (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>,\n        NewExit) \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg e))\n 3. \\<And>e.\n       e =\n       (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>,\n        NewExit) \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg e))", "have \"ParamDefs Entry = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ParamDefs Entry = []", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. ParamDefs Entry \\<noteq> [] \\<Longrightarrow> False", "assume \"ParamDefs Entry \\<noteq> []\""], ["proof (state)\nthis:\n  ParamDefs Entry \\<noteq> []\n\ngoal (1 subgoal):\n 1. ParamDefs Entry \\<noteq> [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  ParamDefs Entry \\<noteq> []", "obtain V Vs where \"ParamDefs Entry = V#Vs\""], ["proof (prove)\nusing this:\n  ParamDefs Entry \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>V Vs.\n        ParamDefs Entry = V # Vs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases \"ParamDefs Entry\") auto"], ["proof (state)\nthis:\n  ParamDefs Entry = V # Vs\n\ngoal (1 subgoal):\n 1. ParamDefs Entry \\<noteq> [] \\<Longrightarrow> False", "hence \"V \\<in> set (ParamDefs Entry)\""], ["proof (prove)\nusing this:\n  ParamDefs Entry = V # Vs\n\ngoal (1 subgoal):\n 1. V \\<in> set (ParamDefs Entry)", "by fastforce"], ["proof (state)\nthis:\n  V \\<in> set (ParamDefs Entry)\n\ngoal (1 subgoal):\n 1. ParamDefs Entry \\<noteq> [] \\<Longrightarrow> False", "hence \"V \\<in> Def Entry\""], ["proof (prove)\nusing this:\n  V \\<in> set (ParamDefs Entry)\n\ngoal (1 subgoal):\n 1. V \\<in> Def Entry", "by(fastforce intro:ParamDefs_in_Def)"], ["proof (state)\nthis:\n  V \\<in> Def Entry\n\ngoal (1 subgoal):\n 1. ParamDefs Entry \\<noteq> [] \\<Longrightarrow> False", "with Entry_empty"], ["proof (chain)\npicking this:\n  Def Entry = {} \\<and> Use Entry = {}\n  V \\<in> Def Entry", "show False"], ["proof (prove)\nusing this:\n  Def Entry = {} \\<and> Use Entry = {}\n  V \\<in> Def Entry\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ParamDefs Entry = []\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       e =\n       (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>,\n        Node Entry) \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg e))\n 2. \\<And>e.\n       e =\n       (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>,\n        NewExit) \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg e))\n 3. \\<And>e.\n       e =\n       (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>,\n        NewExit) \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg e))", "with \\<open>e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\\<close>"], ["proof (chain)\npicking this:\n  e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n  ParamDefs Entry = []", "show ?case"], ["proof (prove)\nusing this:\n  e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n  ParamDefs Entry = []\n\ngoal (1 subgoal):\n 1. distinct (lift_ParamDefs ParamDefs (trg e))", "by simp"], ["proof (state)\nthis:\n  distinct (lift_ParamDefs ParamDefs (trg e))\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       e =\n       (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>,\n        NewExit) \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg e))\n 2. \\<And>e.\n       e =\n       (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>,\n        NewExit) \\<Longrightarrow>\n       distinct (lift_ParamDefs ParamDefs (trg e))", "qed simp_all"], ["proof (state)\nthis:\n  distinct (lift_ParamDefs ParamDefs (trg a))\n\ngoal (14 subgoals):\n 1. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg a)) =\n                         length outs\n 2. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> set (lift_ParamDefs ParamDefs n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 3. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg a)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 5. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 6. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 7. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 8. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 9. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 10. \\<And>a Q r p fs ins outs.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         (p, ins, outs) \\<in> set procs\\<rbrakk>\n        \\<Longrightarrow> length fs = length ins\nA total of 14 subgoals...", "next"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg a)) =\n                         length outs\n 2. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> set (lift_ParamDefs ParamDefs n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 3. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg a)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 5. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 6. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 7. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 8. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 9. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 10. \\<And>a Q r p fs ins outs.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         (p, ins, outs) \\<in> set procs\\<rbrakk>\n        \\<Longrightarrow> length fs = length ins\nA total of 14 subgoals...", "fix a Q' p f' ins outs"], ["proof (state)\ngoal (14 subgoals):\n 1. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg a)) =\n                         length outs\n 2. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> set (lift_ParamDefs ParamDefs n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 3. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg a)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 5. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 6. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 7. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 8. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 9. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 10. \\<And>a Q r p fs ins outs.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         (p, ins, outs) \\<in> set procs\\<rbrakk>\n        \\<Longrightarrow> length fs = length ins\nA total of 14 subgoals...", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\" and \"(p, ins, outs) \\<in> set procs\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs\n\ngoal (14 subgoals):\n 1. \\<And>a Q' p f' ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg a)) =\n                         length outs\n 2. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> set (lift_ParamDefs ParamDefs n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 3. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg a)\n 4. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 5. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 6. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 7. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 8. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 9. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 10. \\<And>a Q r p fs ins outs.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         (p, ins, outs) \\<in> set procs\\<rbrakk>\n        \\<Longrightarrow> length fs = length ins\nA total of 14 subgoals...", "thus \"length (lift_ParamDefs ParamDefs (trg a)) = length outs\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. length (lift_ParamDefs ParamDefs (trg a)) = length outs", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg e)) =\n                         length outs\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg e)) =\n                         length outs\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg e)) =\n                         length outs\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg e)) =\n                         length outs", "case (lve_edge a e)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg e)) =\n                         length outs\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg e)) =\n                         length outs\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg e)) =\n                         length outs\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg e)) =\n                         length outs", "from \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>\n        \\<open>knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\" and \"trg e = Node (targetnode a)\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' &&&\n    trg e = Node (targetnode a)", "by simp_all"], ["proof (state)\nthis:\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  trg e = Node (targetnode a)\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg e)) =\n                         length outs\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg e)) =\n                         length outs\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg e)) =\n                         length outs\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg e)) =\n                         length outs", "with \\<open>valid_edge a\\<close> \\<open>(p,ins,outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  (p, ins, outs) \\<in> set procs\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  trg e = Node (targetnode a)", "have \"length(ParamDefs (targetnode a)) = length outs\""], ["proof (prove)\nusing this:\n  valid_edge a\n  (p, ins, outs) \\<in> set procs\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  trg e = Node (targetnode a)\n\ngoal (1 subgoal):\n 1. length (ParamDefs (targetnode a)) = length outs", "by -(rule ParamDefs_return_target_length)"], ["proof (state)\nthis:\n  length (ParamDefs (targetnode a)) = length outs\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg e)) =\n                         length outs\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg e)) =\n                         length outs\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg e)) =\n                         length outs\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg e)) =\n                         length outs", "with \\<open>trg e = Node (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  trg e = Node (targetnode a)\n  length (ParamDefs (targetnode a)) = length outs", "show ?case"], ["proof (prove)\nusing this:\n  trg e = Node (targetnode a)\n  length (ParamDefs (targetnode a)) = length outs\n\ngoal (1 subgoal):\n 1. length (lift_ParamDefs ParamDefs (trg e)) = length outs", "by simp"], ["proof (state)\nthis:\n  length (lift_ParamDefs ParamDefs (trg e)) = length outs\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg e)) =\n                         length outs\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg e)) =\n                         length outs\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length (lift_ParamDefs ParamDefs (trg e)) =\n                         length outs", "qed simp_all"], ["proof (state)\nthis:\n  length (lift_ParamDefs ParamDefs (trg a)) = length outs\n\ngoal (13 subgoals):\n 1. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> set (lift_ParamDefs ParamDefs n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 2. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg a)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 4. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 5. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 6. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 7. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 8. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 9. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 10. \\<And>a Q r p fs a' Q' r' p' fs' s.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a';\n         knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n         src a = src a'; local.CFG.pred (knd a) s;\n         local.CFG.pred (knd a') s\\<rbrakk>\n        \\<Longrightarrow> a = a'\nA total of 13 subgoals...", "next"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> set (lift_ParamDefs ParamDefs n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 2. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg a)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 4. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 5. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 6. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 7. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 8. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 9. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 10. \\<And>a Q r p fs a' Q' r' p' fs' s.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a';\n         knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n         src a = src a'; local.CFG.pred (knd a) s;\n         local.CFG.pred (knd a') s\\<rbrakk>\n        \\<Longrightarrow> a = a'\nA total of 13 subgoals...", "fix n V"], ["proof (state)\ngoal (13 subgoals):\n 1. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> set (lift_ParamDefs ParamDefs n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 2. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg a)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 4. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 5. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 6. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 7. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 8. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 9. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 10. \\<And>a Q r p fs a' Q' r' p' fs' s.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a';\n         knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n         src a = src a'; local.CFG.pred (knd a) s;\n         local.CFG.pred (knd a') s\\<rbrakk>\n        \\<Longrightarrow> a = a'\nA total of 13 subgoals...", "assume \"CFG.CFG.valid_node src trg \n      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) n\"\n      and \"V \\<in> set (lift_ParamDefs ParamDefs n)\""], ["proof (state)\nthis:\n  local.CFG.valid_node n\n  V \\<in> set (lift_ParamDefs ParamDefs n)\n\ngoal (13 subgoals):\n 1. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> set (lift_ParamDefs ParamDefs n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 2. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg a)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 4. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 5. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 6. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 7. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 8. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 9. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 10. \\<And>a Q r p fs a' Q' r' p' fs' s.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a';\n         knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n         src a = src a'; local.CFG.pred (knd a) s;\n         local.CFG.pred (knd a') s\\<rbrakk>\n        \\<Longrightarrow> a = a'\nA total of 13 subgoals...", "hence \"((n = NewEntry) \\<or> n = NewExit) \\<or> (\\<exists>m. n = Node m \\<and> valid_node m)\""], ["proof (prove)\nusing this:\n  local.CFG.valid_node n\n  V \\<in> set (lift_ParamDefs ParamDefs n)\n\ngoal (1 subgoal):\n 1. (n = NewEntry \\<or> n = NewExit) \\<or>\n    (\\<exists>m. n = Node m \\<and> valid_node m)", "by(auto elim:lift_valid_edge.cases simp:CFG.valid_node_def)"], ["proof (state)\nthis:\n  (n = NewEntry \\<or> n = NewExit) \\<or>\n  (\\<exists>m. n = Node m \\<and> valid_node m)\n\ngoal (13 subgoals):\n 1. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> set (lift_ParamDefs ParamDefs n)\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 2. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg a)\n 3. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 4. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 5. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 6. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 7. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 8. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 9. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 10. \\<And>a Q r p fs a' Q' r' p' fs' s.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a';\n         knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n         src a = src a'; local.CFG.pred (knd a) s;\n         local.CFG.pred (knd a') s\\<rbrakk>\n        \\<Longrightarrow> a = a'\nA total of 13 subgoals...", "thus \"V \\<in> lift_Def Def Entry Exit H L n\""], ["proof (prove)\nusing this:\n  (n = NewEntry \\<or> n = NewExit) \\<or>\n  (\\<exists>m. n = Node m \\<and> valid_node m)\n\ngoal (1 subgoal):\n 1. V \\<in> lift_Def Def Entry Exit H L n", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n = NewEntry \\<or> n = NewExit) \\<or>\n    (\\<exists>m. n = Node m \\<and> valid_node m) \\<Longrightarrow>\n    V \\<in> lift_Def Def Entry Exit H L n", "proof(erule disjE)+"], ["proof (state)\ngoal (3 subgoals):\n 1. n = NewEntry \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 2. n = NewExit \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 3. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    V \\<in> lift_Def Def Entry Exit H L n", "assume \"n = NewEntry\""], ["proof (state)\nthis:\n  n = NewEntry\n\ngoal (3 subgoals):\n 1. n = NewEntry \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 2. n = NewExit \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 3. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    V \\<in> lift_Def Def Entry Exit H L n", "with \\<open>V \\<in> set (lift_ParamDefs ParamDefs n)\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> set (lift_ParamDefs ParamDefs n)\n  n = NewEntry", "show ?thesis"], ["proof (prove)\nusing this:\n  V \\<in> set (lift_ParamDefs ParamDefs n)\n  n = NewEntry\n\ngoal (1 subgoal):\n 1. V \\<in> lift_Def Def Entry Exit H L n", "by simp"], ["proof (state)\nthis:\n  V \\<in> lift_Def Def Entry Exit H L n\n\ngoal (2 subgoals):\n 1. n = NewExit \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 2. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    V \\<in> lift_Def Def Entry Exit H L n", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. n = NewExit \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 2. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    V \\<in> lift_Def Def Entry Exit H L n", "assume \"n = NewExit\""], ["proof (state)\nthis:\n  n = NewExit\n\ngoal (2 subgoals):\n 1. n = NewExit \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L n\n 2. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    V \\<in> lift_Def Def Entry Exit H L n", "with \\<open>V \\<in> set (lift_ParamDefs ParamDefs n)\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> set (lift_ParamDefs ParamDefs n)\n  n = NewExit", "show ?thesis"], ["proof (prove)\nusing this:\n  V \\<in> set (lift_ParamDefs ParamDefs n)\n  n = NewExit\n\ngoal (1 subgoal):\n 1. V \\<in> lift_Def Def Entry Exit H L n", "by simp"], ["proof (state)\nthis:\n  V \\<in> lift_Def Def Entry Exit H L n\n\ngoal (1 subgoal):\n 1. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    V \\<in> lift_Def Def Entry Exit H L n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    V \\<in> lift_Def Def Entry Exit H L n", "assume \"\\<exists>m. n = Node m \\<and> valid_node m\""], ["proof (state)\nthis:\n  \\<exists>m. n = Node m \\<and> valid_node m\n\ngoal (1 subgoal):\n 1. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    V \\<in> lift_Def Def Entry Exit H L n", "then"], ["proof (chain)\npicking this:\n  \\<exists>m. n = Node m \\<and> valid_node m", "obtain m where \"n = Node m\" and \"valid_node m\""], ["proof (prove)\nusing this:\n  \\<exists>m. n = Node m \\<and> valid_node m\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>n = Node m; valid_node m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n = Node m\n  valid_node m\n\ngoal (1 subgoal):\n 1. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    V \\<in> lift_Def Def Entry Exit H L n", "from \\<open>n = Node m\\<close> \\<open>V \\<in> set (lift_ParamDefs ParamDefs n)\\<close>"], ["proof (chain)\npicking this:\n  n = Node m\n  V \\<in> set (lift_ParamDefs ParamDefs n)", "have \"V \\<in> set (ParamDefs m)\""], ["proof (prove)\nusing this:\n  n = Node m\n  V \\<in> set (lift_ParamDefs ParamDefs n)\n\ngoal (1 subgoal):\n 1. V \\<in> set (ParamDefs m)", "by simp"], ["proof (state)\nthis:\n  V \\<in> set (ParamDefs m)\n\ngoal (1 subgoal):\n 1. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    V \\<in> lift_Def Def Entry Exit H L n", "with \\<open>valid_node m\\<close>"], ["proof (chain)\npicking this:\n  valid_node m\n  V \\<in> set (ParamDefs m)", "have \"V \\<in> Def m\""], ["proof (prove)\nusing this:\n  valid_node m\n  V \\<in> set (ParamDefs m)\n\ngoal (1 subgoal):\n 1. V \\<in> Def m", "by(rule ParamDefs_in_Def)"], ["proof (state)\nthis:\n  V \\<in> Def m\n\ngoal (1 subgoal):\n 1. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    V \\<in> lift_Def Def Entry Exit H L n", "with \\<open>n = Node m\\<close>"], ["proof (chain)\npicking this:\n  n = Node m\n  V \\<in> Def m", "show ?thesis"], ["proof (prove)\nusing this:\n  n = Node m\n  V \\<in> Def m\n\ngoal (1 subgoal):\n 1. V \\<in> lift_Def Def Entry Exit H L n", "by(fastforce intro:lift_Def_node)"], ["proof (state)\nthis:\n  V \\<in> lift_Def Def Entry Exit H L n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  V \\<in> lift_Def Def Entry Exit H L n\n\ngoal (12 subgoals):\n 1. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg a)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 3. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 4. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 5. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 6. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 7. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 8. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 9. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 10. \\<And>a Q r p fs i ins outs s s'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n         (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n         local.CFG.pred (knd a) s';\n         \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n            local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n        \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                          local.CFG.params fs (local.CFG.state_val s') ! i\nA total of 12 subgoals...", "next"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg a)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 3. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 4. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 5. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 6. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 7. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 8. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 9. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 10. \\<And>a Q r p fs i ins outs s s'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n         (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n         local.CFG.pred (knd a) s';\n         \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n            local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n        \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                          local.CFG.params fs (local.CFG.state_val s') ! i\nA total of 12 subgoals...", "fix a Q r p fs ins outs V"], ["proof (state)\ngoal (12 subgoals):\n 1. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg a)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 3. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 4. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 5. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 6. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 7. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 8. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 9. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 10. \\<And>a Q r p fs i ins outs s s'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n         (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n         local.CFG.pred (knd a) s';\n         \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n            local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n        \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                          local.CFG.params fs (local.CFG.state_val s') ! i\nA total of 12 subgoals...", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"(p, ins, outs) \\<in> set procs\" and \"V \\<in> set ins\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n  V \\<in> set ins\n\ngoal (12 subgoals):\n 1. \\<And>a Q r p fs ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg a)\n 2. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 3. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 4. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 5. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 6. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 7. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 8. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 9. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 10. \\<And>a Q r p fs i ins outs s s'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n         (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n         local.CFG.pred (knd a) s';\n         \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n            local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n        \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                          local.CFG.params fs (local.CFG.state_val s') ! i\nA total of 12 subgoals...", "thus \"V \\<in> lift_Def Def Entry Exit H L (trg a)\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n  V \\<in> set ins\n\ngoal (1 subgoal):\n 1. V \\<in> lift_Def Def Entry Exit H L (trg a)", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg e)\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg e)\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg e)\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg e)", "case (lve_edge a e)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n  V \\<in> set ins\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg e)\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg e)\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg e)\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg e)", "from \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close> \\<open>knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "by simp"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg e)\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg e)\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg e)\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg e)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>(p, ins, outs) \\<in> set procs\\<close> \\<open>V \\<in> set ins\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n  V \\<in> set ins", "have \"V \\<in> Def (targetnode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n  V \\<in> set ins\n\ngoal (1 subgoal):\n 1. V \\<in> Def (targetnode a)", "by(rule ins_in_Def)"], ["proof (state)\nthis:\n  V \\<in> Def (targetnode a)\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg e)\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg e)\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg e)\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg e)", "from \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))", "have \"trg e = Node (targetnode a)\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n\ngoal (1 subgoal):\n 1. trg e = Node (targetnode a)", "by simp"], ["proof (state)\nthis:\n  trg e = Node (targetnode a)\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg e)\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg e)\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg e)\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg e)", "with \\<open>V \\<in> Def (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> Def (targetnode a)\n  trg e = Node (targetnode a)", "show ?case"], ["proof (prove)\nusing this:\n  V \\<in> Def (targetnode a)\n  trg e = Node (targetnode a)\n\ngoal (1 subgoal):\n 1. V \\<in> lift_Def Def Entry Exit H L (trg e)", "by(fastforce intro:lift_Def_node)"], ["proof (state)\nthis:\n  V \\<in> lift_Def Def Entry Exit H L (trg e)\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg e)\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg e)\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs; V \\<in> set ins\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Def Def Entry Exit H L (trg e)", "qed simp_all"], ["proof (state)\nthis:\n  V \\<in> lift_Def Def Entry Exit H L (trg a)\n\ngoal (11 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 2. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 3. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 4. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 5. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 6. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 7. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 8. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 9. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 10. \\<And>a Q' p f' ins outs vmap vmap'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n         (p, ins, outs) \\<in> set procs\\<rbrakk>\n        \\<Longrightarrow> f' vmap vmap' =\n                          vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                          map vmap outs)\nA total of 11 subgoals...", "next"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 2. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 3. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 4. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 5. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 6. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 7. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 8. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 9. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 10. \\<And>a Q' p f' ins outs vmap vmap'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n         (p, ins, outs) \\<in> set procs\\<rbrakk>\n        \\<Longrightarrow> f' vmap vmap' =\n                          vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                          map vmap outs)\nA total of 11 subgoals...", "fix a Q r p fs"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 2. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 3. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 4. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 5. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 6. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 7. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 8. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 9. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 10. \\<And>a Q' p f' ins outs vmap vmap'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n         (p, ins, outs) \\<in> set procs\\<rbrakk>\n        \\<Longrightarrow> f' vmap vmap' =\n                          vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                          map vmap outs)\nA total of 11 subgoals...", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (11 subgoals):\n 1. \\<And>a Q r p fs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src a) = {}\n 2. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 3. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 4. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 5. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 6. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 7. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 8. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 9. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 10. \\<And>a Q' p f' ins outs vmap vmap'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n         (p, ins, outs) \\<in> set procs\\<rbrakk>\n        \\<Longrightarrow> f' vmap vmap' =\n                          vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                          map vmap outs)\nA total of 11 subgoals...", "thus \"lift_Def Def Entry Exit H L (src a) = {}\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. lift_Def Def Entry Exit H L (src a) = {}", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src e) = {}\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src e) = {}\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src e) = {}\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src e) = {}", "case (lve_edge a e)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src e) = {}\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src e) = {}\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src e) = {}\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src e) = {}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_Def Def Entry Exit H L (src e) = {}", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. lift_Def Def Entry Exit H L (src e) \\<noteq> {} \\<Longrightarrow> False", "assume \"lift_Def Def Entry Exit H L (src e) \\<noteq> {}\""], ["proof (state)\nthis:\n  lift_Def Def Entry Exit H L (src e) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. lift_Def Def Entry Exit H L (src e) \\<noteq> {} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  lift_Def Def Entry Exit H L (src e) \\<noteq> {}", "obtain x where \"x \\<in> lift_Def Def Entry Exit H L (src e)\""], ["proof (prove)\nusing this:\n  lift_Def Def Entry Exit H L (src e) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> lift_Def Def Entry Exit H L (src e) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> lift_Def Def Entry Exit H L (src e)\n\ngoal (1 subgoal):\n 1. lift_Def Def Entry Exit H L (src e) \\<noteq> {} \\<Longrightarrow> False", "from \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close> \\<open>knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "by simp"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. lift_Def Def Entry Exit H L (src e) \\<noteq> {} \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"Def (sourcenode a) = {}\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. Def (sourcenode a) = {}", "by(rule call_source_Def_empty)"], ["proof (state)\nthis:\n  Def (sourcenode a) = {}\n\ngoal (1 subgoal):\n 1. lift_Def Def Entry Exit H L (src e) \\<noteq> {} \\<Longrightarrow> False", "have \"sourcenode a \\<noteq> Entry\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sourcenode a \\<noteq> Entry", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a = Entry \\<Longrightarrow> False", "assume \"sourcenode a = Entry\""], ["proof (state)\nthis:\n  sourcenode a = Entry\n\ngoal (1 subgoal):\n 1. sourcenode a = Entry \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a = Entry", "show False"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a = Entry\n\ngoal (1 subgoal):\n 1. False", "by(rule Entry_no_call_source)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sourcenode a \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. lift_Def Def Entry Exit H L (src e) \\<noteq> {} \\<Longrightarrow> False", "from \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))", "have \"src e = Node (sourcenode a)\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n\ngoal (1 subgoal):\n 1. src e = Node (sourcenode a)", "by simp"], ["proof (state)\nthis:\n  src e = Node (sourcenode a)\n\ngoal (1 subgoal):\n 1. lift_Def Def Entry Exit H L (src e) \\<noteq> {} \\<Longrightarrow> False", "with \\<open>Def (sourcenode a) = {}\\<close> \\<open>x \\<in> lift_Def Def Entry Exit H L (src e)\\<close>\n          \\<open>sourcenode a \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  Def (sourcenode a) = {}\n  x \\<in> lift_Def Def Entry Exit H L (src e)\n  sourcenode a \\<noteq> Entry\n  src e = Node (sourcenode a)", "show False"], ["proof (prove)\nusing this:\n  Def (sourcenode a) = {}\n  x \\<in> lift_Def Def Entry Exit H L (src e)\n  sourcenode a \\<noteq> Entry\n  src e = Node (sourcenode a)\n\ngoal (1 subgoal):\n 1. False", "by(fastforce elim:lift_Def_set.cases)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lift_Def Def Entry Exit H L (src e) = {}\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src e) = {}\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src e) = {}\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<rbrakk>\n       \\<Longrightarrow> lift_Def Def Entry Exit H L (src e) = {}", "qed simp_all"], ["proof (state)\nthis:\n  lift_Def Def Entry Exit H L (src a) = {}\n\ngoal (10 subgoals):\n 1. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 2. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 3. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 4. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 5. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 6. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 7. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 8. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 9. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 10. \\<And>a a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a';\n         src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n         intra_kind (knd a')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             knd a = (Q)\\<^sub>\\<surd> \\<and>\n                             knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 2. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 3. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 4. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 5. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 6. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 7. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 8. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 9. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 10. \\<And>a a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a';\n         src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n         intra_kind (knd a')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             knd a = (Q)\\<^sub>\\<surd> \\<and>\n                             knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))", "fix n V"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 2. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 3. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 4. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 5. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 6. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 7. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 8. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 9. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 10. \\<And>a a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a';\n         src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n         intra_kind (knd a')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             knd a = (Q)\\<^sub>\\<surd> \\<and>\n                             knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"CFG.CFG.valid_node src trg \n      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) n\"\n      and \"V \\<in> \\<Union>(set (lift_ParamUses ParamUses n))\""], ["proof (state)\nthis:\n  local.CFG.valid_node n\n  V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\n\ngoal (10 subgoals):\n 1. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 2. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 3. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 4. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 5. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 6. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 7. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 8. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 9. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 10. \\<And>a a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a';\n         src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n         intra_kind (knd a')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             knd a = (Q)\\<^sub>\\<surd> \\<and>\n                             knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))", "hence \"((n = NewEntry) \\<or> n = NewExit) \\<or> (\\<exists>m. n = Node m \\<and> valid_node m)\""], ["proof (prove)\nusing this:\n  local.CFG.valid_node n\n  V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\n\ngoal (1 subgoal):\n 1. (n = NewEntry \\<or> n = NewExit) \\<or>\n    (\\<exists>m. n = Node m \\<and> valid_node m)", "by(auto elim:lift_valid_edge.cases simp:CFG.valid_node_def)"], ["proof (state)\nthis:\n  (n = NewEntry \\<or> n = NewExit) \\<or>\n  (\\<exists>m. n = Node m \\<and> valid_node m)\n\ngoal (10 subgoals):\n 1. \\<And>n V.\n       \\<lbrakk>local.CFG.valid_node n;\n        V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 2. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 3. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 4. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 5. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 6. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 7. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 8. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 9. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 10. \\<And>a a'.\n        \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                  Exit a;\n         lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          a';\n         src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n         intra_kind (knd a')\\<rbrakk>\n        \\<Longrightarrow> \\<exists>Q Q'.\n                             knd a = (Q)\\<^sub>\\<surd> \\<and>\n                             knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                             (\\<forall>s.\n                                 (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                 (Q' s \\<longrightarrow> \\<not> Q s))", "thus \"V \\<in> lift_Use Use Entry Exit H L n\""], ["proof (prove)\nusing this:\n  (n = NewEntry \\<or> n = NewExit) \\<or>\n  (\\<exists>m. n = Node m \\<and> valid_node m)\n\ngoal (1 subgoal):\n 1. V \\<in> lift_Use Use Entry Exit H L n", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n = NewEntry \\<or> n = NewExit) \\<or>\n    (\\<exists>m. n = Node m \\<and> valid_node m) \\<Longrightarrow>\n    V \\<in> lift_Use Use Entry Exit H L n", "proof(erule disjE)+"], ["proof (state)\ngoal (3 subgoals):\n 1. n = NewEntry \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 2. n = NewExit \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 3. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    V \\<in> lift_Use Use Entry Exit H L n", "assume \"n = NewEntry\""], ["proof (state)\nthis:\n  n = NewEntry\n\ngoal (3 subgoals):\n 1. n = NewEntry \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 2. n = NewExit \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 3. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    V \\<in> lift_Use Use Entry Exit H L n", "with \\<open>V \\<in> \\<Union>(set (lift_ParamUses ParamUses n))\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\n  n = NewEntry", "show ?thesis"], ["proof (prove)\nusing this:\n  V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\n  n = NewEntry\n\ngoal (1 subgoal):\n 1. V \\<in> lift_Use Use Entry Exit H L n", "by simp"], ["proof (state)\nthis:\n  V \\<in> lift_Use Use Entry Exit H L n\n\ngoal (2 subgoals):\n 1. n = NewExit \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 2. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    V \\<in> lift_Use Use Entry Exit H L n", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. n = NewExit \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 2. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    V \\<in> lift_Use Use Entry Exit H L n", "assume \"n = NewExit\""], ["proof (state)\nthis:\n  n = NewExit\n\ngoal (2 subgoals):\n 1. n = NewExit \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L n\n 2. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    V \\<in> lift_Use Use Entry Exit H L n", "with \\<open>V \\<in> \\<Union>(set (lift_ParamUses ParamUses n))\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\n  n = NewExit", "show ?thesis"], ["proof (prove)\nusing this:\n  V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\n  n = NewExit\n\ngoal (1 subgoal):\n 1. V \\<in> lift_Use Use Entry Exit H L n", "by simp"], ["proof (state)\nthis:\n  V \\<in> lift_Use Use Entry Exit H L n\n\ngoal (1 subgoal):\n 1. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    V \\<in> lift_Use Use Entry Exit H L n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    V \\<in> lift_Use Use Entry Exit H L n", "assume \"\\<exists>m. n = Node m \\<and> valid_node m\""], ["proof (state)\nthis:\n  \\<exists>m. n = Node m \\<and> valid_node m\n\ngoal (1 subgoal):\n 1. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    V \\<in> lift_Use Use Entry Exit H L n", "then"], ["proof (chain)\npicking this:\n  \\<exists>m. n = Node m \\<and> valid_node m", "obtain m where \"n = Node m\" and \"valid_node m\""], ["proof (prove)\nusing this:\n  \\<exists>m. n = Node m \\<and> valid_node m\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>n = Node m; valid_node m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n = Node m\n  valid_node m\n\ngoal (1 subgoal):\n 1. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    V \\<in> lift_Use Use Entry Exit H L n", "from \\<open>V \\<in> \\<Union>(set (lift_ParamUses ParamUses n))\\<close> \\<open>n = Node m\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\n  n = Node m", "have \"V \\<in> \\<Union>(set (ParamUses m))\""], ["proof (prove)\nusing this:\n  V \\<in> \\<Union> (set (lift_ParamUses ParamUses n))\n  n = Node m\n\ngoal (1 subgoal):\n 1. V \\<in> \\<Union> (set (ParamUses m))", "by simp"], ["proof (state)\nthis:\n  V \\<in> \\<Union> (set (ParamUses m))\n\ngoal (1 subgoal):\n 1. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    V \\<in> lift_Use Use Entry Exit H L n", "with \\<open>valid_node m\\<close>"], ["proof (chain)\npicking this:\n  valid_node m\n  V \\<in> \\<Union> (set (ParamUses m))", "have \"V \\<in> Use m\""], ["proof (prove)\nusing this:\n  valid_node m\n  V \\<in> \\<Union> (set (ParamUses m))\n\ngoal (1 subgoal):\n 1. V \\<in> Use m", "by(rule ParamUses_in_Use)"], ["proof (state)\nthis:\n  V \\<in> Use m\n\ngoal (1 subgoal):\n 1. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    V \\<in> lift_Use Use Entry Exit H L n", "with \\<open>n = Node m\\<close>"], ["proof (chain)\npicking this:\n  n = Node m\n  V \\<in> Use m", "show ?thesis"], ["proof (prove)\nusing this:\n  n = Node m\n  V \\<in> Use m\n\ngoal (1 subgoal):\n 1. V \\<in> lift_Use Use Entry Exit H L n", "by(fastforce intro:lift_Use_node)"], ["proof (state)\nthis:\n  V \\<in> lift_Use Use Entry Exit H L n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  V \\<in> lift_Use Use Entry Exit H L n\n\ngoal (9 subgoals):\n 1. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 2. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 4. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 5. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 6. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 7. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 8. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 2. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 4. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 5. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 6. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 7. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 8. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "fix a Q p f ins outs V"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 2. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 4. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 5. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 6. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 7. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 8. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\" and \"(p, ins, outs) \\<in> set procs\" and \"V \\<in> set outs\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set procs\n  V \\<in> set outs\n\ngoal (9 subgoals):\n 1. \\<And>a Q p f ins outs V.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src a)\n 2. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 4. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 5. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 6. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 7. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 8. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 9. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "thus \"V \\<in> lift_Use Use Entry Exit H L (src a)\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set procs\n  V \\<in> set outs\n\ngoal (1 subgoal):\n 1. V \\<in> lift_Use Use Entry Exit H L (src a)", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src e)\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src e)\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src e)\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src e)", "case (lve_edge a e)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set procs\n  V \\<in> set outs\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src e)\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src e)\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src e)\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src e)", "from \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close> \\<open>knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "by simp"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src e)\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src e)\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src e)\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src e)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close> \\<open>(p, ins, outs) \\<in> set procs\\<close> \\<open>V \\<in> set outs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set procs\n  V \\<in> set outs", "have \"V \\<in> Use (sourcenode a)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (p, ins, outs) \\<in> set procs\n  V \\<in> set outs\n\ngoal (1 subgoal):\n 1. V \\<in> Use (sourcenode a)", "by(rule outs_in_Use)"], ["proof (state)\nthis:\n  V \\<in> Use (sourcenode a)\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src e)\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src e)\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src e)\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src e)", "from \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))", "have \"src e = Node (sourcenode a)\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n\ngoal (1 subgoal):\n 1. src e = Node (sourcenode a)", "by simp"], ["proof (state)\nthis:\n  src e = Node (sourcenode a)\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src e)\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src e)\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src e)\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src e)", "with \\<open>V \\<in> Use (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> Use (sourcenode a)\n  src e = Node (sourcenode a)", "show ?case"], ["proof (prove)\nusing this:\n  V \\<in> Use (sourcenode a)\n  src e = Node (sourcenode a)\n\ngoal (1 subgoal):\n 1. V \\<in> lift_Use Use Entry Exit H L (src e)", "by(fastforce intro:lift_Use_node)"], ["proof (state)\nthis:\n  V \\<in> lift_Use Use Entry Exit H L (src e)\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src e)\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src e)\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        (p, ins, outs) \\<in> set procs; V \\<in> set outs\\<rbrakk>\n       \\<Longrightarrow> V \\<in> lift_Use Use Entry Exit H L (src e)", "qed simp_all"], ["proof (state)\nthis:\n  V \\<in> lift_Use Use Entry Exit H L (src a)\n\ngoal (8 subgoals):\n 1. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 4. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 5. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 6. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 7. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 4. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 5. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 6. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 7. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "fix a V s"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 4. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 5. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 6. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 7. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"V \\<notin> lift_Def Def Entry Exit H L (src a)\" and \"intra_kind (knd a)\"\n      and \"pred (knd a) s\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  V \\<notin> lift_Def Def Entry Exit H L (src a)\n  intra_kind (knd a)\n  local.CFG.pred (knd a) s\n\ngoal (8 subgoals):\n 1. \\<And>a V s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        V \\<notin> lift_Def Def Entry Exit H L (src a); intra_kind (knd a);\n        local.CFG.pred (knd a) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd a) s)\n                          V =\n                         local.CFG.state_val s V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 3. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 4. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 5. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 6. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 7. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 8. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "thus \"state_val (transfer (knd a) s) V = state_val s V\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  V \\<notin> lift_Def Def Entry Exit H L (src a)\n  intra_kind (knd a)\n  local.CFG.pred (knd a) s\n\ngoal (1 subgoal):\n 1. local.CFG.state_val (local.CFG.transfer (knd a) s) V =\n    local.CFG.state_val s V", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V", "case (lve_edge a e)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  V \\<notin> lift_Def Def Entry Exit H L (src e)\n  intra_kind (knd e)\n  local.CFG.pred (knd e) s\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V", "from \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close> \n        \\<open>intra_kind (knd e)\\<close> \\<open>pred (knd e) s\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  intra_kind (knd e)\n  local.CFG.pred (knd e) s", "have \"intra_kind (kind a)\" and \"pred (kind a) s\" \n        and \"knd e = kind a\" and \"src e = Node (sourcenode a)\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  intra_kind (knd e)\n  local.CFG.pred (knd e) s\n\ngoal (1 subgoal):\n 1. (intra_kind (kind a) &&& local.CFG.pred (kind a) s) &&&\n    knd e = kind a &&& src e = Node (sourcenode a)", "by simp_all"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  local.CFG.pred (kind a) s\n  knd e = kind a\n  src e = Node (sourcenode a)\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V", "from \\<open>V \\<notin> lift_Def Def Entry Exit H L (src e)\\<close> \\<open>src e = Node (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  V \\<notin> lift_Def Def Entry Exit H L (src e)\n  src e = Node (sourcenode a)", "have \"V \\<notin> Def (sourcenode a)\""], ["proof (prove)\nusing this:\n  V \\<notin> lift_Def Def Entry Exit H L (src e)\n  src e = Node (sourcenode a)\n\ngoal (1 subgoal):\n 1. V \\<notin> Def (sourcenode a)", "by (auto dest: lift_Def_node)"], ["proof (state)\nthis:\n  V \\<notin> Def (sourcenode a)\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V", "from \\<open>valid_edge a\\<close> \\<open>V \\<notin> Def (sourcenode a)\\<close> \\<open>intra_kind (kind a)\\<close> \n        \\<open>pred (kind a) s\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  V \\<notin> Def (sourcenode a)\n  intra_kind (kind a)\n  local.CFG.pred (kind a) s", "have \"state_val (transfer (kind a) s) V = state_val s V\""], ["proof (prove)\nusing this:\n  valid_edge a\n  V \\<notin> Def (sourcenode a)\n  intra_kind (kind a)\n  local.CFG.pred (kind a) s\n\ngoal (1 subgoal):\n 1. local.CFG.state_val (local.CFG.transfer (kind a) s) V =\n    local.CFG.state_val s V", "by(rule CFG_intra_edge_no_Def_equal)"], ["proof (state)\nthis:\n  local.CFG.state_val (local.CFG.transfer (kind a) s) V =\n  local.CFG.state_val s V\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V", "with \\<open>knd e = kind a\\<close>"], ["proof (chain)\npicking this:\n  knd e = kind a\n  local.CFG.state_val (local.CFG.transfer (kind a) s) V =\n  local.CFG.state_val s V", "show ?case"], ["proof (prove)\nusing this:\n  knd e = kind a\n  local.CFG.state_val (local.CFG.transfer (kind a) s) V =\n  local.CFG.state_val s V\n\ngoal (1 subgoal):\n 1. local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val s V", "by simp"], ["proof (state)\nthis:\n  local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n  local.CFG.state_val s V\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V", "case (lve_Entry_edge e)"], ["proof (state)\nthis:\n  e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n  V \\<notin> lift_Def Def Entry Exit H L (src e)\n  intra_kind (knd e)\n  local.CFG.pred (knd e) s\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V", "from \\<open>e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\\<close> \\<open>pred (knd e) s\\<close>"], ["proof (chain)\npicking this:\n  e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n  local.CFG.pred (knd e) s", "show ?case"], ["proof (prove)\nusing this:\n  e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n  local.CFG.pred (knd e) s\n\ngoal (1 subgoal):\n 1. local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val s V", "by(cases s) auto"], ["proof (state)\nthis:\n  local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n  local.CFG.state_val s V\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V\n 2. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V\n 2. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V", "case (lve_Exit_edge e)"], ["proof (state)\nthis:\n  e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n  V \\<notin> lift_Def Def Entry Exit H L (src e)\n  intra_kind (knd e)\n  local.CFG.pred (knd e) s\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V\n 2. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V", "from \\<open>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<close> \\<open>pred (knd e) s\\<close>"], ["proof (chain)\npicking this:\n  e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n  local.CFG.pred (knd e) s", "show ?case"], ["proof (prove)\nusing this:\n  e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n  local.CFG.pred (knd e) s\n\ngoal (1 subgoal):\n 1. local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val s V", "by(cases s) auto"], ["proof (state)\nthis:\n  local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n  local.CFG.state_val s V\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V", "case (lve_Entry_Exit_edge e)"], ["proof (state)\nthis:\n  e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n  V \\<notin> lift_Def Def Entry Exit H L (src e)\n  intra_kind (knd e)\n  local.CFG.pred (knd e) s\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V", "from \\<open>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\\<close> \\<open>pred (knd e) s\\<close>"], ["proof (chain)\npicking this:\n  e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n  local.CFG.pred (knd e) s", "have False"], ["proof (prove)\nusing this:\n  e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n  local.CFG.pred (knd e) s\n\ngoal (1 subgoal):\n 1. False", "by(cases s) auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        V \\<notin> lift_Def Def Entry Exit H L (src e); intra_kind (knd e);\n        local.CFG.pred (knd e) s\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val s V", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val s V", "by simp"], ["proof (state)\nthis:\n  local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n  local.CFG.state_val s V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.CFG.state_val (local.CFG.transfer (knd a) s) V =\n  local.CFG.state_val s V\n\ngoal (7 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 3. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 6. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 3. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 6. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "fix a s s'"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 3. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 6. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "assume assms:\"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      \"\\<forall>V\\<in>lift_Use Use Entry Exit H L (src a). state_val s V = state_val s' V\"\n      \"intra_kind (knd a)\" \"pred (knd a) s\" \"pred (knd a) s'\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  intra_kind (knd a)\n  local.CFG.pred (knd a) s\n  local.CFG.pred (knd a) s'\n\ngoal (7 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd a); local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s'\\<rbrakk>\n       \\<Longrightarrow> \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s) V =\n                            local.CFG.state_val\n                             (local.CFG.transfer (knd a) s') V\n 2. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 3. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 5. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 6. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 7. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "show \"\\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n      state_val (transfer (knd a) s) V = state_val (transfer (knd a) s') V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n       local.CFG.state_val (local.CFG.transfer (knd a) s) V =\n       local.CFG.state_val (local.CFG.transfer (knd a) s') V", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> lift_Def Def Entry Exit H L (src a) \\<Longrightarrow>\n       local.CFG.state_val (local.CFG.transfer (knd a) s) V =\n       local.CFG.state_val (local.CFG.transfer (knd a) s') V", "fix V"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> lift_Def Def Entry Exit H L (src a) \\<Longrightarrow>\n       local.CFG.state_val (local.CFG.transfer (knd a) s) V =\n       local.CFG.state_val (local.CFG.transfer (knd a) s') V", "assume \"V \\<in> lift_Def Def Entry Exit H L (src a)\""], ["proof (state)\nthis:\n  V \\<in> lift_Def Def Entry Exit H L (src a)\n\ngoal (1 subgoal):\n 1. \\<And>V.\n       V \\<in> lift_Def Def Entry Exit H L (src a) \\<Longrightarrow>\n       local.CFG.state_val (local.CFG.transfer (knd a) s) V =\n       local.CFG.state_val (local.CFG.transfer (knd a) s') V", "with assms"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  intra_kind (knd a)\n  local.CFG.pred (knd a) s\n  local.CFG.pred (knd a) s'\n  V \\<in> lift_Def Def Entry Exit H L (src a)", "show \"state_val (transfer (knd a) s) V = state_val (transfer (knd a) s') V\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  intra_kind (knd a)\n  local.CFG.pred (knd a) s\n  local.CFG.pred (knd a) s'\n  V \\<in> lift_Def Def Entry Exit H L (src a)\n\ngoal (1 subgoal):\n 1. local.CFG.state_val (local.CFG.transfer (knd a) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd a) s') V", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V", "case (lve_edge a e)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  intra_kind (knd e)\n  local.CFG.pred (knd e) s\n  local.CFG.pred (knd e) s'\n  V \\<in> lift_Def Def Entry Exit H L (src e)\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V", "from \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>\n          \\<open>intra_kind (knd e)\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  intra_kind (knd e)", "have \"intra_kind (kind a)\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  intra_kind (knd e)\n\ngoal (1 subgoal):\n 1. intra_kind (kind a)", "by simp"], ["proof (state)\nthis:\n  intra_kind (kind a)\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "proof (cases \"Node (sourcenode a) = Node Entry\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Node (sourcenode a) = Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V\n 2. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "case True"], ["proof (state)\nthis:\n  Node (sourcenode a) = Node Entry\n\ngoal (2 subgoals):\n 1. Node (sourcenode a) = Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V\n 2. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "hence \"sourcenode a = Entry\""], ["proof (prove)\nusing this:\n  Node (sourcenode a) = Node Entry\n\ngoal (1 subgoal):\n 1. sourcenode a = Entry", "by simp"], ["proof (state)\nthis:\n  sourcenode a = Entry\n\ngoal (2 subgoals):\n 1. Node (sourcenode a) = Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V\n 2. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "from Entry_Exit_edge"], ["proof (chain)\npicking this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = Entry \\<and>\n     targetnode a = Exit \\<and> kind a = (\\<lambda>s. False)\\<^sub>\\<surd>", "obtain a' where \"valid_edge a'\"\n            and \"sourcenode a' = Entry\" and \"targetnode a' = Exit\"\n            and \"kind a' = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\nusing this:\n  \\<exists>a.\n     valid_edge a \\<and>\n     sourcenode a = Entry \\<and>\n     targetnode a = Exit \\<and> kind a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. (\\<And>a'.\n        \\<lbrakk>valid_edge a'; sourcenode a' = Entry; targetnode a' = Exit;\n         kind a' = (\\<lambda>s. False)\\<^sub>\\<surd>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  valid_edge a'\n  sourcenode a' = Entry\n  targetnode a' = Exit\n  kind a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. Node (sourcenode a) = Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V\n 2. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "have \"\\<exists>Q. kind a = (Q)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>", "proof(cases \"targetnode a = Exit\")"], ["proof (state)\ngoal (2 subgoals):\n 1. targetnode a = Exit \\<Longrightarrow>\n    \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>\n 2. targetnode a \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>", "case True"], ["proof (state)\nthis:\n  targetnode a = Exit\n\ngoal (2 subgoals):\n 1. targetnode a = Exit \\<Longrightarrow>\n    \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>\n 2. targetnode a \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>", "with \\<open>valid_edge a\\<close> \\<open>valid_edge a'\\<close> \\<open>sourcenode a = Entry\\<close>\n              \\<open>sourcenode a' = Entry\\<close> \\<open>targetnode a' = Exit\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge a'\n  sourcenode a = Entry\n  sourcenode a' = Entry\n  targetnode a' = Exit\n  targetnode a = Exit", "have \"a = a'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge a'\n  sourcenode a = Entry\n  sourcenode a' = Entry\n  targetnode a' = Exit\n  targetnode a = Exit\n\ngoal (1 subgoal):\n 1. a = a'", "by(fastforce dest:edge_det)"], ["proof (state)\nthis:\n  a = a'\n\ngoal (2 subgoals):\n 1. targetnode a = Exit \\<Longrightarrow>\n    \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>\n 2. targetnode a \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>", "with \\<open>kind a' = (\\<lambda>s. False)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  kind a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n  a = a'", "show ?thesis"], ["proof (prove)\nusing this:\n  kind a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n  a = a'\n\ngoal (1 subgoal):\n 1. \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>", "case False"], ["proof (state)\nthis:\n  targetnode a \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> Exit \\<Longrightarrow>\n    \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>", "with \\<open>valid_edge a\\<close> \\<open>valid_edge a'\\<close> \\<open>sourcenode a = Entry\\<close>\n              \\<open>sourcenode a' = Entry\\<close> \\<open>targetnode a' = Exit\\<close>\n              \\<open>intra_kind (kind a)\\<close> \\<open>kind a' = (\\<lambda>s. False)\\<^sub>\\<surd>\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  valid_edge a'\n  sourcenode a = Entry\n  sourcenode a' = Entry\n  targetnode a' = Exit\n  intra_kind (kind a)\n  kind a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n  targetnode a \\<noteq> Exit", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_edge a\n  valid_edge a'\n  sourcenode a = Entry\n  sourcenode a' = Entry\n  targetnode a' = Exit\n  intra_kind (kind a)\n  kind a' = (\\<lambda>s. False)\\<^sub>\\<surd>\n  targetnode a \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>", "by(auto dest:deterministic simp:intra_kind_def)"], ["proof (state)\nthis:\n  \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>\n\ngoal (2 subgoals):\n 1. Node (sourcenode a) = Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V\n 2. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "from True \\<open>V \\<in> lift_Def Def Entry Exit H L (src e)\\<close> Entry_empty\n            \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  Node (sourcenode a) = Node Entry\n  V \\<in> lift_Def Def Entry Exit H L (src e)\n  Def Entry = {} \\<and> Use Entry = {}\n  e = (Node (sourcenode a), kind a, Node (targetnode a))", "have \"V \\<in> H\""], ["proof (prove)\nusing this:\n  Node (sourcenode a) = Node Entry\n  V \\<in> lift_Def Def Entry Exit H L (src e)\n  Def Entry = {} \\<and> Use Entry = {}\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n\ngoal (1 subgoal):\n 1. V \\<in> H", "by(fastforce elim:lift_Def_set.cases)"], ["proof (state)\nthis:\n  V \\<in> H\n\ngoal (2 subgoals):\n 1. Node (sourcenode a) = Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V\n 2. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "from True \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>\n            \\<open>sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit\\<close>"], ["proof (chain)\npicking this:\n  Node (sourcenode a) = Node Entry\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit", "have \"\\<forall>V\\<in>H. V \\<in> lift_Use Use Entry Exit H L (src e)\""], ["proof (prove)\nusing this:\n  Node (sourcenode a) = Node Entry\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>H. V \\<in> lift_Use Use Entry Exit H L (src e)", "by(fastforce intro:lift_Use_High)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>H. V \\<in> lift_Use Use Entry Exit H L (src e)\n\ngoal (2 subgoals):\n 1. Node (sourcenode a) = Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V\n 2. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "with \\<open>\\<forall>V\\<in>lift_Use Use Entry Exit H L (src e). \n            state_val s V = state_val s' V\\<close> \\<open>V \\<in> H\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  V \\<in> H\n  \\<forall>V\\<in>H. V \\<in> lift_Use Use Entry Exit H L (src e)", "have \"state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  V \\<in> H\n  \\<forall>V\\<in>H. V \\<in> lift_Use Use Entry Exit H L (src e)\n\ngoal (1 subgoal):\n 1. local.CFG.state_val s V = local.CFG.state_val s' V", "by simp"], ["proof (state)\nthis:\n  local.CFG.state_val s V = local.CFG.state_val s' V\n\ngoal (2 subgoals):\n 1. Node (sourcenode a) = Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V\n 2. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "with \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close> \n            \\<open>\\<exists>Q. kind a = (Q)\\<^sub>\\<surd>\\<close> \\<open>pred (knd e) s\\<close> \\<open>pred (knd e) s'\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>\n  local.CFG.pred (knd e) s\n  local.CFG.pred (knd e) s'\n  local.CFG.state_val s V = local.CFG.state_val s' V", "show ?thesis"], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  \\<exists>Q. kind a = (Q)\\<^sub>\\<surd>\n  local.CFG.pred (knd e) s\n  local.CFG.pred (knd e) s'\n  local.CFG.state_val s V = local.CFG.state_val s' V\n\ngoal (1 subgoal):\n 1. local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "by(cases s,auto,cases s',auto)"], ["proof (state)\nthis:\n  local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n  local.CFG.state_val (local.CFG.transfer (knd e) s') V\n\ngoal (1 subgoal):\n 1. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "case False"], ["proof (state)\nthis:\n  Node (sourcenode a) \\<noteq> Node Entry\n\ngoal (1 subgoal):\n 1. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "{"], ["proof (state)\nthis:\n  Node (sourcenode a) \\<noteq> Node Entry\n\ngoal (1 subgoal):\n 1. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "fix V'"], ["proof (state)\ngoal (1 subgoal):\n 1. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "assume \"V' \\<in> Use (sourcenode a)\""], ["proof (state)\nthis:\n  V' \\<in> Use (sourcenode a)\n\ngoal (1 subgoal):\n 1. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "with \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  V' \\<in> Use (sourcenode a)", "have \"V' \\<in> lift_Use Use Entry Exit H L (src e)\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  V' \\<in> Use (sourcenode a)\n\ngoal (1 subgoal):\n 1. V' \\<in> lift_Use Use Entry Exit H L (src e)", "by(fastforce intro:lift_Use_node)"], ["proof (state)\nthis:\n  V' \\<in> lift_Use Use Entry Exit H L (src e)\n\ngoal (1 subgoal):\n 1. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "}"], ["proof (state)\nthis:\n  ?V'2 \\<in> Use (sourcenode a) \\<Longrightarrow>\n  ?V'2 \\<in> lift_Use Use Entry Exit H L (src e)\n\ngoal (1 subgoal):\n 1. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "with \\<open>\\<forall>V\\<in>lift_Use Use Entry Exit H L (src e). \n            state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  ?V'2 \\<in> Use (sourcenode a) \\<Longrightarrow>\n  ?V'2 \\<in> lift_Use Use Entry Exit H L (src e)", "have \"\\<forall>V\\<in>Use (sourcenode a). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  ?V'2 \\<in> Use (sourcenode a) \\<Longrightarrow>\n  ?V'2 \\<in> lift_Use Use Entry Exit H L (src e)\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (sourcenode a).\n       local.CFG.state_val s V = local.CFG.state_val s' V", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (sourcenode a).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n\ngoal (1 subgoal):\n 1. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "from \\<open>valid_edge a\\<close> this \\<open>pred (knd e) s\\<close> \\<open>pred (knd e) s'\\<close>\n            \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>\n            \\<open>intra_kind (knd e)\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  \\<forall>V\\<in>Use (sourcenode a).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  local.CFG.pred (knd e) s\n  local.CFG.pred (knd e) s'\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  intra_kind (knd e)", "have \"\\<forall>V \\<in> Def (sourcenode a). state_val (transfer (kind a) s) V =\n            state_val (transfer (kind a) s') V\""], ["proof (prove)\nusing this:\n  valid_edge a\n  \\<forall>V\\<in>Use (sourcenode a).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  local.CFG.pred (knd e) s\n  local.CFG.pred (knd e) s'\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  intra_kind (knd e)\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Def (sourcenode a).\n       local.CFG.state_val (local.CFG.transfer (kind a) s) V =\n       local.CFG.state_val (local.CFG.transfer (kind a) s') V", "by -(erule CFG_intra_edge_transfer_uses_only_Use,auto)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Def (sourcenode a).\n     local.CFG.state_val (local.CFG.transfer (kind a) s) V =\n     local.CFG.state_val (local.CFG.transfer (kind a) s') V\n\ngoal (1 subgoal):\n 1. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "from \\<open>V \\<in> lift_Def Def Entry Exit H L (src e)\\<close> False\n            \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> lift_Def Def Entry Exit H L (src e)\n  Node (sourcenode a) \\<noteq> Node Entry\n  e = (Node (sourcenode a), kind a, Node (targetnode a))", "have \"V \\<in> Def (sourcenode a)\""], ["proof (prove)\nusing this:\n  V \\<in> lift_Def Def Entry Exit H L (src e)\n  Node (sourcenode a) \\<noteq> Node Entry\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n\ngoal (1 subgoal):\n 1. V \\<in> Def (sourcenode a)", "by(fastforce elim:lift_Def_set.cases)"], ["proof (state)\nthis:\n  V \\<in> Def (sourcenode a)\n\ngoal (1 subgoal):\n 1. Node (sourcenode a) \\<noteq> Node Entry \\<Longrightarrow>\n    local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "with \\<open>\\<forall>V \\<in> Def (sourcenode a). state_val (transfer (kind a) s) V =\n            state_val (transfer (kind a) s') V\\<close>\n            \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>Def (sourcenode a).\n     local.CFG.state_val (local.CFG.transfer (kind a) s) V =\n     local.CFG.state_val (local.CFG.transfer (kind a) s') V\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  V \\<in> Def (sourcenode a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>Def (sourcenode a).\n     local.CFG.state_val (local.CFG.transfer (kind a) s) V =\n     local.CFG.state_val (local.CFG.transfer (kind a) s') V\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  V \\<in> Def (sourcenode a)\n\ngoal (1 subgoal):\n 1. local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "by simp"], ["proof (state)\nthis:\n  local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n  local.CFG.state_val (local.CFG.transfer (knd e) s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n  local.CFG.state_val (local.CFG.transfer (knd e) s') V\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V", "case (lve_Entry_edge e)"], ["proof (state)\nthis:\n  e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  intra_kind (knd e)\n  local.CFG.pred (knd e) s\n  local.CFG.pred (knd e) s'\n  V \\<in> lift_Def Def Entry Exit H L (src e)\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V", "from \\<open>V \\<in> lift_Def Def Entry Exit H L (src e)\\<close> \n          \\<open>e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> lift_Def Def Entry Exit H L (src e)\n  e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)", "have False"], ["proof (prove)\nusing this:\n  V \\<in> lift_Def Def Entry Exit H L (src e)\n  e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n\ngoal (1 subgoal):\n 1. False", "by(fastforce elim:lift_Def_set.cases)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "by simp"], ["proof (state)\nthis:\n  local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n  local.CFG.state_val (local.CFG.transfer (knd e) s') V\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V\n 2. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V\n 2. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V", "case (lve_Exit_edge e)"], ["proof (state)\nthis:\n  e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  intra_kind (knd e)\n  local.CFG.pred (knd e) s\n  local.CFG.pred (knd e) s'\n  V \\<in> lift_Def Def Entry Exit H L (src e)\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V\n 2. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V", "from \\<open>V \\<in> lift_Def Def Entry Exit H L (src e)\\<close> \n          \\<open>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<close>"], ["proof (chain)\npicking this:\n  V \\<in> lift_Def Def Entry Exit H L (src e)\n  e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)", "have False"], ["proof (prove)\nusing this:\n  V \\<in> lift_Def Def Entry Exit H L (src e)\n  e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n\ngoal (1 subgoal):\n 1. False", "by(fastforce elim:lift_Def_set.cases intro!:Entry_noteq_Exit simp:Exit_empty)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V\n 2. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "by simp"], ["proof (state)\nthis:\n  local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n  local.CFG.state_val (local.CFG.transfer (knd e) s') V\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V", "case (lve_Entry_Exit_edge e)"], ["proof (state)\nthis:\n  e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  intra_kind (knd e)\n  local.CFG.pred (knd e) s\n  local.CFG.pred (knd e) s'\n  V \\<in> lift_Def Def Entry Exit H L (src e)\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        intra_kind (knd e); local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        V \\<in> lift_Def Def Entry Exit H L (src e)\\<rbrakk>\n       \\<Longrightarrow> local.CFG.state_val (local.CFG.transfer (knd e) s)\n                          V =\n                         local.CFG.state_val (local.CFG.transfer (knd e) s')\n                          V", "thus ?case"], ["proof (prove)\nusing this:\n  e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  intra_kind (knd e)\n  local.CFG.pred (knd e) s\n  local.CFG.pred (knd e) s'\n  V \\<in> lift_Def Def Entry Exit H L (src e)\n\ngoal (1 subgoal):\n 1. local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n    local.CFG.state_val (local.CFG.transfer (knd e) s') V", "by(cases s) auto"], ["proof (state)\nthis:\n  local.CFG.state_val (local.CFG.transfer (knd e) s) V =\n  local.CFG.state_val (local.CFG.transfer (knd e) s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.CFG.state_val (local.CFG.transfer (knd a) s) V =\n  local.CFG.state_val (local.CFG.transfer (knd a) s') V\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>V\\<in>lift_Def Def Entry Exit H L (src a).\n     local.CFG.state_val (local.CFG.transfer (knd a) s) V =\n     local.CFG.state_val (local.CFG.transfer (knd a) s') V\n\ngoal (6 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 2. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 5. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 2. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 5. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "fix a s s'"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 2. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 5. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"pred (knd a) s\" and \"snd (hd s) = snd (hd s')\"\n      and \"\\<forall>V\\<in>lift_Use Use Entry Exit H L (src a). state_val s V = state_val s' V\"\n      and \"length s = length s'\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  local.CFG.pred (knd a) s\n  snd (hd s) = snd (hd s')\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  length s = length s'\n\ngoal (6 subgoals):\n 1. \\<And>a s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        local.CFG.pred (knd a) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd a) s'\n 2. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 4. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 5. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 6. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "thus \"pred (knd a) s'\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  local.CFG.pred (knd a) s\n  snd (hd s) = snd (hd s')\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src a).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  length s = length s'\n\ngoal (1 subgoal):\n 1. local.CFG.pred (knd a) s'", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'", "case (lve_edge a e)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  local.CFG.pred (knd e) s\n  snd (hd s) = snd (hd s')\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  length s = length s'\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'", "from \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close> \\<open>pred (knd e) s\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  local.CFG.pred (knd e) s", "have \"pred (kind a) s\" and \"src e = Node (sourcenode a)\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  local.CFG.pred (knd e) s\n\ngoal (1 subgoal):\n 1. local.CFG.pred (kind a) s &&& src e = Node (sourcenode a)", "by simp_all"], ["proof (state)\nthis:\n  local.CFG.pred (kind a) s\n  src e = Node (sourcenode a)\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'", "from \\<open>src e = Node (sourcenode a)\\<close> \n        \\<open>\\<forall>V\\<in>lift_Use Use Entry Exit H L (src e). state_val s V = state_val s' V\\<close>"], ["proof (chain)\npicking this:\n  src e = Node (sourcenode a)\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     local.CFG.state_val s V = local.CFG.state_val s' V", "have \"\\<forall>V \\<in> Use (sourcenode a). state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  src e = Node (sourcenode a)\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>Use (sourcenode a).\n       local.CFG.state_val s V = local.CFG.state_val s' V", "by(auto dest:lift_Use_node)"], ["proof (state)\nthis:\n  \\<forall>V\\<in>Use (sourcenode a).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'", "from \\<open>valid_edge a\\<close> \\<open>pred (kind a) s\\<close> \\<open>snd (hd s) = snd (hd s')\\<close>\n        this \\<open>length s = length s'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  local.CFG.pred (kind a) s\n  snd (hd s) = snd (hd s')\n  \\<forall>V\\<in>Use (sourcenode a).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  length s = length s'", "have \"pred (kind a) s'\""], ["proof (prove)\nusing this:\n  valid_edge a\n  local.CFG.pred (kind a) s\n  snd (hd s) = snd (hd s')\n  \\<forall>V\\<in>Use (sourcenode a).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  length s = length s'\n\ngoal (1 subgoal):\n 1. local.CFG.pred (kind a) s'", "by(rule CFG_edge_Uses_pred_equal)"], ["proof (state)\nthis:\n  local.CFG.pred (kind a) s'\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'", "with \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  local.CFG.pred (kind a) s'", "show ?case"], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  local.CFG.pred (kind a) s'\n\ngoal (1 subgoal):\n 1. local.CFG.pred (knd e) s'", "by simp"], ["proof (state)\nthis:\n  local.CFG.pred (knd e) s'\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'", "case (lve_Entry_edge e)"], ["proof (state)\nthis:\n  e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n  local.CFG.pred (knd e) s\n  snd (hd s) = snd (hd s')\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  length s = length s'\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'", "thus ?case"], ["proof (prove)\nusing this:\n  e = (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n  local.CFG.pred (knd e) s\n  snd (hd s) = snd (hd s')\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  length s = length s'\n\ngoal (1 subgoal):\n 1. local.CFG.pred (knd e) s'", "by(cases s') auto"], ["proof (state)\nthis:\n  local.CFG.pred (knd e) s'\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'\n 2. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'\n 2. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'", "case (lve_Exit_edge e)"], ["proof (state)\nthis:\n  e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n  local.CFG.pred (knd e) s\n  snd (hd s) = snd (hd s')\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  length s = length s'\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'\n 2. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'", "thus ?case"], ["proof (prove)\nusing this:\n  e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n  local.CFG.pred (knd e) s\n  snd (hd s) = snd (hd s')\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  length s = length s'\n\ngoal (1 subgoal):\n 1. local.CFG.pred (knd e) s'", "by(cases s') auto"], ["proof (state)\nthis:\n  local.CFG.pred (knd e) s'\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'", "case (lve_Entry_Exit_edge e)"], ["proof (state)\nthis:\n  e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n  local.CFG.pred (knd e) s\n  snd (hd s) = snd (hd s')\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  length s = length s'\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        local.CFG.pred (knd e) s; snd (hd s) = snd (hd s');\n        \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n           local.CFG.state_val s V = local.CFG.state_val s' V;\n        length s = length s'\\<rbrakk>\n       \\<Longrightarrow> local.CFG.pred (knd e) s'", "thus ?case"], ["proof (prove)\nusing this:\n  e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n  local.CFG.pred (knd e) s\n  snd (hd s) = snd (hd s')\n  \\<forall>V\\<in>lift_Use Use Entry Exit H L (src e).\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  length s = length s'\n\ngoal (1 subgoal):\n 1. local.CFG.pred (knd e) s'", "by(cases s) auto"], ["proof (state)\nthis:\n  local.CFG.pred (knd e) s'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.CFG.pred (knd a) s'\n\ngoal (5 subgoals):\n 1. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 4. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 4. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "fix a Q r p fs ins outs"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 4. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"(p, ins, outs) \\<in> set procs\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n\ngoal (5 subgoals):\n 1. \\<And>a Q r p fs ins outs.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 3. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 4. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 5. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "thus \"length fs = length ins\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. length fs = length ins", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins", "case (lve_edge a e)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins", "from \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close> \\<open>knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "by simp"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>(p, ins, outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs", "show ?case"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. length fs = length ins", "by(rule CFG_call_edge_length)"], ["proof (state)\nthis:\n  length fs = length ins\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> length fs = length ins", "qed simp_all"], ["proof (state)\nthis:\n  length fs = length ins\n\ngoal (4 subgoals):\n 1. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 3. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 3. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "fix a Q r p fs a' Q' r' p' fs' s s'"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 3. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\"\n      and \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\"\n      and \"src a = src a'\" and \"pred (knd a) s\" and \"pred (knd a') s\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src a = src a'\n  local.CFG.pred (knd a) s\n  local.CFG.pred (knd a') s\n\ngoal (4 subgoals):\n 1. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 3. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\\<close>\n      \\<open>knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>pred (knd a) s\\<close>"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  local.CFG.pred (knd a) s", "obtain x where a:\"a = (Node (sourcenode x),kind x,Node (targetnode x))\" \n      and \"valid_edge x\" and \"src a = Node (sourcenode x)\" \n      and \"kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"pred (kind x) s\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  local.CFG.pred (knd a) s\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>a = (Node (sourcenode x), kind x, Node (targetnode x));\n         valid_edge x; src a = Node (sourcenode x);\n         kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n         local.CFG.pred (kind x) s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  a = (Node (sourcenode x), kind x, Node (targetnode x))\n  valid_edge x\n  src a = Node (sourcenode x)\n  kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  local.CFG.pred (kind x) s\n\ngoal (4 subgoals):\n 1. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 3. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\\<close>\n      \\<open>knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<close> \\<open>pred (knd a') s\\<close>"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  local.CFG.pred (knd a') s", "obtain x' where a':\"a' = (Node (sourcenode x'),kind x',Node (targetnode x'))\" \n      and \"valid_edge x'\" and \"src a' = Node (sourcenode x')\" \n      and \"kind x' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\" and \"pred (kind x') s\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  local.CFG.pred (knd a') s\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>a' = (Node (sourcenode x'), kind x', Node (targetnode x'));\n         valid_edge x'; src a' = Node (sourcenode x');\n         kind x' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n         local.CFG.pred (kind x') s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  a' = (Node (sourcenode x'), kind x', Node (targetnode x'))\n  valid_edge x'\n  src a' = Node (sourcenode x')\n  kind x' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  local.CFG.pred (kind x') s\n\ngoal (4 subgoals):\n 1. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 3. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>src a = Node (sourcenode x)\\<close> \\<open>src a' = Node (sourcenode x')\\<close> \n      \\<open>src a = src a'\\<close>"], ["proof (chain)\npicking this:\n  src a = Node (sourcenode x)\n  src a' = Node (sourcenode x')\n  src a = src a'", "have \"sourcenode x = sourcenode x'\""], ["proof (prove)\nusing this:\n  src a = Node (sourcenode x)\n  src a' = Node (sourcenode x')\n  src a = src a'\n\ngoal (1 subgoal):\n 1. sourcenode x = sourcenode x'", "by simp"], ["proof (state)\nthis:\n  sourcenode x = sourcenode x'\n\ngoal (4 subgoals):\n 1. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 3. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>valid_edge x\\<close> \\<open>kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>valid_edge x'\\<close> \\<open>kind x' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\\<close>\n      \\<open>sourcenode x = sourcenode x'\\<close> \\<open>pred (kind x) s\\<close> \\<open>pred (kind x') s\\<close>"], ["proof (chain)\npicking this:\n  valid_edge x\n  kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge x'\n  kind x' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  sourcenode x = sourcenode x'\n  local.CFG.pred (kind x) s\n  local.CFG.pred (kind x') s", "have \"x = x'\""], ["proof (prove)\nusing this:\n  valid_edge x\n  kind x = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_edge x'\n  kind x' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs'\n  sourcenode x = sourcenode x'\n  local.CFG.pred (kind x) s\n  local.CFG.pred (kind x') s\n\ngoal (1 subgoal):\n 1. x = x'", "by(rule CFG_call_determ)"], ["proof (state)\nthis:\n  x = x'\n\ngoal (4 subgoals):\n 1. \\<And>a Q r p fs a' Q' r' p' fs' s.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        knd a' = Q':r'\\<hookrightarrow>\\<^bsub>p'\\<^esub>fs';\n        src a = src a'; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a') s\\<rbrakk>\n       \\<Longrightarrow> a = a'\n 2. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 3. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 4. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "with a a'"], ["proof (chain)\npicking this:\n  a = (Node (sourcenode x), kind x, Node (targetnode x))\n  a' = (Node (sourcenode x'), kind x', Node (targetnode x'))\n  x = x'", "show \"a = a'\""], ["proof (prove)\nusing this:\n  a = (Node (sourcenode x), kind x, Node (targetnode x))\n  a' = (Node (sourcenode x'), kind x', Node (targetnode x'))\n  x = x'\n\ngoal (1 subgoal):\n 1. a = a'", "by simp"], ["proof (state)\nthis:\n  a = a'\n\ngoal (3 subgoals):\n 1. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 2. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 2. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "fix a Q r p fs i ins outs s s'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 2. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"i < length ins\" and \"(p, ins, outs) \\<in> set procs\"\n      and \"pred (knd a) s\" and \"pred (knd a) s'\"\n      and \"\\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i. state_val s V = state_val s' V\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  i < length ins\n  (p, ins, outs) \\<in> set procs\n  local.CFG.pred (knd a) s\n  local.CFG.pred (knd a) s'\n  \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n     local.CFG.state_val s V = local.CFG.state_val s' V\n\ngoal (3 subgoals):\n 1. \\<And>a Q r p fs i ins outs s s'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd a) s;\n        local.CFG.pred (knd a) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 2. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 3. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "thus \"params fs (state_val s) ! i = CFG.params fs (state_val s') ! i\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  i < length ins\n  (p, ins, outs) \\<in> set procs\n  local.CFG.pred (knd a) s\n  local.CFG.pred (knd a) s'\n  \\<forall>V\\<in>lift_ParamUses ParamUses (src a) ! i.\n     local.CFG.state_val s V = local.CFG.state_val s' V\n\ngoal (1 subgoal):\n 1. local.CFG.params fs (local.CFG.state_val s) ! i =\n    local.CFG.params fs (local.CFG.state_val s') ! i", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src e) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src e) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src e) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src e) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i", "case (lve_edge a e)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  i < length ins\n  (p, ins, outs) \\<in> set procs\n  local.CFG.pred (knd e) s\n  local.CFG.pred (knd e) s'\n  \\<forall>V\\<in>lift_ParamUses ParamUses (src e) ! i.\n     local.CFG.state_val s V = local.CFG.state_val s' V\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src e) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src e) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src e) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src e) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i", "from \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close> \\<open>knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>\n        \\<open>pred (knd e) s\\<close> \\<open>pred (knd e) s'\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  local.CFG.pred (knd e) s\n  local.CFG.pred (knd e) s'", "have \"kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\" and \"pred (kind a) s\" and \"pred (kind a) s'\"\n        and \"src e = Node (sourcenode a)\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  local.CFG.pred (knd e) s\n  local.CFG.pred (knd e) s'\n\ngoal (1 subgoal):\n 1. (kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs &&&\n     local.CFG.pred (kind a) s) &&&\n    local.CFG.pred (kind a) s' &&& src e = Node (sourcenode a)", "by simp_all"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  local.CFG.pred (kind a) s\n  local.CFG.pred (kind a) s'\n  src e = Node (sourcenode a)\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src e) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src e) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src e) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src e) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i", "from \\<open>\\<forall>V\\<in>lift_ParamUses ParamUses (src e) ! i. state_val s V = state_val s' V\\<close>\n        \\<open>src e = Node (sourcenode a)\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>V\\<in>lift_ParamUses ParamUses (src e) ! i.\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  src e = Node (sourcenode a)", "have \"\\<forall>V \\<in> (ParamUses (sourcenode a))!i. state_val s V = state_val s' V\""], ["proof (prove)\nusing this:\n  \\<forall>V\\<in>lift_ParamUses ParamUses (src e) ! i.\n     local.CFG.state_val s V = local.CFG.state_val s' V\n  src e = Node (sourcenode a)\n\ngoal (1 subgoal):\n 1. \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n       local.CFG.state_val s V = local.CFG.state_val s' V", "by simp"], ["proof (state)\nthis:\n  \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n     local.CFG.state_val s V = local.CFG.state_val s' V\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src e) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src e) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src e) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src e) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close> \\<open>i < length ins\\<close> \n        \\<open>(p, ins, outs) \\<in> set procs\\<close> \\<open>pred (kind a) s\\<close> \\<open>pred (kind a) s'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  i < length ins\n  (p, ins, outs) \\<in> set procs\n  local.CFG.pred (kind a) s\n  local.CFG.pred (kind a) s'\n  \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n     local.CFG.state_val s V = local.CFG.state_val s' V", "show ?case"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  i < length ins\n  (p, ins, outs) \\<in> set procs\n  local.CFG.pred (kind a) s\n  local.CFG.pred (kind a) s'\n  \\<forall>V\\<in>ParamUses (sourcenode a) ! i.\n     local.CFG.state_val s V = local.CFG.state_val s' V\n\ngoal (1 subgoal):\n 1. local.CFG.params fs (local.CFG.state_val s) ! i =\n    local.CFG.params fs (local.CFG.state_val s') ! i", "by(rule CFG_call_edge_params)"], ["proof (state)\nthis:\n  local.CFG.params fs (local.CFG.state_val s) ! i =\n  local.CFG.params fs (local.CFG.state_val s') ! i\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src e) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src e) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs; i < length ins;\n        (p, ins, outs) \\<in> set procs; local.CFG.pred (knd e) s;\n        local.CFG.pred (knd e) s';\n        \\<forall>V\\<in>lift_ParamUses ParamUses (src e) ! i.\n           local.CFG.state_val s V = local.CFG.state_val s' V\\<rbrakk>\n       \\<Longrightarrow> local.CFG.params fs (local.CFG.state_val s) ! i =\n                         local.CFG.params fs (local.CFG.state_val s') ! i", "qed simp_all"], ["proof (state)\nthis:\n  local.CFG.params fs (local.CFG.state_val s) ! i =\n  local.CFG.params fs (local.CFG.state_val s') ! i\n\ngoal (2 subgoals):\n 1. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "fix a Q' p f' ins outs cf cf'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\" and \"(p, ins, outs) \\<in> set procs\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs\n\ngoal (2 subgoals):\n 1. \\<And>a Q' p f' ins outs vmap vmap'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' vmap vmap' =\n                         vmap'(lift_ParamDefs ParamDefs (trg a) [:=]\n                         map vmap outs)\n 2. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "thus \"f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg a) [:=] map cf outs)\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg a) [:=] map cf outs)", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg e) \n                         [:=] map cf outs)\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg e) \n                         [:=] map cf outs)\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg e) \n                         [:=] map cf outs)\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg e) \n                         [:=] map cf outs)", "case (lve_edge a e)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg e) \n                         [:=] map cf outs)\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg e) \n                         [:=] map cf outs)\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg e) \n                         [:=] map cf outs)\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg e) \n                         [:=] map cf outs)", "from \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close> \\<open>knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'", "have \"kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\" and \"trg e = Node (targetnode a)\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n\ngoal (1 subgoal):\n 1. kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f' &&&\n    trg e = Node (targetnode a)", "by simp_all"], ["proof (state)\nthis:\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  trg e = Node (targetnode a)\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg e) \n                         [:=] map cf outs)\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg e) \n                         [:=] map cf outs)\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg e) \n                         [:=] map cf outs)\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg e) \n                         [:=] map cf outs)", "from \\<open>valid_edge a\\<close> \\<open>kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\\<close> \\<open>(p, ins, outs) \\<in> set procs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs", "have \"f' cf cf' = cf'(ParamDefs (targetnode a) [:=] map cf outs)\""], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f'\n  (p, ins, outs) \\<in> set procs\n\ngoal (1 subgoal):\n 1. f' cf cf' = cf'(ParamDefs (targetnode a) [:=] map cf outs)", "by(rule CFG_return_edge_fun)"], ["proof (state)\nthis:\n  f' cf cf' = cf'(ParamDefs (targetnode a) [:=] map cf outs)\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg e) \n                         [:=] map cf outs)\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg e) \n                         [:=] map cf outs)\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg e) \n                         [:=] map cf outs)\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg e) \n                         [:=] map cf outs)", "with \\<open>trg e = Node (targetnode a)\\<close>"], ["proof (chain)\npicking this:\n  trg e = Node (targetnode a)\n  f' cf cf' = cf'(ParamDefs (targetnode a) [:=] map cf outs)", "show ?case"], ["proof (prove)\nusing this:\n  trg e = Node (targetnode a)\n  f' cf cf' = cf'(ParamDefs (targetnode a) [:=] map cf outs)\n\ngoal (1 subgoal):\n 1. f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg e) [:=] map cf outs)", "by simp"], ["proof (state)\nthis:\n  f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg e) [:=] map cf outs)\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg e) \n                         [:=] map cf outs)\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg e) \n                         [:=] map cf outs)\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        knd e = Q'\\<hookleftarrow>\\<^bsub>p\\<^esub>f';\n        (p, ins, outs) \\<in> set procs\\<rbrakk>\n       \\<Longrightarrow> f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg e) \n                         [:=] map cf outs)", "qed simp_all"], ["proof (state)\nthis:\n  f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg a) [:=] map cf outs)\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "fix a a'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\"\n      and \"src a = src a'\" and \"trg a \\<noteq> trg a'\"\n      and \"intra_kind (knd a)\" and \"intra_kind (knd a')\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src a = src a'\n  trg a \\<noteq> trg a'\n  intra_kind (knd a)\n  intra_kind (knd a')\n\ngoal (1 subgoal):\n 1. \\<And>a a'.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src a = src a'; trg a \\<noteq> trg a'; intra_kind (knd a);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd a = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "thus \"\\<exists>Q Q'. knd a = (Q)\\<^sub>\\<surd> \\<and> knd a' = (Q')\\<^sub>\\<surd> \\<and> \n                 (\\<forall>s. (Q s \\<longrightarrow> \\<not> Q' s) \\<and> (Q' s \\<longrightarrow> \\<not> Q s))\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src a = src a'\n  trg a \\<noteq> trg a'\n  intra_kind (knd a)\n  intra_kind (knd a')\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       knd a = (Q)\\<^sub>\\<surd> \\<and>\n       knd a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e \\<noteq> trg a'; intra_kind (knd e);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e \\<noteq> trg a'; intra_kind (knd e);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e \\<noteq> trg a'; intra_kind (knd e);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e \\<noteq> trg a'; intra_kind (knd e);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "case (lve_edge a e)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  src e = src a'\n  trg e \\<noteq> trg a'\n  intra_kind (knd e)\n  intra_kind (knd a')\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e \\<noteq> trg a'; intra_kind (knd e);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e \\<noteq> trg a'; intra_kind (knd e);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e \\<noteq> trg a'; intra_kind (knd e);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e \\<noteq> trg a'; intra_kind (knd e);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\\<close>\n        \\<open>valid_edge a\\<close> \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>\n        \\<open>src e = src a'\\<close> \\<open>trg e \\<noteq> trg a'\\<close> \\<open>intra_kind (knd e)\\<close> \\<open>intra_kind (knd a')\\<close>"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  valid_edge a\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  src e = src a'\n  trg e \\<noteq> trg a'\n  intra_kind (knd e)\n  intra_kind (knd a')", "show ?case"], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  valid_edge a\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  src e = src a'\n  trg e \\<noteq> trg a'\n  intra_kind (knd e)\n  intra_kind (knd a')\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       knd e = (Q)\\<^sub>\\<surd> \\<and>\n       knd a' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a ea.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        ea = (Node (sourcenode a), kind a, Node (targetnode a));\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>ea.\n       \\<lbrakk>ea =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>ea.\n       \\<lbrakk>ea = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>ea.\n       \\<lbrakk>ea = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "case lve_edge"], ["proof (state)\nthis:\n  valid_edge a_\n  sourcenode a_ \\<noteq> Entry \\<or> targetnode a_ \\<noteq> Exit\n  e_ = (Node (sourcenode a_), kind a_, Node (targetnode a_))\n  valid_edge a\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  src e = src e_\n  trg e \\<noteq> trg e_\n  intra_kind (knd e)\n  intra_kind (knd e_)\n\ngoal (4 subgoals):\n 1. \\<And>a ea.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        ea = (Node (sourcenode a), kind a, Node (targetnode a));\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>ea.\n       \\<lbrakk>ea =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>ea.\n       \\<lbrakk>ea = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 4. \\<And>ea.\n       \\<lbrakk>ea = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "thus ?case"], ["proof (prove)\nusing this:\n  valid_edge a_\n  sourcenode a_ \\<noteq> Entry \\<or> targetnode a_ \\<noteq> Exit\n  e_ = (Node (sourcenode a_), kind a_, Node (targetnode a_))\n  valid_edge a\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  src e = src e_\n  trg e \\<noteq> trg e_\n  intra_kind (knd e)\n  intra_kind (knd e_)\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       knd e = (Q)\\<^sub>\\<surd> \\<and>\n       knd e_ = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by(auto dest:deterministic)"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     knd e = (Q)\\<^sub>\\<surd> \\<and>\n     knd e_ = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (3 subgoals):\n 1. \\<And>ea.\n       \\<lbrakk>ea =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>ea.\n       \\<lbrakk>ea = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>ea.\n       \\<lbrakk>ea = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ea.\n       \\<lbrakk>ea =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>ea.\n       \\<lbrakk>ea = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>ea.\n       \\<lbrakk>ea = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "case (lve_Exit_edge e')"], ["proof (state)\nthis:\n  e' = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n  valid_edge a\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  src e = src e'\n  trg e \\<noteq> trg e'\n  intra_kind (knd e)\n  intra_kind (knd e')\n\ngoal (3 subgoals):\n 1. \\<And>ea.\n       \\<lbrakk>ea =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>ea.\n       \\<lbrakk>ea = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>ea.\n       \\<lbrakk>ea = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "from \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close>\n          \\<open>e' = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\\<close> \\<open>src e = src e'\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  e' = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n  src e = src e'", "have \"sourcenode a = Exit\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  e' = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n  src e = src e'\n\ngoal (1 subgoal):\n 1. sourcenode a = Exit", "by simp"], ["proof (state)\nthis:\n  sourcenode a = Exit\n\ngoal (3 subgoals):\n 1. \\<And>ea.\n       \\<lbrakk>ea =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>ea.\n       \\<lbrakk>ea = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>ea.\n       \\<lbrakk>ea = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = Exit", "have False"], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = Exit\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<And>ea.\n       \\<lbrakk>ea =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>ea.\n       \\<lbrakk>ea = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>ea.\n       \\<lbrakk>ea = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>Q Q'.\n       knd e = (Q)\\<^sub>\\<surd> \\<and>\n       knd e' = (Q')\\<^sub>\\<surd> \\<and>\n       (\\<forall>s.\n           (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n           (Q' s \\<longrightarrow> \\<not> Q s))", "by simp"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     knd e = (Q)\\<^sub>\\<surd> \\<and>\n     knd e' = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (2 subgoals):\n 1. \\<And>ea.\n       \\<lbrakk>ea =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>ea.\n       \\<lbrakk>ea = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        valid_edge a;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = src ea; trg e \\<noteq> trg ea; intra_kind (knd e);\n        intra_kind (knd ea)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd ea = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "qed auto"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     knd e = (Q)\\<^sub>\\<surd> \\<and>\n     knd a' = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e \\<noteq> trg a'; intra_kind (knd e);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e \\<noteq> trg a'; intra_kind (knd e);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a';\n        src e = src a'; trg e \\<noteq> trg a'; intra_kind (knd e);\n        intra_kind (knd a')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Q Q'.\n                            knd e = (Q)\\<^sub>\\<surd> \\<and>\n                            knd a' = (Q')\\<^sub>\\<surd> \\<and>\n                            (\\<forall>s.\n                                (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n                                (Q' s \\<longrightarrow> \\<not> Q s))", "qed (fastforce elim:lift_valid_edge.cases)+"], ["proof (state)\nthis:\n  \\<exists>Q Q'.\n     knd a = (Q)\\<^sub>\\<surd> \\<and>\n     knd a' = (Q')\\<^sub>\\<surd> \\<and>\n     (\\<forall>s.\n         (Q s \\<longrightarrow> \\<not> Q' s) \\<and>\n         (Q' s \\<longrightarrow> \\<not> Q s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CFG_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_get_proc get_proc Main)\n   (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode\n     kind)\n   procs Main (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n   (lift_ParamDefs ParamDefs) (lift_ParamUses ParamUses)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_CFGExit:\n  assumes wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc \n  get_return_edges procs Main Exit Def Use ParamDefs ParamUses\"\n  and pd:\"Postdomination sourcenode targetnode kind valid_edge Entry get_proc \n  get_return_edges procs Main Exit\"\n  shows \"CFGExit src trg knd\n  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\n  (lift_get_proc get_proc Main) \n  (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind) \n  procs Main NewExit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CFGExit src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "interpret CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc \n    get_return_edges procs Main Exit Def Use ParamDefs ParamUses"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc\n     get_return_edges procs Main Exit Def Use ParamDefs ParamUses", "by(rule wf)"], ["proof (state)\ngoal (1 subgoal):\n 1. CFGExit src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "interpret Postdomination sourcenode targetnode kind valid_edge Entry get_proc \n    get_return_edges procs Main Exit"], ["proof (prove)\ngoal (1 subgoal):\n 1. Postdomination sourcenode targetnode kind valid_edge Entry get_proc\n     get_return_edges procs Main Exit", "by(rule pd)"], ["proof (state)\ngoal (1 subgoal):\n 1. CFGExit src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "interpret CFG:CFG src trg knd\n    \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\" NewEntry\n    \"lift_get_proc get_proc Main\" \n    \"lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind\"\n    procs Main"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main", "by(fastforce intro:lift_CFG wf pd)"], ["proof (state)\ngoal (1 subgoal):\n 1. CFGExit src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 2. lift_get_proc get_proc Main NewExit = Main\n 3. \\<And>a Q p f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>", "fix a"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 2. lift_get_proc get_proc Main NewExit = Main\n 3. \\<And>a Q p f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"src a = NewExit\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  src a = NewExit\n\ngoal (4 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        src a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 2. lift_get_proc get_proc Main NewExit = Main\n 3. \\<And>a Q p f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>", "thus False"], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  src a = NewExit\n\ngoal (1 subgoal):\n 1. False", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. lift_get_proc get_proc Main NewExit = Main\n 2. \\<And>a Q p f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. lift_get_proc get_proc Main NewExit = Main\n 2. \\<And>a Q p f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>", "show \"lift_get_proc get_proc Main NewExit = Main\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_get_proc get_proc Main NewExit = Main", "by simp"], ["proof (state)\nthis:\n  lift_get_proc get_proc Main NewExit = Main\n\ngoal (2 subgoals):\n 1. \\<And>a Q p f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a Q p f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>", "fix a Q p f"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a Q p f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>", "assume \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n      and \"knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\" and \"trg a = NewExit\""], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  trg a = NewExit\n\ngoal (2 subgoals):\n 1. \\<And>a Q p f.\n       \\<lbrakk>lift_valid_edge valid_edge sourcenode targetnode kind Entry\n                 Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f;\n        trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>", "thus False"], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  trg a = NewExit\n\ngoal (1 subgoal):\n 1. False", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>", "show \"\\<exists>a. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a \\<and>\n      src a = NewEntry \\<and> trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a.\n       lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        a \\<and>\n       src a = NewEntry \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>", "by(fastforce intro:lve_Entry_Exit_edge)"], ["proof (state)\nthis:\n  \\<exists>a.\n     lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n      a \\<and>\n     src a = NewEntry \\<and>\n     trg a = NewExit \\<and> knd a = (\\<lambda>s. False)\\<^sub>\\<surd>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CFGExit src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_get_proc get_proc Main)\n   (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode\n     kind)\n   procs Main NewExit\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_CFGExit_wf:\n  assumes wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc \n  get_return_edges procs Main Exit Def Use ParamDefs ParamUses\"\n  and pd:\"Postdomination sourcenode targetnode kind valid_edge Entry get_proc \n  get_return_edges procs Main Exit\"\n  shows \"CFGExit_wf src trg knd\n  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\n  (lift_get_proc get_proc Main) \n  (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind) \n  procs Main NewExit (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n  (lift_ParamDefs ParamDefs) (lift_ParamUses ParamUses)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit (lift_Def Def Entry Exit H L)\n     (lift_Use Use Entry Exit H L) (lift_ParamDefs ParamDefs)\n     (lift_ParamUses ParamUses)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CFGExit_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit (lift_Def Def Entry Exit H L)\n     (lift_Use Use Entry Exit H L) (lift_ParamDefs ParamDefs)\n     (lift_ParamUses ParamUses)", "interpret CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc \n    get_return_edges procs Main Exit Def Use ParamDefs ParamUses"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc\n     get_return_edges procs Main Exit Def Use ParamDefs ParamUses", "by(rule wf)"], ["proof (state)\ngoal (1 subgoal):\n 1. CFGExit_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit (lift_Def Def Entry Exit H L)\n     (lift_Use Use Entry Exit H L) (lift_ParamDefs ParamDefs)\n     (lift_ParamUses ParamUses)", "interpret Postdomination sourcenode targetnode kind valid_edge Entry get_proc \n    get_return_edges procs Main Exit"], ["proof (prove)\ngoal (1 subgoal):\n 1. Postdomination sourcenode targetnode kind valid_edge Entry get_proc\n     get_return_edges procs Main Exit", "by(rule pd)"], ["proof (state)\ngoal (1 subgoal):\n 1. CFGExit_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit (lift_Def Def Entry Exit H L)\n     (lift_Use Use Entry Exit H L) (lift_ParamDefs ParamDefs)\n     (lift_ParamUses ParamUses)", "interpret CFG_wf:CFG_wf src trg knd\n    \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\" NewEntry\n    \"lift_get_proc get_proc Main\" \n    \"lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind\"\n    procs Main \"lift_Def Def Entry Exit H L\" \"lift_Use Use Entry Exit H L\"\n    \"lift_ParamDefs ParamDefs\" \"lift_ParamUses ParamUses\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFG_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n     (lift_ParamDefs ParamDefs) (lift_ParamUses ParamUses)", "by(fastforce intro:lift_CFG_wf wf pd)"], ["proof (state)\ngoal (1 subgoal):\n 1. CFGExit_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit (lift_Def Def Entry Exit H L)\n     (lift_Use Use Entry Exit H L) (lift_ParamDefs ParamDefs)\n     (lift_ParamUses ParamUses)", "interpret CFGExit:CFGExit src trg knd\n    \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\" NewEntry\n    \"lift_get_proc get_proc Main\"\n    \"lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind\"\n    procs Main NewExit"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "by(fastforce intro:lift_CFGExit wf pd)"], ["proof (state)\ngoal (1 subgoal):\n 1. CFGExit_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit (lift_Def Def Entry Exit H L)\n     (lift_Use Use Entry Exit H L) (lift_ParamDefs ParamDefs)\n     (lift_ParamUses ParamUses)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit (lift_Def Def Entry Exit H L)\n     (lift_Use Use Entry Exit H L) (lift_ParamDefs ParamDefs)\n     (lift_ParamUses ParamUses)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}", "show \"lift_Def Def Entry Exit H L NewExit = {} \\<and>\n      lift_Use Use Entry Exit H L NewExit = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_Def Def Entry Exit H L NewExit = {} \\<and>\n    lift_Use Use Entry Exit H L NewExit = {}", "by(fastforce elim:lift_Def_set.cases lift_Use_set.cases)"], ["proof (state)\nthis:\n  lift_Def Def Entry Exit H L NewExit = {} \\<and>\n  lift_Use Use Entry Exit H L NewExit = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CFGExit_wf src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_get_proc get_proc Main)\n   (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode\n     kind)\n   procs Main NewExit (lift_Def Def Entry Exit H L)\n   (lift_Use Use Entry Exit H L) (lift_ParamDefs ParamDefs)\n   (lift_ParamUses ParamUses)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Lifting the SDG\\<close>"], ["", "lemma lift_Postdomination:\n  assumes wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc \n  get_return_edges procs Main Exit Def Use ParamDefs ParamUses\"\n  and pd:\"Postdomination sourcenode targetnode kind valid_edge Entry get_proc \n  get_return_edges procs Main Exit\"\n  and inner:\"CFGExit.inner_node sourcenode targetnode valid_edge Entry Exit nx\"\n  shows \"Postdomination src trg knd\n  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\n  (lift_get_proc get_proc Main) \n  (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind) \n  procs Main NewExit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "interpret CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc \n    get_return_edges procs Main Exit Def Use ParamDefs ParamUses"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc\n     get_return_edges procs Main Exit Def Use ParamDefs ParamUses", "by(rule wf)"], ["proof (state)\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "interpret Postdomination sourcenode targetnode kind valid_edge Entry get_proc \n    get_return_edges procs Main Exit"], ["proof (prove)\ngoal (1 subgoal):\n 1. Postdomination sourcenode targetnode kind valid_edge Entry get_proc\n     get_return_edges procs Main Exit", "by(rule pd)"], ["proof (state)\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "interpret CFGExit:CFGExit src trg knd\n    \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\" NewEntry\n    \"lift_get_proc get_proc Main\"\n    \"lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind\"\n    procs Main NewExit"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "by(fastforce intro:lift_CFGExit wf pd)"], ["proof (state)\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "assume \"valid_node m\""], ["proof (state)\nthis:\n  valid_node m\n\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "then"], ["proof (chain)\npicking this:\n  valid_node m", "obtain a where \"valid_edge a\" and \"m = sourcenode a \\<or> m = targetnode a\""], ["proof (prove)\nusing this:\n  valid_node m\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>valid_edge a;\n         m = sourcenode a \\<or> m = targetnode a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp:valid_node_def)"], ["proof (state)\nthis:\n  valid_edge a\n  m = sourcenode a \\<or> m = targetnode a\n\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "from \\<open>m = sourcenode a \\<or> m = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  m = sourcenode a \\<or> m = targetnode a", "have \"CFG.CFG.valid_node src trg\n      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) (Node m)\""], ["proof (prove)\nusing this:\n  m = sourcenode a \\<or> m = targetnode a\n\ngoal (1 subgoal):\n 1. CFGExit.valid_node (Node m)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. m = sourcenode a \\<Longrightarrow> CFGExit.valid_node (Node m)\n 2. m = targetnode a \\<Longrightarrow> CFGExit.valid_node (Node m)", "assume \"m = sourcenode a\""], ["proof (state)\nthis:\n  m = sourcenode a\n\ngoal (2 subgoals):\n 1. m = sourcenode a \\<Longrightarrow> CFGExit.valid_node (Node m)\n 2. m = targetnode a \\<Longrightarrow> CFGExit.valid_node (Node m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit.valid_node (Node m)", "proof(cases \"m = Entry\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m = Entry \\<Longrightarrow> CFGExit.valid_node (Node m)\n 2. m \\<noteq> Entry \\<Longrightarrow> CFGExit.valid_node (Node m)", "case True"], ["proof (state)\nthis:\n  m = Entry\n\ngoal (2 subgoals):\n 1. m = Entry \\<Longrightarrow> CFGExit.valid_node (Node m)\n 2. m \\<noteq> Entry \\<Longrightarrow> CFGExit.valid_node (Node m)", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          (NewEntry,(\\<lambda>s. True)\\<^sub>\\<surd>,Node Entry)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)", "by(fastforce intro:lve_Entry_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n\ngoal (2 subgoals):\n 1. m = Entry \\<Longrightarrow> CFGExit.valid_node (Node m)\n 2. m \\<noteq> Entry \\<Longrightarrow> CFGExit.valid_node (Node m)", "with \\<open>m = Entry\\<close>"], ["proof (chain)\npicking this:\n  m = Entry\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)", "show ?thesis"], ["proof (prove)\nusing this:\n  m = Entry\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n\ngoal (1 subgoal):\n 1. CFGExit.valid_node (Node m)", "by(fastforce simp:CFGExit.valid_node_def)"], ["proof (state)\nthis:\n  CFGExit.valid_node (Node m)\n\ngoal (1 subgoal):\n 1. m \\<noteq> Entry \\<Longrightarrow> CFGExit.valid_node (Node m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<noteq> Entry \\<Longrightarrow> CFGExit.valid_node (Node m)", "case False"], ["proof (state)\nthis:\n  m \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. m \\<noteq> Entry \\<Longrightarrow> CFGExit.valid_node (Node m)", "with \\<open>m = sourcenode a\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  m = sourcenode a\n  valid_edge a\n  m \\<noteq> Entry", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          (Node (sourcenode a),kind a,Node(targetnode a))\""], ["proof (prove)\nusing this:\n  m = sourcenode a\n  valid_edge a\n  m \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node (sourcenode a), kind a, Node (targetnode a))", "by(fastforce intro:lve_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a), kind a, Node (targetnode a))\n\ngoal (1 subgoal):\n 1. m \\<noteq> Entry \\<Longrightarrow> CFGExit.valid_node (Node m)", "with \\<open>m = sourcenode a\\<close>"], ["proof (chain)\npicking this:\n  m = sourcenode a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a), kind a, Node (targetnode a))", "show ?thesis"], ["proof (prove)\nusing this:\n  m = sourcenode a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a), kind a, Node (targetnode a))\n\ngoal (1 subgoal):\n 1. CFGExit.valid_node (Node m)", "by(fastforce simp:CFGExit.valid_node_def)"], ["proof (state)\nthis:\n  CFGExit.valid_node (Node m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CFGExit.valid_node (Node m)\n\ngoal (1 subgoal):\n 1. m = targetnode a \\<Longrightarrow> CFGExit.valid_node (Node m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m = targetnode a \\<Longrightarrow> CFGExit.valid_node (Node m)", "assume \"m = targetnode a\""], ["proof (state)\nthis:\n  m = targetnode a\n\ngoal (1 subgoal):\n 1. m = targetnode a \\<Longrightarrow> CFGExit.valid_node (Node m)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit.valid_node (Node m)", "proof(cases \"m = Exit\")"], ["proof (state)\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> CFGExit.valid_node (Node m)\n 2. m \\<noteq> Exit \\<Longrightarrow> CFGExit.valid_node (Node m)", "case True"], ["proof (state)\nthis:\n  m = Exit\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> CFGExit.valid_node (Node m)\n 2. m \\<noteq> Exit \\<Longrightarrow> CFGExit.valid_node (Node m)", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          (Node Exit,(\\<lambda>s. True)\\<^sub>\\<surd>,NewExit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)", "by(fastforce intro:lve_Exit_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> CFGExit.valid_node (Node m)\n 2. m \\<noteq> Exit \\<Longrightarrow> CFGExit.valid_node (Node m)", "with \\<open>m = Exit\\<close>"], ["proof (chain)\npicking this:\n  m = Exit\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)", "show ?thesis"], ["proof (prove)\nusing this:\n  m = Exit\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n\ngoal (1 subgoal):\n 1. CFGExit.valid_node (Node m)", "by(fastforce simp:CFGExit.valid_node_def)"], ["proof (state)\nthis:\n  CFGExit.valid_node (Node m)\n\ngoal (1 subgoal):\n 1. m \\<noteq> Exit \\<Longrightarrow> CFGExit.valid_node (Node m)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<noteq> Exit \\<Longrightarrow> CFGExit.valid_node (Node m)", "case False"], ["proof (state)\nthis:\n  m \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. m \\<noteq> Exit \\<Longrightarrow> CFGExit.valid_node (Node m)", "with \\<open>m = targetnode a\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  m = targetnode a\n  valid_edge a\n  m \\<noteq> Exit", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          (Node (sourcenode a),kind a,Node(targetnode a))\""], ["proof (prove)\nusing this:\n  m = targetnode a\n  valid_edge a\n  m \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node (sourcenode a), kind a, Node (targetnode a))", "by(fastforce intro:lve_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a), kind a, Node (targetnode a))\n\ngoal (1 subgoal):\n 1. m \\<noteq> Exit \\<Longrightarrow> CFGExit.valid_node (Node m)", "with \\<open>m = targetnode a\\<close>"], ["proof (chain)\npicking this:\n  m = targetnode a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a), kind a, Node (targetnode a))", "show ?thesis"], ["proof (prove)\nusing this:\n  m = targetnode a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a), kind a, Node (targetnode a))\n\ngoal (1 subgoal):\n 1. CFGExit.valid_node (Node m)", "by(fastforce simp:CFGExit.valid_node_def)"], ["proof (state)\nthis:\n  CFGExit.valid_node (Node m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CFGExit.valid_node (Node m)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CFGExit.valid_node (Node m)\n\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "}"], ["proof (state)\nthis:\n  valid_node ?m2 \\<Longrightarrow> CFGExit.valid_node (Node ?m2)\n\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "note lift_valid_node = this"], ["proof (state)\nthis:\n  valid_node ?m2 \\<Longrightarrow> CFGExit.valid_node (Node ?m2)\n\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "{"], ["proof (state)\nthis:\n  valid_node ?m2 \\<Longrightarrow> CFGExit.valid_node (Node ?m2)\n\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "fix n as n' cs m m'"], ["proof (state)\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "assume \"valid_path_aux cs as\" and \"m -as\\<rightarrow>* m'\" and \"\\<forall>c \\<in> set cs. valid_edge c\"\n      and \"m \\<noteq> Entry \\<or> m' \\<noteq> Exit\""], ["proof (state)\nthis:\n  valid_path_aux cs as\n  m -as\\<rightarrow>* m'\n  \\<forall>c\\<in>set cs. valid_edge c\n  m \\<noteq> Entry \\<or> m' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "hence \"\\<exists>cs' es. CFG.CFG.valid_path_aux knd\n      (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind)\n      cs' es \\<and> \n      list_all2 (\\<lambda>c c'. c' = (Node (sourcenode c),kind c,Node (targetnode c))) cs cs' \n       \\<and> CFG.CFG.path src trg\n      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n      (Node m) es (Node m')\""], ["proof (prove)\nusing this:\n  valid_path_aux cs as\n  m -as\\<rightarrow>* m'\n  \\<forall>c\\<in>set cs. valid_edge c\n  m \\<noteq> Entry \\<or> m' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "proof(induct arbitrary:m rule:vpa_induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>cs m.\n       \\<lbrakk>m -[]\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as m.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 4. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 5. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "case (vpa_empty cs)"], ["proof (state)\nthis:\n  m -[]\\<rightarrow>* m'\n  \\<forall>a\\<in>set cs. valid_edge a\n  m \\<noteq> Entry \\<or> m' \\<noteq> Exit\n\ngoal (5 subgoals):\n 1. \\<And>cs m.\n       \\<lbrakk>m -[]\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as m.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 4. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 5. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "from \\<open>m -[]\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -[]\\<rightarrow>* m'", "have [simp]:\"m = m'\""], ["proof (prove)\nusing this:\n  m -[]\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. m = m'", "by fastforce"], ["proof (state)\nthis:\n  m = m'\n\ngoal (5 subgoals):\n 1. \\<And>cs m.\n       \\<lbrakk>m -[]\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as m.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 4. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 5. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "from \\<open>m -[]\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -[]\\<rightarrow>* m'", "have \"valid_node m\""], ["proof (prove)\nusing this:\n  m -[]\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. valid_node m", "by(rule path_valid_node)"], ["proof (state)\nthis:\n  valid_node m\n\ngoal (5 subgoals):\n 1. \\<And>cs m.\n       \\<lbrakk>m -[]\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as m.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 4. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 5. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "obtain cs' where \"cs' = \n        map (\\<lambda>c. (Node (sourcenode c),kind c,Node (targetnode c))) cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cs'.\n        cs' =\n        map (\\<lambda>c. (Node (sourcenode c), kind c, Node (targetnode c)))\n         cs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  cs' =\n  map (\\<lambda>c. (Node (sourcenode c), kind c, Node (targetnode c))) cs\n\ngoal (5 subgoals):\n 1. \\<And>cs m.\n       \\<lbrakk>m -[]\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as m.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 4. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 5. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "hence \"list_all2 \n        (\\<lambda>c c'. c' = (Node (sourcenode c),kind c,Node (targetnode c))) cs cs'\""], ["proof (prove)\nusing this:\n  cs' =\n  map (\\<lambda>c. (Node (sourcenode c), kind c, Node (targetnode c))) cs\n\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>c c'.\n         c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n     cs cs'", "by(simp add:list_all2_conv_all_nth)"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n   cs cs'\n\ngoal (5 subgoals):\n 1. \\<And>cs m.\n       \\<lbrakk>m -[]\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as m.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 4. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 5. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "with \\<open>valid_node m\\<close>"], ["proof (chain)\npicking this:\n  valid_node m\n  list_all2\n   (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n   cs cs'", "show ?case"], ["proof (prove)\nusing this:\n  valid_node m\n  list_all2\n   (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n   cs cs'\n\ngoal (1 subgoal):\n 1. \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "apply(rule_tac x=\"cs'\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node m;\n     list_all2\n      (\\<lambda>c c'.\n          c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n      cs cs'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>es.\n                         CFGExit.valid_path_aux cs' es \\<and>\n                         list_all2\n                          (\\<lambda>c c'.\n                              c' =\n                              (Node (sourcenode c), kind c,\n                               Node (targetnode c)))\n                          cs cs' \\<and>\n                         CFGExit.path (Node m) es (Node m')", "apply(rule_tac x=\"[]\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_node m;\n     list_all2\n      (\\<lambda>c c'.\n          c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n      cs cs'\\<rbrakk>\n    \\<Longrightarrow> CFGExit.valid_path_aux cs' [] \\<and>\n                      list_all2\n                       (\\<lambda>c c'.\n                           c' =\n                           (Node (sourcenode c), kind c,\n                            Node (targetnode c)))\n                       cs cs' \\<and>\n                      CFGExit.path (Node m) [] (Node m')", "by(fastforce intro:CFGExit.empty_path lift_valid_node)"], ["proof (state)\nthis:\n  \\<exists>cs' es.\n     CFGExit.valid_path_aux cs' es \\<and>\n     list_all2\n      (\\<lambda>c c'.\n          c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n      cs cs' \\<and>\n     CFGExit.path (Node m) es (Node m')\n\ngoal (4 subgoals):\n 1. \\<And>cs a as m.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 4. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>cs a as m.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 4. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "case (vpa_intra cs a as)"], ["proof (state)\nthis:\n  intra_kind (kind a)\n  valid_path_aux cs as\n  \\<lbrakk>?m -as\\<rightarrow>* m'; \\<forall>a\\<in>set cs. valid_edge a;\n   ?m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cs' es.\n                       CFGExit.valid_path_aux cs' es \\<and>\n                       list_all2\n                        (\\<lambda>c c'.\n                            c' =\n                            (Node (sourcenode c), kind c,\n                             Node (targetnode c)))\n                        cs cs' \\<and>\n                       CFGExit.path (Node ?m) es (Node m')\n  m -a # as\\<rightarrow>* m'\n  \\<forall>a\\<in>set cs. valid_edge a\n  m \\<noteq> Entry \\<or> m' \\<noteq> Exit\n\ngoal (4 subgoals):\n 1. \\<And>cs a as m.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 4. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "note IH = \\<open>\\<And>m. \\<lbrakk>m -as\\<rightarrow>* m'; \\<forall>c\\<in>set cs. valid_edge c; m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk> \\<Longrightarrow>\n        \\<exists>cs' es. CFG.valid_path_aux knd\n        (lift_get_return_edges get_return_edges valid_edge sourcenode\n        targetnode kind) cs' es \\<and>\n        list_all2 (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c))) cs\n        cs' \\<and> CFG.path src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        (Node m) es (Node m')\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?m -as\\<rightarrow>* m'; \\<forall>c\\<in>set cs. valid_edge c;\n   ?m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cs' es.\n                       CFGExit.valid_path_aux cs' es \\<and>\n                       list_all2\n                        (\\<lambda>c c'.\n                            c' =\n                            (Node (sourcenode c), kind c,\n                             Node (targetnode c)))\n                        cs cs' \\<and>\n                       CFGExit.path (Node ?m) es (Node m')\n\ngoal (4 subgoals):\n 1. \\<And>cs a as m.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 4. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "from \\<open>m -a # as\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -a # as\\<rightarrow>* m'", "have \"m = sourcenode a\" and \"valid_edge a\"\n        and \"targetnode a -as\\<rightarrow>* m'\""], ["proof (prove)\nusing this:\n  m -a # as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. m = sourcenode a &&& valid_edge a &&& targetnode a -as\\<rightarrow>* m'", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  m = sourcenode a\n  valid_edge a\n  targetnode a -as\\<rightarrow>* m'\n\ngoal (4 subgoals):\n 1. \\<And>cs a as m.\n       \\<lbrakk>intra_kind (kind a); valid_path_aux cs as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 4. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "proof(cases \"sourcenode a = Entry \\<and> targetnode a = Exit\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sourcenode a = Entry \\<and> targetnode a = Exit \\<Longrightarrow>\n    \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')\n 2. \\<not> (sourcenode a = Entry \\<and>\n            targetnode a = Exit) \\<Longrightarrow>\n    \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "case True"], ["proof (state)\nthis:\n  sourcenode a = Entry \\<and> targetnode a = Exit\n\ngoal (2 subgoals):\n 1. sourcenode a = Entry \\<and> targetnode a = Exit \\<Longrightarrow>\n    \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')\n 2. \\<not> (sourcenode a = Entry \\<and>\n            targetnode a = Exit) \\<Longrightarrow>\n    \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "with \\<open>m = sourcenode a\\<close> \\<open>m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<close>"], ["proof (chain)\npicking this:\n  m = sourcenode a\n  m \\<noteq> Entry \\<or> m' \\<noteq> Exit\n  sourcenode a = Entry \\<and> targetnode a = Exit", "have \"m' \\<noteq> Exit\""], ["proof (prove)\nusing this:\n  m = sourcenode a\n  m \\<noteq> Entry \\<or> m' \\<noteq> Exit\n  sourcenode a = Entry \\<and> targetnode a = Exit\n\ngoal (1 subgoal):\n 1. m' \\<noteq> Exit", "by simp"], ["proof (state)\nthis:\n  m' \\<noteq> Exit\n\ngoal (2 subgoals):\n 1. sourcenode a = Entry \\<and> targetnode a = Exit \\<Longrightarrow>\n    \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')\n 2. \\<not> (sourcenode a = Entry \\<and>\n            targetnode a = Exit) \\<Longrightarrow>\n    \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "from True"], ["proof (chain)\npicking this:\n  sourcenode a = Entry \\<and> targetnode a = Exit", "have \"targetnode a = Exit\""], ["proof (prove)\nusing this:\n  sourcenode a = Entry \\<and> targetnode a = Exit\n\ngoal (1 subgoal):\n 1. targetnode a = Exit", "by simp"], ["proof (state)\nthis:\n  targetnode a = Exit\n\ngoal (2 subgoals):\n 1. sourcenode a = Entry \\<and> targetnode a = Exit \\<Longrightarrow>\n    \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')\n 2. \\<not> (sourcenode a = Entry \\<and>\n            targetnode a = Exit) \\<Longrightarrow>\n    \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "with \\<open>targetnode a -as\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  targetnode a -as\\<rightarrow>* m'\n  targetnode a = Exit", "have \"m' = Exit\""], ["proof (prove)\nusing this:\n  targetnode a -as\\<rightarrow>* m'\n  targetnode a = Exit\n\ngoal (1 subgoal):\n 1. m' = Exit", "by -(drule path_Exit_source,auto)"], ["proof (state)\nthis:\n  m' = Exit\n\ngoal (2 subgoals):\n 1. sourcenode a = Entry \\<and> targetnode a = Exit \\<Longrightarrow>\n    \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')\n 2. \\<not> (sourcenode a = Entry \\<and>\n            targetnode a = Exit) \\<Longrightarrow>\n    \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "with \\<open>m' \\<noteq> Exit\\<close>"], ["proof (chain)\npicking this:\n  m' \\<noteq> Exit\n  m' = Exit", "have False"], ["proof (prove)\nusing this:\n  m' \\<noteq> Exit\n  m' = Exit\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. sourcenode a = Entry \\<and> targetnode a = Exit \\<Longrightarrow>\n    \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')\n 2. \\<not> (sourcenode a = Entry \\<and>\n            targetnode a = Exit) \\<Longrightarrow>\n    \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "by simp"], ["proof (state)\nthis:\n  \\<exists>cs' es.\n     CFGExit.valid_path_aux cs' es \\<and>\n     list_all2\n      (\\<lambda>c c'.\n          c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n      cs cs' \\<and>\n     CFGExit.path (Node m) es (Node m')\n\ngoal (1 subgoal):\n 1. \\<not> (sourcenode a = Entry \\<and>\n            targetnode a = Exit) \\<Longrightarrow>\n    \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (sourcenode a = Entry \\<and>\n            targetnode a = Exit) \\<Longrightarrow>\n    \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "case False"], ["proof (state)\nthis:\n  \\<not> (sourcenode a = Entry \\<and> targetnode a = Exit)\n\ngoal (1 subgoal):\n 1. \\<not> (sourcenode a = Entry \\<and>\n            targetnode a = Exit) \\<Longrightarrow>\n    \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "let ?e = \"(Node (sourcenode a),kind a,Node (targetnode a))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (sourcenode a = Entry \\<and>\n            targetnode a = Exit) \\<Longrightarrow>\n    \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "from False \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  \\<not> (sourcenode a = Entry \\<and> targetnode a = Exit)\n  valid_edge a", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?e\""], ["proof (prove)\nusing this:\n  \\<not> (sourcenode a = Entry \\<and> targetnode a = Exit)\n  valid_edge a\n\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node (sourcenode a), kind a, Node (targetnode a))", "by(fastforce intro:lve_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a), kind a, Node (targetnode a))\n\ngoal (1 subgoal):\n 1. \\<not> (sourcenode a = Entry \\<and>\n            targetnode a = Exit) \\<Longrightarrow>\n    \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "have \"targetnode a \\<noteq> Entry\""], ["proof (prove)\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> Entry", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. targetnode a = Entry \\<Longrightarrow> False", "assume \"targetnode a = Entry\""], ["proof (state)\nthis:\n  targetnode a = Entry\n\ngoal (1 subgoal):\n 1. targetnode a = Entry \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  targetnode a = Entry", "show False"], ["proof (prove)\nusing this:\n  valid_edge a\n  targetnode a = Entry\n\ngoal (1 subgoal):\n 1. False", "by(rule Entry_target)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  targetnode a \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. \\<not> (sourcenode a = Entry \\<and>\n            targetnode a = Exit) \\<Longrightarrow>\n    \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "hence \"targetnode a \\<noteq> Entry \\<or> m' \\<noteq> Exit\""], ["proof (prove)\nusing this:\n  targetnode a \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> Entry \\<or> m' \\<noteq> Exit", "by simp"], ["proof (state)\nthis:\n  targetnode a \\<noteq> Entry \\<or> m' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. \\<not> (sourcenode a = Entry \\<and>\n            targetnode a = Exit) \\<Longrightarrow>\n    \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "from IH[OF \\<open>targetnode a -as\\<rightarrow>* m'\\<close> \\<open>\\<forall>c\\<in>set cs. valid_edge c\\<close> this]"], ["proof (chain)\npicking this:\n  \\<exists>cs' es.\n     CFGExit.valid_path_aux cs' es \\<and>\n     list_all2\n      (\\<lambda>c c'.\n          c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n      cs cs' \\<and>\n     CFGExit.path (Node (targetnode a)) es (Node m')", "obtain cs' es\n          where valid_path:\"CFG.valid_path_aux knd\n          (lift_get_return_edges get_return_edges valid_edge sourcenode \n          targetnode kind) cs' es\" \n          and list:\"list_all2 \n          (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c))) cs cs'\"\n          and path:\"CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (Node (targetnode a)) es (Node m')\""], ["proof (prove)\nusing this:\n  \\<exists>cs' es.\n     CFGExit.valid_path_aux cs' es \\<and>\n     list_all2\n      (\\<lambda>c c'.\n          c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n      cs cs' \\<and>\n     CFGExit.path (Node (targetnode a)) es (Node m')\n\ngoal (1 subgoal):\n 1. (\\<And>cs' es.\n        \\<lbrakk>CFGExit.valid_path_aux cs' es;\n         list_all2\n          (\\<lambda>c c'.\n              c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n          cs cs';\n         CFGExit.path (Node (targetnode a)) es (Node m')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  CFGExit.valid_path_aux cs' es\n  list_all2\n   (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n   cs cs'\n  CFGExit.path (Node (targetnode a)) es (Node m')\n\ngoal (1 subgoal):\n 1. \\<not> (sourcenode a = Entry \\<and>\n            targetnode a = Exit) \\<Longrightarrow>\n    \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "from \\<open>intra_kind (kind a)\\<close> valid_path"], ["proof (chain)\npicking this:\n  intra_kind (kind a)\n  CFGExit.valid_path_aux cs' es", "have \"CFG.valid_path_aux knd\n          (lift_get_return_edges get_return_edges valid_edge sourcenode \n          targetnode kind) cs' (?e#es)\""], ["proof (prove)\nusing this:\n  intra_kind (kind a)\n  CFGExit.valid_path_aux cs' es\n\ngoal (1 subgoal):\n 1. CFGExit.valid_path_aux cs'\n     ((Node (sourcenode a), kind a, Node (targetnode a)) # es)", "by(fastforce simp:intra_kind_def)"], ["proof (state)\nthis:\n  CFGExit.valid_path_aux cs'\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es)\n\ngoal (1 subgoal):\n 1. \\<not> (sourcenode a = Entry \\<and>\n            targetnode a = Exit) \\<Longrightarrow>\n    \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "moreover"], ["proof (state)\nthis:\n  CFGExit.valid_path_aux cs'\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es)\n\ngoal (1 subgoal):\n 1. \\<not> (sourcenode a = Entry \\<and>\n            targetnode a = Exit) \\<Longrightarrow>\n    \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "from path \\<open>m = sourcenode a\\<close> \n          \\<open>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?e\\<close>"], ["proof (chain)\npicking this:\n  CFGExit.path (Node (targetnode a)) es (Node m')\n  m = sourcenode a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a), kind a, Node (targetnode a))", "have \"CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (Node m) (?e#es) (Node m')\""], ["proof (prove)\nusing this:\n  CFGExit.path (Node (targetnode a)) es (Node m')\n  m = sourcenode a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a), kind a, Node (targetnode a))\n\ngoal (1 subgoal):\n 1. CFGExit.path (Node m)\n     ((Node (sourcenode a), kind a, Node (targetnode a)) # es) (Node m')", "by(fastforce intro:CFGExit.Cons_path)"], ["proof (state)\nthis:\n  CFGExit.path (Node m)\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es) (Node m')\n\ngoal (1 subgoal):\n 1. \\<not> (sourcenode a = Entry \\<and>\n            targetnode a = Exit) \\<Longrightarrow>\n    \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "ultimately"], ["proof (chain)\npicking this:\n  CFGExit.valid_path_aux cs'\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es)\n  CFGExit.path (Node m)\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es) (Node m')", "show ?thesis"], ["proof (prove)\nusing this:\n  CFGExit.valid_path_aux cs'\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es)\n  CFGExit.path (Node m)\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es) (Node m')\n\ngoal (1 subgoal):\n 1. \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "using list"], ["proof (prove)\nusing this:\n  CFGExit.valid_path_aux cs'\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es)\n  CFGExit.path (Node m)\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es) (Node m')\n  list_all2\n   (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n   cs cs'\n\ngoal (1 subgoal):\n 1. \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "by blast"], ["proof (state)\nthis:\n  \\<exists>cs' es.\n     CFGExit.valid_path_aux cs' es \\<and>\n     list_all2\n      (\\<lambda>c c'.\n          c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n      cs cs' \\<and>\n     CFGExit.path (Node m) es (Node m')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>cs' es.\n     CFGExit.valid_path_aux cs' es \\<and>\n     list_all2\n      (\\<lambda>c c'.\n          c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n      cs cs' \\<and>\n     CFGExit.path (Node m) es (Node m')\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "case (vpa_Call cs a as Q r p fs)"], ["proof (state)\nthis:\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  valid_path_aux (a # cs) as\n  \\<lbrakk>?m -as\\<rightarrow>* m';\n   \\<forall>a\\<in>set (a # cs). valid_edge a;\n   ?m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cs' es.\n                       CFGExit.valid_path_aux cs' es \\<and>\n                       list_all2\n                        (\\<lambda>c c'.\n                            c' =\n                            (Node (sourcenode c), kind c,\n                             Node (targetnode c)))\n                        (a # cs) cs' \\<and>\n                       CFGExit.path (Node ?m) es (Node m')\n  m -a # as\\<rightarrow>* m'\n  \\<forall>a\\<in>set cs. valid_edge a\n  m \\<noteq> Entry \\<or> m' \\<noteq> Exit\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "note IH = \\<open>\\<And>m. \\<lbrakk>m -as\\<rightarrow>* m'; \\<forall>c\\<in>set (a # cs). valid_edge c; \n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk> \\<Longrightarrow>\n        \\<exists>cs' es. CFG.valid_path_aux knd\n        (lift_get_return_edges get_return_edges valid_edge sourcenode\n        targetnode kind) cs' es \\<and>\n        list_all2 (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c))) \n        (a#cs) cs' \\<and> CFG.path src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        (Node m) es (Node m')\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?m -as\\<rightarrow>* m';\n   \\<forall>c\\<in>set (a # cs). valid_edge c;\n   ?m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cs' es.\n                       CFGExit.valid_path_aux cs' es \\<and>\n                       list_all2\n                        (\\<lambda>c c'.\n                            c' =\n                            (Node (sourcenode c), kind c,\n                             Node (targetnode c)))\n                        (a # cs) cs' \\<and>\n                       CFGExit.path (Node ?m) es (Node m')\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "from \\<open>m -a # as\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -a # as\\<rightarrow>* m'", "have \"m = sourcenode a\" and \"valid_edge a\"\n        and \"targetnode a -as\\<rightarrow>* m'\""], ["proof (prove)\nusing this:\n  m -a # as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. m = sourcenode a &&& valid_edge a &&& targetnode a -as\\<rightarrow>* m'", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  m = sourcenode a\n  valid_edge a\n  targetnode a -as\\<rightarrow>* m'\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "from \\<open>\\<forall>c\\<in>set cs. valid_edge c\\<close> \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>c\\<in>set cs. valid_edge c\n  valid_edge a", "have \"\\<forall>c\\<in>set (a # cs). valid_edge c\""], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>set cs. valid_edge c\n  valid_edge a\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>set (a # cs). valid_edge c", "by simp"], ["proof (state)\nthis:\n  \\<forall>c\\<in>set (a # cs). valid_edge c\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "let ?e = \"(Node (sourcenode a),kind a,Node (targetnode a))\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "have \"sourcenode a \\<noteq> Entry\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sourcenode a \\<noteq> Entry", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode a = Entry \\<Longrightarrow> False", "assume \"sourcenode a = Entry\""], ["proof (state)\nthis:\n  sourcenode a = Entry\n\ngoal (1 subgoal):\n 1. sourcenode a = Entry \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a = Entry", "show False"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n  sourcenode a = Entry\n\ngoal (1 subgoal):\n 1. False", "by(rule Entry_no_call_source)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sourcenode a \\<noteq> Entry\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a \\<noteq> Entry", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?e\""], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node (sourcenode a), kind a, Node (targetnode a))", "by(fastforce intro:lve_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a), kind a, Node (targetnode a))\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "have \"targetnode a \\<noteq> Entry\""], ["proof (prove)\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> Entry", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. targetnode a = Entry \\<Longrightarrow> False", "assume \"targetnode a = Entry\""], ["proof (state)\nthis:\n  targetnode a = Entry\n\ngoal (1 subgoal):\n 1. targetnode a = Entry \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  targetnode a = Entry", "show False"], ["proof (prove)\nusing this:\n  valid_edge a\n  targetnode a = Entry\n\ngoal (1 subgoal):\n 1. False", "by(rule Entry_target)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  targetnode a \\<noteq> Entry\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "hence \"targetnode a \\<noteq> Entry \\<or> m' \\<noteq> Exit\""], ["proof (prove)\nusing this:\n  targetnode a \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> Entry \\<or> m' \\<noteq> Exit", "by simp"], ["proof (state)\nthis:\n  targetnode a \\<noteq> Entry \\<or> m' \\<noteq> Exit\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "from IH[OF \\<open>targetnode a -as\\<rightarrow>* m'\\<close> \\<open>\\<forall>c\\<in>set (a # cs). valid_edge c\\<close> this]"], ["proof (chain)\npicking this:\n  \\<exists>cs' es.\n     CFGExit.valid_path_aux cs' es \\<and>\n     list_all2\n      (\\<lambda>c c'.\n          c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n      (a # cs) cs' \\<and>\n     CFGExit.path (Node (targetnode a)) es (Node m')", "obtain cs' es\n        where valid_path:\"CFG.valid_path_aux knd\n        (lift_get_return_edges get_return_edges valid_edge sourcenode \n        targetnode kind) cs' es\" \n        and list:\"list_all2 \n        (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c))) (a#cs) cs'\"\n        and path:\"CFG.path src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        (Node (targetnode a)) es (Node m')\""], ["proof (prove)\nusing this:\n  \\<exists>cs' es.\n     CFGExit.valid_path_aux cs' es \\<and>\n     list_all2\n      (\\<lambda>c c'.\n          c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n      (a # cs) cs' \\<and>\n     CFGExit.path (Node (targetnode a)) es (Node m')\n\ngoal (1 subgoal):\n 1. (\\<And>cs' es.\n        \\<lbrakk>CFGExit.valid_path_aux cs' es;\n         list_all2\n          (\\<lambda>c c'.\n              c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n          (a # cs) cs';\n         CFGExit.path (Node (targetnode a)) es (Node m')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  CFGExit.valid_path_aux cs' es\n  list_all2\n   (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n   (a # cs) cs'\n  CFGExit.path (Node (targetnode a)) es (Node m')\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "from list"], ["proof (chain)\npicking this:\n  list_all2\n   (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n   (a # cs) cs'", "obtain cx csx where \"cs' = cx#csx\"\n        and cx:\"cx = (Node (sourcenode a), kind a, Node (targetnode a))\"\n        and list':\"list_all2 \n        (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c))) cs csx\""], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n   (a # cs) cs'\n\ngoal (1 subgoal):\n 1. (\\<And>cx csx.\n        \\<lbrakk>cs' = cx # csx;\n         cx = (Node (sourcenode a), kind a, Node (targetnode a));\n         list_all2\n          (\\<lambda>c c'.\n              c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n          cs csx\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp:list_all2_Cons1)"], ["proof (state)\nthis:\n  cs' = cx # csx\n  cx = (Node (sourcenode a), kind a, Node (targetnode a))\n  list_all2\n   (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n   cs csx\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "from valid_path cx \\<open>cs' = cx#csx\\<close> \\<open>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\\<close>"], ["proof (chain)\npicking this:\n  CFGExit.valid_path_aux cs' es\n  cx = (Node (sourcenode a), kind a, Node (targetnode a))\n  cs' = cx # csx\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs", "have \"CFG.valid_path_aux knd\n        (lift_get_return_edges get_return_edges valid_edge sourcenode \n        targetnode kind) csx (?e#es)\""], ["proof (prove)\nusing this:\n  CFGExit.valid_path_aux cs' es\n  cx = (Node (sourcenode a), kind a, Node (targetnode a))\n  cs' = cx # csx\n  kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs\n\ngoal (1 subgoal):\n 1. CFGExit.valid_path_aux csx\n     ((Node (sourcenode a), kind a, Node (targetnode a)) # es)", "by simp"], ["proof (state)\nthis:\n  CFGExit.valid_path_aux csx\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "moreover"], ["proof (state)\nthis:\n  CFGExit.valid_path_aux csx\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es)\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "from path \\<open>m = sourcenode a\\<close> \n        \\<open>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?e\\<close>"], ["proof (chain)\npicking this:\n  CFGExit.path (Node (targetnode a)) es (Node m')\n  m = sourcenode a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a), kind a, Node (targetnode a))", "have \"CFG.path src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        (Node m) (?e#es) (Node m')\""], ["proof (prove)\nusing this:\n  CFGExit.path (Node (targetnode a)) es (Node m')\n  m = sourcenode a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a), kind a, Node (targetnode a))\n\ngoal (1 subgoal):\n 1. CFGExit.path (Node m)\n     ((Node (sourcenode a), kind a, Node (targetnode a)) # es) (Node m')", "by(fastforce intro:CFGExit.Cons_path)"], ["proof (state)\nthis:\n  CFGExit.path (Node m)\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es) (Node m')\n\ngoal (3 subgoals):\n 1. \\<And>cs a as Q r p fs m.\n       \\<lbrakk>kind a = Q:r\\<hookrightarrow>\\<^bsub>p\\<^esub>fs;\n        valid_path_aux (a # cs) as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set (a # cs)) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 (a # cs) cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 3. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "ultimately"], ["proof (chain)\npicking this:\n  CFGExit.valid_path_aux csx\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es)\n  CFGExit.path (Node m)\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es) (Node m')", "show ?case"], ["proof (prove)\nusing this:\n  CFGExit.valid_path_aux csx\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es)\n  CFGExit.path (Node m)\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es) (Node m')\n\ngoal (1 subgoal):\n 1. \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "using list'"], ["proof (prove)\nusing this:\n  CFGExit.valid_path_aux csx\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es)\n  CFGExit.path (Node m)\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es) (Node m')\n  list_all2\n   (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n   cs csx\n\ngoal (1 subgoal):\n 1. \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "by blast"], ["proof (state)\nthis:\n  \\<exists>cs' es.\n     CFGExit.valid_path_aux cs' es \\<and>\n     list_all2\n      (\\<lambda>c c'.\n          c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n      cs cs' \\<and>\n     CFGExit.path (Node m) es (Node m')\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "case (vpa_ReturnEmpty cs a as Q p f)"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = []\n  valid_path_aux [] as\n  \\<lbrakk>?m -as\\<rightarrow>* m'; \\<forall>a\\<in>set []. valid_edge a;\n   ?m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cs' es.\n                       CFGExit.valid_path_aux cs' es \\<and>\n                       list_all2\n                        (\\<lambda>c c'.\n                            c' =\n                            (Node (sourcenode c), kind c,\n                             Node (targetnode c)))\n                        [] cs' \\<and>\n                       CFGExit.path (Node ?m) es (Node m')\n  m -a # as\\<rightarrow>* m'\n  \\<forall>a\\<in>set cs. valid_edge a\n  m \\<noteq> Entry \\<or> m' \\<noteq> Exit\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "note IH = \\<open>\\<And>m. \\<lbrakk>m -as\\<rightarrow>* m'; \\<forall>c\\<in>set []. valid_edge c; m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk> \\<Longrightarrow>\n        \\<exists>cs' es. CFG.valid_path_aux knd\n        (lift_get_return_edges get_return_edges valid_edge sourcenode\n        targetnode kind) cs' es \\<and>\n        list_all2 (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c))) \n        [] cs' \\<and> CFG.path src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        (Node m) es (Node m')\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?m -as\\<rightarrow>* m'; \\<forall>c\\<in>set []. valid_edge c;\n   ?m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cs' es.\n                       CFGExit.valid_path_aux cs' es \\<and>\n                       list_all2\n                        (\\<lambda>c c'.\n                            c' =\n                            (Node (sourcenode c), kind c,\n                             Node (targetnode c)))\n                        [] cs' \\<and>\n                       CFGExit.path (Node ?m) es (Node m')\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "from \\<open>m -a # as\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -a # as\\<rightarrow>* m'", "have \"m = sourcenode a\" and \"valid_edge a\"\n        and \"targetnode a -as\\<rightarrow>* m'\""], ["proof (prove)\nusing this:\n  m -a # as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. m = sourcenode a &&& valid_edge a &&& targetnode a -as\\<rightarrow>* m'", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  m = sourcenode a\n  valid_edge a\n  targetnode a -as\\<rightarrow>* m'\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "let ?e = \"(Node (sourcenode a),kind a,Node (targetnode a))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "have \"targetnode a \\<noteq> Exit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> Exit", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. targetnode a = Exit \\<Longrightarrow> False", "assume \"targetnode a = Exit\""], ["proof (state)\nthis:\n  targetnode a = Exit\n\ngoal (1 subgoal):\n 1. targetnode a = Exit \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  targetnode a = Exit", "show False"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  targetnode a = Exit\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_no_return_target)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  targetnode a \\<noteq> Exit\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  targetnode a \\<noteq> Exit", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?e\""], ["proof (prove)\nusing this:\n  valid_edge a\n  targetnode a \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node (sourcenode a), kind a, Node (targetnode a))", "by(fastforce intro:lve_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a), kind a, Node (targetnode a))\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "have \"targetnode a \\<noteq> Entry\""], ["proof (prove)\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> Entry", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. targetnode a = Entry \\<Longrightarrow> False", "assume \"targetnode a = Entry\""], ["proof (state)\nthis:\n  targetnode a = Entry\n\ngoal (1 subgoal):\n 1. targetnode a = Entry \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  targetnode a = Entry", "show False"], ["proof (prove)\nusing this:\n  valid_edge a\n  targetnode a = Entry\n\ngoal (1 subgoal):\n 1. False", "by(rule Entry_target)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  targetnode a \\<noteq> Entry\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "hence \"targetnode a \\<noteq> Entry \\<or> m' \\<noteq> Exit\""], ["proof (prove)\nusing this:\n  targetnode a \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> Entry \\<or> m' \\<noteq> Exit", "by simp"], ["proof (state)\nthis:\n  targetnode a \\<noteq> Entry \\<or> m' \\<noteq> Exit\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "from IH[OF \\<open>targetnode a -as\\<rightarrow>* m'\\<close> _ this]"], ["proof (chain)\npicking this:\n  \\<forall>c\\<in>set []. valid_edge c \\<Longrightarrow>\n  \\<exists>cs' es.\n     CFGExit.valid_path_aux cs' es \\<and>\n     list_all2\n      (\\<lambda>c c'.\n          c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n      [] cs' \\<and>\n     CFGExit.path (Node (targetnode a)) es (Node m')", "obtain es\n        where valid_path:\"CFG.valid_path_aux knd\n        (lift_get_return_edges get_return_edges valid_edge sourcenode\n        targetnode kind) [] es\"\n        and path:\"CFG.path src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        (Node (targetnode a)) es (Node m')\""], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>set []. valid_edge c \\<Longrightarrow>\n  \\<exists>cs' es.\n     CFGExit.valid_path_aux cs' es \\<and>\n     list_all2\n      (\\<lambda>c c'.\n          c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n      [] cs' \\<and>\n     CFGExit.path (Node (targetnode a)) es (Node m')\n\ngoal (1 subgoal):\n 1. (\\<And>es.\n        \\<lbrakk>CFGExit.valid_path_aux [] es;\n         CFGExit.path (Node (targetnode a)) es (Node m')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  CFGExit.valid_path_aux [] es\n  CFGExit.path (Node (targetnode a)) es (Node m')\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "from valid_path \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  CFGExit.valid_path_aux [] es\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"CFG.valid_path_aux knd\n        (lift_get_return_edges get_return_edges valid_edge sourcenode \n        targetnode kind) [] (?e#es)\""], ["proof (prove)\nusing this:\n  CFGExit.valid_path_aux [] es\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. CFGExit.valid_path_aux []\n     ((Node (sourcenode a), kind a, Node (targetnode a)) # es)", "by simp"], ["proof (state)\nthis:\n  CFGExit.valid_path_aux []\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es)\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "moreover"], ["proof (state)\nthis:\n  CFGExit.valid_path_aux []\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es)\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "from path \\<open>m = sourcenode a\\<close> \n        \\<open>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?e\\<close>"], ["proof (chain)\npicking this:\n  CFGExit.path (Node (targetnode a)) es (Node m')\n  m = sourcenode a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a), kind a, Node (targetnode a))", "have \"CFG.path src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        (Node m) (?e#es) (Node m')\""], ["proof (prove)\nusing this:\n  CFGExit.path (Node (targetnode a)) es (Node m')\n  m = sourcenode a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a), kind a, Node (targetnode a))\n\ngoal (1 subgoal):\n 1. CFGExit.path (Node m)\n     ((Node (sourcenode a), kind a, Node (targetnode a)) # es) (Node m')", "by(fastforce intro:CFGExit.Cons_path)"], ["proof (state)\nthis:\n  CFGExit.path (Node m)\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es) (Node m')\n\ngoal (2 subgoals):\n 1. \\<And>cs a as Q p f m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = [];\n        valid_path_aux [] as;\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set []) valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs' es.\n                                CFGExit.valid_path_aux cs' es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 [] cs' \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')\n 2. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "ultimately"], ["proof (chain)\npicking this:\n  CFGExit.valid_path_aux []\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es)\n  CFGExit.path (Node m)\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es) (Node m')", "show ?case"], ["proof (prove)\nusing this:\n  CFGExit.valid_path_aux []\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es)\n  CFGExit.path (Node m)\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es) (Node m')\n\ngoal (1 subgoal):\n 1. \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "using \\<open>cs = []\\<close>"], ["proof (prove)\nusing this:\n  CFGExit.valid_path_aux []\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es)\n  CFGExit.path (Node m)\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es) (Node m')\n  cs = []\n\ngoal (1 subgoal):\n 1. \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "by blast"], ["proof (state)\nthis:\n  \\<exists>cs' es.\n     CFGExit.valid_path_aux cs' es \\<and>\n     list_all2\n      (\\<lambda>c c'.\n          c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n      cs cs' \\<and>\n     CFGExit.path (Node m) es (Node m')\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "case (vpa_ReturnCons cs a as Q p f c' cs')"], ["proof (state)\nthis:\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  cs = c' # cs'\n  valid_path_aux cs' as\n  a \\<in> get_return_edges c'\n  \\<lbrakk>?m -as\\<rightarrow>* m'; \\<forall>a\\<in>set cs'. valid_edge a;\n   ?m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cs'a es.\n                       CFGExit.valid_path_aux cs'a es \\<and>\n                       list_all2\n                        (\\<lambda>c c'.\n                            c' =\n                            (Node (sourcenode c), kind c,\n                             Node (targetnode c)))\n                        cs' cs'a \\<and>\n                       CFGExit.path (Node ?m) es (Node m')\n  m -a # as\\<rightarrow>* m'\n  \\<forall>a\\<in>set cs. valid_edge a\n  m \\<noteq> Entry \\<or> m' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "note IH = \\<open>\\<And>m. \\<lbrakk>m -as\\<rightarrow>* m'; \\<forall>c\\<in>set cs'. valid_edge c; m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk> \\<Longrightarrow>\n        \\<exists>csx es. CFG.valid_path_aux knd\n        (lift_get_return_edges get_return_edges valid_edge sourcenode\n        targetnode kind) csx es \\<and>\n        list_all2 (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c))) \n        cs' csx \\<and> CFG.path src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        (Node m) es (Node m')\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?m -as\\<rightarrow>* m'; \\<forall>c\\<in>set cs'. valid_edge c;\n   ?m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n  \\<Longrightarrow> \\<exists>csx es.\n                       CFGExit.valid_path_aux csx es \\<and>\n                       list_all2\n                        (\\<lambda>c c'.\n                            c' =\n                            (Node (sourcenode c), kind c,\n                             Node (targetnode c)))\n                        cs' csx \\<and>\n                       CFGExit.path (Node ?m) es (Node m')\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "from \\<open>m -a # as\\<rightarrow>* m'\\<close>"], ["proof (chain)\npicking this:\n  m -a # as\\<rightarrow>* m'", "have \"m = sourcenode a\" and \"valid_edge a\"\n        and \"targetnode a -as\\<rightarrow>* m'\""], ["proof (prove)\nusing this:\n  m -a # as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. m = sourcenode a &&& valid_edge a &&& targetnode a -as\\<rightarrow>* m'", "by(auto elim:path_split_Cons)"], ["proof (state)\nthis:\n  m = sourcenode a\n  valid_edge a\n  targetnode a -as\\<rightarrow>* m'\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "from \\<open>\\<forall>c\\<in>set cs. valid_edge c\\<close> \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>c\\<in>set cs. valid_edge c\n  cs = c' # cs'", "have \"valid_edge c'\" and \"\\<forall>c\\<in>set cs'. valid_edge c\""], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>set cs. valid_edge c\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. valid_edge c' &&& \\<forall>c\\<in>set cs'. valid_edge c", "by simp_all"], ["proof (state)\nthis:\n  valid_edge c'\n  \\<forall>c\\<in>set cs'. valid_edge c\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "let ?e = \"(Node (sourcenode a),kind a,Node (targetnode a))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "have \"targetnode a \\<noteq> Exit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> Exit", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. targetnode a = Exit \\<Longrightarrow> False", "assume \"targetnode a = Exit\""], ["proof (state)\nthis:\n  targetnode a = Exit\n\ngoal (1 subgoal):\n 1. targetnode a = Exit \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close> \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  targetnode a = Exit", "show False"], ["proof (prove)\nusing this:\n  valid_edge a\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  targetnode a = Exit\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_no_return_target)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  targetnode a \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  targetnode a \\<noteq> Exit", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?e\""], ["proof (prove)\nusing this:\n  valid_edge a\n  targetnode a \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node (sourcenode a), kind a, Node (targetnode a))", "by(fastforce intro:lve_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a), kind a, Node (targetnode a))\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "have \"targetnode a \\<noteq> Entry\""], ["proof (prove)\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> Entry", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. targetnode a = Entry \\<Longrightarrow> False", "assume \"targetnode a = Entry\""], ["proof (state)\nthis:\n  targetnode a = Entry\n\ngoal (1 subgoal):\n 1. targetnode a = Entry \\<Longrightarrow> False", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  targetnode a = Entry", "show False"], ["proof (prove)\nusing this:\n  valid_edge a\n  targetnode a = Entry\n\ngoal (1 subgoal):\n 1. False", "by(rule Entry_target)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  targetnode a \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "hence \"targetnode a \\<noteq> Entry \\<or> m' \\<noteq> Exit\""], ["proof (prove)\nusing this:\n  targetnode a \\<noteq> Entry\n\ngoal (1 subgoal):\n 1. targetnode a \\<noteq> Entry \\<or> m' \\<noteq> Exit", "by simp"], ["proof (state)\nthis:\n  targetnode a \\<noteq> Entry \\<or> m' \\<noteq> Exit\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "from IH[OF \\<open>targetnode a -as\\<rightarrow>* m'\\<close> \\<open>\\<forall>c\\<in>set cs'. valid_edge c\\<close> this]"], ["proof (chain)\npicking this:\n  \\<exists>csx es.\n     CFGExit.valid_path_aux csx es \\<and>\n     list_all2\n      (\\<lambda>c c'.\n          c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n      cs' csx \\<and>\n     CFGExit.path (Node (targetnode a)) es (Node m')", "obtain csx es\n        where valid_path:\"CFG.valid_path_aux knd\n        (lift_get_return_edges get_return_edges valid_edge sourcenode\n        targetnode kind) csx es\"\n        and list:\"list_all2 \n        (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c))) cs' csx\"\n        and path:\"CFG.path src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        (Node (targetnode a)) es (Node m')\""], ["proof (prove)\nusing this:\n  \\<exists>csx es.\n     CFGExit.valid_path_aux csx es \\<and>\n     list_all2\n      (\\<lambda>c c'.\n          c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n      cs' csx \\<and>\n     CFGExit.path (Node (targetnode a)) es (Node m')\n\ngoal (1 subgoal):\n 1. (\\<And>csx es.\n        \\<lbrakk>CFGExit.valid_path_aux csx es;\n         list_all2\n          (\\<lambda>c c'.\n              c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n          cs' csx;\n         CFGExit.path (Node (targetnode a)) es (Node m')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  CFGExit.valid_path_aux csx es\n  list_all2\n   (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n   cs' csx\n  CFGExit.path (Node (targetnode a)) es (Node m')\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "from \\<open>valid_edge c'\\<close> \\<open>a \\<in> get_return_edges c'\\<close>"], ["proof (chain)\npicking this:\n  valid_edge c'\n  a \\<in> get_return_edges c'", "have \"?e \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n        targetnode kind (Node (sourcenode c'),kind c',Node (targetnode c'))\""], ["proof (prove)\nusing this:\n  valid_edge c'\n  a \\<in> get_return_edges c'\n\ngoal (1 subgoal):\n 1. (Node (sourcenode a), kind a, Node (targetnode a))\n    \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n           targetnode kind\n           (Node (sourcenode c'), kind c', Node (targetnode c'))", "by(fastforce intro:lift_get_return_edgesI)"], ["proof (state)\nthis:\n  (Node (sourcenode a), kind a, Node (targetnode a))\n  \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n         targetnode kind\n         (Node (sourcenode c'), kind c', Node (targetnode c'))\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "with valid_path \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  CFGExit.valid_path_aux csx es\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (Node (sourcenode a), kind a, Node (targetnode a))\n  \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n         targetnode kind\n         (Node (sourcenode c'), kind c', Node (targetnode c'))", "have \"CFG.valid_path_aux knd\n        (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind)\n        ((Node (sourcenode c'),kind c',Node (targetnode c'))#csx) (?e#es)\""], ["proof (prove)\nusing this:\n  CFGExit.valid_path_aux csx es\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  (Node (sourcenode a), kind a, Node (targetnode a))\n  \\<in> lift_get_return_edges get_return_edges valid_edge sourcenode\n         targetnode kind\n         (Node (sourcenode c'), kind c', Node (targetnode c'))\n\ngoal (1 subgoal):\n 1. CFGExit.valid_path_aux\n     ((Node (sourcenode c'), kind c', Node (targetnode c')) # csx)\n     ((Node (sourcenode a), kind a, Node (targetnode a)) # es)", "by simp"], ["proof (state)\nthis:\n  CFGExit.valid_path_aux\n   ((Node (sourcenode c'), kind c', Node (targetnode c')) # csx)\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "moreover"], ["proof (state)\nthis:\n  CFGExit.valid_path_aux\n   ((Node (sourcenode c'), kind c', Node (targetnode c')) # csx)\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "from list \\<open>cs = c' # cs'\\<close>"], ["proof (chain)\npicking this:\n  list_all2\n   (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n   cs' csx\n  cs = c' # cs'", "have \"list_all2 \n        (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c))) cs \n        ((Node (sourcenode c'),kind c',Node (targetnode c'))#csx)\""], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n   cs' csx\n  cs = c' # cs'\n\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>c c'.\n         c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n     cs ((Node (sourcenode c'), kind c', Node (targetnode c')) # csx)", "by simp"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n   cs ((Node (sourcenode c'), kind c', Node (targetnode c')) # csx)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "moreover"], ["proof (state)\nthis:\n  list_all2\n   (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n   cs ((Node (sourcenode c'), kind c', Node (targetnode c')) # csx)\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "from path \\<open>m = sourcenode a\\<close> \n        \\<open>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?e\\<close>"], ["proof (chain)\npicking this:\n  CFGExit.path (Node (targetnode a)) es (Node m')\n  m = sourcenode a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a), kind a, Node (targetnode a))", "have \"CFG.path src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        (Node m) (?e#es) (Node m')\""], ["proof (prove)\nusing this:\n  CFGExit.path (Node (targetnode a)) es (Node m')\n  m = sourcenode a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode a), kind a, Node (targetnode a))\n\ngoal (1 subgoal):\n 1. CFGExit.path (Node m)\n     ((Node (sourcenode a), kind a, Node (targetnode a)) # es) (Node m')", "by(fastforce intro:CFGExit.Cons_path)"], ["proof (state)\nthis:\n  CFGExit.path (Node m)\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es) (Node m')\n\ngoal (1 subgoal):\n 1. \\<And>cs a as Q p f c' cs' m.\n       \\<lbrakk>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f; cs = c' # cs';\n        valid_path_aux cs' as; a \\<in> get_return_edges c';\n        \\<And>m.\n           \\<lbrakk>m -as\\<rightarrow>* m'; Ball (set cs') valid_edge;\n            m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n           \\<Longrightarrow> \\<exists>cs'a es.\n                                CFGExit.valid_path_aux cs'a es \\<and>\n                                list_all2\n                                 (\\<lambda>c c'.\n                                     c' =\n                                     (Node (sourcenode c), kind c,\nNode (targetnode c)))\n                                 cs' cs'a \\<and>\n                                CFGExit.path (Node m) es (Node m');\n        m -a # as\\<rightarrow>* m'; Ball (set cs) valid_edge;\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cs' es.\n                            CFGExit.valid_path_aux cs' es \\<and>\n                            list_all2\n                             (\\<lambda>c c'.\n                                 c' =\n                                 (Node (sourcenode c), kind c,\n                                  Node (targetnode c)))\n                             cs cs' \\<and>\n                            CFGExit.path (Node m) es (Node m')", "ultimately"], ["proof (chain)\npicking this:\n  CFGExit.valid_path_aux\n   ((Node (sourcenode c'), kind c', Node (targetnode c')) # csx)\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es)\n  list_all2\n   (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n   cs ((Node (sourcenode c'), kind c', Node (targetnode c')) # csx)\n  CFGExit.path (Node m)\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es) (Node m')", "show ?case"], ["proof (prove)\nusing this:\n  CFGExit.valid_path_aux\n   ((Node (sourcenode c'), kind c', Node (targetnode c')) # csx)\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es)\n  list_all2\n   (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n   cs ((Node (sourcenode c'), kind c', Node (targetnode c')) # csx)\n  CFGExit.path (Node m)\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es) (Node m')\n\ngoal (1 subgoal):\n 1. \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "using \\<open>kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (prove)\nusing this:\n  CFGExit.valid_path_aux\n   ((Node (sourcenode c'), kind c', Node (targetnode c')) # csx)\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es)\n  list_all2\n   (\\<lambda>c c'. c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n   cs ((Node (sourcenode c'), kind c', Node (targetnode c')) # csx)\n  CFGExit.path (Node m)\n   ((Node (sourcenode a), kind a, Node (targetnode a)) # es) (Node m')\n  kind a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<exists>cs' es.\n       CFGExit.valid_path_aux cs' es \\<and>\n       list_all2\n        (\\<lambda>c c'.\n            c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n        cs cs' \\<and>\n       CFGExit.path (Node m) es (Node m')", "by blast"], ["proof (state)\nthis:\n  \\<exists>cs' es.\n     CFGExit.valid_path_aux cs' es \\<and>\n     list_all2\n      (\\<lambda>c c'.\n          c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n      cs cs' \\<and>\n     CFGExit.path (Node m) es (Node m')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>cs' es.\n     CFGExit.valid_path_aux cs' es \\<and>\n     list_all2\n      (\\<lambda>c c'.\n          c' = (Node (sourcenode c), kind c, Node (targetnode c)))\n      cs cs' \\<and>\n     CFGExit.path (Node m) es (Node m')\n\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "}"], ["proof (state)\nthis:\n  \\<lbrakk>valid_path_aux ?cs2 ?as2; ?m2 -?as2\\<rightarrow>* ?m'2;\n   \\<forall>c\\<in>set ?cs2. valid_edge c;\n   ?m2 \\<noteq> Entry \\<or> ?m'2 \\<noteq> Exit\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cs' es.\n                       CFGExit.valid_path_aux cs' es \\<and>\n                       list_all2\n                        (\\<lambda>c c'.\n                            c' =\n                            (Node (sourcenode c), kind c,\n                             Node (targetnode c)))\n                        ?cs2 cs' \\<and>\n                       CFGExit.path (Node ?m2) es (Node ?m'2)\n\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "hence lift_valid_path:\"\\<And>m as m'. \\<lbrakk>m -as\\<rightarrow>\\<^sub>\\<surd>* m'; m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk> \n    \\<Longrightarrow> \\<exists>es. CFG.CFG.valid_path' src trg knd\n    (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n    (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind)\n    (Node m) es (Node m')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>valid_path_aux ?cs2 ?as2; ?m2 -?as2\\<rightarrow>* ?m'2;\n   \\<forall>c\\<in>set ?cs2. valid_edge c;\n   ?m2 \\<noteq> Entry \\<or> ?m'2 \\<noteq> Exit\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cs' es.\n                       CFGExit.valid_path_aux cs' es \\<and>\n                       list_all2\n                        (\\<lambda>c c'.\n                            c' =\n                            (Node (sourcenode c), kind c,\n                             Node (targetnode c)))\n                        ?cs2 cs' \\<and>\n                       CFGExit.path (Node ?m2) es (Node ?m'2)\n\ngoal (1 subgoal):\n 1. \\<And>m as m'.\n       \\<lbrakk>m -as\\<rightarrow>\\<^sub>\\<surd>* m';\n        m \\<noteq> Entry \\<or> m' \\<noteq> Exit\\<rbrakk>\n       \\<Longrightarrow> \\<exists>es.\n                            CFGExit.valid_path' (Node m) es (Node m')", "by(fastforce simp:vp_def valid_path_def CFGExit.vp_def CFGExit.valid_path_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?m -?as\\<rightarrow>\\<^sub>\\<surd>* ?m';\n   ?m \\<noteq> Entry \\<or> ?m' \\<noteq> Exit\\<rbrakk>\n  \\<Longrightarrow> \\<exists>es. CFGExit.valid_path' (Node ?m) es (Node ?m')\n\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n.\n       CFGExit.valid_node n \\<Longrightarrow>\n       \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. \\<And>n.\n       CFGExit.valid_node n \\<Longrightarrow>\n       \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. \\<And>n n'.\n       \\<lbrakk>local.CFGExit.method_exit n; local.CFGExit.method_exit n';\n        lift_get_proc get_proc Main n =\n        lift_get_proc get_proc Main n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "fix n"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n.\n       CFGExit.valid_node n \\<Longrightarrow>\n       \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. \\<And>n.\n       CFGExit.valid_node n \\<Longrightarrow>\n       \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. \\<And>n n'.\n       \\<lbrakk>local.CFGExit.method_exit n; local.CFGExit.method_exit n';\n        lift_get_proc get_proc Main n =\n        lift_get_proc get_proc Main n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "assume \"CFG.CFG.valid_node src trg\n      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) n\""], ["proof (state)\nthis:\n  CFGExit.valid_node n\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       CFGExit.valid_node n \\<Longrightarrow>\n       \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. \\<And>n.\n       CFGExit.valid_node n \\<Longrightarrow>\n       \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. \\<And>n n'.\n       \\<lbrakk>local.CFGExit.method_exit n; local.CFGExit.method_exit n';\n        lift_get_proc get_proc Main n =\n        lift_get_proc get_proc Main n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "hence \"((n = NewEntry) \\<or> n = NewExit) \\<or> (\\<exists>m. n = Node m \\<and> valid_node m)\""], ["proof (prove)\nusing this:\n  CFGExit.valid_node n\n\ngoal (1 subgoal):\n 1. (n = NewEntry \\<or> n = NewExit) \\<or>\n    (\\<exists>m. n = Node m \\<and> valid_node m)", "by(auto elim:lift_valid_edge.cases simp:CFGExit.valid_node_def)"], ["proof (state)\nthis:\n  (n = NewEntry \\<or> n = NewExit) \\<or>\n  (\\<exists>m. n = Node m \\<and> valid_node m)\n\ngoal (3 subgoals):\n 1. \\<And>n.\n       CFGExit.valid_node n \\<Longrightarrow>\n       \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. \\<And>n.\n       CFGExit.valid_node n \\<Longrightarrow>\n       \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. \\<And>n n'.\n       \\<lbrakk>local.CFGExit.method_exit n; local.CFGExit.method_exit n';\n        lift_get_proc get_proc Main n =\n        lift_get_proc get_proc Main n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "thus \"\\<exists>as. CFG.CFG.valid_path' src trg knd\n      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n      (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind)\n      NewEntry as n\""], ["proof (prove)\nusing this:\n  (n = NewEntry \\<or> n = NewExit) \\<or>\n  (\\<exists>m. n = Node m \\<and> valid_node m)\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit.valid_path' NewEntry as n", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n = NewEntry \\<or> n = NewExit) \\<or>\n    (\\<exists>m. n = Node m \\<and> valid_node m) \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "proof(erule disjE)+"], ["proof (state)\ngoal (3 subgoals):\n 1. n = NewEntry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. n = NewExit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 3. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "assume \"n = NewEntry\""], ["proof (state)\nthis:\n  n = NewEntry\n\ngoal (3 subgoals):\n 1. n = NewEntry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. n = NewExit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 3. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "hence \"CFG.CFG.valid_path' src trg knd\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind)\n        NewEntry [] n\""], ["proof (prove)\nusing this:\n  n = NewEntry\n\ngoal (1 subgoal):\n 1. CFGExit.valid_path' NewEntry [] n", "by(fastforce intro:CFGExit.empty_path \n          simp:CFGExit.vp_def CFGExit.valid_path_def)"], ["proof (state)\nthis:\n  CFGExit.valid_path' NewEntry [] n\n\ngoal (3 subgoals):\n 1. n = NewEntry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. n = NewExit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 3. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFGExit.valid_path' NewEntry [] n\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit.valid_path' NewEntry as n", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit.valid_path' NewEntry as n\n\ngoal (2 subgoals):\n 1. n = NewExit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. n = NewExit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "assume \"n = NewExit\""], ["proof (state)\nthis:\n  n = NewExit\n\ngoal (2 subgoals):\n 1. n = NewExit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        (NewEntry,(\\<lambda>s. False)\\<^sub>\\<surd>,NewExit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)", "by(fastforce intro:lve_Entry_Exit_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n\ngoal (2 subgoals):\n 1. n = NewExit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "hence \"CFG.CFG.path src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewEntry [(NewEntry,(\\<lambda>s. False)\\<^sub>\\<surd>,NewExit)] NewExit\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n\ngoal (1 subgoal):\n 1. CFGExit.path NewEntry\n     [(NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)] NewExit", "by(fastforce dest:CFGExit.path_edge)"], ["proof (state)\nthis:\n  CFGExit.path NewEntry\n   [(NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)] NewExit\n\ngoal (2 subgoals):\n 1. n = NewExit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "with \\<open>n = NewExit\\<close>"], ["proof (chain)\npicking this:\n  n = NewExit\n  CFGExit.path NewEntry\n   [(NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)] NewExit", "have \"CFG.CFG.valid_path' src trg knd\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind)\n        NewEntry [(NewEntry,(\\<lambda>s. False)\\<^sub>\\<surd>,NewExit)] n\""], ["proof (prove)\nusing this:\n  n = NewExit\n  CFGExit.path NewEntry\n   [(NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)] NewExit\n\ngoal (1 subgoal):\n 1. CFGExit.valid_path' NewEntry\n     [(NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)] n", "by(fastforce simp:CFGExit.vp_def CFGExit.valid_path_def)"], ["proof (state)\nthis:\n  CFGExit.valid_path' NewEntry\n   [(NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)] n\n\ngoal (2 subgoals):\n 1. n = NewExit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFGExit.valid_path' NewEntry\n   [(NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)] n\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit.valid_path' NewEntry as n", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit.valid_path' NewEntry as n\n\ngoal (1 subgoal):\n 1. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "assume \"\\<exists>m. n = Node m \\<and> valid_node m\""], ["proof (state)\nthis:\n  \\<exists>m. n = Node m \\<and> valid_node m\n\ngoal (1 subgoal):\n 1. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "then"], ["proof (chain)\npicking this:\n  \\<exists>m. n = Node m \\<and> valid_node m", "obtain m where \"n = Node m\" and \"valid_node m\""], ["proof (prove)\nusing this:\n  \\<exists>m. n = Node m \\<and> valid_node m\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>n = Node m; valid_node m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n = Node m\n  valid_node m\n\ngoal (1 subgoal):\n 1. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "from \\<open>valid_node m\\<close>"], ["proof (chain)\npicking this:\n  valid_node m", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_node m\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit.valid_path' NewEntry as n", "proof(cases m rule:valid_node_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. m = Exit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 3. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "case Entry"], ["proof (state)\nthis:\n  m = Entry\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. m = Exit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 3. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          (NewEntry,(\\<lambda>s. True)\\<^sub>\\<surd>,Node Entry)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)", "by(fastforce intro:lve_Entry_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. m = Exit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 3. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "with \\<open>m = Entry\\<close> \\<open>n = Node m\\<close>"], ["proof (chain)\npicking this:\n  m = Entry\n  n = Node m\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)", "have \"CFG.CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          NewEntry [(NewEntry,(\\<lambda>s. True)\\<^sub>\\<surd>,Node Entry)] n\""], ["proof (prove)\nusing this:\n  m = Entry\n  n = Node m\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n\ngoal (1 subgoal):\n 1. CFGExit.path NewEntry\n     [(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] n", "by(fastforce intro:CFGExit.Cons_path CFGExit.empty_path\n                       simp:CFGExit.valid_node_def)"], ["proof (state)\nthis:\n  CFGExit.path NewEntry\n   [(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] n\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. m = Exit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 3. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFGExit.path NewEntry\n   [(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] n\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit.valid_path' NewEntry as n", "by(fastforce simp:CFGExit.vp_def CFGExit.valid_path_def)"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit.valid_path' NewEntry as n\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "case Exit"], ["proof (state)\nthis:\n  m = Exit\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "from inner"], ["proof (chain)\npicking this:\n  inner_node nx", "obtain ax where \"valid_edge ax\" and \"intra_kind (kind ax)\"\n          and \"inner_node (sourcenode ax)\"\n          and \"targetnode ax = Exit\""], ["proof (prove)\nusing this:\n  inner_node nx\n\ngoal (1 subgoal):\n 1. (\\<And>ax.\n        \\<lbrakk>valid_edge ax; intra_kind (kind ax);\n         inner_node (sourcenode ax); targetnode ax = Exit\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule inner_node_Exit_edge)"], ["proof (state)\nthis:\n  valid_edge ax\n  intra_kind (kind ax)\n  inner_node (sourcenode ax)\n  targetnode ax = Exit\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "hence \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          (Node (sourcenode ax),kind ax,Node Exit)\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  intra_kind (kind ax)\n  inner_node (sourcenode ax)\n  targetnode ax = Exit\n\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node (sourcenode ax), kind ax, Node Exit)", "by(auto intro:lift_valid_edge.lve_edge simp:inner_node_def)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode ax), kind ax, Node Exit)\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "hence \"CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (Node (sourcenode ax)) [(Node (sourcenode ax),kind ax,Node Exit)] \n          (Node Exit)\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node (sourcenode ax), kind ax, Node Exit)\n\ngoal (1 subgoal):\n 1. CFGExit.path (Node (sourcenode ax))\n     [(Node (sourcenode ax), kind ax, Node Exit)] (Node Exit)", "by(fastforce intro:CFGExit.Cons_path CFGExit.empty_path\n                       simp:CFGExit.valid_node_def)"], ["proof (state)\nthis:\n  CFGExit.path (Node (sourcenode ax))\n   [(Node (sourcenode ax), kind ax, Node Exit)] (Node Exit)\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "with \\<open>intra_kind (kind ax)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind ax)\n  CFGExit.path (Node (sourcenode ax))\n   [(Node (sourcenode ax), kind ax, Node Exit)] (Node Exit)", "have slp_edge:\"CFG.CFG.same_level_path' src trg knd\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (lift_get_return_edges get_return_edges valid_edge sourcenode \n          targetnode kind)\n          (Node (sourcenode ax)) [(Node (sourcenode ax),kind ax,Node Exit)] \n          (Node Exit)\""], ["proof (prove)\nusing this:\n  intra_kind (kind ax)\n  CFGExit.path (Node (sourcenode ax))\n   [(Node (sourcenode ax), kind ax, Node Exit)] (Node Exit)\n\ngoal (1 subgoal):\n 1. CFGExit.same_level_path' (Node (sourcenode ax))\n     [(Node (sourcenode ax), kind ax, Node Exit)] (Node Exit)", "by(fastforce simp:CFGExit.slp_def CFGExit.same_level_path_def \n            intra_kind_def)"], ["proof (state)\nthis:\n  CFGExit.same_level_path' (Node (sourcenode ax))\n   [(Node (sourcenode ax), kind ax, Node Exit)] (Node Exit)\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "have \"sourcenode ax \\<noteq> Exit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sourcenode ax \\<noteq> Exit", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. sourcenode ax = Exit \\<Longrightarrow> False", "assume \"sourcenode ax = Exit\""], ["proof (state)\nthis:\n  sourcenode ax = Exit\n\ngoal (1 subgoal):\n 1. sourcenode ax = Exit \\<Longrightarrow> False", "with \\<open>valid_edge ax\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  sourcenode ax = Exit", "show False"], ["proof (prove)\nusing this:\n  valid_edge ax\n  sourcenode ax = Exit\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sourcenode ax \\<noteq> Exit\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          (NewEntry,(\\<lambda>s. True)\\<^sub>\\<surd>,Node Entry)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)", "by(fastforce intro:lve_Entry_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "hence \"CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (NewEntry) [(NewEntry,(\\<lambda>s. True)\\<^sub>\\<surd>,Node Entry)] (Node Entry)\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n\ngoal (1 subgoal):\n 1. CFGExit.path NewEntry\n     [(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] (Node Entry)", "by(fastforce intro:CFGExit.Cons_path CFGExit.empty_path\n                       simp:CFGExit.valid_node_def)"], ["proof (state)\nthis:\n  CFGExit.path NewEntry\n   [(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] (Node Entry)\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "hence slp_edge':\"CFG.CFG.same_level_path' src trg knd\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (lift_get_return_edges get_return_edges valid_edge sourcenode \n          targetnode kind)\n          (NewEntry) [(NewEntry,(\\<lambda>s. True)\\<^sub>\\<surd>,Node Entry)] (Node Entry)\""], ["proof (prove)\nusing this:\n  CFGExit.path NewEntry\n   [(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] (Node Entry)\n\ngoal (1 subgoal):\n 1. CFGExit.same_level_path' NewEntry\n     [(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] (Node Entry)", "by(fastforce simp:CFGExit.slp_def CFGExit.same_level_path_def)"], ["proof (state)\nthis:\n  CFGExit.same_level_path' NewEntry\n   [(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] (Node Entry)\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "from \\<open>inner_node (sourcenode ax)\\<close>"], ["proof (chain)\npicking this:\n  inner_node (sourcenode ax)", "have \"valid_node (sourcenode ax)\""], ["proof (prove)\nusing this:\n  inner_node (sourcenode ax)\n\ngoal (1 subgoal):\n 1. valid_node (sourcenode ax)", "by(rule inner_is_valid)"], ["proof (state)\nthis:\n  valid_node (sourcenode ax)\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "then"], ["proof (chain)\npicking this:\n  valid_node (sourcenode ax)", "obtain asx where \"Entry -asx\\<rightarrow>\\<^sub>\\<surd>* sourcenode ax\""], ["proof (prove)\nusing this:\n  valid_node (sourcenode ax)\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        Entry -asx\\<rightarrow>\\<^sub>\\<surd>* sourcenode\n          ax \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:Entry_path)"], ["proof (state)\nthis:\n  Entry -asx\\<rightarrow>\\<^sub>\\<surd>* sourcenode ax\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "with \\<open>sourcenode ax \\<noteq> Exit\\<close>"], ["proof (chain)\npicking this:\n  sourcenode ax \\<noteq> Exit\n  Entry -asx\\<rightarrow>\\<^sub>\\<surd>* sourcenode ax", "have \"\\<exists>es. CFG.CFG.valid_path' src trg knd\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (lift_get_return_edges get_return_edges valid_edge sourcenode \n          targetnode kind) (Node Entry) es (Node (sourcenode ax))\""], ["proof (prove)\nusing this:\n  sourcenode ax \\<noteq> Exit\n  Entry -asx\\<rightarrow>\\<^sub>\\<surd>* sourcenode ax\n\ngoal (1 subgoal):\n 1. \\<exists>es. CFGExit.valid_path' (Node Entry) es (Node (sourcenode ax))", "by(fastforce intro:lift_valid_path)"], ["proof (state)\nthis:\n  \\<exists>es. CFGExit.valid_path' (Node Entry) es (Node (sourcenode ax))\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "then"], ["proof (chain)\npicking this:\n  \\<exists>es. CFGExit.valid_path' (Node Entry) es (Node (sourcenode ax))", "obtain es where \"CFG.CFG.valid_path' src trg knd\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (lift_get_return_edges get_return_edges valid_edge sourcenode \n          targetnode kind) (Node Entry) es (Node (sourcenode ax))\""], ["proof (prove)\nusing this:\n  \\<exists>es. CFGExit.valid_path' (Node Entry) es (Node (sourcenode ax))\n\ngoal (1 subgoal):\n 1. (\\<And>es.\n        CFGExit.valid_path' (Node Entry) es\n         (Node (sourcenode ax)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  CFGExit.valid_path' (Node Entry) es (Node (sourcenode ax))\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "with slp_edge"], ["proof (chain)\npicking this:\n  CFGExit.same_level_path' (Node (sourcenode ax))\n   [(Node (sourcenode ax), kind ax, Node Exit)] (Node Exit)\n  CFGExit.valid_path' (Node Entry) es (Node (sourcenode ax))", "have \"CFG.CFG.valid_path' src trg knd\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (lift_get_return_edges get_return_edges valid_edge sourcenode \n          targetnode kind) \n          (Node Entry) (es@[(Node (sourcenode ax),kind ax,Node Exit)]) (Node Exit)\""], ["proof (prove)\nusing this:\n  CFGExit.same_level_path' (Node (sourcenode ax))\n   [(Node (sourcenode ax), kind ax, Node Exit)] (Node Exit)\n  CFGExit.valid_path' (Node Entry) es (Node (sourcenode ax))\n\ngoal (1 subgoal):\n 1. CFGExit.valid_path' (Node Entry)\n     (es @ [(Node (sourcenode ax), kind ax, Node Exit)]) (Node Exit)", "by -(rule CFGExit.vp_slp_Append)"], ["proof (state)\nthis:\n  CFGExit.valid_path' (Node Entry)\n   (es @ [(Node (sourcenode ax), kind ax, Node Exit)]) (Node Exit)\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "with slp_edge'"], ["proof (chain)\npicking this:\n  CFGExit.same_level_path' NewEntry\n   [(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] (Node Entry)\n  CFGExit.valid_path' (Node Entry)\n   (es @ [(Node (sourcenode ax), kind ax, Node Exit)]) (Node Exit)", "have \"CFG.CFG.valid_path' src trg knd\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (lift_get_return_edges get_return_edges valid_edge sourcenode \n          targetnode kind) NewEntry\n          ([(NewEntry,(\\<lambda>s. True)\\<^sub>\\<surd>,Node Entry)]@\n          (es@[(Node (sourcenode ax),kind ax,Node Exit)])) (Node Exit)\""], ["proof (prove)\nusing this:\n  CFGExit.same_level_path' NewEntry\n   [(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] (Node Entry)\n  CFGExit.valid_path' (Node Entry)\n   (es @ [(Node (sourcenode ax), kind ax, Node Exit)]) (Node Exit)\n\ngoal (1 subgoal):\n 1. CFGExit.valid_path' NewEntry\n     ([(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] @\n      es @ [(Node (sourcenode ax), kind ax, Node Exit)])\n     (Node Exit)", "by(rule CFGExit.slp_vp_Append)"], ["proof (state)\nthis:\n  CFGExit.valid_path' NewEntry\n   ([(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] @\n    es @ [(Node (sourcenode ax), kind ax, Node Exit)])\n   (Node Exit)\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "with \\<open>m = Exit\\<close> \\<open>n = Node m\\<close>"], ["proof (chain)\npicking this:\n  m = Exit\n  n = Node m\n  CFGExit.valid_path' NewEntry\n   ([(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] @\n    es @ [(Node (sourcenode ax), kind ax, Node Exit)])\n   (Node Exit)", "show ?thesis"], ["proof (prove)\nusing this:\n  m = Exit\n  n = Node m\n  CFGExit.valid_path' NewEntry\n   ([(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] @\n    es @ [(Node (sourcenode ax), kind ax, Node Exit)])\n   (Node Exit)\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit.valid_path' NewEntry as n", "by simp blast"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit.valid_path' NewEntry as n\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "case inner"], ["proof (state)\nthis:\n  inner_node m\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          (NewEntry,(\\<lambda>s. True)\\<^sub>\\<surd>,Node Entry)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)", "by(fastforce intro:lve_Entry_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "hence \"CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (NewEntry) [(NewEntry,(\\<lambda>s. True)\\<^sub>\\<surd>,Node Entry)] (Node Entry)\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)\n\ngoal (1 subgoal):\n 1. CFGExit.path NewEntry\n     [(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] (Node Entry)", "by(fastforce intro:CFGExit.Cons_path CFGExit.empty_path\n                       simp:CFGExit.valid_node_def)"], ["proof (state)\nthis:\n  CFGExit.path NewEntry\n   [(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] (Node Entry)\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "hence slp_edge:\"CFG.CFG.same_level_path' src trg knd\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (lift_get_return_edges get_return_edges valid_edge sourcenode \n          targetnode kind)\n          (NewEntry) [(NewEntry,(\\<lambda>s. True)\\<^sub>\\<surd>,Node Entry)] (Node Entry)\""], ["proof (prove)\nusing this:\n  CFGExit.path NewEntry\n   [(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] (Node Entry)\n\ngoal (1 subgoal):\n 1. CFGExit.same_level_path' NewEntry\n     [(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] (Node Entry)", "by(fastforce simp:CFGExit.slp_def CFGExit.same_level_path_def)"], ["proof (state)\nthis:\n  CFGExit.same_level_path' NewEntry\n   [(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] (Node Entry)\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "from \\<open>valid_node m\\<close>"], ["proof (chain)\npicking this:\n  valid_node m", "obtain as where \"Entry -as\\<rightarrow>\\<^sub>\\<surd>* m\""], ["proof (prove)\nusing this:\n  valid_node m\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        Entry -as\\<rightarrow>\\<^sub>\\<surd>* m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:Entry_path)"], ["proof (state)\nthis:\n  Entry -as\\<rightarrow>\\<^sub>\\<surd>* m\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "with \\<open>inner_node m\\<close>"], ["proof (chain)\npicking this:\n  inner_node m\n  Entry -as\\<rightarrow>\\<^sub>\\<surd>* m", "have \"\\<exists>es. CFG.CFG.valid_path' src trg knd\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (lift_get_return_edges get_return_edges valid_edge sourcenode \n          targetnode kind) (Node Entry) es (Node m)\""], ["proof (prove)\nusing this:\n  inner_node m\n  Entry -as\\<rightarrow>\\<^sub>\\<surd>* m\n\ngoal (1 subgoal):\n 1. \\<exists>es. CFGExit.valid_path' (Node Entry) es (Node m)", "by(fastforce intro:lift_valid_path simp:inner_node_def)"], ["proof (state)\nthis:\n  \\<exists>es. CFGExit.valid_path' (Node Entry) es (Node m)\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "then"], ["proof (chain)\npicking this:\n  \\<exists>es. CFGExit.valid_path' (Node Entry) es (Node m)", "obtain es where \"CFG.CFG.valid_path' src trg knd\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (lift_get_return_edges get_return_edges valid_edge sourcenode \n          targetnode kind) (Node Entry) es (Node m)\""], ["proof (prove)\nusing this:\n  \\<exists>es. CFGExit.valid_path' (Node Entry) es (Node m)\n\ngoal (1 subgoal):\n 1. (\\<And>es.\n        CFGExit.valid_path' (Node Entry) es (Node m) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  CFGExit.valid_path' (Node Entry) es (Node m)\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "with slp_edge"], ["proof (chain)\npicking this:\n  CFGExit.same_level_path' NewEntry\n   [(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] (Node Entry)\n  CFGExit.valid_path' (Node Entry) es (Node m)", "have \"CFG.CFG.valid_path' src trg knd\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (lift_get_return_edges get_return_edges valid_edge sourcenode \n          targetnode kind) NewEntry ([(NewEntry,(\\<lambda>s. True)\\<^sub>\\<surd>,Node Entry)]@es) (Node m)\""], ["proof (prove)\nusing this:\n  CFGExit.same_level_path' NewEntry\n   [(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] (Node Entry)\n  CFGExit.valid_path' (Node Entry) es (Node m)\n\ngoal (1 subgoal):\n 1. CFGExit.valid_path' NewEntry\n     ([(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] @ es)\n     (Node m)", "by(rule CFGExit.slp_vp_Append)"], ["proof (state)\nthis:\n  CFGExit.valid_path' NewEntry\n   ([(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] @ es)\n   (Node m)\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' NewEntry as n", "with \\<open>n = Node m\\<close>"], ["proof (chain)\npicking this:\n  n = Node m\n  CFGExit.valid_path' NewEntry\n   ([(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] @ es)\n   (Node m)", "show ?thesis"], ["proof (prove)\nusing this:\n  n = Node m\n  CFGExit.valid_path' NewEntry\n   ([(NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry)] @ es)\n   (Node m)\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit.valid_path' NewEntry as n", "by simp blast"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit.valid_path' NewEntry as n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit.valid_path' NewEntry as n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit.valid_path' NewEntry as n\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       CFGExit.valid_node n \\<Longrightarrow>\n       \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. \\<And>n n'.\n       \\<lbrakk>local.CFGExit.method_exit n; local.CFGExit.method_exit n';\n        lift_get_proc get_proc Main n =\n        lift_get_proc get_proc Main n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       CFGExit.valid_node n \\<Longrightarrow>\n       \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. \\<And>n n'.\n       \\<lbrakk>local.CFGExit.method_exit n; local.CFGExit.method_exit n';\n        lift_get_proc get_proc Main n =\n        lift_get_proc get_proc Main n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "fix n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       CFGExit.valid_node n \\<Longrightarrow>\n       \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. \\<And>n n'.\n       \\<lbrakk>local.CFGExit.method_exit n; local.CFGExit.method_exit n';\n        lift_get_proc get_proc Main n =\n        lift_get_proc get_proc Main n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "assume \"CFG.CFG.valid_node src trg\n      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) n\""], ["proof (state)\nthis:\n  CFGExit.valid_node n\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       CFGExit.valid_node n \\<Longrightarrow>\n       \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. \\<And>n n'.\n       \\<lbrakk>local.CFGExit.method_exit n; local.CFGExit.method_exit n';\n        lift_get_proc get_proc Main n =\n        lift_get_proc get_proc Main n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "hence \"((n = NewEntry) \\<or> n = NewExit) \\<or> (\\<exists>m. n = Node m \\<and> valid_node m)\""], ["proof (prove)\nusing this:\n  CFGExit.valid_node n\n\ngoal (1 subgoal):\n 1. (n = NewEntry \\<or> n = NewExit) \\<or>\n    (\\<exists>m. n = Node m \\<and> valid_node m)", "by(auto elim:lift_valid_edge.cases simp:CFGExit.valid_node_def)"], ["proof (state)\nthis:\n  (n = NewEntry \\<or> n = NewExit) \\<or>\n  (\\<exists>m. n = Node m \\<and> valid_node m)\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       CFGExit.valid_node n \\<Longrightarrow>\n       \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. \\<And>n n'.\n       \\<lbrakk>local.CFGExit.method_exit n; local.CFGExit.method_exit n';\n        lift_get_proc get_proc Main n =\n        lift_get_proc get_proc Main n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "thus \"\\<exists>as. CFG.CFG.valid_path' src trg knd\n      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n      (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind)\n      n as NewExit\""], ["proof (prove)\nusing this:\n  (n = NewEntry \\<or> n = NewExit) \\<or>\n  (\\<exists>m. n = Node m \\<and> valid_node m)\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit.valid_path' n as NewExit", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. (n = NewEntry \\<or> n = NewExit) \\<or>\n    (\\<exists>m. n = Node m \\<and> valid_node m) \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "proof(erule disjE)+"], ["proof (state)\ngoal (3 subgoals):\n 1. n = NewEntry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. n = NewExit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "assume \"n = NewEntry\""], ["proof (state)\nthis:\n  n = NewEntry\n\ngoal (3 subgoals):\n 1. n = NewEntry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. n = NewExit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n        (NewEntry,(\\<lambda>s. False)\\<^sub>\\<surd>,NewExit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)", "by(fastforce intro:lve_Entry_Exit_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n\ngoal (3 subgoals):\n 1. n = NewEntry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. n = NewExit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "hence \"CFG.CFG.path src trg\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        NewEntry [(NewEntry,(\\<lambda>s. False)\\<^sub>\\<surd>,NewExit)] NewExit\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)\n\ngoal (1 subgoal):\n 1. CFGExit.path NewEntry\n     [(NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)] NewExit", "by(fastforce dest:CFGExit.path_edge)"], ["proof (state)\nthis:\n  CFGExit.path NewEntry\n   [(NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)] NewExit\n\ngoal (3 subgoals):\n 1. n = NewEntry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. n = NewExit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "with \\<open>n = NewEntry\\<close>"], ["proof (chain)\npicking this:\n  n = NewEntry\n  CFGExit.path NewEntry\n   [(NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)] NewExit", "have \"CFG.CFG.valid_path' src trg knd\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind)\n        n [(NewEntry,(\\<lambda>s. False)\\<^sub>\\<surd>,NewExit)] NewExit\""], ["proof (prove)\nusing this:\n  n = NewEntry\n  CFGExit.path NewEntry\n   [(NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)] NewExit\n\ngoal (1 subgoal):\n 1. CFGExit.valid_path' n\n     [(NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)] NewExit", "by(fastforce simp:CFGExit.vp_def CFGExit.valid_path_def)"], ["proof (state)\nthis:\n  CFGExit.valid_path' n\n   [(NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)] NewExit\n\ngoal (3 subgoals):\n 1. n = NewEntry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. n = NewExit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFGExit.valid_path' n\n   [(NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit)] NewExit\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit.valid_path' n as NewExit", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit.valid_path' n as NewExit\n\ngoal (2 subgoals):\n 1. n = NewExit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. n = NewExit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "assume \"n = NewExit\""], ["proof (state)\nthis:\n  n = NewExit\n\ngoal (2 subgoals):\n 1. n = NewExit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "hence \"CFG.CFG.valid_path' src trg knd\n        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n        (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind)\n        n [] NewExit\""], ["proof (prove)\nusing this:\n  n = NewExit\n\ngoal (1 subgoal):\n 1. CFGExit.valid_path' n [] NewExit", "by(fastforce intro:CFGExit.empty_path \n          simp:CFGExit.vp_def CFGExit.valid_path_def)"], ["proof (state)\nthis:\n  CFGExit.valid_path' n [] NewExit\n\ngoal (2 subgoals):\n 1. n = NewExit \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFGExit.valid_path' n [] NewExit\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit.valid_path' n as NewExit", "by blast"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit.valid_path' n as NewExit\n\ngoal (1 subgoal):\n 1. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "assume \"\\<exists>m. n = Node m \\<and> valid_node m\""], ["proof (state)\nthis:\n  \\<exists>m. n = Node m \\<and> valid_node m\n\ngoal (1 subgoal):\n 1. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "then"], ["proof (chain)\npicking this:\n  \\<exists>m. n = Node m \\<and> valid_node m", "obtain m where \"n = Node m\" and \"valid_node m\""], ["proof (prove)\nusing this:\n  \\<exists>m. n = Node m \\<and> valid_node m\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>n = Node m; valid_node m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n = Node m\n  valid_node m\n\ngoal (1 subgoal):\n 1. \\<exists>m. n = Node m \\<and> valid_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "from \\<open>valid_node m\\<close>"], ["proof (chain)\npicking this:\n  valid_node m", "show ?thesis"], ["proof (prove)\nusing this:\n  valid_node m\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit.valid_path' n as NewExit", "proof(cases m rule:valid_node_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "case Entry"], ["proof (state)\nthis:\n  m = Entry\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "from inner"], ["proof (chain)\npicking this:\n  inner_node nx", "obtain ax where \"valid_edge ax\" and \"intra_kind (kind ax)\"\n          and \"inner_node (targetnode ax)\" and \"sourcenode ax = Entry\""], ["proof (prove)\nusing this:\n  inner_node nx\n\ngoal (1 subgoal):\n 1. (\\<And>ax.\n        \\<lbrakk>valid_edge ax; intra_kind (kind ax);\n         inner_node (targetnode ax); sourcenode ax = Entry\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(erule inner_node_Entry_edge)"], ["proof (state)\nthis:\n  valid_edge ax\n  intra_kind (kind ax)\n  inner_node (targetnode ax)\n  sourcenode ax = Entry\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "hence \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          (Node Entry,kind ax,Node (targetnode ax))\""], ["proof (prove)\nusing this:\n  valid_edge ax\n  intra_kind (kind ax)\n  inner_node (targetnode ax)\n  sourcenode ax = Entry\n\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node Entry, kind ax, Node (targetnode ax))", "by(auto intro:lift_valid_edge.lve_edge simp:inner_node_def)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node Entry, kind ax, Node (targetnode ax))\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "hence \"CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (Node Entry) [(Node Entry,kind ax,Node (targetnode ax))] \n          (Node (targetnode ax))\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node Entry, kind ax, Node (targetnode ax))\n\ngoal (1 subgoal):\n 1. CFGExit.path (Node Entry) [(Node Entry, kind ax, Node (targetnode ax))]\n     (Node (targetnode ax))", "by(fastforce intro:CFGExit.Cons_path CFGExit.empty_path\n                       simp:CFGExit.valid_node_def)"], ["proof (state)\nthis:\n  CFGExit.path (Node Entry) [(Node Entry, kind ax, Node (targetnode ax))]\n   (Node (targetnode ax))\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "with \\<open>intra_kind (kind ax)\\<close>"], ["proof (chain)\npicking this:\n  intra_kind (kind ax)\n  CFGExit.path (Node Entry) [(Node Entry, kind ax, Node (targetnode ax))]\n   (Node (targetnode ax))", "have slp_edge:\"CFG.CFG.same_level_path' src trg knd\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (lift_get_return_edges get_return_edges valid_edge sourcenode \n          targetnode kind)\n          (Node Entry) [(Node Entry,kind ax,Node (targetnode ax))] \n          (Node (targetnode ax))\""], ["proof (prove)\nusing this:\n  intra_kind (kind ax)\n  CFGExit.path (Node Entry) [(Node Entry, kind ax, Node (targetnode ax))]\n   (Node (targetnode ax))\n\ngoal (1 subgoal):\n 1. CFGExit.same_level_path' (Node Entry)\n     [(Node Entry, kind ax, Node (targetnode ax))] (Node (targetnode ax))", "by(fastforce simp:CFGExit.slp_def CFGExit.same_level_path_def \n            intra_kind_def)"], ["proof (state)\nthis:\n  CFGExit.same_level_path' (Node Entry)\n   [(Node Entry, kind ax, Node (targetnode ax))] (Node (targetnode ax))\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "have \"targetnode ax \\<noteq> Entry\""], ["proof (prove)\ngoal (1 subgoal):\n 1. targetnode ax \\<noteq> Entry", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. targetnode ax = Entry \\<Longrightarrow> False", "assume \"targetnode ax = Entry\""], ["proof (state)\nthis:\n  targetnode ax = Entry\n\ngoal (1 subgoal):\n 1. targetnode ax = Entry \\<Longrightarrow> False", "with \\<open>valid_edge ax\\<close>"], ["proof (chain)\npicking this:\n  valid_edge ax\n  targetnode ax = Entry", "show False"], ["proof (prove)\nusing this:\n  valid_edge ax\n  targetnode ax = Entry\n\ngoal (1 subgoal):\n 1. False", "by(rule Entry_target)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  targetnode ax \\<noteq> Entry\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          (Node Exit,(\\<lambda>s. True)\\<^sub>\\<surd>,NewExit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)", "by(fastforce intro:lve_Exit_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "hence \"CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (Node Exit) [(Node Exit,(\\<lambda>s. True)\\<^sub>\\<surd>,NewExit)] NewExit\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n\ngoal (1 subgoal):\n 1. CFGExit.path (Node Exit)\n     [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)] NewExit", "by(fastforce intro:CFGExit.Cons_path CFGExit.empty_path\n                       simp:CFGExit.valid_node_def)"], ["proof (state)\nthis:\n  CFGExit.path (Node Exit)\n   [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)] NewExit\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "hence slp_edge':\"CFG.CFG.same_level_path' src trg knd\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (lift_get_return_edges get_return_edges valid_edge sourcenode \n          targetnode kind)\n          (Node Exit) [(Node Exit,(\\<lambda>s. True)\\<^sub>\\<surd>,NewExit)] NewExit\""], ["proof (prove)\nusing this:\n  CFGExit.path (Node Exit)\n   [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)] NewExit\n\ngoal (1 subgoal):\n 1. CFGExit.same_level_path' (Node Exit)\n     [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)] NewExit", "by(fastforce simp:CFGExit.slp_def CFGExit.same_level_path_def)"], ["proof (state)\nthis:\n  CFGExit.same_level_path' (Node Exit)\n   [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)] NewExit\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "from \\<open>inner_node (targetnode ax)\\<close>"], ["proof (chain)\npicking this:\n  inner_node (targetnode ax)", "have \"valid_node (targetnode ax)\""], ["proof (prove)\nusing this:\n  inner_node (targetnode ax)\n\ngoal (1 subgoal):\n 1. valid_node (targetnode ax)", "by(rule inner_is_valid)"], ["proof (state)\nthis:\n  valid_node (targetnode ax)\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "then"], ["proof (chain)\npicking this:\n  valid_node (targetnode ax)", "obtain asx where \"targetnode ax -asx\\<rightarrow>\\<^sub>\\<surd>* Exit\""], ["proof (prove)\nusing this:\n  valid_node (targetnode ax)\n\ngoal (1 subgoal):\n 1. (\\<And>asx.\n        targetnode\n         ax -asx\\<rightarrow>\\<^sub>\\<surd>* Exit \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:Exit_path)"], ["proof (state)\nthis:\n  targetnode ax -asx\\<rightarrow>\\<^sub>\\<surd>* Exit\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "with \\<open>targetnode ax \\<noteq> Entry\\<close>"], ["proof (chain)\npicking this:\n  targetnode ax \\<noteq> Entry\n  targetnode ax -asx\\<rightarrow>\\<^sub>\\<surd>* Exit", "have \"\\<exists>es. CFG.CFG.valid_path' src trg knd\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (lift_get_return_edges get_return_edges valid_edge sourcenode \n          targetnode kind) (Node (targetnode ax)) es (Node Exit)\""], ["proof (prove)\nusing this:\n  targetnode ax \\<noteq> Entry\n  targetnode ax -asx\\<rightarrow>\\<^sub>\\<surd>* Exit\n\ngoal (1 subgoal):\n 1. \\<exists>es. CFGExit.valid_path' (Node (targetnode ax)) es (Node Exit)", "by(fastforce intro:lift_valid_path)"], ["proof (state)\nthis:\n  \\<exists>es. CFGExit.valid_path' (Node (targetnode ax)) es (Node Exit)\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "then"], ["proof (chain)\npicking this:\n  \\<exists>es. CFGExit.valid_path' (Node (targetnode ax)) es (Node Exit)", "obtain es where \"CFG.CFG.valid_path' src trg knd\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (lift_get_return_edges get_return_edges valid_edge sourcenode \n          targetnode kind) (Node (targetnode ax)) es (Node Exit)\""], ["proof (prove)\nusing this:\n  \\<exists>es. CFGExit.valid_path' (Node (targetnode ax)) es (Node Exit)\n\ngoal (1 subgoal):\n 1. (\\<And>es.\n        CFGExit.valid_path' (Node (targetnode ax)) es\n         (Node Exit) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  CFGExit.valid_path' (Node (targetnode ax)) es (Node Exit)\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "with slp_edge"], ["proof (chain)\npicking this:\n  CFGExit.same_level_path' (Node Entry)\n   [(Node Entry, kind ax, Node (targetnode ax))] (Node (targetnode ax))\n  CFGExit.valid_path' (Node (targetnode ax)) es (Node Exit)", "have \"CFG.CFG.valid_path' src trg knd\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (lift_get_return_edges get_return_edges valid_edge sourcenode \n          targetnode kind) \n          (Node Entry) ([(Node Entry,kind ax,Node (targetnode ax))]@es) (Node Exit)\""], ["proof (prove)\nusing this:\n  CFGExit.same_level_path' (Node Entry)\n   [(Node Entry, kind ax, Node (targetnode ax))] (Node (targetnode ax))\n  CFGExit.valid_path' (Node (targetnode ax)) es (Node Exit)\n\ngoal (1 subgoal):\n 1. CFGExit.valid_path' (Node Entry)\n     ([(Node Entry, kind ax, Node (targetnode ax))] @ es) (Node Exit)", "by(rule CFGExit.slp_vp_Append)"], ["proof (state)\nthis:\n  CFGExit.valid_path' (Node Entry)\n   ([(Node Entry, kind ax, Node (targetnode ax))] @ es) (Node Exit)\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "with slp_edge'"], ["proof (chain)\npicking this:\n  CFGExit.same_level_path' (Node Exit)\n   [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)] NewExit\n  CFGExit.valid_path' (Node Entry)\n   ([(Node Entry, kind ax, Node (targetnode ax))] @ es) (Node Exit)", "have \"CFG.CFG.valid_path' src trg knd\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (lift_get_return_edges get_return_edges valid_edge sourcenode \n          targetnode kind) (Node Entry)\n          (([(Node Entry,kind ax,Node (targetnode ax))]@es)@\n          [(Node Exit,(\\<lambda>s. True)\\<^sub>\\<surd>,NewExit)]) NewExit\""], ["proof (prove)\nusing this:\n  CFGExit.same_level_path' (Node Exit)\n   [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)] NewExit\n  CFGExit.valid_path' (Node Entry)\n   ([(Node Entry, kind ax, Node (targetnode ax))] @ es) (Node Exit)\n\ngoal (1 subgoal):\n 1. CFGExit.valid_path' (Node Entry)\n     (([(Node Entry, kind ax, Node (targetnode ax))] @ es) @\n      [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)])\n     NewExit", "by -(rule CFGExit.vp_slp_Append)"], ["proof (state)\nthis:\n  CFGExit.valid_path' (Node Entry)\n   (([(Node Entry, kind ax, Node (targetnode ax))] @ es) @\n    [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)])\n   NewExit\n\ngoal (3 subgoals):\n 1. m = Entry \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit.valid_path' n as NewExit\n 3. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "with \\<open>m = Entry\\<close> \\<open>n = Node m\\<close>"], ["proof (chain)\npicking this:\n  m = Entry\n  n = Node m\n  CFGExit.valid_path' (Node Entry)\n   (([(Node Entry, kind ax, Node (targetnode ax))] @ es) @\n    [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)])\n   NewExit", "show ?thesis"], ["proof (prove)\nusing this:\n  m = Entry\n  n = Node m\n  CFGExit.valid_path' (Node Entry)\n   (([(Node Entry, kind ax, Node (targetnode ax))] @ es) @\n    [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)])\n   NewExit\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit.valid_path' n as NewExit", "by simp blast"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit.valid_path' n as NewExit\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "case Exit"], ["proof (state)\nthis:\n  m = Exit\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          (Node Exit,(\\<lambda>s. True)\\<^sub>\\<surd>,NewExit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)", "by(fastforce intro:lve_Exit_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "with \\<open>m = Exit\\<close> \\<open>n = Node m\\<close>"], ["proof (chain)\npicking this:\n  m = Exit\n  n = Node m\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)", "have \"CFG.CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          n [(Node Exit,(\\<lambda>s. True)\\<^sub>\\<surd>,NewExit)] NewExit\""], ["proof (prove)\nusing this:\n  m = Exit\n  n = Node m\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n\ngoal (1 subgoal):\n 1. CFGExit.path n [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)]\n     NewExit", "by(fastforce intro:CFGExit.Cons_path CFGExit.empty_path\n                       simp:CFGExit.valid_node_def)"], ["proof (state)\nthis:\n  CFGExit.path n [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)]\n   NewExit\n\ngoal (2 subgoals):\n 1. m = Exit \\<Longrightarrow> \\<exists>as. CFGExit.valid_path' n as NewExit\n 2. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "thus ?thesis"], ["proof (prove)\nusing this:\n  CFGExit.path n [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)]\n   NewExit\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit.valid_path' n as NewExit", "by(fastforce simp:CFGExit.vp_def CFGExit.valid_path_def)"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit.valid_path' n as NewExit\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "case inner"], ["proof (state)\nthis:\n  inner_node m\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n          (Node Exit,(\\<lambda>s. True)\\<^sub>\\<surd>,NewExit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n     (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)", "by(fastforce intro:lve_Exit_edge)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "hence \"CFG.path src trg\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (Node Exit) [(Node Exit,(\\<lambda>s. True)\\<^sub>\\<surd>,NewExit)] NewExit\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\n   (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)\n\ngoal (1 subgoal):\n 1. CFGExit.path (Node Exit)\n     [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)] NewExit", "by(fastforce intro:CFGExit.Cons_path CFGExit.empty_path\n                       simp:CFGExit.valid_node_def)"], ["proof (state)\nthis:\n  CFGExit.path (Node Exit)\n   [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)] NewExit\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "hence slp_edge:\"CFG.CFG.same_level_path' src trg knd\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (lift_get_return_edges get_return_edges valid_edge sourcenode \n          targetnode kind)\n          (Node Exit) [(Node Exit,(\\<lambda>s. True)\\<^sub>\\<surd>,NewExit)] NewExit\""], ["proof (prove)\nusing this:\n  CFGExit.path (Node Exit)\n   [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)] NewExit\n\ngoal (1 subgoal):\n 1. CFGExit.same_level_path' (Node Exit)\n     [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)] NewExit", "by(fastforce simp:CFGExit.slp_def CFGExit.same_level_path_def)"], ["proof (state)\nthis:\n  CFGExit.same_level_path' (Node Exit)\n   [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)] NewExit\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "from \\<open>valid_node m\\<close>"], ["proof (chain)\npicking this:\n  valid_node m", "obtain as where \"m -as\\<rightarrow>\\<^sub>\\<surd>* Exit\""], ["proof (prove)\nusing this:\n  valid_node m\n\ngoal (1 subgoal):\n 1. (\\<And>as.\n        m -as\\<rightarrow>\\<^sub>\\<surd>* Exit \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(fastforce dest:Exit_path)"], ["proof (state)\nthis:\n  m -as\\<rightarrow>\\<^sub>\\<surd>* Exit\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "with \\<open>inner_node m\\<close>"], ["proof (chain)\npicking this:\n  inner_node m\n  m -as\\<rightarrow>\\<^sub>\\<surd>* Exit", "have \"\\<exists>es. CFG.CFG.valid_path' src trg knd\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (lift_get_return_edges get_return_edges valid_edge sourcenode \n          targetnode kind) (Node m) es (Node Exit)\""], ["proof (prove)\nusing this:\n  inner_node m\n  m -as\\<rightarrow>\\<^sub>\\<surd>* Exit\n\ngoal (1 subgoal):\n 1. \\<exists>es. CFGExit.valid_path' (Node m) es (Node Exit)", "by(fastforce intro:lift_valid_path simp:inner_node_def)"], ["proof (state)\nthis:\n  \\<exists>es. CFGExit.valid_path' (Node m) es (Node Exit)\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "then"], ["proof (chain)\npicking this:\n  \\<exists>es. CFGExit.valid_path' (Node m) es (Node Exit)", "obtain es where \"CFG.CFG.valid_path' src trg knd\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (lift_get_return_edges get_return_edges valid_edge sourcenode \n          targetnode kind) (Node m) es (Node Exit)\""], ["proof (prove)\nusing this:\n  \\<exists>es. CFGExit.valid_path' (Node m) es (Node Exit)\n\ngoal (1 subgoal):\n 1. (\\<And>es.\n        CFGExit.valid_path' (Node m) es (Node Exit) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  CFGExit.valid_path' (Node m) es (Node Exit)\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "with slp_edge"], ["proof (chain)\npicking this:\n  CFGExit.same_level_path' (Node Exit)\n   [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)] NewExit\n  CFGExit.valid_path' (Node m) es (Node Exit)", "have \"CFG.CFG.valid_path' src trg knd\n          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n          (lift_get_return_edges get_return_edges valid_edge sourcenode \n          targetnode kind) (Node m) (es@[(Node Exit,(\\<lambda>s. True)\\<^sub>\\<surd>,NewExit)]) NewExit\""], ["proof (prove)\nusing this:\n  CFGExit.same_level_path' (Node Exit)\n   [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)] NewExit\n  CFGExit.valid_path' (Node m) es (Node Exit)\n\ngoal (1 subgoal):\n 1. CFGExit.valid_path' (Node m)\n     (es @ [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)]) NewExit", "by -(rule CFGExit.vp_slp_Append)"], ["proof (state)\nthis:\n  CFGExit.valid_path' (Node m)\n   (es @ [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)]) NewExit\n\ngoal (1 subgoal):\n 1. inner_node m \\<Longrightarrow>\n    \\<exists>as. CFGExit.valid_path' n as NewExit", "with \\<open>n = Node m\\<close>"], ["proof (chain)\npicking this:\n  n = Node m\n  CFGExit.valid_path' (Node m)\n   (es @ [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)]) NewExit", "show ?thesis"], ["proof (prove)\nusing this:\n  n = Node m\n  CFGExit.valid_path' (Node m)\n   (es @ [(Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit)]) NewExit\n\ngoal (1 subgoal):\n 1. \\<exists>as. CFGExit.valid_path' n as NewExit", "by simp blast"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit.valid_path' n as NewExit\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit.valid_path' n as NewExit\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as. CFGExit.valid_path' n as NewExit\n\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>local.CFGExit.method_exit n; local.CFGExit.method_exit n';\n        lift_get_proc get_proc Main n =\n        lift_get_proc get_proc Main n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>local.CFGExit.method_exit n; local.CFGExit.method_exit n';\n        lift_get_proc get_proc Main n =\n        lift_get_proc get_proc Main n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "fix n n'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>local.CFGExit.method_exit n; local.CFGExit.method_exit n';\n        lift_get_proc get_proc Main n =\n        lift_get_proc get_proc Main n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "assume method_exit1:\"CFGExit.CFGExit.method_exit src knd\n      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewExit n\"\n      and method_exit2:\"CFGExit.CFGExit.method_exit src knd\n      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewExit n'\"\n      and lift_eq:\"lift_get_proc get_proc Main n = lift_get_proc get_proc Main n'\""], ["proof (state)\nthis:\n  local.CFGExit.method_exit n\n  local.CFGExit.method_exit n'\n  lift_get_proc get_proc Main n = lift_get_proc get_proc Main n'\n\ngoal (1 subgoal):\n 1. \\<And>n n'.\n       \\<lbrakk>local.CFGExit.method_exit n; local.CFGExit.method_exit n';\n        lift_get_proc get_proc Main n =\n        lift_get_proc get_proc Main n'\\<rbrakk>\n       \\<Longrightarrow> n = n'", "from method_exit1"], ["proof (chain)\npicking this:\n  local.CFGExit.method_exit n", "show \"n = n'\""], ["proof (prove)\nusing this:\n  local.CFGExit.method_exit n\n\ngoal (1 subgoal):\n 1. n = n'", "proof(rule CFGExit.method_exit_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = NewExit \\<Longrightarrow> n = n'\n 2. \\<And>a Q f p.\n       \\<lbrakk>n = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "assume \"n = NewExit\""], ["proof (state)\nthis:\n  n = NewExit\n\ngoal (2 subgoals):\n 1. n = NewExit \\<Longrightarrow> n = n'\n 2. \\<And>a Q f p.\n       \\<lbrakk>n = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "from method_exit2"], ["proof (chain)\npicking this:\n  local.CFGExit.method_exit n'", "show ?thesis"], ["proof (prove)\nusing this:\n  local.CFGExit.method_exit n'\n\ngoal (1 subgoal):\n 1. n = n'", "proof(rule CFGExit.method_exit_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. n' = NewExit \\<Longrightarrow> n = n'\n 2. \\<And>a Q f p.\n       \\<lbrakk>n' = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "assume \"n' = NewExit\""], ["proof (state)\nthis:\n  n' = NewExit\n\ngoal (2 subgoals):\n 1. n' = NewExit \\<Longrightarrow> n = n'\n 2. \\<And>a Q f p.\n       \\<lbrakk>n' = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "with \\<open>n = NewExit\\<close>"], ["proof (chain)\npicking this:\n  n = NewExit\n  n' = NewExit", "show ?thesis"], ["proof (prove)\nusing this:\n  n = NewExit\n  n' = NewExit\n\ngoal (1 subgoal):\n 1. n = n'", "by simp"], ["proof (state)\nthis:\n  n = n'\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "fix a Q f p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "assume \"n' = src a\"\n          and \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n          and \"knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\""], ["proof (state)\nthis:\n  n' = src a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "hence \"lift_get_proc get_proc Main (src a) = p\""], ["proof (prove)\nusing this:\n  n' = src a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. lift_get_proc get_proc Main (src a) = p", "by -(rule CFGExit.get_proc_return)"], ["proof (state)\nthis:\n  lift_get_proc get_proc Main (src a) = p\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "with CFGExit.get_proc_Exit lift_eq \\<open>n' = src a\\<close> \\<open>n = NewExit\\<close>"], ["proof (chain)\npicking this:\n  lift_get_proc get_proc Main NewExit = Main\n  lift_get_proc get_proc Main n = lift_get_proc get_proc Main n'\n  n' = src a\n  n = NewExit\n  lift_get_proc get_proc Main (src a) = p", "have \"p = Main\""], ["proof (prove)\nusing this:\n  lift_get_proc get_proc Main NewExit = Main\n  lift_get_proc get_proc Main n = lift_get_proc get_proc Main n'\n  n' = src a\n  n = NewExit\n  lift_get_proc get_proc Main (src a) = p\n\ngoal (1 subgoal):\n 1. p = Main", "by simp"], ["proof (state)\nthis:\n  p = Main\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "with \\<open>knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = Main", "have \"knd a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f\""], ["proof (prove)\nusing this:\n  knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = Main\n\ngoal (1 subgoal):\n 1. knd a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f", "by simp"], ["proof (state)\nthis:\n  knd a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "with \\<open>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\\<close>"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f", "have False"], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f\n\ngoal (1 subgoal):\n 1. False", "by(rule CFGExit.Main_no_return_source)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n = n'", "by simp"], ["proof (state)\nthis:\n  n = n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n = n'\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "fix a Q f p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "assume \"n = src a\"\n        and \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\"\n        and \"knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\""], ["proof (state)\nthis:\n  n = src a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "then"], ["proof (chain)\npicking this:\n  n = src a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "obtain x where \"valid_edge x\" and \"src a = Node (sourcenode x)\"\n        and \"kind x = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\""], ["proof (prove)\nusing this:\n  n = src a\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>valid_edge x; src a = Node (sourcenode x);\n         kind x = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  valid_edge x\n  src a = Node (sourcenode x)\n  kind x = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "hence \"method_exit (sourcenode x)\""], ["proof (prove)\nusing this:\n  valid_edge x\n  src a = Node (sourcenode x)\n  kind x = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. method_exit (sourcenode x)", "by(fastforce simp:method_exit_def)"], ["proof (state)\nthis:\n  method_exit (sourcenode x)\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "from method_exit2"], ["proof (chain)\npicking this:\n  local.CFGExit.method_exit n'", "show ?thesis"], ["proof (prove)\nusing this:\n  local.CFGExit.method_exit n'\n\ngoal (1 subgoal):\n 1. n = n'", "proof(rule CFGExit.method_exit_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. n' = NewExit \\<Longrightarrow> n = n'\n 2. \\<And>a Q f p.\n       \\<lbrakk>n' = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "assume \"n' = NewExit\""], ["proof (state)\nthis:\n  n' = NewExit\n\ngoal (2 subgoals):\n 1. n' = NewExit \\<Longrightarrow> n = n'\n 2. \\<And>a Q f p.\n       \\<lbrakk>n' = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "from \\<open>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\\<close>\n          \\<open>knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f", "have \"lift_get_proc get_proc Main (src a) = p\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n\ngoal (1 subgoal):\n 1. lift_get_proc get_proc Main (src a) = p", "by -(rule CFGExit.get_proc_return)"], ["proof (state)\nthis:\n  lift_get_proc get_proc Main (src a) = p\n\ngoal (2 subgoals):\n 1. n' = NewExit \\<Longrightarrow> n = n'\n 2. \\<And>a Q f p.\n       \\<lbrakk>n' = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "with CFGExit.get_proc_Exit lift_eq \\<open>n = src a\\<close> \\<open>n' = NewExit\\<close>"], ["proof (chain)\npicking this:\n  lift_get_proc get_proc Main NewExit = Main\n  lift_get_proc get_proc Main n = lift_get_proc get_proc Main n'\n  n = src a\n  n' = NewExit\n  lift_get_proc get_proc Main (src a) = p", "have \"p = Main\""], ["proof (prove)\nusing this:\n  lift_get_proc get_proc Main NewExit = Main\n  lift_get_proc get_proc Main n = lift_get_proc get_proc Main n'\n  n = src a\n  n' = NewExit\n  lift_get_proc get_proc Main (src a) = p\n\ngoal (1 subgoal):\n 1. p = Main", "by simp"], ["proof (state)\nthis:\n  p = Main\n\ngoal (2 subgoals):\n 1. n' = NewExit \\<Longrightarrow> n = n'\n 2. \\<And>a Q f p.\n       \\<lbrakk>n' = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "with \\<open>knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<close>"], ["proof (chain)\npicking this:\n  knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = Main", "have \"knd a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f\""], ["proof (prove)\nusing this:\n  knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\n  p = Main\n\ngoal (1 subgoal):\n 1. knd a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f", "by simp"], ["proof (state)\nthis:\n  knd a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f\n\ngoal (2 subgoals):\n 1. n' = NewExit \\<Longrightarrow> n = n'\n 2. \\<And>a Q f p.\n       \\<lbrakk>n' = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "with \\<open>lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\\<close>"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f", "have False"], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  knd a = Q\\<hookleftarrow>\\<^bsub>Main\\<^esub>f\n\ngoal (1 subgoal):\n 1. False", "by(rule CFGExit.Main_no_return_source)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. n' = NewExit \\<Longrightarrow> n = n'\n 2. \\<And>a Q f p.\n       \\<lbrakk>n' = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. n = n'", "by simp"], ["proof (state)\nthis:\n  n = n'\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "fix a' Q' f' p'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "assume \"n' = src a'\"\n          and \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\"\n          and \"knd a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\""], ["proof (state)\nthis:\n  n' = src a'\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  knd a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "then"], ["proof (chain)\npicking this:\n  n' = src a'\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  knd a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'", "obtain x' where \"valid_edge x'\" and \"src a' = Node (sourcenode x')\"\n          and \"kind x' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\""], ["proof (prove)\nusing this:\n  n' = src a'\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'\n  knd a' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n\ngoal (1 subgoal):\n 1. (\\<And>x'.\n        \\<lbrakk>valid_edge x'; src a' = Node (sourcenode x');\n         kind x' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce elim:lift_valid_edge.cases)"], ["proof (state)\nthis:\n  valid_edge x'\n  src a' = Node (sourcenode x')\n  kind x' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "hence \"method_exit (sourcenode x')\""], ["proof (prove)\nusing this:\n  valid_edge x'\n  src a' = Node (sourcenode x')\n  kind x' = Q'\\<hookleftarrow>\\<^bsub>p'\\<^esub>f'\n\ngoal (1 subgoal):\n 1. method_exit (sourcenode x')", "by(fastforce simp:method_exit_def)"], ["proof (state)\nthis:\n  method_exit (sourcenode x')\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "with \\<open>method_exit (sourcenode x)\\<close> lift_eq \\<open>n = src a\\<close> \\<open>n' = src a'\\<close>\n          \\<open>src a = Node (sourcenode x)\\<close> \\<open>src a' = Node (sourcenode x')\\<close>"], ["proof (chain)\npicking this:\n  method_exit (sourcenode x)\n  lift_get_proc get_proc Main n = lift_get_proc get_proc Main n'\n  n = src a\n  n' = src a'\n  src a = Node (sourcenode x)\n  src a' = Node (sourcenode x')\n  method_exit (sourcenode x')", "have \"sourcenode x = sourcenode x'\""], ["proof (prove)\nusing this:\n  method_exit (sourcenode x)\n  lift_get_proc get_proc Main n = lift_get_proc get_proc Main n'\n  n = src a\n  n' = src a'\n  src a = Node (sourcenode x)\n  src a' = Node (sourcenode x')\n  method_exit (sourcenode x')\n\ngoal (1 subgoal):\n 1. sourcenode x = sourcenode x'", "by(fastforce intro:method_exit_unique)"], ["proof (state)\nthis:\n  sourcenode x = sourcenode x'\n\ngoal (1 subgoal):\n 1. \\<And>a Q f p.\n       \\<lbrakk>n' = src a;\n        lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a;\n        knd a = Q\\<hookleftarrow>\\<^bsub>p\\<^esub>f\\<rbrakk>\n       \\<Longrightarrow> n = n'", "with \\<open>src a = Node (sourcenode x)\\<close> \\<open>src a' = Node (sourcenode x')\\<close>\n          \\<open>n = src a\\<close> \\<open>n' = src a'\\<close>"], ["proof (chain)\npicking this:\n  src a = Node (sourcenode x)\n  src a' = Node (sourcenode x')\n  n = src a\n  n' = src a'\n  sourcenode x = sourcenode x'", "show ?thesis"], ["proof (prove)\nusing this:\n  src a = Node (sourcenode x)\n  src a' = Node (sourcenode x')\n  n = src a\n  n' = src a'\n  sourcenode x = sourcenode x'\n\ngoal (1 subgoal):\n 1. n = n'", "by simp"], ["proof (state)\nthis:\n  n = n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n = n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n = n'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Postdomination src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_get_proc get_proc Main)\n   (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode\n     kind)\n   procs Main NewExit\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lift_SDG:\n  assumes SDG:\"SDG sourcenode targetnode kind valid_edge Entry get_proc \n  get_return_edges procs Main Exit Def Use ParamDefs ParamUses\"\n  and inner:\"CFGExit.inner_node sourcenode targetnode valid_edge Entry Exit nx\"\n  shows \"SDG src trg knd\n  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry\n  (lift_get_proc get_proc Main) \n  (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind) \n  procs Main NewExit (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)\n  (lift_ParamDefs ParamDefs) (lift_ParamUses ParamUses)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. SDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit (lift_Def Def Entry Exit H L)\n     (lift_Use Use Entry Exit H L) (lift_ParamDefs ParamDefs)\n     (lift_ParamUses ParamUses)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. SDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit (lift_Def Def Entry Exit H L)\n     (lift_Use Use Entry Exit H L) (lift_ParamDefs ParamDefs)\n     (lift_ParamUses ParamUses)", "interpret SDG sourcenode targetnode kind valid_edge Entry get_proc \n    get_return_edges procs Main Exit Def Use ParamDefs ParamUses"], ["proof (prove)\ngoal (1 subgoal):\n 1. SDG sourcenode targetnode kind valid_edge Entry get_proc\n     get_return_edges procs Main Exit Def Use ParamDefs ParamUses", "by(rule SDG)"], ["proof (state)\ngoal (1 subgoal):\n 1. SDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit (lift_Def Def Entry Exit H L)\n     (lift_Use Use Entry Exit H L) (lift_ParamDefs ParamDefs)\n     (lift_ParamUses ParamUses)", "have wf:\"CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc\n    get_return_edges procs Main Exit Def Use ParamDefs ParamUses\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc\n     get_return_edges procs Main Exit Def Use ParamDefs ParamUses", "by(unfold_locales)"], ["proof (state)\nthis:\n  CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc\n   get_return_edges procs Main Exit Def Use ParamDefs ParamUses\n\ngoal (1 subgoal):\n 1. SDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit (lift_Def Def Entry Exit H L)\n     (lift_Use Use Entry Exit H L) (lift_ParamDefs ParamDefs)\n     (lift_ParamUses ParamUses)", "have pd:\"Postdomination sourcenode targetnode kind valid_edge Entry get_proc \n    get_return_edges procs Main Exit\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Postdomination sourcenode targetnode kind valid_edge Entry get_proc\n     get_return_edges procs Main Exit", "by(unfold_locales)"], ["proof (state)\nthis:\n  Postdomination sourcenode targetnode kind valid_edge Entry get_proc\n   get_return_edges procs Main Exit\n\ngoal (1 subgoal):\n 1. SDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit (lift_Def Def Entry Exit H L)\n     (lift_Use Use Entry Exit H L) (lift_ParamDefs ParamDefs)\n     (lift_ParamUses ParamUses)", "interpret wf':CFGExit_wf src trg knd\n    \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\" NewEntry\n    \"lift_get_proc get_proc Main\"\n    \"lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind\"\n    procs Main NewExit \"lift_Def Def Entry Exit H L\" \"lift_Use Use Entry Exit H L\"\n    \"lift_ParamDefs ParamDefs\" \"lift_ParamUses ParamUses\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CFGExit_wf src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit (lift_Def Def Entry Exit H L)\n     (lift_Use Use Entry Exit H L) (lift_ParamDefs ParamDefs)\n     (lift_ParamUses ParamUses)", "by(fastforce intro:lift_CFGExit_wf wf pd)"], ["proof (state)\ngoal (1 subgoal):\n 1. SDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit (lift_Def Def Entry Exit H L)\n     (lift_Use Use Entry Exit H L) (lift_ParamDefs ParamDefs)\n     (lift_ParamUses ParamUses)", "interpret pd':Postdomination src trg knd\n    \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\" NewEntry\n    \"lift_get_proc get_proc Main\"\n    \"lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind\" \n    procs Main NewExit"], ["proof (prove)\ngoal (1 subgoal):\n 1. Postdomination src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit", "by(fastforce intro:lift_Postdomination wf pd inner)"], ["proof (state)\ngoal (1 subgoal):\n 1. SDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit (lift_Def Def Entry Exit H L)\n     (lift_Use Use Entry Exit H L) (lift_ParamDefs ParamDefs)\n     (lift_ParamUses ParamUses)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. SDG src trg knd\n     (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n     NewEntry (lift_get_proc get_proc Main)\n     (lift_get_return_edges get_return_edges valid_edge sourcenode\n       targetnode kind)\n     procs Main NewExit (lift_Def Def Entry Exit H L)\n     (lift_Use Use Entry Exit H L) (lift_ParamDefs ParamDefs)\n     (lift_ParamUses ParamUses)", "by(unfold_locales)"], ["proof (state)\nthis:\n  SDG src trg knd\n   (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)\n   NewEntry (lift_get_proc get_proc Main)\n   (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode\n     kind)\n   procs Main NewExit (lift_Def Def Entry Exit H L)\n   (lift_Use Use Entry Exit H L) (lift_ParamDefs ParamDefs)\n   (lift_ParamUses ParamUses)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Low-deterministic security via the lifted graph\\<close>"], ["", "lemma Lift_NonInterferenceGraph:\n  fixes valid_edge and sourcenode and targetnode and kind and Entry and Exit\n  and get_proc and get_return_edges and procs and Main\n  and Def and Use and ParamDefs and ParamUses and H and L\n  defines lve:\"lve \\<equiv> lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit\"\n  and lget_proc:\"lget_proc \\<equiv> lift_get_proc get_proc Main\"\n  and lget_return_edges:\"lget_return_edges \\<equiv> \n  lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind\"\n  and lDef:\"lDef \\<equiv> lift_Def Def Entry Exit H L\" \n  and lUse:\"lUse \\<equiv> lift_Use Use Entry Exit H L\"\n  and lParamDefs:\"lParamDefs \\<equiv> lift_ParamDefs ParamDefs\"\n  and lParamUses:\"lParamUses \\<equiv> lift_ParamUses ParamUses\"\n  assumes SDG:\"SDG sourcenode targetnode kind valid_edge Entry get_proc \n  get_return_edges procs Main Exit Def Use ParamDefs ParamUses\"\n  and inner:\"CFGExit.inner_node sourcenode targetnode valid_edge Entry Exit nx\"\n  and \"H \\<inter> L = {}\" and \"H \\<union> L = UNIV\"\n  shows \"NonInterferenceInterGraph src trg knd lve NewEntry lget_proc \n  lget_return_edges procs Main NewExit lDef lUse lParamDefs lParamUses H L \n  (Node Entry) (Node Exit)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NonInterferenceInterGraph src trg knd lve NewEntry lget_proc\n     lget_return_edges procs Main NewExit lDef lUse lParamDefs lParamUses H\n     L (Node Entry) (Node Exit)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. NonInterferenceInterGraph src trg knd lve NewEntry lget_proc\n     lget_return_edges procs Main NewExit lDef lUse lParamDefs lParamUses H\n     L (Node Entry) (Node Exit)", "interpret SDG sourcenode targetnode kind valid_edge Entry get_proc \n    get_return_edges procs Main Exit Def Use ParamDefs ParamUses"], ["proof (prove)\ngoal (1 subgoal):\n 1. SDG sourcenode targetnode kind valid_edge Entry get_proc\n     get_return_edges procs Main Exit Def Use ParamDefs ParamUses", "by(rule SDG)"], ["proof (state)\ngoal (1 subgoal):\n 1. NonInterferenceInterGraph src trg knd lve NewEntry lget_proc\n     lget_return_edges procs Main NewExit lDef lUse lParamDefs lParamUses H\n     L (Node Entry) (Node Exit)", "interpret SDG':SDG src trg knd lve NewEntry lget_proc lget_return_edges\n    procs Main NewExit lDef lUse lParamDefs lParamUses"], ["proof (prove)\ngoal (1 subgoal):\n 1. SDG src trg knd lve NewEntry lget_proc lget_return_edges procs Main\n     NewExit lDef lUse lParamDefs lParamUses", "by(fastforce intro:lift_SDG SDG inner simp:lve lget_proc lget_return_edges lDef\n                      lUse lParamDefs lParamUses)"], ["proof (state)\ngoal (1 subgoal):\n 1. NonInterferenceInterGraph src trg knd lve NewEntry lget_proc\n     lget_return_edges procs Main NewExit lDef lUse lParamDefs lParamUses H\n     L (Node Entry) (Node Exit)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. NonInterferenceInterGraph src trg knd lve NewEntry lget_proc\n     lget_return_edges procs Main NewExit lDef lUse lParamDefs lParamUses H\n     L (Node Entry) (Node Exit)", "proof"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 7. lDef (Node Entry) = H\n 8. lUse (Node Entry) = H\n 9. lUse (Node Exit) = L\n 10. H \\<inter> L = {}\nA total of 11 subgoals...", "fix a"], ["proof (state)\ngoal (11 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 7. lDef (Node Entry) = H\n 8. lUse (Node Entry) = H\n 9. lUse (Node Exit) = L\n 10. H \\<inter> L = {}\nA total of 11 subgoals...", "assume \"lve a\" and \"src a = NewEntry\""], ["proof (state)\nthis:\n  lve a\n  src a = NewEntry\n\ngoal (11 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = NewEntry\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit \\<or> trg a = Node Entry\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 4. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 5. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 6. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 7. lDef (Node Entry) = H\n 8. lUse (Node Entry) = H\n 9. lUse (Node Exit) = L\n 10. H \\<inter> L = {}\nA total of 11 subgoals...", "thus \"trg a = NewExit \\<or> trg a = Node Entry\""], ["proof (prove)\nusing this:\n  lve a\n  src a = NewEntry\n\ngoal (1 subgoal):\n 1. trg a = NewExit \\<or> trg a = Node Entry", "by(fastforce elim:lift_valid_edge.cases simp:lve)"], ["proof (state)\nthis:\n  trg a = NewExit \\<or> trg a = Node Entry\n\ngoal (10 subgoals):\n 1. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 3. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 6. lDef (Node Entry) = H\n 7. lUse (Node Entry) = H\n 8. lUse (Node Exit) = L\n 9. H \\<inter> L = {}\n 10. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 3. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 4. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 5. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 6. lDef (Node Entry) = H\n 7. lUse (Node Entry) = H\n 8. lUse (Node Exit) = L\n 9. H \\<inter> L = {}\n 10. H \\<union> L = UNIV", "show \"\\<exists>a. lve a \\<and> src a = NewEntry \\<and> trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a.\n       lve a \\<and>\n       src a = NewEntry \\<and>\n       trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by(fastforce intro:lve_Entry_edge simp:lve)"], ["proof (state)\nthis:\n  \\<exists>a.\n     lve a \\<and>\n     src a = NewEntry \\<and>\n     trg a = Node Entry \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (9 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 5. lDef (Node Entry) = H\n 6. lUse (Node Entry) = H\n 7. lUse (Node Exit) = L\n 8. H \\<inter> L = {}\n 9. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 5. lDef (Node Entry) = H\n 6. lUse (Node Entry) = H\n 7. lUse (Node Exit) = L\n 8. H \\<inter> L = {}\n 9. H \\<union> L = UNIV", "fix a"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 5. lDef (Node Entry) = H\n 6. lUse (Node Entry) = H\n 7. lUse (Node Exit) = L\n 8. H \\<inter> L = {}\n 9. H \\<union> L = UNIV", "assume \"lve a\" and \"trg a = Node Entry\""], ["proof (state)\nthis:\n  lve a\n  trg a = Node Entry\n\ngoal (9 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 5. lDef (Node Entry) = H\n 6. lUse (Node Entry) = H\n 7. lUse (Node Exit) = L\n 8. H \\<inter> L = {}\n 9. H \\<union> L = UNIV", "from \\<open>lve a\\<close>"], ["proof (chain)\npicking this:\n  lve a", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\""], ["proof (prove)\nusing this:\n  lve a\n\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a", "by(simp add:lve)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n\ngoal (9 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry\n 2. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 3. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 4. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 5. lDef (Node Entry) = H\n 6. lUse (Node Entry) = H\n 7. lUse (Node Exit) = L\n 8. H \\<inter> L = {}\n 9. H \\<union> L = UNIV", "from this \\<open>trg a = Node Entry\\<close>"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  trg a = Node Entry", "show \"src a = NewEntry\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  trg a = Node Entry\n\ngoal (1 subgoal):\n 1. src a = NewEntry", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        trg e = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src e = NewEntry\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        trg e = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src e = NewEntry\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        trg e = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src e = NewEntry\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        trg e = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src e = NewEntry", "case (lve_edge a e)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  trg e = Node Entry\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        trg e = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src e = NewEntry\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        trg e = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src e = NewEntry\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        trg e = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src e = NewEntry\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        trg e = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src e = NewEntry", "from \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close> \n        \\<open>trg e = Node Entry\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  trg e = Node Entry", "have \"targetnode a = Entry\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  trg e = Node Entry\n\ngoal (1 subgoal):\n 1. targetnode a = Entry", "by simp"], ["proof (state)\nthis:\n  targetnode a = Entry\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        trg e = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src e = NewEntry\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        trg e = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src e = NewEntry\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        trg e = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src e = NewEntry\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        trg e = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src e = NewEntry", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  targetnode a = Entry", "have False"], ["proof (prove)\nusing this:\n  valid_edge a\n  targetnode a = Entry\n\ngoal (1 subgoal):\n 1. False", "by(rule Entry_target)"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        trg e = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src e = NewEntry\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        trg e = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src e = NewEntry\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        trg e = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src e = NewEntry\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        trg e = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src e = NewEntry", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. src e = NewEntry", "by simp"], ["proof (state)\nthis:\n  src e = NewEntry\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        trg e = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src e = NewEntry\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        trg e = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src e = NewEntry\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        trg e = Node Entry\\<rbrakk>\n       \\<Longrightarrow> src e = NewEntry", "qed simp_all"], ["proof (state)\nthis:\n  src a = NewEntry\n\ngoal (8 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 4. lDef (Node Entry) = H\n 5. lUse (Node Entry) = H\n 6. lUse (Node Exit) = L\n 7. H \\<inter> L = {}\n 8. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 4. lDef (Node Entry) = H\n 5. lUse (Node Entry) = H\n 6. lUse (Node Exit) = L\n 7. H \\<inter> L = {}\n 8. H \\<union> L = UNIV", "fix a"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 4. lDef (Node Entry) = H\n 5. lUse (Node Entry) = H\n 6. lUse (Node Exit) = L\n 7. H \\<inter> L = {}\n 8. H \\<union> L = UNIV", "assume \"lve a\" and \"trg a = NewExit\""], ["proof (state)\nthis:\n  lve a\n  trg a = NewExit\n\ngoal (8 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; trg a = NewExit\\<rbrakk>\n       \\<Longrightarrow> src a = NewEntry \\<or> src a = Node Exit\n 2. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 3. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 4. lDef (Node Entry) = H\n 5. lUse (Node Entry) = H\n 6. lUse (Node Exit) = L\n 7. H \\<inter> L = {}\n 8. H \\<union> L = UNIV", "thus \"src a = NewEntry \\<or> src a = Node Exit\""], ["proof (prove)\nusing this:\n  lve a\n  trg a = NewExit\n\ngoal (1 subgoal):\n 1. src a = NewEntry \\<or> src a = Node Exit", "by(fastforce elim:lift_valid_edge.cases simp:lve)"], ["proof (state)\nthis:\n  src a = NewEntry \\<or> src a = Node Exit\n\ngoal (7 subgoals):\n 1. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 3. lDef (Node Entry) = H\n 4. lUse (Node Entry) = H\n 5. lUse (Node Exit) = L\n 6. H \\<inter> L = {}\n 7. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n 2. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 3. lDef (Node Entry) = H\n 4. lUse (Node Entry) = H\n 5. lUse (Node Exit) = L\n 6. H \\<inter> L = {}\n 7. H \\<union> L = UNIV", "show \"\\<exists>a. lve a \\<and> src a = Node Exit \\<and> trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a.\n       lve a \\<and>\n       src a = Node Exit \\<and>\n       trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>", "by(fastforce intro:lve_Exit_edge simp:lve)"], ["proof (state)\nthis:\n  \\<exists>a.\n     lve a \\<and>\n     src a = Node Exit \\<and>\n     trg a = NewExit \\<and> knd a = (\\<lambda>s. True)\\<^sub>\\<surd>\n\ngoal (6 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 2. lDef (Node Entry) = H\n 3. lUse (Node Entry) = H\n 4. lUse (Node Exit) = L\n 5. H \\<inter> L = {}\n 6. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 2. lDef (Node Entry) = H\n 3. lUse (Node Entry) = H\n 4. lUse (Node Exit) = L\n 5. H \\<inter> L = {}\n 6. H \\<union> L = UNIV", "fix a"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 2. lDef (Node Entry) = H\n 3. lUse (Node Entry) = H\n 4. lUse (Node Exit) = L\n 5. H \\<inter> L = {}\n 6. H \\<union> L = UNIV", "assume \"lve a\" and \"src a = Node Exit\""], ["proof (state)\nthis:\n  lve a\n  src a = Node Exit\n\ngoal (6 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 2. lDef (Node Entry) = H\n 3. lUse (Node Entry) = H\n 4. lUse (Node Exit) = L\n 5. H \\<inter> L = {}\n 6. H \\<union> L = UNIV", "from \\<open>lve a\\<close>"], ["proof (chain)\npicking this:\n  lve a", "have \"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\""], ["proof (prove)\nusing this:\n  lve a\n\ngoal (1 subgoal):\n 1. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a", "by(simp add:lve)"], ["proof (state)\nthis:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n\ngoal (6 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>lve a; src a = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg a = NewExit\n 2. lDef (Node Entry) = H\n 3. lUse (Node Entry) = H\n 4. lUse (Node Exit) = L\n 5. H \\<inter> L = {}\n 6. H \\<union> L = UNIV", "from this \\<open>src a = Node Exit\\<close>"], ["proof (chain)\npicking this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  src a = Node Exit", "show \"trg a = NewExit\""], ["proof (prove)\nusing this:\n  lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a\n  src a = Node Exit\n\ngoal (1 subgoal):\n 1. trg a = NewExit", "proof(induct rule:lift_valid_edge.induct)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg e = NewExit\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        src e = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg e = NewExit\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        src e = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg e = NewExit\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        src e = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg e = NewExit", "case (lve_edge a e)"], ["proof (state)\nthis:\n  valid_edge a\n  sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  src e = Node Exit\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg e = NewExit\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        src e = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg e = NewExit\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        src e = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg e = NewExit\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        src e = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg e = NewExit", "from \\<open>e = (Node (sourcenode a), kind a, Node (targetnode a))\\<close> \n        \\<open>src e = Node Exit\\<close>"], ["proof (chain)\npicking this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  src e = Node Exit", "have \"sourcenode a = Exit\""], ["proof (prove)\nusing this:\n  e = (Node (sourcenode a), kind a, Node (targetnode a))\n  src e = Node Exit\n\ngoal (1 subgoal):\n 1. sourcenode a = Exit", "by simp"], ["proof (state)\nthis:\n  sourcenode a = Exit\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg e = NewExit\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        src e = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg e = NewExit\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        src e = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg e = NewExit\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        src e = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg e = NewExit", "with \\<open>valid_edge a\\<close>"], ["proof (chain)\npicking this:\n  valid_edge a\n  sourcenode a = Exit", "have False"], ["proof (prove)\nusing this:\n  valid_edge a\n  sourcenode a = Exit\n\ngoal (1 subgoal):\n 1. False", "by(rule Exit_source)"], ["proof (state)\nthis:\n  False\n\ngoal (4 subgoals):\n 1. \\<And>a e.\n       \\<lbrakk>valid_edge a;\n        sourcenode a \\<noteq> Entry \\<or> targetnode a \\<noteq> Exit;\n        e = (Node (sourcenode a), kind a, Node (targetnode a));\n        src e = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg e = NewExit\n 2. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        src e = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg e = NewExit\n 3. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        src e = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg e = NewExit\n 4. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        src e = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg e = NewExit", "thus ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. trg e = NewExit", "by simp"], ["proof (state)\nthis:\n  trg e = NewExit\n\ngoal (3 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>e =\n                (NewEntry, (\\<lambda>s. True)\\<^sub>\\<surd>, Node Entry);\n        src e = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg e = NewExit\n 2. \\<And>e.\n       \\<lbrakk>e = (Node Exit, (\\<lambda>s. True)\\<^sub>\\<surd>, NewExit);\n        src e = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg e = NewExit\n 3. \\<And>e.\n       \\<lbrakk>e = (NewEntry, (\\<lambda>s. False)\\<^sub>\\<surd>, NewExit);\n        src e = Node Exit\\<rbrakk>\n       \\<Longrightarrow> trg e = NewExit", "qed simp_all"], ["proof (state)\nthis:\n  trg a = NewExit\n\ngoal (5 subgoals):\n 1. lDef (Node Entry) = H\n 2. lUse (Node Entry) = H\n 3. lUse (Node Exit) = L\n 4. H \\<inter> L = {}\n 5. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. lDef (Node Entry) = H\n 2. lUse (Node Entry) = H\n 3. lUse (Node Exit) = L\n 4. H \\<inter> L = {}\n 5. H \\<union> L = UNIV", "from lDef"], ["proof (chain)\npicking this:\n  lDef \\<equiv> lift_Def Def Entry Exit H L", "show \"lDef (Node Entry) = H\""], ["proof (prove)\nusing this:\n  lDef \\<equiv> lift_Def Def Entry Exit H L\n\ngoal (1 subgoal):\n 1. lDef (Node Entry) = H", "by(fastforce elim:lift_Def_set.cases intro:lift_Def_High)"], ["proof (state)\nthis:\n  lDef (Node Entry) = H\n\ngoal (4 subgoals):\n 1. lUse (Node Entry) = H\n 2. lUse (Node Exit) = L\n 3. H \\<inter> L = {}\n 4. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. lUse (Node Entry) = H\n 2. lUse (Node Exit) = L\n 3. H \\<inter> L = {}\n 4. H \\<union> L = UNIV", "from Entry_noteq_Exit lUse"], ["proof (chain)\npicking this:\n  Entry = Exit \\<Longrightarrow> False\n  lUse \\<equiv> lift_Use Use Entry Exit H L", "show \"lUse (Node Entry) = H\""], ["proof (prove)\nusing this:\n  Entry = Exit \\<Longrightarrow> False\n  lUse \\<equiv> lift_Use Use Entry Exit H L\n\ngoal (1 subgoal):\n 1. lUse (Node Entry) = H", "by(fastforce elim:lift_Use_set.cases intro:lift_Use_High)"], ["proof (state)\nthis:\n  lUse (Node Entry) = H\n\ngoal (3 subgoals):\n 1. lUse (Node Exit) = L\n 2. H \\<inter> L = {}\n 3. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. lUse (Node Exit) = L\n 2. H \\<inter> L = {}\n 3. H \\<union> L = UNIV", "from Entry_noteq_Exit lUse"], ["proof (chain)\npicking this:\n  Entry = Exit \\<Longrightarrow> False\n  lUse \\<equiv> lift_Use Use Entry Exit H L", "show \"lUse (Node Exit) = L\""], ["proof (prove)\nusing this:\n  Entry = Exit \\<Longrightarrow> False\n  lUse \\<equiv> lift_Use Use Entry Exit H L\n\ngoal (1 subgoal):\n 1. lUse (Node Exit) = L", "by(fastforce elim:lift_Use_set.cases intro:lift_Use_Low)"], ["proof (state)\nthis:\n  lUse (Node Exit) = L\n\ngoal (2 subgoals):\n 1. H \\<inter> L = {}\n 2. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. H \\<inter> L = {}\n 2. H \\<union> L = UNIV", "from \\<open>H \\<inter> L = {}\\<close>"], ["proof (chain)\npicking this:\n  H \\<inter> L = {}", "show \"H \\<inter> L = {}\""], ["proof (prove)\nusing this:\n  H \\<inter> L = {}\n\ngoal (1 subgoal):\n 1. H \\<inter> L = {}", "."], ["proof (state)\nthis:\n  H \\<inter> L = {}\n\ngoal (1 subgoal):\n 1. H \\<union> L = UNIV", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. H \\<union> L = UNIV", "from \\<open>H \\<union> L = UNIV\\<close>"], ["proof (chain)\npicking this:\n  H \\<union> L = UNIV", "show \"H \\<union> L = UNIV\""], ["proof (prove)\nusing this:\n  H \\<union> L = UNIV\n\ngoal (1 subgoal):\n 1. H \\<union> L = UNIV", "."], ["proof (state)\nthis:\n  H \\<union> L = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  NonInterferenceInterGraph src trg knd lve NewEntry lget_proc\n   lget_return_edges procs Main NewExit lDef lUse lParamDefs lParamUses H L\n   (Node Entry) (Node Exit)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}