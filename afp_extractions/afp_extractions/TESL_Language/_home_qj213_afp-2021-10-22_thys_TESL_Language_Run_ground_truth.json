{"file_name": "/home/qj213/afp-2021-10-22/thys/TESL_Language/Run.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/TESL_Language", "problem_names": ["lemma Abs_run_inverse_rewrite:\n  \\<open>\\<forall>c. mono (\\<lambda>n. time (\\<rho> n c)) \\<Longrightarrow> Rep_run (Abs_run \\<rho>) = \\<rho>\\<close>", "lemma before_first_time:\n  assumes \\<open>first_time \\<rho> K n \\<tau>\\<close>\n      and \\<open>m < n\\<close>\n    shows \\<open>time ((Rep_run \\<rho>) m K) < \\<tau>\\<close>", "lemma alt_first_time_def:\n  assumes \\<open>\\<forall>m < n. time ((Rep_run \\<rho>) m K) < \\<tau>\\<close>\n      and \\<open>time ((Rep_run \\<rho>) n K) = \\<tau>\\<close>\n    shows \\<open>first_time \\<rho> K n \\<tau>\\<close>"], "translations": [["", "lemma Abs_run_inverse_rewrite:\n  \\<open>\\<forall>c. mono (\\<lambda>n. time (\\<rho> n c)) \\<Longrightarrow> Rep_run (Abs_run \\<rho>) = \\<rho>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c. mono (\\<lambda>n. time (\\<rho> n c)) \\<Longrightarrow>\n    Rep_run (Abs_run \\<rho>) = \\<rho>", "by (simp add: Abs_run_inverse)"], ["", "text \\<open>\n  A \\<^emph>\\<open>dense\\<close> run is a run in which something happens (at least one clock ticks) \n  at every instant.\n\\<close>"], ["", "definition \\<open>dense_run \\<rho> \\<equiv> (\\<forall>n. \\<exists>c. hamlet ((Rep_run \\<rho>) n c))\\<close>"], ["", "text\\<open>\n  @{term \\<open>run_tick_count \\<rho> K n\\<close>} counts the number of ticks on clock @{term \\<open>K\\<close>} \n  in the interval \\<^verbatim>\\<open>[0, n]\\<close> of run @{term \\<open>\\<rho>\\<close>}.\n\\<close>"], ["", "fun run_tick_count :: \\<open>('\\<tau>::linordered_field) run \\<Rightarrow> clock \\<Rightarrow> nat \\<Rightarrow> nat\\<close>\n  (\\<open>#\\<^sub>\\<le> _ _ _\\<close>)\nwhere\n  \\<open>(#\\<^sub>\\<le> \\<rho> K 0)       = (if hamlet ((Rep_run \\<rho>) 0 K)\n                       then 1\n                       else 0)\\<close>\n| \\<open>(#\\<^sub>\\<le> \\<rho> K (Suc n)) = (if hamlet ((Rep_run \\<rho>) (Suc n) K)\n                       then 1 + (#\\<^sub>\\<le> \\<rho> K n)\n                       else (#\\<^sub>\\<le> \\<rho> K n))\\<close>"], ["", "text\\<open>\n  @{term \\<open>run_tick_count_strictly \\<rho> K n\\<close>} counts the number of ticks on\n  clock @{term \\<open>K\\<close>} in the interval \\<^verbatim>\\<open>[0, n[\\<close> of run @{term \\<open>\\<rho>\\<close>}.\n\\<close>"], ["", "fun run_tick_count_strictly :: \\<open>('\\<tau>::linordered_field) run \\<Rightarrow> clock \\<Rightarrow> nat \\<Rightarrow> nat\\<close>\n  (\\<open>#\\<^sub>< _ _ _\\<close>)\nwhere\n  \\<open>(#\\<^sub>< \\<rho> K 0)       = 0\\<close>\n| \\<open>(#\\<^sub>< \\<rho> K (Suc n)) = #\\<^sub>\\<le> \\<rho> K n\\<close>"], ["", "text\\<open>\n  @{term \\<open>first_time \\<rho> K n \\<tau>\\<close>} tells whether instant @{term \\<open>n\\<close>} in run @{term\\<open>\\<rho>\\<close>}\n  is the first one where the time on clock @{term \\<open>K\\<close>} reaches @{term \\<open>\\<tau>\\<close>}.\n\\<close>"], ["", "definition first_time :: \\<open>'a::linordered_field run \\<Rightarrow> clock \\<Rightarrow> nat \\<Rightarrow> 'a tag_const\n                          \\<Rightarrow> bool\\<close>\nwhere\n  \\<open>first_time \\<rho> K n \\<tau> \\<equiv> (time ((Rep_run \\<rho>) n K) = \\<tau>)\n                      \\<and> (\\<nexists>n'. n' < n \\<and> time ((Rep_run \\<rho>) n' K) = \\<tau>)\\<close>"], ["", "text\\<open>\n  The time on a clock is necessarily less than @{term \\<open>\\<tau>\\<close>} before the first instant\n  at which it reaches @{term \\<open>\\<tau>\\<close>}.\n\\<close>"], ["", "lemma before_first_time:\n  assumes \\<open>first_time \\<rho> K n \\<tau>\\<close>\n      and \\<open>m < n\\<close>\n    shows \\<open>time ((Rep_run \\<rho>) m K) < \\<tau>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. time (Rep_run \\<rho> m K) < \\<tau>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. time (Rep_run \\<rho> m K) < \\<tau>", "have \\<open>mono (\\<lambda>n. time (Rep_run \\<rho> n K))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (\\<lambda>n. time (Rep_run \\<rho> n K))", "using Rep_run"], ["proof (prove)\nusing this:\n  Rep_run ?x\n  \\<in> {\\<rho>. \\<forall>c. mono (\\<lambda>n. time (\\<rho> n c))}\n\ngoal (1 subgoal):\n 1. mono (\\<lambda>n. time (Rep_run \\<rho> n K))", "by blast"], ["proof (state)\nthis:\n  mono (\\<lambda>n. time (Rep_run \\<rho> n K))\n\ngoal (1 subgoal):\n 1. time (Rep_run \\<rho> m K) < \\<tau>", "moreover"], ["proof (state)\nthis:\n  mono (\\<lambda>n. time (Rep_run \\<rho> n K))\n\ngoal (1 subgoal):\n 1. time (Rep_run \\<rho> m K) < \\<tau>", "from assms(2)"], ["proof (chain)\npicking this:\n  m < n", "have \\<open>m \\<le> n\\<close>"], ["proof (prove)\nusing this:\n  m < n\n\ngoal (1 subgoal):\n 1. m \\<le> n", "using less_imp_le"], ["proof (prove)\nusing this:\n  m < n\n  ?x < ?y \\<Longrightarrow> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. m \\<le> n", "by simp"], ["proof (state)\nthis:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. time (Rep_run \\<rho> m K) < \\<tau>", "moreover"], ["proof (state)\nthis:\n  m \\<le> n\n\ngoal (1 subgoal):\n 1. time (Rep_run \\<rho> m K) < \\<tau>", "have \\<open>mono (\\<lambda>n. time (Rep_run \\<rho> n K))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. mono (\\<lambda>n. time (Rep_run \\<rho> n K))", "using Rep_run"], ["proof (prove)\nusing this:\n  Rep_run ?x\n  \\<in> {\\<rho>. \\<forall>c. mono (\\<lambda>n. time (\\<rho> n c))}\n\ngoal (1 subgoal):\n 1. mono (\\<lambda>n. time (Rep_run \\<rho> n K))", "by blast"], ["proof (state)\nthis:\n  mono (\\<lambda>n. time (Rep_run \\<rho> n K))\n\ngoal (1 subgoal):\n 1. time (Rep_run \\<rho> m K) < \\<tau>", "ultimately"], ["proof (chain)\npicking this:\n  mono (\\<lambda>n. time (Rep_run \\<rho> n K))\n  m \\<le> n\n  mono (\\<lambda>n. time (Rep_run \\<rho> n K))", "have  \\<open>time ((Rep_run \\<rho>) m K) \\<le> time ((Rep_run \\<rho>) n K)\\<close>"], ["proof (prove)\nusing this:\n  mono (\\<lambda>n. time (Rep_run \\<rho> n K))\n  m \\<le> n\n  mono (\\<lambda>n. time (Rep_run \\<rho> n K))\n\ngoal (1 subgoal):\n 1. time (Rep_run \\<rho> m K) \\<le> time (Rep_run \\<rho> n K)", "by (simp add:mono_def)"], ["proof (state)\nthis:\n  time (Rep_run \\<rho> m K) \\<le> time (Rep_run \\<rho> n K)\n\ngoal (1 subgoal):\n 1. time (Rep_run \\<rho> m K) < \\<tau>", "moreover"], ["proof (state)\nthis:\n  time (Rep_run \\<rho> m K) \\<le> time (Rep_run \\<rho> n K)\n\ngoal (1 subgoal):\n 1. time (Rep_run \\<rho> m K) < \\<tau>", "from assms(1)"], ["proof (chain)\npicking this:\n  first_time \\<rho> K n \\<tau>", "have \\<open>time ((Rep_run \\<rho>) n K) = \\<tau>\\<close>"], ["proof (prove)\nusing this:\n  first_time \\<rho> K n \\<tau>\n\ngoal (1 subgoal):\n 1. time (Rep_run \\<rho> n K) = \\<tau>", "using first_time_def"], ["proof (prove)\nusing this:\n  first_time \\<rho> K n \\<tau>\n  first_time ?\\<rho> ?K ?n ?\\<tau> \\<equiv>\n  time (Rep_run ?\\<rho> ?n ?K) = ?\\<tau> \\<and>\n  \\<not> (\\<exists>n'<?n. time (Rep_run ?\\<rho> n' ?K) = ?\\<tau>)\n\ngoal (1 subgoal):\n 1. time (Rep_run \\<rho> n K) = \\<tau>", "by blast"], ["proof (state)\nthis:\n  time (Rep_run \\<rho> n K) = \\<tau>\n\ngoal (1 subgoal):\n 1. time (Rep_run \\<rho> m K) < \\<tau>", "moreover"], ["proof (state)\nthis:\n  time (Rep_run \\<rho> n K) = \\<tau>\n\ngoal (1 subgoal):\n 1. time (Rep_run \\<rho> m K) < \\<tau>", "from assms"], ["proof (chain)\npicking this:\n  first_time \\<rho> K n \\<tau>\n  m < n", "have \\<open>time ((Rep_run \\<rho>) m K) \\<noteq> \\<tau>\\<close>"], ["proof (prove)\nusing this:\n  first_time \\<rho> K n \\<tau>\n  m < n\n\ngoal (1 subgoal):\n 1. time (Rep_run \\<rho> m K) \\<noteq> \\<tau>", "using first_time_def"], ["proof (prove)\nusing this:\n  first_time \\<rho> K n \\<tau>\n  m < n\n  first_time ?\\<rho> ?K ?n ?\\<tau> \\<equiv>\n  time (Rep_run ?\\<rho> ?n ?K) = ?\\<tau> \\<and>\n  \\<not> (\\<exists>n'<?n. time (Rep_run ?\\<rho> n' ?K) = ?\\<tau>)\n\ngoal (1 subgoal):\n 1. time (Rep_run \\<rho> m K) \\<noteq> \\<tau>", "by blast"], ["proof (state)\nthis:\n  time (Rep_run \\<rho> m K) \\<noteq> \\<tau>\n\ngoal (1 subgoal):\n 1. time (Rep_run \\<rho> m K) < \\<tau>", "ultimately"], ["proof (chain)\npicking this:\n  time (Rep_run \\<rho> m K) \\<le> time (Rep_run \\<rho> n K)\n  time (Rep_run \\<rho> n K) = \\<tau>\n  time (Rep_run \\<rho> m K) \\<noteq> \\<tau>", "show ?thesis"], ["proof (prove)\nusing this:\n  time (Rep_run \\<rho> m K) \\<le> time (Rep_run \\<rho> n K)\n  time (Rep_run \\<rho> n K) = \\<tau>\n  time (Rep_run \\<rho> m K) \\<noteq> \\<tau>\n\ngoal (1 subgoal):\n 1. time (Rep_run \\<rho> m K) < \\<tau>", "by simp"], ["proof (state)\nthis:\n  time (Rep_run \\<rho> m K) < \\<tau>\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n  This leads to an alternate definition of @{term \\<open>first_time\\<close>}:\n\\<close>"], ["", "lemma alt_first_time_def:\n  assumes \\<open>\\<forall>m < n. time ((Rep_run \\<rho>) m K) < \\<tau>\\<close>\n      and \\<open>time ((Rep_run \\<rho>) n K) = \\<tau>\\<close>\n    shows \\<open>first_time \\<rho> K n \\<tau>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. first_time \\<rho> K n \\<tau>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. first_time \\<rho> K n \\<tau>", "from assms(1)"], ["proof (chain)\npicking this:\n  \\<forall>m<n. time (Rep_run \\<rho> m K) < \\<tau>", "have \\<open>\\<forall>m < n. time ((Rep_run \\<rho>) m K) \\<noteq> \\<tau>\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>m<n. time (Rep_run \\<rho> m K) < \\<tau>\n\ngoal (1 subgoal):\n 1. \\<forall>m<n. time (Rep_run \\<rho> m K) \\<noteq> \\<tau>", "by (simp add: less_le)"], ["proof (state)\nthis:\n  \\<forall>m<n. time (Rep_run \\<rho> m K) \\<noteq> \\<tau>\n\ngoal (1 subgoal):\n 1. first_time \\<rho> K n \\<tau>", "with assms(2)"], ["proof (chain)\npicking this:\n  time (Rep_run \\<rho> n K) = \\<tau>\n  \\<forall>m<n. time (Rep_run \\<rho> m K) \\<noteq> \\<tau>", "show ?thesis"], ["proof (prove)\nusing this:\n  time (Rep_run \\<rho> n K) = \\<tau>\n  \\<forall>m<n. time (Rep_run \\<rho> m K) \\<noteq> \\<tau>\n\ngoal (1 subgoal):\n 1. first_time \\<rho> K n \\<tau>", "by (simp add: first_time_def)"], ["proof (state)\nthis:\n  first_time \\<rho> K n \\<tau>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}