{"file_name": "/home/qj213/afp-2021-10-22/thys/TESL_Language/Config_Morphisms.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/TESL_Language", "problem_names": ["theorem consistency_finite :\n  assumes start             : \\<open>([], 0 \\<turnstile> \\<Psi> \\<triangleright> [])  \\<hookrightarrow>\\<^sup>*\\<^sup>* (\\<Gamma>\\<^sub>1, n\\<^sub>1 \\<turnstile> [] \\<triangleright> [])\\<close>\n      and init_invariant    : \\<open>consistent_context \\<Gamma>\\<^sub>1\\<close>\n    shows \\<open>consistent \\<Psi>\\<close>", "theorem consistency_coinduct : \n  assumes start             : \\<open>([], 0 \\<turnstile> \\<Psi> \\<triangleright> [])   \\<hookrightarrow>\\<^sup>*\\<^sup>* (\\<Gamma>\\<^sub>1, n\\<^sub>1 \\<turnstile> \\<Psi>\\<^sub>1 \\<triangleright> \\<Phi>\\<^sub>1)\\<close>\n      and loop              : \\<open>(\\<Gamma>\\<^sub>1, n\\<^sub>1 \\<turnstile> \\<Psi>\\<^sub>1 \\<triangleright> \\<Phi>\\<^sub>1) \\<hookrightarrow>\\<^sup>+\\<^sup>+ (\\<Gamma>\\<^sub>2, n\\<^sub>2 \\<turnstile> \\<Psi>\\<^sub>2 \\<triangleright> \\<Phi>\\<^sub>2)\\<close>\n      and init_invariant    : \\<open>consistent_context \\<Gamma>\\<^sub>1\\<close>\n      and post_invariant    : \\<open>consistent_context \\<Gamma>\\<^sub>2\\<close>\n      and retract_condition : \\<open>(\\<Gamma>\\<^sub>2, n\\<^sub>2 \\<turnstile> \\<Psi>\\<^sub>2 \\<triangleright> \\<Phi>\\<^sub>2) \\<Otimes> (f::'\\<tau> \\<Rightarrow> '\\<tau>) = (\\<Gamma>\\<^sub>1, n\\<^sub>1 \\<turnstile> \\<Psi>\\<^sub>1 \\<triangleright> \\<Phi>\\<^sub>1) \\<close> \n    shows \\<open>consistent (\\<Psi> :: ('\\<tau> :: linordered_field)TESL_formula)\\<close>"], "translations": [["", "theorem consistency_finite :\n  assumes start             : \\<open>([], 0 \\<turnstile> \\<Psi> \\<triangleright> [])  \\<hookrightarrow>\\<^sup>*\\<^sup>* (\\<Gamma>\\<^sub>1, n\\<^sub>1 \\<turnstile> [] \\<triangleright> [])\\<close>\n      and init_invariant    : \\<open>consistent_context \\<Gamma>\\<^sub>1\\<close>\n    shows \\<open>consistent \\<Psi>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent \\<Psi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. consistent \\<Psi>", "have * : \\<open>\\<exists> n. (([], 0 \\<turnstile> \\<Psi> \\<triangleright> []) \\<hookrightarrow>\\<^bsup>n\\<^esup> (\\<Gamma>\\<^sub>1, n\\<^sub>1 \\<turnstile> [] \\<triangleright> []))\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       [], 0 \\<turnstile> \\<Psi> \\<triangleright> [] \\<hookrightarrow>\\<^bsup>n\\<^esup> \\<Gamma>\\<^sub>1, n\\<^sub>1 \\<turnstile> [] \\<triangleright> []", "by (simp add: rtranclp_imp_relpowp start)"], ["proof (state)\nthis:\n  \\<exists>n.\n     [], 0 \\<turnstile> \\<Psi> \\<triangleright> [] \\<hookrightarrow>\\<^bsup>n\\<^esup> \\<Gamma>\\<^sub>1, n\\<^sub>1 \\<turnstile> [] \\<triangleright> []\n\ngoal (1 subgoal):\n 1. consistent \\<Psi>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent \\<Psi>", "unfolding consistent_context_def consistent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk> \\<Psi> \\<rbrakk>\\<rbrakk>\\<^sub>T\\<^sub>E\\<^sub>S\\<^sub>L \\<noteq>\n    {}", "using * consistent_context_def init_invariant soundness"], ["proof (prove)\nusing this:\n  \\<exists>n.\n     [], 0 \\<turnstile> \\<Psi> \\<triangleright> [] \\<hookrightarrow>\\<^bsup>n\\<^esup> \\<Gamma>\\<^sub>1, n\\<^sub>1 \\<turnstile> [] \\<triangleright> []\n  consistent_context ?\\<Gamma> \\<equiv>\n  \\<lbrakk>\\<lbrakk> ?\\<Gamma> \\<rbrakk>\\<rbrakk>\\<^sub>p\\<^sub>r\\<^sub>i\\<^sub>m \\<noteq>\n  {}\n  consistent_context \\<Gamma>\\<^sub>1\n  [], 0 \\<turnstile> ?\\<Psi> \\<triangleright> [] \\<hookrightarrow>\\<^bsup>?k\\<^esup> ?\\<S> \\<Longrightarrow>\n  \\<lbrakk> ?\\<S> \\<rbrakk>\\<^sub>c\\<^sub>o\\<^sub>n\\<^sub>f\\<^sub>i\\<^sub>g\n  \\<subseteq> \\<lbrakk>\\<lbrakk> ?\\<Psi> \\<rbrakk>\\<rbrakk>\\<^sub>T\\<^sub>E\\<^sub>S\\<^sub>L\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk> \\<Psi> \\<rbrakk>\\<rbrakk>\\<^sub>T\\<^sub>E\\<^sub>S\\<^sub>L \\<noteq>\n    {}", "by fastforce"], ["proof (state)\nthis:\n  consistent \\<Psi>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Snippets on runs\\<close>"], ["", "text \\<open>\n  A run with no ticks and constant time for all clocks.\n\\<close>"], ["", "definition const_nontick_run :: \\<open>(clock \\<Rightarrow> '\\<tau> tag_const) \\<Rightarrow> ('\\<tau>::linordered_field) run \\<close> (\\<open>\\<box>_\\<close> 80)\n  where \\<open>\\<box>f \\<equiv>  Abs_run(\\<lambda>n c. (False, f c))\\<close>"], ["", "text \\<open>\n  Ensure a clock ticks in a run at a given instant.\n\\<close>"], ["", "definition set_tick :: \\<open>('\\<tau>::linordered_field) run \\<Rightarrow> nat \\<Rightarrow> clock \\<Rightarrow> ('\\<tau>) run\\<close> \n  where   \\<open>set_tick r k c = Abs_run(\\<lambda>n c.  if k = n \n                                           then (True , time(Rep_run r k c)) \n                                           else Rep_run r k c) \\<close>"], ["", "text \\<open>\n  Ensure a clock does not tick in a run at a given instant.\n\\<close>"], ["", "definition unset_tick :: \\<open>('\\<tau>::linordered_field) run \\<Rightarrow> nat \\<Rightarrow> clock \\<Rightarrow> ('\\<tau>) run\\<close> \n  where   \\<open>unset_tick r k c = Abs_run(\\<lambda>n c.  if k = n \n                                           then (False , time(Rep_run r k c)) \n                                           else Rep_run r k c) \\<close>"], ["", "text \\<open>\n  Replace all instants after k in a run with the instants from another run.\n  Warning: the result may not be a proper run since time may not be monotonous\n  from instant k to instant k+1.\n\\<close>"], ["", "definition patch :: \\<open>('\\<tau>::linordered_field) run \\<Rightarrow> nat \\<Rightarrow> '\\<tau> run \\<Rightarrow> '\\<tau> run\\<close> (\\<open>_ \\<ggreater>\\<^bsup>_\\<^esup> _\\<close> 80)\n  where   \\<open>r \\<ggreater>\\<^bsup>k\\<^esup>r' \\<equiv> Abs_run(\\<lambda>n c. if n \\<le> k then Rep_run (r) n c else  Rep_run (r') n c)\\<close>"], ["", "text \\<open>\n  For some infinite cases, the idea for a proof scheme looks as follows: if we can derive\n  from the initial configuration @{term \\<open>([], 0 \\<turnstile> \\<Psi> \\<triangleright> [])\\<close>} a start-point of a lasso\n  @{term \\<open>(\\<Gamma>\\<^sub>1, n\\<^sub>1 \\<turnstile> \\<Psi>\\<^sub>1 \\<triangleright> \\<Phi>\\<^sub>1)\\<close>}, and if we can traverse the lasso one time \n  @{term \\<open>(\\<Gamma>\\<^sub>1, n\\<^sub>1 \\<turnstile> \\<Psi>\\<^sub>1 \\<triangleright> \\<Phi>\\<^sub>1) \\<hookrightarrow>\\<^sup>+\\<^sup>+ (\\<Gamma>\\<^sub>2, n\\<^sub>2 \\<turnstile> \\<Psi>\\<^sub>2 \\<triangleright> \\<Phi>\\<^sub>2)\\<close>} to isomorphic one, \n  we can always always make a derivation along the lasso. If the entry point of the lasso had traces \n  with prefixes consistent to @{term \\<open>\\<Gamma>\\<^sub>1\\<close>}, then there exist traces consisting of this prefix and \n  repetitions of the delta-prefix of the lasso which are consistent with @{term \\<open>\\<Psi>\\<close>} which implies\n  the logical consistency of  @{term \\<open>\\<Psi>\\<close>}.\n  \n  So far the idea. Remains to prove it. Why does one symbolic run along a lasso generalises to \n  arbitrary runs ? \n\\<close>"], ["", "theorem consistency_coinduct : \n  assumes start             : \\<open>([], 0 \\<turnstile> \\<Psi> \\<triangleright> [])   \\<hookrightarrow>\\<^sup>*\\<^sup>* (\\<Gamma>\\<^sub>1, n\\<^sub>1 \\<turnstile> \\<Psi>\\<^sub>1 \\<triangleright> \\<Phi>\\<^sub>1)\\<close>\n      and loop              : \\<open>(\\<Gamma>\\<^sub>1, n\\<^sub>1 \\<turnstile> \\<Psi>\\<^sub>1 \\<triangleright> \\<Phi>\\<^sub>1) \\<hookrightarrow>\\<^sup>+\\<^sup>+ (\\<Gamma>\\<^sub>2, n\\<^sub>2 \\<turnstile> \\<Psi>\\<^sub>2 \\<triangleright> \\<Phi>\\<^sub>2)\\<close>\n      and init_invariant    : \\<open>consistent_context \\<Gamma>\\<^sub>1\\<close>\n      and post_invariant    : \\<open>consistent_context \\<Gamma>\\<^sub>2\\<close>\n      and retract_condition : \\<open>(\\<Gamma>\\<^sub>2, n\\<^sub>2 \\<turnstile> \\<Psi>\\<^sub>2 \\<triangleright> \\<Phi>\\<^sub>2) \\<Otimes> (f::'\\<tau> \\<Rightarrow> '\\<tau>) = (\\<Gamma>\\<^sub>1, n\\<^sub>1 \\<turnstile> \\<Psi>\\<^sub>1 \\<triangleright> \\<Phi>\\<^sub>1) \\<close> \n    shows \\<open>consistent (\\<Psi> :: ('\\<tau> :: linordered_field)TESL_formula)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. consistent \\<Psi>", "oops"], ["", "end"]]}