{"file_name": "/home/qj213/afp-2021-10-22/thys/Matrix/Utility.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Matrix", "problem_names": ["lemma ballI2[Pure.intro]:\n  assumes \"\\<And>x y. (x, y) \\<in> A \\<Longrightarrow> P x y\"\n  shows \"\\<forall>(x, y)\\<in>A. P x y\"", "lemma infinite_imp_elem: \"\\<not> finite A \\<Longrightarrow> \\<exists> x. x \\<in> A\"", "lemma infinite_imp_many_elems:\n  \"infinite A \\<Longrightarrow> \\<exists> xs. set xs \\<subseteq> A \\<and> length xs = n \\<and> distinct xs\"", "lemma inf_pigeonhole_principle:\n  assumes \"\\<forall>k::nat. \\<exists>i<n::nat. f k i\"\n  shows \"\\<exists>i<n. \\<forall>k. \\<exists>k'\\<ge>k. f k' i\"", "lemma map_upt_Suc: \"map f [0 ..< Suc n] = f 0 # map (\\<lambda> i. f (Suc i)) [0 ..< n]\"", "lemma map_upt_add: \"map f [0 ..< n + m] = map f [0 ..< n] @ map (\\<lambda> i. f (i + n)) [0 ..< m]\"", "lemma map_upt_split: assumes i: \"i < n\"\n  shows \"map f [0 ..< n] = map f [0 ..< i] @ f i # map (\\<lambda> j. f (j + Suc i)) [0 ..< n - Suc i]\"", "lemma all_Suc_conv:\n  \"(\\<forall>i<Suc n. P i) \\<longleftrightarrow> P 0 \\<and> (\\<forall>i<n. P (Suc i))\" (is \"?l = ?r\")", "lemma ex_Suc_conv:\n  \"(\\<exists>i<Suc n. P i) \\<longleftrightarrow> P 0 \\<or> (\\<exists>i<n. P (Suc i))\" (is \"?l = ?r\")", "lemma sorted_list_subset:\n  assumes \"sorted as\" and \"sorted bs\"\n  shows \"(sorted_list_subset as bs = None) = (set as \\<subseteq> set bs)\"", "lemma zip_nth_conv: \"length xs = length ys \\<Longrightarrow> zip xs ys = map (\\<lambda> i. (xs ! i, ys ! i)) [0 ..< length ys]\"", "lemma nth_map_conv:\n  assumes \"length xs = length ys\"\n    and \"\\<forall>i<length xs. f (xs ! i) = g (ys ! i)\"\n  shows \"map f xs = map g ys\"", "lemma sum_list_0: \"\\<lbrakk>\\<And> x. x \\<in> set xs \\<Longrightarrow> x = 0\\<rbrakk> \\<Longrightarrow> sum_list xs = 0\"", "lemma foldr_foldr_concat: \"foldr (foldr f) m a = foldr f (concat m) a\"", "lemma sum_list_double_concat: \n  fixes f :: \"'b \\<Rightarrow> 'c \\<Rightarrow> 'a :: comm_monoid_add\" and g as bs\n  shows \"sum_list (concat (map (\\<lambda> i. map (\\<lambda> j. f i j + g i j) as) bs))\n      = sum_list (concat (map (\\<lambda> i. map (\\<lambda> j. f i j) as) bs)) + \n        sum_list (concat (map (\\<lambda> i. map (\\<lambda> j. g i j) as) bs))\"", "lemma max_list: \"x \\<in> set xs \\<Longrightarrow> x \\<le> max_list xs\"", "lemma max_list_mem: \"xs \\<noteq> [] \\<Longrightarrow> max_list xs \\<in> set xs\"", "lemma max_list_set: \"max_list xs = (if set xs = {} then 0 else (THE x. x \\<in> set xs \\<and> (\\<forall> y \\<in> set xs. y \\<le> x)))\"", "lemma max_list_eq_set: \"set xs = set ys \\<Longrightarrow> max_list xs = max_list ys\"", "lemma all_less_two: \"(\\<forall> i < Suc (Suc 0). P i) = (P 0 \\<and> P (Suc 0))\" (is \"?l = ?r\")", "lemma bound_nat_induct[consumes 1]:\n  assumes \"n \\<in> {l..u}\" and \"P l\" and \"\\<And>n. \\<lbrakk>P n; n \\<in> {l..<u}\\<rbrakk> \\<Longrightarrow> P (Suc n)\"\n  shows \"P n\""], "translations": [["", "lemma ballI2[Pure.intro]:\n  assumes \"\\<And>x y. (x, y) \\<in> A \\<Longrightarrow> P x y\"\n  shows \"\\<forall>(x, y)\\<in>A. P x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(x, y)\\<in>A. P x y", "using assms"], ["proof (prove)\nusing this:\n  (?x, ?y) \\<in> A \\<Longrightarrow> P ?x ?y\n\ngoal (1 subgoal):\n 1. \\<forall>(x, y)\\<in>A. P x y", "by auto"], ["", "lemma infinite_imp_elem: \"\\<not> finite A \\<Longrightarrow> \\<exists> x. x \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow> \\<exists>x. x \\<in> A", "by (cases \"A = {}\", auto)"], ["", "lemma infinite_imp_many_elems:\n  \"infinite A \\<Longrightarrow> \\<exists> xs. set xs \\<subseteq> A \\<and> length xs = n \\<and> distinct xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite A \\<Longrightarrow>\n    \\<exists>xs.\n       set xs \\<subseteq> A \\<and> length xs = n \\<and> distinct xs", "proof (induct n arbitrary: A)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow>\n       \\<exists>xs.\n          set xs \\<subseteq> A \\<and> length xs = 0 \\<and> distinct xs\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   infinite A \\<Longrightarrow>\n                   \\<exists>xs.\n                      set xs \\<subseteq> A \\<and>\n                      length xs = n \\<and> distinct xs;\n        infinite A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> A \\<and>\n                            length xs = Suc n \\<and> distinct xs", "case (Suc n)"], ["proof (state)\nthis:\n  infinite ?A \\<Longrightarrow>\n  \\<exists>xs. set xs \\<subseteq> ?A \\<and> length xs = n \\<and> distinct xs\n  infinite A\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow>\n       \\<exists>xs.\n          set xs \\<subseteq> A \\<and> length xs = 0 \\<and> distinct xs\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   infinite A \\<Longrightarrow>\n                   \\<exists>xs.\n                      set xs \\<subseteq> A \\<and>\n                      length xs = n \\<and> distinct xs;\n        infinite A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> A \\<and>\n                            length xs = Suc n \\<and> distinct xs", "from infinite_imp_elem[OF Suc(2)]"], ["proof (chain)\npicking this:\n  \\<exists>x. x \\<in> A", "obtain x where x: \"x \\<in> A\""], ["proof (prove)\nusing this:\n  \\<exists>x. x \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> A \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  x \\<in> A\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow>\n       \\<exists>xs.\n          set xs \\<subseteq> A \\<and> length xs = 0 \\<and> distinct xs\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   infinite A \\<Longrightarrow>\n                   \\<exists>xs.\n                      set xs \\<subseteq> A \\<and>\n                      length xs = n \\<and> distinct xs;\n        infinite A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> A \\<and>\n                            length xs = Suc n \\<and> distinct xs", "from Suc(2)"], ["proof (chain)\npicking this:\n  infinite A", "have \"infinite (A - {x})\""], ["proof (prove)\nusing this:\n  infinite A\n\ngoal (1 subgoal):\n 1. infinite (A - {x})", "by auto"], ["proof (state)\nthis:\n  infinite (A - {x})\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow>\n       \\<exists>xs.\n          set xs \\<subseteq> A \\<and> length xs = 0 \\<and> distinct xs\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   infinite A \\<Longrightarrow>\n                   \\<exists>xs.\n                      set xs \\<subseteq> A \\<and>\n                      length xs = n \\<and> distinct xs;\n        infinite A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> A \\<and>\n                            length xs = Suc n \\<and> distinct xs", "from Suc(1)[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>xs.\n     set xs \\<subseteq> A - {x} \\<and> length xs = n \\<and> distinct xs", "obtain xs where \"set xs \\<subseteq> A - {x}\" and \"length xs = n\" and \"distinct xs\""], ["proof (prove)\nusing this:\n  \\<exists>xs.\n     set xs \\<subseteq> A - {x} \\<and> length xs = n \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>set xs \\<subseteq> A - {x}; length xs = n;\n         distinct xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  set xs \\<subseteq> A - {x}\n  length xs = n\n  distinct xs\n\ngoal (2 subgoals):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow>\n       \\<exists>xs.\n          set xs \\<subseteq> A \\<and> length xs = 0 \\<and> distinct xs\n 2. \\<And>n A.\n       \\<lbrakk>\\<And>A.\n                   infinite A \\<Longrightarrow>\n                   \\<exists>xs.\n                      set xs \\<subseteq> A \\<and>\n                      length xs = n \\<and> distinct xs;\n        infinite A\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            set xs \\<subseteq> A \\<and>\n                            length xs = Suc n \\<and> distinct xs", "with x"], ["proof (chain)\npicking this:\n  x \\<in> A\n  set xs \\<subseteq> A - {x}\n  length xs = n\n  distinct xs", "show ?case"], ["proof (prove)\nusing this:\n  x \\<in> A\n  set xs \\<subseteq> A - {x}\n  length xs = n\n  distinct xs\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       set xs \\<subseteq> A \\<and> length xs = Suc n \\<and> distinct xs", "by (intro exI[of _ \"x # xs\"], auto)"], ["proof (state)\nthis:\n  \\<exists>xs.\n     set xs \\<subseteq> A \\<and> length xs = Suc n \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       infinite A \\<Longrightarrow>\n       \\<exists>xs.\n          set xs \\<subseteq> A \\<and> length xs = 0 \\<and> distinct xs", "qed auto"], ["", "lemma inf_pigeonhole_principle:\n  assumes \"\\<forall>k::nat. \\<exists>i<n::nat. f k i\"\n  shows \"\\<exists>i<n. \\<forall>k. \\<exists>k'\\<ge>k. f k' i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<n. \\<forall>k. \\<exists>k'\\<ge>k. f k' i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i<n. \\<forall>k. \\<exists>k'\\<ge>k. f k' i", "have nfin: \"~ finite (UNIV :: nat set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite UNIV", "by auto"], ["proof (state)\nthis:\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>i<n. \\<forall>k. \\<exists>k'\\<ge>k. f k' i", "have fin: \"finite ({i. i < n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {i. i < n}", "by auto"], ["proof (state)\nthis:\n  finite {i. i < n}\n\ngoal (1 subgoal):\n 1. \\<exists>i<n. \\<forall>k. \\<exists>k'\\<ge>k. f k' i", "from pigeonhole_infinite_rel[OF nfin fin] assms"], ["proof (chain)\npicking this:\n  \\<forall>a\\<in>UNIV. \\<exists>b\\<in>{i. i < n}. ?R a b \\<Longrightarrow>\n  \\<exists>b\\<in>{i. i < n}. infinite {a \\<in> UNIV. ?R a b}\n  \\<forall>k. \\<exists>i<n. f k i", "obtain i where i: \"i < n\" and nfin: \"\\<not> finite {a. f a i}\""], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>UNIV. \\<exists>b\\<in>{i. i < n}. ?R a b \\<Longrightarrow>\n  \\<exists>b\\<in>{i. i < n}. infinite {a \\<in> UNIV. ?R a b}\n  \\<forall>k. \\<exists>i<n. f k i\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i < n; infinite {a. f a i}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  i < n\n  infinite {a. f a i}\n\ngoal (1 subgoal):\n 1. \\<exists>i<n. \\<forall>k. \\<exists>k'\\<ge>k. f k' i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<n. \\<forall>k. \\<exists>k'\\<ge>k. f k' i", "proof (intro exI conjI, rule i, intro allI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. \\<exists>k'\\<ge>k. f k' i", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k. \\<exists>k'\\<ge>k. f k' i", "have \"finite {a. f a i \\<and> a < k}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {a. f a i \\<and> a < k}", "by auto"], ["proof (state)\nthis:\n  finite {a. f a i \\<and> a < k}\n\ngoal (1 subgoal):\n 1. \\<And>k. \\<exists>k'\\<ge>k. f k' i", "with nfin"], ["proof (chain)\npicking this:\n  infinite {a. f a i}\n  finite {a. f a i \\<and> a < k}", "have \"\\<not> finite ({a. f a i} - {a. f a i \\<and> a < k})\""], ["proof (prove)\nusing this:\n  infinite {a. f a i}\n  finite {a. f a i \\<and> a < k}\n\ngoal (1 subgoal):\n 1. infinite ({a. f a i} - {a. f a i \\<and> a < k})", "by auto"], ["proof (state)\nthis:\n  infinite ({a. f a i} - {a. f a i \\<and> a < k})\n\ngoal (1 subgoal):\n 1. \\<And>k. \\<exists>k'\\<ge>k. f k' i", "from infinite_imp_elem[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>x. x \\<in> {a. f a i} - {a. f a i \\<and> a < k}", "obtain a where \"f a i\" and \"a \\<ge> k\""], ["proof (prove)\nusing this:\n  \\<exists>x. x \\<in> {a. f a i} - {a. f a i \\<and> a < k}\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>f a i; k \\<le> a\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f a i\n  k \\<le> a\n\ngoal (1 subgoal):\n 1. \\<And>k. \\<exists>k'\\<ge>k. f k' i", "thus \"\\<exists> k' \\<ge> k. f k' i\""], ["proof (prove)\nusing this:\n  f a i\n  k \\<le> a\n\ngoal (1 subgoal):\n 1. \\<exists>k'\\<ge>k. f k' i", "by force"], ["proof (state)\nthis:\n  \\<exists>k'\\<ge>k. f k' i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i<n. \\<forall>k. \\<exists>k'\\<ge>k. f k' i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_upt_Suc: \"map f [0 ..< Suc n] = f 0 # map (\\<lambda> i. f (Suc i)) [0 ..< n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f [0..<Suc n] = f 0 # map (\\<lambda>i. f (Suc i)) [0..<n]", "by (induct n arbitrary: f, auto)"], ["", "lemma map_upt_add: \"map f [0 ..< n + m] = map f [0 ..< n] @ map (\\<lambda> i. f (i + n)) [0 ..< m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f [0..<n + m] = map f [0..<n] @ map (\\<lambda>i. f (i + n)) [0..<m]", "proof (induct n arbitrary: f)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       map f [0..<0 + m] =\n       map f [0..<0] @ map (\\<lambda>i. f (i + 0)) [0..<m]\n 2. \\<And>n f.\n       (\\<And>f.\n           map f [0..<n + m] =\n           map f [0..<n] @\n           map (\\<lambda>i. f (i + n)) [0..<m]) \\<Longrightarrow>\n       map f [0..<Suc n + m] =\n       map f [0..<Suc n] @ map (\\<lambda>i. f (i + Suc n)) [0..<m]", "case (Suc n f)"], ["proof (state)\nthis:\n  map ?f [0..<n + m] = map ?f [0..<n] @ map (\\<lambda>i. ?f (i + n)) [0..<m]\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       map f [0..<0 + m] =\n       map f [0..<0] @ map (\\<lambda>i. f (i + 0)) [0..<m]\n 2. \\<And>n f.\n       (\\<And>f.\n           map f [0..<n + m] =\n           map f [0..<n] @\n           map (\\<lambda>i. f (i + n)) [0..<m]) \\<Longrightarrow>\n       map f [0..<Suc n + m] =\n       map f [0..<Suc n] @ map (\\<lambda>i. f (i + Suc n)) [0..<m]", "have \"map f [0 ..< Suc n + m] = map f [0 ..< Suc (n+m)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f [0..<Suc n + m] = map f [0..<Suc (n + m)]", "by simp"], ["proof (state)\nthis:\n  map f [0..<Suc n + m] = map f [0..<Suc (n + m)]\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       map f [0..<0 + m] =\n       map f [0..<0] @ map (\\<lambda>i. f (i + 0)) [0..<m]\n 2. \\<And>n f.\n       (\\<And>f.\n           map f [0..<n + m] =\n           map f [0..<n] @\n           map (\\<lambda>i. f (i + n)) [0..<m]) \\<Longrightarrow>\n       map f [0..<Suc n + m] =\n       map f [0..<Suc n] @ map (\\<lambda>i. f (i + Suc n)) [0..<m]", "also"], ["proof (state)\nthis:\n  map f [0..<Suc n + m] = map f [0..<Suc (n + m)]\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       map f [0..<0 + m] =\n       map f [0..<0] @ map (\\<lambda>i. f (i + 0)) [0..<m]\n 2. \\<And>n f.\n       (\\<And>f.\n           map f [0..<n + m] =\n           map f [0..<n] @\n           map (\\<lambda>i. f (i + n)) [0..<m]) \\<Longrightarrow>\n       map f [0..<Suc n + m] =\n       map f [0..<Suc n] @ map (\\<lambda>i. f (i + Suc n)) [0..<m]", "have \"\\<dots> = f 0 # map (\\<lambda> i. f (Suc i)) [0 ..< n + m]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f [0..<Suc (n + m)] = f 0 # map (\\<lambda>i. f (Suc i)) [0..<n + m]", "unfolding map_upt_Suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. f 0 # map (\\<lambda>i. f (Suc i)) [0..<n + m] =\n    f 0 # map (\\<lambda>i. f (Suc i)) [0..<n + m]", ".."], ["proof (state)\nthis:\n  map f [0..<Suc (n + m)] = f 0 # map (\\<lambda>i. f (Suc i)) [0..<n + m]\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       map f [0..<0 + m] =\n       map f [0..<0] @ map (\\<lambda>i. f (i + 0)) [0..<m]\n 2. \\<And>n f.\n       (\\<And>f.\n           map f [0..<n + m] =\n           map f [0..<n] @\n           map (\\<lambda>i. f (i + n)) [0..<m]) \\<Longrightarrow>\n       map f [0..<Suc n + m] =\n       map f [0..<Suc n] @ map (\\<lambda>i. f (i + Suc n)) [0..<m]", "finally"], ["proof (chain)\npicking this:\n  map f [0..<Suc n + m] = f 0 # map (\\<lambda>i. f (Suc i)) [0..<n + m]", "show ?case"], ["proof (prove)\nusing this:\n  map f [0..<Suc n + m] = f 0 # map (\\<lambda>i. f (Suc i)) [0..<n + m]\n\ngoal (1 subgoal):\n 1. map f [0..<Suc n + m] =\n    map f [0..<Suc n] @ map (\\<lambda>i. f (i + Suc n)) [0..<m]", "unfolding Suc map_upt_Suc"], ["proof (prove)\nusing this:\n  map f [0..<Suc n + m] =\n  f 0 #\n  map (\\<lambda>i. f (Suc i)) [0..<n] @\n  map (\\<lambda>i. f (Suc (i + n))) [0..<m]\n\ngoal (1 subgoal):\n 1. map f [0..<Suc n + m] =\n    (f 0 # map (\\<lambda>i. f (Suc i)) [0..<n]) @\n    map (\\<lambda>i. f (i + Suc n)) [0..<m]", "by simp"], ["proof (state)\nthis:\n  map f [0..<Suc n + m] =\n  map f [0..<Suc n] @ map (\\<lambda>i. f (i + Suc n)) [0..<m]\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       map f [0..<0 + m] =\n       map f [0..<0] @ map (\\<lambda>i. f (i + 0)) [0..<m]", "qed simp"], ["", "lemma map_upt_split: assumes i: \"i < n\"\n  shows \"map f [0 ..< n] = map f [0 ..< i] @ f i # map (\\<lambda> j. f (j + Suc i)) [0 ..< n - Suc i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f [0..<n] =\n    map f [0..<i] @ f i # map (\\<lambda>j. f (j + Suc i)) [0..<n - Suc i]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map f [0..<n] =\n    map f [0..<i] @ f i # map (\\<lambda>j. f (j + Suc i)) [0..<n - Suc i]", "from i"], ["proof (chain)\npicking this:\n  i < n", "have \"n = i + Suc 0 + (n - Suc i)\""], ["proof (prove)\nusing this:\n  i < n\n\ngoal (1 subgoal):\n 1. n = i + Suc 0 + (n - Suc i)", "by arith"], ["proof (state)\nthis:\n  n = i + Suc 0 + (n - Suc i)\n\ngoal (1 subgoal):\n 1. map f [0..<n] =\n    map f [0..<i] @ f i # map (\\<lambda>j. f (j + Suc i)) [0..<n - Suc i]", "hence id: \"[0 ..< n] = [0 ..< i + Suc 0 + (n - Suc i)]\""], ["proof (prove)\nusing this:\n  n = i + Suc 0 + (n - Suc i)\n\ngoal (1 subgoal):\n 1. [0..<n] = [0..<i + Suc 0 + (n - Suc i)]", "by simp"], ["proof (state)\nthis:\n  [0..<n] = [0..<i + Suc 0 + (n - Suc i)]\n\ngoal (1 subgoal):\n 1. map f [0..<n] =\n    map f [0..<i] @ f i # map (\\<lambda>j. f (j + Suc i)) [0..<n - Suc i]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. map f [0..<n] =\n    map f [0..<i] @ f i # map (\\<lambda>j. f (j + Suc i)) [0..<n - Suc i]", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. map f [0..<i + Suc 0 + (n - Suc i)] =\n    map f [0..<i] @ f i # map (\\<lambda>j. f (j + Suc i)) [0..<n - Suc i]", "unfolding map_upt_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map f [0..<i] @ map (\\<lambda>ia. f (ia + i)) [0..<Suc 0]) @\n    map (\\<lambda>ia. f (ia + (i + Suc 0))) [0..<n - Suc i] =\n    map f [0..<i] @ f i # map (\\<lambda>j. f (j + Suc i)) [0..<n - Suc i]", "by auto"], ["proof (state)\nthis:\n  map f [0..<n] =\n  map f [0..<i] @ f i # map (\\<lambda>j. f (j + Suc i)) [0..<n - Suc i]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma all_Suc_conv:\n  \"(\\<forall>i<Suc n. P i) \\<longleftrightarrow> P 0 \\<and> (\\<forall>i<n. P (Suc i))\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i<Suc n. P i) = (P 0 \\<and> (\\<forall>i<n. P (Suc i)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i<Suc n. P i \\<Longrightarrow>\n    P 0 \\<and> (\\<forall>i<n. P (Suc i))\n 2. P 0 \\<and> (\\<forall>i<n. P (Suc i)) \\<Longrightarrow>\n    \\<forall>i<Suc n. P i", "assume ?l"], ["proof (state)\nthis:\n  \\<forall>i<Suc n. P i\n\ngoal (2 subgoals):\n 1. \\<forall>i<Suc n. P i \\<Longrightarrow>\n    P 0 \\<and> (\\<forall>i<n. P (Suc i))\n 2. P 0 \\<and> (\\<forall>i<n. P (Suc i)) \\<Longrightarrow>\n    \\<forall>i<Suc n. P i", "thus ?r"], ["proof (prove)\nusing this:\n  \\<forall>i<Suc n. P i\n\ngoal (1 subgoal):\n 1. P 0 \\<and> (\\<forall>i<n. P (Suc i))", "by auto"], ["proof (state)\nthis:\n  P 0 \\<and> (\\<forall>i<n. P (Suc i))\n\ngoal (1 subgoal):\n 1. P 0 \\<and> (\\<forall>i<n. P (Suc i)) \\<Longrightarrow>\n    \\<forall>i<Suc n. P i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. P 0 \\<and> (\\<forall>i<n. P (Suc i)) \\<Longrightarrow>\n    \\<forall>i<Suc n. P i", "assume ?r"], ["proof (state)\nthis:\n  P 0 \\<and> (\\<forall>i<n. P (Suc i))\n\ngoal (1 subgoal):\n 1. P 0 \\<and> (\\<forall>i<n. P (Suc i)) \\<Longrightarrow>\n    \\<forall>i<Suc n. P i", "show ?l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<Suc n. P i", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < Suc n \\<Longrightarrow> P i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < Suc n \\<Longrightarrow> P i", "assume \"i < Suc n\""], ["proof (state)\nthis:\n  i < Suc n\n\ngoal (1 subgoal):\n 1. \\<And>i. i < Suc n \\<Longrightarrow> P i", "with \\<open>?r\\<close>"], ["proof (chain)\npicking this:\n  P 0 \\<and> (\\<forall>i<n. P (Suc i))\n  i < Suc n", "show \"P i\""], ["proof (prove)\nusing this:\n  P 0 \\<and> (\\<forall>i<n. P (Suc i))\n  i < Suc n\n\ngoal (1 subgoal):\n 1. P i", "by (cases i, auto)"], ["proof (state)\nthis:\n  P i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<Suc n. P i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ex_Suc_conv:\n  \"(\\<exists>i<Suc n. P i) \\<longleftrightarrow> P 0 \\<or> (\\<exists>i<n. P (Suc i))\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>i<Suc n. P i) = (P 0 \\<or> (\\<exists>i<n. P (Suc i)))", "using all_Suc_conv[of n \"\\<lambda>i. \\<not> P i\"]"], ["proof (prove)\nusing this:\n  (\\<forall>i<Suc n. \\<not> P i) =\n  (\\<not> P 0 \\<and> (\\<forall>i<n. \\<not> P (Suc i)))\n\ngoal (1 subgoal):\n 1. (\\<exists>i<Suc n. P i) = (P 0 \\<or> (\\<exists>i<n. P (Suc i)))", "by blast"], ["", "fun sorted_list_subset :: \"'a :: linorder list \\<Rightarrow> 'a list \\<Rightarrow> 'a option\" where\n  \"sorted_list_subset (a # as) (b # bs) = \n    (if a = b then sorted_list_subset as (b # bs)\n     else if a > b then sorted_list_subset (a # as) bs\n     else Some a)\"\n| \"sorted_list_subset [] _ = None\"\n| \"sorted_list_subset (a # _) [] = Some a\""], ["", "lemma sorted_list_subset:\n  assumes \"sorted as\" and \"sorted bs\"\n  shows \"(sorted_list_subset as bs = None) = (set as \\<subseteq> set bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sorted_list_subset as bs = None) = (set as \\<subseteq> set bs)", "using assms"], ["proof (prove)\nusing this:\n  sorted as\n  sorted bs\n\ngoal (1 subgoal):\n 1. (sorted_list_subset as bs = None) = (set as \\<subseteq> set bs)", "proof (induct rule: sorted_list_subset.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a as b bs.\n       \\<lbrakk>\\<lbrakk>a = b; sorted as; sorted (b # bs)\\<rbrakk>\n                \\<Longrightarrow> (sorted_list_subset as (b # bs) = None) =\n                                  (set as \\<subseteq> set (b # bs));\n        \\<lbrakk>a \\<noteq> b; b < a; sorted (a # as); sorted bs\\<rbrakk>\n        \\<Longrightarrow> (sorted_list_subset (a # as) bs = None) =\n                          (set (a # as) \\<subseteq> set bs);\n        sorted (a # as); sorted (b # bs)\\<rbrakk>\n       \\<Longrightarrow> (sorted_list_subset (a # as) (b # bs) = None) =\n                         (set (a # as) \\<subseteq> set (b # bs))\n 2. \\<And>uu_.\n       \\<lbrakk>sorted []; sorted uu_\\<rbrakk>\n       \\<Longrightarrow> (sorted_list_subset [] uu_ = None) =\n                         (set [] \\<subseteq> set uu_)\n 3. \\<And>a uv_.\n       \\<lbrakk>sorted (a # uv_); sorted []\\<rbrakk>\n       \\<Longrightarrow> (sorted_list_subset (a # uv_) [] = None) =\n                         (set (a # uv_) \\<subseteq> set [])", "case (2 bs)"], ["proof (state)\nthis:\n  sorted []\n  sorted bs\n\ngoal (3 subgoals):\n 1. \\<And>a as b bs.\n       \\<lbrakk>\\<lbrakk>a = b; sorted as; sorted (b # bs)\\<rbrakk>\n                \\<Longrightarrow> (sorted_list_subset as (b # bs) = None) =\n                                  (set as \\<subseteq> set (b # bs));\n        \\<lbrakk>a \\<noteq> b; b < a; sorted (a # as); sorted bs\\<rbrakk>\n        \\<Longrightarrow> (sorted_list_subset (a # as) bs = None) =\n                          (set (a # as) \\<subseteq> set bs);\n        sorted (a # as); sorted (b # bs)\\<rbrakk>\n       \\<Longrightarrow> (sorted_list_subset (a # as) (b # bs) = None) =\n                         (set (a # as) \\<subseteq> set (b # bs))\n 2. \\<And>uu_.\n       \\<lbrakk>sorted []; sorted uu_\\<rbrakk>\n       \\<Longrightarrow> (sorted_list_subset [] uu_ = None) =\n                         (set [] \\<subseteq> set uu_)\n 3. \\<And>a uv_.\n       \\<lbrakk>sorted (a # uv_); sorted []\\<rbrakk>\n       \\<Longrightarrow> (sorted_list_subset (a # uv_) [] = None) =\n                         (set (a # uv_) \\<subseteq> set [])", "thus ?case"], ["proof (prove)\nusing this:\n  sorted []\n  sorted bs\n\ngoal (1 subgoal):\n 1. (sorted_list_subset [] bs = None) = (set [] \\<subseteq> set bs)", "by auto"], ["proof (state)\nthis:\n  (sorted_list_subset [] bs = None) = (set [] \\<subseteq> set bs)\n\ngoal (2 subgoals):\n 1. \\<And>a as b bs.\n       \\<lbrakk>\\<lbrakk>a = b; sorted as; sorted (b # bs)\\<rbrakk>\n                \\<Longrightarrow> (sorted_list_subset as (b # bs) = None) =\n                                  (set as \\<subseteq> set (b # bs));\n        \\<lbrakk>a \\<noteq> b; b < a; sorted (a # as); sorted bs\\<rbrakk>\n        \\<Longrightarrow> (sorted_list_subset (a # as) bs = None) =\n                          (set (a # as) \\<subseteq> set bs);\n        sorted (a # as); sorted (b # bs)\\<rbrakk>\n       \\<Longrightarrow> (sorted_list_subset (a # as) (b # bs) = None) =\n                         (set (a # as) \\<subseteq> set (b # bs))\n 2. \\<And>a uv_.\n       \\<lbrakk>sorted (a # uv_); sorted []\\<rbrakk>\n       \\<Longrightarrow> (sorted_list_subset (a # uv_) [] = None) =\n                         (set (a # uv_) \\<subseteq> set [])", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a as b bs.\n       \\<lbrakk>\\<lbrakk>a = b; sorted as; sorted (b # bs)\\<rbrakk>\n                \\<Longrightarrow> (sorted_list_subset as (b # bs) = None) =\n                                  (set as \\<subseteq> set (b # bs));\n        \\<lbrakk>a \\<noteq> b; b < a; sorted (a # as); sorted bs\\<rbrakk>\n        \\<Longrightarrow> (sorted_list_subset (a # as) bs = None) =\n                          (set (a # as) \\<subseteq> set bs);\n        sorted (a # as); sorted (b # bs)\\<rbrakk>\n       \\<Longrightarrow> (sorted_list_subset (a # as) (b # bs) = None) =\n                         (set (a # as) \\<subseteq> set (b # bs))\n 2. \\<And>a uv_.\n       \\<lbrakk>sorted (a # uv_); sorted []\\<rbrakk>\n       \\<Longrightarrow> (sorted_list_subset (a # uv_) [] = None) =\n                         (set (a # uv_) \\<subseteq> set [])", "case (3 a as)"], ["proof (state)\nthis:\n  sorted (a # as)\n  sorted []\n\ngoal (2 subgoals):\n 1. \\<And>a as b bs.\n       \\<lbrakk>\\<lbrakk>a = b; sorted as; sorted (b # bs)\\<rbrakk>\n                \\<Longrightarrow> (sorted_list_subset as (b # bs) = None) =\n                                  (set as \\<subseteq> set (b # bs));\n        \\<lbrakk>a \\<noteq> b; b < a; sorted (a # as); sorted bs\\<rbrakk>\n        \\<Longrightarrow> (sorted_list_subset (a # as) bs = None) =\n                          (set (a # as) \\<subseteq> set bs);\n        sorted (a # as); sorted (b # bs)\\<rbrakk>\n       \\<Longrightarrow> (sorted_list_subset (a # as) (b # bs) = None) =\n                         (set (a # as) \\<subseteq> set (b # bs))\n 2. \\<And>a uv_.\n       \\<lbrakk>sorted (a # uv_); sorted []\\<rbrakk>\n       \\<Longrightarrow> (sorted_list_subset (a # uv_) [] = None) =\n                         (set (a # uv_) \\<subseteq> set [])", "thus ?case"], ["proof (prove)\nusing this:\n  sorted (a # as)\n  sorted []\n\ngoal (1 subgoal):\n 1. (sorted_list_subset (a # as) [] = None) =\n    (set (a # as) \\<subseteq> set [])", "by auto"], ["proof (state)\nthis:\n  (sorted_list_subset (a # as) [] = None) =\n  (set (a # as) \\<subseteq> set [])\n\ngoal (1 subgoal):\n 1. \\<And>a as b bs.\n       \\<lbrakk>\\<lbrakk>a = b; sorted as; sorted (b # bs)\\<rbrakk>\n                \\<Longrightarrow> (sorted_list_subset as (b # bs) = None) =\n                                  (set as \\<subseteq> set (b # bs));\n        \\<lbrakk>a \\<noteq> b; b < a; sorted (a # as); sorted bs\\<rbrakk>\n        \\<Longrightarrow> (sorted_list_subset (a # as) bs = None) =\n                          (set (a # as) \\<subseteq> set bs);\n        sorted (a # as); sorted (b # bs)\\<rbrakk>\n       \\<Longrightarrow> (sorted_list_subset (a # as) (b # bs) = None) =\n                         (set (a # as) \\<subseteq> set (b # bs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a as b bs.\n       \\<lbrakk>\\<lbrakk>a = b; sorted as; sorted (b # bs)\\<rbrakk>\n                \\<Longrightarrow> (sorted_list_subset as (b # bs) = None) =\n                                  (set as \\<subseteq> set (b # bs));\n        \\<lbrakk>a \\<noteq> b; b < a; sorted (a # as); sorted bs\\<rbrakk>\n        \\<Longrightarrow> (sorted_list_subset (a # as) bs = None) =\n                          (set (a # as) \\<subseteq> set bs);\n        sorted (a # as); sorted (b # bs)\\<rbrakk>\n       \\<Longrightarrow> (sorted_list_subset (a # as) (b # bs) = None) =\n                         (set (a # as) \\<subseteq> set (b # bs))", "case (1 a as b bs)"], ["proof (state)\nthis:\n  \\<lbrakk>a = b; sorted as; sorted (b # bs)\\<rbrakk>\n  \\<Longrightarrow> (sorted_list_subset as (b # bs) = None) =\n                    (set as \\<subseteq> set (b # bs))\n  \\<lbrakk>a \\<noteq> b; b < a; sorted (a # as); sorted bs\\<rbrakk>\n  \\<Longrightarrow> (sorted_list_subset (a # as) bs = None) =\n                    (set (a # as) \\<subseteq> set bs)\n  sorted (a # as)\n  sorted (b # bs)\n\ngoal (1 subgoal):\n 1. \\<And>a as b bs.\n       \\<lbrakk>\\<lbrakk>a = b; sorted as; sorted (b # bs)\\<rbrakk>\n                \\<Longrightarrow> (sorted_list_subset as (b # bs) = None) =\n                                  (set as \\<subseteq> set (b # bs));\n        \\<lbrakk>a \\<noteq> b; b < a; sorted (a # as); sorted bs\\<rbrakk>\n        \\<Longrightarrow> (sorted_list_subset (a # as) bs = None) =\n                          (set (a # as) \\<subseteq> set bs);\n        sorted (a # as); sorted (b # bs)\\<rbrakk>\n       \\<Longrightarrow> (sorted_list_subset (a # as) (b # bs) = None) =\n                         (set (a # as) \\<subseteq> set (b # bs))", "from 1(3)"], ["proof (chain)\npicking this:\n  sorted (a # as)", "have sas: \"sorted as\" and a: \"\\<And> a'. a' \\<in> set as \\<Longrightarrow> a \\<le> a'\""], ["proof (prove)\nusing this:\n  sorted (a # as)\n\ngoal (1 subgoal):\n 1. sorted as &&& (\\<And>a'. a' \\<in> set as \\<Longrightarrow> a \\<le> a')", "by (auto)"], ["proof (state)\nthis:\n  sorted as\n  ?a' \\<in> set as \\<Longrightarrow> a \\<le> ?a'\n\ngoal (1 subgoal):\n 1. \\<And>a as b bs.\n       \\<lbrakk>\\<lbrakk>a = b; sorted as; sorted (b # bs)\\<rbrakk>\n                \\<Longrightarrow> (sorted_list_subset as (b # bs) = None) =\n                                  (set as \\<subseteq> set (b # bs));\n        \\<lbrakk>a \\<noteq> b; b < a; sorted (a # as); sorted bs\\<rbrakk>\n        \\<Longrightarrow> (sorted_list_subset (a # as) bs = None) =\n                          (set (a # as) \\<subseteq> set bs);\n        sorted (a # as); sorted (b # bs)\\<rbrakk>\n       \\<Longrightarrow> (sorted_list_subset (a # as) (b # bs) = None) =\n                         (set (a # as) \\<subseteq> set (b # bs))", "from 1(4)"], ["proof (chain)\npicking this:\n  sorted (b # bs)", "have sbs: \"sorted bs\" and b: \"\\<And> b'. b' \\<in> set bs \\<Longrightarrow> b \\<le> b'\""], ["proof (prove)\nusing this:\n  sorted (b # bs)\n\ngoal (1 subgoal):\n 1. sorted bs &&& (\\<And>b'. b' \\<in> set bs \\<Longrightarrow> b \\<le> b')", "by (auto)"], ["proof (state)\nthis:\n  sorted bs\n  ?b' \\<in> set bs \\<Longrightarrow> b \\<le> ?b'\n\ngoal (1 subgoal):\n 1. \\<And>a as b bs.\n       \\<lbrakk>\\<lbrakk>a = b; sorted as; sorted (b # bs)\\<rbrakk>\n                \\<Longrightarrow> (sorted_list_subset as (b # bs) = None) =\n                                  (set as \\<subseteq> set (b # bs));\n        \\<lbrakk>a \\<noteq> b; b < a; sorted (a # as); sorted bs\\<rbrakk>\n        \\<Longrightarrow> (sorted_list_subset (a # as) bs = None) =\n                          (set (a # as) \\<subseteq> set bs);\n        sorted (a # as); sorted (b # bs)\\<rbrakk>\n       \\<Longrightarrow> (sorted_list_subset (a # as) (b # bs) = None) =\n                         (set (a # as) \\<subseteq> set (b # bs))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sorted_list_subset (a # as) (b # bs) = None) =\n    (set (a # as) \\<subseteq> set (b # bs))", "proof (cases \"a = b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    (sorted_list_subset (a # as) (b # bs) = None) =\n    (set (a # as) \\<subseteq> set (b # bs))\n 2. a \\<noteq> b \\<Longrightarrow>\n    (sorted_list_subset (a # as) (b # bs) = None) =\n    (set (a # as) \\<subseteq> set (b # bs))", "case True"], ["proof (state)\nthis:\n  a = b\n\ngoal (2 subgoals):\n 1. a = b \\<Longrightarrow>\n    (sorted_list_subset (a # as) (b # bs) = None) =\n    (set (a # as) \\<subseteq> set (b # bs))\n 2. a \\<noteq> b \\<Longrightarrow>\n    (sorted_list_subset (a # as) (b # bs) = None) =\n    (set (a # as) \\<subseteq> set (b # bs))", "from 1(1)[OF this sas 1(4)] True"], ["proof (chain)\npicking this:\n  (sorted_list_subset as (b # bs) = None) =\n  (set as \\<subseteq> set (b # bs))\n  a = b", "show ?thesis"], ["proof (prove)\nusing this:\n  (sorted_list_subset as (b # bs) = None) =\n  (set as \\<subseteq> set (b # bs))\n  a = b\n\ngoal (1 subgoal):\n 1. (sorted_list_subset (a # as) (b # bs) = None) =\n    (set (a # as) \\<subseteq> set (b # bs))", "by auto"], ["proof (state)\nthis:\n  (sorted_list_subset (a # as) (b # bs) = None) =\n  (set (a # as) \\<subseteq> set (b # bs))\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    (sorted_list_subset (a # as) (b # bs) = None) =\n    (set (a # as) \\<subseteq> set (b # bs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    (sorted_list_subset (a # as) (b # bs) = None) =\n    (set (a # as) \\<subseteq> set (b # bs))", "case False"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    (sorted_list_subset (a # as) (b # bs) = None) =\n    (set (a # as) \\<subseteq> set (b # bs))", "note oFalse = this"], ["proof (state)\nthis:\n  a \\<noteq> b\n\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow>\n    (sorted_list_subset (a # as) (b # bs) = None) =\n    (set (a # as) \\<subseteq> set (b # bs))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sorted_list_subset (a # as) (b # bs) = None) =\n    (set (a # as) \\<subseteq> set (b # bs))", "proof (cases \"a > b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. b < a \\<Longrightarrow>\n    (sorted_list_subset (a # as) (b # bs) = None) =\n    (set (a # as) \\<subseteq> set (b # bs))\n 2. \\<not> b < a \\<Longrightarrow>\n    (sorted_list_subset (a # as) (b # bs) = None) =\n    (set (a # as) \\<subseteq> set (b # bs))", "case True"], ["proof (state)\nthis:\n  b < a\n\ngoal (2 subgoals):\n 1. b < a \\<Longrightarrow>\n    (sorted_list_subset (a # as) (b # bs) = None) =\n    (set (a # as) \\<subseteq> set (b # bs))\n 2. \\<not> b < a \\<Longrightarrow>\n    (sorted_list_subset (a # as) (b # bs) = None) =\n    (set (a # as) \\<subseteq> set (b # bs))", "with a b"], ["proof (chain)\npicking this:\n  ?a' \\<in> set as \\<Longrightarrow> a \\<le> ?a'\n  ?b' \\<in> set bs \\<Longrightarrow> b \\<le> ?b'\n  b < a", "have \"b \\<notin> set as\""], ["proof (prove)\nusing this:\n  ?a' \\<in> set as \\<Longrightarrow> a \\<le> ?a'\n  ?b' \\<in> set bs \\<Longrightarrow> b \\<le> ?b'\n  b < a\n\ngoal (1 subgoal):\n 1. b \\<notin> set as", "by force"], ["proof (state)\nthis:\n  b \\<notin> set as\n\ngoal (2 subgoals):\n 1. b < a \\<Longrightarrow>\n    (sorted_list_subset (a # as) (b # bs) = None) =\n    (set (a # as) \\<subseteq> set (b # bs))\n 2. \\<not> b < a \\<Longrightarrow>\n    (sorted_list_subset (a # as) (b # bs) = None) =\n    (set (a # as) \\<subseteq> set (b # bs))", "with 1(2)[OF False True 1(3) sbs] False True"], ["proof (chain)\npicking this:\n  (sorted_list_subset (a # as) bs = None) =\n  (set (a # as) \\<subseteq> set bs)\n  a \\<noteq> b\n  b < a\n  b \\<notin> set as", "show ?thesis"], ["proof (prove)\nusing this:\n  (sorted_list_subset (a # as) bs = None) =\n  (set (a # as) \\<subseteq> set bs)\n  a \\<noteq> b\n  b < a\n  b \\<notin> set as\n\ngoal (1 subgoal):\n 1. (sorted_list_subset (a # as) (b # bs) = None) =\n    (set (a # as) \\<subseteq> set (b # bs))", "by auto"], ["proof (state)\nthis:\n  (sorted_list_subset (a # as) (b # bs) = None) =\n  (set (a # as) \\<subseteq> set (b # bs))\n\ngoal (1 subgoal):\n 1. \\<not> b < a \\<Longrightarrow>\n    (sorted_list_subset (a # as) (b # bs) = None) =\n    (set (a # as) \\<subseteq> set (b # bs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> b < a \\<Longrightarrow>\n    (sorted_list_subset (a # as) (b # bs) = None) =\n    (set (a # as) \\<subseteq> set (b # bs))", "case False"], ["proof (state)\nthis:\n  \\<not> b < a\n\ngoal (1 subgoal):\n 1. \\<not> b < a \\<Longrightarrow>\n    (sorted_list_subset (a # as) (b # bs) = None) =\n    (set (a # as) \\<subseteq> set (b # bs))", "with oFalse"], ["proof (chain)\npicking this:\n  a \\<noteq> b\n  \\<not> b < a", "have \"a < b\""], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  \\<not> b < a\n\ngoal (1 subgoal):\n 1. a < b", "by auto"], ["proof (state)\nthis:\n  a < b\n\ngoal (1 subgoal):\n 1. \\<not> b < a \\<Longrightarrow>\n    (sorted_list_subset (a # as) (b # bs) = None) =\n    (set (a # as) \\<subseteq> set (b # bs))", "with a b"], ["proof (chain)\npicking this:\n  ?a' \\<in> set as \\<Longrightarrow> a \\<le> ?a'\n  ?b' \\<in> set bs \\<Longrightarrow> b \\<le> ?b'\n  a < b", "have \"a \\<notin> set bs\""], ["proof (prove)\nusing this:\n  ?a' \\<in> set as \\<Longrightarrow> a \\<le> ?a'\n  ?b' \\<in> set bs \\<Longrightarrow> b \\<le> ?b'\n  a < b\n\ngoal (1 subgoal):\n 1. a \\<notin> set bs", "by force"], ["proof (state)\nthis:\n  a \\<notin> set bs\n\ngoal (1 subgoal):\n 1. \\<not> b < a \\<Longrightarrow>\n    (sorted_list_subset (a # as) (b # bs) = None) =\n    (set (a # as) \\<subseteq> set (b # bs))", "with oFalse False"], ["proof (chain)\npicking this:\n  a \\<noteq> b\n  \\<not> b < a\n  a \\<notin> set bs", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<noteq> b\n  \\<not> b < a\n  a \\<notin> set bs\n\ngoal (1 subgoal):\n 1. (sorted_list_subset (a # as) (b # bs) = None) =\n    (set (a # as) \\<subseteq> set (b # bs))", "by auto"], ["proof (state)\nthis:\n  (sorted_list_subset (a # as) (b # bs) = None) =\n  (set (a # as) \\<subseteq> set (b # bs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (sorted_list_subset (a # as) (b # bs) = None) =\n  (set (a # as) \\<subseteq> set (b # bs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (sorted_list_subset (a # as) (b # bs) = None) =\n  (set (a # as) \\<subseteq> set (b # bs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zip_nth_conv: \"length xs = length ys \\<Longrightarrow> zip xs ys = map (\\<lambda> i. (xs ! i, ys ! i)) [0 ..< length ys]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length ys \\<Longrightarrow>\n    zip xs ys = map (\\<lambda>i. (xs ! i, ys ! i)) [0..<length ys]", "proof (induct xs arbitrary: ys, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   length xs = length ys \\<Longrightarrow>\n                   zip xs ys =\n                   map (\\<lambda>i. (xs ! i, ys ! i)) [0..<length ys];\n        length (a # xs) = length ys\\<rbrakk>\n       \\<Longrightarrow> zip (a # xs) ys =\n                         map (\\<lambda>i. ((a # xs) ! i, ys ! i))\n                          [0..<length ys]", "case (Cons x xs)"], ["proof (state)\nthis:\n  length xs = length ?ys \\<Longrightarrow>\n  zip xs ?ys = map (\\<lambda>i. (xs ! i, ?ys ! i)) [0..<length ?ys]\n  length (x # xs) = length ys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   length xs = length ys \\<Longrightarrow>\n                   zip xs ys =\n                   map (\\<lambda>i. (xs ! i, ys ! i)) [0..<length ys];\n        length (a # xs) = length ys\\<rbrakk>\n       \\<Longrightarrow> zip (a # xs) ys =\n                         map (\\<lambda>i. ((a # xs) ! i, ys ! i))\n                          [0..<length ys]", "then"], ["proof (chain)\npicking this:\n  length xs = length ?ys \\<Longrightarrow>\n  zip xs ?ys = map (\\<lambda>i. (xs ! i, ?ys ! i)) [0..<length ?ys]\n  length (x # xs) = length ys", "obtain y yys where ys: \"ys = y # yys\""], ["proof (prove)\nusing this:\n  length xs = length ?ys \\<Longrightarrow>\n  zip xs ?ys = map (\\<lambda>i. (xs ! i, ?ys ! i)) [0..<length ?ys]\n  length (x # xs) = length ys\n\ngoal (1 subgoal):\n 1. (\\<And>y yys. ys = y # yys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ys, auto)"], ["proof (state)\nthis:\n  ys = y # yys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   length xs = length ys \\<Longrightarrow>\n                   zip xs ys =\n                   map (\\<lambda>i. (xs ! i, ys ! i)) [0..<length ys];\n        length (a # xs) = length ys\\<rbrakk>\n       \\<Longrightarrow> zip (a # xs) ys =\n                         map (\\<lambda>i. ((a # xs) ! i, ys ! i))\n                          [0..<length ys]", "with Cons"], ["proof (chain)\npicking this:\n  length xs = length ?ys \\<Longrightarrow>\n  zip xs ?ys = map (\\<lambda>i. (xs ! i, ?ys ! i)) [0..<length ?ys]\n  length (x # xs) = length ys\n  ys = y # yys", "have len: \"length xs = length yys\""], ["proof (prove)\nusing this:\n  length xs = length ?ys \\<Longrightarrow>\n  zip xs ?ys = map (\\<lambda>i. (xs ! i, ?ys ! i)) [0..<length ?ys]\n  length (x # xs) = length ys\n  ys = y # yys\n\ngoal (1 subgoal):\n 1. length xs = length yys", "by simp"], ["proof (state)\nthis:\n  length xs = length yys\n\ngoal (1 subgoal):\n 1. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   length xs = length ys \\<Longrightarrow>\n                   zip xs ys =\n                   map (\\<lambda>i. (xs ! i, ys ! i)) [0..<length ys];\n        length (a # xs) = length ys\\<rbrakk>\n       \\<Longrightarrow> zip (a # xs) ys =\n                         map (\\<lambda>i. ((a # xs) ! i, ys ! i))\n                          [0..<length ys]", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. zip (x # xs) ys =\n    map (\\<lambda>i. ((x # xs) ! i, ys ! i)) [0..<length ys]", "unfolding ys"], ["proof (prove)\ngoal (1 subgoal):\n 1. zip (x # xs) (y # yys) =\n    map (\\<lambda>i. ((x # xs) ! i, (y # yys) ! i)) [0..<length (y # yys)]", "by (simp del: upt_Suc add: map_upt_Suc, unfold Cons(1)[OF len], simp)"], ["proof (state)\nthis:\n  zip (x # xs) ys = map (\\<lambda>i. ((x # xs) ! i, ys ! i)) [0..<length ys]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nth_map_conv:\n  assumes \"length xs = length ys\"\n    and \"\\<forall>i<length xs. f (xs ! i) = g (ys ! i)\"\n  shows \"map f xs = map g ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f xs = map g ys", "using assms"], ["proof (prove)\nusing this:\n  length xs = length ys\n  \\<forall>i<length xs. f (xs ! i) = g (ys ! i)\n\ngoal (1 subgoal):\n 1. map f xs = map g ys", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>length [] = length ys;\n        \\<forall>i<length []. f ([] ! i) = g (ys ! i)\\<rbrakk>\n       \\<Longrightarrow> map f [] = map g ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>length xs = length ys;\n                    \\<forall>i<length xs. f (xs ! i) = g (ys ! i)\\<rbrakk>\n                   \\<Longrightarrow> map f xs = map g ys;\n        length (a # xs) = length ys;\n        \\<forall>i<length (a # xs). f ((a # xs) ! i) = g (ys ! i)\\<rbrakk>\n       \\<Longrightarrow> map f (a # xs) = map g ys", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>length xs = length ?ys;\n   \\<forall>i<length xs. f (xs ! i) = g (?ys ! i)\\<rbrakk>\n  \\<Longrightarrow> map f xs = map g ?ys\n  length (x # xs) = length ys\n  \\<forall>i<length (x # xs). f ((x # xs) ! i) = g (ys ! i)\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>length [] = length ys;\n        \\<forall>i<length []. f ([] ! i) = g (ys ! i)\\<rbrakk>\n       \\<Longrightarrow> map f [] = map g ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>\\<And>ys.\n                   \\<lbrakk>length xs = length ys;\n                    \\<forall>i<length xs. f (xs ! i) = g (ys ! i)\\<rbrakk>\n                   \\<Longrightarrow> map f xs = map g ys;\n        length (a # xs) = length ys;\n        \\<forall>i<length (a # xs). f ((a # xs) ! i) = g (ys ! i)\\<rbrakk>\n       \\<Longrightarrow> map f (a # xs) = map g ys", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>length xs = length ?ys;\n   \\<forall>i<length xs. f (xs ! i) = g (?ys ! i)\\<rbrakk>\n  \\<Longrightarrow> map f xs = map g ?ys\n  length (x # xs) = length ys\n  \\<forall>i<length (x # xs). f ((x # xs) ! i) = g (ys ! i)\n\ngoal (1 subgoal):\n 1. map f (x # xs) = map g ys", "proof (induct ys)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>length xs = length ys;\n                 \\<forall>i<length xs. f (xs ! i) = g (ys ! i)\\<rbrakk>\n                \\<Longrightarrow> map f xs = map g ys;\n     length (x # xs) = length [];\n     \\<forall>i<length (x # xs). f ((x # xs) ! i) = g ([] ! i)\\<rbrakk>\n    \\<Longrightarrow> map f (x # xs) = map g []\n 2. \\<And>a ys.\n       \\<lbrakk>\\<lbrakk>\\<And>ys.\n                            \\<lbrakk>length xs = length ys;\n                             \\<forall>i<length xs.\n                                f (xs ! i) = g (ys ! i)\\<rbrakk>\n                            \\<Longrightarrow> map f xs = map g ys;\n                 length (x # xs) = length ys;\n                 \\<forall>i<length (x # xs).\n                    f ((x # xs) ! i) = g (ys ! i)\\<rbrakk>\n                \\<Longrightarrow> map f (x # xs) = map g ys;\n        \\<And>ys.\n           \\<lbrakk>length xs = length ys;\n            \\<forall>i<length xs. f (xs ! i) = g (ys ! i)\\<rbrakk>\n           \\<Longrightarrow> map f xs = map g ys;\n        length (x # xs) = length (a # ys);\n        \\<forall>i<length (x # xs).\n           f ((x # xs) ! i) = g ((a # ys) ! i)\\<rbrakk>\n       \\<Longrightarrow> map f (x # xs) = map g (a # ys)", "case (Cons y ys)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>ys.\n              \\<lbrakk>length xs = length ys;\n               \\<forall>i<length xs. f (xs ! i) = g (ys ! i)\\<rbrakk>\n              \\<Longrightarrow> map f xs = map g ys;\n   length (x # xs) = length ys;\n   \\<forall>i<length (x # xs). f ((x # xs) ! i) = g (ys ! i)\\<rbrakk>\n  \\<Longrightarrow> map f (x # xs) = map g ys\n  \\<lbrakk>length xs = length ?ys;\n   \\<forall>i<length xs. f (xs ! i) = g (?ys ! i)\\<rbrakk>\n  \\<Longrightarrow> map f xs = map g ?ys\n  length (x # xs) = length (y # ys)\n  \\<forall>i<length (x # xs). f ((x # xs) ! i) = g ((y # ys) ! i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>length xs = length ys;\n                 \\<forall>i<length xs. f (xs ! i) = g (ys ! i)\\<rbrakk>\n                \\<Longrightarrow> map f xs = map g ys;\n     length (x # xs) = length [];\n     \\<forall>i<length (x # xs). f ((x # xs) ! i) = g ([] ! i)\\<rbrakk>\n    \\<Longrightarrow> map f (x # xs) = map g []\n 2. \\<And>a ys.\n       \\<lbrakk>\\<lbrakk>\\<And>ys.\n                            \\<lbrakk>length xs = length ys;\n                             \\<forall>i<length xs.\n                                f (xs ! i) = g (ys ! i)\\<rbrakk>\n                            \\<Longrightarrow> map f xs = map g ys;\n                 length (x # xs) = length ys;\n                 \\<forall>i<length (x # xs).\n                    f ((x # xs) ! i) = g (ys ! i)\\<rbrakk>\n                \\<Longrightarrow> map f (x # xs) = map g ys;\n        \\<And>ys.\n           \\<lbrakk>length xs = length ys;\n            \\<forall>i<length xs. f (xs ! i) = g (ys ! i)\\<rbrakk>\n           \\<Longrightarrow> map f xs = map g ys;\n        length (x # xs) = length (a # ys);\n        \\<forall>i<length (x # xs).\n           f ((x # xs) ! i) = g ((a # ys) ! i)\\<rbrakk>\n       \\<Longrightarrow> map f (x # xs) = map g (a # ys)", "have \"\\<forall>i<length xs. f (xs ! i) = g (ys ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length xs. f (xs ! i) = g (ys ! i)", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length xs \\<Longrightarrow> f (xs ! i) = g (ys ! i)", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length xs \\<Longrightarrow> f (xs ! i) = g (ys ! i)", "assume \"i < length xs\""], ["proof (state)\nthis:\n  i < length xs\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length xs \\<Longrightarrow> f (xs ! i) = g (ys ! i)", "thus \"f (xs ! i) = g (ys ! i)\""], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. f (xs ! i) = g (ys ! i)", "using Cons(4)"], ["proof (prove)\nusing this:\n  i < length xs\n  \\<forall>i<length (x # xs). f ((x # xs) ! i) = g ((y # ys) ! i)\n\ngoal (1 subgoal):\n 1. f (xs ! i) = g (ys ! i)", "by force"], ["proof (state)\nthis:\n  f (xs ! i) = g (ys ! i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<length xs. f (xs ! i) = g (ys ! i)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>length xs = length ys;\n                 \\<forall>i<length xs. f (xs ! i) = g (ys ! i)\\<rbrakk>\n                \\<Longrightarrow> map f xs = map g ys;\n     length (x # xs) = length [];\n     \\<forall>i<length (x # xs). f ((x # xs) ! i) = g ([] ! i)\\<rbrakk>\n    \\<Longrightarrow> map f (x # xs) = map g []\n 2. \\<And>a ys.\n       \\<lbrakk>\\<lbrakk>\\<And>ys.\n                            \\<lbrakk>length xs = length ys;\n                             \\<forall>i<length xs.\n                                f (xs ! i) = g (ys ! i)\\<rbrakk>\n                            \\<Longrightarrow> map f xs = map g ys;\n                 length (x # xs) = length ys;\n                 \\<forall>i<length (x # xs).\n                    f ((x # xs) ! i) = g (ys ! i)\\<rbrakk>\n                \\<Longrightarrow> map f (x # xs) = map g ys;\n        \\<And>ys.\n           \\<lbrakk>length xs = length ys;\n            \\<forall>i<length xs. f (xs ! i) = g (ys ! i)\\<rbrakk>\n           \\<Longrightarrow> map f xs = map g ys;\n        length (x # xs) = length (a # ys);\n        \\<forall>i<length (x # xs).\n           f ((x # xs) ! i) = g ((a # ys) ! i)\\<rbrakk>\n       \\<Longrightarrow> map f (x # xs) = map g (a # ys)", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<And>ys.\n              \\<lbrakk>length xs = length ys;\n               \\<forall>i<length xs. f (xs ! i) = g (ys ! i)\\<rbrakk>\n              \\<Longrightarrow> map f xs = map g ys;\n   length (x # xs) = length ys;\n   \\<forall>i<length (x # xs). f ((x # xs) ! i) = g (ys ! i)\\<rbrakk>\n  \\<Longrightarrow> map f (x # xs) = map g ys\n  \\<lbrakk>length xs = length ?ys;\n   \\<forall>i<length xs. f (xs ! i) = g (?ys ! i)\\<rbrakk>\n  \\<Longrightarrow> map f xs = map g ?ys\n  length (x # xs) = length (y # ys)\n  \\<forall>i<length (x # xs). f ((x # xs) ! i) = g ((y # ys) ! i)\n  \\<forall>i<length xs. f (xs ! i) = g (ys ! i)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>ys.\n              \\<lbrakk>length xs = length ys;\n               \\<forall>i<length xs. f (xs ! i) = g (ys ! i)\\<rbrakk>\n              \\<Longrightarrow> map f xs = map g ys;\n   length (x # xs) = length ys;\n   \\<forall>i<length (x # xs). f ((x # xs) ! i) = g (ys ! i)\\<rbrakk>\n  \\<Longrightarrow> map f (x # xs) = map g ys\n  \\<lbrakk>length xs = length ?ys;\n   \\<forall>i<length xs. f (xs ! i) = g (?ys ! i)\\<rbrakk>\n  \\<Longrightarrow> map f xs = map g ?ys\n  length (x # xs) = length (y # ys)\n  \\<forall>i<length (x # xs). f ((x # xs) ! i) = g ((y # ys) ! i)\n  \\<forall>i<length xs. f (xs ! i) = g (ys ! i)\n\ngoal (1 subgoal):\n 1. map f (x # xs) = map g (y # ys)", "by auto"], ["proof (state)\nthis:\n  map f (x # xs) = map g (y # ys)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>ys.\n                \\<lbrakk>length xs = length ys;\n                 \\<forall>i<length xs. f (xs ! i) = g (ys ! i)\\<rbrakk>\n                \\<Longrightarrow> map f xs = map g ys;\n     length (x # xs) = length [];\n     \\<forall>i<length (x # xs). f ((x # xs) ! i) = g ([] ! i)\\<rbrakk>\n    \\<Longrightarrow> map f (x # xs) = map g []", "qed simp"], ["proof (state)\nthis:\n  map f (x # xs) = map g ys\n\ngoal (1 subgoal):\n 1. \\<And>ys.\n       \\<lbrakk>length [] = length ys;\n        \\<forall>i<length []. f ([] ! i) = g (ys ! i)\\<rbrakk>\n       \\<Longrightarrow> map f [] = map g ys", "qed simp"], ["", "lemma sum_list_0: \"\\<lbrakk>\\<And> x. x \\<in> set xs \\<Longrightarrow> x = 0\\<rbrakk> \\<Longrightarrow> sum_list xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set xs \\<Longrightarrow> x = (0::'a)) \\<Longrightarrow>\n    sum_list xs = (0::'a)", "by (induct xs, auto)"], ["", "lemma foldr_foldr_concat: \"foldr (foldr f) m a = foldr f (concat m) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (foldr f) m a = foldr f (concat m) a", "proof (induct m arbitrary: a)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. foldr (foldr f) [] a = foldr f (concat []) a\n 2. \\<And>a m aa.\n       (\\<And>a.\n           foldr (foldr f) m a = foldr f (concat m) a) \\<Longrightarrow>\n       foldr (foldr f) (a # m) aa = foldr f (concat (a # m)) aa", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>a. foldr (foldr f) [] a = foldr f (concat []) a\n 2. \\<And>a m aa.\n       (\\<And>a.\n           foldr (foldr f) m a = foldr f (concat m) a) \\<Longrightarrow>\n       foldr (foldr f) (a # m) aa = foldr f (concat (a # m)) aa", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (foldr f) [] a = foldr f (concat []) a", "by simp"], ["proof (state)\nthis:\n  foldr (foldr f) [] a = foldr f (concat []) a\n\ngoal (1 subgoal):\n 1. \\<And>a m aa.\n       (\\<And>a.\n           foldr (foldr f) m a = foldr f (concat m) a) \\<Longrightarrow>\n       foldr (foldr f) (a # m) aa = foldr f (concat (a # m)) aa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a m aa.\n       (\\<And>a.\n           foldr (foldr f) m a = foldr f (concat m) a) \\<Longrightarrow>\n       foldr (foldr f) (a # m) aa = foldr f (concat (a # m)) aa", "case (Cons v m a)"], ["proof (state)\nthis:\n  foldr (foldr f) m ?a = foldr f (concat m) ?a\n\ngoal (1 subgoal):\n 1. \\<And>a m aa.\n       (\\<And>a.\n           foldr (foldr f) m a = foldr f (concat m) a) \\<Longrightarrow>\n       foldr (foldr f) (a # m) aa = foldr f (concat (a # m)) aa", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (foldr f) (v # m) a = foldr f (concat (v # m)) a", "unfolding concat.simps foldr_Cons o_def Cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr f v (foldr f (concat m) a) = foldr f (v @ concat m) a", "unfolding foldr_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr f v (foldr f (concat m) a) = foldr f v (foldr f (concat m) a)", "by simp"], ["proof (state)\nthis:\n  foldr (foldr f) (v # m) a = foldr f (concat (v # m)) a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_list_double_concat: \n  fixes f :: \"'b \\<Rightarrow> 'c \\<Rightarrow> 'a :: comm_monoid_add\" and g as bs\n  shows \"sum_list (concat (map (\\<lambda> i. map (\\<lambda> j. f i j + g i j) as) bs))\n      = sum_list (concat (map (\\<lambda> i. map (\\<lambda> j. f i j) as) bs)) + \n        sum_list (concat (map (\\<lambda> i. map (\\<lambda> j. g i j) as) bs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (concat (map (\\<lambda>i. map (\\<lambda>j. f i j + g i j) as) bs)) =\n    sum_list (concat (map (\\<lambda>i. map (f i) as) bs)) +\n    sum_list (concat (map (\\<lambda>i. map (g i) as) bs))", "proof (induct bs)"], ["proof (state)\ngoal (2 subgoals):\n 1. sum_list\n     (concat (map (\\<lambda>i. map (\\<lambda>j. f i j + g i j) as) [])) =\n    sum_list (concat (map (\\<lambda>i. map (f i) as) [])) +\n    sum_list (concat (map (\\<lambda>i. map (g i) as) []))\n 2. \\<And>a bs.\n       sum_list\n        (concat (map (\\<lambda>i. map (\\<lambda>j. f i j + g i j) as) bs)) =\n       sum_list (concat (map (\\<lambda>i. map (f i) as) bs)) +\n       sum_list\n        (concat (map (\\<lambda>i. map (g i) as) bs)) \\<Longrightarrow>\n       sum_list\n        (concat\n          (map (\\<lambda>i. map (\\<lambda>j. f i j + g i j) as) (a # bs))) =\n       sum_list (concat (map (\\<lambda>i. map (f i) as) (a # bs))) +\n       sum_list (concat (map (\\<lambda>i. map (g i) as) (a # bs)))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. sum_list\n     (concat (map (\\<lambda>i. map (\\<lambda>j. f i j + g i j) as) [])) =\n    sum_list (concat (map (\\<lambda>i. map (f i) as) [])) +\n    sum_list (concat (map (\\<lambda>i. map (g i) as) []))\n 2. \\<And>a bs.\n       sum_list\n        (concat (map (\\<lambda>i. map (\\<lambda>j. f i j + g i j) as) bs)) =\n       sum_list (concat (map (\\<lambda>i. map (f i) as) bs)) +\n       sum_list\n        (concat (map (\\<lambda>i. map (g i) as) bs)) \\<Longrightarrow>\n       sum_list\n        (concat\n          (map (\\<lambda>i. map (\\<lambda>j. f i j + g i j) as) (a # bs))) =\n       sum_list (concat (map (\\<lambda>i. map (f i) as) (a # bs))) +\n       sum_list (concat (map (\\<lambda>i. map (g i) as) (a # bs)))", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (concat (map (\\<lambda>i. map (\\<lambda>j. f i j + g i j) as) [])) =\n    sum_list (concat (map (\\<lambda>i. map (f i) as) [])) +\n    sum_list (concat (map (\\<lambda>i. map (g i) as) []))", "by simp"], ["proof (state)\nthis:\n  sum_list\n   (concat (map (\\<lambda>i. map (\\<lambda>j. f i j + g i j) as) [])) =\n  sum_list (concat (map (\\<lambda>i. map (f i) as) [])) +\n  sum_list (concat (map (\\<lambda>i. map (g i) as) []))\n\ngoal (1 subgoal):\n 1. \\<And>a bs.\n       sum_list\n        (concat (map (\\<lambda>i. map (\\<lambda>j. f i j + g i j) as) bs)) =\n       sum_list (concat (map (\\<lambda>i. map (f i) as) bs)) +\n       sum_list\n        (concat (map (\\<lambda>i. map (g i) as) bs)) \\<Longrightarrow>\n       sum_list\n        (concat\n          (map (\\<lambda>i. map (\\<lambda>j. f i j + g i j) as) (a # bs))) =\n       sum_list (concat (map (\\<lambda>i. map (f i) as) (a # bs))) +\n       sum_list (concat (map (\\<lambda>i. map (g i) as) (a # bs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a bs.\n       sum_list\n        (concat (map (\\<lambda>i. map (\\<lambda>j. f i j + g i j) as) bs)) =\n       sum_list (concat (map (\\<lambda>i. map (f i) as) bs)) +\n       sum_list\n        (concat (map (\\<lambda>i. map (g i) as) bs)) \\<Longrightarrow>\n       sum_list\n        (concat\n          (map (\\<lambda>i. map (\\<lambda>j. f i j + g i j) as) (a # bs))) =\n       sum_list (concat (map (\\<lambda>i. map (f i) as) (a # bs))) +\n       sum_list (concat (map (\\<lambda>i. map (g i) as) (a # bs)))", "case (Cons b bs)"], ["proof (state)\nthis:\n  sum_list\n   (concat (map (\\<lambda>i. map (\\<lambda>j. f i j + g i j) as) bs)) =\n  sum_list (concat (map (\\<lambda>i. map (f i) as) bs)) +\n  sum_list (concat (map (\\<lambda>i. map (g i) as) bs))\n\ngoal (1 subgoal):\n 1. \\<And>a bs.\n       sum_list\n        (concat (map (\\<lambda>i. map (\\<lambda>j. f i j + g i j) as) bs)) =\n       sum_list (concat (map (\\<lambda>i. map (f i) as) bs)) +\n       sum_list\n        (concat (map (\\<lambda>i. map (g i) as) bs)) \\<Longrightarrow>\n       sum_list\n        (concat\n          (map (\\<lambda>i. map (\\<lambda>j. f i j + g i j) as) (a # bs))) =\n       sum_list (concat (map (\\<lambda>i. map (f i) as) (a # bs))) +\n       sum_list (concat (map (\\<lambda>i. map (g i) as) (a # bs)))", "have id: \"(\\<Sum>j\\<leftarrow>as. f b j + g b j) = sum_list (map (f b) as) + sum_list (map (g b) as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>as. f b j + g b j) =\n    sum_list (map (f b) as) + sum_list (map (g b) as)", "by (induct as, auto simp: ac_simps)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<leftarrow>as. f b j + g b j) =\n  sum_list (map (f b) as) + sum_list (map (g b) as)\n\ngoal (1 subgoal):\n 1. \\<And>a bs.\n       sum_list\n        (concat (map (\\<lambda>i. map (\\<lambda>j. f i j + g i j) as) bs)) =\n       sum_list (concat (map (\\<lambda>i. map (f i) as) bs)) +\n       sum_list\n        (concat (map (\\<lambda>i. map (g i) as) bs)) \\<Longrightarrow>\n       sum_list\n        (concat\n          (map (\\<lambda>i. map (\\<lambda>j. f i j + g i j) as) (a # bs))) =\n       sum_list (concat (map (\\<lambda>i. map (f i) as) (a # bs))) +\n       sum_list (concat (map (\\<lambda>i. map (g i) as) (a # bs)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (concat\n       (map (\\<lambda>i. map (\\<lambda>j. f i j + g i j) as) (b # bs))) =\n    sum_list (concat (map (\\<lambda>i. map (f i) as) (b # bs))) +\n    sum_list (concat (map (\\<lambda>i. map (g i) as) (b # bs)))", "unfolding list.map concat.simps sum_list_append"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>as. f b j + g b j) +\n    sum_list\n     (concat (map (\\<lambda>i. map (\\<lambda>j. f i j + g i j) as) bs)) =\n    sum_list (map (f b) as) +\n    sum_list (concat (map (\\<lambda>i. map (f i) as) bs)) +\n    (sum_list (map (g b) as) +\n     sum_list (concat (map (\\<lambda>i. map (g i) as) bs)))", "unfolding Cons"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<leftarrow>as. f b j + g b j) +\n    (sum_list (concat (map (\\<lambda>i. map (f i) as) bs)) +\n     sum_list (concat (map (\\<lambda>i. map (g i) as) bs))) =\n    sum_list (map (f b) as) +\n    sum_list (concat (map (\\<lambda>i. map (f i) as) bs)) +\n    (sum_list (map (g b) as) +\n     sum_list (concat (map (\\<lambda>i. map (g i) as) bs)))", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map (f b) as) + sum_list (map (g b) as) +\n    (sum_list (concat (map (\\<lambda>i. map (f i) as) bs)) +\n     sum_list (concat (map (\\<lambda>i. map (g i) as) bs))) =\n    sum_list (map (f b) as) +\n    sum_list (concat (map (\\<lambda>i. map (f i) as) bs)) +\n    (sum_list (map (g b) as) +\n     sum_list (concat (map (\\<lambda>i. map (g i) as) bs)))", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  sum_list\n   (concat\n     (map (\\<lambda>i. map (\\<lambda>j. f i j + g i j) as) (b # bs))) =\n  sum_list (concat (map (\\<lambda>i. map (f i) as) (b # bs))) +\n  sum_list (concat (map (\\<lambda>i. map (g i) as) (b # bs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "fun max_list :: \"nat list \\<Rightarrow> nat\" where\n  \"max_list [] = 0\"\n| \"max_list (x # xs) = max x (max_list xs)\""], ["", "lemma max_list: \"x \\<in> set xs \\<Longrightarrow> x \\<le> max_list xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set xs \\<Longrightarrow> x \\<le> max_list xs", "by (induct xs) auto"], ["", "lemma max_list_mem: \"xs \\<noteq> [] \\<Longrightarrow> max_list xs \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow> max_list xs \\<in> set xs", "proof (induct xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow> max_list [] \\<in> set []\n 2. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow> max_list xs \\<in> set xs;\n        a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> max_list (a # xs) \\<in> set (a # xs)", "case (Cons x xs)"], ["proof (state)\nthis:\n  xs \\<noteq> [] \\<Longrightarrow> max_list xs \\<in> set xs\n  x # xs \\<noteq> []\n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<Longrightarrow> max_list [] \\<in> set []\n 2. \\<And>a xs.\n       \\<lbrakk>xs \\<noteq> [] \\<Longrightarrow> max_list xs \\<in> set xs;\n        a # xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> max_list (a # xs) \\<in> set (a # xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. max_list (x # xs) \\<in> set (x # xs)", "proof (cases \"x \\<ge> max_list xs\")"], ["proof (state)\ngoal (2 subgoals):\n 1. max_list xs \\<le> x \\<Longrightarrow>\n    max_list (x # xs) \\<in> set (x # xs)\n 2. \\<not> max_list xs \\<le> x \\<Longrightarrow>\n    max_list (x # xs) \\<in> set (x # xs)", "case True"], ["proof (state)\nthis:\n  max_list xs \\<le> x\n\ngoal (2 subgoals):\n 1. max_list xs \\<le> x \\<Longrightarrow>\n    max_list (x # xs) \\<in> set (x # xs)\n 2. \\<not> max_list xs \\<le> x \\<Longrightarrow>\n    max_list (x # xs) \\<in> set (x # xs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  max_list xs \\<le> x\n\ngoal (1 subgoal):\n 1. max_list (x # xs) \\<in> set (x # xs)", "by auto"], ["proof (state)\nthis:\n  max_list (x # xs) \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. \\<not> max_list xs \\<le> x \\<Longrightarrow>\n    max_list (x # xs) \\<in> set (x # xs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> max_list xs \\<le> x \\<Longrightarrow>\n    max_list (x # xs) \\<in> set (x # xs)", "case False"], ["proof (state)\nthis:\n  \\<not> max_list xs \\<le> x\n\ngoal (1 subgoal):\n 1. \\<not> max_list xs \\<le> x \\<Longrightarrow>\n    max_list (x # xs) \\<in> set (x # xs)", "hence max: \"max_list xs > x\""], ["proof (prove)\nusing this:\n  \\<not> max_list xs \\<le> x\n\ngoal (1 subgoal):\n 1. x < max_list xs", "by auto"], ["proof (state)\nthis:\n  x < max_list xs\n\ngoal (1 subgoal):\n 1. \\<not> max_list xs \\<le> x \\<Longrightarrow>\n    max_list (x # xs) \\<in> set (x # xs)", "hence nil: \"xs \\<noteq> []\""], ["proof (prove)\nusing this:\n  x < max_list xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> []", "by (cases xs, auto)"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> max_list xs \\<le> x \\<Longrightarrow>\n    max_list (x # xs) \\<in> set (x # xs)", "from max"], ["proof (chain)\npicking this:\n  x < max_list xs", "have max: \"max x (max_list xs) = max_list xs\""], ["proof (prove)\nusing this:\n  x < max_list xs\n\ngoal (1 subgoal):\n 1. max x (max_list xs) = max_list xs", "by auto"], ["proof (state)\nthis:\n  max x (max_list xs) = max_list xs\n\ngoal (1 subgoal):\n 1. \\<not> max_list xs \\<le> x \\<Longrightarrow>\n    max_list (x # xs) \\<in> set (x # xs)", "from Cons(1)[OF nil] max"], ["proof (chain)\npicking this:\n  max_list xs \\<in> set xs\n  max x (max_list xs) = max_list xs", "show ?thesis"], ["proof (prove)\nusing this:\n  max_list xs \\<in> set xs\n  max x (max_list xs) = max_list xs\n\ngoal (1 subgoal):\n 1. max_list (x # xs) \\<in> set (x # xs)", "by auto"], ["proof (state)\nthis:\n  max_list (x # xs) \\<in> set (x # xs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  max_list (x # xs) \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<Longrightarrow> max_list [] \\<in> set []", "qed simp"], ["", "lemma max_list_set: \"max_list xs = (if set xs = {} then 0 else (THE x. x \\<in> set xs \\<and> (\\<forall> y \\<in> set xs. y \\<le> x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max_list xs =\n    (if set xs = {} then 0\n     else THE x. x \\<in> set xs \\<and> (\\<forall>y\\<in>set xs. y \\<le> x))", "proof (cases \"xs = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    max_list xs =\n    (if set xs = {} then 0\n     else THE x. x \\<in> set xs \\<and> (\\<forall>y\\<in>set xs. y \\<le> x))\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    max_list xs =\n    (if set xs = {} then 0\n     else THE x. x \\<in> set xs \\<and> (\\<forall>y\\<in>set xs. y \\<le> x))", "case True"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    max_list xs =\n    (if set xs = {} then 0\n     else THE x. x \\<in> set xs \\<and> (\\<forall>y\\<in>set xs. y \\<le> x))\n 2. xs \\<noteq> [] \\<Longrightarrow>\n    max_list xs =\n    (if set xs = {} then 0\n     else THE x. x \\<in> set xs \\<and> (\\<forall>y\\<in>set xs. y \\<le> x))", "thus ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. max_list xs =\n    (if set xs = {} then 0\n     else THE x. x \\<in> set xs \\<and> (\\<forall>y\\<in>set xs. y \\<le> x))", "by simp"], ["proof (state)\nthis:\n  max_list xs =\n  (if set xs = {} then 0\n   else THE x. x \\<in> set xs \\<and> (\\<forall>y\\<in>set xs. y \\<le> x))\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    max_list xs =\n    (if set xs = {} then 0\n     else THE x. x \\<in> set xs \\<and> (\\<forall>y\\<in>set xs. y \\<le> x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    max_list xs =\n    (if set xs = {} then 0\n     else THE x. x \\<in> set xs \\<and> (\\<forall>y\\<in>set xs. y \\<le> x))", "case False"], ["proof (state)\nthis:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    max_list xs =\n    (if set xs = {} then 0\n     else THE x. x \\<in> set xs \\<and> (\\<forall>y\\<in>set xs. y \\<le> x))", "note p = max_list_mem[OF this] max_list[of _ xs]"], ["proof (state)\nthis:\n  max_list xs \\<in> set xs\n  ?x \\<in> set xs \\<Longrightarrow> ?x \\<le> max_list xs\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    max_list xs =\n    (if set xs = {} then 0\n     else THE x. x \\<in> set xs \\<and> (\\<forall>y\\<in>set xs. y \\<le> x))", "from False"], ["proof (chain)\npicking this:\n  xs \\<noteq> []", "have id: \"(set xs = {}) = False\""], ["proof (prove)\nusing this:\n  xs \\<noteq> []\n\ngoal (1 subgoal):\n 1. (set xs = {}) = False", "by simp"], ["proof (state)\nthis:\n  (set xs = {}) = False\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [] \\<Longrightarrow>\n    max_list xs =\n    (if set xs = {} then 0\n     else THE x. x \\<in> set xs \\<and> (\\<forall>y\\<in>set xs. y \\<le> x))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. max_list xs =\n    (if set xs = {} then 0\n     else THE x. x \\<in> set xs \\<and> (\\<forall>y\\<in>set xs. y \\<le> x))", "unfolding id if_False"], ["proof (prove)\ngoal (1 subgoal):\n 1. max_list xs =\n    (THE x. x \\<in> set xs \\<and> (\\<forall>y\\<in>set xs. y \\<le> x))", "proof (rule the_equality[symmetric], intro conjI ballI, rule p, rule p)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y. y \\<in> set xs \\<Longrightarrow> y \\<in> set xs\n 2. \\<And>x.\n       x \\<in> set xs \\<and>\n       (\\<forall>y\\<in>set xs. y \\<le> x) \\<Longrightarrow>\n       x = max_list xs", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y. y \\<in> set xs \\<Longrightarrow> y \\<in> set xs\n 2. \\<And>x.\n       x \\<in> set xs \\<and>\n       (\\<forall>y\\<in>set xs. y \\<le> x) \\<Longrightarrow>\n       x = max_list xs", "assume \"x \\<in> set xs \\<and> (\\<forall> y \\<in> set xs. y \\<le> x)\""], ["proof (state)\nthis:\n  x \\<in> set xs \\<and> (\\<forall>y\\<in>set xs. y \\<le> x)\n\ngoal (2 subgoals):\n 1. \\<And>y. y \\<in> set xs \\<Longrightarrow> y \\<in> set xs\n 2. \\<And>x.\n       x \\<in> set xs \\<and>\n       (\\<forall>y\\<in>set xs. y \\<le> x) \\<Longrightarrow>\n       x = max_list xs", "hence mem: \"x \\<in> set xs\" and le: \"\\<And> y. y \\<in> set xs \\<Longrightarrow> y \\<le> x\""], ["proof (prove)\nusing this:\n  x \\<in> set xs \\<and> (\\<forall>y\\<in>set xs. y \\<le> x)\n\ngoal (1 subgoal):\n 1. x \\<in> set xs &&& (\\<And>y. y \\<in> set xs \\<Longrightarrow> y \\<le> x)", "by auto"], ["proof (state)\nthis:\n  x \\<in> set xs\n  ?y \\<in> set xs \\<Longrightarrow> ?y \\<le> x\n\ngoal (2 subgoals):\n 1. \\<And>y. y \\<in> set xs \\<Longrightarrow> y \\<in> set xs\n 2. \\<And>x.\n       x \\<in> set xs \\<and>\n       (\\<forall>y\\<in>set xs. y \\<le> x) \\<Longrightarrow>\n       x = max_list xs", "from max_list[OF mem] le[OF max_list_mem[OF False]]"], ["proof (chain)\npicking this:\n  x \\<le> max_list xs\n  max_list xs \\<le> x", "show \"x = max_list xs\""], ["proof (prove)\nusing this:\n  x \\<le> max_list xs\n  max_list xs \\<le> x\n\ngoal (1 subgoal):\n 1. x = max_list xs", "by simp"], ["proof (state)\nthis:\n  x = max_list xs\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> set xs \\<Longrightarrow> y \\<in> set xs", "qed"], ["proof (state)\nthis:\n  max_list xs =\n  (if set xs = {} then 0\n   else THE x. x \\<in> set xs \\<and> (\\<forall>y\\<in>set xs. y \\<le> x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma max_list_eq_set: \"set xs = set ys \\<Longrightarrow> max_list xs = max_list ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs = set ys \\<Longrightarrow> max_list xs = max_list ys", "unfolding max_list_set"], ["proof (prove)\ngoal (1 subgoal):\n 1. set xs = set ys \\<Longrightarrow>\n    (if set xs = {} then 0\n     else THE x. x \\<in> set xs \\<and> (\\<forall>y\\<in>set xs. y \\<le> x)) =\n    (if set ys = {} then 0\n     else THE x. x \\<in> set ys \\<and> (\\<forall>y\\<in>set ys. y \\<le> x))", "by simp"], ["", "lemma all_less_two: \"(\\<forall> i < Suc (Suc 0). P i) = (P 0 \\<and> P (Suc 0))\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i<Suc (Suc 0). P i) = (P 0 \\<and> P (Suc 0))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i<Suc (Suc 0). P i \\<Longrightarrow> P 0 \\<and> P (Suc 0)\n 2. P 0 \\<and> P (Suc 0) \\<Longrightarrow> \\<forall>i<Suc (Suc 0). P i", "assume ?r"], ["proof (state)\nthis:\n  P 0 \\<and> P (Suc 0)\n\ngoal (2 subgoals):\n 1. \\<forall>i<Suc (Suc 0). P i \\<Longrightarrow> P 0 \\<and> P (Suc 0)\n 2. P 0 \\<and> P (Suc 0) \\<Longrightarrow> \\<forall>i<Suc (Suc 0). P i", "show ?l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<Suc (Suc 0). P i", "proof(intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < Suc (Suc 0) \\<Longrightarrow> P i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < Suc (Suc 0) \\<Longrightarrow> P i", "assume \"i < Suc (Suc 0)\""], ["proof (state)\nthis:\n  i < Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. \\<And>i. i < Suc (Suc 0) \\<Longrightarrow> P i", "hence \"i = 0 \\<or> i = Suc 0\""], ["proof (prove)\nusing this:\n  i < Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. i = 0 \\<or> i = Suc 0", "by auto"], ["proof (state)\nthis:\n  i = 0 \\<or> i = Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>i. i < Suc (Suc 0) \\<Longrightarrow> P i", "with \\<open>?r\\<close>"], ["proof (chain)\npicking this:\n  P 0 \\<and> P (Suc 0)\n  i = 0 \\<or> i = Suc 0", "show \"P i\""], ["proof (prove)\nusing this:\n  P 0 \\<and> P (Suc 0)\n  i = 0 \\<or> i = Suc 0\n\ngoal (1 subgoal):\n 1. P i", "by auto"], ["proof (state)\nthis:\n  P i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i<Suc (Suc 0). P i\n\ngoal (1 subgoal):\n 1. \\<forall>i<Suc (Suc 0). P i \\<Longrightarrow> P 0 \\<and> P (Suc 0)", "qed auto"], ["", "text \\<open>Induction over a finite set of natural numbers.\\<close>"], ["", "lemma bound_nat_induct[consumes 1]:\n  assumes \"n \\<in> {l..u}\" and \"P l\" and \"\\<And>n. \\<lbrakk>P n; n \\<in> {l..<u}\\<rbrakk> \\<Longrightarrow> P (Suc n)\"\n  shows \"P n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P n", "using assms"], ["proof (prove)\nusing this:\n  n \\<in> {l..u}\n  P l\n  \\<lbrakk>P ?n; ?n \\<in> {l..<u}\\<rbrakk> \\<Longrightarrow> P (Suc ?n)\n\ngoal (1 subgoal):\n 1. P n", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<in> {l..u}; P l;\n     \\<And>n.\n        \\<lbrakk>P n; n \\<in> {l..<u}\\<rbrakk>\n        \\<Longrightarrow> P (Suc n)\\<rbrakk>\n    \\<Longrightarrow> P 0\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>n \\<in> {l..u}; P l;\n                 \\<And>n.\n                    \\<lbrakk>P n; n \\<in> {l..<u}\\<rbrakk>\n                    \\<Longrightarrow> P (Suc n)\\<rbrakk>\n                \\<Longrightarrow> P n;\n        Suc n \\<in> {l..u}; P l;\n        \\<And>n.\n           \\<lbrakk>P n; n \\<in> {l..<u}\\<rbrakk>\n           \\<Longrightarrow> P (Suc n)\\<rbrakk>\n       \\<Longrightarrow> P (Suc n)", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<in> {l..u}; P l;\n   \\<And>n.\n      \\<lbrakk>P n; n \\<in> {l..<u}\\<rbrakk>\n      \\<Longrightarrow> P (Suc n)\\<rbrakk>\n  \\<Longrightarrow> P n\n  Suc n \\<in> {l..u}\n  P l\n  \\<lbrakk>P ?n; ?n \\<in> {l..<u}\\<rbrakk> \\<Longrightarrow> P (Suc ?n)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<in> {l..u}; P l;\n     \\<And>n.\n        \\<lbrakk>P n; n \\<in> {l..<u}\\<rbrakk>\n        \\<Longrightarrow> P (Suc n)\\<rbrakk>\n    \\<Longrightarrow> P 0\n 2. \\<And>n.\n       \\<lbrakk>\\<lbrakk>n \\<in> {l..u}; P l;\n                 \\<And>n.\n                    \\<lbrakk>P n; n \\<in> {l..<u}\\<rbrakk>\n                    \\<Longrightarrow> P (Suc n)\\<rbrakk>\n                \\<Longrightarrow> P n;\n        Suc n \\<in> {l..u}; P l;\n        \\<And>n.\n           \\<lbrakk>P n; n \\<in> {l..<u}\\<rbrakk>\n           \\<Longrightarrow> P (Suc n)\\<rbrakk>\n       \\<Longrightarrow> P (Suc n)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>n \\<in> {l..u}; P l;\n   \\<And>n.\n      \\<lbrakk>P n; n \\<in> {l..<u}\\<rbrakk>\n      \\<Longrightarrow> P (Suc n)\\<rbrakk>\n  \\<Longrightarrow> P n\n  Suc n \\<in> {l..u}\n  P l\n  \\<lbrakk>P ?n; ?n \\<in> {l..<u}\\<rbrakk> \\<Longrightarrow> P (Suc ?n)\n\ngoal (1 subgoal):\n 1. P (Suc n)", "by (cases \"Suc n = l\") auto"], ["proof (state)\nthis:\n  P (Suc n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<in> {l..u}; P l;\n     \\<And>n.\n        \\<lbrakk>P n; n \\<in> {l..<u}\\<rbrakk>\n        \\<Longrightarrow> P (Suc n)\\<rbrakk>\n    \\<Longrightarrow> P 0", "qed simp"], ["", "end"]]}