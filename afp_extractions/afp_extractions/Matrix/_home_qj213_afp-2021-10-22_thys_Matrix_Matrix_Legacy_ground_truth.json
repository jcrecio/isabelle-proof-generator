{"file_name": "/home/qj213/afp-2021-10-22/thys/Matrix/Matrix_Legacy.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Matrix", "problem_names": ["lemma vec0[simp,intro]: \"vec nr (vec0I ze nr)\"", "lemma replicate_prop:\n  assumes \"P x\"\n  shows \"\\<forall>y\\<in>set (replicate n x). P y\"", "lemma mat0[simp,intro]: \"mat nr nc (mat0I ze nr nc)\"", "lemma vec1[simp,intro]: assumes \"i < nr\" shows \"vec nr (vec1I ze on nr i)\"", "lemma mat1[simp,intro]: \"mat nr nr (mat1I ze on nr)\"", "lemma vec_plus[simp,intro]: \"\\<lbrakk>vec nr u; vec nr v\\<rbrakk> \\<Longrightarrow> vec nr (vec_plusI pl u v)\"", "lemma mat_plus[simp,intro]: assumes \"mat nr nc m1\" and \"mat nr nc m2\" shows \"mat nr nc (mat_plusI pl m1 m2)\"", "lemma vec_map[simp,intro]: \"vec nr u \\<Longrightarrow> vec nr (vec_map f u)\"", "lemma mat_map[simp,intro]: \"mat nr nc m \\<Longrightarrow> mat nr nc (mat_map f m)\"", "lemma concat_mat: \"mat nr nc m \\<Longrightarrow>\n  concat m = [ m ! i ! j. i \\<leftarrow> [0 ..< nc], j \\<leftarrow> [0 ..< nr] ]\"", "lemma row: assumes \"mat nr nc m\"\n  and \"i < nr\"\n  shows \"vec nc (row m i)\"", "lemma col: assumes \"mat nr nc m\"\n  and \"i < nc\"\n  shows \"vec nr (col m i)\"", "lemma transpose[simp,intro]: assumes \"mat nr nc m\"\n  shows \"mat nc nr (transpose nr m)\"", "lemma matT_vec_multI: assumes \"mat nr nc m\"\n  shows \"vec nc (matT_vec_multI ze pl ti m v)\"", "lemma mat_mult[simp,intro]: assumes wf1: \"mat nr n m1\"\n  and wf2: \"mat n nc m2\"\n  shows \"mat nr nc (mat_multI ze pl ti nr m1 m2)\"", "lemma mat_pow[simp,intro]: assumes \"mat n n m\"\n  shows \"mat n n (mat_powI ze on pl ti n m i)\"", "lemma sub_vec[simp,intro]: assumes \"vec nr v\" and \"sd \\<le> nr\"\n  shows \"vec sd (sub_vec sd v)\"", "lemma sub_mat[simp,intro]: assumes wf: \"mat nr nc m\" and sr: \"sr \\<le> nr\" and sc: \"sc \\<le> nc\"\n  shows \"mat sr sc (sub_mat sr sc m)\"", "lemma mat0_index[simp]: assumes \"i < nc\" and \"j < nr\"\n  shows \"mat0I ze nr nc ! i ! j = ze\"", "lemma mat0_row[simp]: assumes \"i < nr\"\n  shows \"row (mat0I ze nr nc) i = vec0I ze nc\"", "lemma mat0_col[simp]: assumes \"i < nc\"\n  shows \"col (mat0I ze nr nc) i = vec0I ze nr\"", "lemma vec1_index: assumes j: \"j < n\"\n  shows \"vec1I ze on n i ! j = (if i = j then on else ze)\" (is \"_ = ?r\")", "lemma col_transpose_is_row[simp]:\n  assumes wf: \"mat nr nc m\"\n  and i: \"i < nr\"\n  shows \"col (transpose nr m) i = row m i\"", "lemma mat_col_eq:\n  assumes wf1: \"mat nr nc m1\"\n  and wf2: \"mat nr nc m2\"\n  shows \"(m1 = m2) = (\\<forall> i < nc. col m1 i = col m2 i)\" (is \"?l = ?r\")", "lemma mat_col_eqI:\n  assumes wf1: \"mat nr nc m1\"\n  and wf2: \"mat nr nc m2\"\n  and id: \"\\<And> i. i < nc \\<Longrightarrow> col m1 i = col m2 i\"\n  shows \"m1 = m2\"", "lemma mat_eq:\n  assumes wf1: \"mat nr nc m1\"\n  and wf2: \"mat nr nc m2\"\n  shows \"(m1 = m2) = (\\<forall> i < nc. \\<forall> j < nr. m1 ! i ! j = m2 ! i ! j)\" (is \"?l = ?r\")", "lemma mat_eqI:\n  assumes wf1: \"mat nr nc m1\"\n  and wf2: \"mat nr nc m2\"\n  and id: \"\\<And> i j. i < nc \\<Longrightarrow> j < nr \\<Longrightarrow> m1 ! i ! j = m2 ! i ! j\"\n  shows \"m1 = m2\"", "lemma vec_eq:\n  assumes wf1: \"vec n v1\"\n  and wf2: \"vec n v2\"\n  shows \"(v1 = v2) = (\\<forall> i < n. v1 ! i = v2 ! i)\" (is \"?l = ?r\")", "lemma vec_eqI:\n  assumes wf1: \"vec n v1\"\n  and wf2: \"vec n v2\"\n  and id: \"\\<And> i. i < n \\<Longrightarrow> v1 ! i = v2 ! i\"\n  shows \"v1 = v2\"", "lemma row_col: assumes \"mat nr nc m\"\n  and \"i < nr\" and \"j < nc\"\n  shows \"row m i ! j = col m j ! i\"", "lemma col_index: assumes m: \"mat nr nc m\"\n  and i: \"i < nc\"\n  shows \"col m i = map (\\<lambda> j. m ! i ! j) [0 ..< nr]\"", "lemma row_index: assumes m: \"mat nr nc m\"\n  and i: \"i < nr\"\n  shows \"row m i = map (\\<lambda> j. m ! j ! i) [0 ..< nc]\"", "lemma mat_row_eq:\n  assumes wf1: \"mat nr nc m1\"\n  and wf2: \"mat nr nc m2\"\n  shows \"(m1 = m2) = (\\<forall> i < nr. row m1 i = row m2 i)\" (is \"?l = ?r\")", "lemma mat_row_eqI:\n  assumes wf1: \"mat nr nc m1\"\n  and wf2: \"mat nr nc m2\"\n  and id: \"\\<And> i. i < nr \\<Longrightarrow> row m1 i = row m2 i\"\n  shows \"m1 = m2\"", "lemma row_transpose_is_col[simp]:   assumes wf: \"mat nr nc m\"\n  and i: \"i < nc\"\n  shows \"row (transpose nr m) i = col m i\"", "lemma matT_vec_mult_to_scalar:\n  assumes \"mat nr nc m\"\n  and \"vec nr v\"\n  and \"i < nc\"\n  shows \"matT_vec_multI ze pl ti m v ! i = scalar_prodI ze pl ti (col m i) v\"", "lemma mat_vec_mult_index:\n  assumes wf: \"mat nr nc m\"\n  and wfV: \"vec nc v\"\n  and i: \"i < nr\"\n  shows \"matT_vec_multI ze pl ti (transpose nr m) v ! i = scalar_prodI ze pl ti (row m i) v\"", "lemma mat_mult_index[simp] :\n  assumes wf1: \"mat nr n m1\"\n  and wf2: \"mat n nc m2\"\n  and i: \"i < nr\"\n  and j: \"j < nc\"\n  shows \"mat_multI ze pl ti nr m1 m2 ! j ! i = scalar_prodI ze pl ti (row m1 i) (col m2 j)\"", "lemma col_mat_mult_index :\n  assumes wf1: \"mat nr n m1\"\n  and wf2: \"mat n nc m2\"\n  and j: \"j < nc\"\n  shows \"col (mat_multI ze pl ti nr m1 m2) j = map (\\<lambda> i. scalar_prodI ze pl ti (row m1 i) (col m2 j)) [0 ..< nr]\" (is \"col ?l j = ?r\")", "lemma row_mat_mult_index :\n  assumes wf1: \"mat nr n m1\"\n  and wf2: \"mat n nc m2\"\n  and i: \"i < nr\"\n  shows \"row (mat_multI ze pl ti nr m1 m2) i = map (\\<lambda> j. scalar_prodI ze pl ti (row m1 i) (col m2 j)) [0 ..< nc]\" (is \"row ?l i = ?r\")", "lemma scalar_prod_cons:\n  \"scalar_prodI ze pl ti (a # as) (b # bs) = pl (ti a b) (scalar_prodI ze pl ti as bs)\"", "lemma vec_plus_index[simp]:\n  assumes wf1: \"vec nr v1\"\n  and wf2: \"vec nr v2\"\n  and i: \"i < nr\"\n  shows \"vec_plusI pl v1 v2 ! i = pl (v1 ! i)  (v2 ! i)\"", "lemma mat_map_index[simp]: assumes wf: \"mat nr nc m\" and i: \"i < nc\" and j: \"j < nr\"\n  shows \"mat_map f m ! i ! j = f (m ! i ! j)\"", "lemma mat_plus_index[simp]:\n  assumes wf1: \"mat nr nc m1\"\n  and wf2: \"mat nr nc m2\"\n  and i: \"i < nc\"\n  and j: \"j < nr\"\n  shows \"mat_plusI pl m1 m2 ! i ! j = pl (m1 ! i ! j) (m2 ! i ! j)\"", "lemma col_mat_plus: assumes wf1: \"mat nr nc m1\"\n  and wf2: \"mat nr nc m2\"\n  and i: \"i < nc\"\n  shows \"col (mat_plusI pl m1 m2) i = vec_plusI pl (col m1 i) (col m2 i)\"", "lemma transpose_index[simp]: assumes wf: \"mat nr nc m\"\n  and i: \"i < nr\"\n  and j: \"j < nc\"\n  shows \"transpose nr m ! i ! j = m ! j ! i\"", "lemma transpose_mat_plus: assumes wf: \"mat nr nc m1\" \"mat nr nc m2\"\n  shows \"transpose nr (mat_plusI pl m1 m2) = mat_plusI pl (transpose nr m1) (transpose nr m2)\" (is \"?l = ?r\")", "lemma row_mat_plus: assumes wf1: \"mat nr nc m1\"\n  and wf2: \"mat nr nc m2\"\n  and i: \"i < nr\"\n  shows \"row (mat_plusI pl m1 m2) i = vec_plusI pl (row m1 i) (row m2 i)\"", "lemma col_mat1: assumes \"i < nr\"\n  shows \"col (mat1I ze on nr) i = vec1I ze on nr i\"", "lemma mat1_index: assumes i: \"i < n\" and j: \"j < n\"\n  shows \"mat1I ze on n ! i ! j = (if i = j then on else ze)\"", "lemma transpose_mat1: \"transpose nr (mat1I ze on nr) = (mat1I ze on nr)\" (is \"?l = ?r\")", "lemma row_mat1: assumes i: \"i < nr\"\n  shows \"row (mat1I ze on nr) i = vec1I ze on nr i\"", "lemma sub_mat_index:\n  assumes wf: \"mat nr nc m\"\n  and sr: \"sr \\<le> nr\"\n  and sc: \"sc \\<le> nc\"\n  and j: \"j < sr\"\n  and i: \"i < sc\"\n  shows \"sub_mat sr sc m ! i ! j = m ! i ! j\"", "lemma vec_plus_assoc: assumes vec: \"vec nr u\" \"vec nr v\" \"vec nr w\"\n shows \"vec_plus u (vec_plus v w) = vec_plus (vec_plus u v) w\"", "lemma mat_plus_assoc: assumes wf: \"mat nr nc m1\" \"mat nr nc m2\" \"mat nr nc m3\"\n  shows \"mat_plus m1 (mat_plus m2 m3) = mat_plus (mat_plus m1 m2) m3\" (is \"?l = ?r\")", "lemma vec_plus_comm: \"vec_plus x y = vec_plus y x\"", "lemma mat_plus_comm: \"mat_plus m1 m2 = mat_plus m2 m1\"", "lemma vec0_plus[simp]: assumes \"vec nr u\" shows \"vec_plus (vec0 nr) u = u\"", "lemma plus_vec0[simp]: assumes \"vec nr u\" shows \"vec_plus u (vec0 nr) = u\"", "lemma plus_mat0[simp]: assumes wf: \"mat nr nc m\" shows \"mat_plus m (mat0 nr nc) = m\" (is \"?l = ?r\")", "lemma mat0_plus[simp]: assumes wf: \"mat nr nc m\" shows \"mat_plus (mat0 nr nc) m = m\" (is \"?l = ?r\")", "lemma scalar_prod: \"scalar_prod v1 v2 = sum_list (map (\\<lambda>(x,y). x * y) (zip v1 v2))\"", "lemma scalar_prod_last: assumes \"length v1 = length v2\"\n  shows \"scalar_prod (v1 @ [x1]) (v2 @ [x2]) = x1 * x2 + scalar_prod v1 v2\"", "lemma scalar_product_assoc:\n  assumes wfm: \"mat nr nc m\"\n  and wfr: \"vec nr r\"\n  and wfc: \"vec nc c\"\n  shows \"scalar_prod (map (\\<lambda>k. scalar_prod r (col m k)) [0..<nc]) c = scalar_prod r (map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr])\"", "lemma mat_mult_assoc:\n  assumes wf1: \"mat nr n1 m1\"\n  and wf2: \"mat n1 n2 m2\"\n  and wf3: \"mat n2 nc m3\"\n  shows \"mat_mult nr (mat_mult nr m1 m2) m3 = mat_mult nr m1 (mat_mult n1 m2 m3)\" (is \"?m12_3 = ?m1_23\")", "lemma mat_mult_assoc_n:\n  assumes wf1: \"mat n n m1\"\n  and wf2: \"mat n n m2\"\n  and wf3: \"mat n n m3\"\n  shows \"mat_mult n (mat_mult n m1 m2) m3 = mat_mult n m1 (mat_mult n m2 m3)\"", "lemma scalar_left_zero: \"scalar_prod (vec0 nn) v = zero\"", "lemma scalar_right_zero: \"scalar_prod v (vec0 nn) = zero\"", "lemma mat0_mult_left: assumes wf: \"mat nc ncc m\"\n  shows \"mat_mult nr (mat0 nr nc) m = (mat0 nr ncc)\"", "lemma mat0_mult_right: assumes wf: \"mat nr nc m\"\n  shows \"mat_mult nr m (mat0 nc ncc) = (mat0 nr ncc)\"", "lemma scalar_vec_plus_distrib_right:\n  assumes wf1: \"vec nr u\"\n  assumes wf2: \"vec nr v\"\n  assumes wf3: \"vec nr w\"\n  shows \"scalar_prod u (vec_plus v w) = plus (scalar_prod u v) (scalar_prod u w)\"", "lemma scalar_vec_plus_distrib_left:\n  assumes wf1: \"vec nr u\"\n  assumes wf2: \"vec nr v\"\n  assumes wf3: \"vec nr w\"\n  shows \"scalar_prod (vec_plus u v) w = plus (scalar_prod u w) (scalar_prod v w)\"", "lemma mat_mult_plus_distrib_right:\n  assumes wf1: \"mat nr nc m1\"\n  and wf2: \"mat nc ncc m2\"\n  and wf3: \"mat nc ncc m3\"\n  shows \"mat_mult nr m1 (mat_plus m2 m3) = mat_plus (mat_mult nr m1 m2) (mat_mult nr m1 m3)\" (is \"mat_mult nr m1 ?m23 = mat_plus ?m12 ?m13\")", "lemma mat_mult_plus_distrib_left:\n  assumes wf1: \"mat nr nc m1\"\n  and wf2: \"mat nr nc m2\"\n  and wf3: \"mat nc ncc m3\"\n  shows \"mat_mult nr (mat_plus m1 m2) m3 = mat_plus (mat_mult nr m1 m3) (mat_mult nr m2 m3)\" (is \"mat_mult nr ?m12 _ = mat_plus ?m13 ?m23\")", "lemma scalar_left_one: assumes wf: \"vec nn v\"\n  and i: \"i < nn\"\n  shows \"scalar_prod (vec1 nn i) v = v ! i\"", "lemma scalar_right_one: assumes wf: \"vec nn v\"\n  and i: \"i < nn\"\n  shows \"scalar_prod v (vec1 nn i) = v ! i\"", "lemma mat1_mult_right: assumes wf: \"mat nr nc m\"\n  shows \"mat_mult nr m (mat1 nc) = m\"", "lemma mat1_mult_left: assumes wf: \"mat nr nc m\"\n  shows \"mat_mult nr (mat1 nr) m = m\"", "lemma mat_monoid: \"monoid (mat_monoid nr nc b :: (('a :: monoid_add) mat,'b)monoid_scheme)\"", "lemma mat_group: \"group (mat_monoid nr nc b :: (('a :: group_add) mat,'b)monoid_scheme)\" (is \"group ?G\")", "lemma mat_comm_monoid:\n  \"comm_monoid (mat_monoid nr nc b :: (('a :: comm_monoid_add) mat,'b)monoid_scheme)\" (is \"comm_monoid ?G\")", "lemma mat_comm_group:\n  \"comm_group (mat_monoid nr nc b :: (('a :: ab_group_add) mat,'b)monoid_scheme)\" (is \"comm_group ?G\")", "lemma mat_abelian_monoid: \"abelian_monoid (mat_ring n b :: (('a :: semiring_1) mat,'b)ring_scheme)\"", "lemma mat_abelian_group: \"abelian_group (mat_ring n b :: (('a :: {ab_group_add,semiring_1}) mat,'b)ring_scheme)\"\n  (is \"abelian_group ?R\")", "lemma mat_semiring: \"semiring (mat_ring n b :: (('a :: semiring_1) mat,'b)ring_scheme)\"\n  (is \"semiring ?R\")", "lemma mat_ring: \"ring (mat_ring n b :: (('a :: ring_1) mat,'b)ring_scheme)\"\n  (is \"ring ?R\")", "lemma mat_pow_ring_pow: assumes mat: \"mat n n (m :: ('a :: semiring_1)mat)\" shows \"mat_pow n m k = m [^]\\<^bsub>mat_ring n b\\<^esub> k\"\n  (is \"_ = m [^]\\<^bsub>?C\\<^esub> k\")"], "translations": [["", "lemma vec0[simp,intro]: \"vec nr (vec0I ze nr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec nr (vec0I ze nr)", "by (simp add: vec_def vec0I_def)"], ["", "lemma replicate_prop:\n  assumes \"P x\"\n  shows \"\\<forall>y\\<in>set (replicate n x). P y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set (replicate n x). P y", "using assms"], ["proof (prove)\nusing this:\n  P x\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set (replicate n x). P y", "by (induct n) simp_all"], ["", "lemma mat0[simp,intro]: \"mat nr nc (mat0I ze nr nc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat nr nc (mat0I ze nr nc)", "unfolding mat_def mat0I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (replicate nc (vec0I ze nr)) = nc \\<and>\n    Ball (set (replicate nc (vec0I ze nr))) (vec nr)", "using replicate_prop[of \"vec nr\" \"vec0I ze nr\" \"nc\"]"], ["proof (prove)\nusing this:\n  vec nr (vec0I ze nr) \\<Longrightarrow>\n  \\<forall>y\\<in>set (replicate nc (vec0I ze nr)). vec nr y\n\ngoal (1 subgoal):\n 1. length (replicate nc (vec0I ze nr)) = nc \\<and>\n    Ball (set (replicate nc (vec0I ze nr))) (vec nr)", "by simp"], ["", "lemma vec1[simp,intro]: assumes \"i < nr\" shows \"vec nr (vec1I ze on nr i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec nr (vec1I ze on nr i)", "unfolding vec_def vec1I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (replicate i ze @ on # replicate (nr - 1 - i) ze) = nr", "using assms"], ["proof (prove)\nusing this:\n  i < nr\n\ngoal (1 subgoal):\n 1. length (replicate i ze @ on # replicate (nr - 1 - i) ze) = nr", "by auto"], ["", "lemma mat1[simp,intro]: \"mat nr nr (mat1I ze on nr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat nr nr (mat1I ze on nr)", "unfolding mat_def mat1I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (vec1I ze on nr) [0..<nr]) = nr \\<and>\n    Ball (set (map (vec1I ze on nr) [0..<nr])) (vec nr)", "using vec1"], ["proof (prove)\nusing this:\n  ?i < ?nr \\<Longrightarrow> vec ?nr (vec1I ?ze ?on ?nr ?i)\n\ngoal (1 subgoal):\n 1. length (map (vec1I ze on nr) [0..<nr]) = nr \\<and>\n    Ball (set (map (vec1I ze on nr) [0..<nr])) (vec nr)", "by auto"], ["", "lemma vec_plus[simp,intro]: \"\\<lbrakk>vec nr u; vec nr v\\<rbrakk> \\<Longrightarrow> vec nr (vec_plusI pl u v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vec nr u; vec nr v\\<rbrakk>\n    \\<Longrightarrow> vec nr (vec_plusI pl u v)", "unfolding vec_plusI_def vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length u = nr; length v = nr\\<rbrakk>\n    \\<Longrightarrow> length\n                       (map (\\<lambda>xy. pl (fst xy) (snd xy)) (zip u v)) =\n                      nr", "by auto"], ["", "lemma mat_plus[simp,intro]: assumes \"mat nr nc m1\" and \"mat nr nc m2\" shows \"mat nr nc (mat_plusI pl m1 m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat nr nc (mat_plusI pl m1 m2)", "using assms"], ["proof (prove)\nusing this:\n  mat nr nc m1\n  mat nr nc m2\n\ngoal (1 subgoal):\n 1. mat nr nc (mat_plusI pl m1 m2)", "unfolding mat_def mat_plusI_def"], ["proof (prove)\nusing this:\n  length m1 = nc \\<and> Ball (set m1) (vec nr)\n  length m2 = nc \\<and> Ball (set m2) (vec nr)\n\ngoal (1 subgoal):\n 1. length (map (\\<lambda>uv. vec_plusI pl (fst uv) (snd uv)) (zip m1 m2)) =\n    nc \\<and>\n    Ball\n     (set (map (\\<lambda>uv. vec_plusI pl (fst uv) (snd uv)) (zip m1 m2)))\n     (vec nr)", "proof (simp, induct nc arbitrary: m1 m2, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nc m1 m2.\n       \\<lbrakk>\\<And>m1 m2.\n                   \\<lbrakk>length m1 = nc \\<and> Ball (set m1) (vec nr);\n                    length m2 = nc \\<and> Ball (set m2) (vec nr);\n                    length m1 = nc \\<and> Ball (set m1) (vec nr);\n                    length m2 = nc \\<and> Ball (set m2) (vec nr)\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set (zip m1 m2).\n  vec nr (vec_plusI pl (fst x) (snd x));\n        length m1 = Suc nc \\<and> Ball (set m1) (vec nr);\n        length m2 = Suc nc \\<and> Ball (set m2) (vec nr);\n        length m1 = Suc nc \\<and> Ball (set m1) (vec nr);\n        length m2 = Suc nc \\<and> Ball (set m2) (vec nr)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (zip m1 m2).\n                            vec nr (vec_plusI pl (fst x) (snd x))", "case (Suc nn)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?m1.0 = nn \\<and> (\\<forall>a\\<in>set ?m1.0. vec nr a);\n   length ?m2.0 = nn \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   length ?m1.0 = nn \\<and> (\\<forall>a\\<in>set ?m1.0. vec nr a);\n   length ?m2.0 = nn \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (zip ?m1.0 ?m2.0).\n                       vec nr (vec_plusI pl (fst x) (snd x))\n  length m1 = Suc nn \\<and> (\\<forall>a\\<in>set m1. vec nr a)\n  length m2 = Suc nn \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  length m1 = Suc nn \\<and> (\\<forall>a\\<in>set m1. vec nr a)\n  length m2 = Suc nn \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n\ngoal (1 subgoal):\n 1. \\<And>nc m1 m2.\n       \\<lbrakk>\\<And>m1 m2.\n                   \\<lbrakk>length m1 = nc \\<and> Ball (set m1) (vec nr);\n                    length m2 = nc \\<and> Ball (set m2) (vec nr);\n                    length m1 = nc \\<and> Ball (set m1) (vec nr);\n                    length m2 = nc \\<and> Ball (set m2) (vec nr)\\<rbrakk>\n                   \\<Longrightarrow> \\<forall>x\\<in>set (zip m1 m2).\n  vec nr (vec_plusI pl (fst x) (snd x));\n        length m1 = Suc nc \\<and> Ball (set m1) (vec nr);\n        length m2 = Suc nc \\<and> Ball (set m2) (vec nr);\n        length m1 = Suc nc \\<and> Ball (set m1) (vec nr);\n        length m2 = Suc nc \\<and> Ball (set m2) (vec nr)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>set (zip m1 m2).\n                            vec nr (vec_plusI pl (fst x) (snd x))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))", "proof (cases m1)"], ["proof (state)\ngoal (2 subgoals):\n 1. m1 = [] \\<Longrightarrow>\n    \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))\n 2. \\<And>a list.\n       m1 = a # list \\<Longrightarrow>\n       \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))", "case Nil"], ["proof (state)\nthis:\n  m1 = []\n\ngoal (2 subgoals):\n 1. m1 = [] \\<Longrightarrow>\n    \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))\n 2. \\<And>a list.\n       m1 = a # list \\<Longrightarrow>\n       \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))", "with Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?m1.0 = nn \\<and> (\\<forall>a\\<in>set ?m1.0. vec nr a);\n   length ?m2.0 = nn \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   length ?m1.0 = nn \\<and> (\\<forall>a\\<in>set ?m1.0. vec nr a);\n   length ?m2.0 = nn \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (zip ?m1.0 ?m2.0).\n                       vec nr (vec_plusI pl (fst x) (snd x))\n  length m1 = Suc nn \\<and> (\\<forall>a\\<in>set m1. vec nr a)\n  length m2 = Suc nn \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  length m1 = Suc nn \\<and> (\\<forall>a\\<in>set m1. vec nr a)\n  length m2 = Suc nn \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  m1 = []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?m1.0 = nn \\<and> (\\<forall>a\\<in>set ?m1.0. vec nr a);\n   length ?m2.0 = nn \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   length ?m1.0 = nn \\<and> (\\<forall>a\\<in>set ?m1.0. vec nr a);\n   length ?m2.0 = nn \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (zip ?m1.0 ?m2.0).\n                       vec nr (vec_plusI pl (fst x) (snd x))\n  length m1 = Suc nn \\<and> (\\<forall>a\\<in>set m1. vec nr a)\n  length m2 = Suc nn \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  length m1 = Suc nn \\<and> (\\<forall>a\\<in>set m1. vec nr a)\n  length m2 = Suc nn \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  m1 = []\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       m1 = a # list \\<Longrightarrow>\n       \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       m1 = a # list \\<Longrightarrow>\n       \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))", "case (Cons v1 mm1)"], ["proof (state)\nthis:\n  m1 = v1 # mm1\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       m1 = a # list \\<Longrightarrow>\n       \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))", "note oCons = this"], ["proof (state)\nthis:\n  m1 = v1 # mm1\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       m1 = a # list \\<Longrightarrow>\n       \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))", "with Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?m1.0 = nn \\<and> (\\<forall>a\\<in>set ?m1.0. vec nr a);\n   length ?m2.0 = nn \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   length ?m1.0 = nn \\<and> (\\<forall>a\\<in>set ?m1.0. vec nr a);\n   length ?m2.0 = nn \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (zip ?m1.0 ?m2.0).\n                       vec nr (vec_plusI pl (fst x) (snd x))\n  length m1 = Suc nn \\<and> (\\<forall>a\\<in>set m1. vec nr a)\n  length m2 = Suc nn \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  length m1 = Suc nn \\<and> (\\<forall>a\\<in>set m1. vec nr a)\n  length m2 = Suc nn \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  m1 = v1 # mm1", "have l1: \"length mm1 = nn\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?m1.0 = nn \\<and> (\\<forall>a\\<in>set ?m1.0. vec nr a);\n   length ?m2.0 = nn \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   length ?m1.0 = nn \\<and> (\\<forall>a\\<in>set ?m1.0. vec nr a);\n   length ?m2.0 = nn \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (zip ?m1.0 ?m2.0).\n                       vec nr (vec_plusI pl (fst x) (snd x))\n  length m1 = Suc nn \\<and> (\\<forall>a\\<in>set m1. vec nr a)\n  length m2 = Suc nn \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  length m1 = Suc nn \\<and> (\\<forall>a\\<in>set m1. vec nr a)\n  length m2 = Suc nn \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  m1 = v1 # mm1\n\ngoal (1 subgoal):\n 1. length mm1 = nn", "by auto"], ["proof (state)\nthis:\n  length mm1 = nn\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       m1 = a # list \\<Longrightarrow>\n       \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))", "proof (cases m2)"], ["proof (state)\ngoal (2 subgoals):\n 1. m2 = [] \\<Longrightarrow>\n    \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))\n 2. \\<And>a list.\n       m2 = a # list \\<Longrightarrow>\n       \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))", "case Nil"], ["proof (state)\nthis:\n  m2 = []\n\ngoal (2 subgoals):\n 1. m2 = [] \\<Longrightarrow>\n    \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))\n 2. \\<And>a list.\n       m2 = a # list \\<Longrightarrow>\n       \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))", "with Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?m1.0 = nn \\<and> (\\<forall>a\\<in>set ?m1.0. vec nr a);\n   length ?m2.0 = nn \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   length ?m1.0 = nn \\<and> (\\<forall>a\\<in>set ?m1.0. vec nr a);\n   length ?m2.0 = nn \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (zip ?m1.0 ?m2.0).\n                       vec nr (vec_plusI pl (fst x) (snd x))\n  length m1 = Suc nn \\<and> (\\<forall>a\\<in>set m1. vec nr a)\n  length m2 = Suc nn \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  length m1 = Suc nn \\<and> (\\<forall>a\\<in>set m1. vec nr a)\n  length m2 = Suc nn \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  m2 = []", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?m1.0 = nn \\<and> (\\<forall>a\\<in>set ?m1.0. vec nr a);\n   length ?m2.0 = nn \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   length ?m1.0 = nn \\<and> (\\<forall>a\\<in>set ?m1.0. vec nr a);\n   length ?m2.0 = nn \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (zip ?m1.0 ?m2.0).\n                       vec nr (vec_plusI pl (fst x) (snd x))\n  length m1 = Suc nn \\<and> (\\<forall>a\\<in>set m1. vec nr a)\n  length m2 = Suc nn \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  length m1 = Suc nn \\<and> (\\<forall>a\\<in>set m1. vec nr a)\n  length m2 = Suc nn \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  m2 = []\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       m2 = a # list \\<Longrightarrow>\n       \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       m2 = a # list \\<Longrightarrow>\n       \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))", "case (Cons v2 mm2)"], ["proof (state)\nthis:\n  m2 = v2 # mm2\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       m2 = a # list \\<Longrightarrow>\n       \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))", "with Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?m1.0 = nn \\<and> (\\<forall>a\\<in>set ?m1.0. vec nr a);\n   length ?m2.0 = nn \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   length ?m1.0 = nn \\<and> (\\<forall>a\\<in>set ?m1.0. vec nr a);\n   length ?m2.0 = nn \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (zip ?m1.0 ?m2.0).\n                       vec nr (vec_plusI pl (fst x) (snd x))\n  length m1 = Suc nn \\<and> (\\<forall>a\\<in>set m1. vec nr a)\n  length m2 = Suc nn \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  length m1 = Suc nn \\<and> (\\<forall>a\\<in>set m1. vec nr a)\n  length m2 = Suc nn \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  m2 = v2 # mm2", "have l2: \"length mm2 = nn\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?m1.0 = nn \\<and> (\\<forall>a\\<in>set ?m1.0. vec nr a);\n   length ?m2.0 = nn \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   length ?m1.0 = nn \\<and> (\\<forall>a\\<in>set ?m1.0. vec nr a);\n   length ?m2.0 = nn \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a)\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>set (zip ?m1.0 ?m2.0).\n                       vec nr (vec_plusI pl (fst x) (snd x))\n  length m1 = Suc nn \\<and> (\\<forall>a\\<in>set m1. vec nr a)\n  length m2 = Suc nn \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  length m1 = Suc nn \\<and> (\\<forall>a\\<in>set m1. vec nr a)\n  length m2 = Suc nn \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  m2 = v2 # mm2\n\ngoal (1 subgoal):\n 1. length mm2 = nn", "by auto"], ["proof (state)\nthis:\n  length mm2 = nn\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       m2 = a # list \\<Longrightarrow>\n       \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))", "by (simp add: Cons oCons, intro conjI[OF vec_plus], (simp add: Cons oCons Suc)+, rule Suc, auto simp: Cons oCons Suc l1 l2)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (zip m1 m2). vec nr (vec_plusI pl (fst x) (snd x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vec_map[simp,intro]: \"vec nr u \\<Longrightarrow> vec nr (vec_map f u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec nr u \\<Longrightarrow> vec nr (vec_map f u)", "unfolding vec_map_def vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length u = nr \\<Longrightarrow> length (map f u) = nr", "by auto"], ["", "lemma mat_map[simp,intro]: \"mat nr nc m \\<Longrightarrow> mat nr nc (mat_map f m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat nr nc m \\<Longrightarrow> mat nr nc (mat_map f m)", "using vec_map"], ["proof (prove)\nusing this:\n  vec ?nr ?u \\<Longrightarrow> vec ?nr (vec_map ?f ?u)\n\ngoal (1 subgoal):\n 1. mat nr nc m \\<Longrightarrow> mat nr nc (mat_map f m)", "unfolding mat_map_def mat_def"], ["proof (prove)\nusing this:\n  vec ?nr ?u \\<Longrightarrow> vec ?nr (vec_map ?f ?u)\n\ngoal (1 subgoal):\n 1. length m = nc \\<and> Ball (set m) (vec nr) \\<Longrightarrow>\n    length (map (vec_map f) m) = nc \\<and>\n    Ball (set (map (vec_map f) m)) (vec nr)", "by auto"], ["", "fun vec_fold :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'b) \\<Rightarrow> 'a vec \\<Rightarrow> 'b \\<Rightarrow> 'b\"\n  where [code_unfold]: \"vec_fold f = foldr f\""], ["", "fun mat_fold :: \"('a \\<Rightarrow> 'b \\<Rightarrow> 'b) \\<Rightarrow> 'a mat \\<Rightarrow> 'b \\<Rightarrow> 'b\"\n  where [code_unfold]: \"mat_fold f = foldr (vec_fold f)\""], ["", "lemma concat_mat: \"mat nr nc m \\<Longrightarrow>\n  concat m = [ m ! i ! j. i \\<leftarrow> [0 ..< nc], j \\<leftarrow> [0 ..< nr] ]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat nr nc m \\<Longrightarrow>\n    concat m =\n    concat (map (\\<lambda>i. map ((!) (m ! i)) [0..<nr]) [0..<nc])", "proof (induct m arbitrary: nc)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       concat [] =\n       concat (map (\\<lambda>i. map ((!) ([] ! i)) [0..<nr]) [0..<nc])\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   concat m =\n                   concat\n                    (map (\\<lambda>i. map ((!) (m ! i)) [0..<nr]) [0..<nc]);\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> concat (a # m) =\n                         concat\n                          (map (\\<lambda>i.\n                                   map ((!) ((a # m) ! i)) [0..<nr])\n                            [0..<nc])", "case Nil"], ["proof (state)\nthis:\n  mat nr nc []\n\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       concat [] =\n       concat (map (\\<lambda>i. map ((!) ([] ! i)) [0..<nr]) [0..<nc])\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   concat m =\n                   concat\n                    (map (\\<lambda>i. map ((!) (m ! i)) [0..<nr]) [0..<nc]);\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> concat (a # m) =\n                         concat\n                          (map (\\<lambda>i.\n                                   map ((!) ((a # m) ! i)) [0..<nr])\n                            [0..<nc])", "thus ?case"], ["proof (prove)\nusing this:\n  mat nr nc []\n\ngoal (1 subgoal):\n 1. concat [] =\n    concat (map (\\<lambda>i. map ((!) ([] ! i)) [0..<nr]) [0..<nc])", "unfolding mat_def"], ["proof (prove)\nusing this:\n  length [] = nc \\<and> Ball (set []) (vec nr)\n\ngoal (1 subgoal):\n 1. concat [] =\n    concat (map (\\<lambda>i. map ((!) ([] ! i)) [0..<nr]) [0..<nc])", "by auto"], ["proof (state)\nthis:\n  concat [] =\n  concat (map (\\<lambda>i. map ((!) ([] ! i)) [0..<nr]) [0..<nc])\n\ngoal (1 subgoal):\n 1. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   concat m =\n                   concat\n                    (map (\\<lambda>i. map ((!) (m ! i)) [0..<nr]) [0..<nc]);\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> concat (a # m) =\n                         concat\n                          (map (\\<lambda>i.\n                                   map ((!) ((a # m) ! i)) [0..<nr])\n                            [0..<nc])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   concat m =\n                   concat\n                    (map (\\<lambda>i. map ((!) (m ! i)) [0..<nr]) [0..<nc]);\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> concat (a # m) =\n                         concat\n                          (map (\\<lambda>i.\n                                   map ((!) ((a # m) ! i)) [0..<nr])\n                            [0..<nc])", "case (Cons v m snc)"], ["proof (state)\nthis:\n  mat nr ?nc m \\<Longrightarrow>\n  concat m = concat (map (\\<lambda>i. map ((!) (m ! i)) [0..<nr]) [0..<?nc])\n  mat nr snc (v # m)\n\ngoal (1 subgoal):\n 1. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   concat m =\n                   concat\n                    (map (\\<lambda>i. map ((!) (m ! i)) [0..<nr]) [0..<nc]);\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> concat (a # m) =\n                         concat\n                          (map (\\<lambda>i.\n                                   map ((!) ((a # m) ! i)) [0..<nr])\n                            [0..<nc])", "from Cons(2)"], ["proof (chain)\npicking this:\n  mat nr snc (v # m)", "obtain nc where snc: \"snc = Suc nc\" and mat: \"mat nr nc m\" and v: \"vec nr v\""], ["proof (prove)\nusing this:\n  mat nr snc (v # m)\n\ngoal (1 subgoal):\n 1. (\\<And>nc.\n        \\<lbrakk>snc = Suc nc; mat nr nc m; vec nr v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding mat_def"], ["proof (prove)\nusing this:\n  length (v # m) = snc \\<and> Ball (set (v # m)) (vec nr)\n\ngoal (1 subgoal):\n 1. (\\<And>nc.\n        \\<lbrakk>snc = Suc nc; length m = nc \\<and> Ball (set m) (vec nr);\n         vec nr v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases snc, auto)"], ["proof (state)\nthis:\n  snc = Suc nc\n  mat nr nc m\n  vec nr v\n\ngoal (1 subgoal):\n 1. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   concat m =\n                   concat\n                    (map (\\<lambda>i. map ((!) (m ! i)) [0..<nr]) [0..<nc]);\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> concat (a # m) =\n                         concat\n                          (map (\\<lambda>i.\n                                   map ((!) ((a # m) ! i)) [0..<nr])\n                            [0..<nc])", "from v"], ["proof (chain)\npicking this:\n  vec nr v", "have nr: \"nr = length v\""], ["proof (prove)\nusing this:\n  vec nr v\n\ngoal (1 subgoal):\n 1. nr = length v", "unfolding vec_def"], ["proof (prove)\nusing this:\n  length v = nr\n\ngoal (1 subgoal):\n 1. nr = length v", "by auto"], ["proof (state)\nthis:\n  nr = length v\n\ngoal (1 subgoal):\n 1. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   concat m =\n                   concat\n                    (map (\\<lambda>i. map ((!) (m ! i)) [0..<nr]) [0..<nc]);\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> concat (a # m) =\n                         concat\n                          (map (\\<lambda>i.\n                                   map ((!) ((a # m) ! i)) [0..<nr])\n                            [0..<nc])", "have v: \"map (\\<lambda> i. v ! i) [0 ..< nr] = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) v) [0..<nr] = v", "unfolding nr map_nth"], ["proof (prove)\ngoal (1 subgoal):\n 1. v = v", "by simp"], ["proof (state)\nthis:\n  map ((!) v) [0..<nr] = v\n\ngoal (1 subgoal):\n 1. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   concat m =\n                   concat\n                    (map (\\<lambda>i. map ((!) (m ! i)) [0..<nr]) [0..<nc]);\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> concat (a # m) =\n                         concat\n                          (map (\\<lambda>i.\n                                   map ((!) ((a # m) ! i)) [0..<nr])\n                            [0..<nc])", "note IH = Cons(1)[OF mat]"], ["proof (state)\nthis:\n  concat m = concat (map (\\<lambda>i. map ((!) (m ! i)) [0..<nr]) [0..<nc])\n\ngoal (1 subgoal):\n 1. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   concat m =\n                   concat\n                    (map (\\<lambda>i. map ((!) (m ! i)) [0..<nr]) [0..<nc]);\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> concat (a # m) =\n                         concat\n                          (map (\\<lambda>i.\n                                   map ((!) ((a # m) ! i)) [0..<nr])\n                            [0..<nc])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (v # m) =\n    concat (map (\\<lambda>i. map ((!) ((v # m) ! i)) [0..<nr]) [0..<snc])", "unfolding snc"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (v # m) =\n    concat (map (\\<lambda>i. map ((!) ((v # m) ! i)) [0..<nr]) [0..<Suc nc])", "unfolding map_upt_Suc"], ["proof (prove)\ngoal (1 subgoal):\n 1. concat (v # m) =\n    concat\n     (map ((!) ((v # m) ! 0)) [0..<nr] #\n      map (\\<lambda>i. map ((!) ((v # m) ! Suc i)) [0..<nr]) [0..<nc])", "unfolding nth.simps nat.simps concat.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. v @ concat m =\n    map ((!) v) [0..<nr] @\n    concat (map (\\<lambda>i. map ((!) (m ! i)) [0..<nr]) [0..<nc])", "unfolding IH v"], ["proof (prove)\ngoal (1 subgoal):\n 1. v @ concat (map (\\<lambda>i. map ((!) (m ! i)) [0..<nr]) [0..<nc]) =\n    v @ concat (map (\\<lambda>i. map ((!) (m ! i)) [0..<nr]) [0..<nc])", ".."], ["proof (state)\nthis:\n  concat (v # m) =\n  concat (map (\\<lambda>i. map ((!) ((v # m) ! i)) [0..<nr]) [0..<snc])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma row: assumes \"mat nr nc m\"\n  and \"i < nr\"\n  shows \"vec nc (row m i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec nc (row m i)", "using assms"], ["proof (prove)\nusing this:\n  mat nr nc m\n  i < nr\n\ngoal (1 subgoal):\n 1. vec nc (row m i)", "unfolding vec_def row_def mat_def"], ["proof (prove)\nusing this:\n  length m = nc \\<and> (\\<forall>x\\<in>set m. length x = nr)\n  i < nr\n\ngoal (1 subgoal):\n 1. length (map (\\<lambda>w. w ! i) m) = nc", "by (auto simp: vec_def)"], ["", "lemma col: assumes \"mat nr nc m\"\n  and \"i < nc\"\n  shows \"vec nr (col m i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec nr (col m i)", "using assms"], ["proof (prove)\nusing this:\n  mat nr nc m\n  i < nc\n\ngoal (1 subgoal):\n 1. vec nr (col m i)", "unfolding vec_def col_def mat_def"], ["proof (prove)\nusing this:\n  length m = nc \\<and> (\\<forall>x\\<in>set m. length x = nr)\n  i < nc\n\ngoal (1 subgoal):\n 1. length (m ! i) = nr", "by (auto simp: vec_def)"], ["", "lemma transpose[simp,intro]: assumes \"mat nr nc m\"\n  shows \"mat nc nr (transpose nr m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat nc nr (Matrix_Legacy.transpose nr m)", "using assms"], ["proof (prove)\nusing this:\n  mat nr nc m\n\ngoal (1 subgoal):\n 1. mat nc nr (Matrix_Legacy.transpose nr m)", "proof (induct m arbitrary: nc)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       mat nc nr (Matrix_Legacy.transpose nr [])\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   mat nc nr (Matrix_Legacy.transpose nr m);\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> mat nc nr (Matrix_Legacy.transpose nr (a # m))", "case (Cons v m)"], ["proof (state)\nthis:\n  mat nr ?nc m \\<Longrightarrow> mat ?nc nr (Matrix_Legacy.transpose nr m)\n  mat nr nc (v # m)\n\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       mat nc nr (Matrix_Legacy.transpose nr [])\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   mat nc nr (Matrix_Legacy.transpose nr m);\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> mat nc nr (Matrix_Legacy.transpose nr (a # m))", "from \\<open>mat nr nc (v # m)\\<close>"], ["proof (chain)\npicking this:\n  mat nr nc (v # m)", "obtain ncc where nc: \"nc = Suc ncc\""], ["proof (prove)\nusing this:\n  mat nr nc (v # m)\n\ngoal (1 subgoal):\n 1. (\\<And>ncc. nc = Suc ncc \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases nc, auto simp: mat_def)"], ["proof (state)\nthis:\n  nc = Suc ncc\n\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       mat nc nr (Matrix_Legacy.transpose nr [])\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   mat nc nr (Matrix_Legacy.transpose nr m);\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> mat nc nr (Matrix_Legacy.transpose nr (a # m))", "with Cons"], ["proof (chain)\npicking this:\n  mat nr ?nc m \\<Longrightarrow> mat ?nc nr (Matrix_Legacy.transpose nr m)\n  mat nr nc (v # m)\n  nc = Suc ncc", "have wfRec: \"mat ncc nr (transpose nr m)\""], ["proof (prove)\nusing this:\n  mat nr ?nc m \\<Longrightarrow> mat ?nc nr (Matrix_Legacy.transpose nr m)\n  mat nr nc (v # m)\n  nc = Suc ncc\n\ngoal (1 subgoal):\n 1. mat ncc nr (Matrix_Legacy.transpose nr m)", "unfolding mat_def"], ["proof (prove)\nusing this:\n  length m = ?nc \\<and> Ball (set m) (vec nr) \\<Longrightarrow>\n  length (Matrix_Legacy.transpose nr m) = nr \\<and>\n  Ball (set (Matrix_Legacy.transpose nr m)) (vec ?nc)\n  length (v # m) = nc \\<and> Ball (set (v # m)) (vec nr)\n  nc = Suc ncc\n\ngoal (1 subgoal):\n 1. length (Matrix_Legacy.transpose nr m) = nr \\<and>\n    Ball (set (Matrix_Legacy.transpose nr m)) (vec ncc)", "by auto"], ["proof (state)\nthis:\n  mat ncc nr (Matrix_Legacy.transpose nr m)\n\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       mat nc nr (Matrix_Legacy.transpose nr [])\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   mat nc nr (Matrix_Legacy.transpose nr m);\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> mat nc nr (Matrix_Legacy.transpose nr (a # m))", "have \"min nr (length (transpose nr m)) = nr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min nr (length (Matrix_Legacy.transpose nr m)) = nr", "using wfRec"], ["proof (prove)\nusing this:\n  mat ncc nr (Matrix_Legacy.transpose nr m)\n\ngoal (1 subgoal):\n 1. min nr (length (Matrix_Legacy.transpose nr m)) = nr", "unfolding mat_def"], ["proof (prove)\nusing this:\n  length (Matrix_Legacy.transpose nr m) = nr \\<and>\n  Ball (set (Matrix_Legacy.transpose nr m)) (vec ncc)\n\ngoal (1 subgoal):\n 1. min nr (length (Matrix_Legacy.transpose nr m)) = nr", "by auto"], ["proof (state)\nthis:\n  min nr (length (Matrix_Legacy.transpose nr m)) = nr\n\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       mat nc nr (Matrix_Legacy.transpose nr [])\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   mat nc nr (Matrix_Legacy.transpose nr m);\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> mat nc nr (Matrix_Legacy.transpose nr (a # m))", "moreover"], ["proof (state)\nthis:\n  min nr (length (Matrix_Legacy.transpose nr m)) = nr\n\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       mat nc nr (Matrix_Legacy.transpose nr [])\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   mat nc nr (Matrix_Legacy.transpose nr m);\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> mat nc nr (Matrix_Legacy.transpose nr (a # m))", "have \"Ball (set (transpose nr (v # m))) (vec nc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (set (Matrix_Legacy.transpose nr (v # m))) (vec nc)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Ball (set (Matrix_Legacy.transpose nr (v # m))) (vec nc)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. Ball (set (Matrix_Legacy.transpose nr (v # m))) (vec nc)", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. Ball (set (Matrix_Legacy.transpose nr (v # m))) (vec nc)", "assume mem: \"(a,b) \\<in> set (zip v (transpose nr m))\""], ["proof (state)\nthis:\n  (a, b) \\<in> set (zip v (Matrix_Legacy.transpose nr m))\n\ngoal (1 subgoal):\n 1. Ball (set (Matrix_Legacy.transpose nr (v # m))) (vec nc)", "from mem"], ["proof (chain)\npicking this:\n  (a, b) \\<in> set (zip v (Matrix_Legacy.transpose nr m))", "have \"b \\<in> set (transpose nr m)\""], ["proof (prove)\nusing this:\n  (a, b) \\<in> set (zip v (Matrix_Legacy.transpose nr m))\n\ngoal (1 subgoal):\n 1. b \\<in> set (Matrix_Legacy.transpose nr m)", "by (rule set_zip_rightD)"], ["proof (state)\nthis:\n  b \\<in> set (Matrix_Legacy.transpose nr m)\n\ngoal (1 subgoal):\n 1. Ball (set (Matrix_Legacy.transpose nr (v # m))) (vec nc)", "with wfRec"], ["proof (chain)\npicking this:\n  mat ncc nr (Matrix_Legacy.transpose nr m)\n  b \\<in> set (Matrix_Legacy.transpose nr m)", "have \"length b = ncc\""], ["proof (prove)\nusing this:\n  mat ncc nr (Matrix_Legacy.transpose nr m)\n  b \\<in> set (Matrix_Legacy.transpose nr m)\n\ngoal (1 subgoal):\n 1. length b = ncc", "unfolding mat_def"], ["proof (prove)\nusing this:\n  length (Matrix_Legacy.transpose nr m) = nr \\<and>\n  Ball (set (Matrix_Legacy.transpose nr m)) (vec ncc)\n  b \\<in> set (Matrix_Legacy.transpose nr m)\n\ngoal (1 subgoal):\n 1. length b = ncc", "using vec_def[of ncc]"], ["proof (prove)\nusing this:\n  length (Matrix_Legacy.transpose nr m) = nr \\<and>\n  Ball (set (Matrix_Legacy.transpose nr m)) (vec ncc)\n  b \\<in> set (Matrix_Legacy.transpose nr m)\n  vec ncc ?x = (length ?x = ncc)\n\ngoal (1 subgoal):\n 1. length b = ncc", "by auto"], ["proof (state)\nthis:\n  length b = ncc\n\ngoal (1 subgoal):\n 1. Ball (set (Matrix_Legacy.transpose nr (v # m))) (vec nc)", "hence \"length (case_prod (#) (a,b)) = Suc ncc\""], ["proof (prove)\nusing this:\n  length b = ncc\n\ngoal (1 subgoal):\n 1. length (case (a, b) of (x, xa) \\<Rightarrow> x # xa) = Suc ncc", "by auto"], ["proof (state)\nthis:\n  length (case (a, b) of (x, xa) \\<Rightarrow> x # xa) = Suc ncc\n\ngoal (1 subgoal):\n 1. Ball (set (Matrix_Legacy.transpose nr (v # m))) (vec nc)", "}"], ["proof (state)\nthis:\n  (?a2, ?b2)\n  \\<in> set (zip v (Matrix_Legacy.transpose nr m)) \\<Longrightarrow>\n  length (case (?a2, ?b2) of (x, xa) \\<Rightarrow> x # xa) = Suc ncc\n\ngoal (1 subgoal):\n 1. Ball (set (Matrix_Legacy.transpose nr (v # m))) (vec nc)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?a2, ?b2)\n  \\<in> set (zip v (Matrix_Legacy.transpose nr m)) \\<Longrightarrow>\n  length (case (?a2, ?b2) of (x, xa) \\<Rightarrow> x # xa) = Suc ncc\n\ngoal (1 subgoal):\n 1. Ball (set (Matrix_Legacy.transpose nr (v # m))) (vec nc)", "by (auto simp: vec_def nc)"], ["proof (state)\nthis:\n  Ball (set (Matrix_Legacy.transpose nr (v # m))) (vec nc)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Ball (set (Matrix_Legacy.transpose nr (v # m))) (vec nc)\n\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       mat nc nr (Matrix_Legacy.transpose nr [])\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   mat nc nr (Matrix_Legacy.transpose nr m);\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> mat nc nr (Matrix_Legacy.transpose nr (a # m))", "moreover"], ["proof (state)\nthis:\n  Ball (set (Matrix_Legacy.transpose nr (v # m))) (vec nc)\n\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       mat nc nr (Matrix_Legacy.transpose nr [])\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   mat nc nr (Matrix_Legacy.transpose nr m);\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> mat nc nr (Matrix_Legacy.transpose nr (a # m))", "from \\<open>mat nr nc (v # m)\\<close>"], ["proof (chain)\npicking this:\n  mat nr nc (v # m)", "have wfV: \"length v = nr\""], ["proof (prove)\nusing this:\n  mat nr nc (v # m)\n\ngoal (1 subgoal):\n 1. length v = nr", "unfolding mat_def"], ["proof (prove)\nusing this:\n  length (v # m) = nc \\<and> Ball (set (v # m)) (vec nr)\n\ngoal (1 subgoal):\n 1. length v = nr", "by (simp add: vec_def)"], ["proof (state)\nthis:\n  length v = nr\n\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       mat nc nr (Matrix_Legacy.transpose nr [])\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   mat nc nr (Matrix_Legacy.transpose nr m);\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> mat nc nr (Matrix_Legacy.transpose nr (a # m))", "ultimately"], ["proof (chain)\npicking this:\n  min nr (length (Matrix_Legacy.transpose nr m)) = nr\n  Ball (set (Matrix_Legacy.transpose nr (v # m))) (vec nc)\n  length v = nr", "show ?case"], ["proof (prove)\nusing this:\n  min nr (length (Matrix_Legacy.transpose nr m)) = nr\n  Ball (set (Matrix_Legacy.transpose nr (v # m))) (vec nc)\n  length v = nr\n\ngoal (1 subgoal):\n 1. mat nc nr (Matrix_Legacy.transpose nr (v # m))", "unfolding mat_def"], ["proof (prove)\nusing this:\n  min nr (length (Matrix_Legacy.transpose nr m)) = nr\n  Ball (set (Matrix_Legacy.transpose nr (v # m))) (vec nc)\n  length v = nr\n\ngoal (1 subgoal):\n 1. length (Matrix_Legacy.transpose nr (v # m)) = nr \\<and>\n    Ball (set (Matrix_Legacy.transpose nr (v # m))) (vec nc)", "by (intro conjI, auto simp: wfV wfRec mat_def vec_def)"], ["proof (state)\nthis:\n  mat nc nr (Matrix_Legacy.transpose nr (v # m))\n\ngoal (1 subgoal):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       mat nc nr (Matrix_Legacy.transpose nr [])", "qed (simp add: mat_def vec_def set_replicate_conv_if)"], ["", "lemma matT_vec_multI: assumes \"mat nr nc m\"\n  shows \"vec nc (matT_vec_multI ze pl ti m v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec nc (matT_vec_multI ze pl ti m v)", "unfolding matT_vec_multI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec nc (map (\\<lambda>w. scalar_prodI ze pl ti w v) m)", "using assms"], ["proof (prove)\nusing this:\n  mat nr nc m\n\ngoal (1 subgoal):\n 1. vec nc (map (\\<lambda>w. scalar_prodI ze pl ti w v) m)", "unfolding mat_def"], ["proof (prove)\nusing this:\n  length m = nc \\<and> Ball (set m) (vec nr)\n\ngoal (1 subgoal):\n 1. vec nc (map (\\<lambda>w. scalar_prodI ze pl ti w v) m)", "by (simp add: vec_def)"], ["", "lemma mat_mult[simp,intro]: assumes wf1: \"mat nr n m1\"\n  and wf2: \"mat n nc m2\"\n  shows \"mat nr nc (mat_multI ze pl ti nr m1 m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat nr nc (mat_multI ze pl ti nr m1 m2)", "using assms"], ["proof (prove)\nusing this:\n  mat nr n m1\n  mat n nc m2\n\ngoal (1 subgoal):\n 1. mat nr nc (mat_multI ze pl ti nr m1 m2)", "unfolding mat_def mat_multI_def"], ["proof (prove)\nusing this:\n  length m1 = n \\<and> Ball (set m1) (vec nr)\n  length m2 = nc \\<and> Ball (set m2) (vec n)\n\ngoal (1 subgoal):\n 1. length\n     (map (matT_vec_multI ze pl ti (Matrix_Legacy.transpose nr m1)) m2) =\n    nc \\<and>\n    Ball\n     (set (map (matT_vec_multI ze pl ti (Matrix_Legacy.transpose nr m1))\n            m2))\n     (vec nr)", "by (auto simp: matT_vec_multI[OF transpose[OF wf1]])"], ["", "lemma mat_pow[simp,intro]: assumes \"mat n n m\"\n  shows \"mat n n (mat_powI ze on pl ti n m i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat n n (mat_powI ze on pl ti n m i)", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. mat n n (mat_powI ze on pl ti n m 0)\n 2. \\<And>i.\n       mat n n (mat_powI ze on pl ti n m i) \\<Longrightarrow>\n       mat n n (mat_powI ze on pl ti n m (Suc i))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. mat n n (mat_powI ze on pl ti n m 0)\n 2. \\<And>i.\n       mat n n (mat_powI ze on pl ti n m i) \\<Longrightarrow>\n       mat n n (mat_powI ze on pl ti n m (Suc i))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat n n (mat_powI ze on pl ti n m 0)", "unfolding mat_powI.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat n n (mat1I ze on n)", "by (rule mat1)"], ["proof (state)\nthis:\n  mat n n (mat_powI ze on pl ti n m 0)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       mat n n (mat_powI ze on pl ti n m i) \\<Longrightarrow>\n       mat n n (mat_powI ze on pl ti n m (Suc i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       mat n n (mat_powI ze on pl ti n m i) \\<Longrightarrow>\n       mat n n (mat_powI ze on pl ti n m (Suc i))", "case (Suc i)"], ["proof (state)\nthis:\n  mat n n (mat_powI ze on pl ti n m i)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       mat n n (mat_powI ze on pl ti n m i) \\<Longrightarrow>\n       mat n n (mat_powI ze on pl ti n m (Suc i))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat n n (mat_powI ze on pl ti n m (Suc i))", "unfolding mat_powI.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat n n (mat_multI ze pl ti n (mat_powI ze on pl ti n m i) m)", "by (rule mat_mult[OF Suc assms])"], ["proof (state)\nthis:\n  mat n n (mat_powI ze on pl ti n m (Suc i))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sub_vec[simp,intro]: assumes \"vec nr v\" and \"sd \\<le> nr\"\n  shows \"vec sd (sub_vec sd v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec sd (sub_vec sd v)", "using assms"], ["proof (prove)\nusing this:\n  vec nr v\n  sd \\<le> nr\n\ngoal (1 subgoal):\n 1. vec sd (sub_vec sd v)", "unfolding vec_def sub_vec_def"], ["proof (prove)\nusing this:\n  length v = nr\n  sd \\<le> nr\n\ngoal (1 subgoal):\n 1. length (take sd v) = sd", "by auto"], ["", "lemma sub_mat[simp,intro]: assumes wf: \"mat nr nc m\" and sr: \"sr \\<le> nr\" and sc: \"sc \\<le> nc\"\n  shows \"mat sr sc (sub_mat sr sc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat sr sc (sub_mat sr sc m)", "using assms in_set_takeD[of _ sc m] sub_vec[OF _ sr]"], ["proof (prove)\nusing this:\n  mat nr nc m\n  sr \\<le> nr\n  sc \\<le> nc\n  ?x \\<in> set (take sc m) \\<Longrightarrow> ?x \\<in> set m\n  vec nr ?v \\<Longrightarrow> vec sr (sub_vec sr ?v)\n\ngoal (1 subgoal):\n 1. mat sr sc (sub_mat sr sc m)", "unfolding mat_def sub_mat_def"], ["proof (prove)\nusing this:\n  length m = nc \\<and> Ball (set m) (vec nr)\n  sr \\<le> nr\n  sc \\<le> nc\n  ?x \\<in> set (take sc m) \\<Longrightarrow> ?x \\<in> set m\n  vec nr ?v \\<Longrightarrow> vec sr (sub_vec sr ?v)\n\ngoal (1 subgoal):\n 1. length (map (sub_vec sr) (take sc m)) = sc \\<and>\n    Ball (set (map (sub_vec sr) (take sc m))) (vec sr)", "by auto"], ["", "subsection \\<open>properties of algorithms which do not depend on properties of type of matrix\\<close>"], ["", "lemma mat0_index[simp]: assumes \"i < nc\" and \"j < nr\"\n  shows \"mat0I ze nr nc ! i ! j = ze\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat0I ze nr nc ! i ! j = ze", "unfolding mat0I_def vec0I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate nc (replicate nr ze) ! i ! j = ze", "using assms"], ["proof (prove)\nusing this:\n  i < nc\n  j < nr\n\ngoal (1 subgoal):\n 1. replicate nc (replicate nr ze) ! i ! j = ze", "by auto"], ["", "lemma mat0_row[simp]: assumes \"i < nr\"\n  shows \"row (mat0I ze nr nc) i = vec0I ze nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat0I ze nr nc) i = vec0I ze nc", "unfolding row_def mat0I_def vec0I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>w. w ! i) (replicate nc (replicate nr ze)) =\n    replicate nc ze", "using assms"], ["proof (prove)\nusing this:\n  i < nr\n\ngoal (1 subgoal):\n 1. map (\\<lambda>w. w ! i) (replicate nc (replicate nr ze)) =\n    replicate nc ze", "by auto"], ["", "lemma mat0_col[simp]: assumes \"i < nc\"\n  shows \"col (mat0I ze nr nc) i = vec0I ze nr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (mat0I ze nr nc) i = vec0I ze nr", "unfolding mat0I_def col_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. replicate nc (vec0I ze nr) ! i = vec0I ze nr", "using assms"], ["proof (prove)\nusing this:\n  i < nc\n\ngoal (1 subgoal):\n 1. replicate nc (vec0I ze nr) ! i = vec0I ze nr", "by auto"], ["", "lemma vec1_index: assumes j: \"j < n\"\n  shows \"vec1I ze on n i ! j = (if i = j then on else ze)\" (is \"_ = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec1I ze on n i ! j = (if i = j then on else ze)", "unfolding vec1I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)", "let ?l = \"replicate i ze @ on # replicate (n - 1 - i) ze\""], ["proof (state)\ngoal (1 subgoal):\n 1. (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)", "have len: \"length ?l > i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (replicate i ze @ on # replicate (n - 1 - i) ze)", "by auto"], ["proof (state)\nthis:\n  i < length (replicate i ze @ on # replicate (n - 1 - i) ze)\n\ngoal (1 subgoal):\n 1. (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)", "have len2: \"length (replicate i ze @ on # []) > i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length (replicate i ze @ [on])", "by auto"], ["proof (state)\nthis:\n  i < length (replicate i ze @ [on])\n\ngoal (1 subgoal):\n 1. (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)", "show \"?l ! j = ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)", "proof (cases \"j = i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j = i \\<Longrightarrow>\n    (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)\n 2. j \\<noteq> i \\<Longrightarrow>\n    (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)", "case True"], ["proof (state)\nthis:\n  j = i\n\ngoal (2 subgoals):\n 1. j = i \\<Longrightarrow>\n    (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)\n 2. j \\<noteq> i \\<Longrightarrow>\n    (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)", "thus ?thesis"], ["proof (prove)\nusing this:\n  j = i\n\ngoal (1 subgoal):\n 1. (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n  (if i = j then on else ze)\n\ngoal (1 subgoal):\n 1. j \\<noteq> i \\<Longrightarrow>\n    (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<noteq> i \\<Longrightarrow>\n    (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)", "case False"], ["proof (state)\nthis:\n  j \\<noteq> i\n\ngoal (1 subgoal):\n 1. j \\<noteq> i \\<Longrightarrow>\n    (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)", "proof (cases \"j < i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)\n 2. \\<not> j < i \\<Longrightarrow>\n    (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)", "case True"], ["proof (state)\nthis:\n  j < i\n\ngoal (2 subgoals):\n 1. j < i \\<Longrightarrow>\n    (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)\n 2. \\<not> j < i \\<Longrightarrow>\n    (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)", "thus ?thesis"], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n  (if i = j then on else ze)\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)", "case False"], ["proof (state)\nthis:\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)", "with \\<open>j \\<noteq> i\\<close>"], ["proof (chain)\npicking this:\n  j \\<noteq> i\n  \\<not> j < i", "have gt: \"j > i\""], ["proof (prove)\nusing this:\n  j \\<noteq> i\n  \\<not> j < i\n\ngoal (1 subgoal):\n 1. i < j", "by auto"], ["proof (state)\nthis:\n  i < j\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)", "from this"], ["proof (chain)\npicking this:\n  i < j", "have \"\\<exists> k. j = i + Suc k\""], ["proof (prove)\nusing this:\n  i < j\n\ngoal (1 subgoal):\n 1. \\<exists>k. j = i + Suc k", "by arith"], ["proof (state)\nthis:\n  \\<exists>k. j = i + Suc k\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>k. j = i + Suc k", "obtain k where k: \"j = i + Suc k\""], ["proof (prove)\nusing this:\n  \\<exists>k. j = i + Suc k\n\ngoal (1 subgoal):\n 1. (\\<And>k. j = i + Suc k \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j = i + Suc k\n\ngoal (1 subgoal):\n 1. \\<not> j < i \\<Longrightarrow>\n    (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)", "with j"], ["proof (chain)\npicking this:\n  j < n\n  j = i + Suc k", "show ?thesis"], ["proof (prove)\nusing this:\n  j < n\n  j = i + Suc k\n\ngoal (1 subgoal):\n 1. (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n    (if i = j then on else ze)", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n  (if i = j then on else ze)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n  (if i = j then on else ze)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (replicate i ze @ on # replicate (n - 1 - i) ze) ! j =\n  (if i = j then on else ze)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma col_transpose_is_row[simp]:\n  assumes wf: \"mat nr nc m\"\n  and i: \"i < nr\"\n  shows \"col (transpose nr m) i = row m i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (Matrix_Legacy.transpose nr m) i = row m i", "using wf"], ["proof (prove)\nusing this:\n  mat nr nc m\n\ngoal (1 subgoal):\n 1. col (Matrix_Legacy.transpose nr m) i = row m i", "proof (induct m arbitrary: nc)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       col (Matrix_Legacy.transpose nr []) i = row [] i\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   col (Matrix_Legacy.transpose nr m) i = row m i;\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> col (Matrix_Legacy.transpose nr (a # m)) i =\n                         row (a # m) i", "case (Cons v m)"], ["proof (state)\nthis:\n  mat nr ?nc m \\<Longrightarrow>\n  col (Matrix_Legacy.transpose nr m) i = row m i\n  mat nr nc (v # m)\n\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       col (Matrix_Legacy.transpose nr []) i = row [] i\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   col (Matrix_Legacy.transpose nr m) i = row m i;\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> col (Matrix_Legacy.transpose nr (a # m)) i =\n                         row (a # m) i", "from \\<open>mat nr nc (v # m)\\<close>"], ["proof (chain)\npicking this:\n  mat nr nc (v # m)", "obtain ncc where nc: \"nc = Suc ncc\" and wf: \"mat nr ncc m\""], ["proof (prove)\nusing this:\n  mat nr nc (v # m)\n\ngoal (1 subgoal):\n 1. (\\<And>ncc.\n        \\<lbrakk>nc = Suc ncc; mat nr ncc m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases nc, auto simp: mat_def)"], ["proof (state)\nthis:\n  nc = Suc ncc\n  mat nr ncc m\n\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       col (Matrix_Legacy.transpose nr []) i = row [] i\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   col (Matrix_Legacy.transpose nr m) i = row m i;\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> col (Matrix_Legacy.transpose nr (a # m)) i =\n                         row (a # m) i", "from \\<open>mat nr nc (v # m)\\<close> nc"], ["proof (chain)\npicking this:\n  mat nr nc (v # m)\n  nc = Suc ncc", "have lengths: \"(\\<forall> w \\<in> set m. length w = nr) \\<and> length v = nr \\<and> length m = ncc\""], ["proof (prove)\nusing this:\n  mat nr nc (v # m)\n  nc = Suc ncc\n\ngoal (1 subgoal):\n 1. (\\<forall>w\\<in>set m. length w = nr) \\<and>\n    length v = nr \\<and> length m = ncc", "unfolding mat_def"], ["proof (prove)\nusing this:\n  length (v # m) = nc \\<and> Ball (set (v # m)) (vec nr)\n  nc = Suc ncc\n\ngoal (1 subgoal):\n 1. (\\<forall>w\\<in>set m. length w = nr) \\<and>\n    length v = nr \\<and> length m = ncc", "by (auto simp: vec_def)"], ["proof (state)\nthis:\n  (\\<forall>w\\<in>set m. length w = nr) \\<and>\n  length v = nr \\<and> length m = ncc\n\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       col (Matrix_Legacy.transpose nr []) i = row [] i\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   col (Matrix_Legacy.transpose nr m) i = row m i;\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> col (Matrix_Legacy.transpose nr (a # m)) i =\n                         row (a # m) i", "from wf Cons"], ["proof (chain)\npicking this:\n  mat nr ncc m\n  mat nr ?nc m \\<Longrightarrow>\n  col (Matrix_Legacy.transpose nr m) i = row m i\n  mat nr nc (v # m)", "have colRec: \"col (transpose nr m) i = row m i\""], ["proof (prove)\nusing this:\n  mat nr ncc m\n  mat nr ?nc m \\<Longrightarrow>\n  col (Matrix_Legacy.transpose nr m) i = row m i\n  mat nr nc (v # m)\n\ngoal (1 subgoal):\n 1. col (Matrix_Legacy.transpose nr m) i = row m i", "by auto"], ["proof (state)\nthis:\n  col (Matrix_Legacy.transpose nr m) i = row m i\n\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       col (Matrix_Legacy.transpose nr []) i = row [] i\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   col (Matrix_Legacy.transpose nr m) i = row m i;\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> col (Matrix_Legacy.transpose nr (a # m)) i =\n                         row (a # m) i", "hence simpme: \"transpose nr m ! i = row m i\""], ["proof (prove)\nusing this:\n  col (Matrix_Legacy.transpose nr m) i = row m i\n\ngoal (1 subgoal):\n 1. Matrix_Legacy.transpose nr m ! i = row m i", "unfolding col_def"], ["proof (prove)\nusing this:\n  Matrix_Legacy.transpose nr m ! i = row m i\n\ngoal (1 subgoal):\n 1. Matrix_Legacy.transpose nr m ! i = row m i", "by auto"], ["proof (state)\nthis:\n  Matrix_Legacy.transpose nr m ! i = row m i\n\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       col (Matrix_Legacy.transpose nr []) i = row [] i\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   col (Matrix_Legacy.transpose nr m) i = row m i;\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> col (Matrix_Legacy.transpose nr (a # m)) i =\n                         row (a # m) i", "from wf"], ["proof (chain)\npicking this:\n  mat nr ncc m", "have trans: \"mat ncc nr (transpose nr m)\""], ["proof (prove)\nusing this:\n  mat nr ncc m\n\ngoal (1 subgoal):\n 1. mat ncc nr (Matrix_Legacy.transpose nr m)", "by (rule transpose)"], ["proof (state)\nthis:\n  mat ncc nr (Matrix_Legacy.transpose nr m)\n\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       col (Matrix_Legacy.transpose nr []) i = row [] i\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   col (Matrix_Legacy.transpose nr m) i = row m i;\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> col (Matrix_Legacy.transpose nr (a # m)) i =\n                         row (a # m) i", "hence lengths2: \"(\\<forall> w \\<in> set (transpose nr m). length w = ncc) \\<and> length (transpose nr m) = nr\""], ["proof (prove)\nusing this:\n  mat ncc nr (Matrix_Legacy.transpose nr m)\n\ngoal (1 subgoal):\n 1. (\\<forall>w\\<in>set (Matrix_Legacy.transpose nr m).\n        length w = ncc) \\<and>\n    length (Matrix_Legacy.transpose nr m) = nr", "unfolding mat_def"], ["proof (prove)\nusing this:\n  length (Matrix_Legacy.transpose nr m) = nr \\<and>\n  Ball (set (Matrix_Legacy.transpose nr m)) (vec ncc)\n\ngoal (1 subgoal):\n 1. (\\<forall>w\\<in>set (Matrix_Legacy.transpose nr m).\n        length w = ncc) \\<and>\n    length (Matrix_Legacy.transpose nr m) = nr", "by (auto simp: vec_def)"], ["proof (state)\nthis:\n  (\\<forall>w\\<in>set (Matrix_Legacy.transpose nr m). length w = ncc) \\<and>\n  length (Matrix_Legacy.transpose nr m) = nr\n\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       col (Matrix_Legacy.transpose nr []) i = row [] i\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   col (Matrix_Legacy.transpose nr m) i = row m i;\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> col (Matrix_Legacy.transpose nr (a # m)) i =\n                         row (a # m) i", "{"], ["proof (state)\nthis:\n  (\\<forall>w\\<in>set (Matrix_Legacy.transpose nr m). length w = ncc) \\<and>\n  length (Matrix_Legacy.transpose nr m) = nr\n\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       col (Matrix_Legacy.transpose nr []) i = row [] i\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   col (Matrix_Legacy.transpose nr m) i = row m i;\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> col (Matrix_Legacy.transpose nr (a # m)) i =\n                         row (a # m) i", "fix j"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       col (Matrix_Legacy.transpose nr []) i = row [] i\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   col (Matrix_Legacy.transpose nr m) i = row m i;\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> col (Matrix_Legacy.transpose nr (a # m)) i =\n                         row (a # m) i", "assume \"j < length (col (transpose nr (v # m)) i)\""], ["proof (state)\nthis:\n  j < length (col (Matrix_Legacy.transpose nr (v # m)) i)\n\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       col (Matrix_Legacy.transpose nr []) i = row [] i\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   col (Matrix_Legacy.transpose nr m) i = row m i;\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> col (Matrix_Legacy.transpose nr (a # m)) i =\n                         row (a # m) i", "hence \"j < Suc ncc\""], ["proof (prove)\nusing this:\n  j < length (col (Matrix_Legacy.transpose nr (v # m)) i)\n\ngoal (1 subgoal):\n 1. j < Suc ncc", "by (simp add: col_def lengths2 lengths i)"], ["proof (state)\nthis:\n  j < Suc ncc\n\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       col (Matrix_Legacy.transpose nr []) i = row [] i\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   col (Matrix_Legacy.transpose nr m) i = row m i;\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> col (Matrix_Legacy.transpose nr (a # m)) i =\n                         row (a # m) i", "hence \"col (transpose nr (v # m)) i ! j = row (v # m) i ! j\""], ["proof (prove)\nusing this:\n  j < Suc ncc\n\ngoal (1 subgoal):\n 1. col (Matrix_Legacy.transpose nr (v # m)) i ! j = row (v # m) i ! j", "by (cases j, simp add: row_def col_def i lengths lengths2, simp add: row_def col_def i lengths lengths2 simpme)"], ["proof (state)\nthis:\n  col (Matrix_Legacy.transpose nr (v # m)) i ! j = row (v # m) i ! j\n\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       col (Matrix_Legacy.transpose nr []) i = row [] i\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   col (Matrix_Legacy.transpose nr m) i = row m i;\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> col (Matrix_Legacy.transpose nr (a # m)) i =\n                         row (a # m) i", "}"], ["proof (state)\nthis:\n  ?j2\n  < length (col (Matrix_Legacy.transpose nr (v # m)) i) \\<Longrightarrow>\n  col (Matrix_Legacy.transpose nr (v # m)) i ! ?j2 = row (v # m) i ! ?j2\n\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       col (Matrix_Legacy.transpose nr []) i = row [] i\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   col (Matrix_Legacy.transpose nr m) i = row m i;\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> col (Matrix_Legacy.transpose nr (a # m)) i =\n                         row (a # m) i", "note simpme = this"], ["proof (state)\nthis:\n  ?j2\n  < length (col (Matrix_Legacy.transpose nr (v # m)) i) \\<Longrightarrow>\n  col (Matrix_Legacy.transpose nr (v # m)) i ! ?j2 = row (v # m) i ! ?j2\n\ngoal (2 subgoals):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       col (Matrix_Legacy.transpose nr []) i = row [] i\n 2. \\<And>a m nc.\n       \\<lbrakk>\\<And>nc.\n                   mat nr nc m \\<Longrightarrow>\n                   col (Matrix_Legacy.transpose nr m) i = row m i;\n        mat nr nc (a # m)\\<rbrakk>\n       \\<Longrightarrow> col (Matrix_Legacy.transpose nr (a # m)) i =\n                         row (a # m) i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (Matrix_Legacy.transpose nr (v # m)) i = row (v # m) i", "by (rule nth_equalityI, simp add: col_def row_def lengths lengths2 i, rule simpme)"], ["proof (state)\nthis:\n  col (Matrix_Legacy.transpose nr (v # m)) i = row (v # m) i\n\ngoal (1 subgoal):\n 1. \\<And>nc.\n       mat nr nc [] \\<Longrightarrow>\n       col (Matrix_Legacy.transpose nr []) i = row [] i", "qed (simp add: col_def row_def mat_def i)"], ["", "lemma mat_col_eq:\n  assumes wf1: \"mat nr nc m1\"\n  and wf2: \"mat nr nc m2\"\n  shows \"(m1 = m2) = (\\<forall> i < nc. col m1 i = col m2 i)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (m1 = m2) = (\\<forall>i<nc. col m1 i = col m2 i)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. m1 = m2 \\<Longrightarrow> \\<forall>i<nc. col m1 i = col m2 i\n 2. \\<forall>i<nc. col m1 i = col m2 i \\<Longrightarrow> m1 = m2", "assume ?l"], ["proof (state)\nthis:\n  m1 = m2\n\ngoal (2 subgoals):\n 1. m1 = m2 \\<Longrightarrow> \\<forall>i<nc. col m1 i = col m2 i\n 2. \\<forall>i<nc. col m1 i = col m2 i \\<Longrightarrow> m1 = m2", "thus ?r"], ["proof (prove)\nusing this:\n  m1 = m2\n\ngoal (1 subgoal):\n 1. \\<forall>i<nc. col m1 i = col m2 i", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<nc. col m1 i = col m2 i\n\ngoal (1 subgoal):\n 1. \\<forall>i<nc. col m1 i = col m2 i \\<Longrightarrow> m1 = m2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i<nc. col m1 i = col m2 i \\<Longrightarrow> m1 = m2", "assume ?r"], ["proof (state)\nthis:\n  \\<forall>i<nc. col m1 i = col m2 i\n\ngoal (1 subgoal):\n 1. \\<forall>i<nc. col m1 i = col m2 i \\<Longrightarrow> m1 = m2", "show ?l"], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 = m2", "proof (rule nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length m1 = length m2\n 2. \\<And>i. i < length m1 \\<Longrightarrow> m1 ! i = m2 ! i", "show \"length m1 = length m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length m1 = length m2", "using wf1 wf2"], ["proof (prove)\nusing this:\n  mat nr nc m1\n  mat nr nc m2\n\ngoal (1 subgoal):\n 1. length m1 = length m2", "unfolding mat_def"], ["proof (prove)\nusing this:\n  length m1 = nc \\<and> Ball (set m1) (vec nr)\n  length m2 = nc \\<and> Ball (set m2) (vec nr)\n\ngoal (1 subgoal):\n 1. length m1 = length m2", "by auto"], ["proof (state)\nthis:\n  length m1 = length m2\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length m1 \\<Longrightarrow> m1 ! i = m2 ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length m1 \\<Longrightarrow> m1 ! i = m2 ! i", "from \\<open>?r\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>i<nc. col m1 i = col m2 i", "show \"\\<And>i. i < length m1 \\<Longrightarrow> m1 ! i = m2 ! i\""], ["proof (prove)\nusing this:\n  \\<forall>i<nc. col m1 i = col m2 i\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length m1 \\<Longrightarrow> m1 ! i = m2 ! i", "using wf1"], ["proof (prove)\nusing this:\n  \\<forall>i<nc. col m1 i = col m2 i\n  mat nr nc m1\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length m1 \\<Longrightarrow> m1 ! i = m2 ! i", "unfolding col_def mat_def"], ["proof (prove)\nusing this:\n  \\<forall>i<nc. m1 ! i = m2 ! i\n  length m1 = nc \\<and> Ball (set m1) (vec nr)\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length m1 \\<Longrightarrow> m1 ! i = m2 ! i", "by auto"], ["proof (state)\nthis:\n  ?i < length m1 \\<Longrightarrow> m1 ! ?i = m2 ! ?i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m1 = m2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_col_eqI:\n  assumes wf1: \"mat nr nc m1\"\n  and wf2: \"mat nr nc m2\"\n  and id: \"\\<And> i. i < nc \\<Longrightarrow> col m1 i = col m2 i\"\n  shows \"m1 = m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 = m2", "unfolding mat_col_eq[OF wf1 wf2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<nc. col m1 i = col m2 i", "using id"], ["proof (prove)\nusing this:\n  ?i < nc \\<Longrightarrow> col m1 ?i = col m2 ?i\n\ngoal (1 subgoal):\n 1. \\<forall>i<nc. col m1 i = col m2 i", "by auto"], ["", "lemma mat_eq:\n  assumes wf1: \"mat nr nc m1\"\n  and wf2: \"mat nr nc m2\"\n  shows \"(m1 = m2) = (\\<forall> i < nc. \\<forall> j < nr. m1 ! i ! j = m2 ! i ! j)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (m1 = m2) = (\\<forall>i<nc. \\<forall>j<nr. m1 ! i ! j = m2 ! i ! j)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. m1 = m2 \\<Longrightarrow>\n    \\<forall>i<nc. \\<forall>j<nr. m1 ! i ! j = m2 ! i ! j\n 2. \\<forall>i<nc. \\<forall>j<nr. m1 ! i ! j = m2 ! i ! j \\<Longrightarrow>\n    m1 = m2", "assume ?l"], ["proof (state)\nthis:\n  m1 = m2\n\ngoal (2 subgoals):\n 1. m1 = m2 \\<Longrightarrow>\n    \\<forall>i<nc. \\<forall>j<nr. m1 ! i ! j = m2 ! i ! j\n 2. \\<forall>i<nc. \\<forall>j<nr. m1 ! i ! j = m2 ! i ! j \\<Longrightarrow>\n    m1 = m2", "thus ?r"], ["proof (prove)\nusing this:\n  m1 = m2\n\ngoal (1 subgoal):\n 1. \\<forall>i<nc. \\<forall>j<nr. m1 ! i ! j = m2 ! i ! j", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<nc. \\<forall>j<nr. m1 ! i ! j = m2 ! i ! j\n\ngoal (1 subgoal):\n 1. \\<forall>i<nc. \\<forall>j<nr. m1 ! i ! j = m2 ! i ! j \\<Longrightarrow>\n    m1 = m2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i<nc. \\<forall>j<nr. m1 ! i ! j = m2 ! i ! j \\<Longrightarrow>\n    m1 = m2", "assume ?r"], ["proof (state)\nthis:\n  \\<forall>i<nc. \\<forall>j<nr. m1 ! i ! j = m2 ! i ! j\n\ngoal (1 subgoal):\n 1. \\<forall>i<nc. \\<forall>j<nr. m1 ! i ! j = m2 ! i ! j \\<Longrightarrow>\n    m1 = m2", "show ?l"], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 = m2", "proof (rule mat_col_eqI[OF wf1 wf2], unfold col_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < nc \\<Longrightarrow> m1 ! i = m2 ! i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < nc \\<Longrightarrow> m1 ! i = m2 ! i", "assume i: \"i < nc\""], ["proof (state)\nthis:\n  i < nc\n\ngoal (1 subgoal):\n 1. \\<And>i. i < nc \\<Longrightarrow> m1 ! i = m2 ! i", "show \"m1 ! i = m2 ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 ! i = m2 ! i", "proof (rule nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (m1 ! i) = length (m2 ! i)\n 2. \\<And>ia.\n       ia < length (m1 ! i) \\<Longrightarrow> m1 ! i ! ia = m2 ! i ! ia", "show \"length (m1 ! i)  = length (m2 ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (m1 ! i) = length (m2 ! i)", "using wf1 wf2 i"], ["proof (prove)\nusing this:\n  mat nr nc m1\n  mat nr nc m2\n  i < nc\n\ngoal (1 subgoal):\n 1. length (m1 ! i) = length (m2 ! i)", "unfolding mat_def"], ["proof (prove)\nusing this:\n  length m1 = nc \\<and> Ball (set m1) (vec nr)\n  length m2 = nc \\<and> Ball (set m2) (vec nr)\n  i < nc\n\ngoal (1 subgoal):\n 1. length (m1 ! i) = length (m2 ! i)", "by (auto simp: vec_def)"], ["proof (state)\nthis:\n  length (m1 ! i) = length (m2 ! i)\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < length (m1 ! i) \\<Longrightarrow> m1 ! i ! ia = m2 ! i ! ia", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < length (m1 ! i) \\<Longrightarrow> m1 ! i ! ia = m2 ! i ! ia", "from \\<open>?r\\<close> i"], ["proof (chain)\npicking this:\n  \\<forall>i<nc. \\<forall>j<nr. m1 ! i ! j = m2 ! i ! j\n  i < nc", "show \"\\<And>j. j < length (m1 ! i) \\<Longrightarrow> m1 ! i ! j = m2 ! i ! j\""], ["proof (prove)\nusing this:\n  \\<forall>i<nc. \\<forall>j<nr. m1 ! i ! j = m2 ! i ! j\n  i < nc\n\ngoal (1 subgoal):\n 1. \\<And>j. j < length (m1 ! i) \\<Longrightarrow> m1 ! i ! j = m2 ! i ! j", "using wf1 wf2"], ["proof (prove)\nusing this:\n  \\<forall>i<nc. \\<forall>j<nr. m1 ! i ! j = m2 ! i ! j\n  i < nc\n  mat nr nc m1\n  mat nr nc m2\n\ngoal (1 subgoal):\n 1. \\<And>j. j < length (m1 ! i) \\<Longrightarrow> m1 ! i ! j = m2 ! i ! j", "unfolding mat_def"], ["proof (prove)\nusing this:\n  \\<forall>i<nc. \\<forall>j<nr. m1 ! i ! j = m2 ! i ! j\n  i < nc\n  length m1 = nc \\<and> Ball (set m1) (vec nr)\n  length m2 = nc \\<and> Ball (set m2) (vec nr)\n\ngoal (1 subgoal):\n 1. \\<And>j. j < length (m1 ! i) \\<Longrightarrow> m1 ! i ! j = m2 ! i ! j", "by (auto simp: vec_def)"], ["proof (state)\nthis:\n  ?j < length (m1 ! i) \\<Longrightarrow> m1 ! i ! ?j = m2 ! i ! ?j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m1 ! i = m2 ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m1 = m2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_eqI:\n  assumes wf1: \"mat nr nc m1\"\n  and wf2: \"mat nr nc m2\"\n  and id: \"\\<And> i j. i < nc \\<Longrightarrow> j < nr \\<Longrightarrow> m1 ! i ! j = m2 ! i ! j\"\n  shows \"m1 = m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 = m2", "unfolding mat_eq[OF wf1 wf2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<nc. \\<forall>j<nr. m1 ! i ! j = m2 ! i ! j", "using id"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i < nc; ?j < nr\\<rbrakk>\n  \\<Longrightarrow> m1 ! ?i ! ?j = m2 ! ?i ! ?j\n\ngoal (1 subgoal):\n 1. \\<forall>i<nc. \\<forall>j<nr. m1 ! i ! j = m2 ! i ! j", "by auto"], ["", "lemma vec_eq:\n  assumes wf1: \"vec n v1\"\n  and wf2: \"vec n v2\"\n  shows \"(v1 = v2) = (\\<forall> i < n. v1 ! i = v2 ! i)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (v1 = v2) = (\\<forall>i<n. v1 ! i = v2 ! i)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. v1 = v2 \\<Longrightarrow> \\<forall>i<n. v1 ! i = v2 ! i\n 2. \\<forall>i<n. v1 ! i = v2 ! i \\<Longrightarrow> v1 = v2", "assume ?l"], ["proof (state)\nthis:\n  v1 = v2\n\ngoal (2 subgoals):\n 1. v1 = v2 \\<Longrightarrow> \\<forall>i<n. v1 ! i = v2 ! i\n 2. \\<forall>i<n. v1 ! i = v2 ! i \\<Longrightarrow> v1 = v2", "thus ?r"], ["proof (prove)\nusing this:\n  v1 = v2\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. v1 ! i = v2 ! i", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<n. v1 ! i = v2 ! i\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. v1 ! i = v2 ! i \\<Longrightarrow> v1 = v2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i<n. v1 ! i = v2 ! i \\<Longrightarrow> v1 = v2", "assume ?r"], ["proof (state)\nthis:\n  \\<forall>i<n. v1 ! i = v2 ! i\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. v1 ! i = v2 ! i \\<Longrightarrow> v1 = v2", "show ?l"], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 = v2", "proof (rule nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length v1 = length v2\n 2. \\<And>i. i < length v1 \\<Longrightarrow> v1 ! i = v2 ! i", "from wf1 wf2"], ["proof (chain)\npicking this:\n  vec n v1\n  vec n v2", "show \"length v1 = length v2\""], ["proof (prove)\nusing this:\n  vec n v1\n  vec n v2\n\ngoal (1 subgoal):\n 1. length v1 = length v2", "unfolding vec_def"], ["proof (prove)\nusing this:\n  length v1 = n\n  length v2 = n\n\ngoal (1 subgoal):\n 1. length v1 = length v2", "by simp"], ["proof (state)\nthis:\n  length v1 = length v2\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length v1 \\<Longrightarrow> v1 ! i = v2 ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length v1 \\<Longrightarrow> v1 ! i = v2 ! i", "from \\<open>?r\\<close> wf1"], ["proof (chain)\npicking this:\n  \\<forall>i<n. v1 ! i = v2 ! i\n  vec n v1", "show \"\\<And>i. i < length v1 \\<Longrightarrow> v1 ! i = v2 ! i\""], ["proof (prove)\nusing this:\n  \\<forall>i<n. v1 ! i = v2 ! i\n  vec n v1\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length v1 \\<Longrightarrow> v1 ! i = v2 ! i", "unfolding vec_def"], ["proof (prove)\nusing this:\n  \\<forall>i<n. v1 ! i = v2 ! i\n  length v1 = n\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length v1 \\<Longrightarrow> v1 ! i = v2 ! i", "by simp"], ["proof (state)\nthis:\n  ?i < length v1 \\<Longrightarrow> v1 ! ?i = v2 ! ?i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  v1 = v2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vec_eqI:\n  assumes wf1: \"vec n v1\"\n  and wf2: \"vec n v2\"\n  and id: \"\\<And> i. i < n \\<Longrightarrow> v1 ! i = v2 ! i\"\n  shows \"v1 = v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v1 = v2", "unfolding vec_eq[OF wf1 wf2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<n. v1 ! i = v2 ! i", "using id"], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow> v1 ! ?i = v2 ! ?i\n\ngoal (1 subgoal):\n 1. \\<forall>i<n. v1 ! i = v2 ! i", "by auto"], ["", "lemma row_col: assumes \"mat nr nc m\"\n  and \"i < nr\" and \"j < nc\"\n  shows \"row m i ! j = col m j ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row m i ! j = col m j ! i", "using assms"], ["proof (prove)\nusing this:\n  mat nr nc m\n  i < nr\n  j < nc\n\ngoal (1 subgoal):\n 1. row m i ! j = col m j ! i", "unfolding mat_def row_def col_def"], ["proof (prove)\nusing this:\n  length m = nc \\<and> Ball (set m) (vec nr)\n  i < nr\n  j < nc\n\ngoal (1 subgoal):\n 1. map (\\<lambda>w. w ! i) m ! j = m ! j ! i", "by auto"], ["", "lemma col_index: assumes m: \"mat nr nc m\"\n  and i: \"i < nc\"\n  shows \"col m i = map (\\<lambda> j. m ! i ! j) [0 ..< nr]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col m i = map ((!) (m ! i)) [0..<nr]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. col m i = map ((!) (m ! i)) [0..<nr]", "from m[unfolded mat_def] i"], ["proof (chain)\npicking this:\n  length m = nc \\<and> Ball (set m) (vec nr)\n  i < nc", "have nr: \"nr = length (m ! i)\""], ["proof (prove)\nusing this:\n  length m = nc \\<and> Ball (set m) (vec nr)\n  i < nc\n\ngoal (1 subgoal):\n 1. nr = length (m ! i)", "by (auto simp: vec_def)"], ["proof (state)\nthis:\n  nr = length (m ! i)\n\ngoal (1 subgoal):\n 1. col m i = map ((!) (m ! i)) [0..<nr]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. col m i = map ((!) (m ! i)) [0..<nr]", "unfolding nr col_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. m ! i = map ((!) (m ! i)) [0..<length (m ! i)]", "by (rule map_nth[symmetric])"], ["proof (state)\nthis:\n  col m i = map ((!) (m ! i)) [0..<nr]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma row_index: assumes m: \"mat nr nc m\"\n  and i: \"i < nr\"\n  shows \"row m i = map (\\<lambda> j. m ! j ! i) [0 ..< nc]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row m i = map (\\<lambda>j. m ! j ! i) [0..<nc]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. row m i = map (\\<lambda>j. m ! j ! i) [0..<nc]", "note rc = row_col[OF m i]"], ["proof (state)\nthis:\n  ?j < nc \\<Longrightarrow> row m i ! ?j = col m ?j ! i\n\ngoal (1 subgoal):\n 1. row m i = map (\\<lambda>j. m ! j ! i) [0..<nc]", "from row[OF m i]"], ["proof (chain)\npicking this:\n  vec nc (row m i)", "have id: \"length (row m i) = nc\""], ["proof (prove)\nusing this:\n  vec nc (row m i)\n\ngoal (1 subgoal):\n 1. length (row m i) = nc", "unfolding vec_def"], ["proof (prove)\nusing this:\n  length (row m i) = nc\n\ngoal (1 subgoal):\n 1. length (row m i) = nc", "by simp"], ["proof (state)\nthis:\n  length (row m i) = nc\n\ngoal (1 subgoal):\n 1. row m i = map (\\<lambda>j. m ! j ! i) [0..<nc]", "from map_nth[of \"row m i\"]"], ["proof (chain)\npicking this:\n  map ((!) (row m i)) [0..<length (row m i)] = row m i", "have \"row m i = map (\\<lambda> j. row m i ! j) [0 ..< nc]\""], ["proof (prove)\nusing this:\n  map ((!) (row m i)) [0..<length (row m i)] = row m i\n\ngoal (1 subgoal):\n 1. row m i = map ((!) (row m i)) [0..<nc]", "unfolding id"], ["proof (prove)\nusing this:\n  map ((!) (row m i)) [0..<nc] = row m i\n\ngoal (1 subgoal):\n 1. row m i = map ((!) (row m i)) [0..<nc]", "by simp"], ["proof (state)\nthis:\n  row m i = map ((!) (row m i)) [0..<nc]\n\ngoal (1 subgoal):\n 1. row m i = map (\\<lambda>j. m ! j ! i) [0..<nc]", "also"], ["proof (state)\nthis:\n  row m i = map ((!) (row m i)) [0..<nc]\n\ngoal (1 subgoal):\n 1. row m i = map (\\<lambda>j. m ! j ! i) [0..<nc]", "have \"... = map (\\<lambda> j. m ! j ! i) [0 ..< nc]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map ((!) (row m i)) [0..<nc] = map (\\<lambda>j. m ! j ! i) [0..<nc]", "using rc[unfolded col_def]"], ["proof (prove)\nusing this:\n  ?j < nc \\<Longrightarrow> row m i ! ?j = m ! ?j ! i\n\ngoal (1 subgoal):\n 1. map ((!) (row m i)) [0..<nc] = map (\\<lambda>j. m ! j ! i) [0..<nc]", "by auto"], ["proof (state)\nthis:\n  map ((!) (row m i)) [0..<nc] = map (\\<lambda>j. m ! j ! i) [0..<nc]\n\ngoal (1 subgoal):\n 1. row m i = map (\\<lambda>j. m ! j ! i) [0..<nc]", "finally"], ["proof (chain)\npicking this:\n  row m i = map (\\<lambda>j. m ! j ! i) [0..<nc]", "show ?thesis"], ["proof (prove)\nusing this:\n  row m i = map (\\<lambda>j. m ! j ! i) [0..<nc]\n\ngoal (1 subgoal):\n 1. row m i = map (\\<lambda>j. m ! j ! i) [0..<nc]", "."], ["proof (state)\nthis:\n  row m i = map (\\<lambda>j. m ! j ! i) [0..<nc]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_row_eq:\n  assumes wf1: \"mat nr nc m1\"\n  and wf2: \"mat nr nc m2\"\n  shows \"(m1 = m2) = (\\<forall> i < nr. row m1 i = row m2 i)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (m1 = m2) = (\\<forall>i<nr. row m1 i = row m2 i)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. m1 = m2 \\<Longrightarrow> \\<forall>i<nr. row m1 i = row m2 i\n 2. \\<forall>i<nr. row m1 i = row m2 i \\<Longrightarrow> m1 = m2", "assume ?l"], ["proof (state)\nthis:\n  m1 = m2\n\ngoal (2 subgoals):\n 1. m1 = m2 \\<Longrightarrow> \\<forall>i<nr. row m1 i = row m2 i\n 2. \\<forall>i<nr. row m1 i = row m2 i \\<Longrightarrow> m1 = m2", "thus ?r"], ["proof (prove)\nusing this:\n  m1 = m2\n\ngoal (1 subgoal):\n 1. \\<forall>i<nr. row m1 i = row m2 i", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<nr. row m1 i = row m2 i\n\ngoal (1 subgoal):\n 1. \\<forall>i<nr. row m1 i = row m2 i \\<Longrightarrow> m1 = m2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>i<nr. row m1 i = row m2 i \\<Longrightarrow> m1 = m2", "assume ?r"], ["proof (state)\nthis:\n  \\<forall>i<nr. row m1 i = row m2 i\n\ngoal (1 subgoal):\n 1. \\<forall>i<nr. row m1 i = row m2 i \\<Longrightarrow> m1 = m2", "show ?l"], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 = m2", "proof (rule nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length m1 = length m2\n 2. \\<And>i. i < length m1 \\<Longrightarrow> m1 ! i = m2 ! i", "show \"length m1 = length m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length m1 = length m2", "using wf1 wf2"], ["proof (prove)\nusing this:\n  mat nr nc m1\n  mat nr nc m2\n\ngoal (1 subgoal):\n 1. length m1 = length m2", "unfolding mat_def"], ["proof (prove)\nusing this:\n  length m1 = nc \\<and> Ball (set m1) (vec nr)\n  length m2 = nc \\<and> Ball (set m2) (vec nr)\n\ngoal (1 subgoal):\n 1. length m1 = length m2", "by auto"], ["proof (state)\nthis:\n  length m1 = length m2\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length m1 \\<Longrightarrow> m1 ! i = m2 ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i < length m1 \\<Longrightarrow> m1 ! i = m2 ! i", "show \"m1 ! i = m2 ! i\" if i: \"i < length m1\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 ! i = m2 ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m1 ! i = m2 ! i", "show \"m1 ! i = m2 ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 ! i = m2 ! i", "proof (rule nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (m1 ! i) = length (m2 ! i)\n 2. \\<And>ia.\n       ia < length (m1 ! i) \\<Longrightarrow> m1 ! i ! ia = m2 ! i ! ia", "show \"length (m1 ! i) = length (m2 ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (m1 ! i) = length (m2 ! i)", "using wf1 wf2 i"], ["proof (prove)\nusing this:\n  mat nr nc m1\n  mat nr nc m2\n  i < length m1\n\ngoal (1 subgoal):\n 1. length (m1 ! i) = length (m2 ! i)", "unfolding mat_def"], ["proof (prove)\nusing this:\n  length m1 = nc \\<and> Ball (set m1) (vec nr)\n  length m2 = nc \\<and> Ball (set m2) (vec nr)\n  i < length m1\n\ngoal (1 subgoal):\n 1. length (m1 ! i) = length (m2 ! i)", "by (auto simp: vec_def)"], ["proof (state)\nthis:\n  length (m1 ! i) = length (m2 ! i)\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < length (m1 ! i) \\<Longrightarrow> m1 ! i ! ia = m2 ! i ! ia", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < length (m1 ! i) \\<Longrightarrow> m1 ! i ! ia = m2 ! i ! ia", "show \"m1 ! i ! j = m2 ! i ! j\" if j: \"j < length (m1 ! i)\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 ! i ! j = m2 ! i ! j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m1 ! i ! j = m2 ! i ! j", "from i j wf1"], ["proof (chain)\npicking this:\n  i < length m1\n  j < length (m1 ! i)\n  mat nr nc m1", "have i1: \"i < nc\" and j1: \"j < nr\""], ["proof (prove)\nusing this:\n  i < length m1\n  j < length (m1 ! i)\n  mat nr nc m1\n\ngoal (1 subgoal):\n 1. i < nc &&& j < nr", "unfolding mat_def"], ["proof (prove)\nusing this:\n  i < length m1\n  j < length (m1 ! i)\n  length m1 = nc \\<and> Ball (set m1) (vec nr)\n\ngoal (1 subgoal):\n 1. i < nc &&& j < nr", "by (auto simp: vec_def)"], ["proof (state)\nthis:\n  i < nc\n  j < nr\n\ngoal (1 subgoal):\n 1. m1 ! i ! j = m2 ! i ! j", "from \\<open>?r\\<close> j1"], ["proof (chain)\npicking this:\n  \\<forall>i<nr. row m1 i = row m2 i\n  j < nr", "have \"col m1 i ! j = col m2 i ! j\""], ["proof (prove)\nusing this:\n  \\<forall>i<nr. row m1 i = row m2 i\n  j < nr\n\ngoal (1 subgoal):\n 1. col m1 i ! j = col m2 i ! j", "by (simp add: row_col[OF wf1 j1 i1, symmetric] row_col[OF wf2 j1 i1, symmetric])"], ["proof (state)\nthis:\n  col m1 i ! j = col m2 i ! j\n\ngoal (1 subgoal):\n 1. m1 ! i ! j = m2 ! i ! j", "thus \"m1 ! i ! j = m2 ! i ! j\""], ["proof (prove)\nusing this:\n  col m1 i ! j = col m2 i ! j\n\ngoal (1 subgoal):\n 1. m1 ! i ! j = m2 ! i ! j", "unfolding col_def"], ["proof (prove)\nusing this:\n  m1 ! i ! j = m2 ! i ! j\n\ngoal (1 subgoal):\n 1. m1 ! i ! j = m2 ! i ! j", "."], ["proof (state)\nthis:\n  m1 ! i ! j = m2 ! i ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?j < length (m1 ! i) \\<Longrightarrow> m1 ! i ! ?j = m2 ! i ! ?j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m1 ! i = m2 ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < length m1 \\<Longrightarrow> m1 ! ?i = m2 ! ?i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  m1 = m2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_row_eqI:\n  assumes wf1: \"mat nr nc m1\"\n  and wf2: \"mat nr nc m2\"\n  and id: \"\\<And> i. i < nr \\<Longrightarrow> row m1 i = row m2 i\"\n  shows \"m1 = m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m1 = m2", "unfolding mat_row_eq[OF wf1 wf2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<nr. row m1 i = row m2 i", "using id"], ["proof (prove)\nusing this:\n  ?i < nr \\<Longrightarrow> row m1 ?i = row m2 ?i\n\ngoal (1 subgoal):\n 1. \\<forall>i<nr. row m1 i = row m2 i", "by auto"], ["", "lemma row_transpose_is_col[simp]:   assumes wf: \"mat nr nc m\"\n  and i: \"i < nc\"\n  shows \"row (transpose nr m) i = col m i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (Matrix_Legacy.transpose nr m) i = col m i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. row (Matrix_Legacy.transpose nr m) i = col m i", "have len: \"length (row (transpose nr m) i) = length (col m i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (row (Matrix_Legacy.transpose nr m) i) = length (col m i)", "using transpose[OF wf]  wf i"], ["proof (prove)\nusing this:\n  mat nc nr (Matrix_Legacy.transpose nr m)\n  mat nr nc m\n  i < nc\n\ngoal (1 subgoal):\n 1. length (row (Matrix_Legacy.transpose nr m) i) = length (col m i)", "unfolding row_def col_def mat_def"], ["proof (prove)\nusing this:\n  length (Matrix_Legacy.transpose nr m) = nr \\<and>\n  Ball (set (Matrix_Legacy.transpose nr m)) (vec nc)\n  length m = nc \\<and> Ball (set m) (vec nr)\n  i < nc\n\ngoal (1 subgoal):\n 1. length (map (\\<lambda>w. w ! i) (Matrix_Legacy.transpose nr m)) =\n    length (m ! i)", "by (auto simp: vec_def)"], ["proof (state)\nthis:\n  length (row (Matrix_Legacy.transpose nr m) i) = length (col m i)\n\ngoal (1 subgoal):\n 1. row (Matrix_Legacy.transpose nr m) i = col m i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. row (Matrix_Legacy.transpose nr m) i = col m i", "proof (rule nth_equalityI[OF len])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < length (row (Matrix_Legacy.transpose nr m) i) \\<Longrightarrow>\n       row (Matrix_Legacy.transpose nr m) i ! ia = col m i ! ia", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < length (row (Matrix_Legacy.transpose nr m) i) \\<Longrightarrow>\n       row (Matrix_Legacy.transpose nr m) i ! ia = col m i ! ia", "assume \"j < length (row (transpose nr m) i)\""], ["proof (state)\nthis:\n  j < length (row (Matrix_Legacy.transpose nr m) i)\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < length (row (Matrix_Legacy.transpose nr m) i) \\<Longrightarrow>\n       row (Matrix_Legacy.transpose nr m) i ! ia = col m i ! ia", "hence j: \"j < nr\""], ["proof (prove)\nusing this:\n  j < length (row (Matrix_Legacy.transpose nr m) i)\n\ngoal (1 subgoal):\n 1. j < nr", "using transpose[OF wf] wf i"], ["proof (prove)\nusing this:\n  j < length (row (Matrix_Legacy.transpose nr m) i)\n  mat nc nr (Matrix_Legacy.transpose nr m)\n  mat nr nc m\n  i < nc\n\ngoal (1 subgoal):\n 1. j < nr", "unfolding row_def col_def mat_def"], ["proof (prove)\nusing this:\n  j < length (map (\\<lambda>w. w ! i) (Matrix_Legacy.transpose nr m))\n  length (Matrix_Legacy.transpose nr m) = nr \\<and>\n  Ball (set (Matrix_Legacy.transpose nr m)) (vec nc)\n  length m = nc \\<and> Ball (set m) (vec nr)\n  i < nc\n\ngoal (1 subgoal):\n 1. j < nr", "by (auto simp: vec_def)"], ["proof (state)\nthis:\n  j < nr\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < length (row (Matrix_Legacy.transpose nr m) i) \\<Longrightarrow>\n       row (Matrix_Legacy.transpose nr m) i ! ia = col m i ! ia", "show \"row (transpose nr m) i ! j = col m i ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (Matrix_Legacy.transpose nr m) i ! j = col m i ! j", "by (simp only: row_col[OF transpose[OF wf] i j],\n        simp only: col_transpose_is_row[OF wf j],\n        simp only: row_col[OF wf j i])"], ["proof (state)\nthis:\n  row (Matrix_Legacy.transpose nr m) i ! j = col m i ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  row (Matrix_Legacy.transpose nr m) i = col m i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matT_vec_mult_to_scalar:\n  assumes \"mat nr nc m\"\n  and \"vec nr v\"\n  and \"i < nc\"\n  shows \"matT_vec_multI ze pl ti m v ! i = scalar_prodI ze pl ti (col m i) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matT_vec_multI ze pl ti m v ! i = scalar_prodI ze pl ti (col m i) v", "unfolding matT_vec_multI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>w. scalar_prodI ze pl ti w v) m ! i =\n    scalar_prodI ze pl ti (col m i) v", "using assms"], ["proof (prove)\nusing this:\n  mat nr nc m\n  vec nr v\n  i < nc\n\ngoal (1 subgoal):\n 1. map (\\<lambda>w. scalar_prodI ze pl ti w v) m ! i =\n    scalar_prodI ze pl ti (col m i) v", "unfolding mat_def col_def"], ["proof (prove)\nusing this:\n  length m = nc \\<and> Ball (set m) (vec nr)\n  vec nr v\n  i < nc\n\ngoal (1 subgoal):\n 1. map (\\<lambda>w. scalar_prodI ze pl ti w v) m ! i =\n    scalar_prodI ze pl ti (m ! i) v", "by (auto simp: vec_def)"], ["", "lemma mat_vec_mult_index:\n  assumes wf: \"mat nr nc m\"\n  and wfV: \"vec nc v\"\n  and i: \"i < nr\"\n  shows \"matT_vec_multI ze pl ti (transpose nr m) v ! i = scalar_prodI ze pl ti (row m i) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matT_vec_multI ze pl ti (Matrix_Legacy.transpose nr m) v ! i =\n    scalar_prodI ze pl ti (row m i) v", "by (simp only:matT_vec_mult_to_scalar[OF transpose[OF wf] wfV i],\n  simp only: col_transpose_is_row[OF wf i])"], ["", "lemma mat_mult_index[simp] :\n  assumes wf1: \"mat nr n m1\"\n  and wf2: \"mat n nc m2\"\n  and i: \"i < nr\"\n  and j: \"j < nc\"\n  shows \"mat_multI ze pl ti nr m1 m2 ! j ! i = scalar_prodI ze pl ti (row m1 i) (col m2 j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_multI ze pl ti nr m1 m2 ! j ! i =\n    scalar_prodI ze pl ti (row m1 i) (col m2 j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_multI ze pl ti nr m1 m2 ! j ! i =\n    scalar_prodI ze pl ti (row m1 i) (col m2 j)", "have jlen: \"j < length m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < length m2", "using wf2 j"], ["proof (prove)\nusing this:\n  mat n nc m2\n  j < nc\n\ngoal (1 subgoal):\n 1. j < length m2", "unfolding mat_def"], ["proof (prove)\nusing this:\n  length m2 = nc \\<and> Ball (set m2) (vec n)\n  j < nc\n\ngoal (1 subgoal):\n 1. j < length m2", "by auto"], ["proof (state)\nthis:\n  j < length m2\n\ngoal (1 subgoal):\n 1. mat_multI ze pl ti nr m1 m2 ! j ! i =\n    scalar_prodI ze pl ti (row m1 i) (col m2 j)", "have wfj: \"vec n (m2 ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec n (m2 ! j)", "using jlen j wf2"], ["proof (prove)\nusing this:\n  j < length m2\n  j < nc\n  mat n nc m2\n\ngoal (1 subgoal):\n 1. vec n (m2 ! j)", "unfolding mat_def"], ["proof (prove)\nusing this:\n  j < length m2\n  j < nc\n  length m2 = nc \\<and> Ball (set m2) (vec n)\n\ngoal (1 subgoal):\n 1. vec n (m2 ! j)", "by auto"], ["proof (state)\nthis:\n  vec n (m2 ! j)\n\ngoal (1 subgoal):\n 1. mat_multI ze pl ti nr m1 m2 ! j ! i =\n    scalar_prodI ze pl ti (row m1 i) (col m2 j)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_multI ze pl ti nr m1 m2 ! j ! i =\n    scalar_prodI ze pl ti (row m1 i) (col m2 j)", "unfolding mat_multI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (matT_vec_multI ze pl ti (Matrix_Legacy.transpose nr m1)) m2 ! j !\n    i =\n    scalar_prodI ze pl ti (row m1 i) (col m2 j)", "by (simp add: jlen, simp only: mat_vec_mult_index[OF wf1 wfj i], unfold col_def, simp)"], ["proof (state)\nthis:\n  mat_multI ze pl ti nr m1 m2 ! j ! i =\n  scalar_prodI ze pl ti (row m1 i) (col m2 j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma col_mat_mult_index :\n  assumes wf1: \"mat nr n m1\"\n  and wf2: \"mat n nc m2\"\n  and j: \"j < nc\"\n  shows \"col (mat_multI ze pl ti nr m1 m2) j = map (\\<lambda> i. scalar_prodI ze pl ti (row m1 i) (col m2 j)) [0 ..< nr]\" (is \"col ?l j = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (mat_multI ze pl ti nr m1 m2) j =\n    map (\\<lambda>i. scalar_prodI ze pl ti (row m1 i) (col m2 j)) [0..<nr]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. col (mat_multI ze pl ti nr m1 m2) j =\n    map (\\<lambda>i. scalar_prodI ze pl ti (row m1 i) (col m2 j)) [0..<nr]", "have wf12: \"mat nr nc ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat nr nc (mat_multI ze pl ti nr m1 m2)", "by (rule mat_mult[OF wf1 wf2])"], ["proof (state)\nthis:\n  mat nr nc (mat_multI ze pl ti nr m1 m2)\n\ngoal (1 subgoal):\n 1. col (mat_multI ze pl ti nr m1 m2) j =\n    map (\\<lambda>i. scalar_prodI ze pl ti (row m1 i) (col m2 j)) [0..<nr]", "have len: \"length (col ?l j) = length ?r\" and nr: \"length (col ?l j) = nr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (col (mat_multI ze pl ti nr m1 m2) j) =\n    length\n     (map (\\<lambda>i. scalar_prodI ze pl ti (row m1 i) (col m2 j))\n       [0..<nr]) &&&\n    length (col (mat_multI ze pl ti nr m1 m2) j) = nr", "using wf1 wf2 wf12 j"], ["proof (prove)\nusing this:\n  mat nr n m1\n  mat n nc m2\n  mat nr nc (mat_multI ze pl ti nr m1 m2)\n  j < nc\n\ngoal (1 subgoal):\n 1. length (col (mat_multI ze pl ti nr m1 m2) j) =\n    length\n     (map (\\<lambda>i. scalar_prodI ze pl ti (row m1 i) (col m2 j))\n       [0..<nr]) &&&\n    length (col (mat_multI ze pl ti nr m1 m2) j) = nr", "unfolding mat_def col_def"], ["proof (prove)\nusing this:\n  length m1 = n \\<and> Ball (set m1) (vec nr)\n  length m2 = nc \\<and> Ball (set m2) (vec n)\n  length (mat_multI ze pl ti nr m1 m2) = nc \\<and>\n  Ball (set (mat_multI ze pl ti nr m1 m2)) (vec nr)\n  j < nc\n\ngoal (1 subgoal):\n 1. length (mat_multI ze pl ti nr m1 m2 ! j) =\n    length\n     (map (\\<lambda>i. scalar_prodI ze pl ti (row m1 i) (m2 ! j))\n       [0..<nr]) &&&\n    length (mat_multI ze pl ti nr m1 m2 ! j) = nr", "by (auto simp: vec_def)"], ["proof (state)\nthis:\n  length (col (mat_multI ze pl ti nr m1 m2) j) =\n  length\n   (map (\\<lambda>i. scalar_prodI ze pl ti (row m1 i) (col m2 j)) [0..<nr])\n  length (col (mat_multI ze pl ti nr m1 m2) j) = nr\n\ngoal (1 subgoal):\n 1. col (mat_multI ze pl ti nr m1 m2) j =\n    map (\\<lambda>i. scalar_prodI ze pl ti (row m1 i) (col m2 j)) [0..<nr]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. col (mat_multI ze pl ti nr m1 m2) j =\n    map (\\<lambda>i. scalar_prodI ze pl ti (row m1 i) (col m2 j)) [0..<nr]", "by (rule nth_equalityI[OF len], simp add: j nr, unfold col_def, simp only:\n    mat_mult_index[OF wf1 wf2 _ j], simp add: col_def)"], ["proof (state)\nthis:\n  col (mat_multI ze pl ti nr m1 m2) j =\n  map (\\<lambda>i. scalar_prodI ze pl ti (row m1 i) (col m2 j)) [0..<nr]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma row_mat_mult_index :\n  assumes wf1: \"mat nr n m1\"\n  and wf2: \"mat n nc m2\"\n  and i: \"i < nr\"\n  shows \"row (mat_multI ze pl ti nr m1 m2) i = map (\\<lambda> j. scalar_prodI ze pl ti (row m1 i) (col m2 j)) [0 ..< nc]\" (is \"row ?l i = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat_multI ze pl ti nr m1 m2) i =\n    map (\\<lambda>j. scalar_prodI ze pl ti (row m1 i) (col m2 j)) [0..<nc]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. row (mat_multI ze pl ti nr m1 m2) i =\n    map (\\<lambda>j. scalar_prodI ze pl ti (row m1 i) (col m2 j)) [0..<nc]", "have wf12: \"mat nr nc ?l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat nr nc (mat_multI ze pl ti nr m1 m2)", "by (rule mat_mult[OF wf1 wf2])"], ["proof (state)\nthis:\n  mat nr nc (mat_multI ze pl ti nr m1 m2)\n\ngoal (1 subgoal):\n 1. row (mat_multI ze pl ti nr m1 m2) i =\n    map (\\<lambda>j. scalar_prodI ze pl ti (row m1 i) (col m2 j)) [0..<nc]", "hence lenL: \"length ?l = nc\""], ["proof (prove)\nusing this:\n  mat nr nc (mat_multI ze pl ti nr m1 m2)\n\ngoal (1 subgoal):\n 1. length (mat_multI ze pl ti nr m1 m2) = nc", "unfolding mat_def"], ["proof (prove)\nusing this:\n  length (mat_multI ze pl ti nr m1 m2) = nc \\<and>\n  Ball (set (mat_multI ze pl ti nr m1 m2)) (vec nr)\n\ngoal (1 subgoal):\n 1. length (mat_multI ze pl ti nr m1 m2) = nc", "by simp"], ["proof (state)\nthis:\n  length (mat_multI ze pl ti nr m1 m2) = nc\n\ngoal (1 subgoal):\n 1. row (mat_multI ze pl ti nr m1 m2) i =\n    map (\\<lambda>j. scalar_prodI ze pl ti (row m1 i) (col m2 j)) [0..<nc]", "have len: \"length (row ?l i) = length ?r\" and nc: \"length (row ?l i) = nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (row (mat_multI ze pl ti nr m1 m2) i) =\n    length\n     (map (\\<lambda>j. scalar_prodI ze pl ti (row m1 i) (col m2 j))\n       [0..<nc]) &&&\n    length (row (mat_multI ze pl ti nr m1 m2) i) = nc", "using wf1 wf2 wf12 i"], ["proof (prove)\nusing this:\n  mat nr n m1\n  mat n nc m2\n  mat nr nc (mat_multI ze pl ti nr m1 m2)\n  i < nr\n\ngoal (1 subgoal):\n 1. length (row (mat_multI ze pl ti nr m1 m2) i) =\n    length\n     (map (\\<lambda>j. scalar_prodI ze pl ti (row m1 i) (col m2 j))\n       [0..<nc]) &&&\n    length (row (mat_multI ze pl ti nr m1 m2) i) = nc", "unfolding mat_def row_def"], ["proof (prove)\nusing this:\n  length m1 = n \\<and> Ball (set m1) (vec nr)\n  length m2 = nc \\<and> Ball (set m2) (vec n)\n  length (mat_multI ze pl ti nr m1 m2) = nc \\<and>\n  Ball (set (mat_multI ze pl ti nr m1 m2)) (vec nr)\n  i < nr\n\ngoal (1 subgoal):\n 1. length (map (\\<lambda>w. w ! i) (mat_multI ze pl ti nr m1 m2)) =\n    length\n     (map (\\<lambda>j.\n              scalar_prodI ze pl ti (map (\\<lambda>w. w ! i) m1) (col m2 j))\n       [0..<nc]) &&&\n    length (map (\\<lambda>w. w ! i) (mat_multI ze pl ti nr m1 m2)) = nc", "by (auto simp: vec_def)"], ["proof (state)\nthis:\n  length (row (mat_multI ze pl ti nr m1 m2) i) =\n  length\n   (map (\\<lambda>j. scalar_prodI ze pl ti (row m1 i) (col m2 j)) [0..<nc])\n  length (row (mat_multI ze pl ti nr m1 m2) i) = nc\n\ngoal (1 subgoal):\n 1. row (mat_multI ze pl ti nr m1 m2) i =\n    map (\\<lambda>j. scalar_prodI ze pl ti (row m1 i) (col m2 j)) [0..<nc]", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat_multI ze pl ti nr m1 m2) i =\n    map (\\<lambda>j. scalar_prodI ze pl ti (row m1 i) (col m2 j)) [0..<nc]", "by (rule nth_equalityI[OF len], simp add: i nc, unfold row_def, simp add: lenL, simp only:\n    mat_mult_index[OF wf1 wf2 i], simp add: row_def)"], ["proof (state)\nthis:\n  row (mat_multI ze pl ti nr m1 m2) i =\n  map (\\<lambda>j. scalar_prodI ze pl ti (row m1 i) (col m2 j)) [0..<nc]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scalar_prod_cons:\n  \"scalar_prodI ze pl ti (a # as) (b # bs) = pl (ti a b) (scalar_prodI ze pl ti as bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_prodI ze pl ti (a # as) (b # bs) =\n    pl (ti a b) (scalar_prodI ze pl ti as bs)", "unfolding scalar_prodI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(x, y). pl (ti x y)) (zip (a # as) (b # bs)) ze =\n    pl (ti a b) (foldr (\\<lambda>(x, y). pl (ti x y)) (zip as bs) ze)", "by auto"], ["", "lemma vec_plus_index[simp]:\n  assumes wf1: \"vec nr v1\"\n  and wf2: \"vec nr v2\"\n  and i: \"i < nr\"\n  shows \"vec_plusI pl v1 v2 ! i = pl (v1 ! i)  (v2 ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_plusI pl v1 v2 ! i = pl (v1 ! i) (v2 ! i)", "using wf1 wf2 i"], ["proof (prove)\nusing this:\n  vec nr v1\n  vec nr v2\n  i < nr\n\ngoal (1 subgoal):\n 1. vec_plusI pl v1 v2 ! i = pl (v1 ! i) (v2 ! i)", "unfolding vec_def vec_plusI_def"], ["proof (prove)\nusing this:\n  length v1 = nr\n  length v2 = nr\n  i < nr\n\ngoal (1 subgoal):\n 1. map (\\<lambda>xy. pl (fst xy) (snd xy)) (zip v1 v2) ! i =\n    pl (v1 ! i) (v2 ! i)", "proof (induct v1 arbitrary: i v2 nr, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a v1 i v2 nr.\n       \\<lbrakk>\\<And>i v2 nr.\n                   \\<lbrakk>length v1 = nr; length v2 = nr; i < nr\\<rbrakk>\n                   \\<Longrightarrow> map (\\<lambda>xy. pl (fst xy) (snd xy))\n(zip v1 v2) !\n                                     i =\n                                     pl (v1 ! i) (v2 ! i);\n        length (a # v1) = nr; length v2 = nr; i < nr\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>xy. pl (fst xy) (snd xy))\n                          (zip (a # v1) v2) !\n                         i =\n                         pl ((a # v1) ! i) (v2 ! i)", "case (Cons a v11)"], ["proof (state)\nthis:\n  \\<lbrakk>length v11 = ?nr; length ?v2.0 = ?nr; ?i < ?nr\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>xy. pl (fst xy) (snd xy))\n                     (zip v11 ?v2.0) !\n                    ?i =\n                    pl (v11 ! ?i) (?v2.0 ! ?i)\n  length (a # v11) = nr\n  length v2 = nr\n  i < nr\n\ngoal (1 subgoal):\n 1. \\<And>a v1 i v2 nr.\n       \\<lbrakk>\\<And>i v2 nr.\n                   \\<lbrakk>length v1 = nr; length v2 = nr; i < nr\\<rbrakk>\n                   \\<Longrightarrow> map (\\<lambda>xy. pl (fst xy) (snd xy))\n(zip v1 v2) !\n                                     i =\n                                     pl (v1 ! i) (v2 ! i);\n        length (a # v1) = nr; length v2 = nr; i < nr\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>xy. pl (fst xy) (snd xy))\n                          (zip (a # v1) v2) !\n                         i =\n                         pl ((a # v1) ! i) (v2 ! i)", "from Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>length v11 = ?nr; length ?v2.0 = ?nr; ?i < ?nr\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>xy. pl (fst xy) (snd xy))\n                     (zip v11 ?v2.0) !\n                    ?i =\n                    pl (v11 ! ?i) (?v2.0 ! ?i)\n  length (a # v11) = nr\n  length v2 = nr\n  i < nr", "obtain b v22 where v2: \"v2 = b # v22\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length v11 = ?nr; length ?v2.0 = ?nr; ?i < ?nr\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>xy. pl (fst xy) (snd xy))\n                     (zip v11 ?v2.0) !\n                    ?i =\n                    pl (v11 ! ?i) (?v2.0 ! ?i)\n  length (a # v11) = nr\n  length v2 = nr\n  i < nr\n\ngoal (1 subgoal):\n 1. (\\<And>b v22. v2 = b # v22 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases v2, auto)"], ["proof (state)\nthis:\n  v2 = b # v22\n\ngoal (1 subgoal):\n 1. \\<And>a v1 i v2 nr.\n       \\<lbrakk>\\<And>i v2 nr.\n                   \\<lbrakk>length v1 = nr; length v2 = nr; i < nr\\<rbrakk>\n                   \\<Longrightarrow> map (\\<lambda>xy. pl (fst xy) (snd xy))\n(zip v1 v2) !\n                                     i =\n                                     pl (v1 ! i) (v2 ! i);\n        length (a # v1) = nr; length v2 = nr; i < nr\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>xy. pl (fst xy) (snd xy))\n                          (zip (a # v1) v2) !\n                         i =\n                         pl ((a # v1) ! i) (v2 ! i)", "from v2 Cons"], ["proof (chain)\npicking this:\n  v2 = b # v22\n  \\<lbrakk>length v11 = ?nr; length ?v2.0 = ?nr; ?i < ?nr\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>xy. pl (fst xy) (snd xy))\n                     (zip v11 ?v2.0) !\n                    ?i =\n                    pl (v11 ! ?i) (?v2.0 ! ?i)\n  length (a # v11) = nr\n  length v2 = nr\n  i < nr", "obtain nrr where nr: \"nr = Suc nrr\""], ["proof (prove)\nusing this:\n  v2 = b # v22\n  \\<lbrakk>length v11 = ?nr; length ?v2.0 = ?nr; ?i < ?nr\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>xy. pl (fst xy) (snd xy))\n                     (zip v11 ?v2.0) !\n                    ?i =\n                    pl (v11 ! ?i) (?v2.0 ! ?i)\n  length (a # v11) = nr\n  length v2 = nr\n  i < nr\n\ngoal (1 subgoal):\n 1. (\\<And>nrr. nr = Suc nrr \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (force)"], ["proof (state)\nthis:\n  nr = Suc nrr\n\ngoal (1 subgoal):\n 1. \\<And>a v1 i v2 nr.\n       \\<lbrakk>\\<And>i v2 nr.\n                   \\<lbrakk>length v1 = nr; length v2 = nr; i < nr\\<rbrakk>\n                   \\<Longrightarrow> map (\\<lambda>xy. pl (fst xy) (snd xy))\n(zip v1 v2) !\n                                     i =\n                                     pl (v1 ! i) (v2 ! i);\n        length (a # v1) = nr; length v2 = nr; i < nr\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>xy. pl (fst xy) (snd xy))\n                          (zip (a # v1) v2) !\n                         i =\n                         pl ((a # v1) ! i) (v2 ! i)", "from Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>length v11 = ?nr; length ?v2.0 = ?nr; ?i < ?nr\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>xy. pl (fst xy) (snd xy))\n                     (zip v11 ?v2.0) !\n                    ?i =\n                    pl (v11 ! ?i) (?v2.0 ! ?i)\n  length (a # v11) = nr\n  length v2 = nr\n  i < nr", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>length v11 = ?nr; length ?v2.0 = ?nr; ?i < ?nr\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>xy. pl (fst xy) (snd xy))\n                     (zip v11 ?v2.0) !\n                    ?i =\n                    pl (v11 ! ?i) (?v2.0 ! ?i)\n  length (a # v11) = nr\n  length v2 = nr\n  i < nr\n\ngoal (1 subgoal):\n 1. map (\\<lambda>xy. pl (fst xy) (snd xy)) (zip (a # v11) v2) ! i =\n    pl ((a # v11) ! i) (v2 ! i)", "by (cases i, simp add: v2, auto simp: v2 nr)"], ["proof (state)\nthis:\n  map (\\<lambda>xy. pl (fst xy) (snd xy)) (zip (a # v11) v2) ! i =\n  pl ((a # v11) ! i) (v2 ! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_map_index[simp]: assumes wf: \"mat nr nc m\" and i: \"i < nc\" and j: \"j < nr\"\n  shows \"mat_map f m ! i ! j = f (m ! i ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_map f m ! i ! j = f (m ! i ! j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_map f m ! i ! j = f (m ! i ! j)", "from wf i"], ["proof (chain)\npicking this:\n  mat nr nc m\n  i < nc", "have i: \"i < length m\""], ["proof (prove)\nusing this:\n  mat nr nc m\n  i < nc\n\ngoal (1 subgoal):\n 1. i < length m", "unfolding mat_def"], ["proof (prove)\nusing this:\n  length m = nc \\<and> Ball (set m) (vec nr)\n  i < nc\n\ngoal (1 subgoal):\n 1. i < length m", "by auto"], ["proof (state)\nthis:\n  i < length m\n\ngoal (1 subgoal):\n 1. mat_map f m ! i ! j = f (m ! i ! j)", "with wf j"], ["proof (chain)\npicking this:\n  mat nr nc m\n  j < nr\n  i < length m", "have j: \"j < length (m ! i)\""], ["proof (prove)\nusing this:\n  mat nr nc m\n  j < nr\n  i < length m\n\ngoal (1 subgoal):\n 1. j < length (m ! i)", "unfolding mat_def"], ["proof (prove)\nusing this:\n  length m = nc \\<and> Ball (set m) (vec nr)\n  j < nr\n  i < length m\n\ngoal (1 subgoal):\n 1. j < length (m ! i)", "by (auto simp: vec_def)"], ["proof (state)\nthis:\n  j < length (m ! i)\n\ngoal (1 subgoal):\n 1. mat_map f m ! i ! j = f (m ! i ! j)", "have \"mat_map f m ! i ! j = map (map f) m ! i ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_map f m ! i ! j = map (map f) m ! i ! j", "unfolding mat_map_def vec_map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (map f) m ! i ! j = map (map f) m ! i ! j", "by auto"], ["proof (state)\nthis:\n  mat_map f m ! i ! j = map (map f) m ! i ! j\n\ngoal (1 subgoal):\n 1. mat_map f m ! i ! j = f (m ! i ! j)", "also"], ["proof (state)\nthis:\n  mat_map f m ! i ! j = map (map f) m ! i ! j\n\ngoal (1 subgoal):\n 1. mat_map f m ! i ! j = f (m ! i ! j)", "have \"\\<dots> = map f (m ! i) ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (map f) m ! i ! j = map f (m ! i) ! j", "using i"], ["proof (prove)\nusing this:\n  i < length m\n\ngoal (1 subgoal):\n 1. map (map f) m ! i ! j = map f (m ! i) ! j", "by auto"], ["proof (state)\nthis:\n  map (map f) m ! i ! j = map f (m ! i) ! j\n\ngoal (1 subgoal):\n 1. mat_map f m ! i ! j = f (m ! i ! j)", "also"], ["proof (state)\nthis:\n  map (map f) m ! i ! j = map f (m ! i) ! j\n\ngoal (1 subgoal):\n 1. mat_map f m ! i ! j = f (m ! i ! j)", "have \"\\<dots> = f (m ! i ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map f (m ! i) ! j = f (m ! i ! j)", "using j"], ["proof (prove)\nusing this:\n  j < length (m ! i)\n\ngoal (1 subgoal):\n 1. map f (m ! i) ! j = f (m ! i ! j)", "by auto"], ["proof (state)\nthis:\n  map f (m ! i) ! j = f (m ! i ! j)\n\ngoal (1 subgoal):\n 1. mat_map f m ! i ! j = f (m ! i ! j)", "finally"], ["proof (chain)\npicking this:\n  mat_map f m ! i ! j = f (m ! i ! j)", "show ?thesis"], ["proof (prove)\nusing this:\n  mat_map f m ! i ! j = f (m ! i ! j)\n\ngoal (1 subgoal):\n 1. mat_map f m ! i ! j = f (m ! i ! j)", "."], ["proof (state)\nthis:\n  mat_map f m ! i ! j = f (m ! i ! j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_plus_index[simp]:\n  assumes wf1: \"mat nr nc m1\"\n  and wf2: \"mat nr nc m2\"\n  and i: \"i < nc\"\n  and j: \"j < nr\"\n  shows \"mat_plusI pl m1 m2 ! i ! j = pl (m1 ! i ! j) (m2 ! i ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_plusI pl m1 m2 ! i ! j = pl (m1 ! i ! j) (m2 ! i ! j)", "using wf1 wf2 i"], ["proof (prove)\nusing this:\n  mat nr nc m1\n  mat nr nc m2\n  i < nc\n\ngoal (1 subgoal):\n 1. mat_plusI pl m1 m2 ! i ! j = pl (m1 ! i ! j) (m2 ! i ! j)", "unfolding mat_plusI_def mat_def"], ["proof (prove)\nusing this:\n  length m1 = nc \\<and> Ball (set m1) (vec nr)\n  length m2 = nc \\<and> Ball (set m2) (vec nr)\n  i < nc\n\ngoal (1 subgoal):\n 1. map (\\<lambda>uv. vec_plusI pl (fst uv) (snd uv)) (zip m1 m2) ! i ! j =\n    pl (m1 ! i ! j) (m2 ! i ! j)", "proof (simp, induct m1 arbitrary: m2 i nc, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a m1 m2 i nc.\n       \\<lbrakk>\\<And>m2 i nc.\n                   \\<lbrakk>length m1 = nc \\<and> Ball (set m1) (vec nr);\n                    length m2 = nc \\<and> Ball (set m2) (vec nr); i < nc;\n                    length m1 = nc \\<and> Ball (set m1) (vec nr);\n                    length m2 = nc \\<and> Ball (set m2) (vec nr);\n                    i < nc\\<rbrakk>\n                   \\<Longrightarrow> vec_plusI pl (m1 ! i) (m2 ! i) ! j =\n                                     pl (m1 ! i ! j) (m2 ! i ! j);\n        length (a # m1) = nc \\<and> Ball (set (a # m1)) (vec nr);\n        length m2 = nc \\<and> Ball (set m2) (vec nr); i < nc;\n        length (a # m1) = nc \\<and> Ball (set (a # m1)) (vec nr);\n        length m2 = nc \\<and> Ball (set m2) (vec nr); i < nc\\<rbrakk>\n       \\<Longrightarrow> vec_plusI pl ((a # m1) ! i) (m2 ! i) ! j =\n                         pl ((a # m1) ! i ! j) (m2 ! i ! j)", "case (Cons v1 m11)"], ["proof (state)\nthis:\n  \\<lbrakk>length m11 = ?nc \\<and> (\\<forall>a\\<in>set m11. vec nr a);\n   length ?m2.0 = ?nc \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a); ?i < ?nc;\n   length m11 = ?nc \\<and> (\\<forall>a\\<in>set m11. vec nr a);\n   length ?m2.0 = ?nc \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   ?i < ?nc\\<rbrakk>\n  \\<Longrightarrow> vec_plusI pl (m11 ! ?i) (?m2.0 ! ?i) ! j =\n                    pl (m11 ! ?i ! j) (?m2.0 ! ?i ! j)\n  length (v1 # m11) = nc \\<and> (\\<forall>a\\<in>set (v1 # m11). vec nr a)\n  length m2 = nc \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  i < nc\n  length (v1 # m11) = nc \\<and> (\\<forall>a\\<in>set (v1 # m11). vec nr a)\n  length m2 = nc \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  i < nc\n\ngoal (1 subgoal):\n 1. \\<And>a m1 m2 i nc.\n       \\<lbrakk>\\<And>m2 i nc.\n                   \\<lbrakk>length m1 = nc \\<and> Ball (set m1) (vec nr);\n                    length m2 = nc \\<and> Ball (set m2) (vec nr); i < nc;\n                    length m1 = nc \\<and> Ball (set m1) (vec nr);\n                    length m2 = nc \\<and> Ball (set m2) (vec nr);\n                    i < nc\\<rbrakk>\n                   \\<Longrightarrow> vec_plusI pl (m1 ! i) (m2 ! i) ! j =\n                                     pl (m1 ! i ! j) (m2 ! i ! j);\n        length (a # m1) = nc \\<and> Ball (set (a # m1)) (vec nr);\n        length m2 = nc \\<and> Ball (set m2) (vec nr); i < nc;\n        length (a # m1) = nc \\<and> Ball (set (a # m1)) (vec nr);\n        length m2 = nc \\<and> Ball (set m2) (vec nr); i < nc\\<rbrakk>\n       \\<Longrightarrow> vec_plusI pl ((a # m1) ! i) (m2 ! i) ! j =\n                         pl ((a # m1) ! i ! j) (m2 ! i ! j)", "from Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>length m11 = ?nc \\<and> (\\<forall>a\\<in>set m11. vec nr a);\n   length ?m2.0 = ?nc \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a); ?i < ?nc;\n   length m11 = ?nc \\<and> (\\<forall>a\\<in>set m11. vec nr a);\n   length ?m2.0 = ?nc \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   ?i < ?nc\\<rbrakk>\n  \\<Longrightarrow> vec_plusI pl (m11 ! ?i) (?m2.0 ! ?i) ! j =\n                    pl (m11 ! ?i ! j) (?m2.0 ! ?i ! j)\n  length (v1 # m11) = nc \\<and> (\\<forall>a\\<in>set (v1 # m11). vec nr a)\n  length m2 = nc \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  i < nc\n  length (v1 # m11) = nc \\<and> (\\<forall>a\\<in>set (v1 # m11). vec nr a)\n  length m2 = nc \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  i < nc", "obtain v2 m22 where m2: \"m2 = v2 # m22\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length m11 = ?nc \\<and> (\\<forall>a\\<in>set m11. vec nr a);\n   length ?m2.0 = ?nc \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a); ?i < ?nc;\n   length m11 = ?nc \\<and> (\\<forall>a\\<in>set m11. vec nr a);\n   length ?m2.0 = ?nc \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   ?i < ?nc\\<rbrakk>\n  \\<Longrightarrow> vec_plusI pl (m11 ! ?i) (?m2.0 ! ?i) ! j =\n                    pl (m11 ! ?i ! j) (?m2.0 ! ?i ! j)\n  length (v1 # m11) = nc \\<and> (\\<forall>a\\<in>set (v1 # m11). vec nr a)\n  length m2 = nc \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  i < nc\n  length (v1 # m11) = nc \\<and> (\\<forall>a\\<in>set (v1 # m11). vec nr a)\n  length m2 = nc \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  i < nc\n\ngoal (1 subgoal):\n 1. (\\<And>v2 m22. m2 = v2 # m22 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases m2, auto)"], ["proof (state)\nthis:\n  m2 = v2 # m22\n\ngoal (1 subgoal):\n 1. \\<And>a m1 m2 i nc.\n       \\<lbrakk>\\<And>m2 i nc.\n                   \\<lbrakk>length m1 = nc \\<and> Ball (set m1) (vec nr);\n                    length m2 = nc \\<and> Ball (set m2) (vec nr); i < nc;\n                    length m1 = nc \\<and> Ball (set m1) (vec nr);\n                    length m2 = nc \\<and> Ball (set m2) (vec nr);\n                    i < nc\\<rbrakk>\n                   \\<Longrightarrow> vec_plusI pl (m1 ! i) (m2 ! i) ! j =\n                                     pl (m1 ! i ! j) (m2 ! i ! j);\n        length (a # m1) = nc \\<and> Ball (set (a # m1)) (vec nr);\n        length m2 = nc \\<and> Ball (set m2) (vec nr); i < nc;\n        length (a # m1) = nc \\<and> Ball (set (a # m1)) (vec nr);\n        length m2 = nc \\<and> Ball (set m2) (vec nr); i < nc\\<rbrakk>\n       \\<Longrightarrow> vec_plusI pl ((a # m1) ! i) (m2 ! i) ! j =\n                         pl ((a # m1) ! i ! j) (m2 ! i ! j)", "from m2 Cons"], ["proof (chain)\npicking this:\n  m2 = v2 # m22\n  \\<lbrakk>length m11 = ?nc \\<and> (\\<forall>a\\<in>set m11. vec nr a);\n   length ?m2.0 = ?nc \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a); ?i < ?nc;\n   length m11 = ?nc \\<and> (\\<forall>a\\<in>set m11. vec nr a);\n   length ?m2.0 = ?nc \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   ?i < ?nc\\<rbrakk>\n  \\<Longrightarrow> vec_plusI pl (m11 ! ?i) (?m2.0 ! ?i) ! j =\n                    pl (m11 ! ?i ! j) (?m2.0 ! ?i ! j)\n  length (v1 # m11) = nc \\<and> (\\<forall>a\\<in>set (v1 # m11). vec nr a)\n  length m2 = nc \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  i < nc\n  length (v1 # m11) = nc \\<and> (\\<forall>a\\<in>set (v1 # m11). vec nr a)\n  length m2 = nc \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  i < nc", "obtain ncc where nc: \"nc = Suc ncc\""], ["proof (prove)\nusing this:\n  m2 = v2 # m22\n  \\<lbrakk>length m11 = ?nc \\<and> (\\<forall>a\\<in>set m11. vec nr a);\n   length ?m2.0 = ?nc \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a); ?i < ?nc;\n   length m11 = ?nc \\<and> (\\<forall>a\\<in>set m11. vec nr a);\n   length ?m2.0 = ?nc \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   ?i < ?nc\\<rbrakk>\n  \\<Longrightarrow> vec_plusI pl (m11 ! ?i) (?m2.0 ! ?i) ! j =\n                    pl (m11 ! ?i ! j) (?m2.0 ! ?i ! j)\n  length (v1 # m11) = nc \\<and> (\\<forall>a\\<in>set (v1 # m11). vec nr a)\n  length m2 = nc \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  i < nc\n  length (v1 # m11) = nc \\<and> (\\<forall>a\\<in>set (v1 # m11). vec nr a)\n  length m2 = nc \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  i < nc\n\ngoal (1 subgoal):\n 1. (\\<And>ncc. nc = Suc ncc \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  nc = Suc ncc\n\ngoal (1 subgoal):\n 1. \\<And>a m1 m2 i nc.\n       \\<lbrakk>\\<And>m2 i nc.\n                   \\<lbrakk>length m1 = nc \\<and> Ball (set m1) (vec nr);\n                    length m2 = nc \\<and> Ball (set m2) (vec nr); i < nc;\n                    length m1 = nc \\<and> Ball (set m1) (vec nr);\n                    length m2 = nc \\<and> Ball (set m2) (vec nr);\n                    i < nc\\<rbrakk>\n                   \\<Longrightarrow> vec_plusI pl (m1 ! i) (m2 ! i) ! j =\n                                     pl (m1 ! i ! j) (m2 ! i ! j);\n        length (a # m1) = nc \\<and> Ball (set (a # m1)) (vec nr);\n        length m2 = nc \\<and> Ball (set m2) (vec nr); i < nc;\n        length (a # m1) = nc \\<and> Ball (set (a # m1)) (vec nr);\n        length m2 = nc \\<and> Ball (set m2) (vec nr); i < nc\\<rbrakk>\n       \\<Longrightarrow> vec_plusI pl ((a # m1) ! i) (m2 ! i) ! j =\n                         pl ((a # m1) ! i ! j) (m2 ! i ! j)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_plusI pl ((v1 # m11) ! i) (m2 ! i) ! j =\n    pl ((v1 # m11) ! i ! j) (m2 ! i ! j)", "proof (cases i, simp add: m2, rule vec_plus_index[where nr = nr], (auto simp: Cons j m2)[3])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       vec_plusI pl ((v1 # m11) ! i) (m2 ! i) ! j =\n       pl ((v1 # m11) ! i ! j) (m2 ! i ! j)", "case (Suc ii)"], ["proof (state)\nthis:\n  i = Suc ii\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       vec_plusI pl ((v1 # m11) ! i) (m2 ! i) ! j =\n       pl ((v1 # m11) ! i ! j) (m2 ! i ! j)", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>length m11 = ?nc \\<and> (\\<forall>a\\<in>set m11. vec nr a);\n   length ?m2.0 = ?nc \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a); ?i < ?nc;\n   length m11 = ?nc \\<and> (\\<forall>a\\<in>set m11. vec nr a);\n   length ?m2.0 = ?nc \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   ?i < ?nc\\<rbrakk>\n  \\<Longrightarrow> vec_plusI pl (m11 ! ?i) (?m2.0 ! ?i) ! j =\n                    pl (m11 ! ?i ! j) (?m2.0 ! ?i ! j)\n  length (v1 # m11) = nc \\<and> (\\<forall>a\\<in>set (v1 # m11). vec nr a)\n  length m2 = nc \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  i < nc\n  length (v1 # m11) = nc \\<and> (\\<forall>a\\<in>set (v1 # m11). vec nr a)\n  length m2 = nc \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  i < nc\n  i = Suc ii", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length m11 = ?nc \\<and> (\\<forall>a\\<in>set m11. vec nr a);\n   length ?m2.0 = ?nc \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a); ?i < ?nc;\n   length m11 = ?nc \\<and> (\\<forall>a\\<in>set m11. vec nr a);\n   length ?m2.0 = ?nc \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   ?i < ?nc\\<rbrakk>\n  \\<Longrightarrow> vec_plusI pl (m11 ! ?i) (?m2.0 ! ?i) ! j =\n                    pl (m11 ! ?i ! j) (?m2.0 ! ?i ! j)\n  length (v1 # m11) = nc \\<and> (\\<forall>a\\<in>set (v1 # m11). vec nr a)\n  length m2 = nc \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  i < nc\n  length (v1 # m11) = nc \\<and> (\\<forall>a\\<in>set (v1 # m11). vec nr a)\n  length m2 = nc \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  i < nc\n  i = Suc ii\n\ngoal (1 subgoal):\n 1. vec_plusI pl ((v1 # m11) ! i) (m2 ! i) ! j =\n    pl ((v1 # m11) ! i ! j) (m2 ! i ! j)", "using m2 nc"], ["proof (prove)\nusing this:\n  \\<lbrakk>length m11 = ?nc \\<and> (\\<forall>a\\<in>set m11. vec nr a);\n   length ?m2.0 = ?nc \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a); ?i < ?nc;\n   length m11 = ?nc \\<and> (\\<forall>a\\<in>set m11. vec nr a);\n   length ?m2.0 = ?nc \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   ?i < ?nc\\<rbrakk>\n  \\<Longrightarrow> vec_plusI pl (m11 ! ?i) (?m2.0 ! ?i) ! j =\n                    pl (m11 ! ?i ! j) (?m2.0 ! ?i ! j)\n  length (v1 # m11) = nc \\<and> (\\<forall>a\\<in>set (v1 # m11). vec nr a)\n  length m2 = nc \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  i < nc\n  length (v1 # m11) = nc \\<and> (\\<forall>a\\<in>set (v1 # m11). vec nr a)\n  length m2 = nc \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  i < nc\n  i = Suc ii\n  m2 = v2 # m22\n  nc = Suc ncc\n\ngoal (1 subgoal):\n 1. vec_plusI pl ((v1 # m11) ! i) (m2 ! i) ! j =\n    pl ((v1 # m11) ! i ! j) (m2 ! i ! j)", "by auto"], ["proof (state)\nthis:\n  vec_plusI pl ((v1 # m11) ! i) (m2 ! i) ! j =\n  pl ((v1 # m11) ! i ! j) (m2 ! i ! j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  vec_plusI pl ((v1 # m11) ! i) (m2 ! i) ! j =\n  pl ((v1 # m11) ! i ! j) (m2 ! i ! j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma col_mat_plus: assumes wf1: \"mat nr nc m1\"\n  and wf2: \"mat nr nc m2\"\n  and i: \"i < nc\"\n  shows \"col (mat_plusI pl m1 m2) i = vec_plusI pl (col m1 i) (col m2 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (mat_plusI pl m1 m2) i = vec_plusI pl (col m1 i) (col m2 i)", "using assms"], ["proof (prove)\nusing this:\n  mat nr nc m1\n  mat nr nc m2\n  i < nc\n\ngoal (1 subgoal):\n 1. col (mat_plusI pl m1 m2) i = vec_plusI pl (col m1 i) (col m2 i)", "unfolding mat_plusI_def col_def mat_def"], ["proof (prove)\nusing this:\n  length m1 = nc \\<and> Ball (set m1) (vec nr)\n  length m2 = nc \\<and> Ball (set m2) (vec nr)\n  i < nc\n\ngoal (1 subgoal):\n 1. map (\\<lambda>uv. vec_plusI pl (fst uv) (snd uv)) (zip m1 m2) ! i =\n    vec_plusI pl (m1 ! i) (m2 ! i)", "proof (induct m1 arbitrary: m2 nc i, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a m1 m2 nc i.\n       \\<lbrakk>\\<And>m2 nc i.\n                   \\<lbrakk>length m1 = nc \\<and> Ball (set m1) (vec nr);\n                    length m2 = nc \\<and> Ball (set m2) (vec nr);\n                    i < nc\\<rbrakk>\n                   \\<Longrightarrow> map\n(\\<lambda>uv. vec_plusI pl (fst uv) (snd uv)) (zip m1 m2) !\n                                     i =\n                                     vec_plusI pl (m1 ! i) (m2 ! i);\n        length (a # m1) = nc \\<and> Ball (set (a # m1)) (vec nr);\n        length m2 = nc \\<and> Ball (set m2) (vec nr); i < nc\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>uv. vec_plusI pl (fst uv) (snd uv))\n                          (zip (a # m1) m2) !\n                         i =\n                         vec_plusI pl ((a # m1) ! i) (m2 ! i)", "case (Cons v m1)"], ["proof (state)\nthis:\n  \\<lbrakk>length m1 = ?nc \\<and> (\\<forall>a\\<in>set m1. vec nr a);\n   length ?m2.0 = ?nc \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   ?i < ?nc\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>uv. vec_plusI pl (fst uv) (snd uv))\n                     (zip m1 ?m2.0) !\n                    ?i =\n                    vec_plusI pl (m1 ! ?i) (?m2.0 ! ?i)\n  length (v # m1) = nc \\<and> (\\<forall>a\\<in>set (v # m1). vec nr a)\n  length m2 = nc \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  i < nc\n\ngoal (1 subgoal):\n 1. \\<And>a m1 m2 nc i.\n       \\<lbrakk>\\<And>m2 nc i.\n                   \\<lbrakk>length m1 = nc \\<and> Ball (set m1) (vec nr);\n                    length m2 = nc \\<and> Ball (set m2) (vec nr);\n                    i < nc\\<rbrakk>\n                   \\<Longrightarrow> map\n(\\<lambda>uv. vec_plusI pl (fst uv) (snd uv)) (zip m1 m2) !\n                                     i =\n                                     vec_plusI pl (m1 ! i) (m2 ! i);\n        length (a # m1) = nc \\<and> Ball (set (a # m1)) (vec nr);\n        length m2 = nc \\<and> Ball (set m2) (vec nr); i < nc\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>uv. vec_plusI pl (fst uv) (snd uv))\n                          (zip (a # m1) m2) !\n                         i =\n                         vec_plusI pl ((a # m1) ! i) (m2 ! i)", "from Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>length m1 = ?nc \\<and> (\\<forall>a\\<in>set m1. vec nr a);\n   length ?m2.0 = ?nc \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   ?i < ?nc\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>uv. vec_plusI pl (fst uv) (snd uv))\n                     (zip m1 ?m2.0) !\n                    ?i =\n                    vec_plusI pl (m1 ! ?i) (?m2.0 ! ?i)\n  length (v # m1) = nc \\<and> (\\<forall>a\\<in>set (v # m1). vec nr a)\n  length m2 = nc \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  i < nc", "obtain v2 m22 where m2: \"m2 = v2 # m22\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length m1 = ?nc \\<and> (\\<forall>a\\<in>set m1. vec nr a);\n   length ?m2.0 = ?nc \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   ?i < ?nc\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>uv. vec_plusI pl (fst uv) (snd uv))\n                     (zip m1 ?m2.0) !\n                    ?i =\n                    vec_plusI pl (m1 ! ?i) (?m2.0 ! ?i)\n  length (v # m1) = nc \\<and> (\\<forall>a\\<in>set (v # m1). vec nr a)\n  length m2 = nc \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  i < nc\n\ngoal (1 subgoal):\n 1. (\\<And>v2 m22. m2 = v2 # m22 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases m2, auto)"], ["proof (state)\nthis:\n  m2 = v2 # m22\n\ngoal (1 subgoal):\n 1. \\<And>a m1 m2 nc i.\n       \\<lbrakk>\\<And>m2 nc i.\n                   \\<lbrakk>length m1 = nc \\<and> Ball (set m1) (vec nr);\n                    length m2 = nc \\<and> Ball (set m2) (vec nr);\n                    i < nc\\<rbrakk>\n                   \\<Longrightarrow> map\n(\\<lambda>uv. vec_plusI pl (fst uv) (snd uv)) (zip m1 m2) !\n                                     i =\n                                     vec_plusI pl (m1 ! i) (m2 ! i);\n        length (a # m1) = nc \\<and> Ball (set (a # m1)) (vec nr);\n        length m2 = nc \\<and> Ball (set m2) (vec nr); i < nc\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>uv. vec_plusI pl (fst uv) (snd uv))\n                          (zip (a # m1) m2) !\n                         i =\n                         vec_plusI pl ((a # m1) ! i) (m2 ! i)", "from m2 Cons"], ["proof (chain)\npicking this:\n  m2 = v2 # m22\n  \\<lbrakk>length m1 = ?nc \\<and> (\\<forall>a\\<in>set m1. vec nr a);\n   length ?m2.0 = ?nc \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   ?i < ?nc\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>uv. vec_plusI pl (fst uv) (snd uv))\n                     (zip m1 ?m2.0) !\n                    ?i =\n                    vec_plusI pl (m1 ! ?i) (?m2.0 ! ?i)\n  length (v # m1) = nc \\<and> (\\<forall>a\\<in>set (v # m1). vec nr a)\n  length m2 = nc \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  i < nc", "obtain ncc where nc: \"nc = Suc ncc\""], ["proof (prove)\nusing this:\n  m2 = v2 # m22\n  \\<lbrakk>length m1 = ?nc \\<and> (\\<forall>a\\<in>set m1. vec nr a);\n   length ?m2.0 = ?nc \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   ?i < ?nc\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>uv. vec_plusI pl (fst uv) (snd uv))\n                     (zip m1 ?m2.0) !\n                    ?i =\n                    vec_plusI pl (m1 ! ?i) (?m2.0 ! ?i)\n  length (v # m1) = nc \\<and> (\\<forall>a\\<in>set (v # m1). vec nr a)\n  length m2 = nc \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  i < nc\n\ngoal (1 subgoal):\n 1. (\\<And>ncc. nc = Suc ncc \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  nc = Suc ncc\n\ngoal (1 subgoal):\n 1. \\<And>a m1 m2 nc i.\n       \\<lbrakk>\\<And>m2 nc i.\n                   \\<lbrakk>length m1 = nc \\<and> Ball (set m1) (vec nr);\n                    length m2 = nc \\<and> Ball (set m2) (vec nr);\n                    i < nc\\<rbrakk>\n                   \\<Longrightarrow> map\n(\\<lambda>uv. vec_plusI pl (fst uv) (snd uv)) (zip m1 m2) !\n                                     i =\n                                     vec_plusI pl (m1 ! i) (m2 ! i);\n        length (a # m1) = nc \\<and> Ball (set (a # m1)) (vec nr);\n        length m2 = nc \\<and> Ball (set m2) (vec nr); i < nc\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>uv. vec_plusI pl (fst uv) (snd uv))\n                          (zip (a # m1) m2) !\n                         i =\n                         vec_plusI pl ((a # m1) ! i) (m2 ! i)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>uv. vec_plusI pl (fst uv) (snd uv)) (zip (v # m1) m2) !\n    i =\n    vec_plusI pl ((v # m1) ! i) (m2 ! i)", "proof (cases i, simp add: m2)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       map (\\<lambda>uv. vec_plusI pl (fst uv) (snd uv)) (zip (v # m1) m2) !\n       i =\n       vec_plusI pl ((v # m1) ! i) (m2 ! i)", "case (Suc ii)"], ["proof (state)\nthis:\n  i = Suc ii\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       map (\\<lambda>uv. vec_plusI pl (fst uv) (snd uv)) (zip (v # m1) m2) !\n       i =\n       vec_plusI pl ((v # m1) ! i) (m2 ! i)", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>length m1 = ?nc \\<and> (\\<forall>a\\<in>set m1. vec nr a);\n   length ?m2.0 = ?nc \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   ?i < ?nc\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>uv. vec_plusI pl (fst uv) (snd uv))\n                     (zip m1 ?m2.0) !\n                    ?i =\n                    vec_plusI pl (m1 ! ?i) (?m2.0 ! ?i)\n  length (v # m1) = nc \\<and> (\\<forall>a\\<in>set (v # m1). vec nr a)\n  length m2 = nc \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  i < nc\n  i = Suc ii", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length m1 = ?nc \\<and> (\\<forall>a\\<in>set m1. vec nr a);\n   length ?m2.0 = ?nc \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   ?i < ?nc\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>uv. vec_plusI pl (fst uv) (snd uv))\n                     (zip m1 ?m2.0) !\n                    ?i =\n                    vec_plusI pl (m1 ! ?i) (?m2.0 ! ?i)\n  length (v # m1) = nc \\<and> (\\<forall>a\\<in>set (v # m1). vec nr a)\n  length m2 = nc \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  i < nc\n  i = Suc ii\n\ngoal (1 subgoal):\n 1. map (\\<lambda>uv. vec_plusI pl (fst uv) (snd uv)) (zip (v # m1) m2) !\n    i =\n    vec_plusI pl ((v # m1) ! i) (m2 ! i)", "using m2 nc"], ["proof (prove)\nusing this:\n  \\<lbrakk>length m1 = ?nc \\<and> (\\<forall>a\\<in>set m1. vec nr a);\n   length ?m2.0 = ?nc \\<and> (\\<forall>a\\<in>set ?m2.0. vec nr a);\n   ?i < ?nc\\<rbrakk>\n  \\<Longrightarrow> map (\\<lambda>uv. vec_plusI pl (fst uv) (snd uv))\n                     (zip m1 ?m2.0) !\n                    ?i =\n                    vec_plusI pl (m1 ! ?i) (?m2.0 ! ?i)\n  length (v # m1) = nc \\<and> (\\<forall>a\\<in>set (v # m1). vec nr a)\n  length m2 = nc \\<and> (\\<forall>a\\<in>set m2. vec nr a)\n  i < nc\n  i = Suc ii\n  m2 = v2 # m22\n  nc = Suc ncc\n\ngoal (1 subgoal):\n 1. map (\\<lambda>uv. vec_plusI pl (fst uv) (snd uv)) (zip (v # m1) m2) !\n    i =\n    vec_plusI pl ((v # m1) ! i) (m2 ! i)", "by auto"], ["proof (state)\nthis:\n  map (\\<lambda>uv. vec_plusI pl (fst uv) (snd uv)) (zip (v # m1) m2) ! i =\n  vec_plusI pl ((v # m1) ! i) (m2 ! i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (\\<lambda>uv. vec_plusI pl (fst uv) (snd uv)) (zip (v # m1) m2) ! i =\n  vec_plusI pl ((v # m1) ! i) (m2 ! i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma transpose_index[simp]: assumes wf: \"mat nr nc m\"\n  and i: \"i < nr\"\n  and j: \"j < nc\"\n  shows \"transpose nr m ! i ! j = m ! j ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix_Legacy.transpose nr m ! i ! j = m ! j ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Matrix_Legacy.transpose nr m ! i ! j = m ! j ! i", "have \"transpose nr m ! i ! j = col (transpose nr m) i ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix_Legacy.transpose nr m ! i ! j =\n    col (Matrix_Legacy.transpose nr m) i ! j", "unfolding col_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix_Legacy.transpose nr m ! i ! j =\n    Matrix_Legacy.transpose nr m ! i ! j", "by simp"], ["proof (state)\nthis:\n  Matrix_Legacy.transpose nr m ! i ! j =\n  col (Matrix_Legacy.transpose nr m) i ! j\n\ngoal (1 subgoal):\n 1. Matrix_Legacy.transpose nr m ! i ! j = m ! j ! i", "also"], ["proof (state)\nthis:\n  Matrix_Legacy.transpose nr m ! i ! j =\n  col (Matrix_Legacy.transpose nr m) i ! j\n\ngoal (1 subgoal):\n 1. Matrix_Legacy.transpose nr m ! i ! j = m ! j ! i", "have \"\\<dots> = row m i ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (Matrix_Legacy.transpose nr m) i ! j = row m i ! j", "using col_transpose_is_row[OF wf i]"], ["proof (prove)\nusing this:\n  col (Matrix_Legacy.transpose nr m) i = row m i\n\ngoal (1 subgoal):\n 1. col (Matrix_Legacy.transpose nr m) i ! j = row m i ! j", "by simp"], ["proof (state)\nthis:\n  col (Matrix_Legacy.transpose nr m) i ! j = row m i ! j\n\ngoal (1 subgoal):\n 1. Matrix_Legacy.transpose nr m ! i ! j = m ! j ! i", "also"], ["proof (state)\nthis:\n  col (Matrix_Legacy.transpose nr m) i ! j = row m i ! j\n\ngoal (1 subgoal):\n 1. Matrix_Legacy.transpose nr m ! i ! j = m ! j ! i", "have \"\\<dots> = m ! j ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row m i ! j = m ! j ! i", "unfolding row_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>w. w ! i) m ! j = m ! j ! i", "using wf j"], ["proof (prove)\nusing this:\n  mat nr nc m\n  j < nc\n\ngoal (1 subgoal):\n 1. map (\\<lambda>w. w ! i) m ! j = m ! j ! i", "unfolding mat_def"], ["proof (prove)\nusing this:\n  length m = nc \\<and> Ball (set m) (vec nr)\n  j < nc\n\ngoal (1 subgoal):\n 1. map (\\<lambda>w. w ! i) m ! j = m ! j ! i", "by (auto simp: vec_def)"], ["proof (state)\nthis:\n  row m i ! j = m ! j ! i\n\ngoal (1 subgoal):\n 1. Matrix_Legacy.transpose nr m ! i ! j = m ! j ! i", "finally"], ["proof (chain)\npicking this:\n  Matrix_Legacy.transpose nr m ! i ! j = m ! j ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  Matrix_Legacy.transpose nr m ! i ! j = m ! j ! i\n\ngoal (1 subgoal):\n 1. Matrix_Legacy.transpose nr m ! i ! j = m ! j ! i", "."], ["proof (state)\nthis:\n  Matrix_Legacy.transpose nr m ! i ! j = m ! j ! i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma transpose_mat_plus: assumes wf: \"mat nr nc m1\" \"mat nr nc m2\"\n  shows \"transpose nr (mat_plusI pl m1 m2) = mat_plusI pl (transpose nr m1) (transpose nr m2)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix_Legacy.transpose nr (mat_plusI pl m1 m2) =\n    mat_plusI pl (Matrix_Legacy.transpose nr m1)\n     (Matrix_Legacy.transpose nr m2)", "proof (rule mat_eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. mat ?nr ?nc (Matrix_Legacy.transpose nr (mat_plusI pl m1 m2))\n 2. mat ?nr ?nc\n     (mat_plusI pl (Matrix_Legacy.transpose nr m1)\n       (Matrix_Legacy.transpose nr m2))\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> Matrix_Legacy.transpose nr (mat_plusI pl m1 m2) !\n                         i !\n                         j =\n                         mat_plusI pl (Matrix_Legacy.transpose nr m1)\n                          (Matrix_Legacy.transpose nr m2) !\n                         i !\n                         j", "fix i j"], ["proof (state)\ngoal (3 subgoals):\n 1. mat ?nr ?nc (Matrix_Legacy.transpose nr (mat_plusI pl m1 m2))\n 2. mat ?nr ?nc\n     (mat_plusI pl (Matrix_Legacy.transpose nr m1)\n       (Matrix_Legacy.transpose nr m2))\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> Matrix_Legacy.transpose nr (mat_plusI pl m1 m2) !\n                         i !\n                         j =\n                         mat_plusI pl (Matrix_Legacy.transpose nr m1)\n                          (Matrix_Legacy.transpose nr m2) !\n                         i !\n                         j", "assume i: \"i < nr\" and j: \"j < nc\""], ["proof (state)\nthis:\n  i < nr\n  j < nc\n\ngoal (3 subgoals):\n 1. mat ?nr ?nc (Matrix_Legacy.transpose nr (mat_plusI pl m1 m2))\n 2. mat ?nr ?nc\n     (mat_plusI pl (Matrix_Legacy.transpose nr m1)\n       (Matrix_Legacy.transpose nr m2))\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> Matrix_Legacy.transpose nr (mat_plusI pl m1 m2) !\n                         i !\n                         j =\n                         mat_plusI pl (Matrix_Legacy.transpose nr m1)\n                          (Matrix_Legacy.transpose nr m2) !\n                         i !\n                         j", "note [simp] = transpose_index[OF _ this] mat_plus_index[OF _ _ j i] mat_plus_index[OF _ _ this]"], ["proof (state)\nthis:\n  mat nr nc ?m \\<Longrightarrow>\n  Matrix_Legacy.transpose nr ?m ! i ! j = ?m ! j ! i\n  \\<lbrakk>mat nr nc ?m1.0; mat nr nc ?m2.0\\<rbrakk>\n  \\<Longrightarrow> mat_plusI ?pl ?m1.0 ?m2.0 ! j ! i =\n                    ?pl (?m1.0 ! j ! i) (?m2.0 ! j ! i)\n  \\<lbrakk>mat nc nr ?m1.0; mat nc nr ?m2.0\\<rbrakk>\n  \\<Longrightarrow> mat_plusI ?pl ?m1.0 ?m2.0 ! i ! j =\n                    ?pl (?m1.0 ! i ! j) (?m2.0 ! i ! j)\n\ngoal (3 subgoals):\n 1. mat ?nr ?nc (Matrix_Legacy.transpose nr (mat_plusI pl m1 m2))\n 2. mat ?nr ?nc\n     (mat_plusI pl (Matrix_Legacy.transpose nr m1)\n       (Matrix_Legacy.transpose nr m2))\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> Matrix_Legacy.transpose nr (mat_plusI pl m1 m2) !\n                         i !\n                         j =\n                         mat_plusI pl (Matrix_Legacy.transpose nr m1)\n                          (Matrix_Legacy.transpose nr m2) !\n                         i !\n                         j", "show \"?l ! i ! j = ?r ! i ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix_Legacy.transpose nr (mat_plusI pl m1 m2) ! i ! j =\n    mat_plusI pl (Matrix_Legacy.transpose nr m1)\n     (Matrix_Legacy.transpose nr m2) !\n    i !\n    j", "using wf"], ["proof (prove)\nusing this:\n  mat nr nc m1\n  mat nr nc m2\n\ngoal (1 subgoal):\n 1. Matrix_Legacy.transpose nr (mat_plusI pl m1 m2) ! i ! j =\n    mat_plusI pl (Matrix_Legacy.transpose nr m1)\n     (Matrix_Legacy.transpose nr m2) !\n    i !\n    j", "by simp"], ["proof (state)\nthis:\n  Matrix_Legacy.transpose nr (mat_plusI pl m1 m2) ! i ! j =\n  mat_plusI pl (Matrix_Legacy.transpose nr m1)\n   (Matrix_Legacy.transpose nr m2) !\n  i !\n  j\n\ngoal (2 subgoals):\n 1. mat nc nr (Matrix_Legacy.transpose nr (mat_plusI pl m1 m2))\n 2. mat nc nr\n     (mat_plusI pl (Matrix_Legacy.transpose nr m1)\n       (Matrix_Legacy.transpose nr m2))", "qed (auto intro: wf)"], ["", "lemma row_mat_plus: assumes wf1: \"mat nr nc m1\"\n  and wf2: \"mat nr nc m2\"\n  and i: \"i < nr\"\n  shows \"row (mat_plusI pl m1 m2) i = vec_plusI pl (row m1 i) (row m2 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat_plusI pl m1 m2) i = vec_plusI pl (row m1 i) (row m2 i)", "by (\n    simp only: col_transpose_is_row[OF mat_plus[OF wf1 wf2] i, symmetric],\n    simp only: transpose_mat_plus[OF wf1 wf2],\n    simp only: col_mat_plus[OF transpose[OF wf1] transpose[OF wf2] i],\n    simp only: col_transpose_is_row[OF wf1 i],\n    simp only: col_transpose_is_row[OF wf2 i])"], ["", "lemma col_mat1: assumes \"i < nr\"\n  shows \"col (mat1I ze on nr) i = vec1I ze on nr i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. col (mat1I ze on nr) i = vec1I ze on nr i", "unfolding mat1I_def col_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (vec1I ze on nr) [0..<nr] ! i = vec1I ze on nr i", "using assms"], ["proof (prove)\nusing this:\n  i < nr\n\ngoal (1 subgoal):\n 1. map (vec1I ze on nr) [0..<nr] ! i = vec1I ze on nr i", "by auto"], ["", "lemma mat1_index: assumes i: \"i < n\" and j: \"j < n\"\n  shows \"mat1I ze on n ! i ! j = (if i = j then on else ze)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat1I ze on n ! i ! j = (if i = j then on else ze)", "by (simp add: col_mat1[OF i, simplified col_def] vec1_index[OF j])"], ["", "lemma transpose_mat1: \"transpose nr (mat1I ze on nr) = (mat1I ze on nr)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix_Legacy.transpose nr (mat1I ze on nr) = mat1I ze on nr", "proof (rule mat_eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. mat ?nr ?nc (Matrix_Legacy.transpose nr (mat1I ze on nr))\n 2. mat ?nr ?nc (mat1I ze on nr)\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> Matrix_Legacy.transpose nr (mat1I ze on nr) ! i !\n                         j =\n                         mat1I ze on nr ! i ! j", "fix i j"], ["proof (state)\ngoal (3 subgoals):\n 1. mat ?nr ?nc (Matrix_Legacy.transpose nr (mat1I ze on nr))\n 2. mat ?nr ?nc (mat1I ze on nr)\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> Matrix_Legacy.transpose nr (mat1I ze on nr) ! i !\n                         j =\n                         mat1I ze on nr ! i ! j", "assume i:\"i < nr\" and j: \"j < nr\""], ["proof (state)\nthis:\n  i < nr\n  j < nr\n\ngoal (3 subgoals):\n 1. mat ?nr ?nc (Matrix_Legacy.transpose nr (mat1I ze on nr))\n 2. mat ?nr ?nc (mat1I ze on nr)\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> Matrix_Legacy.transpose nr (mat1I ze on nr) ! i !\n                         j =\n                         mat1I ze on nr ! i ! j", "note [simp] = transpose_index[OF _ this] mat1_index[OF this] mat1_index[OF j i]"], ["proof (state)\nthis:\n  mat nr nr ?m \\<Longrightarrow>\n  Matrix_Legacy.transpose nr ?m ! i ! j = ?m ! j ! i\n  mat1I ?ze ?on nr ! i ! j = (if i = j then ?on else ?ze)\n  mat1I ?ze ?on nr ! j ! i = (if j = i then ?on else ?ze)\n\ngoal (3 subgoals):\n 1. mat ?nr ?nc (Matrix_Legacy.transpose nr (mat1I ze on nr))\n 2. mat ?nr ?nc (mat1I ze on nr)\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> Matrix_Legacy.transpose nr (mat1I ze on nr) ! i !\n                         j =\n                         mat1I ze on nr ! i ! j", "show \"?l ! i ! j = ?r ! i ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Matrix_Legacy.transpose nr (mat1I ze on nr) ! i ! j =\n    mat1I ze on nr ! i ! j", "by auto"], ["proof (state)\nthis:\n  Matrix_Legacy.transpose nr (mat1I ze on nr) ! i ! j =\n  mat1I ze on nr ! i ! j\n\ngoal (2 subgoals):\n 1. mat nr nr (Matrix_Legacy.transpose nr (mat1I ze on nr))\n 2. mat nr nr (mat1I ze on nr)", "qed auto"], ["", "lemma row_mat1: assumes i: \"i < nr\"\n  shows \"row (mat1I ze on nr) i = vec1I ze on nr i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. row (mat1I ze on nr) i = vec1I ze on nr i", "by (simp only: col_transpose_is_row[OF mat1 i, symmetric],\n  simp only: transpose_mat1,\n  simp only: col_mat1[OF i])"], ["", "lemma sub_mat_index:\n  assumes wf: \"mat nr nc m\"\n  and sr: \"sr \\<le> nr\"\n  and sc: \"sc \\<le> nc\"\n  and j: \"j < sr\"\n  and i: \"i < sc\"\n  shows \"sub_mat sr sc m ! i ! j = m ! i ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sub_mat sr sc m ! i ! j = m ! i ! j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sub_mat sr sc m ! i ! j = m ! i ! j", "from assms"], ["proof (chain)\npicking this:\n  mat nr nc m\n  sr \\<le> nr\n  sc \\<le> nc\n  j < sr\n  i < sc", "have im: \"i < length m\""], ["proof (prove)\nusing this:\n  mat nr nc m\n  sr \\<le> nr\n  sc \\<le> nc\n  j < sr\n  i < sc\n\ngoal (1 subgoal):\n 1. i < length m", "unfolding mat_def"], ["proof (prove)\nusing this:\n  length m = nc \\<and> Ball (set m) (vec nr)\n  sr \\<le> nr\n  sc \\<le> nc\n  j < sr\n  i < sc\n\ngoal (1 subgoal):\n 1. i < length m", "by auto"], ["proof (state)\nthis:\n  i < length m\n\ngoal (1 subgoal):\n 1. sub_mat sr sc m ! i ! j = m ! i ! j", "from assms"], ["proof (chain)\npicking this:\n  mat nr nc m\n  sr \\<le> nr\n  sc \\<le> nc\n  j < sr\n  i < sc", "have jm: \"j < length (m ! i)\""], ["proof (prove)\nusing this:\n  mat nr nc m\n  sr \\<le> nr\n  sc \\<le> nc\n  j < sr\n  i < sc\n\ngoal (1 subgoal):\n 1. j < length (m ! i)", "unfolding mat_def"], ["proof (prove)\nusing this:\n  length m = nc \\<and> Ball (set m) (vec nr)\n  sr \\<le> nr\n  sc \\<le> nc\n  j < sr\n  i < sc\n\ngoal (1 subgoal):\n 1. j < length (m ! i)", "by (auto simp: vec_def)"], ["proof (state)\nthis:\n  j < length (m ! i)\n\ngoal (1 subgoal):\n 1. sub_mat sr sc m ! i ! j = m ! i ! j", "have \"sub_mat sr sc m ! i ! j = map (take sr) (take sc m) ! i ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sub_mat sr sc m ! i ! j = map (take sr) (take sc m) ! i ! j", "unfolding sub_mat_def sub_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (take sr) (take sc m) ! i ! j = map (take sr) (take sc m) ! i ! j", "by auto"], ["proof (state)\nthis:\n  sub_mat sr sc m ! i ! j = map (take sr) (take sc m) ! i ! j\n\ngoal (1 subgoal):\n 1. sub_mat sr sc m ! i ! j = m ! i ! j", "also"], ["proof (state)\nthis:\n  sub_mat sr sc m ! i ! j = map (take sr) (take sc m) ! i ! j\n\ngoal (1 subgoal):\n 1. sub_mat sr sc m ! i ! j = m ! i ! j", "have \"\\<dots> = take sr (m ! i) ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (take sr) (take sc m) ! i ! j = take sr (m ! i) ! j", "using i im"], ["proof (prove)\nusing this:\n  i < sc\n  i < length m\n\ngoal (1 subgoal):\n 1. map (take sr) (take sc m) ! i ! j = take sr (m ! i) ! j", "by auto"], ["proof (state)\nthis:\n  map (take sr) (take sc m) ! i ! j = take sr (m ! i) ! j\n\ngoal (1 subgoal):\n 1. sub_mat sr sc m ! i ! j = m ! i ! j", "also"], ["proof (state)\nthis:\n  map (take sr) (take sc m) ! i ! j = take sr (m ! i) ! j\n\ngoal (1 subgoal):\n 1. sub_mat sr sc m ! i ! j = m ! i ! j", "have \"\\<dots> = m ! i ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. take sr (m ! i) ! j = m ! i ! j", "using j jm"], ["proof (prove)\nusing this:\n  j < sr\n  j < length (m ! i)\n\ngoal (1 subgoal):\n 1. take sr (m ! i) ! j = m ! i ! j", "by auto"], ["proof (state)\nthis:\n  take sr (m ! i) ! j = m ! i ! j\n\ngoal (1 subgoal):\n 1. sub_mat sr sc m ! i ! j = m ! i ! j", "finally"], ["proof (chain)\npicking this:\n  sub_mat sr sc m ! i ! j = m ! i ! j", "show ?thesis"], ["proof (prove)\nusing this:\n  sub_mat sr sc m ! i ! j = m ! i ! j\n\ngoal (1 subgoal):\n 1. sub_mat sr sc m ! i ! j = m ! i ! j", "."], ["proof (state)\nthis:\n  sub_mat sr sc m ! i ! j = m ! i ! j\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>lemmas requiring properties of plus, times, ...\\<close>"], ["", "context plus\nbegin"], ["", "abbreviation vec_plus :: \"'a vec \\<Rightarrow> 'a vec \\<Rightarrow> 'a vec\"\nwhere \"vec_plus \\<equiv> vec_plusI plus\""], ["", "abbreviation mat_plus :: \"'a mat \\<Rightarrow> 'a mat \\<Rightarrow> 'a mat\"\nwhere \"mat_plus \\<equiv> mat_plusI plus\""], ["", "end"], ["", "context semigroup_add\nbegin"], ["", "lemma vec_plus_assoc: assumes vec: \"vec nr u\" \"vec nr v\" \"vec nr w\"\n shows \"vec_plus u (vec_plus v w) = vec_plus (vec_plus u v) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_plus u (vec_plus v w) = vec_plus (vec_plus u v) w", "proof (rule vec_eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. vec ?n (vec_plus u (vec_plus v w))\n 2. vec ?n (vec_plus (vec_plus u v) w)\n 3. \\<And>i.\n       i < ?n \\<Longrightarrow>\n       vec_plus u (vec_plus v w) ! i = vec_plus (vec_plus u v) w ! i", "fix i"], ["proof (state)\ngoal (3 subgoals):\n 1. vec ?n (vec_plus u (vec_plus v w))\n 2. vec ?n (vec_plus (vec_plus u v) w)\n 3. \\<And>i.\n       i < ?n \\<Longrightarrow>\n       vec_plus u (vec_plus v w) ! i = vec_plus (vec_plus u v) w ! i", "assume i: \"i < nr\""], ["proof (state)\nthis:\n  i < nr\n\ngoal (3 subgoals):\n 1. vec ?n (vec_plus u (vec_plus v w))\n 2. vec ?n (vec_plus (vec_plus u v) w)\n 3. \\<And>i.\n       i < ?n \\<Longrightarrow>\n       vec_plus u (vec_plus v w) ! i = vec_plus (vec_plus u v) w ! i", "note [simp] = vec_plus_index[OF _ _ i]"], ["proof (state)\nthis:\n  \\<lbrakk>vec nr ?v1.0; vec nr ?v2.0\\<rbrakk>\n  \\<Longrightarrow> vec_plusI ?pl ?v1.0 ?v2.0 ! i =\n                    ?pl (?v1.0 ! i) (?v2.0 ! i)\n\ngoal (3 subgoals):\n 1. vec ?n (vec_plus u (vec_plus v w))\n 2. vec ?n (vec_plus (vec_plus u v) w)\n 3. \\<And>i.\n       i < ?n \\<Longrightarrow>\n       vec_plus u (vec_plus v w) ! i = vec_plus (vec_plus u v) w ! i", "from vec"], ["proof (chain)\npicking this:\n  vec nr u\n  vec nr v\n  vec nr w", "show \"vec_plus u (vec_plus v w) ! i = vec_plus (vec_plus u v) w ! i\""], ["proof (prove)\nusing this:\n  vec nr u\n  vec nr v\n  vec nr w\n\ngoal (1 subgoal):\n 1. vec_plus u (vec_plus v w) ! i = vec_plus (vec_plus u v) w ! i", "by (auto simp: add.assoc)"], ["proof (state)\nthis:\n  vec_plus u (vec_plus v w) ! i = vec_plus (vec_plus u v) w ! i\n\ngoal (2 subgoals):\n 1. vec nr (vec_plus u (vec_plus v w))\n 2. vec nr (vec_plus (vec_plus u v) w)", "qed (auto intro: vec)"], ["", "lemma mat_plus_assoc: assumes wf: \"mat nr nc m1\" \"mat nr nc m2\" \"mat nr nc m3\"\n  shows \"mat_plus m1 (mat_plus m2 m3) = mat_plus (mat_plus m1 m2) m3\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_plus m1 (mat_plus m2 m3) = mat_plus (mat_plus m1 m2) m3", "proof (rule mat_eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_plus m1 (mat_plus m2 m3))\n 2. mat ?nr ?nc (mat_plus (mat_plus m1 m2) m3)\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_plus m1 (mat_plus m2 m3) ! i ! j =\n                         mat_plus (mat_plus m1 m2) m3 ! i ! j", "fix i j"], ["proof (state)\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_plus m1 (mat_plus m2 m3))\n 2. mat ?nr ?nc (mat_plus (mat_plus m1 m2) m3)\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_plus m1 (mat_plus m2 m3) ! i ! j =\n                         mat_plus (mat_plus m1 m2) m3 ! i ! j", "assume \"i < nc\" \"j < nr\""], ["proof (state)\nthis:\n  i < nc\n  j < nr\n\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_plus m1 (mat_plus m2 m3))\n 2. mat ?nr ?nc (mat_plus (mat_plus m1 m2) m3)\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_plus m1 (mat_plus m2 m3) ! i ! j =\n                         mat_plus (mat_plus m1 m2) m3 ! i ! j", "note [simp] = mat_plus_index[OF _ _ this]"], ["proof (state)\nthis:\n  \\<lbrakk>mat nr nc ?m1.0; mat nr nc ?m2.0\\<rbrakk>\n  \\<Longrightarrow> mat_plusI ?pl ?m1.0 ?m2.0 ! i ! j =\n                    ?pl (?m1.0 ! i ! j) (?m2.0 ! i ! j)\n\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_plus m1 (mat_plus m2 m3))\n 2. mat ?nr ?nc (mat_plus (mat_plus m1 m2) m3)\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_plus m1 (mat_plus m2 m3) ! i ! j =\n                         mat_plus (mat_plus m1 m2) m3 ! i ! j", "show \"?l ! i ! j = ?r ! i ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_plus m1 (mat_plus m2 m3) ! i ! j =\n    mat_plus (mat_plus m1 m2) m3 ! i ! j", "using wf"], ["proof (prove)\nusing this:\n  mat nr nc m1\n  mat nr nc m2\n  mat nr nc m3\n\ngoal (1 subgoal):\n 1. mat_plus m1 (mat_plus m2 m3) ! i ! j =\n    mat_plus (mat_plus m1 m2) m3 ! i ! j", "by (simp add: add.assoc)"], ["proof (state)\nthis:\n  mat_plus m1 (mat_plus m2 m3) ! i ! j =\n  mat_plus (mat_plus m1 m2) m3 ! i ! j\n\ngoal (2 subgoals):\n 1. mat nr nc (mat_plus m1 (mat_plus m2 m3))\n 2. mat nr nc (mat_plus (mat_plus m1 m2) m3)", "qed (auto simp: wf)"], ["", "end"], ["", "context ab_semigroup_add\nbegin"], ["", "lemma vec_plus_comm: \"vec_plus x y = vec_plus y x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_plus x y = vec_plus y x", "unfolding vec_plusI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>xy. fst xy + snd xy) (zip x y) =\n    map (\\<lambda>xy. fst xy + snd xy) (zip y x)", "proof (induct x arbitrary: y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y.\n       map (\\<lambda>xy. fst xy + snd xy) (zip [] y) =\n       map (\\<lambda>xy. fst xy + snd xy) (zip y [])\n 2. \\<And>a x y.\n       (\\<And>y.\n           map (\\<lambda>xy. fst xy + snd xy) (zip x y) =\n           map (\\<lambda>xy. fst xy + snd xy) (zip y x)) \\<Longrightarrow>\n       map (\\<lambda>xy. fst xy + snd xy) (zip (a # x) y) =\n       map (\\<lambda>xy. fst xy + snd xy) (zip y (a # x))", "case (Cons a x)"], ["proof (state)\nthis:\n  map (\\<lambda>xy. fst xy + snd xy) (zip x ?y) =\n  map (\\<lambda>xy. fst xy + snd xy) (zip ?y x)\n\ngoal (2 subgoals):\n 1. \\<And>y.\n       map (\\<lambda>xy. fst xy + snd xy) (zip [] y) =\n       map (\\<lambda>xy. fst xy + snd xy) (zip y [])\n 2. \\<And>a x y.\n       (\\<And>y.\n           map (\\<lambda>xy. fst xy + snd xy) (zip x y) =\n           map (\\<lambda>xy. fst xy + snd xy) (zip y x)) \\<Longrightarrow>\n       map (\\<lambda>xy. fst xy + snd xy) (zip (a # x) y) =\n       map (\\<lambda>xy. fst xy + snd xy) (zip y (a # x))", "thus ?case"], ["proof (prove)\nusing this:\n  map (\\<lambda>xy. fst xy + snd xy) (zip x ?y) =\n  map (\\<lambda>xy. fst xy + snd xy) (zip ?y x)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>xy. fst xy + snd xy) (zip (a # x) y) =\n    map (\\<lambda>xy. fst xy + snd xy) (zip y (a # x))", "by (cases y, auto simp: add.commute)"], ["proof (state)\nthis:\n  map (\\<lambda>xy. fst xy + snd xy) (zip (a # x) y) =\n  map (\\<lambda>xy. fst xy + snd xy) (zip y (a # x))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       map (\\<lambda>xy. fst xy + snd xy) (zip [] y) =\n       map (\\<lambda>xy. fst xy + snd xy) (zip y [])", "qed simp"], ["", "lemma mat_plus_comm: \"mat_plus m1 m2 = mat_plus m2 m1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_plus m1 m2 = mat_plus m2 m1", "unfolding mat_plusI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m1 m2) =\n    map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m2 m1)", "proof (induct m1 arbitrary: m2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m2.\n       map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip [] m2) =\n       map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m2 [])\n 2. \\<And>a m1 m2.\n       (\\<And>m2.\n           map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m1 m2) =\n           map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n            (zip m2 m1)) \\<Longrightarrow>\n       map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip (a # m1) m2) =\n       map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m2 (a # m1))", "case (Cons v m1)"], ["proof (state)\nthis:\n  map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m1 ?m2.0) =\n  map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip ?m2.0 m1)\n\ngoal (2 subgoals):\n 1. \\<And>m2.\n       map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip [] m2) =\n       map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m2 [])\n 2. \\<And>a m1 m2.\n       (\\<And>m2.\n           map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m1 m2) =\n           map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n            (zip m2 m1)) \\<Longrightarrow>\n       map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip (a # m1) m2) =\n       map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m2 (a # m1))", "note oCons = this"], ["proof (state)\nthis:\n  map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m1 ?m2.0) =\n  map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip ?m2.0 m1)\n\ngoal (2 subgoals):\n 1. \\<And>m2.\n       map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip [] m2) =\n       map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m2 [])\n 2. \\<And>a m1 m2.\n       (\\<And>m2.\n           map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m1 m2) =\n           map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n            (zip m2 m1)) \\<Longrightarrow>\n       map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip (a # m1) m2) =\n       map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m2 (a # m1))", "thus ?case"], ["proof (prove)\nusing this:\n  map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m1 ?m2.0) =\n  map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip ?m2.0 m1)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip (v # m1) m2) =\n    map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m2 (v # m1))", "proof (cases m2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>m2.\n                map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m1 m2) =\n                map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m2 m1);\n     m2 = []\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                       (zip (v # m1) m2) =\n                      map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                       (zip m2 (v # m1))\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>m2.\n                   map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                    (zip m1 m2) =\n                   map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                    (zip m2 m1);\n        m2 = a # list\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                          (zip (v # m1) m2) =\n                         map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                          (zip m2 (v # m1))", "case (Cons w m2a)"], ["proof (state)\nthis:\n  m2 = w # m2a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>m2.\n                map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m1 m2) =\n                map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m2 m1);\n     m2 = []\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                       (zip (v # m1) m2) =\n                      map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                       (zip m2 (v # m1))\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>m2.\n                   map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                    (zip m1 m2) =\n                   map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                    (zip m2 m1);\n        m2 = a # list\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                          (zip (v # m1) m2) =\n                         map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                          (zip m2 (v # m1))", "hence \"mat_plus (v # m1) m2 = vec_plus v w # mat_plus m1 m2a\""], ["proof (prove)\nusing this:\n  m2 = w # m2a\n\ngoal (1 subgoal):\n 1. mat_plus (v # m1) m2 = vec_plus v w # mat_plus m1 m2a", "by (auto simp: mat_plusI_def)"], ["proof (state)\nthis:\n  mat_plus (v # m1) m2 = vec_plus v w # mat_plus m1 m2a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>m2.\n                map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m1 m2) =\n                map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m2 m1);\n     m2 = []\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                       (zip (v # m1) m2) =\n                      map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                       (zip m2 (v # m1))\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>m2.\n                   map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                    (zip m1 m2) =\n                   map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                    (zip m2 m1);\n        m2 = a # list\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                          (zip (v # m1) m2) =\n                         map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                          (zip m2 (v # m1))", "also"], ["proof (state)\nthis:\n  mat_plus (v # m1) m2 = vec_plus v w # mat_plus m1 m2a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>m2.\n                map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m1 m2) =\n                map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m2 m1);\n     m2 = []\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                       (zip (v # m1) m2) =\n                      map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                       (zip m2 (v # m1))\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>m2.\n                   map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                    (zip m1 m2) =\n                   map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                    (zip m2 m1);\n        m2 = a # list\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                          (zip (v # m1) m2) =\n                         map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                          (zip m2 (v # m1))", "have \"\\<dots> = vec_plus w v # mat_plus m1 m2a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_plus v w # mat_plus m1 m2a = vec_plus w v # mat_plus m1 m2a", "using vec_plus_comm"], ["proof (prove)\nusing this:\n  vec_plus ?x ?y = vec_plus ?y ?x\n\ngoal (1 subgoal):\n 1. vec_plus v w # mat_plus m1 m2a = vec_plus w v # mat_plus m1 m2a", "by auto"], ["proof (state)\nthis:\n  vec_plus v w # mat_plus m1 m2a = vec_plus w v # mat_plus m1 m2a\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>m2.\n                map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m1 m2) =\n                map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m2 m1);\n     m2 = []\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                       (zip (v # m1) m2) =\n                      map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                       (zip m2 (v # m1))\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>m2.\n                   map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                    (zip m1 m2) =\n                   map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                    (zip m2 m1);\n        m2 = a # list\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                          (zip (v # m1) m2) =\n                         map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                          (zip m2 (v # m1))", "finally"], ["proof (chain)\npicking this:\n  mat_plus (v # m1) m2 = vec_plus w v # mat_plus m1 m2a", "show ?thesis"], ["proof (prove)\nusing this:\n  mat_plus (v # m1) m2 = vec_plus w v # mat_plus m1 m2a\n\ngoal (1 subgoal):\n 1. map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip (v # m1) m2) =\n    map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m2 (v # m1))", "using Cons oCons"], ["proof (prove)\nusing this:\n  mat_plus (v # m1) m2 = vec_plus w v # mat_plus m1 m2a\n  m2 = w # m2a\n  map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m1 ?m2.0) =\n  map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip ?m2.0 m1)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip (v # m1) m2) =\n    map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m2 (v # m1))", "by (auto simp: mat_plusI_def)"], ["proof (state)\nthis:\n  map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip (v # m1) m2) =\n  map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m2 (v # m1))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>m2.\n                map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m1 m2) =\n                map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m2 m1);\n     m2 = []\\<rbrakk>\n    \\<Longrightarrow> map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                       (zip (v # m1) m2) =\n                      map (\\<lambda>uv. vec_plus (fst uv) (snd uv))\n                       (zip m2 (v # m1))", "qed simp"], ["proof (state)\nthis:\n  map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip (v # m1) m2) =\n  map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m2 (v # m1))\n\ngoal (1 subgoal):\n 1. \\<And>m2.\n       map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip [] m2) =\n       map (\\<lambda>uv. vec_plus (fst uv) (snd uv)) (zip m2 [])", "qed simp"], ["", "end"], ["", "context zero\nbegin"], ["", "abbreviation vec0 :: \"nat \\<Rightarrow> 'a vec\"\nwhere \"vec0 \\<equiv> vec0I zero\""], ["", "abbreviation mat0 :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'a mat\"\nwhere \"mat0 \\<equiv> mat0I zero\""], ["", "end"], ["", "context monoid_add\nbegin"], ["", "lemma vec0_plus[simp]: assumes \"vec nr u\" shows \"vec_plus (vec0 nr) u = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_plus (vec0 nr) u = u", "using assms"], ["proof (prove)\nusing this:\n  vec nr u\n\ngoal (1 subgoal):\n 1. vec_plus (vec0 nr) u = u", "unfolding vec_def vec_plusI_def vec0I_def"], ["proof (prove)\nusing this:\n  length u = nr\n\ngoal (1 subgoal):\n 1. map (\\<lambda>xy. fst xy + snd xy) (zip (replicate nr (0::'a)) u) = u", "proof (induct nr arbitrary: u)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u.\n       length u = 0 \\<Longrightarrow>\n       map (\\<lambda>xy. fst xy + snd xy) (zip (replicate 0 (0::'a)) u) = u\n 2. \\<And>nr u.\n       \\<lbrakk>\\<And>u.\n                   length u = nr \\<Longrightarrow>\n                   map (\\<lambda>xy. fst xy + snd xy)\n                    (zip (replicate nr (0::'a)) u) =\n                   u;\n        length u = Suc nr\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>xy. fst xy + snd xy)\n                          (zip (replicate (Suc nr) (0::'a)) u) =\n                         u", "case (Suc nn)"], ["proof (state)\nthis:\n  length ?u = nn \\<Longrightarrow>\n  map (\\<lambda>xy. fst xy + snd xy) (zip (replicate nn (0::'a)) ?u) = ?u\n  length u = Suc nn\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       length u = 0 \\<Longrightarrow>\n       map (\\<lambda>xy. fst xy + snd xy) (zip (replicate 0 (0::'a)) u) = u\n 2. \\<And>nr u.\n       \\<lbrakk>\\<And>u.\n                   length u = nr \\<Longrightarrow>\n                   map (\\<lambda>xy. fst xy + snd xy)\n                    (zip (replicate nr (0::'a)) u) =\n                   u;\n        length u = Suc nr\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>xy. fst xy + snd xy)\n                          (zip (replicate (Suc nr) (0::'a)) u) =\n                         u", "thus ?case"], ["proof (prove)\nusing this:\n  length ?u = nn \\<Longrightarrow>\n  map (\\<lambda>xy. fst xy + snd xy) (zip (replicate nn (0::'a)) ?u) = ?u\n  length u = Suc nn\n\ngoal (1 subgoal):\n 1. map (\\<lambda>xy. fst xy + snd xy)\n     (zip (replicate (Suc nn) (0::'a)) u) =\n    u", "by (cases u, auto)"], ["proof (state)\nthis:\n  map (\\<lambda>xy. fst xy + snd xy) (zip (replicate (Suc nn) (0::'a)) u) =\n  u\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       length u = 0 \\<Longrightarrow>\n       map (\\<lambda>xy. fst xy + snd xy) (zip (replicate 0 (0::'a)) u) = u", "qed simp"], ["", "lemma plus_vec0[simp]: assumes \"vec nr u\" shows \"vec_plus u (vec0 nr) = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_plus u (vec0 nr) = u", "using assms"], ["proof (prove)\nusing this:\n  vec nr u\n\ngoal (1 subgoal):\n 1. vec_plus u (vec0 nr) = u", "unfolding vec_def vec_plusI_def vec0I_def"], ["proof (prove)\nusing this:\n  length u = nr\n\ngoal (1 subgoal):\n 1. map (\\<lambda>xy. fst xy + snd xy) (zip u (replicate nr (0::'a))) = u", "proof (induct nr arbitrary: u)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u.\n       length u = 0 \\<Longrightarrow>\n       map (\\<lambda>xy. fst xy + snd xy) (zip u (replicate 0 (0::'a))) = u\n 2. \\<And>nr u.\n       \\<lbrakk>\\<And>u.\n                   length u = nr \\<Longrightarrow>\n                   map (\\<lambda>xy. fst xy + snd xy)\n                    (zip u (replicate nr (0::'a))) =\n                   u;\n        length u = Suc nr\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>xy. fst xy + snd xy)\n                          (zip u (replicate (Suc nr) (0::'a))) =\n                         u", "case (Suc nn)"], ["proof (state)\nthis:\n  length ?u = nn \\<Longrightarrow>\n  map (\\<lambda>xy. fst xy + snd xy) (zip ?u (replicate nn (0::'a))) = ?u\n  length u = Suc nn\n\ngoal (2 subgoals):\n 1. \\<And>u.\n       length u = 0 \\<Longrightarrow>\n       map (\\<lambda>xy. fst xy + snd xy) (zip u (replicate 0 (0::'a))) = u\n 2. \\<And>nr u.\n       \\<lbrakk>\\<And>u.\n                   length u = nr \\<Longrightarrow>\n                   map (\\<lambda>xy. fst xy + snd xy)\n                    (zip u (replicate nr (0::'a))) =\n                   u;\n        length u = Suc nr\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>xy. fst xy + snd xy)\n                          (zip u (replicate (Suc nr) (0::'a))) =\n                         u", "thus ?case"], ["proof (prove)\nusing this:\n  length ?u = nn \\<Longrightarrow>\n  map (\\<lambda>xy. fst xy + snd xy) (zip ?u (replicate nn (0::'a))) = ?u\n  length u = Suc nn\n\ngoal (1 subgoal):\n 1. map (\\<lambda>xy. fst xy + snd xy)\n     (zip u (replicate (Suc nn) (0::'a))) =\n    u", "by (cases u, auto)"], ["proof (state)\nthis:\n  map (\\<lambda>xy. fst xy + snd xy) (zip u (replicate (Suc nn) (0::'a))) =\n  u\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       length u = 0 \\<Longrightarrow>\n       map (\\<lambda>xy. fst xy + snd xy) (zip u (replicate 0 (0::'a))) = u", "qed simp"], ["", "lemma plus_mat0[simp]: assumes wf: \"mat nr nc m\" shows \"mat_plus m (mat0 nr nc) = m\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_plus m (mat0 nr nc) = m", "proof (rule mat_eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_plus m (mat0 nr nc))\n 2. mat ?nr ?nc m\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_plus m (mat0 nr nc) ! i ! j = m ! i ! j", "fix i j"], ["proof (state)\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_plus m (mat0 nr nc))\n 2. mat ?nr ?nc m\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_plus m (mat0 nr nc) ! i ! j = m ! i ! j", "assume \"i < nc\" \"j < nr\""], ["proof (state)\nthis:\n  i < nc\n  j < nr\n\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_plus m (mat0 nr nc))\n 2. mat ?nr ?nc m\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_plus m (mat0 nr nc) ! i ! j = m ! i ! j", "note [simp] = mat_plus_index[OF _ _ this] mat0_index[OF this]"], ["proof (state)\nthis:\n  \\<lbrakk>mat nr nc ?m1.0; mat nr nc ?m2.0\\<rbrakk>\n  \\<Longrightarrow> mat_plusI ?pl ?m1.0 ?m2.0 ! i ! j =\n                    ?pl (?m1.0 ! i ! j) (?m2.0 ! i ! j)\n  mat0I ?ze nr nc ! i ! j = ?ze\n\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_plus m (mat0 nr nc))\n 2. mat ?nr ?nc m\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_plus m (mat0 nr nc) ! i ! j = m ! i ! j", "show \"?l ! i ! j = ?r ! i ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_plus m (mat0 nr nc) ! i ! j = m ! i ! j", "using wf"], ["proof (prove)\nusing this:\n  mat nr nc m\n\ngoal (1 subgoal):\n 1. mat_plus m (mat0 nr nc) ! i ! j = m ! i ! j", "by simp"], ["proof (state)\nthis:\n  mat_plus m (mat0 nr nc) ! i ! j = m ! i ! j\n\ngoal (2 subgoals):\n 1. mat nr nc (mat_plus m (mat0 nr nc))\n 2. mat nr nc m", "qed (insert wf, auto)"], ["", "lemma mat0_plus[simp]: assumes wf: \"mat nr nc m\" shows \"mat_plus (mat0 nr nc) m = m\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_plus (mat0 nr nc) m = m", "proof (rule mat_eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_plus (mat0 nr nc) m)\n 2. mat ?nr ?nc m\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_plus (mat0 nr nc) m ! i ! j = m ! i ! j", "fix i j"], ["proof (state)\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_plus (mat0 nr nc) m)\n 2. mat ?nr ?nc m\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_plus (mat0 nr nc) m ! i ! j = m ! i ! j", "assume \"i < nc\" \"j < nr\""], ["proof (state)\nthis:\n  i < nc\n  j < nr\n\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_plus (mat0 nr nc) m)\n 2. mat ?nr ?nc m\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_plus (mat0 nr nc) m ! i ! j = m ! i ! j", "note [simp] = mat_plus_index[OF _ _ this] mat0_index[OF this]"], ["proof (state)\nthis:\n  \\<lbrakk>mat nr nc ?m1.0; mat nr nc ?m2.0\\<rbrakk>\n  \\<Longrightarrow> mat_plusI ?pl ?m1.0 ?m2.0 ! i ! j =\n                    ?pl (?m1.0 ! i ! j) (?m2.0 ! i ! j)\n  mat0I ?ze nr nc ! i ! j = ?ze\n\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_plus (mat0 nr nc) m)\n 2. mat ?nr ?nc m\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_plus (mat0 nr nc) m ! i ! j = m ! i ! j", "show \"?l ! i ! j = ?r ! i ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_plus (mat0 nr nc) m ! i ! j = m ! i ! j", "using wf"], ["proof (prove)\nusing this:\n  mat nr nc m\n\ngoal (1 subgoal):\n 1. mat_plus (mat0 nr nc) m ! i ! j = m ! i ! j", "by simp"], ["proof (state)\nthis:\n  mat_plus (mat0 nr nc) m ! i ! j = m ! i ! j\n\ngoal (2 subgoals):\n 1. mat nr nc (mat_plus (mat0 nr nc) m)\n 2. mat nr nc m", "qed (insert wf, auto)"], ["", "end"], ["", "context semiring_0\nbegin"], ["", "abbreviation scalar_prod :: \"'a vec \\<Rightarrow> 'a vec \\<Rightarrow> 'a\"\nwhere \"scalar_prod \\<equiv> scalar_prodI zero plus times\""], ["", "abbreviation mat_mult :: \"nat \\<Rightarrow> 'a mat \\<Rightarrow> 'a mat \\<Rightarrow> 'a mat\"\nwhere \"mat_mult \\<equiv> mat_multI zero plus times\""], ["", "lemma scalar_prod: \"scalar_prod v1 v2 = sum_list (map (\\<lambda>(x,y). x * y) (zip v1 v2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_prod v1 v2 = sum_list (map2 (*) v1 v2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. scalar_prod v1 v2 = sum_list (map2 (*) v1 v2)", "obtain z where z: \"zip v1 v2 = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>z. zip v1 v2 = z \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  zip v1 v2 = z\n\ngoal (1 subgoal):\n 1. scalar_prod v1 v2 = sum_list (map2 (*) v1 v2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_prod v1 v2 = sum_list (map2 (*) v1 v2)", "unfolding scalar_prodI_def z"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(x, y). (+) (x * y)) z (0::'a) =\n    (\\<Sum>(x, y)\\<leftarrow>z. x * y)", "by (induct z, auto)"], ["proof (state)\nthis:\n  scalar_prod v1 v2 = sum_list (map2 (*) v1 v2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scalar_prod_last: assumes \"length v1 = length v2\"\n  shows \"scalar_prod (v1 @ [x1]) (v2 @ [x2]) = x1 * x2 + scalar_prod v1 v2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_prod (v1 @ [x1]) (v2 @ [x2]) = x1 * x2 + scalar_prod v1 v2", "using assms"], ["proof (prove)\nusing this:\n  length v1 = length v2\n\ngoal (1 subgoal):\n 1. scalar_prod (v1 @ [x1]) (v2 @ [x2]) = x1 * x2 + scalar_prod v1 v2", "proof (induct v1 arbitrary: v2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v2.\n       length [] = length v2 \\<Longrightarrow>\n       scalar_prod ([] @ [x1]) (v2 @ [x2]) = x1 * x2 + scalar_prod [] v2\n 2. \\<And>a v1 v2.\n       \\<lbrakk>\\<And>v2.\n                   length v1 = length v2 \\<Longrightarrow>\n                   scalar_prod (v1 @ [x1]) (v2 @ [x2]) =\n                   x1 * x2 + scalar_prod v1 v2;\n        length (a # v1) = length v2\\<rbrakk>\n       \\<Longrightarrow> scalar_prod ((a # v1) @ [x1]) (v2 @ [x2]) =\n                         x1 * x2 + scalar_prod (a # v1) v2", "case (Cons y1 w1)"], ["proof (state)\nthis:\n  length w1 = length ?v2.1 \\<Longrightarrow>\n  scalar_prod (w1 @ [x1]) (?v2.1 @ [x2]) = x1 * x2 + scalar_prod w1 ?v2.1\n  length (y1 # w1) = length v2\n\ngoal (2 subgoals):\n 1. \\<And>v2.\n       length [] = length v2 \\<Longrightarrow>\n       scalar_prod ([] @ [x1]) (v2 @ [x2]) = x1 * x2 + scalar_prod [] v2\n 2. \\<And>a v1 v2.\n       \\<lbrakk>\\<And>v2.\n                   length v1 = length v2 \\<Longrightarrow>\n                   scalar_prod (v1 @ [x1]) (v2 @ [x2]) =\n                   x1 * x2 + scalar_prod v1 v2;\n        length (a # v1) = length v2\\<rbrakk>\n       \\<Longrightarrow> scalar_prod ((a # v1) @ [x1]) (v2 @ [x2]) =\n                         x1 * x2 + scalar_prod (a # v1) v2", "from Cons(2)"], ["proof (chain)\npicking this:\n  length (y1 # w1) = length v2", "obtain y2 w2 where v2: \"v2 = Cons y2 w2\" and len: \"length w1 = length w2\""], ["proof (prove)\nusing this:\n  length (y1 # w1) = length v2\n\ngoal (1 subgoal):\n 1. (\\<And>y2 w2.\n        \\<lbrakk>v2 = y2 # w2; length w1 = length w2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases v2, auto)"], ["proof (state)\nthis:\n  v2 = y2 # w2\n  length w1 = length w2\n\ngoal (2 subgoals):\n 1. \\<And>v2.\n       length [] = length v2 \\<Longrightarrow>\n       scalar_prod ([] @ [x1]) (v2 @ [x2]) = x1 * x2 + scalar_prod [] v2\n 2. \\<And>a v1 v2.\n       \\<lbrakk>\\<And>v2.\n                   length v1 = length v2 \\<Longrightarrow>\n                   scalar_prod (v1 @ [x1]) (v2 @ [x2]) =\n                   x1 * x2 + scalar_prod v1 v2;\n        length (a # v1) = length v2\\<rbrakk>\n       \\<Longrightarrow> scalar_prod ((a # v1) @ [x1]) (v2 @ [x2]) =\n                         x1 * x2 + scalar_prod (a # v1) v2", "from Cons(1)[OF len]"], ["proof (chain)\npicking this:\n  scalar_prod (w1 @ [x1]) (w2 @ [x2]) = x1 * x2 + scalar_prod w1 w2", "have rec: \"scalar_prod (w1 @ [x1]) (w2 @ [x2]) = x1 * x2 + scalar_prod w1 w2\""], ["proof (prove)\nusing this:\n  scalar_prod (w1 @ [x1]) (w2 @ [x2]) = x1 * x2 + scalar_prod w1 w2\n\ngoal (1 subgoal):\n 1. scalar_prod (w1 @ [x1]) (w2 @ [x2]) = x1 * x2 + scalar_prod w1 w2", "."], ["proof (state)\nthis:\n  scalar_prod (w1 @ [x1]) (w2 @ [x2]) = x1 * x2 + scalar_prod w1 w2\n\ngoal (2 subgoals):\n 1. \\<And>v2.\n       length [] = length v2 \\<Longrightarrow>\n       scalar_prod ([] @ [x1]) (v2 @ [x2]) = x1 * x2 + scalar_prod [] v2\n 2. \\<And>a v1 v2.\n       \\<lbrakk>\\<And>v2.\n                   length v1 = length v2 \\<Longrightarrow>\n                   scalar_prod (v1 @ [x1]) (v2 @ [x2]) =\n                   x1 * x2 + scalar_prod v1 v2;\n        length (a # v1) = length v2\\<rbrakk>\n       \\<Longrightarrow> scalar_prod ((a # v1) @ [x1]) (v2 @ [x2]) =\n                         x1 * x2 + scalar_prod (a # v1) v2", "have \"scalar_prod ((y1 # w1) @ [x1]) (v2 @ [x2]) =\n    (y1 * y2 + x1 * x2) + scalar_prod w1 w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_prod ((y1 # w1) @ [x1]) (v2 @ [x2]) =\n    y1 * y2 + x1 * x2 + scalar_prod w1 w2", "by (simp add: scalar_prod_cons v2 rec add.assoc)"], ["proof (state)\nthis:\n  scalar_prod ((y1 # w1) @ [x1]) (v2 @ [x2]) =\n  y1 * y2 + x1 * x2 + scalar_prod w1 w2\n\ngoal (2 subgoals):\n 1. \\<And>v2.\n       length [] = length v2 \\<Longrightarrow>\n       scalar_prod ([] @ [x1]) (v2 @ [x2]) = x1 * x2 + scalar_prod [] v2\n 2. \\<And>a v1 v2.\n       \\<lbrakk>\\<And>v2.\n                   length v1 = length v2 \\<Longrightarrow>\n                   scalar_prod (v1 @ [x1]) (v2 @ [x2]) =\n                   x1 * x2 + scalar_prod v1 v2;\n        length (a # v1) = length v2\\<rbrakk>\n       \\<Longrightarrow> scalar_prod ((a # v1) @ [x1]) (v2 @ [x2]) =\n                         x1 * x2 + scalar_prod (a # v1) v2", "also"], ["proof (state)\nthis:\n  scalar_prod ((y1 # w1) @ [x1]) (v2 @ [x2]) =\n  y1 * y2 + x1 * x2 + scalar_prod w1 w2\n\ngoal (2 subgoals):\n 1. \\<And>v2.\n       length [] = length v2 \\<Longrightarrow>\n       scalar_prod ([] @ [x1]) (v2 @ [x2]) = x1 * x2 + scalar_prod [] v2\n 2. \\<And>a v1 v2.\n       \\<lbrakk>\\<And>v2.\n                   length v1 = length v2 \\<Longrightarrow>\n                   scalar_prod (v1 @ [x1]) (v2 @ [x2]) =\n                   x1 * x2 + scalar_prod v1 v2;\n        length (a # v1) = length v2\\<rbrakk>\n       \\<Longrightarrow> scalar_prod ((a # v1) @ [x1]) (v2 @ [x2]) =\n                         x1 * x2 + scalar_prod (a # v1) v2", "have \"\\<dots> = (x1 * x2 + y1 * y2) + scalar_prod w1 w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y1 * y2 + x1 * x2 + scalar_prod w1 w2 =\n    x1 * x2 + y1 * y2 + scalar_prod w1 w2", "using add.commute[of \"x1 * x2\"]"], ["proof (prove)\nusing this:\n  x1 * x2 + ?b = ?b + x1 * x2\n\ngoal (1 subgoal):\n 1. y1 * y2 + x1 * x2 + scalar_prod w1 w2 =\n    x1 * x2 + y1 * y2 + scalar_prod w1 w2", "by simp"], ["proof (state)\nthis:\n  y1 * y2 + x1 * x2 + scalar_prod w1 w2 =\n  x1 * x2 + y1 * y2 + scalar_prod w1 w2\n\ngoal (2 subgoals):\n 1. \\<And>v2.\n       length [] = length v2 \\<Longrightarrow>\n       scalar_prod ([] @ [x1]) (v2 @ [x2]) = x1 * x2 + scalar_prod [] v2\n 2. \\<And>a v1 v2.\n       \\<lbrakk>\\<And>v2.\n                   length v1 = length v2 \\<Longrightarrow>\n                   scalar_prod (v1 @ [x1]) (v2 @ [x2]) =\n                   x1 * x2 + scalar_prod v1 v2;\n        length (a # v1) = length v2\\<rbrakk>\n       \\<Longrightarrow> scalar_prod ((a # v1) @ [x1]) (v2 @ [x2]) =\n                         x1 * x2 + scalar_prod (a # v1) v2", "also"], ["proof (state)\nthis:\n  y1 * y2 + x1 * x2 + scalar_prod w1 w2 =\n  x1 * x2 + y1 * y2 + scalar_prod w1 w2\n\ngoal (2 subgoals):\n 1. \\<And>v2.\n       length [] = length v2 \\<Longrightarrow>\n       scalar_prod ([] @ [x1]) (v2 @ [x2]) = x1 * x2 + scalar_prod [] v2\n 2. \\<And>a v1 v2.\n       \\<lbrakk>\\<And>v2.\n                   length v1 = length v2 \\<Longrightarrow>\n                   scalar_prod (v1 @ [x1]) (v2 @ [x2]) =\n                   x1 * x2 + scalar_prod v1 v2;\n        length (a # v1) = length v2\\<rbrakk>\n       \\<Longrightarrow> scalar_prod ((a # v1) @ [x1]) (v2 @ [x2]) =\n                         x1 * x2 + scalar_prod (a # v1) v2", "have \"\\<dots> = x1 * x2 + (scalar_prod (y1 # w1) v2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x1 * x2 + y1 * y2 + scalar_prod w1 w2 =\n    x1 * x2 + scalar_prod (y1 # w1) v2", "by (simp add: add.assoc scalar_prod_cons v2)"], ["proof (state)\nthis:\n  x1 * x2 + y1 * y2 + scalar_prod w1 w2 = x1 * x2 + scalar_prod (y1 # w1) v2\n\ngoal (2 subgoals):\n 1. \\<And>v2.\n       length [] = length v2 \\<Longrightarrow>\n       scalar_prod ([] @ [x1]) (v2 @ [x2]) = x1 * x2 + scalar_prod [] v2\n 2. \\<And>a v1 v2.\n       \\<lbrakk>\\<And>v2.\n                   length v1 = length v2 \\<Longrightarrow>\n                   scalar_prod (v1 @ [x1]) (v2 @ [x2]) =\n                   x1 * x2 + scalar_prod v1 v2;\n        length (a # v1) = length v2\\<rbrakk>\n       \\<Longrightarrow> scalar_prod ((a # v1) @ [x1]) (v2 @ [x2]) =\n                         x1 * x2 + scalar_prod (a # v1) v2", "finally"], ["proof (chain)\npicking this:\n  scalar_prod ((y1 # w1) @ [x1]) (v2 @ [x2]) =\n  x1 * x2 + scalar_prod (y1 # w1) v2", "show ?case"], ["proof (prove)\nusing this:\n  scalar_prod ((y1 # w1) @ [x1]) (v2 @ [x2]) =\n  x1 * x2 + scalar_prod (y1 # w1) v2\n\ngoal (1 subgoal):\n 1. scalar_prod ((y1 # w1) @ [x1]) (v2 @ [x2]) =\n    x1 * x2 + scalar_prod (y1 # w1) v2", "."], ["proof (state)\nthis:\n  scalar_prod ((y1 # w1) @ [x1]) (v2 @ [x2]) =\n  x1 * x2 + scalar_prod (y1 # w1) v2\n\ngoal (1 subgoal):\n 1. \\<And>v2.\n       length [] = length v2 \\<Longrightarrow>\n       scalar_prod ([] @ [x1]) (v2 @ [x2]) = x1 * x2 + scalar_prod [] v2", "qed (simp add: scalar_prodI_def)"], ["", "lemma scalar_product_assoc:\n  assumes wfm: \"mat nr nc m\"\n  and wfr: \"vec nr r\"\n  and wfc: \"vec nc c\"\n  shows \"scalar_prod (map (\\<lambda>k. scalar_prod r (col m k)) [0..<nc]) c = scalar_prod r (map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_prod (map (\\<lambda>k. scalar_prod r (col m k)) [0..<nc]) c =\n    scalar_prod r (map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr])", "using wfm wfc"], ["proof (prove)\nusing this:\n  mat nr nc m\n  vec nc c\n\ngoal (1 subgoal):\n 1. scalar_prod (map (\\<lambda>k. scalar_prod r (col m k)) [0..<nc]) c =\n    scalar_prod r (map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr])", "unfolding col_def"], ["proof (prove)\nusing this:\n  mat nr nc m\n  vec nc c\n\ngoal (1 subgoal):\n 1. scalar_prod (map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n    scalar_prod r (map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr])", "proof (induct m arbitrary: nc c)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nc c.\n       \\<lbrakk>mat nr nc []; vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ([] ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row [] k) c)\n                            [0..<nr])\n 2. \\<And>a m nc c.\n       \\<lbrakk>\\<And>nc c.\n                   \\<lbrakk>mat nr nc m; vec nc c\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr]);\n        mat nr nc (a # m); vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ((a # m) ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row (a # m) k) c)\n                            [0..<nr])", "case Nil"], ["proof (state)\nthis:\n  mat nr nc []\n  vec nc c\n\ngoal (2 subgoals):\n 1. \\<And>nc c.\n       \\<lbrakk>mat nr nc []; vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ([] ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row [] k) c)\n                            [0..<nr])\n 2. \\<And>a m nc c.\n       \\<lbrakk>\\<And>nc c.\n                   \\<lbrakk>mat nr nc m; vec nc c\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr]);\n        mat nr nc (a # m); vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ((a # m) ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row (a # m) k) c)\n                            [0..<nr])", "hence nc: \"nc = 0\""], ["proof (prove)\nusing this:\n  mat nr nc []\n  vec nc c\n\ngoal (1 subgoal):\n 1. nc = 0", "unfolding mat_def"], ["proof (prove)\nusing this:\n  length [] = nc \\<and> Ball (set []) (vec nr)\n  vec nc c\n\ngoal (1 subgoal):\n 1. nc = 0", "by (auto)"], ["proof (state)\nthis:\n  nc = 0\n\ngoal (2 subgoals):\n 1. \\<And>nc c.\n       \\<lbrakk>mat nr nc []; vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ([] ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row [] k) c)\n                            [0..<nr])\n 2. \\<And>a m nc c.\n       \\<lbrakk>\\<And>nc c.\n                   \\<lbrakk>mat nr nc m; vec nc c\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr]);\n        mat nr nc (a # m); vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ((a # m) ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row (a # m) k) c)\n                            [0..<nr])", "from wfr"], ["proof (chain)\npicking this:\n  vec nr r", "have nr: \"nr = length r\""], ["proof (prove)\nusing this:\n  vec nr r\n\ngoal (1 subgoal):\n 1. nr = length r", "unfolding vec_def"], ["proof (prove)\nusing this:\n  length r = nr\n\ngoal (1 subgoal):\n 1. nr = length r", "by auto"], ["proof (state)\nthis:\n  nr = length r\n\ngoal (2 subgoals):\n 1. \\<And>nc c.\n       \\<lbrakk>mat nr nc []; vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ([] ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row [] k) c)\n                            [0..<nr])\n 2. \\<And>a m nc c.\n       \\<lbrakk>\\<And>nc c.\n                   \\<lbrakk>mat nr nc m; vec nc c\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr]);\n        mat nr nc (a # m); vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ((a # m) ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row (a # m) k) c)\n                            [0..<nr])", "let ?term = \"\\<lambda> r :: 'a vec. zip r (map (\\<lambda> k. zero) [0..<length r])\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nc c.\n       \\<lbrakk>mat nr nc []; vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ([] ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row [] k) c)\n                            [0..<nr])\n 2. \\<And>a m nc c.\n       \\<lbrakk>\\<And>nc c.\n                   \\<lbrakk>mat nr nc m; vec nc c\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr]);\n        mat nr nc (a # m); vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ((a # m) ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row (a # m) k) c)\n                            [0..<nr])", "let ?fun = \"\\<lambda> (x,y). plus (times x y)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nc c.\n       \\<lbrakk>mat nr nc []; vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ([] ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row [] k) c)\n                            [0..<nr])\n 2. \\<And>a m nc c.\n       \\<lbrakk>\\<And>nc c.\n                   \\<lbrakk>mat nr nc m; vec nc c\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr]);\n        mat nr nc (a # m); vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ((a # m) ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row (a # m) k) c)\n                            [0..<nr])", "have \"foldr ?fun (?term r) zero = zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(x, y). (+) (x * y))\n     (zip r (map (\\<lambda>k. 0::'a) [0..<length r])) (0::'a) =\n    (0::'a)", "proof (induct r, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a r.\n       foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n        (zip r (map (\\<lambda>k. 0::'a) [0..<length r])) (0::'a) =\n       (0::'a) \\<Longrightarrow>\n       foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n        (zip (a # r) (map (\\<lambda>k. 0::'a) [0..<length (a # r)]))\n        (0::'a) =\n       (0::'a)", "case (Cons d r)"], ["proof (state)\nthis:\n  foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n   (zip r (map (\\<lambda>k. 0::'a) [0..<length r])) (0::'a) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a r.\n       foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n        (zip r (map (\\<lambda>k. 0::'a) [0..<length r])) (0::'a) =\n       (0::'a) \\<Longrightarrow>\n       foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n        (zip (a # r) (map (\\<lambda>k. 0::'a) [0..<length (a # r)]))\n        (0::'a) =\n       (0::'a)", "have \"foldr ?fun (?term (d # r)) zero = foldr ?fun ( (d,zero) # ?term r) zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(x, y). (+) (x * y))\n     (zip (d # r) (map (\\<lambda>k. 0::'a) [0..<length (d # r)])) (0::'a) =\n    foldr (\\<lambda>(x, y). (+) (x * y))\n     ((d, 0::'a) # zip r (map (\\<lambda>k. 0::'a) [0..<length r])) (0::'a)", "by (simp only: map_replicate_trivial, simp)"], ["proof (state)\nthis:\n  foldr (\\<lambda>(x, y). (+) (x * y))\n   (zip (d # r) (map (\\<lambda>k. 0::'a) [0..<length (d # r)])) (0::'a) =\n  foldr (\\<lambda>(x, y). (+) (x * y))\n   ((d, 0::'a) # zip r (map (\\<lambda>k. 0::'a) [0..<length r])) (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a r.\n       foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n        (zip r (map (\\<lambda>k. 0::'a) [0..<length r])) (0::'a) =\n       (0::'a) \\<Longrightarrow>\n       foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n        (zip (a # r) (map (\\<lambda>k. 0::'a) [0..<length (a # r)]))\n        (0::'a) =\n       (0::'a)", "also"], ["proof (state)\nthis:\n  foldr (\\<lambda>(x, y). (+) (x * y))\n   (zip (d # r) (map (\\<lambda>k. 0::'a) [0..<length (d # r)])) (0::'a) =\n  foldr (\\<lambda>(x, y). (+) (x * y))\n   ((d, 0::'a) # zip r (map (\\<lambda>k. 0::'a) [0..<length r])) (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a r.\n       foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n        (zip r (map (\\<lambda>k. 0::'a) [0..<length r])) (0::'a) =\n       (0::'a) \\<Longrightarrow>\n       foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n        (zip (a # r) (map (\\<lambda>k. 0::'a) [0..<length (a # r)]))\n        (0::'a) =\n       (0::'a)", "have \"\\<dots> = zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(x, y). (+) (x * y))\n     ((d, 0::'a) # zip r (map (\\<lambda>k. 0::'a) [0..<length r])) (0::'a) =\n    (0::'a)", "using Cons"], ["proof (prove)\nusing this:\n  foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n   (zip r (map (\\<lambda>k. 0::'a) [0..<length r])) (0::'a) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(x, y). (+) (x * y))\n     ((d, 0::'a) # zip r (map (\\<lambda>k. 0::'a) [0..<length r])) (0::'a) =\n    (0::'a)", "by simp"], ["proof (state)\nthis:\n  foldr (\\<lambda>(x, y). (+) (x * y))\n   ((d, 0::'a) # zip r (map (\\<lambda>k. 0::'a) [0..<length r])) (0::'a) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>a r.\n       foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n        (zip r (map (\\<lambda>k. 0::'a) [0..<length r])) (0::'a) =\n       (0::'a) \\<Longrightarrow>\n       foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n        (zip (a # r) (map (\\<lambda>k. 0::'a) [0..<length (a # r)]))\n        (0::'a) =\n       (0::'a)", "finally"], ["proof (chain)\npicking this:\n  foldr (\\<lambda>(x, y). (+) (x * y))\n   (zip (d # r) (map (\\<lambda>k. 0::'a) [0..<length (d # r)])) (0::'a) =\n  (0::'a)", "show ?case"], ["proof (prove)\nusing this:\n  foldr (\\<lambda>(x, y). (+) (x * y))\n   (zip (d # r) (map (\\<lambda>k. 0::'a) [0..<length (d # r)])) (0::'a) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n     (zip (d # r) (map (\\<lambda>k. 0::'a) [0..<length (d # r)])) (0::'a) =\n    (0::'a)", "."], ["proof (state)\nthis:\n  foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n   (zip (d # r) (map (\\<lambda>k. 0::'a) [0..<length (d # r)])) (0::'a) =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  foldr (\\<lambda>(x, y). (+) (x * y))\n   (zip r (map (\\<lambda>k. 0::'a) [0..<length r])) (0::'a) =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>nc c.\n       \\<lbrakk>mat nr nc []; vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ([] ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row [] k) c)\n                            [0..<nr])\n 2. \\<And>a m nc c.\n       \\<lbrakk>\\<And>nc c.\n                   \\<lbrakk>mat nr nc m; vec nc c\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr]);\n        mat nr nc (a # m); vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ((a # m) ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row (a # m) k) c)\n                            [0..<nr])", "hence \"zero = foldr ?fun (zip r (map (\\<lambda> k. zero) [0..<nr])) zero\""], ["proof (prove)\nusing this:\n  foldr (\\<lambda>(x, y). (+) (x * y))\n   (zip r (map (\\<lambda>k. 0::'a) [0..<length r])) (0::'a) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) =\n    foldr (\\<lambda>(x, y). (+) (x * y))\n     (zip r (map (\\<lambda>k. 0::'a) [0..<nr])) (0::'a)", "by (simp add: nr)"], ["proof (state)\nthis:\n  (0::'a) =\n  foldr (\\<lambda>(x, y). (+) (x * y))\n   (zip r (map (\\<lambda>k. 0::'a) [0..<nr])) (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>nc c.\n       \\<lbrakk>mat nr nc []; vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ([] ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row [] k) c)\n                            [0..<nr])\n 2. \\<And>a m nc c.\n       \\<lbrakk>\\<And>nc c.\n                   \\<lbrakk>mat nr nc m; vec nc c\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr]);\n        mat nr nc (a # m); vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ((a # m) ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row (a # m) k) c)\n                            [0..<nr])", "with Nil nc"], ["proof (chain)\npicking this:\n  mat nr nc []\n  vec nc c\n  nc = 0\n  (0::'a) =\n  foldr (\\<lambda>(x, y). (+) (x * y))\n   (zip r (map (\\<lambda>k. 0::'a) [0..<nr])) (0::'a)", "show ?case"], ["proof (prove)\nusing this:\n  mat nr nc []\n  vec nc c\n  nc = 0\n  (0::'a) =\n  foldr (\\<lambda>(x, y). (+) (x * y))\n   (zip r (map (\\<lambda>k. 0::'a) [0..<nr])) (0::'a)\n\ngoal (1 subgoal):\n 1. scalar_prod (map (\\<lambda>k. scalar_prod r ([] ! k)) [0..<nc]) c =\n    scalar_prod r (map (\\<lambda>k. scalar_prod (row [] k) c) [0..<nr])", "by (simp add: scalar_prodI_def row_def)"], ["proof (state)\nthis:\n  scalar_prod (map (\\<lambda>k. scalar_prod r ([] ! k)) [0..<nc]) c =\n  scalar_prod r (map (\\<lambda>k. scalar_prod (row [] k) c) [0..<nr])\n\ngoal (1 subgoal):\n 1. \\<And>a m nc c.\n       \\<lbrakk>\\<And>nc c.\n                   \\<lbrakk>mat nr nc m; vec nc c\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr]);\n        mat nr nc (a # m); vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ((a # m) ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row (a # m) k) c)\n                            [0..<nr])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a m nc c.\n       \\<lbrakk>\\<And>nc c.\n                   \\<lbrakk>mat nr nc m; vec nc c\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr]);\n        mat nr nc (a # m); vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ((a # m) ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row (a # m) k) c)\n                            [0..<nr])", "case (Cons v m)"], ["proof (state)\nthis:\n  \\<lbrakk>mat nr ?nc1 m; vec ?nc1 ?c1\\<rbrakk>\n  \\<Longrightarrow> scalar_prod\n                     (map (\\<lambda>k. scalar_prod r (m ! k)) [0..<?nc1])\n                     ?c1 =\n                    scalar_prod r\n                     (map (\\<lambda>k. scalar_prod (row m k) ?c1) [0..<nr])\n  mat nr nc (v # m)\n  vec nc c\n\ngoal (1 subgoal):\n 1. \\<And>a m nc c.\n       \\<lbrakk>\\<And>nc c.\n                   \\<lbrakk>mat nr nc m; vec nc c\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr]);\n        mat nr nc (a # m); vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ((a # m) ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row (a # m) k) c)\n                            [0..<nr])", "from this"], ["proof (chain)\npicking this:\n  \\<lbrakk>mat nr ?nc1 m; vec ?nc1 ?c1\\<rbrakk>\n  \\<Longrightarrow> scalar_prod\n                     (map (\\<lambda>k. scalar_prod r (m ! k)) [0..<?nc1])\n                     ?c1 =\n                    scalar_prod r\n                     (map (\\<lambda>k. scalar_prod (row m k) ?c1) [0..<nr])\n  mat nr nc (v # m)\n  vec nc c", "obtain ncc where nc: \"nc = Suc ncc\" and wf: \"mat nr ncc m\""], ["proof (prove)\nusing this:\n  \\<lbrakk>mat nr ?nc1 m; vec ?nc1 ?c1\\<rbrakk>\n  \\<Longrightarrow> scalar_prod\n                     (map (\\<lambda>k. scalar_prod r (m ! k)) [0..<?nc1])\n                     ?c1 =\n                    scalar_prod r\n                     (map (\\<lambda>k. scalar_prod (row m k) ?c1) [0..<nr])\n  mat nr nc (v # m)\n  vec nc c\n\ngoal (1 subgoal):\n 1. (\\<And>ncc.\n        \\<lbrakk>nc = Suc ncc; mat nr ncc m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding mat_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>length m = ?nc1 \\<and> Ball (set m) (vec nr);\n   vec ?nc1 ?c1\\<rbrakk>\n  \\<Longrightarrow> scalar_prod\n                     (map (\\<lambda>k. scalar_prod r (m ! k)) [0..<?nc1])\n                     ?c1 =\n                    scalar_prod r\n                     (map (\\<lambda>k. scalar_prod (row m k) ?c1) [0..<nr])\n  length (v # m) = nc \\<and> Ball (set (v # m)) (vec nr)\n  vec nc c\n\ngoal (1 subgoal):\n 1. (\\<And>ncc.\n        \\<lbrakk>nc = Suc ncc;\n         length m = ncc \\<and> Ball (set m) (vec nr)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: vec_def)"], ["proof (state)\nthis:\n  nc = Suc ncc\n  mat nr ncc m\n\ngoal (1 subgoal):\n 1. \\<And>a m nc c.\n       \\<lbrakk>\\<And>nc c.\n                   \\<lbrakk>mat nr nc m; vec nc c\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr]);\n        mat nr nc (a # m); vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ((a # m) ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row (a # m) k) c)\n                            [0..<nr])", "from nc \\<open>vec nc c\\<close>"], ["proof (chain)\npicking this:\n  nc = Suc ncc\n  vec nc c", "obtain a cc where c: \"c = a # cc\" and wfc: \"vec ncc cc\""], ["proof (prove)\nusing this:\n  nc = Suc ncc\n  vec nc c\n\ngoal (1 subgoal):\n 1. (\\<And>a cc.\n        \\<lbrakk>c = a # cc; vec ncc cc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding vec_def"], ["proof (prove)\nusing this:\n  nc = Suc ncc\n  length c = nc\n\ngoal (1 subgoal):\n 1. (\\<And>a cc.\n        \\<lbrakk>c = a # cc; length cc = ncc\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases c, auto)"], ["proof (state)\nthis:\n  c = a # cc\n  vec ncc cc\n\ngoal (1 subgoal):\n 1. \\<And>a m nc c.\n       \\<lbrakk>\\<And>nc c.\n                   \\<lbrakk>mat nr nc m; vec nc c\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr]);\n        mat nr nc (a # m); vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ((a # m) ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row (a # m) k) c)\n                            [0..<nr])", "have rec: \"scalar_prod (map (\\<lambda> k. scalar_prod r (m ! k)) [0..<ncc]) cc = scalar_prod r (map (\\<lambda> k. scalar_prod (row m k) cc) [0..<nr])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_prod (map (\\<lambda>k. scalar_prod r (m ! k)) [0..<ncc]) cc =\n    scalar_prod r (map (\\<lambda>k. scalar_prod (row m k) cc) [0..<nr])", "by (rule Cons, rule wf, rule wfc)"], ["proof (state)\nthis:\n  scalar_prod (map (\\<lambda>k. scalar_prod r (m ! k)) [0..<ncc]) cc =\n  scalar_prod r (map (\\<lambda>k. scalar_prod (row m k) cc) [0..<nr])\n\ngoal (1 subgoal):\n 1. \\<And>a m nc c.\n       \\<lbrakk>\\<And>nc c.\n                   \\<lbrakk>mat nr nc m; vec nc c\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr]);\n        mat nr nc (a # m); vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ((a # m) ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row (a # m) k) c)\n                            [0..<nr])", "have id: \"map (\\<lambda>k. scalar_prod r ((v # m) ! k)) [0..<Suc ncc] = scalar_prod r v # map (\\<lambda> k. scalar_prod r (m ! k)) [0..<ncc]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>k. scalar_prod r ((v # m) ! k)) [0..<Suc ncc] =\n    scalar_prod r v # map (\\<lambda>k. scalar_prod r (m ! k)) [0..<ncc]", "by (induct ncc, auto)"], ["proof (state)\nthis:\n  map (\\<lambda>k. scalar_prod r ((v # m) ! k)) [0..<Suc ncc] =\n  scalar_prod r v # map (\\<lambda>k. scalar_prod r (m ! k)) [0..<ncc]\n\ngoal (1 subgoal):\n 1. \\<And>a m nc c.\n       \\<lbrakk>\\<And>nc c.\n                   \\<lbrakk>mat nr nc m; vec nc c\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr]);\n        mat nr nc (a # m); vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ((a # m) ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row (a # m) k) c)\n                            [0..<nr])", "from wfr"], ["proof (chain)\npicking this:\n  vec nr r", "have nr: \"nr = length r\""], ["proof (prove)\nusing this:\n  vec nr r\n\ngoal (1 subgoal):\n 1. nr = length r", "unfolding vec_def"], ["proof (prove)\nusing this:\n  length r = nr\n\ngoal (1 subgoal):\n 1. nr = length r", "by auto"], ["proof (state)\nthis:\n  nr = length r\n\ngoal (1 subgoal):\n 1. \\<And>a m nc c.\n       \\<lbrakk>\\<And>nc c.\n                   \\<lbrakk>mat nr nc m; vec nc c\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr]);\n        mat nr nc (a # m); vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ((a # m) ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row (a # m) k) c)\n                            [0..<nr])", "with Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>mat nr ?nc1 m; vec ?nc1 ?c1\\<rbrakk>\n  \\<Longrightarrow> scalar_prod\n                     (map (\\<lambda>k. scalar_prod r (m ! k)) [0..<?nc1])\n                     ?c1 =\n                    scalar_prod r\n                     (map (\\<lambda>k. scalar_prod (row m k) ?c1) [0..<nr])\n  mat nr nc (v # m)\n  vec nc c\n  nr = length r", "have v: \"length v = length r\""], ["proof (prove)\nusing this:\n  \\<lbrakk>mat nr ?nc1 m; vec ?nc1 ?c1\\<rbrakk>\n  \\<Longrightarrow> scalar_prod\n                     (map (\\<lambda>k. scalar_prod r (m ! k)) [0..<?nc1])\n                     ?c1 =\n                    scalar_prod r\n                     (map (\\<lambda>k. scalar_prod (row m k) ?c1) [0..<nr])\n  mat nr nc (v # m)\n  vec nc c\n  nr = length r\n\ngoal (1 subgoal):\n 1. length v = length r", "unfolding mat_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>length m = ?nc1 \\<and> Ball (set m) (vec nr);\n   vec ?nc1 ?c1\\<rbrakk>\n  \\<Longrightarrow> scalar_prod\n                     (map (\\<lambda>k. scalar_prod r (m ! k)) [0..<?nc1])\n                     ?c1 =\n                    scalar_prod r\n                     (map (\\<lambda>k. scalar_prod (row m k) ?c1) [0..<nr])\n  length (v # m) = nc \\<and> Ball (set (v # m)) (vec nr)\n  vec nc c\n  nr = length r\n\ngoal (1 subgoal):\n 1. length v = length r", "by (auto simp: vec_def)"], ["proof (state)\nthis:\n  length v = length r\n\ngoal (1 subgoal):\n 1. \\<And>a m nc c.\n       \\<lbrakk>\\<And>nc c.\n                   \\<lbrakk>mat nr nc m; vec nc c\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr]);\n        mat nr nc (a # m); vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ((a # m) ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row (a # m) k) c)\n                            [0..<nr])", "have \"\\<forall> i < nr. vec ncc (row m i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<nr. vec ncc (row m i)", "by (intro allI impI, rule row[OF wf], simp)"], ["proof (state)\nthis:\n  \\<forall>i<nr. vec ncc (row m i)\n\ngoal (1 subgoal):\n 1. \\<And>a m nc c.\n       \\<lbrakk>\\<And>nc c.\n                   \\<lbrakk>mat nr nc m; vec nc c\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr]);\n        mat nr nc (a # m); vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ((a # m) ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row (a # m) k) c)\n                            [0..<nr])", "obtain tm where tm: \"tm = transpose nr m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tm.\n        tm = Matrix_Legacy.transpose nr m \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  tm = Matrix_Legacy.transpose nr m\n\ngoal (1 subgoal):\n 1. \\<And>a m nc c.\n       \\<lbrakk>\\<And>nc c.\n                   \\<lbrakk>mat nr nc m; vec nc c\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr]);\n        mat nr nc (a # m); vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ((a # m) ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row (a # m) k) c)\n                            [0..<nr])", "hence idk: \"\\<forall> k < length r. row m k = tm ! k\""], ["proof (prove)\nusing this:\n  tm = Matrix_Legacy.transpose nr m\n\ngoal (1 subgoal):\n 1. \\<forall>k<length r. row m k = tm ! k", "using col_transpose_is_row[OF wf]"], ["proof (prove)\nusing this:\n  tm = Matrix_Legacy.transpose nr m\n  ?i < nr \\<Longrightarrow> col (Matrix_Legacy.transpose nr m) ?i = row m ?i\n\ngoal (1 subgoal):\n 1. \\<forall>k<length r. row m k = tm ! k", "unfolding col_def"], ["proof (prove)\nusing this:\n  tm = Matrix_Legacy.transpose nr m\n  ?i < nr \\<Longrightarrow> Matrix_Legacy.transpose nr m ! ?i = row m ?i\n\ngoal (1 subgoal):\n 1. \\<forall>k<length r. row m k = tm ! k", "by (auto simp: nr)"], ["proof (state)\nthis:\n  \\<forall>k<length r. row m k = tm ! k\n\ngoal (1 subgoal):\n 1. \\<And>a m nc c.\n       \\<lbrakk>\\<And>nc c.\n                   \\<lbrakk>mat nr nc m; vec nc c\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr]);\n        mat nr nc (a # m); vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ((a # m) ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row (a # m) k) c)\n                            [0..<nr])", "hence idtm1: \"map (\\<lambda>k. scalar_prod (row m k) cc) [0..<length r] = map (\\<lambda>k. scalar_prod (tm ! k) cc) [0..<length r]\"\n    and idtm2: \"map (\\<lambda>k. plus (times (v ! k) a) (scalar_prod (row m k) cc)) [0..<length r] = map (\\<lambda>k. plus (times (v ! k) a) (scalar_prod (tm ! k) cc)) [0..<length r]\""], ["proof (prove)\nusing this:\n  \\<forall>k<length r. row m k = tm ! k\n\ngoal (1 subgoal):\n 1. map (\\<lambda>k. scalar_prod (row m k) cc) [0..<length r] =\n    map (\\<lambda>k. scalar_prod (tm ! k) cc) [0..<length r] &&&\n    map (\\<lambda>k. v ! k * a + scalar_prod (row m k) cc) [0..<length r] =\n    map (\\<lambda>k. v ! k * a + scalar_prod (tm ! k) cc) [0..<length r]", "by auto"], ["proof (state)\nthis:\n  map (\\<lambda>k. scalar_prod (row m k) cc) [0..<length r] =\n  map (\\<lambda>k. scalar_prod (tm ! k) cc) [0..<length r]\n  map (\\<lambda>k. v ! k * a + scalar_prod (row m k) cc) [0..<length r] =\n  map (\\<lambda>k. v ! k * a + scalar_prod (tm ! k) cc) [0..<length r]\n\ngoal (1 subgoal):\n 1. \\<And>a m nc c.\n       \\<lbrakk>\\<And>nc c.\n                   \\<lbrakk>mat nr nc m; vec nc c\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr]);\n        mat nr nc (a # m); vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ((a # m) ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row (a # m) k) c)\n                            [0..<nr])", "from tm transpose[OF wf]"], ["proof (chain)\npicking this:\n  tm = Matrix_Legacy.transpose nr m\n  mat ncc nr (Matrix_Legacy.transpose nr m)", "have \"mat ncc nr tm\""], ["proof (prove)\nusing this:\n  tm = Matrix_Legacy.transpose nr m\n  mat ncc nr (Matrix_Legacy.transpose nr m)\n\ngoal (1 subgoal):\n 1. mat ncc nr tm", "by simp"], ["proof (state)\nthis:\n  mat ncc nr tm\n\ngoal (1 subgoal):\n 1. \\<And>a m nc c.\n       \\<lbrakk>\\<And>nc c.\n                   \\<lbrakk>mat nr nc m; vec nc c\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr]);\n        mat nr nc (a # m); vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ((a # m) ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row (a # m) k) c)\n                            [0..<nr])", "with nr"], ["proof (chain)\npicking this:\n  nr = length r\n  mat ncc nr tm", "have \"length tm = length r\" and  \"(\\<forall> i < length r. length (tm ! i) = ncc)\""], ["proof (prove)\nusing this:\n  nr = length r\n  mat ncc nr tm\n\ngoal (1 subgoal):\n 1. length tm = length r &&& \\<forall>i<length r. length (tm ! i) = ncc", "unfolding mat_def"], ["proof (prove)\nusing this:\n  nr = length r\n  length tm = nr \\<and> Ball (set tm) (vec ncc)\n\ngoal (1 subgoal):\n 1. length tm = length r &&& \\<forall>i<length r. length (tm ! i) = ncc", "by (auto simp: vec_def)"], ["proof (state)\nthis:\n  length tm = length r\n  \\<forall>i<length r. length (tm ! i) = ncc\n\ngoal (1 subgoal):\n 1. \\<And>a m nc c.\n       \\<lbrakk>\\<And>nc c.\n                   \\<lbrakk>mat nr nc m; vec nc c\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr]);\n        mat nr nc (a # m); vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ((a # m) ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row (a # m) k) c)\n                            [0..<nr])", "with v"], ["proof (chain)\npicking this:\n  length v = length r\n  length tm = length r\n  \\<forall>i<length r. length (tm ! i) = ncc", "have main: \"plus (times (scalar_prod r v) a) (scalar_prod r (map (\\<lambda>k. scalar_prod (tm ! k) cc) [0..<length r])) =\n    scalar_prod r (map (\\<lambda>k. plus (times (v ! k) a) (scalar_prod (tm ! k) cc)) [0..<length r])\""], ["proof (prove)\nusing this:\n  length v = length r\n  length tm = length r\n  \\<forall>i<length r. length (tm ! i) = ncc\n\ngoal (1 subgoal):\n 1. scalar_prod r v * a +\n    scalar_prod r\n     (map (\\<lambda>k. scalar_prod (tm ! k) cc) [0..<length r]) =\n    scalar_prod r\n     (map (\\<lambda>k. v ! k * a + scalar_prod (tm ! k) cc) [0..<length r])", "proof (induct r arbitrary: v tm)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v tm.\n       \\<lbrakk>length v = length []; length tm = length [];\n        \\<forall>i<length []. length (tm ! i) = ncc\\<rbrakk>\n       \\<Longrightarrow> scalar_prod [] v * a +\n                         scalar_prod []\n                          (map (\\<lambda>k. scalar_prod (tm ! k) cc)\n                            [0..<length []]) =\n                         scalar_prod []\n                          (map (\\<lambda>k.\n                                   v ! k * a + scalar_prod (tm ! k) cc)\n                            [0..<length []])\n 2. \\<And>aa r v tm.\n       \\<lbrakk>\\<And>v tm.\n                   \\<lbrakk>length v = length r; length tm = length r;\n                    \\<forall>i<length r. length (tm ! i) = ncc\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod r v * a +\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (tm ! k) cc) [0..<length r]) =\n                                     scalar_prod r\n(map (\\<lambda>k. v ! k * a + scalar_prod (tm ! k) cc) [0..<length r]);\n        length v = length (aa # r); length tm = length (aa # r);\n        \\<forall>i<length (aa # r). length (tm ! i) = ncc\\<rbrakk>\n       \\<Longrightarrow> scalar_prod (aa # r) v * a +\n                         scalar_prod (aa # r)\n                          (map (\\<lambda>k. scalar_prod (tm ! k) cc)\n                            [0..<length (aa # r)]) =\n                         scalar_prod (aa # r)\n                          (map (\\<lambda>k.\n                                   v ! k * a + scalar_prod (tm ! k) cc)\n                            [0..<length (aa # r)])", "case Nil"], ["proof (state)\nthis:\n  length v = length []\n  length tm = length []\n  \\<forall>i<length []. length (tm ! i) = ncc\n\ngoal (2 subgoals):\n 1. \\<And>v tm.\n       \\<lbrakk>length v = length []; length tm = length [];\n        \\<forall>i<length []. length (tm ! i) = ncc\\<rbrakk>\n       \\<Longrightarrow> scalar_prod [] v * a +\n                         scalar_prod []\n                          (map (\\<lambda>k. scalar_prod (tm ! k) cc)\n                            [0..<length []]) =\n                         scalar_prod []\n                          (map (\\<lambda>k.\n                                   v ! k * a + scalar_prod (tm ! k) cc)\n                            [0..<length []])\n 2. \\<And>aa r v tm.\n       \\<lbrakk>\\<And>v tm.\n                   \\<lbrakk>length v = length r; length tm = length r;\n                    \\<forall>i<length r. length (tm ! i) = ncc\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod r v * a +\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (tm ! k) cc) [0..<length r]) =\n                                     scalar_prod r\n(map (\\<lambda>k. v ! k * a + scalar_prod (tm ! k) cc) [0..<length r]);\n        length v = length (aa # r); length tm = length (aa # r);\n        \\<forall>i<length (aa # r). length (tm ! i) = ncc\\<rbrakk>\n       \\<Longrightarrow> scalar_prod (aa # r) v * a +\n                         scalar_prod (aa # r)\n                          (map (\\<lambda>k. scalar_prod (tm ! k) cc)\n                            [0..<length (aa # r)]) =\n                         scalar_prod (aa # r)\n                          (map (\\<lambda>k.\n                                   v ! k * a + scalar_prod (tm ! k) cc)\n                            [0..<length (aa # r)])", "thus ?case"], ["proof (prove)\nusing this:\n  length v = length []\n  length tm = length []\n  \\<forall>i<length []. length (tm ! i) = ncc\n\ngoal (1 subgoal):\n 1. scalar_prod [] v * a +\n    scalar_prod []\n     (map (\\<lambda>k. scalar_prod (tm ! k) cc) [0..<length []]) =\n    scalar_prod []\n     (map (\\<lambda>k. v ! k * a + scalar_prod (tm ! k) cc) [0..<length []])", "by (auto simp: scalar_prodI_def row_def)"], ["proof (state)\nthis:\n  scalar_prod [] v * a +\n  scalar_prod []\n   (map (\\<lambda>k. scalar_prod (tm ! k) cc) [0..<length []]) =\n  scalar_prod []\n   (map (\\<lambda>k. v ! k * a + scalar_prod (tm ! k) cc) [0..<length []])\n\ngoal (1 subgoal):\n 1. \\<And>aa r v tm.\n       \\<lbrakk>\\<And>v tm.\n                   \\<lbrakk>length v = length r; length tm = length r;\n                    \\<forall>i<length r. length (tm ! i) = ncc\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod r v * a +\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (tm ! k) cc) [0..<length r]) =\n                                     scalar_prod r\n(map (\\<lambda>k. v ! k * a + scalar_prod (tm ! k) cc) [0..<length r]);\n        length v = length (aa # r); length tm = length (aa # r);\n        \\<forall>i<length (aa # r). length (tm ! i) = ncc\\<rbrakk>\n       \\<Longrightarrow> scalar_prod (aa # r) v * a +\n                         scalar_prod (aa # r)\n                          (map (\\<lambda>k. scalar_prod (tm ! k) cc)\n                            [0..<length (aa # r)]) =\n                         scalar_prod (aa # r)\n                          (map (\\<lambda>k.\n                                   v ! k * a + scalar_prod (tm ! k) cc)\n                            [0..<length (aa # r)])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa r v tm.\n       \\<lbrakk>\\<And>v tm.\n                   \\<lbrakk>length v = length r; length tm = length r;\n                    \\<forall>i<length r. length (tm ! i) = ncc\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod r v * a +\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (tm ! k) cc) [0..<length r]) =\n                                     scalar_prod r\n(map (\\<lambda>k. v ! k * a + scalar_prod (tm ! k) cc) [0..<length r]);\n        length v = length (aa # r); length tm = length (aa # r);\n        \\<forall>i<length (aa # r). length (tm ! i) = ncc\\<rbrakk>\n       \\<Longrightarrow> scalar_prod (aa # r) v * a +\n                         scalar_prod (aa # r)\n                          (map (\\<lambda>k. scalar_prod (tm ! k) cc)\n                            [0..<length (aa # r)]) =\n                         scalar_prod (aa # r)\n                          (map (\\<lambda>k.\n                                   v ! k * a + scalar_prod (tm ! k) cc)\n                            [0..<length (aa # r)])", "case (Cons b r)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?v1 = length r; length ?tm1 = length r;\n   \\<forall>i<length r. length (?tm1 ! i) = ncc\\<rbrakk>\n  \\<Longrightarrow> scalar_prod r ?v1 * a +\n                    scalar_prod r\n                     (map (\\<lambda>k. scalar_prod (?tm1 ! k) cc)\n                       [0..<length r]) =\n                    scalar_prod r\n                     (map (\\<lambda>k.\n                              ?v1 ! k * a + scalar_prod (?tm1 ! k) cc)\n                       [0..<length r])\n  length v = length (b # r)\n  length tm = length (b # r)\n  \\<forall>i<length (b # r). length (tm ! i) = ncc\n\ngoal (1 subgoal):\n 1. \\<And>aa r v tm.\n       \\<lbrakk>\\<And>v tm.\n                   \\<lbrakk>length v = length r; length tm = length r;\n                    \\<forall>i<length r. length (tm ! i) = ncc\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod r v * a +\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (tm ! k) cc) [0..<length r]) =\n                                     scalar_prod r\n(map (\\<lambda>k. v ! k * a + scalar_prod (tm ! k) cc) [0..<length r]);\n        length v = length (aa # r); length tm = length (aa # r);\n        \\<forall>i<length (aa # r). length (tm ! i) = ncc\\<rbrakk>\n       \\<Longrightarrow> scalar_prod (aa # r) v * a +\n                         scalar_prod (aa # r)\n                          (map (\\<lambda>k. scalar_prod (tm ! k) cc)\n                            [0..<length (aa # r)]) =\n                         scalar_prod (aa # r)\n                          (map (\\<lambda>k.\n                                   v ! k * a + scalar_prod (tm ! k) cc)\n                            [0..<length (aa # r)])", "from this"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?v1 = length r; length ?tm1 = length r;\n   \\<forall>i<length r. length (?tm1 ! i) = ncc\\<rbrakk>\n  \\<Longrightarrow> scalar_prod r ?v1 * a +\n                    scalar_prod r\n                     (map (\\<lambda>k. scalar_prod (?tm1 ! k) cc)\n                       [0..<length r]) =\n                    scalar_prod r\n                     (map (\\<lambda>k.\n                              ?v1 ! k * a + scalar_prod (?tm1 ! k) cc)\n                       [0..<length r])\n  length v = length (b # r)\n  length tm = length (b # r)\n  \\<forall>i<length (b # r). length (tm ! i) = ncc", "obtain c vv where v: \"v = c # vv\" and vvlen: \"length vv = length r\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?v1 = length r; length ?tm1 = length r;\n   \\<forall>i<length r. length (?tm1 ! i) = ncc\\<rbrakk>\n  \\<Longrightarrow> scalar_prod r ?v1 * a +\n                    scalar_prod r\n                     (map (\\<lambda>k. scalar_prod (?tm1 ! k) cc)\n                       [0..<length r]) =\n                    scalar_prod r\n                     (map (\\<lambda>k.\n                              ?v1 ! k * a + scalar_prod (?tm1 ! k) cc)\n                       [0..<length r])\n  length v = length (b # r)\n  length tm = length (b # r)\n  \\<forall>i<length (b # r). length (tm ! i) = ncc\n\ngoal (1 subgoal):\n 1. (\\<And>c vv.\n        \\<lbrakk>v = c # vv; length vv = length r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases v, auto)"], ["proof (state)\nthis:\n  v = c # vv\n  length vv = length r\n\ngoal (1 subgoal):\n 1. \\<And>aa r v tm.\n       \\<lbrakk>\\<And>v tm.\n                   \\<lbrakk>length v = length r; length tm = length r;\n                    \\<forall>i<length r. length (tm ! i) = ncc\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod r v * a +\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (tm ! k) cc) [0..<length r]) =\n                                     scalar_prod r\n(map (\\<lambda>k. v ! k * a + scalar_prod (tm ! k) cc) [0..<length r]);\n        length v = length (aa # r); length tm = length (aa # r);\n        \\<forall>i<length (aa # r). length (tm ! i) = ncc\\<rbrakk>\n       \\<Longrightarrow> scalar_prod (aa # r) v * a +\n                         scalar_prod (aa # r)\n                          (map (\\<lambda>k. scalar_prod (tm ! k) cc)\n                            [0..<length (aa # r)]) =\n                         scalar_prod (aa # r)\n                          (map (\\<lambda>k.\n                                   v ! k * a + scalar_prod (tm ! k) cc)\n                            [0..<length (aa # r)])", "from Cons"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?v1 = length r; length ?tm1 = length r;\n   \\<forall>i<length r. length (?tm1 ! i) = ncc\\<rbrakk>\n  \\<Longrightarrow> scalar_prod r ?v1 * a +\n                    scalar_prod r\n                     (map (\\<lambda>k. scalar_prod (?tm1 ! k) cc)\n                       [0..<length r]) =\n                    scalar_prod r\n                     (map (\\<lambda>k.\n                              ?v1 ! k * a + scalar_prod (?tm1 ! k) cc)\n                       [0..<length r])\n  length v = length (b # r)\n  length tm = length (b # r)\n  \\<forall>i<length (b # r). length (tm ! i) = ncc", "obtain u mm where tm: \"tm = u # mm\" and mmlen: \"length mm = length r\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?v1 = length r; length ?tm1 = length r;\n   \\<forall>i<length r. length (?tm1 ! i) = ncc\\<rbrakk>\n  \\<Longrightarrow> scalar_prod r ?v1 * a +\n                    scalar_prod r\n                     (map (\\<lambda>k. scalar_prod (?tm1 ! k) cc)\n                       [0..<length r]) =\n                    scalar_prod r\n                     (map (\\<lambda>k.\n                              ?v1 ! k * a + scalar_prod (?tm1 ! k) cc)\n                       [0..<length r])\n  length v = length (b # r)\n  length tm = length (b # r)\n  \\<forall>i<length (b # r). length (tm ! i) = ncc\n\ngoal (1 subgoal):\n 1. (\\<And>u mm.\n        \\<lbrakk>tm = u # mm; length mm = length r\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases tm, auto)"], ["proof (state)\nthis:\n  tm = u # mm\n  length mm = length r\n\ngoal (1 subgoal):\n 1. \\<And>aa r v tm.\n       \\<lbrakk>\\<And>v tm.\n                   \\<lbrakk>length v = length r; length tm = length r;\n                    \\<forall>i<length r. length (tm ! i) = ncc\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod r v * a +\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (tm ! k) cc) [0..<length r]) =\n                                     scalar_prod r\n(map (\\<lambda>k. v ! k * a + scalar_prod (tm ! k) cc) [0..<length r]);\n        length v = length (aa # r); length tm = length (aa # r);\n        \\<forall>i<length (aa # r). length (tm ! i) = ncc\\<rbrakk>\n       \\<Longrightarrow> scalar_prod (aa # r) v * a +\n                         scalar_prod (aa # r)\n                          (map (\\<lambda>k. scalar_prod (tm ! k) cc)\n                            [0..<length (aa # r)]) =\n                         scalar_prod (aa # r)\n                          (map (\\<lambda>k.\n                                   v ! k * a + scalar_prod (tm ! k) cc)\n                            [0..<length (aa # r)])", "from Cons tm"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?v1 = length r; length ?tm1 = length r;\n   \\<forall>i<length r. length (?tm1 ! i) = ncc\\<rbrakk>\n  \\<Longrightarrow> scalar_prod r ?v1 * a +\n                    scalar_prod r\n                     (map (\\<lambda>k. scalar_prod (?tm1 ! k) cc)\n                       [0..<length r]) =\n                    scalar_prod r\n                     (map (\\<lambda>k.\n                              ?v1 ! k * a + scalar_prod (?tm1 ! k) cc)\n                       [0..<length r])\n  length v = length (b # r)\n  length tm = length (b # r)\n  \\<forall>i<length (b # r). length (tm ! i) = ncc\n  tm = u # mm", "have argLen: \"\\<forall> i < length r. length (mm ! i) = ncc\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?v1 = length r; length ?tm1 = length r;\n   \\<forall>i<length r. length (?tm1 ! i) = ncc\\<rbrakk>\n  \\<Longrightarrow> scalar_prod r ?v1 * a +\n                    scalar_prod r\n                     (map (\\<lambda>k. scalar_prod (?tm1 ! k) cc)\n                       [0..<length r]) =\n                    scalar_prod r\n                     (map (\\<lambda>k.\n                              ?v1 ! k * a + scalar_prod (?tm1 ! k) cc)\n                       [0..<length r])\n  length v = length (b # r)\n  length tm = length (b # r)\n  \\<forall>i<length (b # r). length (tm ! i) = ncc\n  tm = u # mm\n\ngoal (1 subgoal):\n 1. \\<forall>i<length r. length (mm ! i) = ncc", "by auto"], ["proof (state)\nthis:\n  \\<forall>i<length r. length (mm ! i) = ncc\n\ngoal (1 subgoal):\n 1. \\<And>aa r v tm.\n       \\<lbrakk>\\<And>v tm.\n                   \\<lbrakk>length v = length r; length tm = length r;\n                    \\<forall>i<length r. length (tm ! i) = ncc\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod r v * a +\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (tm ! k) cc) [0..<length r]) =\n                                     scalar_prod r\n(map (\\<lambda>k. v ! k * a + scalar_prod (tm ! k) cc) [0..<length r]);\n        length v = length (aa # r); length tm = length (aa # r);\n        \\<forall>i<length (aa # r). length (tm ! i) = ncc\\<rbrakk>\n       \\<Longrightarrow> scalar_prod (aa # r) v * a +\n                         scalar_prod (aa # r)\n                          (map (\\<lambda>k. scalar_prod (tm ! k) cc)\n                            [0..<length (aa # r)]) =\n                         scalar_prod (aa # r)\n                          (map (\\<lambda>k.\n                                   v ! k * a + scalar_prod (tm ! k) cc)\n                            [0..<length (aa # r)])", "have rec: \"plus (times (scalar_prod r vv) a) (scalar_prod r (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n     scalar_prod r (map (\\<lambda>k. plus (times (vv ! k) a) (scalar_prod (mm ! k) cc)) [0..<length r])\"\n      (is \"plus (times ?rv a) ?recl = ?recr\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_prod r vv * a +\n    scalar_prod r\n     (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r]) =\n    scalar_prod r\n     (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r])", "by (rule Cons, auto simp: vvlen mmlen argLen)"], ["proof (state)\nthis:\n  scalar_prod r vv * a +\n  scalar_prod r (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r]) =\n  scalar_prod r\n   (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r])\n\ngoal (1 subgoal):\n 1. \\<And>aa r v tm.\n       \\<lbrakk>\\<And>v tm.\n                   \\<lbrakk>length v = length r; length tm = length r;\n                    \\<forall>i<length r. length (tm ! i) = ncc\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod r v * a +\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (tm ! k) cc) [0..<length r]) =\n                                     scalar_prod r\n(map (\\<lambda>k. v ! k * a + scalar_prod (tm ! k) cc) [0..<length r]);\n        length v = length (aa # r); length tm = length (aa # r);\n        \\<forall>i<length (aa # r). length (tm ! i) = ncc\\<rbrakk>\n       \\<Longrightarrow> scalar_prod (aa # r) v * a +\n                         scalar_prod (aa # r)\n                          (map (\\<lambda>k. scalar_prod (tm ! k) cc)\n                            [0..<length (aa # r)]) =\n                         scalar_prod (aa # r)\n                          (map (\\<lambda>k.\n                                   v ! k * a + scalar_prod (tm ! k) cc)\n                            [0..<length (aa # r)])", "have id: \"map (\\<lambda>k. scalar_prod ((u # mm) ! k) cc) [0..<length (b # r)] = scalar_prod u cc # map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>k. scalar_prod ((u # mm) ! k) cc) [0..<length (b # r)] =\n    scalar_prod u cc #\n    map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r]", "by (simp, induct r, auto)"], ["proof (state)\nthis:\n  map (\\<lambda>k. scalar_prod ((u # mm) ! k) cc) [0..<length (b # r)] =\n  scalar_prod u cc #\n  map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r]\n\ngoal (1 subgoal):\n 1. \\<And>aa r v tm.\n       \\<lbrakk>\\<And>v tm.\n                   \\<lbrakk>length v = length r; length tm = length r;\n                    \\<forall>i<length r. length (tm ! i) = ncc\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod r v * a +\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (tm ! k) cc) [0..<length r]) =\n                                     scalar_prod r\n(map (\\<lambda>k. v ! k * a + scalar_prod (tm ! k) cc) [0..<length r]);\n        length v = length (aa # r); length tm = length (aa # r);\n        \\<forall>i<length (aa # r). length (tm ! i) = ncc\\<rbrakk>\n       \\<Longrightarrow> scalar_prod (aa # r) v * a +\n                         scalar_prod (aa # r)\n                          (map (\\<lambda>k. scalar_prod (tm ! k) cc)\n                            [0..<length (aa # r)]) =\n                         scalar_prod (aa # r)\n                          (map (\\<lambda>k.\n                                   v ! k * a + scalar_prod (tm ! k) cc)\n                            [0..<length (aa # r)])", "have id2: \"map (\\<lambda>k. plus (times ((c # vv) ! k) a) (scalar_prod ((u # mm) ! k) cc)) [0..<length (b # r)] =\n               (plus (times c a) (scalar_prod u cc)) #\n               map (\\<lambda>k. plus (times (vv ! k) a) (scalar_prod (mm ! k) cc)) [0..<length r]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>k. (c # vv) ! k * a + scalar_prod ((u # mm) ! k) cc)\n     [0..<length (b # r)] =\n    (c * a + scalar_prod u cc) #\n    map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r]", "by (simp, induct r, auto)"], ["proof (state)\nthis:\n  map (\\<lambda>k. (c # vv) ! k * a + scalar_prod ((u # mm) ! k) cc)\n   [0..<length (b # r)] =\n  (c * a + scalar_prod u cc) #\n  map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r]\n\ngoal (1 subgoal):\n 1. \\<And>aa r v tm.\n       \\<lbrakk>\\<And>v tm.\n                   \\<lbrakk>length v = length r; length tm = length r;\n                    \\<forall>i<length r. length (tm ! i) = ncc\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod r v * a +\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (tm ! k) cc) [0..<length r]) =\n                                     scalar_prod r\n(map (\\<lambda>k. v ! k * a + scalar_prod (tm ! k) cc) [0..<length r]);\n        length v = length (aa # r); length tm = length (aa # r);\n        \\<forall>i<length (aa # r). length (tm ! i) = ncc\\<rbrakk>\n       \\<Longrightarrow> scalar_prod (aa # r) v * a +\n                         scalar_prod (aa # r)\n                          (map (\\<lambda>k. scalar_prod (tm ! k) cc)\n                            [0..<length (aa # r)]) =\n                         scalar_prod (aa # r)\n                          (map (\\<lambda>k.\n                                   v ! k * a + scalar_prod (tm ! k) cc)\n                            [0..<length (aa # r)])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_prod (b # r) v * a +\n    scalar_prod (b # r)\n     (map (\\<lambda>k. scalar_prod (tm ! k) cc) [0..<length (b # r)]) =\n    scalar_prod (b # r)\n     (map (\\<lambda>k. v ! k * a + scalar_prod (tm ! k) cc)\n       [0..<length (b # r)])", "proof (simp only: v tm, simp only: id, simp only: id2, simp only: scalar_prod_cons)"], ["proof (state)\ngoal (1 subgoal):\n 1. (b * c + scalar_prod r vv) * a +\n    (b * scalar_prod u cc +\n     scalar_prod r\n      (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n    b * (c * a + scalar_prod u cc) +\n    scalar_prod r\n     (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r])", "let ?uc = \"scalar_prod u cc\""], ["proof (state)\ngoal (1 subgoal):\n 1. (b * c + scalar_prod r vv) * a +\n    (b * scalar_prod u cc +\n     scalar_prod r\n      (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n    b * (c * a + scalar_prod u cc) +\n    scalar_prod r\n     (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r])", "let ?bca = \"times (times b c) a\""], ["proof (state)\ngoal (1 subgoal):\n 1. (b * c + scalar_prod r vv) * a +\n    (b * scalar_prod u cc +\n     scalar_prod r\n      (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n    b * (c * a + scalar_prod u cc) +\n    scalar_prod r\n     (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r])", "have \"plus (times (plus (times b c) ?rv) a) (plus (times b ?uc) ?recl) = plus (plus ?bca (times ?rv a)) (plus (times b ?uc) ?recl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (b * c + scalar_prod r vv) * a +\n    (b * scalar_prod u cc +\n     scalar_prod r\n      (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n    b * c * a + scalar_prod r vv * a +\n    (b * scalar_prod u cc +\n     scalar_prod r\n      (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r]))", "by (simp add: distrib_right)"], ["proof (state)\nthis:\n  (b * c + scalar_prod r vv) * a +\n  (b * scalar_prod u cc +\n   scalar_prod r\n    (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n  b * c * a + scalar_prod r vv * a +\n  (b * scalar_prod u cc +\n   scalar_prod r (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r]))\n\ngoal (1 subgoal):\n 1. (b * c + scalar_prod r vv) * a +\n    (b * scalar_prod u cc +\n     scalar_prod r\n      (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n    b * (c * a + scalar_prod u cc) +\n    scalar_prod r\n     (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r])", "also"], ["proof (state)\nthis:\n  (b * c + scalar_prod r vv) * a +\n  (b * scalar_prod u cc +\n   scalar_prod r\n    (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n  b * c * a + scalar_prod r vv * a +\n  (b * scalar_prod u cc +\n   scalar_prod r (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r]))\n\ngoal (1 subgoal):\n 1. (b * c + scalar_prod r vv) * a +\n    (b * scalar_prod u cc +\n     scalar_prod r\n      (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n    b * (c * a + scalar_prod u cc) +\n    scalar_prod r\n     (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r])", "have \"\\<dots> = plus (plus ?bca (times ?rv a)) (plus ?recl (times b ?uc))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b * c * a + scalar_prod r vv * a +\n    (b * scalar_prod u cc +\n     scalar_prod r\n      (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n    b * c * a + scalar_prod r vv * a +\n    (scalar_prod r\n      (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r]) +\n     b * scalar_prod u cc)", "by (simp add: add.commute)"], ["proof (state)\nthis:\n  b * c * a + scalar_prod r vv * a +\n  (b * scalar_prod u cc +\n   scalar_prod r\n    (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n  b * c * a + scalar_prod r vv * a +\n  (scalar_prod r\n    (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r]) +\n   b * scalar_prod u cc)\n\ngoal (1 subgoal):\n 1. (b * c + scalar_prod r vv) * a +\n    (b * scalar_prod u cc +\n     scalar_prod r\n      (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n    b * (c * a + scalar_prod u cc) +\n    scalar_prod r\n     (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r])", "also"], ["proof (state)\nthis:\n  b * c * a + scalar_prod r vv * a +\n  (b * scalar_prod u cc +\n   scalar_prod r\n    (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n  b * c * a + scalar_prod r vv * a +\n  (scalar_prod r\n    (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r]) +\n   b * scalar_prod u cc)\n\ngoal (1 subgoal):\n 1. (b * c + scalar_prod r vv) * a +\n    (b * scalar_prod u cc +\n     scalar_prod r\n      (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n    b * (c * a + scalar_prod u cc) +\n    scalar_prod r\n     (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r])", "have \"\\<dots> = plus ?bca (plus (plus (times ?rv a) ?recl) (times b ?uc))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b * c * a + scalar_prod r vv * a +\n    (scalar_prod r\n      (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r]) +\n     b * scalar_prod u cc) =\n    b * c * a +\n    (scalar_prod r vv * a +\n     scalar_prod r\n      (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r]) +\n     b * scalar_prod u cc)", "by (simp add: add.assoc)"], ["proof (state)\nthis:\n  b * c * a + scalar_prod r vv * a +\n  (scalar_prod r\n    (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r]) +\n   b * scalar_prod u cc) =\n  b * c * a +\n  (scalar_prod r vv * a +\n   scalar_prod r\n    (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r]) +\n   b * scalar_prod u cc)\n\ngoal (1 subgoal):\n 1. (b * c + scalar_prod r vv) * a +\n    (b * scalar_prod u cc +\n     scalar_prod r\n      (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n    b * (c * a + scalar_prod u cc) +\n    scalar_prod r\n     (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r])", "also"], ["proof (state)\nthis:\n  b * c * a + scalar_prod r vv * a +\n  (scalar_prod r\n    (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r]) +\n   b * scalar_prod u cc) =\n  b * c * a +\n  (scalar_prod r vv * a +\n   scalar_prod r\n    (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r]) +\n   b * scalar_prod u cc)\n\ngoal (1 subgoal):\n 1. (b * c + scalar_prod r vv) * a +\n    (b * scalar_prod u cc +\n     scalar_prod r\n      (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n    b * (c * a + scalar_prod u cc) +\n    scalar_prod r\n     (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r])", "have \"\\<dots> = plus ?bca (plus ?recr (times b ?uc))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b * c * a +\n    (scalar_prod r vv * a +\n     scalar_prod r\n      (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r]) +\n     b * scalar_prod u cc) =\n    b * c * a +\n    (scalar_prod r\n      (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc)\n        [0..<length r]) +\n     b * scalar_prod u cc)", "by (simp only: rec)"], ["proof (state)\nthis:\n  b * c * a +\n  (scalar_prod r vv * a +\n   scalar_prod r\n    (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r]) +\n   b * scalar_prod u cc) =\n  b * c * a +\n  (scalar_prod r\n    (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc)\n      [0..<length r]) +\n   b * scalar_prod u cc)\n\ngoal (1 subgoal):\n 1. (b * c + scalar_prod r vv) * a +\n    (b * scalar_prod u cc +\n     scalar_prod r\n      (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n    b * (c * a + scalar_prod u cc) +\n    scalar_prod r\n     (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r])", "also"], ["proof (state)\nthis:\n  b * c * a +\n  (scalar_prod r vv * a +\n   scalar_prod r\n    (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r]) +\n   b * scalar_prod u cc) =\n  b * c * a +\n  (scalar_prod r\n    (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc)\n      [0..<length r]) +\n   b * scalar_prod u cc)\n\ngoal (1 subgoal):\n 1. (b * c + scalar_prod r vv) * a +\n    (b * scalar_prod u cc +\n     scalar_prod r\n      (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n    b * (c * a + scalar_prod u cc) +\n    scalar_prod r\n     (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r])", "have \"\\<dots> = plus ?bca (plus (times b ?uc) ?recr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b * c * a +\n    (scalar_prod r\n      (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc)\n        [0..<length r]) +\n     b * scalar_prod u cc) =\n    b * c * a +\n    (b * scalar_prod u cc +\n     scalar_prod r\n      (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc)\n        [0..<length r]))", "by (simp add: add.commute)"], ["proof (state)\nthis:\n  b * c * a +\n  (scalar_prod r\n    (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc)\n      [0..<length r]) +\n   b * scalar_prod u cc) =\n  b * c * a +\n  (b * scalar_prod u cc +\n   scalar_prod r\n    (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r]))\n\ngoal (1 subgoal):\n 1. (b * c + scalar_prod r vv) * a +\n    (b * scalar_prod u cc +\n     scalar_prod r\n      (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n    b * (c * a + scalar_prod u cc) +\n    scalar_prod r\n     (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r])", "also"], ["proof (state)\nthis:\n  b * c * a +\n  (scalar_prod r\n    (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc)\n      [0..<length r]) +\n   b * scalar_prod u cc) =\n  b * c * a +\n  (b * scalar_prod u cc +\n   scalar_prod r\n    (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r]))\n\ngoal (1 subgoal):\n 1. (b * c + scalar_prod r vv) * a +\n    (b * scalar_prod u cc +\n     scalar_prod r\n      (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n    b * (c * a + scalar_prod u cc) +\n    scalar_prod r\n     (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r])", "have \"\\<dots> = plus (times b (plus (times c a) ?uc)) ?recr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b * c * a +\n    (b * scalar_prod u cc +\n     scalar_prod r\n      (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc)\n        [0..<length r])) =\n    b * (c * a + scalar_prod u cc) +\n    scalar_prod r\n     (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r])", "by (simp add: distrib_left mult.assoc add.assoc)"], ["proof (state)\nthis:\n  b * c * a +\n  (b * scalar_prod u cc +\n   scalar_prod r\n    (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc)\n      [0..<length r])) =\n  b * (c * a + scalar_prod u cc) +\n  scalar_prod r\n   (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r])\n\ngoal (1 subgoal):\n 1. (b * c + scalar_prod r vv) * a +\n    (b * scalar_prod u cc +\n     scalar_prod r\n      (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n    b * (c * a + scalar_prod u cc) +\n    scalar_prod r\n     (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r])", "finally"], ["proof (chain)\npicking this:\n  (b * c + scalar_prod r vv) * a +\n  (b * scalar_prod u cc +\n   scalar_prod r\n    (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n  b * (c * a + scalar_prod u cc) +\n  scalar_prod r\n   (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r])", "show \"plus (times (plus (times b c) ?rv) a) (plus (times b ?uc) ?recl) = plus (times b (plus (times c a) ?uc)) ?recr\""], ["proof (prove)\nusing this:\n  (b * c + scalar_prod r vv) * a +\n  (b * scalar_prod u cc +\n   scalar_prod r\n    (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n  b * (c * a + scalar_prod u cc) +\n  scalar_prod r\n   (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r])\n\ngoal (1 subgoal):\n 1. (b * c + scalar_prod r vv) * a +\n    (b * scalar_prod u cc +\n     scalar_prod r\n      (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n    b * (c * a + scalar_prod u cc) +\n    scalar_prod r\n     (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r])", "."], ["proof (state)\nthis:\n  (b * c + scalar_prod r vv) * a +\n  (b * scalar_prod u cc +\n   scalar_prod r\n    (map (\\<lambda>k. scalar_prod (mm ! k) cc) [0..<length r])) =\n  b * (c * a + scalar_prod u cc) +\n  scalar_prod r\n   (map (\\<lambda>k. vv ! k * a + scalar_prod (mm ! k) cc) [0..<length r])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  scalar_prod (b # r) v * a +\n  scalar_prod (b # r)\n   (map (\\<lambda>k. scalar_prod (tm ! k) cc) [0..<length (b # r)]) =\n  scalar_prod (b # r)\n   (map (\\<lambda>k. v ! k * a + scalar_prod (tm ! k) cc)\n     [0..<length (b # r)])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  scalar_prod r v * a +\n  scalar_prod r (map (\\<lambda>k. scalar_prod (tm ! k) cc) [0..<length r]) =\n  scalar_prod r\n   (map (\\<lambda>k. v ! k * a + scalar_prod (tm ! k) cc) [0..<length r])\n\ngoal (1 subgoal):\n 1. \\<And>a m nc c.\n       \\<lbrakk>\\<And>nc c.\n                   \\<lbrakk>mat nr nc m; vec nc c\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(map (\\<lambda>k. scalar_prod r (m ! k)) [0..<nc]) c =\n                                     scalar_prod r\n(map (\\<lambda>k. scalar_prod (row m k) c) [0..<nr]);\n        mat nr nc (a # m); vec nc c\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (map (\\<lambda>k. scalar_prod r ((a # m) ! k))\n                            [0..<nc])\n                          c =\n                         scalar_prod r\n                          (map (\\<lambda>k. scalar_prod (row (a # m) k) c)\n                            [0..<nr])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_prod (map (\\<lambda>k. scalar_prod r ((v # m) ! k)) [0..<nc]) c =\n    scalar_prod r (map (\\<lambda>k. scalar_prod (row (v # m) k) c) [0..<nr])", "by (simp only: c scalar_prod_cons, simp only: nc, simp only: id, simp only: scalar_prod_cons, simp only: rec, simp only: nr, simp only: idtm1 idtm2, simp only: main, simp only: idtm2[symmetric], simp add: row_def scalar_prod_cons)"], ["proof (state)\nthis:\n  scalar_prod (map (\\<lambda>k. scalar_prod r ((v # m) ! k)) [0..<nc]) c =\n  scalar_prod r (map (\\<lambda>k. scalar_prod (row (v # m) k) c) [0..<nr])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_mult_assoc:\n  assumes wf1: \"mat nr n1 m1\"\n  and wf2: \"mat n1 n2 m2\"\n  and wf3: \"mat n2 nc m3\"\n  shows \"mat_mult nr (mat_mult nr m1 m2) m3 = mat_mult nr m1 (mat_mult n1 m2 m3)\" (is \"?m12_3 = ?m1_23\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_mult nr (mat_mult nr m1 m2) m3 = mat_mult nr m1 (mat_mult n1 m2 m3)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_mult nr (mat_mult nr m1 m2) m3 = mat_mult nr m1 (mat_mult n1 m2 m3)", "note wf = wf1 wf2 wf3"], ["proof (state)\nthis:\n  mat nr n1 m1\n  mat n1 n2 m2\n  mat n2 nc m3\n\ngoal (1 subgoal):\n 1. mat_mult nr (mat_mult nr m1 m2) m3 = mat_mult nr m1 (mat_mult n1 m2 m3)", "let ?m12 = \"mat_mult nr m1 m2\""], ["proof (state)\ngoal (1 subgoal):\n 1. mat_mult nr (mat_mult nr m1 m2) m3 = mat_mult nr m1 (mat_mult n1 m2 m3)", "let ?m23 = \"mat_mult n1 m2 m3\""], ["proof (state)\ngoal (1 subgoal):\n 1. mat_mult nr (mat_mult nr m1 m2) m3 = mat_mult nr m1 (mat_mult n1 m2 m3)", "from wf"], ["proof (chain)\npicking this:\n  mat nr n1 m1\n  mat n1 n2 m2\n  mat n2 nc m3", "have\n    wf12: \"mat nr n2 ?m12\" and\n    wf23: \"mat n1 nc ?m23\" and\n    wf1_23: \"mat nr nc ?m1_23\" and\n    wf12_3: \"mat nr nc ?m12_3\""], ["proof (prove)\nusing this:\n  mat nr n1 m1\n  mat n1 n2 m2\n  mat n2 nc m3\n\ngoal (1 subgoal):\n 1. (mat nr n2 (mat_mult nr m1 m2) &&& mat n1 nc (mat_mult n1 m2 m3)) &&&\n    mat nr nc (mat_mult nr m1 (mat_mult n1 m2 m3)) &&&\n    mat nr nc (mat_mult nr (mat_mult nr m1 m2) m3)", "by auto"], ["proof (state)\nthis:\n  mat nr n2 (mat_mult nr m1 m2)\n  mat n1 nc (mat_mult n1 m2 m3)\n  mat nr nc (mat_mult nr m1 (mat_mult n1 m2 m3))\n  mat nr nc (mat_mult nr (mat_mult nr m1 m2) m3)\n\ngoal (1 subgoal):\n 1. mat_mult nr (mat_mult nr m1 m2) m3 = mat_mult nr m1 (mat_mult n1 m2 m3)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_mult nr (mat_mult nr m1 m2) m3 = mat_mult nr m1 (mat_mult n1 m2 m3)", "proof (rule mat_col_eqI, unfold col_def)"], ["proof (state)\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_mult nr (mat_mult nr m1 m2) m3)\n 2. mat ?nr ?nc (mat_mult nr m1 (mat_mult n1 m2 m3))\n 3. \\<And>i.\n       i < ?nc \\<Longrightarrow>\n       mat_mult nr (mat_mult nr m1 m2) m3 ! i =\n       mat_mult nr m1 (mat_mult n1 m2 m3) ! i", "fix i"], ["proof (state)\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_mult nr (mat_mult nr m1 m2) m3)\n 2. mat ?nr ?nc (mat_mult nr m1 (mat_mult n1 m2 m3))\n 3. \\<And>i.\n       i < ?nc \\<Longrightarrow>\n       mat_mult nr (mat_mult nr m1 m2) m3 ! i =\n       mat_mult nr m1 (mat_mult n1 m2 m3) ! i", "assume i: \"i < nc\""], ["proof (state)\nthis:\n  i < nc\n\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_mult nr (mat_mult nr m1 m2) m3)\n 2. mat ?nr ?nc (mat_mult nr m1 (mat_mult n1 m2 m3))\n 3. \\<And>i.\n       i < ?nc \\<Longrightarrow>\n       mat_mult nr (mat_mult nr m1 m2) m3 ! i =\n       mat_mult nr m1 (mat_mult n1 m2 m3) ! i", "with wf1_23 wf12_3 wf3"], ["proof (chain)\npicking this:\n  mat nr nc (mat_mult nr m1 (mat_mult n1 m2 m3))\n  mat nr nc (mat_mult nr (mat_mult nr m1 m2) m3)\n  mat n2 nc m3\n  i < nc", "have len: \"length (?m12_3 ! i) = length (?m1_23 ! i)\" and ilen: \"i < length m3\""], ["proof (prove)\nusing this:\n  mat nr nc (mat_mult nr m1 (mat_mult n1 m2 m3))\n  mat nr nc (mat_mult nr (mat_mult nr m1 m2) m3)\n  mat n2 nc m3\n  i < nc\n\ngoal (1 subgoal):\n 1. length (mat_mult nr (mat_mult nr m1 m2) m3 ! i) =\n    length (mat_mult nr m1 (mat_mult n1 m2 m3) ! i) &&&\n    i < length m3", "unfolding mat_def"], ["proof (prove)\nusing this:\n  length (mat_mult nr m1 (mat_mult n1 m2 m3)) = nc \\<and>\n  Ball (set (mat_mult nr m1 (mat_mult n1 m2 m3))) (vec nr)\n  length (mat_mult nr (mat_mult nr m1 m2) m3) = nc \\<and>\n  Ball (set (mat_mult nr (mat_mult nr m1 m2) m3)) (vec nr)\n  length m3 = nc \\<and> Ball (set m3) (vec n2)\n  i < nc\n\ngoal (1 subgoal):\n 1. length (mat_mult nr (mat_mult nr m1 m2) m3 ! i) =\n    length (mat_mult nr m1 (mat_mult n1 m2 m3) ! i) &&&\n    i < length m3", "by (auto simp: vec_def)"], ["proof (state)\nthis:\n  length (mat_mult nr (mat_mult nr m1 m2) m3 ! i) =\n  length (mat_mult nr m1 (mat_mult n1 m2 m3) ! i)\n  i < length m3\n\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_mult nr (mat_mult nr m1 m2) m3)\n 2. mat ?nr ?nc (mat_mult nr m1 (mat_mult n1 m2 m3))\n 3. \\<And>i.\n       i < ?nc \\<Longrightarrow>\n       mat_mult nr (mat_mult nr m1 m2) m3 ! i =\n       mat_mult nr m1 (mat_mult n1 m2 m3) ! i", "show \"?m12_3 ! i = ?m1_23 ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_mult nr (mat_mult nr m1 m2) m3 ! i =\n    mat_mult nr m1 (mat_mult n1 m2 m3) ! i", "proof (rule nth_equalityI[OF len])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < length\n             (mat_mult nr (mat_mult nr m1 m2) m3 ! i) \\<Longrightarrow>\n       mat_mult nr (mat_mult nr m1 m2) m3 ! i ! ia =\n       mat_mult nr m1 (mat_mult n1 m2 m3) ! i ! ia", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < length\n             (mat_mult nr (mat_mult nr m1 m2) m3 ! i) \\<Longrightarrow>\n       mat_mult nr (mat_mult nr m1 m2) m3 ! i ! ia =\n       mat_mult nr m1 (mat_mult n1 m2 m3) ! i ! ia", "assume jlen: \"j < length (?m12_3 ! i)\""], ["proof (state)\nthis:\n  j < length (mat_mult nr (mat_mult nr m1 m2) m3 ! i)\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < length\n             (mat_mult nr (mat_mult nr m1 m2) m3 ! i) \\<Longrightarrow>\n       mat_mult nr (mat_mult nr m1 m2) m3 ! i ! ia =\n       mat_mult nr m1 (mat_mult n1 m2 m3) ! i ! ia", "with wf12_3 i"], ["proof (chain)\npicking this:\n  mat nr nc (mat_mult nr (mat_mult nr m1 m2) m3)\n  i < nc\n  j < length (mat_mult nr (mat_mult nr m1 m2) m3 ! i)", "have j: \"j < nr\""], ["proof (prove)\nusing this:\n  mat nr nc (mat_mult nr (mat_mult nr m1 m2) m3)\n  i < nc\n  j < length (mat_mult nr (mat_mult nr m1 m2) m3 ! i)\n\ngoal (1 subgoal):\n 1. j < nr", "unfolding mat_def"], ["proof (prove)\nusing this:\n  length (mat_mult nr (mat_mult nr m1 m2) m3) = nc \\<and>\n  Ball (set (mat_mult nr (mat_mult nr m1 m2) m3)) (vec nr)\n  i < nc\n  j < length (mat_mult nr (mat_mult nr m1 m2) m3 ! i)\n\ngoal (1 subgoal):\n 1. j < nr", "by (auto simp: vec_def)"], ["proof (state)\nthis:\n  j < nr\n\ngoal (1 subgoal):\n 1. \\<And>ia.\n       ia < length\n             (mat_mult nr (mat_mult nr m1 m2) m3 ! i) \\<Longrightarrow>\n       mat_mult nr (mat_mult nr m1 m2) m3 ! i ! ia =\n       mat_mult nr m1 (mat_mult n1 m2 m3) ! i ! ia", "show \"?m12_3 ! i ! j = ?m1_23 ! i ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_mult nr (mat_mult nr m1 m2) m3 ! i ! j =\n    mat_mult nr m1 (mat_mult n1 m2 m3) ! i ! j", "by (unfold mat_mult_index[OF wf12 wf3 j i]\n              mat_mult_index[OF wf1 wf23 j i]\n              row_mat_mult_index[OF wf1 wf2 j]\n              col_mat_mult_index[OF wf2 wf3 i]\n              scalar_product_assoc[OF wf2 row[OF wf1 j] col[OF wf3 i]], simp)"], ["proof (state)\nthis:\n  mat_mult nr (mat_mult nr m1 m2) m3 ! i ! j =\n  mat_mult nr m1 (mat_mult n1 m2 m3) ! i ! j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mat_mult nr (mat_mult nr m1 m2) m3 ! i =\n  mat_mult nr m1 (mat_mult n1 m2 m3) ! i\n\ngoal (2 subgoals):\n 1. mat ?nr nc (mat_mult nr (mat_mult nr m1 m2) m3)\n 2. mat ?nr nc (mat_mult nr m1 (mat_mult n1 m2 m3))", "qed (insert wf, auto)"], ["proof (state)\nthis:\n  mat_mult nr (mat_mult nr m1 m2) m3 = mat_mult nr m1 (mat_mult n1 m2 m3)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_mult_assoc_n:\n  assumes wf1: \"mat n n m1\"\n  and wf2: \"mat n n m2\"\n  and wf3: \"mat n n m3\"\n  shows \"mat_mult n (mat_mult n m1 m2) m3 = mat_mult n m1 (mat_mult n m2 m3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_mult n (mat_mult n m1 m2) m3 = mat_mult n m1 (mat_mult n m2 m3)", "using assms"], ["proof (prove)\nusing this:\n  mat n n m1\n  mat n n m2\n  mat n n m3\n\ngoal (1 subgoal):\n 1. mat_mult n (mat_mult n m1 m2) m3 = mat_mult n m1 (mat_mult n m2 m3)", "by (rule mat_mult_assoc)"], ["", "lemma scalar_left_zero: \"scalar_prod (vec0 nn) v = zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_prod (vec0 nn) v = (0::'a)", "unfolding vec0I_def scalar_prodI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(x, y). (+) (x * y)) (zip (replicate nn (0::'a)) v)\n     (0::'a) =\n    (0::'a)", "proof (induct nn arbitrary: v)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       foldr (\\<lambda>(x, y). (+) (x * y)) (zip (replicate 0 (0::'a)) v)\n        (0::'a) =\n       (0::'a)\n 2. \\<And>nn v.\n       (\\<And>v.\n           foldr (\\<lambda>(x, y). (+) (x * y))\n            (zip (replicate nn (0::'a)) v) (0::'a) =\n           (0::'a)) \\<Longrightarrow>\n       foldr (\\<lambda>(x, y). (+) (x * y))\n        (zip (replicate (Suc nn) (0::'a)) v) (0::'a) =\n       (0::'a)", "case (Suc m)"], ["proof (state)\nthis:\n  foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n   (zip (replicate m (0::'a)) ?v1) (0::'a) =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       foldr (\\<lambda>(x, y). (+) (x * y)) (zip (replicate 0 (0::'a)) v)\n        (0::'a) =\n       (0::'a)\n 2. \\<And>nn v.\n       (\\<And>v.\n           foldr (\\<lambda>(x, y). (+) (x * y))\n            (zip (replicate nn (0::'a)) v) (0::'a) =\n           (0::'a)) \\<Longrightarrow>\n       foldr (\\<lambda>(x, y). (+) (x * y))\n        (zip (replicate (Suc nn) (0::'a)) v) (0::'a) =\n       (0::'a)", "thus ?case"], ["proof (prove)\nusing this:\n  foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n   (zip (replicate m (0::'a)) ?v1) (0::'a) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n     (zip (replicate (Suc m) (0::'a)) v) (0::'a) =\n    (0::'a)", "by (cases v, auto)"], ["proof (state)\nthis:\n  foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n   (zip (replicate (Suc m) (0::'a)) v) (0::'a) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       foldr (\\<lambda>(x, y). (+) (x * y)) (zip (replicate 0 (0::'a)) v)\n        (0::'a) =\n       (0::'a)", "qed simp"], ["", "lemma scalar_right_zero: \"scalar_prod v (vec0 nn) = zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_prod v (vec0 nn) = (0::'a)", "unfolding vec0I_def scalar_prodI_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(x, y). (+) (x * y)) (zip v (replicate nn (0::'a)))\n     (0::'a) =\n    (0::'a)", "proof (induct v arbitrary: nn)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>nn.\n       foldr (\\<lambda>(x, y). (+) (x * y)) (zip [] (replicate nn (0::'a)))\n        (0::'a) =\n       (0::'a)\n 2. \\<And>a v nn.\n       (\\<And>nn.\n           foldr (\\<lambda>(x, y). (+) (x * y))\n            (zip v (replicate nn (0::'a))) (0::'a) =\n           (0::'a)) \\<Longrightarrow>\n       foldr (\\<lambda>(x, y). (+) (x * y))\n        (zip (a # v) (replicate nn (0::'a))) (0::'a) =\n       (0::'a)", "case (Cons a vv)"], ["proof (state)\nthis:\n  foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n   (zip vv (replicate ?nn1 (0::'a))) (0::'a) =\n  (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>nn.\n       foldr (\\<lambda>(x, y). (+) (x * y)) (zip [] (replicate nn (0::'a)))\n        (0::'a) =\n       (0::'a)\n 2. \\<And>a v nn.\n       (\\<And>nn.\n           foldr (\\<lambda>(x, y). (+) (x * y))\n            (zip v (replicate nn (0::'a))) (0::'a) =\n           (0::'a)) \\<Longrightarrow>\n       foldr (\\<lambda>(x, y). (+) (x * y))\n        (zip (a # v) (replicate nn (0::'a))) (0::'a) =\n       (0::'a)", "thus ?case"], ["proof (prove)\nusing this:\n  foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n   (zip vv (replicate ?nn1 (0::'a))) (0::'a) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n     (zip (a # vv) (replicate nn (0::'a))) (0::'a) =\n    (0::'a)", "by (cases nn, auto)"], ["proof (state)\nthis:\n  foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n   (zip (a # vv) (replicate nn (0::'a))) (0::'a) =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nn.\n       foldr (\\<lambda>(x, y). (+) (x * y)) (zip [] (replicate nn (0::'a)))\n        (0::'a) =\n       (0::'a)", "qed simp"], ["", "lemma mat0_mult_left: assumes wf: \"mat nc ncc m\"\n  shows \"mat_mult nr (mat0 nr nc) m = (mat0 nr ncc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_mult nr (mat0 nr nc) m = mat0 nr ncc", "proof (rule mat_eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_mult nr (mat0 nr nc) m)\n 2. mat ?nr ?nc (mat0 nr ncc)\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_mult nr (mat0 nr nc) m ! i ! j =\n                         mat0 nr ncc ! i ! j", "fix i j"], ["proof (state)\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_mult nr (mat0 nr nc) m)\n 2. mat ?nr ?nc (mat0 nr ncc)\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_mult nr (mat0 nr nc) m ! i ! j =\n                         mat0 nr ncc ! i ! j", "assume i: \"i < ncc\" and j: \"j < nr\""], ["proof (state)\nthis:\n  i < ncc\n  j < nr\n\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_mult nr (mat0 nr nc) m)\n 2. mat ?nr ?nc (mat0 nr ncc)\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_mult nr (mat0 nr nc) m ! i ! j =\n                         mat0 nr ncc ! i ! j", "show \"mat_mult nr (mat0 nr nc) m ! i ! j = mat0 nr ncc ! i ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_mult nr (mat0 nr nc) m ! i ! j = mat0 nr ncc ! i ! j", "by (unfold mat_mult_index[OF mat0 wf j i] mat0_index[OF i j] mat0_row[OF j] scalar_left_zero, simp)"], ["proof (state)\nthis:\n  mat_mult nr (mat0 nr nc) m ! i ! j = mat0 nr ncc ! i ! j\n\ngoal (2 subgoals):\n 1. mat nr ncc (mat_mult nr (mat0 nr nc) m)\n 2. mat nr ncc (mat0 nr ncc)", "qed (auto simp: wf)"], ["", "lemma mat0_mult_right: assumes wf: \"mat nr nc m\"\n  shows \"mat_mult nr m (mat0 nc ncc) = (mat0 nr ncc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_mult nr m (mat0 nc ncc) = mat0 nr ncc", "proof (rule mat_eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_mult nr m (mat0 nc ncc))\n 2. mat ?nr ?nc (mat0 nr ncc)\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_mult nr m (mat0 nc ncc) ! i ! j =\n                         mat0 nr ncc ! i ! j", "fix i j"], ["proof (state)\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_mult nr m (mat0 nc ncc))\n 2. mat ?nr ?nc (mat0 nr ncc)\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_mult nr m (mat0 nc ncc) ! i ! j =\n                         mat0 nr ncc ! i ! j", "assume i: \"i < ncc\" and j: \"j < nr\""], ["proof (state)\nthis:\n  i < ncc\n  j < nr\n\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_mult nr m (mat0 nc ncc))\n 2. mat ?nr ?nc (mat0 nr ncc)\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_mult nr m (mat0 nc ncc) ! i ! j =\n                         mat0 nr ncc ! i ! j", "show \"mat_mult nr m (mat0 nc ncc) ! i ! j = mat0 nr ncc ! i ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_mult nr m (mat0 nc ncc) ! i ! j = mat0 nr ncc ! i ! j", "by (unfold mat_mult_index[OF wf mat0 j i] mat0_index[OF i j] mat0_col[OF i] scalar_right_zero, simp)"], ["proof (state)\nthis:\n  mat_mult nr m (mat0 nc ncc) ! i ! j = mat0 nr ncc ! i ! j\n\ngoal (2 subgoals):\n 1. mat nr ncc (mat_mult nr m (mat0 nc ncc))\n 2. mat nr ncc (mat0 nr ncc)", "qed (insert wf, auto)"], ["", "lemma scalar_vec_plus_distrib_right:\n  assumes wf1: \"vec nr u\"\n  assumes wf2: \"vec nr v\"\n  assumes wf3: \"vec nr w\"\n  shows \"scalar_prod u (vec_plus v w) = plus (scalar_prod u v) (scalar_prod u w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_prod u (vec_plus v w) = scalar_prod u v + scalar_prod u w", "using assms"], ["proof (prove)\nusing this:\n  vec nr u\n  vec nr v\n  vec nr w\n\ngoal (1 subgoal):\n 1. scalar_prod u (vec_plus v w) = scalar_prod u v + scalar_prod u w", "unfolding vec_def scalar_prodI_def vec_plusI_def"], ["proof (prove)\nusing this:\n  length u = nr\n  length v = nr\n  length w = nr\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(x, y). (+) (x * y))\n     (zip u (map (\\<lambda>xy. fst xy + snd xy) (zip v w))) (0::'a) =\n    foldr (\\<lambda>(x, y). (+) (x * y)) (zip u v) (0::'a) +\n    foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w) (0::'a)", "proof (induct nr arbitrary: u v w)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u v w.\n       \\<lbrakk>length u = 0; length v = 0; length w = 0\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip u\n                            (map (\\<lambda>xy. fst xy + snd xy) (zip v w)))\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u v)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a)\n 2. \\<And>nr u v w.\n       \\<lbrakk>\\<And>u v w.\n                   \\<lbrakk>length u = nr; length v = nr;\n                    length w = nr\\<rbrakk>\n                   \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n(zip u (map (\\<lambda>xy. fst xy + snd xy) (zip v w))) (0::'a) =\n                                     foldr (\\<lambda>(x, y). (+) (x * y))\n(zip u v) (0::'a) +\n                                     foldr (\\<lambda>(x, y). (+) (x * y))\n(zip u w) (0::'a);\n        length u = Suc nr; length v = Suc nr; length w = Suc nr\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip u\n                            (map (\\<lambda>xy. fst xy + snd xy) (zip v w)))\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u v)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a)", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?u1 = n; length ?v1 = n; length ?w1 = n\\<rbrakk>\n  \\<Longrightarrow> foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1\n                       (map (\\<lambda>xy. fst xy + snd xy) (zip ?v1 ?w1)))\n                     (0::'a) =\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?v1) (0::'a) +\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?w1) (0::'a)\n  length u = Suc n\n  length v = Suc n\n  length w = Suc n\n\ngoal (2 subgoals):\n 1. \\<And>u v w.\n       \\<lbrakk>length u = 0; length v = 0; length w = 0\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip u\n                            (map (\\<lambda>xy. fst xy + snd xy) (zip v w)))\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u v)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a)\n 2. \\<And>nr u v w.\n       \\<lbrakk>\\<And>u v w.\n                   \\<lbrakk>length u = nr; length v = nr;\n                    length w = nr\\<rbrakk>\n                   \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n(zip u (map (\\<lambda>xy. fst xy + snd xy) (zip v w))) (0::'a) =\n                                     foldr (\\<lambda>(x, y). (+) (x * y))\n(zip u v) (0::'a) +\n                                     foldr (\\<lambda>(x, y). (+) (x * y))\n(zip u w) (0::'a);\n        length u = Suc nr; length v = Suc nr; length w = Suc nr\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip u\n                            (map (\\<lambda>xy. fst xy + snd xy) (zip v w)))\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u v)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a)", "from Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?u1 = n; length ?v1 = n; length ?w1 = n\\<rbrakk>\n  \\<Longrightarrow> foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1\n                       (map (\\<lambda>xy. fst xy + snd xy) (zip ?v1 ?w1)))\n                     (0::'a) =\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?v1) (0::'a) +\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?w1) (0::'a)\n  length u = Suc n\n  length v = Suc n\n  length w = Suc n", "obtain a uu where u: \"u = a # uu\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?u1 = n; length ?v1 = n; length ?w1 = n\\<rbrakk>\n  \\<Longrightarrow> foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1\n                       (map (\\<lambda>xy. fst xy + snd xy) (zip ?v1 ?w1)))\n                     (0::'a) =\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?v1) (0::'a) +\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?w1) (0::'a)\n  length u = Suc n\n  length v = Suc n\n  length w = Suc n\n\ngoal (1 subgoal):\n 1. (\\<And>a uu. u = a # uu \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases u, auto)"], ["proof (state)\nthis:\n  u = a # uu\n\ngoal (2 subgoals):\n 1. \\<And>u v w.\n       \\<lbrakk>length u = 0; length v = 0; length w = 0\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip u\n                            (map (\\<lambda>xy. fst xy + snd xy) (zip v w)))\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u v)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a)\n 2. \\<And>nr u v w.\n       \\<lbrakk>\\<And>u v w.\n                   \\<lbrakk>length u = nr; length v = nr;\n                    length w = nr\\<rbrakk>\n                   \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n(zip u (map (\\<lambda>xy. fst xy + snd xy) (zip v w))) (0::'a) =\n                                     foldr (\\<lambda>(x, y). (+) (x * y))\n(zip u v) (0::'a) +\n                                     foldr (\\<lambda>(x, y). (+) (x * y))\n(zip u w) (0::'a);\n        length u = Suc nr; length v = Suc nr; length w = Suc nr\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip u\n                            (map (\\<lambda>xy. fst xy + snd xy) (zip v w)))\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u v)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a)", "from Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?u1 = n; length ?v1 = n; length ?w1 = n\\<rbrakk>\n  \\<Longrightarrow> foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1\n                       (map (\\<lambda>xy. fst xy + snd xy) (zip ?v1 ?w1)))\n                     (0::'a) =\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?v1) (0::'a) +\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?w1) (0::'a)\n  length u = Suc n\n  length v = Suc n\n  length w = Suc n", "obtain b vv where v: \"v = b # vv\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?u1 = n; length ?v1 = n; length ?w1 = n\\<rbrakk>\n  \\<Longrightarrow> foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1\n                       (map (\\<lambda>xy. fst xy + snd xy) (zip ?v1 ?w1)))\n                     (0::'a) =\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?v1) (0::'a) +\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?w1) (0::'a)\n  length u = Suc n\n  length v = Suc n\n  length w = Suc n\n\ngoal (1 subgoal):\n 1. (\\<And>b vv. v = b # vv \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases v, auto)"], ["proof (state)\nthis:\n  v = b # vv\n\ngoal (2 subgoals):\n 1. \\<And>u v w.\n       \\<lbrakk>length u = 0; length v = 0; length w = 0\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip u\n                            (map (\\<lambda>xy. fst xy + snd xy) (zip v w)))\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u v)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a)\n 2. \\<And>nr u v w.\n       \\<lbrakk>\\<And>u v w.\n                   \\<lbrakk>length u = nr; length v = nr;\n                    length w = nr\\<rbrakk>\n                   \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n(zip u (map (\\<lambda>xy. fst xy + snd xy) (zip v w))) (0::'a) =\n                                     foldr (\\<lambda>(x, y). (+) (x * y))\n(zip u v) (0::'a) +\n                                     foldr (\\<lambda>(x, y). (+) (x * y))\n(zip u w) (0::'a);\n        length u = Suc nr; length v = Suc nr; length w = Suc nr\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip u\n                            (map (\\<lambda>xy. fst xy + snd xy) (zip v w)))\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u v)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a)", "from Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?u1 = n; length ?v1 = n; length ?w1 = n\\<rbrakk>\n  \\<Longrightarrow> foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1\n                       (map (\\<lambda>xy. fst xy + snd xy) (zip ?v1 ?w1)))\n                     (0::'a) =\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?v1) (0::'a) +\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?w1) (0::'a)\n  length u = Suc n\n  length v = Suc n\n  length w = Suc n", "obtain c ww where w: \"w = c # ww\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?u1 = n; length ?v1 = n; length ?w1 = n\\<rbrakk>\n  \\<Longrightarrow> foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1\n                       (map (\\<lambda>xy. fst xy + snd xy) (zip ?v1 ?w1)))\n                     (0::'a) =\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?v1) (0::'a) +\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?w1) (0::'a)\n  length u = Suc n\n  length v = Suc n\n  length w = Suc n\n\ngoal (1 subgoal):\n 1. (\\<And>c ww. w = c # ww \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases w, auto)"], ["proof (state)\nthis:\n  w = c # ww\n\ngoal (2 subgoals):\n 1. \\<And>u v w.\n       \\<lbrakk>length u = 0; length v = 0; length w = 0\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip u\n                            (map (\\<lambda>xy. fst xy + snd xy) (zip v w)))\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u v)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a)\n 2. \\<And>nr u v w.\n       \\<lbrakk>\\<And>u v w.\n                   \\<lbrakk>length u = nr; length v = nr;\n                    length w = nr\\<rbrakk>\n                   \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n(zip u (map (\\<lambda>xy. fst xy + snd xy) (zip v w))) (0::'a) =\n                                     foldr (\\<lambda>(x, y). (+) (x * y))\n(zip u v) (0::'a) +\n                                     foldr (\\<lambda>(x, y). (+) (x * y))\n(zip u w) (0::'a);\n        length u = Suc nr; length v = Suc nr; length w = Suc nr\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip u\n                            (map (\\<lambda>xy. fst xy + snd xy) (zip v w)))\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u v)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a)", "from Suc u v w"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?u1 = n; length ?v1 = n; length ?w1 = n\\<rbrakk>\n  \\<Longrightarrow> foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1\n                       (map (\\<lambda>xy. fst xy + snd xy) (zip ?v1 ?w1)))\n                     (0::'a) =\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?v1) (0::'a) +\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?w1) (0::'a)\n  length u = Suc n\n  length v = Suc n\n  length w = Suc n\n  u = a # uu\n  v = b # vv\n  w = c # ww", "have lu: \"length uu = n\" and lv: \"length vv = n\" and lw: \"length ww = n\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?u1 = n; length ?v1 = n; length ?w1 = n\\<rbrakk>\n  \\<Longrightarrow> foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1\n                       (map (\\<lambda>xy. fst xy + snd xy) (zip ?v1 ?w1)))\n                     (0::'a) =\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?v1) (0::'a) +\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?w1) (0::'a)\n  length u = Suc n\n  length v = Suc n\n  length w = Suc n\n  u = a # uu\n  v = b # vv\n  w = c # ww\n\ngoal (1 subgoal):\n 1. length uu = n &&& length vv = n &&& length ww = n", "by auto"], ["proof (state)\nthis:\n  length uu = n\n  length vv = n\n  length ww = n\n\ngoal (2 subgoals):\n 1. \\<And>u v w.\n       \\<lbrakk>length u = 0; length v = 0; length w = 0\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip u\n                            (map (\\<lambda>xy. fst xy + snd xy) (zip v w)))\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u v)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a)\n 2. \\<And>nr u v w.\n       \\<lbrakk>\\<And>u v w.\n                   \\<lbrakk>length u = nr; length v = nr;\n                    length w = nr\\<rbrakk>\n                   \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n(zip u (map (\\<lambda>xy. fst xy + snd xy) (zip v w))) (0::'a) =\n                                     foldr (\\<lambda>(x, y). (+) (x * y))\n(zip u v) (0::'a) +\n                                     foldr (\\<lambda>(x, y). (+) (x * y))\n(zip u w) (0::'a);\n        length u = Suc nr; length v = Suc nr; length w = Suc nr\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip u\n                            (map (\\<lambda>xy. fst xy + snd xy) (zip v w)))\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u v)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n     (zip u (map (\\<lambda>xy. fst xy + snd xy) (zip v w))) (0::'a) =\n    foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y)) (zip u v)\n     (0::'a) +\n    foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y)) (zip u w)\n     (0::'a)", "by (simp only: u v w, simp, simp only: Suc(1)[OF lu lv lw], simp add: add.commute[of _ \"times a c\"] distrib_left add.assoc[symmetric])"], ["proof (state)\nthis:\n  foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n   (zip u (map (\\<lambda>xy. fst xy + snd xy) (zip v w))) (0::'a) =\n  foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y)) (zip u v)\n   (0::'a) +\n  foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y)) (zip u w)\n   (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>u v w.\n       \\<lbrakk>length u = 0; length v = 0; length w = 0\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip u\n                            (map (\\<lambda>xy. fst xy + snd xy) (zip v w)))\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u v)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a)", "qed simp"], ["", "lemma scalar_vec_plus_distrib_left:\n  assumes wf1: \"vec nr u\"\n  assumes wf2: \"vec nr v\"\n  assumes wf3: \"vec nr w\"\n  shows \"scalar_prod (vec_plus u v) w = plus (scalar_prod u w) (scalar_prod v w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_prod (vec_plus u v) w = scalar_prod u w + scalar_prod v w", "using assms"], ["proof (prove)\nusing this:\n  vec nr u\n  vec nr v\n  vec nr w\n\ngoal (1 subgoal):\n 1. scalar_prod (vec_plus u v) w = scalar_prod u w + scalar_prod v w", "unfolding vec_def scalar_prodI_def vec_plusI_def"], ["proof (prove)\nusing this:\n  length u = nr\n  length v = nr\n  length w = nr\n\ngoal (1 subgoal):\n 1. foldr (\\<lambda>(x, y). (+) (x * y))\n     (zip (map (\\<lambda>xy. fst xy + snd xy) (zip u v)) w) (0::'a) =\n    foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w) (0::'a) +\n    foldr (\\<lambda>(x, y). (+) (x * y)) (zip v w) (0::'a)", "proof (induct nr arbitrary: u v w)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u v w.\n       \\<lbrakk>length u = 0; length v = 0; length w = 0\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip (map (\\<lambda>xy. fst xy + snd xy)\n                                 (zip u v))\n                            w)\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip v w)\n                          (0::'a)\n 2. \\<And>nr u v w.\n       \\<lbrakk>\\<And>u v w.\n                   \\<lbrakk>length u = nr; length v = nr;\n                    length w = nr\\<rbrakk>\n                   \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n(zip (map (\\<lambda>xy. fst xy + snd xy) (zip u v)) w) (0::'a) =\n                                     foldr (\\<lambda>(x, y). (+) (x * y))\n(zip u w) (0::'a) +\n                                     foldr (\\<lambda>(x, y). (+) (x * y))\n(zip v w) (0::'a);\n        length u = Suc nr; length v = Suc nr; length w = Suc nr\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip (map (\\<lambda>xy. fst xy + snd xy)\n                                 (zip u v))\n                            w)\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip v w)\n                          (0::'a)", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?u1 = n; length ?v1 = n; length ?w1 = n\\<rbrakk>\n  \\<Longrightarrow> foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip (map (\\<lambda>xy. fst xy + snd xy) (zip ?u1 ?v1))\n                       ?w1)\n                     (0::'a) =\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?w1) (0::'a) +\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?v1 ?w1) (0::'a)\n  length u = Suc n\n  length v = Suc n\n  length w = Suc n\n\ngoal (2 subgoals):\n 1. \\<And>u v w.\n       \\<lbrakk>length u = 0; length v = 0; length w = 0\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip (map (\\<lambda>xy. fst xy + snd xy)\n                                 (zip u v))\n                            w)\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip v w)\n                          (0::'a)\n 2. \\<And>nr u v w.\n       \\<lbrakk>\\<And>u v w.\n                   \\<lbrakk>length u = nr; length v = nr;\n                    length w = nr\\<rbrakk>\n                   \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n(zip (map (\\<lambda>xy. fst xy + snd xy) (zip u v)) w) (0::'a) =\n                                     foldr (\\<lambda>(x, y). (+) (x * y))\n(zip u w) (0::'a) +\n                                     foldr (\\<lambda>(x, y). (+) (x * y))\n(zip v w) (0::'a);\n        length u = Suc nr; length v = Suc nr; length w = Suc nr\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip (map (\\<lambda>xy. fst xy + snd xy)\n                                 (zip u v))\n                            w)\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip v w)\n                          (0::'a)", "from Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?u1 = n; length ?v1 = n; length ?w1 = n\\<rbrakk>\n  \\<Longrightarrow> foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip (map (\\<lambda>xy. fst xy + snd xy) (zip ?u1 ?v1))\n                       ?w1)\n                     (0::'a) =\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?w1) (0::'a) +\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?v1 ?w1) (0::'a)\n  length u = Suc n\n  length v = Suc n\n  length w = Suc n", "obtain a uu where u: \"u = a # uu\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?u1 = n; length ?v1 = n; length ?w1 = n\\<rbrakk>\n  \\<Longrightarrow> foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip (map (\\<lambda>xy. fst xy + snd xy) (zip ?u1 ?v1))\n                       ?w1)\n                     (0::'a) =\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?w1) (0::'a) +\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?v1 ?w1) (0::'a)\n  length u = Suc n\n  length v = Suc n\n  length w = Suc n\n\ngoal (1 subgoal):\n 1. (\\<And>a uu. u = a # uu \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases u, auto)"], ["proof (state)\nthis:\n  u = a # uu\n\ngoal (2 subgoals):\n 1. \\<And>u v w.\n       \\<lbrakk>length u = 0; length v = 0; length w = 0\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip (map (\\<lambda>xy. fst xy + snd xy)\n                                 (zip u v))\n                            w)\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip v w)\n                          (0::'a)\n 2. \\<And>nr u v w.\n       \\<lbrakk>\\<And>u v w.\n                   \\<lbrakk>length u = nr; length v = nr;\n                    length w = nr\\<rbrakk>\n                   \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n(zip (map (\\<lambda>xy. fst xy + snd xy) (zip u v)) w) (0::'a) =\n                                     foldr (\\<lambda>(x, y). (+) (x * y))\n(zip u w) (0::'a) +\n                                     foldr (\\<lambda>(x, y). (+) (x * y))\n(zip v w) (0::'a);\n        length u = Suc nr; length v = Suc nr; length w = Suc nr\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip (map (\\<lambda>xy. fst xy + snd xy)\n                                 (zip u v))\n                            w)\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip v w)\n                          (0::'a)", "from Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?u1 = n; length ?v1 = n; length ?w1 = n\\<rbrakk>\n  \\<Longrightarrow> foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip (map (\\<lambda>xy. fst xy + snd xy) (zip ?u1 ?v1))\n                       ?w1)\n                     (0::'a) =\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?w1) (0::'a) +\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?v1 ?w1) (0::'a)\n  length u = Suc n\n  length v = Suc n\n  length w = Suc n", "obtain b vv where v: \"v = b # vv\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?u1 = n; length ?v1 = n; length ?w1 = n\\<rbrakk>\n  \\<Longrightarrow> foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip (map (\\<lambda>xy. fst xy + snd xy) (zip ?u1 ?v1))\n                       ?w1)\n                     (0::'a) =\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?w1) (0::'a) +\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?v1 ?w1) (0::'a)\n  length u = Suc n\n  length v = Suc n\n  length w = Suc n\n\ngoal (1 subgoal):\n 1. (\\<And>b vv. v = b # vv \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases v, auto)"], ["proof (state)\nthis:\n  v = b # vv\n\ngoal (2 subgoals):\n 1. \\<And>u v w.\n       \\<lbrakk>length u = 0; length v = 0; length w = 0\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip (map (\\<lambda>xy. fst xy + snd xy)\n                                 (zip u v))\n                            w)\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip v w)\n                          (0::'a)\n 2. \\<And>nr u v w.\n       \\<lbrakk>\\<And>u v w.\n                   \\<lbrakk>length u = nr; length v = nr;\n                    length w = nr\\<rbrakk>\n                   \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n(zip (map (\\<lambda>xy. fst xy + snd xy) (zip u v)) w) (0::'a) =\n                                     foldr (\\<lambda>(x, y). (+) (x * y))\n(zip u w) (0::'a) +\n                                     foldr (\\<lambda>(x, y). (+) (x * y))\n(zip v w) (0::'a);\n        length u = Suc nr; length v = Suc nr; length w = Suc nr\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip (map (\\<lambda>xy. fst xy + snd xy)\n                                 (zip u v))\n                            w)\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip v w)\n                          (0::'a)", "from Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?u1 = n; length ?v1 = n; length ?w1 = n\\<rbrakk>\n  \\<Longrightarrow> foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip (map (\\<lambda>xy. fst xy + snd xy) (zip ?u1 ?v1))\n                       ?w1)\n                     (0::'a) =\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?w1) (0::'a) +\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?v1 ?w1) (0::'a)\n  length u = Suc n\n  length v = Suc n\n  length w = Suc n", "obtain c ww where w: \"w = c # ww\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?u1 = n; length ?v1 = n; length ?w1 = n\\<rbrakk>\n  \\<Longrightarrow> foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip (map (\\<lambda>xy. fst xy + snd xy) (zip ?u1 ?v1))\n                       ?w1)\n                     (0::'a) =\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?w1) (0::'a) +\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?v1 ?w1) (0::'a)\n  length u = Suc n\n  length v = Suc n\n  length w = Suc n\n\ngoal (1 subgoal):\n 1. (\\<And>c ww. w = c # ww \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases w, auto)"], ["proof (state)\nthis:\n  w = c # ww\n\ngoal (2 subgoals):\n 1. \\<And>u v w.\n       \\<lbrakk>length u = 0; length v = 0; length w = 0\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip (map (\\<lambda>xy. fst xy + snd xy)\n                                 (zip u v))\n                            w)\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip v w)\n                          (0::'a)\n 2. \\<And>nr u v w.\n       \\<lbrakk>\\<And>u v w.\n                   \\<lbrakk>length u = nr; length v = nr;\n                    length w = nr\\<rbrakk>\n                   \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n(zip (map (\\<lambda>xy. fst xy + snd xy) (zip u v)) w) (0::'a) =\n                                     foldr (\\<lambda>(x, y). (+) (x * y))\n(zip u w) (0::'a) +\n                                     foldr (\\<lambda>(x, y). (+) (x * y))\n(zip v w) (0::'a);\n        length u = Suc nr; length v = Suc nr; length w = Suc nr\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip (map (\\<lambda>xy. fst xy + snd xy)\n                                 (zip u v))\n                            w)\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip v w)\n                          (0::'a)", "from Suc u v w"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?u1 = n; length ?v1 = n; length ?w1 = n\\<rbrakk>\n  \\<Longrightarrow> foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip (map (\\<lambda>xy. fst xy + snd xy) (zip ?u1 ?v1))\n                       ?w1)\n                     (0::'a) =\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?w1) (0::'a) +\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?v1 ?w1) (0::'a)\n  length u = Suc n\n  length v = Suc n\n  length w = Suc n\n  u = a # uu\n  v = b # vv\n  w = c # ww", "have lu: \"length uu = n\" and lv: \"length vv = n\" and lw: \"length ww = n\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?u1 = n; length ?v1 = n; length ?w1 = n\\<rbrakk>\n  \\<Longrightarrow> foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip (map (\\<lambda>xy. fst xy + snd xy) (zip ?u1 ?v1))\n                       ?w1)\n                     (0::'a) =\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?u1 ?w1) (0::'a) +\n                    foldr\n                     (\\<lambda>a.\n                         case a of (x, y) \\<Rightarrow> (+) (x * y))\n                     (zip ?v1 ?w1) (0::'a)\n  length u = Suc n\n  length v = Suc n\n  length w = Suc n\n  u = a # uu\n  v = b # vv\n  w = c # ww\n\ngoal (1 subgoal):\n 1. length uu = n &&& length vv = n &&& length ww = n", "by auto"], ["proof (state)\nthis:\n  length uu = n\n  length vv = n\n  length ww = n\n\ngoal (2 subgoals):\n 1. \\<And>u v w.\n       \\<lbrakk>length u = 0; length v = 0; length w = 0\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip (map (\\<lambda>xy. fst xy + snd xy)\n                                 (zip u v))\n                            w)\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip v w)\n                          (0::'a)\n 2. \\<And>nr u v w.\n       \\<lbrakk>\\<And>u v w.\n                   \\<lbrakk>length u = nr; length v = nr;\n                    length w = nr\\<rbrakk>\n                   \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n(zip (map (\\<lambda>xy. fst xy + snd xy) (zip u v)) w) (0::'a) =\n                                     foldr (\\<lambda>(x, y). (+) (x * y))\n(zip u w) (0::'a) +\n                                     foldr (\\<lambda>(x, y). (+) (x * y))\n(zip v w) (0::'a);\n        length u = Suc nr; length v = Suc nr; length w = Suc nr\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip (map (\\<lambda>xy. fst xy + snd xy)\n                                 (zip u v))\n                            w)\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip v w)\n                          (0::'a)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n     (zip (map (\\<lambda>xy. fst xy + snd xy) (zip u v)) w) (0::'a) =\n    foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y)) (zip u w)\n     (0::'a) +\n    foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y)) (zip v w)\n     (0::'a)", "by (simp only: u v w, simp, simp only: Suc(1)[OF lu lv lw], simp add: add.commute[of _ \"times b c\"] distrib_right add.assoc[symmetric])"], ["proof (state)\nthis:\n  foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y))\n   (zip (map (\\<lambda>xy. fst xy + snd xy) (zip u v)) w) (0::'a) =\n  foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y)) (zip u w)\n   (0::'a) +\n  foldr (\\<lambda>a. case a of (x, y) \\<Rightarrow> (+) (x * y)) (zip v w)\n   (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>u v w.\n       \\<lbrakk>length u = 0; length v = 0; length w = 0\\<rbrakk>\n       \\<Longrightarrow> foldr (\\<lambda>(x, y). (+) (x * y))\n                          (zip (map (\\<lambda>xy. fst xy + snd xy)\n                                 (zip u v))\n                            w)\n                          (0::'a) =\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip u w)\n                          (0::'a) +\n                         foldr (\\<lambda>(x, y). (+) (x * y)) (zip v w)\n                          (0::'a)", "qed simp"], ["", "lemma mat_mult_plus_distrib_right:\n  assumes wf1: \"mat nr nc m1\"\n  and wf2: \"mat nc ncc m2\"\n  and wf3: \"mat nc ncc m3\"\n  shows \"mat_mult nr m1 (mat_plus m2 m3) = mat_plus (mat_mult nr m1 m2) (mat_mult nr m1 m3)\" (is \"mat_mult nr m1 ?m23 = mat_plus ?m12 ?m13\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_mult nr m1 (mat_plus m2 m3) =\n    mat_plus (mat_mult nr m1 m2) (mat_mult nr m1 m3)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_mult nr m1 (mat_plus m2 m3) =\n    mat_plus (mat_mult nr m1 m2) (mat_mult nr m1 m3)", "note wf = wf1 wf2 wf3"], ["proof (state)\nthis:\n  mat nr nc m1\n  mat nc ncc m2\n  mat nc ncc m3\n\ngoal (1 subgoal):\n 1. mat_mult nr m1 (mat_plus m2 m3) =\n    mat_plus (mat_mult nr m1 m2) (mat_mult nr m1 m3)", "let ?m1_23 = \"mat_mult nr m1 ?m23\""], ["proof (state)\ngoal (1 subgoal):\n 1. mat_mult nr m1 (mat_plus m2 m3) =\n    mat_plus (mat_mult nr m1 m2) (mat_mult nr m1 m3)", "let ?m12_13 = \"mat_plus ?m12 ?m13\""], ["proof (state)\ngoal (1 subgoal):\n 1. mat_mult nr m1 (mat_plus m2 m3) =\n    mat_plus (mat_mult nr m1 m2) (mat_mult nr m1 m3)", "from wf"], ["proof (chain)\npicking this:\n  mat nr nc m1\n  mat nc ncc m2\n  mat nc ncc m3", "have\n    wf23: \"mat nc ncc ?m23\" and\n    wf12: \"mat nr ncc ?m12\" and\n    wf13: \"mat nr ncc ?m13\" and\n    wf1_23: \"mat nr ncc ?m1_23\" and\n    wf12_13: \"mat nr ncc ?m12_13\""], ["proof (prove)\nusing this:\n  mat nr nc m1\n  mat nc ncc m2\n  mat nc ncc m3\n\ngoal (1 subgoal):\n 1. (mat nc ncc (mat_plus m2 m3) &&& mat nr ncc (mat_mult nr m1 m2)) &&&\n    mat nr ncc (mat_mult nr m1 m3) &&&\n    mat nr ncc (mat_mult nr m1 (mat_plus m2 m3)) &&&\n    mat nr ncc (mat_plus (mat_mult nr m1 m2) (mat_mult nr m1 m3))", "by auto"], ["proof (state)\nthis:\n  mat nc ncc (mat_plus m2 m3)\n  mat nr ncc (mat_mult nr m1 m2)\n  mat nr ncc (mat_mult nr m1 m3)\n  mat nr ncc (mat_mult nr m1 (mat_plus m2 m3))\n  mat nr ncc (mat_plus (mat_mult nr m1 m2) (mat_mult nr m1 m3))\n\ngoal (1 subgoal):\n 1. mat_mult nr m1 (mat_plus m2 m3) =\n    mat_plus (mat_mult nr m1 m2) (mat_mult nr m1 m3)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_mult nr m1 (mat_plus m2 m3) =\n    mat_plus (mat_mult nr m1 m2) (mat_mult nr m1 m3)", "proof (rule mat_eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_mult nr m1 (mat_plus m2 m3))\n 2. mat ?nr ?nc (mat_plus (mat_mult nr m1 m2) (mat_mult nr m1 m3))\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_mult nr m1 (mat_plus m2 m3) ! i ! j =\n                         mat_plus (mat_mult nr m1 m2) (mat_mult nr m1 m3) !\n                         i !\n                         j", "fix i j"], ["proof (state)\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_mult nr m1 (mat_plus m2 m3))\n 2. mat ?nr ?nc (mat_plus (mat_mult nr m1 m2) (mat_mult nr m1 m3))\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_mult nr m1 (mat_plus m2 m3) ! i ! j =\n                         mat_plus (mat_mult nr m1 m2) (mat_mult nr m1 m3) !\n                         i !\n                         j", "assume i: \"i < ncc\" and j: \"j < nr\""], ["proof (state)\nthis:\n  i < ncc\n  j < nr\n\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_mult nr m1 (mat_plus m2 m3))\n 2. mat ?nr ?nc (mat_plus (mat_mult nr m1 m2) (mat_mult nr m1 m3))\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_mult nr m1 (mat_plus m2 m3) ! i ! j =\n                         mat_plus (mat_mult nr m1 m2) (mat_mult nr m1 m3) !\n                         i !\n                         j", "show \"?m1_23 ! i ! j = ?m12_13 ! i ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_mult nr m1 (mat_plus m2 m3) ! i ! j =\n    mat_plus (mat_mult nr m1 m2) (mat_mult nr m1 m3) ! i ! j", "by (unfold mat_mult_index[OF wf1 wf23 j i]\n           mat_plus_index[OF wf12 wf13 i j]\n           mat_mult_index[OF wf1 wf2 j i]\n           mat_mult_index[OF wf1 wf3 j i]\n           col_mat_plus[OF wf2 wf3 i],\n        rule scalar_vec_plus_distrib_right[OF row[OF wf1 j] col[OF wf2 i] col[OF wf3 i]])"], ["proof (state)\nthis:\n  mat_mult nr m1 (mat_plus m2 m3) ! i ! j =\n  mat_plus (mat_mult nr m1 m2) (mat_mult nr m1 m3) ! i ! j\n\ngoal (2 subgoals):\n 1. mat nr ncc (mat_mult nr m1 (mat_plus m2 m3))\n 2. mat nr ncc (mat_plus (mat_mult nr m1 m2) (mat_mult nr m1 m3))", "qed (insert wf, auto)"], ["proof (state)\nthis:\n  mat_mult nr m1 (mat_plus m2 m3) =\n  mat_plus (mat_mult nr m1 m2) (mat_mult nr m1 m3)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_mult_plus_distrib_left:\n  assumes wf1: \"mat nr nc m1\"\n  and wf2: \"mat nr nc m2\"\n  and wf3: \"mat nc ncc m3\"\n  shows \"mat_mult nr (mat_plus m1 m2) m3 = mat_plus (mat_mult nr m1 m3) (mat_mult nr m2 m3)\" (is \"mat_mult nr ?m12 _ = mat_plus ?m13 ?m23\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_mult nr (mat_plus m1 m2) m3 =\n    mat_plus (mat_mult nr m1 m3) (mat_mult nr m2 m3)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_mult nr (mat_plus m1 m2) m3 =\n    mat_plus (mat_mult nr m1 m3) (mat_mult nr m2 m3)", "note wf = wf1 wf2 wf3"], ["proof (state)\nthis:\n  mat nr nc m1\n  mat nr nc m2\n  mat nc ncc m3\n\ngoal (1 subgoal):\n 1. mat_mult nr (mat_plus m1 m2) m3 =\n    mat_plus (mat_mult nr m1 m3) (mat_mult nr m2 m3)", "let ?m12_3 = \"mat_mult nr ?m12 m3\""], ["proof (state)\ngoal (1 subgoal):\n 1. mat_mult nr (mat_plus m1 m2) m3 =\n    mat_plus (mat_mult nr m1 m3) (mat_mult nr m2 m3)", "let ?m13_23 = \"mat_plus ?m13 ?m23\""], ["proof (state)\ngoal (1 subgoal):\n 1. mat_mult nr (mat_plus m1 m2) m3 =\n    mat_plus (mat_mult nr m1 m3) (mat_mult nr m2 m3)", "from wf"], ["proof (chain)\npicking this:\n  mat nr nc m1\n  mat nr nc m2\n  mat nc ncc m3", "have\n    wf12: \"mat nr nc ?m12\" and\n    wf13: \"mat nr ncc ?m13\" and\n    wf23: \"mat nr ncc ?m23\" and\n    wf12_3: \"mat nr ncc ?m12_3\" and\n    wf13_23: \"mat nr ncc ?m13_23\""], ["proof (prove)\nusing this:\n  mat nr nc m1\n  mat nr nc m2\n  mat nc ncc m3\n\ngoal (1 subgoal):\n 1. (mat nr nc (mat_plus m1 m2) &&& mat nr ncc (mat_mult nr m1 m3)) &&&\n    mat nr ncc (mat_mult nr m2 m3) &&&\n    mat nr ncc (mat_mult nr (mat_plus m1 m2) m3) &&&\n    mat nr ncc (mat_plus (mat_mult nr m1 m3) (mat_mult nr m2 m3))", "by auto"], ["proof (state)\nthis:\n  mat nr nc (mat_plus m1 m2)\n  mat nr ncc (mat_mult nr m1 m3)\n  mat nr ncc (mat_mult nr m2 m3)\n  mat nr ncc (mat_mult nr (mat_plus m1 m2) m3)\n  mat nr ncc (mat_plus (mat_mult nr m1 m3) (mat_mult nr m2 m3))\n\ngoal (1 subgoal):\n 1. mat_mult nr (mat_plus m1 m2) m3 =\n    mat_plus (mat_mult nr m1 m3) (mat_mult nr m2 m3)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_mult nr (mat_plus m1 m2) m3 =\n    mat_plus (mat_mult nr m1 m3) (mat_mult nr m2 m3)", "proof (rule mat_eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_mult nr (mat_plus m1 m2) m3)\n 2. mat ?nr ?nc (mat_plus (mat_mult nr m1 m3) (mat_mult nr m2 m3))\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_mult nr (mat_plus m1 m2) m3 ! i ! j =\n                         mat_plus (mat_mult nr m1 m3) (mat_mult nr m2 m3) !\n                         i !\n                         j", "fix i j"], ["proof (state)\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_mult nr (mat_plus m1 m2) m3)\n 2. mat ?nr ?nc (mat_plus (mat_mult nr m1 m3) (mat_mult nr m2 m3))\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_mult nr (mat_plus m1 m2) m3 ! i ! j =\n                         mat_plus (mat_mult nr m1 m3) (mat_mult nr m2 m3) !\n                         i !\n                         j", "assume i: \"i < ncc\" and j: \"j < nr\""], ["proof (state)\nthis:\n  i < ncc\n  j < nr\n\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_mult nr (mat_plus m1 m2) m3)\n 2. mat ?nr ?nc (mat_plus (mat_mult nr m1 m3) (mat_mult nr m2 m3))\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_mult nr (mat_plus m1 m2) m3 ! i ! j =\n                         mat_plus (mat_mult nr m1 m3) (mat_mult nr m2 m3) !\n                         i !\n                         j", "show \"?m12_3 ! i ! j = ?m13_23 ! i ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_mult nr (mat_plus m1 m2) m3 ! i ! j =\n    mat_plus (mat_mult nr m1 m3) (mat_mult nr m2 m3) ! i ! j", "by (unfold mat_mult_index[OF wf12 wf3 j i]\n           mat_plus_index[OF wf13 wf23 i j]\n           mat_mult_index[OF wf1 wf3 j i]\n           mat_mult_index[OF wf2 wf3 j i]\n           row_mat_plus[OF wf1 wf2 j],\n           rule scalar_vec_plus_distrib_left[OF row[OF wf1 j] row[OF wf2 j] col[OF wf3 i]])"], ["proof (state)\nthis:\n  mat_mult nr (mat_plus m1 m2) m3 ! i ! j =\n  mat_plus (mat_mult nr m1 m3) (mat_mult nr m2 m3) ! i ! j\n\ngoal (2 subgoals):\n 1. mat nr ncc (mat_mult nr (mat_plus m1 m2) m3)\n 2. mat nr ncc (mat_plus (mat_mult nr m1 m3) (mat_mult nr m2 m3))", "qed (insert wf, auto)"], ["proof (state)\nthis:\n  mat_mult nr (mat_plus m1 m2) m3 =\n  mat_plus (mat_mult nr m1 m3) (mat_mult nr m2 m3)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context semiring_1\nbegin"], ["", "abbreviation vec1 :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'a vec\"\nwhere \"vec1 \\<equiv> vec1I zero one\""], ["", "abbreviation mat1 :: \"nat \\<Rightarrow> 'a mat\"\nwhere \"mat1 \\<equiv> mat1I zero one\""], ["", "abbreviation mat_pow where \"mat_pow \\<equiv> mat_powI (0 :: 'a) 1 (+) (*)\""], ["", "lemma scalar_left_one: assumes wf: \"vec nn v\"\n  and i: \"i < nn\"\n  shows \"scalar_prod (vec1 nn i) v = v ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_prod (vec1 nn i) v = v ! i", "using assms"], ["proof (prove)\nusing this:\n  vec nn v\n  i < nn\n\ngoal (1 subgoal):\n 1. scalar_prod (vec1 nn i) v = v ! i", "unfolding vec1I_def vec_def"], ["proof (prove)\nusing this:\n  length v = nn\n  i < nn\n\ngoal (1 subgoal):\n 1. scalar_prod\n     (replicate i (0::'a) @ (1::'a) # replicate (nn - 1 - i) (0::'a)) v =\n    v ! i", "proof (induct nn arbitrary: v i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v i.\n       \\<lbrakk>length v = 0; i < 0\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (replicate i (0::'a) @\n                           (1::'a) # replicate (0 - 1 - i) (0::'a))\n                          v =\n                         v ! i\n 2. \\<And>nn v i.\n       \\<lbrakk>\\<And>v i.\n                   \\<lbrakk>length v = nn; i < nn\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(replicate i (0::'a) @ (1::'a) # replicate (nn - 1 - i) (0::'a)) v =\n                                     v ! i;\n        length v = Suc nn; i < Suc nn\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (replicate i (0::'a) @\n                           (1::'a) # replicate (Suc nn - 1 - i) (0::'a))\n                          v =\n                         v ! i", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?v1 = n; ?i1 < n\\<rbrakk>\n  \\<Longrightarrow> scalar_prod\n                     (replicate ?i1 (0::'a) @\n                      (1::'a) # replicate (n - 1 - ?i1) (0::'a))\n                     ?v1 =\n                    ?v1 ! ?i1\n  length v = Suc n\n  i < Suc n\n\ngoal (2 subgoals):\n 1. \\<And>v i.\n       \\<lbrakk>length v = 0; i < 0\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (replicate i (0::'a) @\n                           (1::'a) # replicate (0 - 1 - i) (0::'a))\n                          v =\n                         v ! i\n 2. \\<And>nn v i.\n       \\<lbrakk>\\<And>v i.\n                   \\<lbrakk>length v = nn; i < nn\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(replicate i (0::'a) @ (1::'a) # replicate (nn - 1 - i) (0::'a)) v =\n                                     v ! i;\n        length v = Suc nn; i < Suc nn\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (replicate i (0::'a) @\n                           (1::'a) # replicate (Suc nn - 1 - i) (0::'a))\n                          v =\n                         v ! i", "note oSuc = this"], ["proof (state)\nthis:\n  \\<lbrakk>length ?v1 = n; ?i1 < n\\<rbrakk>\n  \\<Longrightarrow> scalar_prod\n                     (replicate ?i1 (0::'a) @\n                      (1::'a) # replicate (n - 1 - ?i1) (0::'a))\n                     ?v1 =\n                    ?v1 ! ?i1\n  length v = Suc n\n  i < Suc n\n\ngoal (2 subgoals):\n 1. \\<And>v i.\n       \\<lbrakk>length v = 0; i < 0\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (replicate i (0::'a) @\n                           (1::'a) # replicate (0 - 1 - i) (0::'a))\n                          v =\n                         v ! i\n 2. \\<And>nn v i.\n       \\<lbrakk>\\<And>v i.\n                   \\<lbrakk>length v = nn; i < nn\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(replicate i (0::'a) @ (1::'a) # replicate (nn - 1 - i) (0::'a)) v =\n                                     v ! i;\n        length v = Suc nn; i < Suc nn\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (replicate i (0::'a) @\n                           (1::'a) # replicate (Suc nn - 1 - i) (0::'a))\n                          v =\n                         v ! i", "from this"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?v1 = n; ?i1 < n\\<rbrakk>\n  \\<Longrightarrow> scalar_prod\n                     (replicate ?i1 (0::'a) @\n                      (1::'a) # replicate (n - 1 - ?i1) (0::'a))\n                     ?v1 =\n                    ?v1 ! ?i1\n  length v = Suc n\n  i < Suc n", "obtain a vv where v: \"v = a # vv\" and lvv: \"length vv = n\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?v1 = n; ?i1 < n\\<rbrakk>\n  \\<Longrightarrow> scalar_prod\n                     (replicate ?i1 (0::'a) @\n                      (1::'a) # replicate (n - 1 - ?i1) (0::'a))\n                     ?v1 =\n                    ?v1 ! ?i1\n  length v = Suc n\n  i < Suc n\n\ngoal (1 subgoal):\n 1. (\\<And>a vv.\n        \\<lbrakk>v = a # vv; length vv = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases v, auto)"], ["proof (state)\nthis:\n  v = a # vv\n  length vv = n\n\ngoal (2 subgoals):\n 1. \\<And>v i.\n       \\<lbrakk>length v = 0; i < 0\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (replicate i (0::'a) @\n                           (1::'a) # replicate (0 - 1 - i) (0::'a))\n                          v =\n                         v ! i\n 2. \\<And>nn v i.\n       \\<lbrakk>\\<And>v i.\n                   \\<lbrakk>length v = nn; i < nn\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod\n(replicate i (0::'a) @ (1::'a) # replicate (nn - 1 - i) (0::'a)) v =\n                                     v ! i;\n        length v = Suc nn; i < Suc nn\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (replicate i (0::'a) @\n                           (1::'a) # replicate (Suc nn - 1 - i) (0::'a))\n                          v =\n                         v ! i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_prod\n     (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a)) v =\n    v ! i", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    scalar_prod\n     (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a)) v =\n    v ! i\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       scalar_prod\n        (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a))\n        v =\n       v ! i", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    scalar_prod\n     (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a)) v =\n    v ! i\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       scalar_prod\n        (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a))\n        v =\n       v ! i", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. scalar_prod\n     (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a)) v =\n    v ! i", "using scalar_left_zero"], ["proof (prove)\nusing this:\n  i = 0\n  scalar_prod (vec0 ?nn) ?v = (0::'a)\n\ngoal (1 subgoal):\n 1. scalar_prod\n     (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a)) v =\n    v ! i", "unfolding vec0I_def"], ["proof (prove)\nusing this:\n  i = 0\n  scalar_prod (replicate ?nn (0::'a)) ?v = (0::'a)\n\ngoal (1 subgoal):\n 1. scalar_prod\n     (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a)) v =\n    v ! i", "by (simp add: v scalar_prod_cons add.commute)"], ["proof (state)\nthis:\n  scalar_prod\n   (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a)) v =\n  v ! i\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       scalar_prod\n        (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a))\n        v =\n       v ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       scalar_prod\n        (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a))\n        v =\n       v ! i", "case (Suc ii)"], ["proof (state)\nthis:\n  i = Suc ii\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       scalar_prod\n        (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a))\n        v =\n       v ! i", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = Suc ii\n\ngoal (1 subgoal):\n 1. scalar_prod\n     (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a)) v =\n    v ! i", "using oSuc lvv v"], ["proof (prove)\nusing this:\n  i = Suc ii\n  \\<lbrakk>length ?v1 = n; ?i1 < n\\<rbrakk>\n  \\<Longrightarrow> scalar_prod\n                     (replicate ?i1 (0::'a) @\n                      (1::'a) # replicate (n - 1 - ?i1) (0::'a))\n                     ?v1 =\n                    ?v1 ! ?i1\n  length v = Suc n\n  i < Suc n\n  length vv = n\n  v = a # vv\n\ngoal (1 subgoal):\n 1. scalar_prod\n     (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a)) v =\n    v ! i", "by (auto simp: scalar_prod_cons)"], ["proof (state)\nthis:\n  scalar_prod\n   (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a)) v =\n  v ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  scalar_prod\n   (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a)) v =\n  v ! i\n\ngoal (1 subgoal):\n 1. \\<And>v i.\n       \\<lbrakk>length v = 0; i < 0\\<rbrakk>\n       \\<Longrightarrow> scalar_prod\n                          (replicate i (0::'a) @\n                           (1::'a) # replicate (0 - 1 - i) (0::'a))\n                          v =\n                         v ! i", "qed blast"], ["", "lemma scalar_right_one: assumes wf: \"vec nn v\"\n  and i: \"i < nn\"\n  shows \"scalar_prod v (vec1 nn i) = v ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_prod v (vec1 nn i) = v ! i", "using assms"], ["proof (prove)\nusing this:\n  vec nn v\n  i < nn\n\ngoal (1 subgoal):\n 1. scalar_prod v (vec1 nn i) = v ! i", "unfolding vec1I_def vec_def"], ["proof (prove)\nusing this:\n  length v = nn\n  i < nn\n\ngoal (1 subgoal):\n 1. scalar_prod v\n     (replicate i (0::'a) @ (1::'a) # replicate (nn - 1 - i) (0::'a)) =\n    v ! i", "proof (induct nn arbitrary: v i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v i.\n       \\<lbrakk>length v = 0; i < 0\\<rbrakk>\n       \\<Longrightarrow> scalar_prod v\n                          (replicate i (0::'a) @\n                           (1::'a) # replicate (0 - 1 - i) (0::'a)) =\n                         v ! i\n 2. \\<And>nn v i.\n       \\<lbrakk>\\<And>v i.\n                   \\<lbrakk>length v = nn; i < nn\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod v\n(replicate i (0::'a) @ (1::'a) # replicate (nn - 1 - i) (0::'a)) =\n                                     v ! i;\n        length v = Suc nn; i < Suc nn\\<rbrakk>\n       \\<Longrightarrow> scalar_prod v\n                          (replicate i (0::'a) @\n                           (1::'a) # replicate (Suc nn - 1 - i) (0::'a)) =\n                         v ! i", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>length ?v1 = n; ?i1 < n\\<rbrakk>\n  \\<Longrightarrow> scalar_prod ?v1\n                     (replicate ?i1 (0::'a) @\n                      (1::'a) # replicate (n - 1 - ?i1) (0::'a)) =\n                    ?v1 ! ?i1\n  length v = Suc n\n  i < Suc n\n\ngoal (2 subgoals):\n 1. \\<And>v i.\n       \\<lbrakk>length v = 0; i < 0\\<rbrakk>\n       \\<Longrightarrow> scalar_prod v\n                          (replicate i (0::'a) @\n                           (1::'a) # replicate (0 - 1 - i) (0::'a)) =\n                         v ! i\n 2. \\<And>nn v i.\n       \\<lbrakk>\\<And>v i.\n                   \\<lbrakk>length v = nn; i < nn\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod v\n(replicate i (0::'a) @ (1::'a) # replicate (nn - 1 - i) (0::'a)) =\n                                     v ! i;\n        length v = Suc nn; i < Suc nn\\<rbrakk>\n       \\<Longrightarrow> scalar_prod v\n                          (replicate i (0::'a) @\n                           (1::'a) # replicate (Suc nn - 1 - i) (0::'a)) =\n                         v ! i", "note oSuc = this"], ["proof (state)\nthis:\n  \\<lbrakk>length ?v1 = n; ?i1 < n\\<rbrakk>\n  \\<Longrightarrow> scalar_prod ?v1\n                     (replicate ?i1 (0::'a) @\n                      (1::'a) # replicate (n - 1 - ?i1) (0::'a)) =\n                    ?v1 ! ?i1\n  length v = Suc n\n  i < Suc n\n\ngoal (2 subgoals):\n 1. \\<And>v i.\n       \\<lbrakk>length v = 0; i < 0\\<rbrakk>\n       \\<Longrightarrow> scalar_prod v\n                          (replicate i (0::'a) @\n                           (1::'a) # replicate (0 - 1 - i) (0::'a)) =\n                         v ! i\n 2. \\<And>nn v i.\n       \\<lbrakk>\\<And>v i.\n                   \\<lbrakk>length v = nn; i < nn\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod v\n(replicate i (0::'a) @ (1::'a) # replicate (nn - 1 - i) (0::'a)) =\n                                     v ! i;\n        length v = Suc nn; i < Suc nn\\<rbrakk>\n       \\<Longrightarrow> scalar_prod v\n                          (replicate i (0::'a) @\n                           (1::'a) # replicate (Suc nn - 1 - i) (0::'a)) =\n                         v ! i", "from this"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ?v1 = n; ?i1 < n\\<rbrakk>\n  \\<Longrightarrow> scalar_prod ?v1\n                     (replicate ?i1 (0::'a) @\n                      (1::'a) # replicate (n - 1 - ?i1) (0::'a)) =\n                    ?v1 ! ?i1\n  length v = Suc n\n  i < Suc n", "obtain a vv where v: \"v = a # vv\" and lvv: \"length vv = n\""], ["proof (prove)\nusing this:\n  \\<lbrakk>length ?v1 = n; ?i1 < n\\<rbrakk>\n  \\<Longrightarrow> scalar_prod ?v1\n                     (replicate ?i1 (0::'a) @\n                      (1::'a) # replicate (n - 1 - ?i1) (0::'a)) =\n                    ?v1 ! ?i1\n  length v = Suc n\n  i < Suc n\n\ngoal (1 subgoal):\n 1. (\\<And>a vv.\n        \\<lbrakk>v = a # vv; length vv = n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases v, auto)"], ["proof (state)\nthis:\n  v = a # vv\n  length vv = n\n\ngoal (2 subgoals):\n 1. \\<And>v i.\n       \\<lbrakk>length v = 0; i < 0\\<rbrakk>\n       \\<Longrightarrow> scalar_prod v\n                          (replicate i (0::'a) @\n                           (1::'a) # replicate (0 - 1 - i) (0::'a)) =\n                         v ! i\n 2. \\<And>nn v i.\n       \\<lbrakk>\\<And>v i.\n                   \\<lbrakk>length v = nn; i < nn\\<rbrakk>\n                   \\<Longrightarrow> scalar_prod v\n(replicate i (0::'a) @ (1::'a) # replicate (nn - 1 - i) (0::'a)) =\n                                     v ! i;\n        length v = Suc nn; i < Suc nn\\<rbrakk>\n       \\<Longrightarrow> scalar_prod v\n                          (replicate i (0::'a) @\n                           (1::'a) # replicate (Suc nn - 1 - i) (0::'a)) =\n                         v ! i", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. scalar_prod v\n     (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a)) =\n    v ! i", "proof (cases i)"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    scalar_prod v\n     (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a)) =\n    v ! i\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       scalar_prod v\n        (replicate i (0::'a) @\n         (1::'a) # replicate (Suc n - 1 - i) (0::'a)) =\n       v ! i", "case 0"], ["proof (state)\nthis:\n  i = 0\n\ngoal (2 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    scalar_prod v\n     (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a)) =\n    v ! i\n 2. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       scalar_prod v\n        (replicate i (0::'a) @\n         (1::'a) # replicate (Suc n - 1 - i) (0::'a)) =\n       v ! i", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. scalar_prod v\n     (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a)) =\n    v ! i", "using scalar_right_zero"], ["proof (prove)\nusing this:\n  i = 0\n  scalar_prod ?v (vec0 ?nn) = (0::'a)\n\ngoal (1 subgoal):\n 1. scalar_prod v\n     (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a)) =\n    v ! i", "unfolding vec0I_def"], ["proof (prove)\nusing this:\n  i = 0\n  scalar_prod ?v (replicate ?nn (0::'a)) = (0::'a)\n\ngoal (1 subgoal):\n 1. scalar_prod v\n     (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a)) =\n    v ! i", "by (simp add: v scalar_prod_cons add.commute)"], ["proof (state)\nthis:\n  scalar_prod v\n   (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a)) =\n  v ! i\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       scalar_prod v\n        (replicate i (0::'a) @\n         (1::'a) # replicate (Suc n - 1 - i) (0::'a)) =\n       v ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       scalar_prod v\n        (replicate i (0::'a) @\n         (1::'a) # replicate (Suc n - 1 - i) (0::'a)) =\n       v ! i", "case (Suc ii)"], ["proof (state)\nthis:\n  i = Suc ii\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       i = Suc nat \\<Longrightarrow>\n       scalar_prod v\n        (replicate i (0::'a) @\n         (1::'a) # replicate (Suc n - 1 - i) (0::'a)) =\n       v ! i", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = Suc ii\n\ngoal (1 subgoal):\n 1. scalar_prod v\n     (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a)) =\n    v ! i", "using oSuc lvv v"], ["proof (prove)\nusing this:\n  i = Suc ii\n  \\<lbrakk>length ?v1 = n; ?i1 < n\\<rbrakk>\n  \\<Longrightarrow> scalar_prod ?v1\n                     (replicate ?i1 (0::'a) @\n                      (1::'a) # replicate (n - 1 - ?i1) (0::'a)) =\n                    ?v1 ! ?i1\n  length v = Suc n\n  i < Suc n\n  length vv = n\n  v = a # vv\n\ngoal (1 subgoal):\n 1. scalar_prod v\n     (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a)) =\n    v ! i", "by (auto simp: scalar_prod_cons)"], ["proof (state)\nthis:\n  scalar_prod v\n   (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a)) =\n  v ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  scalar_prod v\n   (replicate i (0::'a) @ (1::'a) # replicate (Suc n - 1 - i) (0::'a)) =\n  v ! i\n\ngoal (1 subgoal):\n 1. \\<And>v i.\n       \\<lbrakk>length v = 0; i < 0\\<rbrakk>\n       \\<Longrightarrow> scalar_prod v\n                          (replicate i (0::'a) @\n                           (1::'a) # replicate (0 - 1 - i) (0::'a)) =\n                         v ! i", "qed blast"], ["", "lemma mat1_mult_right: assumes wf: \"mat nr nc m\"\n  shows \"mat_mult nr m (mat1 nc) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_mult nr m (mat1 nc) = m", "proof (rule mat_eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_mult nr m (mat1 nc))\n 2. mat ?nr ?nc m\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_mult nr m (mat1 nc) ! i ! j = m ! i ! j", "fix i j"], ["proof (state)\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_mult nr m (mat1 nc))\n 2. mat ?nr ?nc m\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_mult nr m (mat1 nc) ! i ! j = m ! i ! j", "assume i: \"i < nc\" and j: \"j < nr\""], ["proof (state)\nthis:\n  i < nc\n  j < nr\n\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_mult nr m (mat1 nc))\n 2. mat ?nr ?nc m\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_mult nr m (mat1 nc) ! i ! j = m ! i ! j", "show \"mat_mult nr m (mat1 nc) ! i ! j = m ! i ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_mult nr m (mat1 nc) ! i ! j = m ! i ! j", "by (unfold mat_mult_index[OF wf mat1 j i]\n     col_mat1[OF i]\n     scalar_right_one[OF row[OF wf j] i]\n     row_col[OF wf j i],\n     unfold col_def, simp)"], ["proof (state)\nthis:\n  mat_mult nr m (mat1 nc) ! i ! j = m ! i ! j\n\ngoal (2 subgoals):\n 1. mat nr nc (mat_mult nr m (mat1 nc))\n 2. mat nr nc m", "qed (insert wf, auto)"], ["", "lemma mat1_mult_left: assumes wf: \"mat nr nc m\"\n  shows \"mat_mult nr (mat1 nr) m = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_mult nr (mat1 nr) m = m", "proof (rule mat_eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_mult nr (mat1 nr) m)\n 2. mat ?nr ?nc m\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_mult nr (mat1 nr) m ! i ! j = m ! i ! j", "fix i j"], ["proof (state)\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_mult nr (mat1 nr) m)\n 2. mat ?nr ?nc m\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_mult nr (mat1 nr) m ! i ! j = m ! i ! j", "assume i: \"i < nc\" and j: \"j < nr\""], ["proof (state)\nthis:\n  i < nc\n  j < nr\n\ngoal (3 subgoals):\n 1. mat ?nr ?nc (mat_mult nr (mat1 nr) m)\n 2. mat ?nr ?nc m\n 3. \\<And>i j.\n       \\<lbrakk>i < ?nc; j < ?nr\\<rbrakk>\n       \\<Longrightarrow> mat_mult nr (mat1 nr) m ! i ! j = m ! i ! j", "show \"mat_mult nr (mat1 nr) m ! i ! j = m ! i ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_mult nr (mat1 nr) m ! i ! j = m ! i ! j", "by (unfold mat_mult_index[OF mat1 wf j i]\n      row_mat1[OF j]\n      scalar_left_one[OF col[OF wf i] j], unfold col_def, simp)"], ["proof (state)\nthis:\n  mat_mult nr (mat1 nr) m ! i ! j = m ! i ! j\n\ngoal (2 subgoals):\n 1. mat nr nc (mat_mult nr (mat1 nr) m)\n 2. mat nr nc m", "qed (insert wf, auto)"], ["", "end"], ["", "declare vec0[simp del] mat0[simp del] vec0_plus[simp del] plus_vec0[simp del] plus_mat0[simp del]"], ["", "subsection \\<open>Connection to HOL-Algebra\\<close>"], ["", "definition mat_monoid :: \"nat \\<Rightarrow> nat \\<Rightarrow> 'b \\<Rightarrow> (('a :: {plus,zero}) mat,'b) monoid_scheme\" where\n  \"mat_monoid nr nc b \\<equiv> \\<lparr>\n    carrier = Collect (mat nr nc),\n    mult = mat_plus,\n    one = mat0 nr nc,\n    \\<dots> = b\\<rparr>\""], ["", "definition mat_ring :: \"nat \\<Rightarrow> 'b \\<Rightarrow> (('a :: semiring_1) mat,'b) ring_scheme\" where\n  \"mat_ring n b \\<equiv> \\<lparr>\n    carrier = Collect (mat n n),\n    mult = mat_mult n,\n    one = mat1 n,\n    zero = mat0 n n,\n    add = mat_plus,\n    \\<dots> = b\\<rparr>\""], ["", "lemma mat_monoid: \"monoid (mat_monoid nr nc b :: (('a :: monoid_add) mat,'b)monoid_scheme)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.monoid (mat_monoid nr nc b)", "by (unfold_locales, auto simp: mat_plus_assoc mat_monoid_def plus_mat0)"], ["", "lemma mat_group: \"group (mat_monoid nr nc b :: (('a :: group_add) mat,'b)monoid_scheme)\" (is \"group ?G\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group (mat_monoid nr nc b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Group.group (mat_monoid nr nc b)", "interpret monoid ?G"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.monoid (mat_monoid nr nc b)", "by (rule mat_monoid)"], ["proof (state)\ngoal (1 subgoal):\n 1. Group.group (mat_monoid nr nc b)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. Group.group (mat_monoid nr nc b)", "fix m :: \"'a mat\""], ["proof (state)\ngoal (1 subgoal):\n 1. Group.group (mat_monoid nr nc b)", "assume wf: \"mat nr nc m\""], ["proof (state)\nthis:\n  mat nr nc m\n\ngoal (1 subgoal):\n 1. Group.group (mat_monoid nr nc b)", "let ?m' = \"mat_map uminus m\""], ["proof (state)\ngoal (1 subgoal):\n 1. Group.group (mat_monoid nr nc b)", "have \"\\<exists> m'. mat nr nc m' \\<and> mat_plus m' m = mat0 nr nc \\<and> mat_plus m m' = mat0 nr nc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m'.\n       mat nr nc m' \\<and>\n       mat_plus m' m = mat0 nr nc \\<and> mat_plus m m' = mat0 nr nc", "proof (rule exI[of _ ?m'], intro conjI mat_eqI)"], ["proof (state)\ngoal (7 subgoals):\n 1. mat nr nc (mat_map uminus m)\n 2. mat ?nr5 ?nc5 (mat_plus (mat_map uminus m) m)\n 3. mat ?nr5 ?nc5 (mat0 nr nc)\n 4. \\<And>i j.\n       \\<lbrakk>i < ?nc5; j < ?nr5\\<rbrakk>\n       \\<Longrightarrow> mat_plus (mat_map uminus m) m ! i ! j =\n                         mat0 nr nc ! i ! j\n 5. mat ?nr4 ?nc4 (mat_plus m (mat_map uminus m))\n 6. mat ?nr4 ?nc4 (mat0 nr nc)\n 7. \\<And>i j.\n       \\<lbrakk>i < ?nc4; j < ?nr4\\<rbrakk>\n       \\<Longrightarrow> mat_plus m (mat_map uminus m) ! i ! j =\n                         mat0 nr nc ! i ! j", "fix i j"], ["proof (state)\ngoal (7 subgoals):\n 1. mat nr nc (mat_map uminus m)\n 2. mat ?nr5 ?nc5 (mat_plus (mat_map uminus m) m)\n 3. mat ?nr5 ?nc5 (mat0 nr nc)\n 4. \\<And>i j.\n       \\<lbrakk>i < ?nc5; j < ?nr5\\<rbrakk>\n       \\<Longrightarrow> mat_plus (mat_map uminus m) m ! i ! j =\n                         mat0 nr nc ! i ! j\n 5. mat ?nr4 ?nc4 (mat_plus m (mat_map uminus m))\n 6. mat ?nr4 ?nc4 (mat0 nr nc)\n 7. \\<And>i j.\n       \\<lbrakk>i < ?nc4; j < ?nr4\\<rbrakk>\n       \\<Longrightarrow> mat_plus m (mat_map uminus m) ! i ! j =\n                         mat0 nr nc ! i ! j", "assume \"i < nc\" \"j < nr\""], ["proof (state)\nthis:\n  i < nc\n  j < nr\n\ngoal (7 subgoals):\n 1. mat nr nc (mat_map uminus m)\n 2. mat ?nr5 ?nc5 (mat_plus (mat_map uminus m) m)\n 3. mat ?nr5 ?nc5 (mat0 nr nc)\n 4. \\<And>i j.\n       \\<lbrakk>i < ?nc5; j < ?nr5\\<rbrakk>\n       \\<Longrightarrow> mat_plus (mat_map uminus m) m ! i ! j =\n                         mat0 nr nc ! i ! j\n 5. mat ?nr4 ?nc4 (mat_plus m (mat_map uminus m))\n 6. mat ?nr4 ?nc4 (mat0 nr nc)\n 7. \\<And>i j.\n       \\<lbrakk>i < ?nc4; j < ?nr4\\<rbrakk>\n       \\<Longrightarrow> mat_plus m (mat_map uminus m) ! i ! j =\n                         mat0 nr nc ! i ! j", "note [simp] = mat_plus_index[OF _ _ this] mat_map_index[OF _ this] mat0_index[OF this]"], ["proof (state)\nthis:\n  \\<lbrakk>mat nr nc ?m1.0; mat nr nc ?m2.0\\<rbrakk>\n  \\<Longrightarrow> mat_plusI ?pl ?m1.0 ?m2.0 ! i ! j =\n                    ?pl (?m1.0 ! i ! j) (?m2.0 ! i ! j)\n  mat nr nc ?m \\<Longrightarrow> mat_map ?f ?m ! i ! j = ?f (?m ! i ! j)\n  mat0I ?ze nr nc ! i ! j = ?ze\n\ngoal (7 subgoals):\n 1. mat nr nc (mat_map uminus m)\n 2. mat ?nr5 ?nc5 (mat_plus (mat_map uminus m) m)\n 3. mat ?nr5 ?nc5 (mat0 nr nc)\n 4. \\<And>i j.\n       \\<lbrakk>i < ?nc5; j < ?nr5\\<rbrakk>\n       \\<Longrightarrow> mat_plus (mat_map uminus m) m ! i ! j =\n                         mat0 nr nc ! i ! j\n 5. mat ?nr4 ?nc4 (mat_plus m (mat_map uminus m))\n 6. mat ?nr4 ?nc4 (mat0 nr nc)\n 7. \\<And>i j.\n       \\<lbrakk>i < ?nc4; j < ?nr4\\<rbrakk>\n       \\<Longrightarrow> mat_plus m (mat_map uminus m) ! i ! j =\n                         mat0 nr nc ! i ! j", "show \"mat_plus ?m' m ! i ! j = mat0 nr nc ! i ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_plus (mat_map uminus m) m ! i ! j = mat0 nr nc ! i ! j", "using wf"], ["proof (prove)\nusing this:\n  mat nr nc m\n\ngoal (1 subgoal):\n 1. mat_plus (mat_map uminus m) m ! i ! j = mat0 nr nc ! i ! j", "by simp"], ["proof (state)\nthis:\n  mat_plus (mat_map uminus m) m ! i ! j = mat0 nr nc ! i ! j\n\ngoal (6 subgoals):\n 1. mat nr nc (mat_map uminus m)\n 2. mat nr nc (mat_plus (mat_map uminus m) m)\n 3. mat nr nc (mat0 nr nc)\n 4. mat ?nr4 ?nc4 (mat_plus m (mat_map uminus m))\n 5. mat ?nr4 ?nc4 (mat0 nr nc)\n 6. \\<And>i j.\n       \\<lbrakk>i < ?nc4; j < ?nr4\\<rbrakk>\n       \\<Longrightarrow> mat_plus m (mat_map uminus m) ! i ! j =\n                         mat0 nr nc ! i ! j", "show \"mat_plus m ?m' ! i ! j = mat0 nr nc ! i ! j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_plus m (mat_map uminus m) ! i ! j = mat0 nr nc ! i ! j", "using wf"], ["proof (prove)\nusing this:\n  mat nr nc m\n\ngoal (1 subgoal):\n 1. mat_plus m (mat_map uminus m) ! i ! j = mat0 nr nc ! i ! j", "by simp"], ["proof (state)\nthis:\n  mat_plus m (mat_map uminus m) ! i ! j = mat0 nr nc ! i ! j\n\ngoal (5 subgoals):\n 1. mat nr nc (mat_map uminus m)\n 2. mat nr nc (mat_plus (mat_map uminus m) m)\n 3. mat nr nc (mat0 nr nc)\n 4. mat nr nc (mat_plus m (mat_map uminus m))\n 5. mat nr nc (mat0 nr nc)", "qed (auto intro: wf)"], ["proof (state)\nthis:\n  \\<exists>m'.\n     mat nr nc m' \\<and>\n     mat_plus m' m = mat0 nr nc \\<and> mat_plus m m' = mat0 nr nc\n\ngoal (1 subgoal):\n 1. Group.group (mat_monoid nr nc b)", "}"], ["proof (state)\nthis:\n  mat nr nc ?m2 \\<Longrightarrow>\n  \\<exists>m'.\n     mat nr nc m' \\<and>\n     mat_plus m' ?m2 = mat0 nr nc \\<and> mat_plus ?m2 m' = mat0 nr nc\n\ngoal (1 subgoal):\n 1. Group.group (mat_monoid nr nc b)", "note Units = this"], ["proof (state)\nthis:\n  mat nr nc ?m2 \\<Longrightarrow>\n  \\<exists>m'.\n     mat nr nc m' \\<and>\n     mat_plus m' ?m2 = mat0 nr nc \\<and> mat_plus ?m2 m' = mat0 nr nc\n\ngoal (1 subgoal):\n 1. Group.group (mat_monoid nr nc b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group (mat_monoid nr nc b)", "by (unfold_locales, auto simp: mat_monoid_def Units_def Units)"], ["proof (state)\nthis:\n  Group.group (mat_monoid nr nc b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_comm_monoid:\n  \"comm_monoid (mat_monoid nr nc b :: (('a :: comm_monoid_add) mat,'b)monoid_scheme)\" (is \"comm_monoid ?G\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.comm_monoid (mat_monoid nr nc b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Group.comm_monoid (mat_monoid nr nc b)", "interpret monoid ?G"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.monoid (mat_monoid nr nc b)", "by (rule mat_monoid)"], ["proof (state)\ngoal (1 subgoal):\n 1. Group.comm_monoid (mat_monoid nr nc b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.comm_monoid (mat_monoid nr nc b)", "by (unfold_locales, insert mat_plus_comm, auto simp: mat_monoid_def)"], ["proof (state)\nthis:\n  Group.comm_monoid (mat_monoid nr nc b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_comm_group:\n  \"comm_group (mat_monoid nr nc b :: (('a :: ab_group_add) mat,'b)monoid_scheme)\" (is \"comm_group ?G\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_group (mat_monoid nr nc b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. comm_group (mat_monoid nr nc b)", "interpret group ?G"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group (mat_monoid nr nc b)", "by (rule mat_group)"], ["proof (state)\ngoal (1 subgoal):\n 1. comm_group (mat_monoid nr nc b)", "interpret comm_monoid ?G"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.comm_monoid (mat_monoid nr nc b)", "by (rule mat_comm_monoid)"], ["proof (state)\ngoal (1 subgoal):\n 1. comm_group (mat_monoid nr nc b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_group (mat_monoid nr nc b)", ".."], ["proof (state)\nthis:\n  comm_group (mat_monoid nr nc b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_abelian_monoid: \"abelian_monoid (mat_ring n b :: (('a :: semiring_1) mat,'b)ring_scheme)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. abelian_monoid (mat_ring n b)", "unfolding mat_ring_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. abelian_monoid\n     \\<lparr>carrier = Collect (mat n n), mult = mat_mult n, one = mat1 n,\n        zero = mat0 n n, add = mat_plus, \\<dots> = b\\<rparr>", "unfolding abelian_monoid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.comm_monoid\n     (add_monoid\n       \\<lparr>carrier = Collect (mat n n), mult = mat_mult n, one = mat1 n,\n          zero = mat0 n n, add = mat_plus, \\<dots> = b\\<rparr>)", "using mat_comm_monoid[of n n, unfolded mat_monoid_def mat_ring_def]"], ["proof (prove)\nusing this:\n  Group.comm_monoid\n   \\<lparr>carrier = Collect (mat n n), mult = mat_plus, one = mat0 n n,\n      \\<dots> = ?b\\<rparr>\n\ngoal (1 subgoal):\n 1. Group.comm_monoid\n     (add_monoid\n       \\<lparr>carrier = Collect (mat n n), mult = mat_mult n, one = mat1 n,\n          zero = mat0 n n, add = mat_plus, \\<dots> = b\\<rparr>)", "by simp"], ["", "lemma mat_abelian_group: \"abelian_group (mat_ring n b :: (('a :: {ab_group_add,semiring_1}) mat,'b)ring_scheme)\"\n  (is \"abelian_group ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. abelian_group (mat_ring n b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. abelian_group (mat_ring n b)", "interpret abelian_monoid ?R"], ["proof (prove)\ngoal (1 subgoal):\n 1. abelian_monoid (mat_ring n b)", "by (rule mat_abelian_monoid)"], ["proof (state)\ngoal (1 subgoal):\n 1. abelian_group (mat_ring n b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. abelian_group (mat_ring n b)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. carrier (add_monoid (mat_ring n b))\n    \\<subseteq> Units (add_monoid (mat_ring n b))", "apply (rule group.Units)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Group.group (add_monoid (mat_ring n b))", "by (metis mat_group mat_monoid_def mat_ring_def partial_object.simps(1) ring.simps(1) ring.simps(2))"], ["proof (state)\nthis:\n  abelian_group (mat_ring n b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_semiring: \"semiring (mat_ring n b :: (('a :: semiring_1) mat,'b)ring_scheme)\"\n  (is \"semiring ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. semiring (mat_ring n b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. semiring (mat_ring n b)", "interpret abelian_monoid ?R"], ["proof (prove)\ngoal (1 subgoal):\n 1. abelian_monoid (mat_ring n b)", "by (rule mat_abelian_monoid)"], ["proof (state)\ngoal (1 subgoal):\n 1. semiring (mat_ring n b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. semiring (mat_ring n b)", "by (unfold_locales, unfold mat_ring_def, insert\n      mat_mult_assoc mat0_mult_left mat0_mult_right mat1_mult_left mat1_mult_right\n      mat_mult_plus_distrib_left mat_mult_plus_distrib_right, auto)"], ["proof (state)\nthis:\n  semiring (mat_ring n b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_ring: \"ring (mat_ring n b :: (('a :: ring_1) mat,'b)ring_scheme)\"\n  (is \"ring ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ring (mat_ring n b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ring (mat_ring n b)", "interpret abelian_group ?R"], ["proof (prove)\ngoal (1 subgoal):\n 1. abelian_group (mat_ring n b)", "by (rule mat_abelian_group)"], ["proof (state)\ngoal (1 subgoal):\n 1. ring (mat_ring n b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ring (mat_ring n b)", "by (unfold_locales, unfold mat_ring_def, insert\n      mat_mult_assoc mat1_mult_left mat1_mult_right mat_mult_plus_distrib_left\n      mat_mult_plus_distrib_right, auto)"], ["proof (state)\nthis:\n  ring (mat_ring n b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_pow_ring_pow: assumes mat: \"mat n n (m :: ('a :: semiring_1)mat)\" shows \"mat_pow n m k = m [^]\\<^bsub>mat_ring n b\\<^esub> k\"\n  (is \"_ = m [^]\\<^bsub>?C\\<^esub> k\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_pow n m k = m [^]\\<^bsub>mat_ring n b\\<^esub> k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_pow n m k = m [^]\\<^bsub>mat_ring n b\\<^esub> k", "interpret semiring ?C"], ["proof (prove)\ngoal (1 subgoal):\n 1. semiring (mat_ring n b)", "by (rule mat_semiring)"], ["proof (state)\ngoal (1 subgoal):\n 1. mat_pow n m k = m [^]\\<^bsub>mat_ring n b\\<^esub> k", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mat_pow n m k = m [^]\\<^bsub>mat_ring n b\\<^esub> k", "by (induct k, auto, auto simp: mat_ring_def)"], ["proof (state)\nthis:\n  mat_pow n m k = m [^]\\<^bsub>mat_ring n b\\<^esub> k\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}