{"file_name": "/home/qj213/afp-2021-10-22/thys/Simple_Firewall/SimpleFw_Semantics.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Simple_Firewall", "problem_names": ["lemma wordinterval_to_set_ipcidr_tuple_to_wordinterval_simple_match_ip_set:\n    \"wordinterval_to_set (ipcidr_tuple_to_wordinterval ip) = {d. simple_match_ip ip d}\"", "lemma \"{(253::8 word) .. 8} = {}\"", "lemma simple_fw_alt: \"simple_fw r p = simple_fw_alt r p\"", "lemma simple_match_any: \"simple_matches simple_match_any p\"", "lemma simple_match_none: \"\\<not> simple_matches simple_match_none p\"", "lemma empty_match: \"empty_match m \\<longleftrightarrow> (\\<forall>(p::('i::len, 'a) simple_packet_scheme). \\<not> simple_matches m p)\"", "lemma nomatch: \"\\<not> simple_matches m p \\<Longrightarrow> simple_fw (SimpleRule m a # rs) p = simple_fw rs p\"", "lemma \"{(p1s:: 16 word) .. p1e} \\<inter> {p2s .. p2e} = {max p1s p2s .. min p1e p2e}\"", "lemma simple_ports_conjunct_correct:\n    \"simple_match_port p1 pkt \\<and> simple_match_port p2 pkt \\<longleftrightarrow> simple_match_port (simpl_ports_conjunct p1 p2) pkt\"", "lemma simple_match_port_code[code] :\"simple_match_port (s,e) p_p = (s \\<le> p_p \\<and> p_p \\<le> e)\"", "lemma simple_match_port_UNIV: \"{p. simple_match_port (s,e) p} = UNIV \\<longleftrightarrow> (s = 0 \\<and> e = max_word)\"", "lemma simple_match_ip_conjunct:\n    fixes ip1 :: \"'i::len word \\<times> nat\"\n    shows \"simple_match_ip ip1 p_ip \\<and> simple_match_ip ip2 p_ip \\<longleftrightarrow> \n            (case ipcidr_conjunct ip1 ip2 of None \\<Rightarrow> False | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)\"", "lemma simple_match_and_correct: \"simple_matches m1 p \\<and> simple_matches m2 p \\<longleftrightarrow> \n    (case simple_match_and m1 m2 of None \\<Rightarrow> False | Some m \\<Rightarrow> simple_matches m p)\"", "lemma simple_match_and_SomeD: \"simple_match_and m1 m2 = Some m \\<Longrightarrow>\n    simple_matches m p \\<longleftrightarrow> (simple_matches m1 p \\<and> simple_matches m2 p)\"", "lemma simple_match_and_NoneD: \"simple_match_and m1 m2 = None \\<Longrightarrow>\n    \\<not>(simple_matches m1 p \\<and> simple_matches m2 p)\"", "lemma simple_matches_andD: \"simple_matches m1 p \\<Longrightarrow> simple_matches m2 p \\<Longrightarrow>\n    \\<exists>m. simple_match_and m1 m2 = Some m \\<and> simple_matches m p\"", "lemma has_default_policy: \"has_default_policy rs \\<Longrightarrow>\n    simple_fw rs p = Decision FinalAllow \\<or> simple_fw rs p = Decision FinalDeny\"", "lemma has_default_policy_fst: \"has_default_policy rs \\<Longrightarrow> has_default_policy (r#rs)\"", "lemma cut_off_after_match_any: \"simple_fw (cut_off_after_match_any rs) p = simple_fw rs p\"", "lemma simple_fw_not_matches_removeAll: \"\\<not> simple_matches m p \\<Longrightarrow>\n    simple_fw (removeAll (SimpleRule m a) rs) p = simple_fw rs p\"", "lemma ipcidr_conjunct_valid:\n    \"\\<lbrakk>valid_prefix_fw p1; valid_prefix_fw p2; ipcidr_conjunct p1 p2 = Some p\\<rbrakk> \\<Longrightarrow> valid_prefix_fw p\"", "lemma simple_match_valid_alt[code_unfold]: \"simple_match_valid = (\\<lambda> m.\n    (let c = (\\<lambda>(s,e). (s \\<noteq> 0 \\<or> e \\<noteq> max_word)) in (\n    if c (sports m) \\<or> c (dports m) then proto m = Proto TCP \\<or> proto m = Proto UDP \\<or> proto m = Proto L4_Protocol.SCTP else True)) \\<and>\n  valid_prefix_fw (src m) \\<and> valid_prefix_fw (dst m))\"", "lemma \"simple_fw [SimpleRule example_simple_match1 Drop]\n      \\<lparr>p_iiface = '''', p_oiface = '''',  p_src = (1::32 word), p_dst = 2, p_proto = TCP, p_sport = 8,\n       p_dport = 9, p_tcp_flags = {}, p_payload = ''''\\<rparr> =\n        Decision FinalDeny\"", "lemma \"simple_match_valid example_simple_match1\"", "lemma \"\\<not> simple_match_valid example_simple_match2\"", "lemma simple_match_and_valid: \n    fixes m1 :: \"'i::len simple_match\"\n    assumes mv: \"simple_match_valid m1\" \"simple_match_valid m2\"\n    assumes mj: \"simple_match_and m1 m2 = Some m\"\n    shows \"simple_match_valid m\"", "lemma simple_matches_extended_packet:\n      \"simple_matches m\n        \\<lparr>p_iiface = iifce,\n         oiface = oifce,\n         p_src = s, dst = d,\n         p_proto = prot,\n         p_sport = sport, p_dport = dport,\n         tcp_flags = tcp_flags, p_payload = payload1\\<rparr>\n        \\<longleftrightarrow>\n       simple_matches m\n        \\<lparr>p_iiface = iifce,\n         oiface = oifce,\n         p_src = s, p_dst = d,\n         p_proto = prot,\n         p_sport = sport, p_dport = dport,\n         p_tcp_flags = tcp_flags2, p_payload = payload2, \\<dots> = aux\\<rparr>\n        \""], "translations": [["", "lemma wordinterval_to_set_ipcidr_tuple_to_wordinterval_simple_match_ip_set:\n    \"wordinterval_to_set (ipcidr_tuple_to_wordinterval ip) = {d. simple_match_ip ip d}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (ipcidr_tuple_to_wordinterval ip) =\n    {d. simple_match_ip ip d}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wordinterval_to_set (ipcidr_tuple_to_wordinterval ip) =\n    {d. simple_match_ip ip d}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. wordinterval_to_set (ipcidr_tuple_to_wordinterval ip) =\n    {d. simple_match_ip ip d}", "fix s and d :: \"'a::len word \\<times> nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. wordinterval_to_set (ipcidr_tuple_to_wordinterval ip) =\n    {d. simple_match_ip ip d}", "from wordinterval_to_set_ipcidr_tuple_to_wordinterval"], ["proof (chain)\npicking this:\n  wordinterval_to_set (ipcidr_tuple_to_wordinterval (?b, ?m)) =\n  ipset_from_cidr ?b ?m", "have\n          \"s \\<in> wordinterval_to_set (ipcidr_tuple_to_wordinterval d) \\<longleftrightarrow> simple_match_ip d s\""], ["proof (prove)\nusing this:\n  wordinterval_to_set (ipcidr_tuple_to_wordinterval (?b, ?m)) =\n  ipset_from_cidr ?b ?m\n\ngoal (1 subgoal):\n 1. (s \\<in> wordinterval_to_set (ipcidr_tuple_to_wordinterval d)) =\n    simple_match_ip d s", "by(cases d) auto"], ["proof (state)\nthis:\n  (s \\<in> wordinterval_to_set (ipcidr_tuple_to_wordinterval d)) =\n  simple_match_ip d s\n\ngoal (1 subgoal):\n 1. wordinterval_to_set (ipcidr_tuple_to_wordinterval ip) =\n    {d. simple_match_ip ip d}", "}"], ["proof (state)\nthis:\n  (?s2 \\<in> wordinterval_to_set (ipcidr_tuple_to_wordinterval ?d2)) =\n  simple_match_ip ?d2 ?s2\n\ngoal (1 subgoal):\n 1. wordinterval_to_set (ipcidr_tuple_to_wordinterval ip) =\n    {d. simple_match_ip ip d}", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?s2 \\<in> wordinterval_to_set (ipcidr_tuple_to_wordinterval ?d2)) =\n  simple_match_ip ?d2 ?s2\n\ngoal (1 subgoal):\n 1. wordinterval_to_set (ipcidr_tuple_to_wordinterval ip) =\n    {d. simple_match_ip ip d}", "by blast"], ["proof (state)\nthis:\n  wordinterval_to_set (ipcidr_tuple_to_wordinterval ip) =\n  {d. simple_match_ip ip d}\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>by the way, the words do not wrap around\\<close>"], ["", "lemma \"{(253::8 word) .. 8} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {253..8} = {}", "by simp"], ["", "fun simple_match_port :: \"(16 word \\<times> 16 word) \\<Rightarrow> 16 word \\<Rightarrow> bool\" where\n    \"simple_match_port (s,e) p_p \\<longleftrightarrow> p_p \\<in> {s..e}\""], ["", "fun simple_matches :: \"'i::len simple_match \\<Rightarrow> ('i, 'a) simple_packet_scheme \\<Rightarrow> bool\" where\n    \"simple_matches m p \\<longleftrightarrow>\n      (match_iface (iiface m) (p_iiface p)) \\<and>\n      (match_iface (oiface m) (p_oiface p)) \\<and>\n      (simple_match_ip (src m) (p_src p)) \\<and>\n      (simple_match_ip (dst m) (p_dst p)) \\<and>\n      (match_proto (proto m) (p_proto p)) \\<and>\n      (simple_match_port (sports m) (p_sport p)) \\<and>\n      (simple_match_port (dports m) (p_dport p))\""], ["", "text\\<open>The semantics of a simple firewall: just iterate over the rules sequentially\\<close>"], ["", "fun simple_fw :: \"'i::len simple_rule list \\<Rightarrow> ('i, 'a) simple_packet_scheme \\<Rightarrow> state\" where\n    \"simple_fw [] _ = Undecided\" |\n    \"simple_fw ((SimpleRule m Accept)#rs) p = (if simple_matches m p then Decision FinalAllow else simple_fw rs p)\" |\n    \"simple_fw ((SimpleRule m Drop)#rs) p = (if simple_matches m p then Decision FinalDeny else simple_fw rs p)\""], ["", "fun simple_fw_alt where\n    \"simple_fw_alt [] _ = Undecided\" |\n    \"simple_fw_alt (r#rs) p = (if simple_matches (match_sel r) p then \n    \t(case action_sel r of Accept \\<Rightarrow> Decision FinalAllow | Drop \\<Rightarrow> Decision FinalDeny) else simple_fw_alt rs p)\""], ["", "lemma simple_fw_alt: \"simple_fw r p = simple_fw_alt r p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_fw r p = simple_fw_alt r p", "by(induction rule: simple_fw.induct) simp_all"], ["", "definition simple_match_any :: \"'i::len simple_match\" where\n    \"simple_match_any \\<equiv> \\<lparr>iiface=ifaceAny, oiface=ifaceAny, src=(0,0), dst=(0,0), proto=ProtoAny, sports=(0,65535), dports=(0,65535) \\<rparr>\""], ["", "lemma simple_match_any: \"simple_matches simple_match_any p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_matches simple_match_any p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. simple_matches simple_match_any p", "have *: \"(65535::16 word) = max_word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 65535 = - 1", "by simp"], ["proof (state)\nthis:\n  65535 = - 1\n\ngoal (1 subgoal):\n 1. simple_matches simple_match_any p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_matches simple_match_any p", "by (simp add: simple_match_any_def ipset_from_cidr_0 match_ifaceAny *)"], ["proof (state)\nthis:\n  simple_matches simple_match_any p\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>we specify only one empty port range\\<close>"], ["", "definition simple_match_none :: \"'i::len simple_match\" where\n    \"simple_match_none \\<equiv>\n      \\<lparr>iiface=ifaceAny, oiface=ifaceAny, src=(1,0), dst=(0,0),\n       proto=ProtoAny, sports=(1,0), dports=(0,65535) \\<rparr>\""], ["", "lemma simple_match_none: \"\\<not> simple_matches simple_match_none p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> simple_matches simple_match_none p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> simple_matches simple_match_none p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> simple_matches simple_match_none p", "by(simp add: simple_match_none_def)"], ["proof (state)\nthis:\n  \\<not> simple_matches simple_match_none p\n\ngoal:\nNo subgoals!", "qed"], ["", "fun empty_match :: \"'i::len simple_match \\<Rightarrow> bool\" where\n    \"empty_match \\<lparr>iiface=_, oiface=_, src=_, dst=_, proto=_,\n                  sports=(sps1, sps2), dports=(dps1, dps2) \\<rparr> \\<longleftrightarrow> (sps1 > sps2) \\<or> (dps1 > dps2)\""], ["", "lemma empty_match: \"empty_match m \\<longleftrightarrow> (\\<forall>(p::('i::len, 'a) simple_packet_scheme). \\<not> simple_matches m p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. empty_match m = (\\<forall>p. \\<not> simple_matches m p)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. empty_match m \\<Longrightarrow> \\<forall>p. \\<not> simple_matches m p\n 2. \\<forall>p. \\<not> simple_matches m p \\<Longrightarrow> empty_match m", "assume \"empty_match m\""], ["proof (state)\nthis:\n  empty_match m\n\ngoal (2 subgoals):\n 1. empty_match m \\<Longrightarrow> \\<forall>p. \\<not> simple_matches m p\n 2. \\<forall>p. \\<not> simple_matches m p \\<Longrightarrow> empty_match m", "thus \"\\<forall>p. \\<not> simple_matches m p\""], ["proof (prove)\nusing this:\n  empty_match m\n\ngoal (1 subgoal):\n 1. \\<forall>p. \\<not> simple_matches m p", "by(cases m) fastforce"], ["proof (state)\nthis:\n  \\<forall>p. \\<not> simple_matches m p\n\ngoal (1 subgoal):\n 1. \\<forall>p. \\<not> simple_matches m p \\<Longrightarrow> empty_match m", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>p. \\<not> simple_matches m p \\<Longrightarrow> empty_match m", "assume assm: \"\\<forall>(p::('i::len, 'a) simple_packet_scheme). \\<not> simple_matches m p\""], ["proof (state)\nthis:\n  \\<forall>p. \\<not> simple_matches m p\n\ngoal (1 subgoal):\n 1. \\<forall>p. \\<not> simple_matches m p \\<Longrightarrow> empty_match m", "obtain iif oif sip dip protocol sps1 sps2 dps1 dps2 where m:\n        \"m = \\<lparr>iiface = iif, oiface = oif, src = sip, dst = dip, proto = protocol, sports = (sps1, sps2), dports = (dps1, dps2)\\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>iif oif sip dip protocol sps1 sps2 dps1 dps2.\n        m =\n        \\<lparr>iiface = iif, oiface = oif, src = sip, dst = dip,\n           proto = protocol, sports = (sps1, sps2),\n           dports = (dps1, dps2)\\<rparr> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases m) force"], ["proof (state)\nthis:\n  m =\n  \\<lparr>iiface = iif, oiface = oif, src = sip, dst = dip,\n     proto = protocol, sports = (sps1, sps2), dports = (dps1, dps2)\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<forall>p. \\<not> simple_matches m p \\<Longrightarrow> empty_match m", "show \"empty_match m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. empty_match m", "proof(simp add: m)"], ["proof (state)\ngoal (1 subgoal):\n 1. sps2 < sps1 \\<or> dps2 < dps1", "let ?x=\"\\<lambda>p. dps1 \\<le> p_dport p \\<longrightarrow> p_sport p \\<le> sps2 \\<longrightarrow> sps1 \\<le> p_sport p \\<longrightarrow> \n              match_proto protocol (p_proto p) \\<longrightarrow> simple_match_ip dip (p_dst p) \\<longrightarrow> simple_match_ip sip (p_src p) \\<longrightarrow>\n              match_iface oif (p_oiface p) \\<longrightarrow> match_iface iif (p_iiface p) \\<longrightarrow> \\<not> p_dport p \\<le> dps2\""], ["proof (state)\ngoal (1 subgoal):\n 1. sps2 < sps1 \\<or> dps2 < dps1", "from assm"], ["proof (chain)\npicking this:\n  \\<forall>p. \\<not> simple_matches m p", "have nomatch: \"\\<forall>(p::('i::len, 'a) simple_packet_scheme). ?x p\""], ["proof (prove)\nusing this:\n  \\<forall>p. \\<not> simple_matches m p\n\ngoal (1 subgoal):\n 1. \\<forall>p.\n       dps1 \\<le> p_dport p \\<longrightarrow>\n       p_sport p \\<le> sps2 \\<longrightarrow>\n       sps1 \\<le> p_sport p \\<longrightarrow>\n       match_proto protocol (p_proto p) \\<longrightarrow>\n       simple_match_ip dip (p_dst p) \\<longrightarrow>\n       simple_match_ip sip (p_src p) \\<longrightarrow>\n       match_iface oif (p_oiface p) \\<longrightarrow>\n       match_iface iif (p_iiface p) \\<longrightarrow>\n       \\<not> p_dport p \\<le> dps2", "by(simp add: m)"], ["proof (state)\nthis:\n  \\<forall>p.\n     dps1 \\<le> p_dport p \\<longrightarrow>\n     p_sport p \\<le> sps2 \\<longrightarrow>\n     sps1 \\<le> p_sport p \\<longrightarrow>\n     match_proto protocol (p_proto p) \\<longrightarrow>\n     simple_match_ip dip (p_dst p) \\<longrightarrow>\n     simple_match_ip sip (p_src p) \\<longrightarrow>\n     match_iface oif (p_oiface p) \\<longrightarrow>\n     match_iface iif (p_iiface p) \\<longrightarrow>\n     \\<not> p_dport p \\<le> dps2\n\ngoal (1 subgoal):\n 1. sps2 < sps1 \\<or> dps2 < dps1", "{"], ["proof (state)\nthis:\n  \\<forall>p.\n     dps1 \\<le> p_dport p \\<longrightarrow>\n     p_sport p \\<le> sps2 \\<longrightarrow>\n     sps1 \\<le> p_sport p \\<longrightarrow>\n     match_proto protocol (p_proto p) \\<longrightarrow>\n     simple_match_ip dip (p_dst p) \\<longrightarrow>\n     simple_match_ip sip (p_src p) \\<longrightarrow>\n     match_iface oif (p_oiface p) \\<longrightarrow>\n     match_iface iif (p_iiface p) \\<longrightarrow>\n     \\<not> p_dport p \\<le> dps2\n\ngoal (1 subgoal):\n 1. sps2 < sps1 \\<or> dps2 < dps1", "fix ips::\"'i::len word \\<times> nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. sps2 < sps1 \\<or> dps2 < dps1", "have \"a \\<in> ipset_from_cidr a n\" for a::\"'i::len word\" and n"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> ipset_from_cidr a n", "using ipset_from_cidr_lowest"], ["proof (prove)\nusing this:\n  ?a \\<in> ipset_from_cidr ?a ?n\n\ngoal (1 subgoal):\n 1. a \\<in> ipset_from_cidr a n", "by auto"], ["proof (state)\nthis:\n  ?a1 \\<in> ipset_from_cidr ?a1 ?n1\n\ngoal (1 subgoal):\n 1. sps2 < sps1 \\<or> dps2 < dps1", "hence \"simple_match_ip ips (fst ips)\""], ["proof (prove)\nusing this:\n  ?a1 \\<in> ipset_from_cidr ?a1 ?n1\n\ngoal (1 subgoal):\n 1. simple_match_ip ips (fst ips)", "by(cases ips) simp"], ["proof (state)\nthis:\n  simple_match_ip ips (fst ips)\n\ngoal (1 subgoal):\n 1. sps2 < sps1 \\<or> dps2 < dps1", "}"], ["proof (state)\nthis:\n  simple_match_ip ?ips3 (fst ?ips3)\n\ngoal (1 subgoal):\n 1. sps2 < sps1 \\<or> dps2 < dps1", "note ips=this"], ["proof (state)\nthis:\n  simple_match_ip ?ips3 (fst ?ips3)\n\ngoal (1 subgoal):\n 1. sps2 < sps1 \\<or> dps2 < dps1", "have proto: \"match_proto protocol (case protocol of ProtoAny \\<Rightarrow> TCP | Proto p \\<Rightarrow> p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_proto protocol\n     (case protocol of ProtoAny \\<Rightarrow> TCP | Proto p \\<Rightarrow> p)", "by(simp split: protocol.split)"], ["proof (state)\nthis:\n  match_proto protocol\n   (case protocol of ProtoAny \\<Rightarrow> TCP | Proto p \\<Rightarrow> p)\n\ngoal (1 subgoal):\n 1. sps2 < sps1 \\<or> dps2 < dps1", "{"], ["proof (state)\nthis:\n  match_proto protocol\n   (case protocol of ProtoAny \\<Rightarrow> TCP | Proto p \\<Rightarrow> p)\n\ngoal (1 subgoal):\n 1. sps2 < sps1 \\<or> dps2 < dps1", "fix ifce"], ["proof (state)\ngoal (1 subgoal):\n 1. sps2 < sps1 \\<or> dps2 < dps1", "have \" match_iface ifce (iface_sel ifce)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_iface ifce (iface_sel ifce)", "by(cases ifce) (simp add: match_iface_refl)"], ["proof (state)\nthis:\n  match_iface ifce (iface_sel ifce)\n\ngoal (1 subgoal):\n 1. sps2 < sps1 \\<or> dps2 < dps1", "}"], ["proof (state)\nthis:\n  match_iface ?ifce3 (iface_sel ?ifce3)\n\ngoal (1 subgoal):\n 1. sps2 < sps1 \\<or> dps2 < dps1", "note ifaces=this"], ["proof (state)\nthis:\n  match_iface ?ifce3 (iface_sel ?ifce3)\n\ngoal (1 subgoal):\n 1. sps2 < sps1 \\<or> dps2 < dps1", "{"], ["proof (state)\nthis:\n  match_iface ?ifce3 (iface_sel ?ifce3)\n\ngoal (1 subgoal):\n 1. sps2 < sps1 \\<or> dps2 < dps1", "fix p::\"('i, 'a) simple_packet_scheme\""], ["proof (state)\ngoal (1 subgoal):\n 1. sps2 < sps1 \\<or> dps2 < dps1", "from nomatch"], ["proof (chain)\npicking this:\n  \\<forall>p.\n     dps1 \\<le> p_dport p \\<longrightarrow>\n     p_sport p \\<le> sps2 \\<longrightarrow>\n     sps1 \\<le> p_sport p \\<longrightarrow>\n     match_proto protocol (p_proto p) \\<longrightarrow>\n     simple_match_ip dip (p_dst p) \\<longrightarrow>\n     simple_match_ip sip (p_src p) \\<longrightarrow>\n     match_iface oif (p_oiface p) \\<longrightarrow>\n     match_iface iif (p_iiface p) \\<longrightarrow>\n     \\<not> p_dport p \\<le> dps2", "have \"?x p\""], ["proof (prove)\nusing this:\n  \\<forall>p.\n     dps1 \\<le> p_dport p \\<longrightarrow>\n     p_sport p \\<le> sps2 \\<longrightarrow>\n     sps1 \\<le> p_sport p \\<longrightarrow>\n     match_proto protocol (p_proto p) \\<longrightarrow>\n     simple_match_ip dip (p_dst p) \\<longrightarrow>\n     simple_match_ip sip (p_src p) \\<longrightarrow>\n     match_iface oif (p_oiface p) \\<longrightarrow>\n     match_iface iif (p_iiface p) \\<longrightarrow>\n     \\<not> p_dport p \\<le> dps2\n\ngoal (1 subgoal):\n 1. dps1 \\<le> p_dport p \\<longrightarrow>\n    p_sport p \\<le> sps2 \\<longrightarrow>\n    sps1 \\<le> p_sport p \\<longrightarrow>\n    match_proto protocol (p_proto p) \\<longrightarrow>\n    simple_match_ip dip (p_dst p) \\<longrightarrow>\n    simple_match_ip sip (p_src p) \\<longrightarrow>\n    match_iface oif (p_oiface p) \\<longrightarrow>\n    match_iface iif (p_iiface p) \\<longrightarrow>\n    \\<not> p_dport p \\<le> dps2", "by blast"], ["proof (state)\nthis:\n  dps1 \\<le> p_dport p \\<longrightarrow>\n  p_sport p \\<le> sps2 \\<longrightarrow>\n  sps1 \\<le> p_sport p \\<longrightarrow>\n  match_proto protocol (p_proto p) \\<longrightarrow>\n  simple_match_ip dip (p_dst p) \\<longrightarrow>\n  simple_match_ip sip (p_src p) \\<longrightarrow>\n  match_iface oif (p_oiface p) \\<longrightarrow>\n  match_iface iif (p_iiface p) \\<longrightarrow> \\<not> p_dport p \\<le> dps2\n\ngoal (1 subgoal):\n 1. sps2 < sps1 \\<or> dps2 < dps1", "}"], ["proof (state)\nthis:\n  dps1 \\<le> p_dport ?p3 \\<longrightarrow>\n  p_sport ?p3 \\<le> sps2 \\<longrightarrow>\n  sps1 \\<le> p_sport ?p3 \\<longrightarrow>\n  match_proto protocol (p_proto ?p3) \\<longrightarrow>\n  simple_match_ip dip (p_dst ?p3) \\<longrightarrow>\n  simple_match_ip sip (p_src ?p3) \\<longrightarrow>\n  match_iface oif (p_oiface ?p3) \\<longrightarrow>\n  match_iface iif (p_iiface ?p3) \\<longrightarrow>\n  \\<not> p_dport ?p3 \\<le> dps2\n\ngoal (1 subgoal):\n 1. sps2 < sps1 \\<or> dps2 < dps1", "note pkt1=this"], ["proof (state)\nthis:\n  dps1 \\<le> p_dport ?p3 \\<longrightarrow>\n  p_sport ?p3 \\<le> sps2 \\<longrightarrow>\n  sps1 \\<le> p_sport ?p3 \\<longrightarrow>\n  match_proto protocol (p_proto ?p3) \\<longrightarrow>\n  simple_match_ip dip (p_dst ?p3) \\<longrightarrow>\n  simple_match_ip sip (p_src ?p3) \\<longrightarrow>\n  match_iface oif (p_oiface ?p3) \\<longrightarrow>\n  match_iface iif (p_iiface ?p3) \\<longrightarrow>\n  \\<not> p_dport ?p3 \\<le> dps2\n\ngoal (1 subgoal):\n 1. sps2 < sps1 \\<or> dps2 < dps1", "obtain p::\"('i, 'a) simple_packet_scheme\" where [simp]:\n\t\t\t  \"p_iiface p = iface_sel iif\"\n\t\t\t  \"p_oiface p = iface_sel oif\"\n\t\t\t  \"p_src p = fst sip\"\n\t\t\t  \"p_dst p = fst dip\"\n\t\t\t  \"p_proto p = (case protocol of ProtoAny \\<Rightarrow> TCP | Proto p \\<Rightarrow> p)\"\n\t\t\t  \"p_sport p = sps1\"\n\t\t\t  \"p_dport p = dps1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<lbrakk>p_iiface p = iface_sel iif; p_oiface p = iface_sel oif;\n         p_src p = fst sip; p_dst p = fst dip;\n         p_proto p =\n         (case protocol of ProtoAny \\<Rightarrow> TCP\n          | Proto p \\<Rightarrow> p);\n         p_sport p = sps1; p_dport p = dps1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson simple_packet.select_convs)"], ["proof (state)\nthis:\n  p_iiface p = iface_sel iif\n  p_oiface p = iface_sel oif\n  p_src p = fst sip\n  p_dst p = fst dip\n  p_proto p =\n  (case protocol of ProtoAny \\<Rightarrow> TCP | Proto p \\<Rightarrow> p)\n  p_sport p = sps1\n  p_dport p = dps1\n\ngoal (1 subgoal):\n 1. sps2 < sps1 \\<or> dps2 < dps1", "note pkt=pkt1[of p, simplified]"], ["proof (state)\nthis:\n  sps1 \\<le> sps2 \\<longrightarrow>\n  match_proto protocol\n   (case protocol of ProtoAny \\<Rightarrow> TCP\n    | Proto p \\<Rightarrow> p) \\<longrightarrow>\n  simple_match_ip dip (fst dip) \\<longrightarrow>\n  simple_match_ip sip (fst sip) \\<longrightarrow>\n  match_iface oif (iface_sel oif) \\<longrightarrow>\n  match_iface iif (iface_sel iif) \\<longrightarrow> \\<not> dps1 \\<le> dps2\n\ngoal (1 subgoal):\n 1. sps2 < sps1 \\<or> dps2 < dps1", "from pkt ips proto ifaces"], ["proof (chain)\npicking this:\n  sps1 \\<le> sps2 \\<longrightarrow>\n  match_proto protocol\n   (case protocol of ProtoAny \\<Rightarrow> TCP\n    | Proto p \\<Rightarrow> p) \\<longrightarrow>\n  simple_match_ip dip (fst dip) \\<longrightarrow>\n  simple_match_ip sip (fst sip) \\<longrightarrow>\n  match_iface oif (iface_sel oif) \\<longrightarrow>\n  match_iface iif (iface_sel iif) \\<longrightarrow> \\<not> dps1 \\<le> dps2\n  simple_match_ip ?ips3 (fst ?ips3)\n  match_proto protocol\n   (case protocol of ProtoAny \\<Rightarrow> TCP | Proto p \\<Rightarrow> p)\n  match_iface ?ifce3 (iface_sel ?ifce3)", "have \" sps1 \\<le> sps2 \\<longrightarrow> \\<not> dps1 \\<le> dps2\""], ["proof (prove)\nusing this:\n  sps1 \\<le> sps2 \\<longrightarrow>\n  match_proto protocol\n   (case protocol of ProtoAny \\<Rightarrow> TCP\n    | Proto p \\<Rightarrow> p) \\<longrightarrow>\n  simple_match_ip dip (fst dip) \\<longrightarrow>\n  simple_match_ip sip (fst sip) \\<longrightarrow>\n  match_iface oif (iface_sel oif) \\<longrightarrow>\n  match_iface iif (iface_sel iif) \\<longrightarrow> \\<not> dps1 \\<le> dps2\n  simple_match_ip ?ips3 (fst ?ips3)\n  match_proto protocol\n   (case protocol of ProtoAny \\<Rightarrow> TCP | Proto p \\<Rightarrow> p)\n  match_iface ?ifce3 (iface_sel ?ifce3)\n\ngoal (1 subgoal):\n 1. sps1 \\<le> sps2 \\<longrightarrow> \\<not> dps1 \\<le> dps2", "by blast"], ["proof (state)\nthis:\n  sps1 \\<le> sps2 \\<longrightarrow> \\<not> dps1 \\<le> dps2\n\ngoal (1 subgoal):\n 1. sps2 < sps1 \\<or> dps2 < dps1", "thus \"sps2 < sps1 \\<or> dps2 < dps1\""], ["proof (prove)\nusing this:\n  sps1 \\<le> sps2 \\<longrightarrow> \\<not> dps1 \\<le> dps2\n\ngoal (1 subgoal):\n 1. sps2 < sps1 \\<or> dps2 < dps1", "by fastforce"], ["proof (state)\nthis:\n  sps2 < sps1 \\<or> dps2 < dps1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  empty_match m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nomatch: \"\\<not> simple_matches m p \\<Longrightarrow> simple_fw (SimpleRule m a # rs) p = simple_fw rs p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> simple_matches m p \\<Longrightarrow>\n    simple_fw (SimpleRule m a # rs) p = simple_fw rs p", "by(cases a, simp_all del: simple_matches.simps)"], ["", "subsection\\<open>Simple Ports\\<close>"], ["", "fun simpl_ports_conjunct :: \"(16 word \\<times> 16 word) \\<Rightarrow> (16 word \\<times> 16 word) \\<Rightarrow> (16 word \\<times> 16 word)\" where\n    \"simpl_ports_conjunct (p1s, p1e) (p2s, p2e) = (max p1s p2s, min p1e p2e)\""], ["", "lemma \"{(p1s:: 16 word) .. p1e} \\<inter> {p2s .. p2e} = {max p1s p2s .. min p1e p2e}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {p1s..p1e} \\<inter> {p2s..p2e} = {max p1s p2s..min p1e p2e}", "by(simp)"], ["", "lemma simple_ports_conjunct_correct:\n    \"simple_match_port p1 pkt \\<and> simple_match_port p2 pkt \\<longleftrightarrow> simple_match_port (simpl_ports_conjunct p1 p2) pkt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (simple_match_port p1 pkt \\<and> simple_match_port p2 pkt) =\n    simple_match_port (simpl_ports_conjunct p1 p2) pkt", "apply(cases p1, cases p2, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>p1 = (a, b); p2 = (aa, ba)\\<rbrakk>\n       \\<Longrightarrow> (a \\<le> pkt \\<and>\n                          pkt \\<le> b \\<and>\n                          aa \\<le> pkt \\<and> pkt \\<le> ba) =\n                         (a \\<le> pkt \\<and>\n                          aa \\<le> pkt \\<and>\n                          pkt \\<le> b \\<and> pkt \\<le> ba)", "by blast"], ["", "lemma simple_match_port_code[code] :\"simple_match_port (s,e) p_p = (s \\<le> p_p \\<and> p_p \\<le> e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_match_port (s, e) p_p = (s \\<le> p_p \\<and> p_p \\<le> e)", "by simp"], ["", "lemma simple_match_port_UNIV: \"{p. simple_match_port (s,e) p} = UNIV \\<longleftrightarrow> (s = 0 \\<and> e = max_word)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({p. simple_match_port (s, e) p} = UNIV) = (s = 0 \\<and> e = - 1)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({p. s \\<le> p \\<and> p \\<le> e} = UNIV) = (s = 0 \\<and> e = - 1)", "apply(rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. {p. s \\<le> p \\<and> p \\<le> e} = UNIV \\<Longrightarrow>\n    s = 0 \\<and> e = - 1\n 2. s = 0 \\<and> e = - 1 \\<Longrightarrow>\n    {p. s \\<le> p \\<and> p \\<le> e} = UNIV", "apply(case_tac \"s = 0\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>{p. s \\<le> p \\<and> p \\<le> e} = UNIV; s = 0\\<rbrakk>\n    \\<Longrightarrow> s = 0 \\<and> e = - 1\n 2. \\<lbrakk>{p. s \\<le> p \\<and> p \\<le> e} = UNIV; s \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> s = 0 \\<and> e = - 1\n 3. s = 0 \\<and> e = - 1 \\<Longrightarrow>\n    {p. s \\<le> p \\<and> p \\<le> e} = UNIV", "using antisym_conv"], ["proof (prove)\nusing this:\n  ?y \\<le> ?x \\<Longrightarrow> (?x \\<le> ?y) = (?x = ?y)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>{p. s \\<le> p \\<and> p \\<le> e} = UNIV; s = 0\\<rbrakk>\n    \\<Longrightarrow> s = 0 \\<and> e = - 1\n 2. \\<lbrakk>{p. s \\<le> p \\<and> p \\<le> e} = UNIV; s \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> s = 0 \\<and> e = - 1\n 3. s = 0 \\<and> e = - 1 \\<Longrightarrow>\n    {p. s \\<le> p \\<and> p \\<le> e} = UNIV", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>{p. s \\<le> p \\<and> p \\<le> e} = UNIV; s \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> s = 0 \\<and> e = - 1\n 2. s = 0 \\<and> e = - 1 \\<Longrightarrow>\n    {p. s \\<le> p \\<and> p \\<le> e} = UNIV", "using word_le_0_iff"], ["proof (prove)\nusing this:\n  (?x \\<le> 0) = (?x = 0)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>{p. s \\<le> p \\<and> p \\<le> e} = UNIV; s \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> s = 0 \\<and> e = - 1\n 2. s = 0 \\<and> e = - 1 \\<Longrightarrow>\n    {p. s \\<le> p \\<and> p \\<le> e} = UNIV", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. s = 0 \\<and> e = - 1 \\<Longrightarrow>\n    {p. s \\<le> p \\<and> p \\<le> e} = UNIV", "using word_zero_le"], ["proof (prove)\nusing this:\n  0 \\<le> ?y\n\ngoal (1 subgoal):\n 1. s = 0 \\<and> e = - 1 \\<Longrightarrow>\n    {p. s \\<le> p \\<and> p \\<le> e} = UNIV", "by blast"], ["", "subsection\\<open>Simple IPs\\<close>"], ["", "lemma simple_match_ip_conjunct:\n    fixes ip1 :: \"'i::len word \\<times> nat\"\n    shows \"simple_match_ip ip1 p_ip \\<and> simple_match_ip ip2 p_ip \\<longleftrightarrow> \n            (case ipcidr_conjunct ip1 ip2 of None \\<Rightarrow> False | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (simple_match_ip ip1 p_ip \\<and> simple_match_ip ip2 p_ip) =\n    (case ipcidr_conjunct ip1 ip2 of None \\<Rightarrow> False\n     | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (simple_match_ip ip1 p_ip \\<and> simple_match_ip ip2 p_ip) =\n    (case ipcidr_conjunct ip1 ip2 of None \\<Rightarrow> False\n     | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (simple_match_ip ip1 p_ip \\<and> simple_match_ip ip2 p_ip) =\n    (case ipcidr_conjunct ip1 ip2 of None \\<Rightarrow> False\n     | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)", "fix b1 m1 b2 m2"], ["proof (state)\ngoal (1 subgoal):\n 1. (simple_match_ip ip1 p_ip \\<and> simple_match_ip ip2 p_ip) =\n    (case ipcidr_conjunct ip1 ip2 of None \\<Rightarrow> False\n     | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)", "have \"simple_match_ip (b1, m1) p_ip \\<and> simple_match_ip (b2, m2) p_ip \\<longleftrightarrow> \n          p_ip \\<in> ipset_from_cidr b1 m1 \\<inter> ipset_from_cidr b2 m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (simple_match_ip (b1, m1) p_ip \\<and> simple_match_ip (b2, m2) p_ip) =\n    (p_ip \\<in> ipset_from_cidr b1 m1 \\<inter> ipset_from_cidr b2 m2)", "by simp"], ["proof (state)\nthis:\n  (simple_match_ip (b1, m1) p_ip \\<and> simple_match_ip (b2, m2) p_ip) =\n  (p_ip \\<in> ipset_from_cidr b1 m1 \\<inter> ipset_from_cidr b2 m2)\n\ngoal (1 subgoal):\n 1. (simple_match_ip ip1 p_ip \\<and> simple_match_ip ip2 p_ip) =\n    (case ipcidr_conjunct ip1 ip2 of None \\<Rightarrow> False\n     | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)", "also"], ["proof (state)\nthis:\n  (simple_match_ip (b1, m1) p_ip \\<and> simple_match_ip (b2, m2) p_ip) =\n  (p_ip \\<in> ipset_from_cidr b1 m1 \\<inter> ipset_from_cidr b2 m2)\n\ngoal (1 subgoal):\n 1. (simple_match_ip ip1 p_ip \\<and> simple_match_ip ip2 p_ip) =\n    (case ipcidr_conjunct ip1 ip2 of None \\<Rightarrow> False\n     | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)", "have \"\\<dots> \\<longleftrightarrow> p_ip \\<in> (case ipcidr_conjunct (b1, m1) (b2, m2) of None \\<Rightarrow> {} | Some (bx, mx) \\<Rightarrow> ipset_from_cidr bx mx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p_ip \\<in> ipset_from_cidr b1 m1 \\<inter> ipset_from_cidr b2 m2) =\n    (p_ip\n     \\<in> (case ipcidr_conjunct (b1, m1) (b2, m2) of None \\<Rightarrow> {}\n            | Some (bx, mx) \\<Rightarrow> ipset_from_cidr bx mx))", "using ipcidr_conjunct_correct"], ["proof (prove)\nusing this:\n  (case ipcidr_conjunct (?b1.0, ?m1.0) (?b2.0, ?m2.0) of\n   None \\<Rightarrow> {}\n   | Some (bx, mx) \\<Rightarrow> ipset_from_cidr bx mx) =\n  ipset_from_cidr ?b1.0 ?m1.0 \\<inter> ipset_from_cidr ?b2.0 ?m2.0\n\ngoal (1 subgoal):\n 1. (p_ip \\<in> ipset_from_cidr b1 m1 \\<inter> ipset_from_cidr b2 m2) =\n    (p_ip\n     \\<in> (case ipcidr_conjunct (b1, m1) (b2, m2) of None \\<Rightarrow> {}\n            | Some (bx, mx) \\<Rightarrow> ipset_from_cidr bx mx))", "by blast"], ["proof (state)\nthis:\n  (p_ip \\<in> ipset_from_cidr b1 m1 \\<inter> ipset_from_cidr b2 m2) =\n  (p_ip\n   \\<in> (case ipcidr_conjunct (b1, m1) (b2, m2) of None \\<Rightarrow> {}\n          | Some (bx, mx) \\<Rightarrow> ipset_from_cidr bx mx))\n\ngoal (1 subgoal):\n 1. (simple_match_ip ip1 p_ip \\<and> simple_match_ip ip2 p_ip) =\n    (case ipcidr_conjunct ip1 ip2 of None \\<Rightarrow> False\n     | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)", "also"], ["proof (state)\nthis:\n  (p_ip \\<in> ipset_from_cidr b1 m1 \\<inter> ipset_from_cidr b2 m2) =\n  (p_ip\n   \\<in> (case ipcidr_conjunct (b1, m1) (b2, m2) of None \\<Rightarrow> {}\n          | Some (bx, mx) \\<Rightarrow> ipset_from_cidr bx mx))\n\ngoal (1 subgoal):\n 1. (simple_match_ip ip1 p_ip \\<and> simple_match_ip ip2 p_ip) =\n    (case ipcidr_conjunct ip1 ip2 of None \\<Rightarrow> False\n     | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)", "have \"\\<dots> \\<longleftrightarrow> (case ipcidr_conjunct (b1, m1) (b2, m2) of None \\<Rightarrow> False | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p_ip\n     \\<in> (case ipcidr_conjunct (b1, m1) (b2, m2) of None \\<Rightarrow> {}\n            | Some (bx, mx) \\<Rightarrow> ipset_from_cidr bx mx)) =\n    (case ipcidr_conjunct (b1, m1) (b2, m2) of None \\<Rightarrow> False\n     | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)", "by(simp split: option.split)"], ["proof (state)\nthis:\n  (p_ip\n   \\<in> (case ipcidr_conjunct (b1, m1) (b2, m2) of None \\<Rightarrow> {}\n          | Some (bx, mx) \\<Rightarrow> ipset_from_cidr bx mx)) =\n  (case ipcidr_conjunct (b1, m1) (b2, m2) of None \\<Rightarrow> False\n   | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)\n\ngoal (1 subgoal):\n 1. (simple_match_ip ip1 p_ip \\<and> simple_match_ip ip2 p_ip) =\n    (case ipcidr_conjunct ip1 ip2 of None \\<Rightarrow> False\n     | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)", "finally"], ["proof (chain)\npicking this:\n  (simple_match_ip (b1, m1) p_ip \\<and> simple_match_ip (b2, m2) p_ip) =\n  (case ipcidr_conjunct (b1, m1) (b2, m2) of None \\<Rightarrow> False\n   | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)", "have \"simple_match_ip (b1, m1) p_ip \\<and> simple_match_ip (b2, m2) p_ip \\<longleftrightarrow> \n         (case ipcidr_conjunct (b1, m1) (b2, m2) of None \\<Rightarrow> False | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)\""], ["proof (prove)\nusing this:\n  (simple_match_ip (b1, m1) p_ip \\<and> simple_match_ip (b2, m2) p_ip) =\n  (case ipcidr_conjunct (b1, m1) (b2, m2) of None \\<Rightarrow> False\n   | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)\n\ngoal (1 subgoal):\n 1. (simple_match_ip (b1, m1) p_ip \\<and> simple_match_ip (b2, m2) p_ip) =\n    (case ipcidr_conjunct (b1, m1) (b2, m2) of None \\<Rightarrow> False\n     | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)", "."], ["proof (state)\nthis:\n  (simple_match_ip (b1, m1) p_ip \\<and> simple_match_ip (b2, m2) p_ip) =\n  (case ipcidr_conjunct (b1, m1) (b2, m2) of None \\<Rightarrow> False\n   | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)\n\ngoal (1 subgoal):\n 1. (simple_match_ip ip1 p_ip \\<and> simple_match_ip ip2 p_ip) =\n    (case ipcidr_conjunct ip1 ip2 of None \\<Rightarrow> False\n     | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)", "}"], ["proof (state)\nthis:\n  (simple_match_ip (?b1.2, ?m1.2) p_ip \\<and>\n   simple_match_ip (?b2.2, ?m2.2) p_ip) =\n  (case ipcidr_conjunct (?b1.2, ?m1.2) (?b2.2, ?m2.2) of\n   None \\<Rightarrow> False\n   | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)\n\ngoal (1 subgoal):\n 1. (simple_match_ip ip1 p_ip \\<and> simple_match_ip ip2 p_ip) =\n    (case ipcidr_conjunct ip1 ip2 of None \\<Rightarrow> False\n     | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (simple_match_ip (?b1.2, ?m1.2) p_ip \\<and>\n   simple_match_ip (?b2.2, ?m2.2) p_ip) =\n  (case ipcidr_conjunct (?b1.2, ?m1.2) (?b2.2, ?m2.2) of\n   None \\<Rightarrow> False\n   | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)\n\ngoal (1 subgoal):\n 1. (simple_match_ip ip1 p_ip \\<and> simple_match_ip ip2 p_ip) =\n    (case ipcidr_conjunct ip1 ip2 of None \\<Rightarrow> False\n     | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)", "by(cases ip1, cases ip2, simp)"], ["proof (state)\nthis:\n  (simple_match_ip ip1 p_ip \\<and> simple_match_ip ip2 p_ip) =\n  (case ipcidr_conjunct ip1 ip2 of None \\<Rightarrow> False\n   | Some ipx \\<Rightarrow> simple_match_ip ipx p_ip)\n\ngoal:\nNo subgoals!", "qed"], ["", "declare simple_matches.simps[simp del]"], ["", "subsection\\<open>Merging Simple Matches\\<close>"], ["", "text\\<open>@{typ \"'i::len simple_match\"} \\<open>\\<and>\\<close> @{typ \"'i::len simple_match\"}\\<close>"], ["", "fun simple_match_and :: \"'i::len simple_match \\<Rightarrow> 'i simple_match \\<Rightarrow> 'i simple_match option\" where\n    \"simple_match_and \\<lparr>iiface=iif1, oiface=oif1, src=sip1, dst=dip1, proto=p1, sports=sps1, dports=dps1 \\<rparr> \n                      \\<lparr>iiface=iif2, oiface=oif2, src=sip2, dst=dip2, proto=p2, sports=sps2, dports=dps2 \\<rparr> = \n      (case ipcidr_conjunct sip1 sip2 of None \\<Rightarrow> None | Some sip \\<Rightarrow> \n      (case ipcidr_conjunct dip1 dip2 of None \\<Rightarrow> None | Some dip \\<Rightarrow> \n      (case iface_conjunct iif1 iif2 of None \\<Rightarrow> None | Some iif \\<Rightarrow>\n      (case iface_conjunct oif1 oif2 of None \\<Rightarrow> None | Some oif \\<Rightarrow>\n      (case simple_proto_conjunct p1 p2 of None \\<Rightarrow> None | Some p \\<Rightarrow>\n      Some \\<lparr>iiface=iif, oiface=oif, src=sip, dst=dip, proto=p,\n            sports=simpl_ports_conjunct sps1 sps2, dports=simpl_ports_conjunct dps1 dps2 \\<rparr>)))))\""], ["", "lemma simple_match_and_correct: \"simple_matches m1 p \\<and> simple_matches m2 p \\<longleftrightarrow> \n    (case simple_match_and m1 m2 of None \\<Rightarrow> False | Some m \\<Rightarrow> simple_matches m p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (simple_matches m1 p \\<and> simple_matches m2 p) =\n    (case simple_match_and m1 m2 of None \\<Rightarrow> False\n     | Some m \\<Rightarrow> simple_matches m p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (simple_matches m1 p \\<and> simple_matches m2 p) =\n    (case simple_match_and m1 m2 of None \\<Rightarrow> False\n     | Some m \\<Rightarrow> simple_matches m p)", "obtain iif1 oif1 sip1 dip1 p1 sps1 dps1 where m1:\n        \"m1 = \\<lparr>iiface=iif1, oiface=oif1, src=sip1, dst=dip1, proto=p1, sports=sps1, dports=dps1 \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>iif1 oif1 sip1 dip1 p1 sps1 dps1.\n        m1 =\n        \\<lparr>iiface = iif1, oiface = oif1, src = sip1, dst = dip1,\n           proto = p1, sports = sps1,\n           dports = dps1\\<rparr> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases m1, blast)"], ["proof (state)\nthis:\n  m1 =\n  \\<lparr>iiface = iif1, oiface = oif1, src = sip1, dst = dip1, proto = p1,\n     sports = sps1, dports = dps1\\<rparr>\n\ngoal (1 subgoal):\n 1. (simple_matches m1 p \\<and> simple_matches m2 p) =\n    (case simple_match_and m1 m2 of None \\<Rightarrow> False\n     | Some m \\<Rightarrow> simple_matches m p)", "obtain iif2 oif2 sip2 dip2 p2 sps2 dps2 where m2:\n        \"m2 = \\<lparr>iiface=iif2, oiface=oif2, src=sip2, dst=dip2, proto=p2, sports=sps2, dports=dps2 \\<rparr>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>iif2 oif2 sip2 dip2 p2 sps2 dps2.\n        m2 =\n        \\<lparr>iiface = iif2, oiface = oif2, src = sip2, dst = dip2,\n           proto = p2, sports = sps2,\n           dports = dps2\\<rparr> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(cases m2, blast)"], ["proof (state)\nthis:\n  m2 =\n  \\<lparr>iiface = iif2, oiface = oif2, src = sip2, dst = dip2, proto = p2,\n     sports = sps2, dports = dps2\\<rparr>\n\ngoal (1 subgoal):\n 1. (simple_matches m1 p \\<and> simple_matches m2 p) =\n    (case simple_match_and m1 m2 of None \\<Rightarrow> False\n     | Some m \\<Rightarrow> simple_matches m p)", "have sip_None: \"ipcidr_conjunct sip1 sip2 = None \\<Longrightarrow> \\<not> simple_match_ip sip1 (p_src p) \\<or> \\<not> simple_match_ip sip2 (p_src p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipcidr_conjunct sip1 sip2 = None \\<Longrightarrow>\n    \\<not> simple_match_ip sip1 (p_src p) \\<or>\n    \\<not> simple_match_ip sip2 (p_src p)", "using simple_match_ip_conjunct[of sip1 \"p_src p\" sip2]"], ["proof (prove)\nusing this:\n  (simple_match_ip sip1 (p_src p) \\<and> simple_match_ip sip2 (p_src p)) =\n  (case ipcidr_conjunct sip1 sip2 of None \\<Rightarrow> False\n   | Some ipx \\<Rightarrow> simple_match_ip ipx (p_src p))\n\ngoal (1 subgoal):\n 1. ipcidr_conjunct sip1 sip2 = None \\<Longrightarrow>\n    \\<not> simple_match_ip sip1 (p_src p) \\<or>\n    \\<not> simple_match_ip sip2 (p_src p)", "by simp"], ["proof (state)\nthis:\n  ipcidr_conjunct sip1 sip2 = None \\<Longrightarrow>\n  \\<not> simple_match_ip sip1 (p_src p) \\<or>\n  \\<not> simple_match_ip sip2 (p_src p)\n\ngoal (1 subgoal):\n 1. (simple_matches m1 p \\<and> simple_matches m2 p) =\n    (case simple_match_and m1 m2 of None \\<Rightarrow> False\n     | Some m \\<Rightarrow> simple_matches m p)", "have dip_None: \"ipcidr_conjunct dip1 dip2 = None \\<Longrightarrow> \\<not> simple_match_ip dip1 (p_dst p) \\<or> \\<not> simple_match_ip dip2 (p_dst p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipcidr_conjunct dip1 dip2 = None \\<Longrightarrow>\n    \\<not> simple_match_ip dip1 (p_dst p) \\<or>\n    \\<not> simple_match_ip dip2 (p_dst p)", "using simple_match_ip_conjunct[of dip1 \"p_dst p\" dip2]"], ["proof (prove)\nusing this:\n  (simple_match_ip dip1 (p_dst p) \\<and> simple_match_ip dip2 (p_dst p)) =\n  (case ipcidr_conjunct dip1 dip2 of None \\<Rightarrow> False\n   | Some ipx \\<Rightarrow> simple_match_ip ipx (p_dst p))\n\ngoal (1 subgoal):\n 1. ipcidr_conjunct dip1 dip2 = None \\<Longrightarrow>\n    \\<not> simple_match_ip dip1 (p_dst p) \\<or>\n    \\<not> simple_match_ip dip2 (p_dst p)", "by simp"], ["proof (state)\nthis:\n  ipcidr_conjunct dip1 dip2 = None \\<Longrightarrow>\n  \\<not> simple_match_ip dip1 (p_dst p) \\<or>\n  \\<not> simple_match_ip dip2 (p_dst p)\n\ngoal (1 subgoal):\n 1. (simple_matches m1 p \\<and> simple_matches m2 p) =\n    (case simple_match_and m1 m2 of None \\<Rightarrow> False\n     | Some m \\<Rightarrow> simple_matches m p)", "have sip_Some: \"\\<And>ip. ipcidr_conjunct sip1 sip2 = Some ip \\<Longrightarrow>\n        simple_match_ip ip (p_src p) \\<longleftrightarrow> simple_match_ip sip1 (p_src p) \\<and> simple_match_ip sip2 (p_src p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ip.\n       ipcidr_conjunct sip1 sip2 = Some ip \\<Longrightarrow>\n       simple_match_ip ip (p_src p) =\n       (simple_match_ip sip1 (p_src p) \\<and>\n        simple_match_ip sip2 (p_src p))", "using simple_match_ip_conjunct[of sip1 \"p_src p\" sip2]"], ["proof (prove)\nusing this:\n  (simple_match_ip sip1 (p_src p) \\<and> simple_match_ip sip2 (p_src p)) =\n  (case ipcidr_conjunct sip1 sip2 of None \\<Rightarrow> False\n   | Some ipx \\<Rightarrow> simple_match_ip ipx (p_src p))\n\ngoal (1 subgoal):\n 1. \\<And>ip.\n       ipcidr_conjunct sip1 sip2 = Some ip \\<Longrightarrow>\n       simple_match_ip ip (p_src p) =\n       (simple_match_ip sip1 (p_src p) \\<and>\n        simple_match_ip sip2 (p_src p))", "by simp"], ["proof (state)\nthis:\n  ipcidr_conjunct sip1 sip2 = Some ?ip \\<Longrightarrow>\n  simple_match_ip ?ip (p_src p) =\n  (simple_match_ip sip1 (p_src p) \\<and> simple_match_ip sip2 (p_src p))\n\ngoal (1 subgoal):\n 1. (simple_matches m1 p \\<and> simple_matches m2 p) =\n    (case simple_match_and m1 m2 of None \\<Rightarrow> False\n     | Some m \\<Rightarrow> simple_matches m p)", "have dip_Some: \"\\<And>ip. ipcidr_conjunct dip1 dip2 = Some ip \\<Longrightarrow>\n        simple_match_ip ip (p_dst p) \\<longleftrightarrow> simple_match_ip dip1 (p_dst p) \\<and> simple_match_ip dip2 (p_dst p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ip.\n       ipcidr_conjunct dip1 dip2 = Some ip \\<Longrightarrow>\n       simple_match_ip ip (p_dst p) =\n       (simple_match_ip dip1 (p_dst p) \\<and>\n        simple_match_ip dip2 (p_dst p))", "using simple_match_ip_conjunct[of dip1 \"p_dst p\" dip2]"], ["proof (prove)\nusing this:\n  (simple_match_ip dip1 (p_dst p) \\<and> simple_match_ip dip2 (p_dst p)) =\n  (case ipcidr_conjunct dip1 dip2 of None \\<Rightarrow> False\n   | Some ipx \\<Rightarrow> simple_match_ip ipx (p_dst p))\n\ngoal (1 subgoal):\n 1. \\<And>ip.\n       ipcidr_conjunct dip1 dip2 = Some ip \\<Longrightarrow>\n       simple_match_ip ip (p_dst p) =\n       (simple_match_ip dip1 (p_dst p) \\<and>\n        simple_match_ip dip2 (p_dst p))", "by simp"], ["proof (state)\nthis:\n  ipcidr_conjunct dip1 dip2 = Some ?ip \\<Longrightarrow>\n  simple_match_ip ?ip (p_dst p) =\n  (simple_match_ip dip1 (p_dst p) \\<and> simple_match_ip dip2 (p_dst p))\n\ngoal (1 subgoal):\n 1. (simple_matches m1 p \\<and> simple_matches m2 p) =\n    (case simple_match_and m1 m2 of None \\<Rightarrow> False\n     | Some m \\<Rightarrow> simple_matches m p)", "have iiface_None: \"iface_conjunct iif1 iif2 = None \\<Longrightarrow> \\<not> match_iface iif1 (p_iiface p) \\<or> \\<not> match_iface iif2 (p_iiface p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iface_conjunct iif1 iif2 = None \\<Longrightarrow>\n    \\<not> match_iface iif1 (p_iiface p) \\<or>\n    \\<not> match_iface iif2 (p_iiface p)", "using iface_conjunct[of iif1 \"(p_iiface p)\" iif2]"], ["proof (prove)\nusing this:\n  (match_iface iif1 (p_iiface p) \\<and> match_iface iif2 (p_iiface p)) =\n  (case iface_conjunct iif1 iif2 of None \\<Rightarrow> False\n   | Some x \\<Rightarrow> match_iface x (p_iiface p))\n\ngoal (1 subgoal):\n 1. iface_conjunct iif1 iif2 = None \\<Longrightarrow>\n    \\<not> match_iface iif1 (p_iiface p) \\<or>\n    \\<not> match_iface iif2 (p_iiface p)", "by simp"], ["proof (state)\nthis:\n  iface_conjunct iif1 iif2 = None \\<Longrightarrow>\n  \\<not> match_iface iif1 (p_iiface p) \\<or>\n  \\<not> match_iface iif2 (p_iiface p)\n\ngoal (1 subgoal):\n 1. (simple_matches m1 p \\<and> simple_matches m2 p) =\n    (case simple_match_and m1 m2 of None \\<Rightarrow> False\n     | Some m \\<Rightarrow> simple_matches m p)", "have oiface_None: \"iface_conjunct oif1 oif2 = None \\<Longrightarrow> \\<not> match_iface oif1 (p_oiface p) \\<or> \\<not> match_iface oif2 (p_oiface p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iface_conjunct oif1 oif2 = None \\<Longrightarrow>\n    \\<not> match_iface oif1 (p_oiface p) \\<or>\n    \\<not> match_iface oif2 (p_oiface p)", "using iface_conjunct[of oif1 \"(p_oiface p)\" oif2]"], ["proof (prove)\nusing this:\n  (match_iface oif1 (p_oiface p) \\<and> match_iface oif2 (p_oiface p)) =\n  (case iface_conjunct oif1 oif2 of None \\<Rightarrow> False\n   | Some x \\<Rightarrow> match_iface x (p_oiface p))\n\ngoal (1 subgoal):\n 1. iface_conjunct oif1 oif2 = None \\<Longrightarrow>\n    \\<not> match_iface oif1 (p_oiface p) \\<or>\n    \\<not> match_iface oif2 (p_oiface p)", "by simp"], ["proof (state)\nthis:\n  iface_conjunct oif1 oif2 = None \\<Longrightarrow>\n  \\<not> match_iface oif1 (p_oiface p) \\<or>\n  \\<not> match_iface oif2 (p_oiface p)\n\ngoal (1 subgoal):\n 1. (simple_matches m1 p \\<and> simple_matches m2 p) =\n    (case simple_match_and m1 m2 of None \\<Rightarrow> False\n     | Some m \\<Rightarrow> simple_matches m p)", "have iiface_Some: \"\\<And>iface. iface_conjunct iif1 iif2 = Some iface \\<Longrightarrow> \n        match_iface iface (p_iiface p) \\<longleftrightarrow> match_iface iif1 (p_iiface p) \\<and> match_iface iif2 (p_iiface p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>iface.\n       iface_conjunct iif1 iif2 = Some iface \\<Longrightarrow>\n       match_iface iface (p_iiface p) =\n       (match_iface iif1 (p_iiface p) \\<and> match_iface iif2 (p_iiface p))", "using iface_conjunct[of iif1 \"(p_iiface p)\" iif2]"], ["proof (prove)\nusing this:\n  (match_iface iif1 (p_iiface p) \\<and> match_iface iif2 (p_iiface p)) =\n  (case iface_conjunct iif1 iif2 of None \\<Rightarrow> False\n   | Some x \\<Rightarrow> match_iface x (p_iiface p))\n\ngoal (1 subgoal):\n 1. \\<And>iface.\n       iface_conjunct iif1 iif2 = Some iface \\<Longrightarrow>\n       match_iface iface (p_iiface p) =\n       (match_iface iif1 (p_iiface p) \\<and> match_iface iif2 (p_iiface p))", "by simp"], ["proof (state)\nthis:\n  iface_conjunct iif1 iif2 = Some ?iface \\<Longrightarrow>\n  match_iface ?iface (p_iiface p) =\n  (match_iface iif1 (p_iiface p) \\<and> match_iface iif2 (p_iiface p))\n\ngoal (1 subgoal):\n 1. (simple_matches m1 p \\<and> simple_matches m2 p) =\n    (case simple_match_and m1 m2 of None \\<Rightarrow> False\n     | Some m \\<Rightarrow> simple_matches m p)", "have oiface_Some: \"\\<And>iface. iface_conjunct oif1 oif2 = Some iface \\<Longrightarrow> \n        match_iface iface (p_oiface p) \\<longleftrightarrow> match_iface oif1 (p_oiface p) \\<and> match_iface oif2 (p_oiface p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>iface.\n       iface_conjunct oif1 oif2 = Some iface \\<Longrightarrow>\n       match_iface iface (p_oiface p) =\n       (match_iface oif1 (p_oiface p) \\<and> match_iface oif2 (p_oiface p))", "using iface_conjunct[of oif1 \"(p_oiface p)\" oif2]"], ["proof (prove)\nusing this:\n  (match_iface oif1 (p_oiface p) \\<and> match_iface oif2 (p_oiface p)) =\n  (case iface_conjunct oif1 oif2 of None \\<Rightarrow> False\n   | Some x \\<Rightarrow> match_iface x (p_oiface p))\n\ngoal (1 subgoal):\n 1. \\<And>iface.\n       iface_conjunct oif1 oif2 = Some iface \\<Longrightarrow>\n       match_iface iface (p_oiface p) =\n       (match_iface oif1 (p_oiface p) \\<and> match_iface oif2 (p_oiface p))", "by simp"], ["proof (state)\nthis:\n  iface_conjunct oif1 oif2 = Some ?iface \\<Longrightarrow>\n  match_iface ?iface (p_oiface p) =\n  (match_iface oif1 (p_oiface p) \\<and> match_iface oif2 (p_oiface p))\n\ngoal (1 subgoal):\n 1. (simple_matches m1 p \\<and> simple_matches m2 p) =\n    (case simple_match_and m1 m2 of None \\<Rightarrow> False\n     | Some m \\<Rightarrow> simple_matches m p)", "have proto_None: \"simple_proto_conjunct p1 p2 = None \\<Longrightarrow> \\<not> match_proto p1 (p_proto p) \\<or> \\<not> match_proto p2 (p_proto p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_proto_conjunct p1 p2 = None \\<Longrightarrow>\n    \\<not> match_proto p1 (p_proto p) \\<or>\n    \\<not> match_proto p2 (p_proto p)", "using simple_proto_conjunct_correct[of p1 \"(p_proto p)\" p2]"], ["proof (prove)\nusing this:\n  (match_proto p1 (p_proto p) \\<and> match_proto p2 (p_proto p)) =\n  (case simple_proto_conjunct p1 p2 of None \\<Rightarrow> False\n   | Some proto \\<Rightarrow> match_proto proto (p_proto p))\n\ngoal (1 subgoal):\n 1. simple_proto_conjunct p1 p2 = None \\<Longrightarrow>\n    \\<not> match_proto p1 (p_proto p) \\<or>\n    \\<not> match_proto p2 (p_proto p)", "by simp"], ["proof (state)\nthis:\n  simple_proto_conjunct p1 p2 = None \\<Longrightarrow>\n  \\<not> match_proto p1 (p_proto p) \\<or> \\<not> match_proto p2 (p_proto p)\n\ngoal (1 subgoal):\n 1. (simple_matches m1 p \\<and> simple_matches m2 p) =\n    (case simple_match_and m1 m2 of None \\<Rightarrow> False\n     | Some m \\<Rightarrow> simple_matches m p)", "have proto_Some: \"\\<And>proto. simple_proto_conjunct p1 p2 = Some proto \\<Longrightarrow>\n        match_proto proto (p_proto p) \\<longleftrightarrow> match_proto p1 (p_proto p) \\<and> match_proto p2 (p_proto p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>proto.\n       simple_proto_conjunct p1 p2 = Some proto \\<Longrightarrow>\n       match_proto proto (p_proto p) =\n       (match_proto p1 (p_proto p) \\<and> match_proto p2 (p_proto p))", "using simple_proto_conjunct_correct[of p1 \"(p_proto p)\" p2]"], ["proof (prove)\nusing this:\n  (match_proto p1 (p_proto p) \\<and> match_proto p2 (p_proto p)) =\n  (case simple_proto_conjunct p1 p2 of None \\<Rightarrow> False\n   | Some proto \\<Rightarrow> match_proto proto (p_proto p))\n\ngoal (1 subgoal):\n 1. \\<And>proto.\n       simple_proto_conjunct p1 p2 = Some proto \\<Longrightarrow>\n       match_proto proto (p_proto p) =\n       (match_proto p1 (p_proto p) \\<and> match_proto p2 (p_proto p))", "by simp"], ["proof (state)\nthis:\n  simple_proto_conjunct p1 p2 = Some ?proto \\<Longrightarrow>\n  match_proto ?proto (p_proto p) =\n  (match_proto p1 (p_proto p) \\<and> match_proto p2 (p_proto p))\n\ngoal (1 subgoal):\n 1. (simple_matches m1 p \\<and> simple_matches m2 p) =\n    (case simple_match_and m1 m2 of None \\<Rightarrow> False\n     | Some m \\<Rightarrow> simple_matches m p)", "have case_Some: \"\\<And>m. Some m = simple_match_and m1 m2 \\<Longrightarrow>\n       (simple_matches m1 p \\<and> simple_matches m2 p) \\<longleftrightarrow> simple_matches m p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       Some m = simple_match_and m1 m2 \\<Longrightarrow>\n       (simple_matches m1 p \\<and> simple_matches m2 p) = simple_matches m p", "apply(simp add: m1 m2 simple_matches.simps split: option.split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m x2 x2a x2b x2c x2d.\n       \\<lbrakk>ipcidr_conjunct sip1 sip2 = Some x2;\n        ipcidr_conjunct dip1 dip2 = Some x2a;\n        iface_conjunct iif1 iif2 = Some x2b;\n        iface_conjunct oif1 oif2 = Some x2c;\n        simple_proto_conjunct p1 p2 = Some x2d;\n        m =\n        \\<lparr>iiface = x2b, oiface = x2c, src = x2, dst = x2a,\n           proto = x2d, sports = simpl_ports_conjunct sps1 sps2,\n           dports = simpl_ports_conjunct dps1 dps2\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> (match_iface iif1 (p_iiface p) \\<and>\n                          match_iface oif1 (p_oiface p) \\<and>\n                          simple_match_ip sip1 (p_src p) \\<and>\n                          simple_match_ip dip1 (p_dst p) \\<and>\n                          match_proto p1 (p_proto p) \\<and>\n                          simple_match_port sps1 (p_sport p) \\<and>\n                          simple_match_port dps1 (p_dport p) \\<and>\n                          match_iface iif2 (p_iiface p) \\<and>\n                          match_iface oif2 (p_oiface p) \\<and>\n                          simple_match_ip sip2 (p_src p) \\<and>\n                          simple_match_ip dip2 (p_dst p) \\<and>\n                          match_proto p2 (p_proto p) \\<and>\n                          simple_match_port sps2 (p_sport p) \\<and>\n                          simple_match_port dps2 (p_dport p)) =\n                         (match_iface x2b (p_iiface p) \\<and>\n                          match_iface x2c (p_oiface p) \\<and>\n                          simple_match_ip x2 (p_src p) \\<and>\n                          simple_match_ip x2a (p_dst p) \\<and>\n                          match_proto x2d (p_proto p) \\<and>\n                          simple_match_port (simpl_ports_conjunct sps1 sps2)\n                           (p_sport p) \\<and>\n                          simple_match_port (simpl_ports_conjunct dps1 dps2)\n                           (p_dport p))", "using simple_ports_conjunct_correct"], ["proof (prove)\nusing this:\n  (simple_match_port ?p1.0 ?pkt \\<and> simple_match_port ?p2.0 ?pkt) =\n  simple_match_port (simpl_ports_conjunct ?p1.0 ?p2.0) ?pkt\n\ngoal (1 subgoal):\n 1. \\<And>m x2 x2a x2b x2c x2d.\n       \\<lbrakk>ipcidr_conjunct sip1 sip2 = Some x2;\n        ipcidr_conjunct dip1 dip2 = Some x2a;\n        iface_conjunct iif1 iif2 = Some x2b;\n        iface_conjunct oif1 oif2 = Some x2c;\n        simple_proto_conjunct p1 p2 = Some x2d;\n        m =\n        \\<lparr>iiface = x2b, oiface = x2c, src = x2, dst = x2a,\n           proto = x2d, sports = simpl_ports_conjunct sps1 sps2,\n           dports = simpl_ports_conjunct dps1 dps2\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> (match_iface iif1 (p_iiface p) \\<and>\n                          match_iface oif1 (p_oiface p) \\<and>\n                          simple_match_ip sip1 (p_src p) \\<and>\n                          simple_match_ip dip1 (p_dst p) \\<and>\n                          match_proto p1 (p_proto p) \\<and>\n                          simple_match_port sps1 (p_sport p) \\<and>\n                          simple_match_port dps1 (p_dport p) \\<and>\n                          match_iface iif2 (p_iiface p) \\<and>\n                          match_iface oif2 (p_oiface p) \\<and>\n                          simple_match_ip sip2 (p_src p) \\<and>\n                          simple_match_ip dip2 (p_dst p) \\<and>\n                          match_proto p2 (p_proto p) \\<and>\n                          simple_match_port sps2 (p_sport p) \\<and>\n                          simple_match_port dps2 (p_dport p)) =\n                         (match_iface x2b (p_iiface p) \\<and>\n                          match_iface x2c (p_oiface p) \\<and>\n                          simple_match_ip x2 (p_src p) \\<and>\n                          simple_match_ip x2a (p_dst p) \\<and>\n                          match_proto x2d (p_proto p) \\<and>\n                          simple_match_port (simpl_ports_conjunct sps1 sps2)\n                           (p_sport p) \\<and>\n                          simple_match_port (simpl_ports_conjunct dps1 dps2)\n                           (p_dport p))", "by(blast dest: sip_Some dip_Some iiface_Some oiface_Some proto_Some)"], ["proof (state)\nthis:\n  Some ?m = simple_match_and m1 m2 \\<Longrightarrow>\n  (simple_matches m1 p \\<and> simple_matches m2 p) = simple_matches ?m p\n\ngoal (1 subgoal):\n 1. (simple_matches m1 p \\<and> simple_matches m2 p) =\n    (case simple_match_and m1 m2 of None \\<Rightarrow> False\n     | Some m \\<Rightarrow> simple_matches m p)", "have case_None: \"simple_match_and m1 m2 = None \\<Longrightarrow> \\<not> (simple_matches m1 p \\<and> simple_matches m2 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_match_and m1 m2 = None \\<Longrightarrow>\n    \\<not> (simple_matches m1 p \\<and> simple_matches m2 p)", "apply(simp add: m1 m2 simple_matches.simps split: option.split_asm)"], ["proof (prove)\ngoal (5 subgoals):\n 1. ipcidr_conjunct sip1 sip2 = None \\<Longrightarrow>\n    simple_match_port sps2 (p_sport p) \\<longrightarrow>\n    match_proto p2 (p_proto p) \\<longrightarrow>\n    simple_match_ip dip2 (p_dst p) \\<longrightarrow>\n    simple_match_ip sip2 (p_src p) \\<longrightarrow>\n    match_iface oif2 (p_oiface p) \\<longrightarrow>\n    match_iface iif2 (p_iiface p) \\<longrightarrow>\n    simple_match_port dps1 (p_dport p) \\<longrightarrow>\n    simple_match_port sps1 (p_sport p) \\<longrightarrow>\n    match_proto p1 (p_proto p) \\<longrightarrow>\n    simple_match_ip dip1 (p_dst p) \\<longrightarrow>\n    simple_match_ip sip1 (p_src p) \\<longrightarrow>\n    match_iface oif1 (p_oiface p) \\<longrightarrow>\n    match_iface iif1 (p_iiface p) \\<longrightarrow>\n    \\<not> simple_match_port dps2 (p_dport p)\n 2. \\<And>x2.\n       \\<lbrakk>ipcidr_conjunct sip1 sip2 = Some x2;\n        ipcidr_conjunct dip1 dip2 = None\\<rbrakk>\n       \\<Longrightarrow> simple_match_port sps2\n                          (p_sport p) \\<longrightarrow>\n                         match_proto p2 (p_proto p) \\<longrightarrow>\n                         simple_match_ip dip2 (p_dst p) \\<longrightarrow>\n                         simple_match_ip sip2 (p_src p) \\<longrightarrow>\n                         match_iface oif2 (p_oiface p) \\<longrightarrow>\n                         match_iface iif2 (p_iiface p) \\<longrightarrow>\n                         simple_match_port dps1\n                          (p_dport p) \\<longrightarrow>\n                         simple_match_port sps1\n                          (p_sport p) \\<longrightarrow>\n                         match_proto p1 (p_proto p) \\<longrightarrow>\n                         simple_match_ip dip1 (p_dst p) \\<longrightarrow>\n                         simple_match_ip sip1 (p_src p) \\<longrightarrow>\n                         match_iface oif1 (p_oiface p) \\<longrightarrow>\n                         match_iface iif1 (p_iiface p) \\<longrightarrow>\n                         \\<not> simple_match_port dps2 (p_dport p)\n 3. \\<And>x2 x2a.\n       \\<lbrakk>ipcidr_conjunct sip1 sip2 = Some x2;\n        ipcidr_conjunct dip1 dip2 = Some x2a;\n        iface_conjunct iif1 iif2 = None\\<rbrakk>\n       \\<Longrightarrow> simple_match_port sps2\n                          (p_sport p) \\<longrightarrow>\n                         match_proto p2 (p_proto p) \\<longrightarrow>\n                         simple_match_ip dip2 (p_dst p) \\<longrightarrow>\n                         simple_match_ip sip2 (p_src p) \\<longrightarrow>\n                         match_iface oif2 (p_oiface p) \\<longrightarrow>\n                         match_iface iif2 (p_iiface p) \\<longrightarrow>\n                         simple_match_port dps1\n                          (p_dport p) \\<longrightarrow>\n                         simple_match_port sps1\n                          (p_sport p) \\<longrightarrow>\n                         match_proto p1 (p_proto p) \\<longrightarrow>\n                         simple_match_ip dip1 (p_dst p) \\<longrightarrow>\n                         simple_match_ip sip1 (p_src p) \\<longrightarrow>\n                         match_iface oif1 (p_oiface p) \\<longrightarrow>\n                         match_iface iif1 (p_iiface p) \\<longrightarrow>\n                         \\<not> simple_match_port dps2 (p_dport p)\n 4. \\<And>x2 x2a x2b.\n       \\<lbrakk>ipcidr_conjunct sip1 sip2 = Some x2;\n        ipcidr_conjunct dip1 dip2 = Some x2a;\n        iface_conjunct iif1 iif2 = Some x2b;\n        iface_conjunct oif1 oif2 = None\\<rbrakk>\n       \\<Longrightarrow> simple_match_port sps2\n                          (p_sport p) \\<longrightarrow>\n                         match_proto p2 (p_proto p) \\<longrightarrow>\n                         simple_match_ip dip2 (p_dst p) \\<longrightarrow>\n                         simple_match_ip sip2 (p_src p) \\<longrightarrow>\n                         match_iface oif2 (p_oiface p) \\<longrightarrow>\n                         match_iface iif2 (p_iiface p) \\<longrightarrow>\n                         simple_match_port dps1\n                          (p_dport p) \\<longrightarrow>\n                         simple_match_port sps1\n                          (p_sport p) \\<longrightarrow>\n                         match_proto p1 (p_proto p) \\<longrightarrow>\n                         simple_match_ip dip1 (p_dst p) \\<longrightarrow>\n                         simple_match_ip sip1 (p_src p) \\<longrightarrow>\n                         match_iface oif1 (p_oiface p) \\<longrightarrow>\n                         match_iface iif1 (p_iiface p) \\<longrightarrow>\n                         \\<not> simple_match_port dps2 (p_dport p)\n 5. \\<And>x2 x2a x2b x2c.\n       \\<lbrakk>ipcidr_conjunct sip1 sip2 = Some x2;\n        ipcidr_conjunct dip1 dip2 = Some x2a;\n        iface_conjunct iif1 iif2 = Some x2b;\n        iface_conjunct oif1 oif2 = Some x2c;\n        simple_proto_conjunct p1 p2 = None\\<rbrakk>\n       \\<Longrightarrow> simple_match_port sps2\n                          (p_sport p) \\<longrightarrow>\n                         match_proto p2 (p_proto p) \\<longrightarrow>\n                         simple_match_ip dip2 (p_dst p) \\<longrightarrow>\n                         simple_match_ip sip2 (p_src p) \\<longrightarrow>\n                         match_iface oif2 (p_oiface p) \\<longrightarrow>\n                         match_iface iif2 (p_iiface p) \\<longrightarrow>\n                         simple_match_port dps1\n                          (p_dport p) \\<longrightarrow>\n                         simple_match_port sps1\n                          (p_sport p) \\<longrightarrow>\n                         match_proto p1 (p_proto p) \\<longrightarrow>\n                         simple_match_ip dip1 (p_dst p) \\<longrightarrow>\n                         simple_match_ip sip1 (p_src p) \\<longrightarrow>\n                         match_iface oif1 (p_oiface p) \\<longrightarrow>\n                         match_iface iif1 (p_iiface p) \\<longrightarrow>\n                         \\<not> simple_match_port dps2 (p_dport p)", "apply(blast dest: sip_None dip_None iiface_None oiface_None proto_None)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  simple_match_and m1 m2 = None \\<Longrightarrow>\n  \\<not> (simple_matches m1 p \\<and> simple_matches m2 p)\n\ngoal (1 subgoal):\n 1. (simple_matches m1 p \\<and> simple_matches m2 p) =\n    (case simple_match_and m1 m2 of None \\<Rightarrow> False\n     | Some m \\<Rightarrow> simple_matches m p)", "from case_Some case_None"], ["proof (chain)\npicking this:\n  Some ?m = simple_match_and m1 m2 \\<Longrightarrow>\n  (simple_matches m1 p \\<and> simple_matches m2 p) = simple_matches ?m p\n  simple_match_and m1 m2 = None \\<Longrightarrow>\n  \\<not> (simple_matches m1 p \\<and> simple_matches m2 p)", "show ?thesis"], ["proof (prove)\nusing this:\n  Some ?m = simple_match_and m1 m2 \\<Longrightarrow>\n  (simple_matches m1 p \\<and> simple_matches m2 p) = simple_matches ?m p\n  simple_match_and m1 m2 = None \\<Longrightarrow>\n  \\<not> (simple_matches m1 p \\<and> simple_matches m2 p)\n\ngoal (1 subgoal):\n 1. (simple_matches m1 p \\<and> simple_matches m2 p) =\n    (case simple_match_and m1 m2 of None \\<Rightarrow> False\n     | Some m \\<Rightarrow> simple_matches m p)", "by(cases \"simple_match_and m1 m2\") simp_all"], ["proof (state)\nthis:\n  (simple_matches m1 p \\<and> simple_matches m2 p) =\n  (case simple_match_and m1 m2 of None \\<Rightarrow> False\n   | Some m \\<Rightarrow> simple_matches m p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma simple_match_and_SomeD: \"simple_match_and m1 m2 = Some m \\<Longrightarrow>\n    simple_matches m p \\<longleftrightarrow> (simple_matches m1 p \\<and> simple_matches m2 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_match_and m1 m2 = Some m \\<Longrightarrow>\n    simple_matches m p = (simple_matches m1 p \\<and> simple_matches m2 p)", "by(simp add: simple_match_and_correct)"], ["", "lemma simple_match_and_NoneD: \"simple_match_and m1 m2 = None \\<Longrightarrow>\n    \\<not>(simple_matches m1 p \\<and> simple_matches m2 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_match_and m1 m2 = None \\<Longrightarrow>\n    \\<not> (simple_matches m1 p \\<and> simple_matches m2 p)", "by(simp add: simple_match_and_correct)"], ["", "lemma simple_matches_andD: \"simple_matches m1 p \\<Longrightarrow> simple_matches m2 p \\<Longrightarrow>\n    \\<exists>m. simple_match_and m1 m2 = Some m \\<and> simple_matches m p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>simple_matches m1 p; simple_matches m2 p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>m.\n                         simple_match_and m1 m2 = Some m \\<and>\n                         simple_matches m p", "by (meson option.exhaust_sel simple_match_and_NoneD simple_match_and_SomeD)"], ["", "subsection\\<open>Further Properties of a Simple Firewall\\<close>"], ["", "fun has_default_policy :: \"'i::len simple_rule list \\<Rightarrow> bool\" where\n    \"has_default_policy [] = False\" |\n    \"has_default_policy [(SimpleRule m _)] = (m = simple_match_any)\" |\n    \"has_default_policy (_#rs) = has_default_policy rs\""], ["", "lemma has_default_policy: \"has_default_policy rs \\<Longrightarrow>\n    simple_fw rs p = Decision FinalAllow \\<or> simple_fw rs p = Decision FinalDeny\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_default_policy rs \\<Longrightarrow>\n    simple_fw rs p = Decision FinalAllow \\<or>\n    simple_fw rs p = Decision FinalDeny", "proof(induction rs rule: has_default_policy.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. has_default_policy [] \\<Longrightarrow>\n    simple_fw [] p = Decision FinalAllow \\<or>\n    simple_fw [] p = Decision FinalDeny\n 2. \\<And>m uu_.\n       has_default_policy [SimpleRule m uu_] \\<Longrightarrow>\n       simple_fw [SimpleRule m uu_] p = Decision FinalAllow \\<or>\n       simple_fw [SimpleRule m uu_] p = Decision FinalDeny\n 3. \\<And>uv_ v va.\n       \\<lbrakk>has_default_policy (v # va) \\<Longrightarrow>\n                simple_fw (v # va) p = Decision FinalAllow \\<or>\n                simple_fw (v # va) p = Decision FinalDeny;\n        has_default_policy (uv_ # v # va)\\<rbrakk>\n       \\<Longrightarrow> simple_fw (uv_ # v # va) p =\n                         Decision FinalAllow \\<or>\n                         simple_fw (uv_ # v # va) p = Decision FinalDeny", "case 1"], ["proof (state)\nthis:\n  has_default_policy []\n\ngoal (3 subgoals):\n 1. has_default_policy [] \\<Longrightarrow>\n    simple_fw [] p = Decision FinalAllow \\<or>\n    simple_fw [] p = Decision FinalDeny\n 2. \\<And>m uu_.\n       has_default_policy [SimpleRule m uu_] \\<Longrightarrow>\n       simple_fw [SimpleRule m uu_] p = Decision FinalAllow \\<or>\n       simple_fw [SimpleRule m uu_] p = Decision FinalDeny\n 3. \\<And>uv_ v va.\n       \\<lbrakk>has_default_policy (v # va) \\<Longrightarrow>\n                simple_fw (v # va) p = Decision FinalAllow \\<or>\n                simple_fw (v # va) p = Decision FinalDeny;\n        has_default_policy (uv_ # v # va)\\<rbrakk>\n       \\<Longrightarrow> simple_fw (uv_ # v # va) p =\n                         Decision FinalAllow \\<or>\n                         simple_fw (uv_ # v # va) p = Decision FinalDeny", "thus ?case"], ["proof (prove)\nusing this:\n  has_default_policy []\n\ngoal (1 subgoal):\n 1. simple_fw [] p = Decision FinalAllow \\<or>\n    simple_fw [] p = Decision FinalDeny", "by (simp)"], ["proof (state)\nthis:\n  simple_fw [] p = Decision FinalAllow \\<or>\n  simple_fw [] p = Decision FinalDeny\n\ngoal (2 subgoals):\n 1. \\<And>m uu_.\n       has_default_policy [SimpleRule m uu_] \\<Longrightarrow>\n       simple_fw [SimpleRule m uu_] p = Decision FinalAllow \\<or>\n       simple_fw [SimpleRule m uu_] p = Decision FinalDeny\n 2. \\<And>uv_ v va.\n       \\<lbrakk>has_default_policy (v # va) \\<Longrightarrow>\n                simple_fw (v # va) p = Decision FinalAllow \\<or>\n                simple_fw (v # va) p = Decision FinalDeny;\n        has_default_policy (uv_ # v # va)\\<rbrakk>\n       \\<Longrightarrow> simple_fw (uv_ # v # va) p =\n                         Decision FinalAllow \\<or>\n                         simple_fw (uv_ # v # va) p = Decision FinalDeny", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m uu_.\n       has_default_policy [SimpleRule m uu_] \\<Longrightarrow>\n       simple_fw [SimpleRule m uu_] p = Decision FinalAllow \\<or>\n       simple_fw [SimpleRule m uu_] p = Decision FinalDeny\n 2. \\<And>uv_ v va.\n       \\<lbrakk>has_default_policy (v # va) \\<Longrightarrow>\n                simple_fw (v # va) p = Decision FinalAllow \\<or>\n                simple_fw (v # va) p = Decision FinalDeny;\n        has_default_policy (uv_ # v # va)\\<rbrakk>\n       \\<Longrightarrow> simple_fw (uv_ # v # va) p =\n                         Decision FinalAllow \\<or>\n                         simple_fw (uv_ # v # va) p = Decision FinalDeny", "case (2 m a)"], ["proof (state)\nthis:\n  has_default_policy [SimpleRule m a]\n\ngoal (2 subgoals):\n 1. \\<And>m uu_.\n       has_default_policy [SimpleRule m uu_] \\<Longrightarrow>\n       simple_fw [SimpleRule m uu_] p = Decision FinalAllow \\<or>\n       simple_fw [SimpleRule m uu_] p = Decision FinalDeny\n 2. \\<And>uv_ v va.\n       \\<lbrakk>has_default_policy (v # va) \\<Longrightarrow>\n                simple_fw (v # va) p = Decision FinalAllow \\<or>\n                simple_fw (v # va) p = Decision FinalDeny;\n        has_default_policy (uv_ # v # va)\\<rbrakk>\n       \\<Longrightarrow> simple_fw (uv_ # v # va) p =\n                         Decision FinalAllow \\<or>\n                         simple_fw (uv_ # v # va) p = Decision FinalDeny", "thus ?case"], ["proof (prove)\nusing this:\n  has_default_policy [SimpleRule m a]\n\ngoal (1 subgoal):\n 1. simple_fw [SimpleRule m a] p = Decision FinalAllow \\<or>\n    simple_fw [SimpleRule m a] p = Decision FinalDeny", "by(cases a) (simp_all add: simple_match_any)"], ["proof (state)\nthis:\n  simple_fw [SimpleRule m a] p = Decision FinalAllow \\<or>\n  simple_fw [SimpleRule m a] p = Decision FinalDeny\n\ngoal (1 subgoal):\n 1. \\<And>uv_ v va.\n       \\<lbrakk>has_default_policy (v # va) \\<Longrightarrow>\n                simple_fw (v # va) p = Decision FinalAllow \\<or>\n                simple_fw (v # va) p = Decision FinalDeny;\n        has_default_policy (uv_ # v # va)\\<rbrakk>\n       \\<Longrightarrow> simple_fw (uv_ # v # va) p =\n                         Decision FinalAllow \\<or>\n                         simple_fw (uv_ # v # va) p = Decision FinalDeny", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>uv_ v va.\n       \\<lbrakk>has_default_policy (v # va) \\<Longrightarrow>\n                simple_fw (v # va) p = Decision FinalAllow \\<or>\n                simple_fw (v # va) p = Decision FinalDeny;\n        has_default_policy (uv_ # v # va)\\<rbrakk>\n       \\<Longrightarrow> simple_fw (uv_ # v # va) p =\n                         Decision FinalAllow \\<or>\n                         simple_fw (uv_ # v # va) p = Decision FinalDeny", "case (3 r1 r2 rs)"], ["proof (state)\nthis:\n  has_default_policy (r2 # rs) \\<Longrightarrow>\n  simple_fw (r2 # rs) p = Decision FinalAllow \\<or>\n  simple_fw (r2 # rs) p = Decision FinalDeny\n  has_default_policy (r1 # r2 # rs)\n\ngoal (1 subgoal):\n 1. \\<And>uv_ v va.\n       \\<lbrakk>has_default_policy (v # va) \\<Longrightarrow>\n                simple_fw (v # va) p = Decision FinalAllow \\<or>\n                simple_fw (v # va) p = Decision FinalDeny;\n        has_default_policy (uv_ # v # va)\\<rbrakk>\n       \\<Longrightarrow> simple_fw (uv_ # v # va) p =\n                         Decision FinalAllow \\<or>\n                         simple_fw (uv_ # v # va) p = Decision FinalDeny", "from 3"], ["proof (chain)\npicking this:\n  has_default_policy (r2 # rs) \\<Longrightarrow>\n  simple_fw (r2 # rs) p = Decision FinalAllow \\<or>\n  simple_fw (r2 # rs) p = Decision FinalDeny\n  has_default_policy (r1 # r2 # rs)", "obtain a m where \"r1 = SimpleRule m a\""], ["proof (prove)\nusing this:\n  has_default_policy (r2 # rs) \\<Longrightarrow>\n  simple_fw (r2 # rs) p = Decision FinalAllow \\<or>\n  simple_fw (r2 # rs) p = Decision FinalDeny\n  has_default_policy (r1 # r2 # rs)\n\ngoal (1 subgoal):\n 1. (\\<And>m a.\n        r1 = SimpleRule m a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases r1) simp"], ["proof (state)\nthis:\n  r1 = SimpleRule m a\n\ngoal (1 subgoal):\n 1. \\<And>uv_ v va.\n       \\<lbrakk>has_default_policy (v # va) \\<Longrightarrow>\n                simple_fw (v # va) p = Decision FinalAllow \\<or>\n                simple_fw (v # va) p = Decision FinalDeny;\n        has_default_policy (uv_ # v # va)\\<rbrakk>\n       \\<Longrightarrow> simple_fw (uv_ # v # va) p =\n                         Decision FinalAllow \\<or>\n                         simple_fw (uv_ # v # va) p = Decision FinalDeny", "with 3"], ["proof (chain)\npicking this:\n  has_default_policy (r2 # rs) \\<Longrightarrow>\n  simple_fw (r2 # rs) p = Decision FinalAllow \\<or>\n  simple_fw (r2 # rs) p = Decision FinalDeny\n  has_default_policy (r1 # r2 # rs)\n  r1 = SimpleRule m a", "show ?case"], ["proof (prove)\nusing this:\n  has_default_policy (r2 # rs) \\<Longrightarrow>\n  simple_fw (r2 # rs) p = Decision FinalAllow \\<or>\n  simple_fw (r2 # rs) p = Decision FinalDeny\n  has_default_policy (r1 # r2 # rs)\n  r1 = SimpleRule m a\n\ngoal (1 subgoal):\n 1. simple_fw (r1 # r2 # rs) p = Decision FinalAllow \\<or>\n    simple_fw (r1 # r2 # rs) p = Decision FinalDeny", "by (cases a) simp_all"], ["proof (state)\nthis:\n  simple_fw (r1 # r2 # rs) p = Decision FinalAllow \\<or>\n  simple_fw (r1 # r2 # rs) p = Decision FinalDeny\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_default_policy_fst: \"has_default_policy rs \\<Longrightarrow> has_default_policy (r#rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_default_policy rs \\<Longrightarrow> has_default_policy (r # rs)", "apply(cases r, rename_tac m a, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>has_default_policy rs; r = SimpleRule m a\\<rbrakk>\n       \\<Longrightarrow> has_default_policy (SimpleRule m a # rs)", "apply(cases rs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>has_default_policy rs; r = SimpleRule m a; rs = []\\<rbrakk>\n       \\<Longrightarrow> has_default_policy (SimpleRule m a # rs)\n 2. \\<And>m a aa list.\n       \\<lbrakk>has_default_policy rs; r = SimpleRule m a;\n        rs = aa # list\\<rbrakk>\n       \\<Longrightarrow> has_default_policy (SimpleRule m a # rs)", "by(simp_all)"], ["", "text\\<open>We can stop after a default rule (a rule which matches anything) is observed.\\<close>"], ["", "fun cut_off_after_match_any :: \"'i::len simple_rule list \\<Rightarrow> 'i simple_rule list\" where\n    \"cut_off_after_match_any [] = []\" |\n    \"cut_off_after_match_any (SimpleRule m a # rs) =\n      (if m = simple_match_any then [SimpleRule m a] else SimpleRule m a # cut_off_after_match_any rs)\""], ["", "lemma cut_off_after_match_any: \"simple_fw (cut_off_after_match_any rs) p = simple_fw rs p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_fw (cut_off_after_match_any rs) p = simple_fw rs p", "apply(induction rs p rule: simple_fw.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_. simple_fw (cut_off_after_match_any []) uu_ = simple_fw [] uu_\n 2. \\<And>m rs p.\n       (\\<not> simple_matches m p \\<Longrightarrow>\n        simple_fw (cut_off_after_match_any rs) p =\n        simple_fw rs p) \\<Longrightarrow>\n       simple_fw (cut_off_after_match_any (SimpleRule m Accept # rs)) p =\n       simple_fw (SimpleRule m Accept # rs) p\n 3. \\<And>m rs p.\n       (\\<not> simple_matches m p \\<Longrightarrow>\n        simple_fw (cut_off_after_match_any rs) p =\n        simple_fw rs p) \\<Longrightarrow>\n       simple_fw (cut_off_after_match_any (SimpleRule m Drop # rs)) p =\n       simple_fw (SimpleRule m Drop # rs) p", "by(simp add: simple_match_any)+"], ["", "lemma simple_fw_not_matches_removeAll: \"\\<not> simple_matches m p \\<Longrightarrow>\n    simple_fw (removeAll (SimpleRule m a) rs) p = simple_fw rs p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> simple_matches m p \\<Longrightarrow>\n    simple_fw (removeAll (SimpleRule m a) rs) p = simple_fw rs p", "apply(induction rs p rule: simple_fw.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_.\n       \\<not> simple_matches m uu_ \\<Longrightarrow>\n       simple_fw (removeAll (SimpleRule m a) []) uu_ = simple_fw [] uu_\n 2. \\<And>ma rs p.\n       \\<lbrakk>\\<lbrakk>\\<not> simple_matches ma p;\n                 \\<not> simple_matches m p\\<rbrakk>\n                \\<Longrightarrow> simple_fw (removeAll (SimpleRule m a) rs)\n                                   p =\n                                  simple_fw rs p;\n        \\<not> simple_matches m p\\<rbrakk>\n       \\<Longrightarrow> simple_fw\n                          (removeAll (SimpleRule m a)\n                            (SimpleRule ma Accept # rs))\n                          p =\n                         simple_fw (SimpleRule ma Accept # rs) p\n 3. \\<And>ma rs p.\n       \\<lbrakk>\\<lbrakk>\\<not> simple_matches ma p;\n                 \\<not> simple_matches m p\\<rbrakk>\n                \\<Longrightarrow> simple_fw (removeAll (SimpleRule m a) rs)\n                                   p =\n                                  simple_fw rs p;\n        \\<not> simple_matches m p\\<rbrakk>\n       \\<Longrightarrow> simple_fw\n                          (removeAll (SimpleRule m a)\n                            (SimpleRule ma Drop # rs))\n                          p =\n                         simple_fw (SimpleRule ma Drop # rs) p", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ma rs p.\n       \\<lbrakk>\\<lbrakk>\\<not> simple_matches ma p;\n                 \\<not> simple_matches m p\\<rbrakk>\n                \\<Longrightarrow> simple_fw (removeAll (SimpleRule m a) rs)\n                                   p =\n                                  simple_fw rs p;\n        \\<not> simple_matches m p\\<rbrakk>\n       \\<Longrightarrow> simple_fw\n                          (removeAll (SimpleRule m a)\n                            (SimpleRule ma Accept # rs))\n                          p =\n                         simple_fw (SimpleRule ma Accept # rs) p\n 2. \\<And>ma rs p.\n       \\<lbrakk>\\<lbrakk>\\<not> simple_matches ma p;\n                 \\<not> simple_matches m p\\<rbrakk>\n                \\<Longrightarrow> simple_fw (removeAll (SimpleRule m a) rs)\n                                   p =\n                                  simple_fw rs p;\n        \\<not> simple_matches m p\\<rbrakk>\n       \\<Longrightarrow> simple_fw\n                          (removeAll (SimpleRule m a)\n                            (SimpleRule ma Drop # rs))\n                          p =\n                         simple_fw (SimpleRule ma Drop # rs) p", "apply(simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ma rs p.\n       \\<lbrakk>\\<not> simple_matches ma p \\<Longrightarrow>\n                simple_fw (removeAll (SimpleRule m a) rs) p =\n                simple_fw rs p;\n        \\<not> simple_matches m p\\<rbrakk>\n       \\<Longrightarrow> m = ma \\<and> a = Accept \\<longrightarrow>\n                         (simple_matches ma p \\<longrightarrow>\n                          simple_fw (removeAll (SimpleRule ma Accept) rs)\n                           p =\n                          Decision FinalAllow) \\<and>\n                         (\\<not> simple_matches ma p \\<longrightarrow>\n                          simple_fw (removeAll (SimpleRule ma Accept) rs)\n                           p =\n                          simple_fw rs p)\n 2. \\<And>ma rs p.\n       \\<lbrakk>\\<not> simple_matches ma p \\<Longrightarrow>\n                simple_fw (removeAll (SimpleRule m a) rs) p =\n                simple_fw rs p;\n        \\<not> simple_matches m p\\<rbrakk>\n       \\<Longrightarrow> m = ma \\<and> a = Drop \\<longrightarrow>\n                         (simple_matches ma p \\<longrightarrow>\n                          simple_fw (removeAll (SimpleRule ma Drop) rs) p =\n                          Decision FinalDeny) \\<and>\n                         (\\<not> simple_matches ma p \\<longrightarrow>\n                          simple_fw (removeAll (SimpleRule ma Drop) rs) p =\n                          simple_fw rs p)", "apply blast+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>Reality check: Validity of Simple Matches\\<close>"], ["", "text\\<open>While it is possible to construct a \\<open>simple_fw\\<close> expression that only matches a source\n  or destination port, such a match is not meaningful, as the presence of the port information is \n  dependent on the protocol. Thus, a match for a port should always include the match for a protocol.\n  Additionally, prefixes should be zero on bits beyond the prefix length.\n  \\<close>"], ["", "definition \"valid_prefix_fw m = valid_prefix (uncurry PrefixMatch m)\""], ["", "lemma ipcidr_conjunct_valid:\n    \"\\<lbrakk>valid_prefix_fw p1; valid_prefix_fw p2; ipcidr_conjunct p1 p2 = Some p\\<rbrakk> \\<Longrightarrow> valid_prefix_fw p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefix_fw p1; valid_prefix_fw p2;\n     ipcidr_conjunct p1 p2 = Some p\\<rbrakk>\n    \\<Longrightarrow> valid_prefix_fw p", "unfolding valid_prefix_fw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid_prefix (uncurry PrefixMatch p1);\n     valid_prefix (uncurry PrefixMatch p2);\n     ipcidr_conjunct p1 p2 = Some p\\<rbrakk>\n    \\<Longrightarrow> valid_prefix (uncurry PrefixMatch p)", "by(cases p; cases p1; cases p2) (simp add: ipcidr_conjunct.simps split: if_splits)"], ["", "definition simple_match_valid :: \"('i::len, 'a) simple_match_scheme \\<Rightarrow> bool\" where\n    \"simple_match_valid m \\<equiv> \n    ({p. simple_match_port (sports m) p} \\<noteq> UNIV \\<or> {p. simple_match_port (dports m) p} \\<noteq> UNIV \\<longrightarrow>\n        proto m \\<in> Proto `{TCP, UDP, L4_Protocol.SCTP}) \\<and>\n    valid_prefix_fw (src m) \\<and> valid_prefix_fw (dst m)\""], ["", "lemma simple_match_valid_alt[code_unfold]: \"simple_match_valid = (\\<lambda> m.\n    (let c = (\\<lambda>(s,e). (s \\<noteq> 0 \\<or> e \\<noteq> max_word)) in (\n    if c (sports m) \\<or> c (dports m) then proto m = Proto TCP \\<or> proto m = Proto UDP \\<or> proto m = Proto L4_Protocol.SCTP else True)) \\<and>\n  valid_prefix_fw (src m) \\<and> valid_prefix_fw (dst m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_match_valid =\n    (\\<lambda>m.\n        (let c = \\<lambda>(s, e). s \\<noteq> 0 \\<or> e \\<noteq> - 1\n         in if c (sports m) \\<or> c (dports m)\n            then proto m = Proto TCP \\<or>\n                 proto m = Proto UDP \\<or> proto m = Proto L4_Protocol.SCTP\n            else True) \\<and>\n        valid_prefix_fw (src m) \\<and> valid_prefix_fw (dst m))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. simple_match_valid =\n    (\\<lambda>m.\n        (let c = \\<lambda>(s, e). s \\<noteq> 0 \\<or> e \\<noteq> - 1\n         in if c (sports m) \\<or> c (dports m)\n            then proto m = Proto TCP \\<or>\n                 proto m = Proto UDP \\<or> proto m = Proto L4_Protocol.SCTP\n            else True) \\<and>\n        valid_prefix_fw (src m) \\<and> valid_prefix_fw (dst m))", "have simple_match_valid_alt_hlp1: \"{p. simple_match_port x p} \\<noteq> UNIV \\<longleftrightarrow> (case x of (s,e) \\<Rightarrow> s \\<noteq> 0 \\<or> e \\<noteq> max_word)\"\n      for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({p. simple_match_port x p} \\<noteq> UNIV) =\n    (case x of (s, e) \\<Rightarrow> s \\<noteq> 0 \\<or> e \\<noteq> - 1)", "using simple_match_port_UNIV"], ["proof (prove)\nusing this:\n  ({p. simple_match_port (?s, ?e) p} = UNIV) = (?s = 0 \\<and> ?e = - 1)\n\ngoal (1 subgoal):\n 1. ({p. simple_match_port x p} \\<noteq> UNIV) =\n    (case x of (s, e) \\<Rightarrow> s \\<noteq> 0 \\<or> e \\<noteq> - 1)", "by auto"], ["proof (state)\nthis:\n  ({p. simple_match_port ?x p} \\<noteq> UNIV) =\n  (case ?x of (s, e) \\<Rightarrow> s \\<noteq> 0 \\<or> e \\<noteq> - 1)\n\ngoal (1 subgoal):\n 1. simple_match_valid =\n    (\\<lambda>m.\n        (let c = \\<lambda>(s, e). s \\<noteq> 0 \\<or> e \\<noteq> - 1\n         in if c (sports m) \\<or> c (dports m)\n            then proto m = Proto TCP \\<or>\n                 proto m = Proto UDP \\<or> proto m = Proto L4_Protocol.SCTP\n            else True) \\<and>\n        valid_prefix_fw (src m) \\<and> valid_prefix_fw (dst m))", "have simple_match_valid_alt_hlp2: \"{p. simple_match_port x p} \\<noteq> {} \\<longleftrightarrow> (case x of (s,e) \\<Rightarrow> s \\<le> e)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({p. simple_match_port x p} \\<noteq> {}) =\n    (case x of (s, e) \\<Rightarrow> s \\<le> e)", "by auto"], ["proof (state)\nthis:\n  ({p. simple_match_port ?x p} \\<noteq> {}) =\n  (case ?x of (s, e) \\<Rightarrow> s \\<le> e)\n\ngoal (1 subgoal):\n 1. simple_match_valid =\n    (\\<lambda>m.\n        (let c = \\<lambda>(s, e). s \\<noteq> 0 \\<or> e \\<noteq> - 1\n         in if c (sports m) \\<or> c (dports m)\n            then proto m = Proto TCP \\<or>\n                 proto m = Proto UDP \\<or> proto m = Proto L4_Protocol.SCTP\n            else True) \\<and>\n        valid_prefix_fw (src m) \\<and> valid_prefix_fw (dst m))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_match_valid =\n    (\\<lambda>m.\n        (let c = \\<lambda>(s, e). s \\<noteq> 0 \\<or> e \\<noteq> - 1\n         in if c (sports m) \\<or> c (dports m)\n            then proto m = Proto TCP \\<or>\n                 proto m = Proto UDP \\<or> proto m = Proto L4_Protocol.SCTP\n            else True) \\<and>\n        valid_prefix_fw (src m) \\<and> valid_prefix_fw (dst m))", "unfolding fun_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       simple_match_valid x =\n       ((let c = \\<lambda>(s, e). s \\<noteq> 0 \\<or> e \\<noteq> - 1\n         in if c (sports x) \\<or> c (dports x)\n            then proto x = Proto TCP \\<or>\n                 proto x = Proto UDP \\<or> proto x = Proto L4_Protocol.SCTP\n            else True) \\<and>\n        valid_prefix_fw (src x) \\<and> valid_prefix_fw (dst x))", "unfolding simple_match_valid_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (({p. simple_match_port (sports x) p} \\<noteq> UNIV \\<or>\n         {p. simple_match_port (dports x) p} \\<noteq> UNIV \\<longrightarrow>\n         proto x \\<in> Proto ` {TCP, UDP, L4_Protocol.SCTP}) \\<and>\n        valid_prefix_fw (src x) \\<and> valid_prefix_fw (dst x)) =\n       ((if (case sports x of\n             (s, e) \\<Rightarrow> s \\<noteq> 0 \\<or> e \\<noteq> - 1) \\<or>\n            (case dports x of\n             (s, e) \\<Rightarrow> s \\<noteq> 0 \\<or> e \\<noteq> - 1)\n         then proto x = Proto TCP \\<or>\n              proto x = Proto UDP \\<or> proto x = Proto L4_Protocol.SCTP\n         else True) \\<and>\n        valid_prefix_fw (src x) \\<and> valid_prefix_fw (dst x))", "unfolding simple_match_valid_alt_hlp1 simple_match_valid_alt_hlp2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       (((case sports x of\n          (s, e) \\<Rightarrow> s \\<noteq> 0 \\<or> e \\<noteq> - 1) \\<or>\n         (case dports x of\n          (s, e) \\<Rightarrow>\n            s \\<noteq> 0 \\<or> e \\<noteq> - 1) \\<longrightarrow>\n         proto x \\<in> Proto ` {TCP, UDP, L4_Protocol.SCTP}) \\<and>\n        valid_prefix_fw (src x) \\<and> valid_prefix_fw (dst x)) =\n       ((if (case sports x of\n             (s, e) \\<Rightarrow> s \\<noteq> 0 \\<or> e \\<noteq> - 1) \\<or>\n            (case dports x of\n             (s, e) \\<Rightarrow> s \\<noteq> 0 \\<or> e \\<noteq> - 1)\n         then proto x = Proto TCP \\<or>\n              proto x = Proto UDP \\<or> proto x = Proto L4_Protocol.SCTP\n         else True) \\<and>\n        valid_prefix_fw (src x) \\<and> valid_prefix_fw (dst x))", "apply(clarify, rename_tac m, case_tac \"sports m\"; case_tac \"dports m\"; case_tac \"proto m\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m a b aa ba.\n       \\<lbrakk>sports m = (a, b); dports m = (aa, ba);\n        proto m = ProtoAny\\<rbrakk>\n       \\<Longrightarrow> (((case sports m of\n                            (s, e) \\<Rightarrow>\n                              s \\<noteq> 0 \\<or> e \\<noteq> - 1) \\<or>\n                           (case dports m of\n                            (s, e) \\<Rightarrow>\n                              s \\<noteq> 0 \\<or>\n                              e \\<noteq> - 1) \\<longrightarrow>\n                           proto m\n                           \\<in> Proto `\n                                 {TCP, UDP, L4_Protocol.SCTP}) \\<and>\n                          valid_prefix_fw (src m) \\<and>\n                          valid_prefix_fw (dst m)) =\n                         ((if (case sports m of\n                               (s, e) \\<Rightarrow>\n                                 s \\<noteq> 0 \\<or> e \\<noteq> - 1) \\<or>\n                              (case dports m of\n                               (s, e) \\<Rightarrow>\n                                 s \\<noteq> 0 \\<or> e \\<noteq> - 1)\n                           then proto m = Proto TCP \\<or>\n                                proto m = Proto UDP \\<or>\n                                proto m = Proto L4_Protocol.SCTP\n                           else True) \\<and>\n                          valid_prefix_fw (src m) \\<and>\n                          valid_prefix_fw (dst m))\n 2. \\<And>m a b aa ba x2.\n       \\<lbrakk>sports m = (a, b); dports m = (aa, ba);\n        proto m = Proto x2\\<rbrakk>\n       \\<Longrightarrow> (((case sports m of\n                            (s, e) \\<Rightarrow>\n                              s \\<noteq> 0 \\<or> e \\<noteq> - 1) \\<or>\n                           (case dports m of\n                            (s, e) \\<Rightarrow>\n                              s \\<noteq> 0 \\<or>\n                              e \\<noteq> - 1) \\<longrightarrow>\n                           proto m\n                           \\<in> Proto `\n                                 {TCP, UDP, L4_Protocol.SCTP}) \\<and>\n                          valid_prefix_fw (src m) \\<and>\n                          valid_prefix_fw (dst m)) =\n                         ((if (case sports m of\n                               (s, e) \\<Rightarrow>\n                                 s \\<noteq> 0 \\<or> e \\<noteq> - 1) \\<or>\n                              (case dports m of\n                               (s, e) \\<Rightarrow>\n                                 s \\<noteq> 0 \\<or> e \\<noteq> - 1)\n                           then proto m = Proto TCP \\<or>\n                                proto m = Proto UDP \\<or>\n                                proto m = Proto L4_Protocol.SCTP\n                           else True) \\<and>\n                          valid_prefix_fw (src m) \\<and>\n                          valid_prefix_fw (dst m))", "by auto"], ["proof (state)\nthis:\n  simple_match_valid =\n  (\\<lambda>m.\n      (let c = \\<lambda>(s, e). s \\<noteq> 0 \\<or> e \\<noteq> - 1\n       in if c (sports m) \\<or> c (dports m)\n          then proto m = Proto TCP \\<or>\n               proto m = Proto UDP \\<or> proto m = Proto L4_Protocol.SCTP\n          else True) \\<and>\n      valid_prefix_fw (src m) \\<and> valid_prefix_fw (dst m))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Example:\\<close>"], ["", "context\n  begin"], ["", "private"], ["", "definition \"example_simple_match1 \\<equiv>\n      \\<lparr>iiface = Iface ''+'', oiface = Iface ''+'', src = (0::32 word, 0), dst = (0, 0),\n       proto = Proto TCP, sports = (0, 1024), dports = (0, 1024)\\<rparr>\""], ["", "lemma \"simple_fw [SimpleRule example_simple_match1 Drop]\n      \\<lparr>p_iiface = '''', p_oiface = '''',  p_src = (1::32 word), p_dst = 2, p_proto = TCP, p_sport = 8,\n       p_dport = 9, p_tcp_flags = {}, p_payload = ''''\\<rparr> =\n        Decision FinalDeny\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_fw [SimpleRule example_simple_match1 Drop]\n     \\<lparr>p_iiface = [], p_oiface = [], p_src = 1, p_dst = 2,\n        p_proto = TCP, p_sport = 8, p_dport = 9, p_tcp_flags = {},\n        p_payload = []\\<rparr> =\n    Decision FinalDeny", "by eval"], ["", "private"], ["", "definition \"example_simple_match2 \\<equiv> example_simple_match1\\<lparr> proto := ProtoAny \\<rparr>\""], ["", "text\\<open>Thus, \\<open>example_simple_match1\\<close> is valid, but if we set its protocol match to any, it isn't anymore\\<close>"], ["", "private"], ["", "lemma \"simple_match_valid example_simple_match1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_match_valid example_simple_match1", "by eval"], ["", "private"], ["", "lemma \"\\<not> simple_match_valid example_simple_match2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> simple_match_valid example_simple_match2", "by eval"], ["", "end"], ["", "lemma simple_match_and_valid: \n    fixes m1 :: \"'i::len simple_match\"\n    assumes mv: \"simple_match_valid m1\" \"simple_match_valid m2\"\n    assumes mj: \"simple_match_and m1 m2 = Some m\"\n    shows \"simple_match_valid m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_match_valid m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. simple_match_valid m", "have simpl_ports_conjunct_not_UNIV:\n    \"Collect (simple_match_port x) \\<noteq> UNIV \\<Longrightarrow>\n      x = simpl_ports_conjunct p1 p2 \\<Longrightarrow>\n      Collect (simple_match_port p1) \\<noteq> UNIV \\<or> Collect (simple_match_port p2) \\<noteq> UNIV\" \n    for x p1 p2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Collect (simple_match_port x) \\<noteq> UNIV;\n     x = simpl_ports_conjunct p1 p2\\<rbrakk>\n    \\<Longrightarrow> Collect (simple_match_port p1) \\<noteq> UNIV \\<or>\n                      Collect (simple_match_port p2) \\<noteq> UNIV", "by (metis Collect_cong mem_Collect_eq simple_ports_conjunct_correct)"], ["proof (state)\nthis:\n  \\<lbrakk>Collect (simple_match_port ?x) \\<noteq> UNIV;\n   ?x = simpl_ports_conjunct ?p1.0 ?p2.0\\<rbrakk>\n  \\<Longrightarrow> Collect (simple_match_port ?p1.0) \\<noteq> UNIV \\<or>\n                    Collect (simple_match_port ?p2.0) \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. simple_match_valid m", "(* prefix validity. That's simple. *)"], ["proof (state)\nthis:\n  \\<lbrakk>Collect (simple_match_port ?x) \\<noteq> UNIV;\n   ?x = simpl_ports_conjunct ?p1.0 ?p2.0\\<rbrakk>\n  \\<Longrightarrow> Collect (simple_match_port ?p1.0) \\<noteq> UNIV \\<or>\n                    Collect (simple_match_port ?p2.0) \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. simple_match_valid m", "have \"valid_prefix_fw (src m1)\" \"valid_prefix_fw (src m2)\" \"valid_prefix_fw (dst m1)\" \"valid_prefix_fw (dst m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (valid_prefix_fw (src m1) &&& valid_prefix_fw (src m2)) &&&\n    valid_prefix_fw (dst m1) &&& valid_prefix_fw (dst m2)", "using mv"], ["proof (prove)\nusing this:\n  simple_match_valid m1\n  simple_match_valid m2\n\ngoal (1 subgoal):\n 1. (valid_prefix_fw (src m1) &&& valid_prefix_fw (src m2)) &&&\n    valid_prefix_fw (dst m1) &&& valid_prefix_fw (dst m2)", "unfolding simple_match_valid_alt"], ["proof (prove)\nusing this:\n  (let c = \\<lambda>(s, e). s \\<noteq> 0 \\<or> e \\<noteq> - 1\n   in if c (sports m1) \\<or> c (dports m1)\n      then proto m1 = Proto TCP \\<or>\n           proto m1 = Proto UDP \\<or> proto m1 = Proto L4_Protocol.SCTP\n      else True) \\<and>\n  valid_prefix_fw (src m1) \\<and> valid_prefix_fw (dst m1)\n  (let c = \\<lambda>(s, e). s \\<noteq> 0 \\<or> e \\<noteq> - 1\n   in if c (sports m2) \\<or> c (dports m2)\n      then proto m2 = Proto TCP \\<or>\n           proto m2 = Proto UDP \\<or> proto m2 = Proto L4_Protocol.SCTP\n      else True) \\<and>\n  valid_prefix_fw (src m2) \\<and> valid_prefix_fw (dst m2)\n\ngoal (1 subgoal):\n 1. (valid_prefix_fw (src m1) &&& valid_prefix_fw (src m2)) &&&\n    valid_prefix_fw (dst m1) &&& valid_prefix_fw (dst m2)", "by simp_all"], ["proof (state)\nthis:\n  valid_prefix_fw (src m1)\n  valid_prefix_fw (src m2)\n  valid_prefix_fw (dst m1)\n  valid_prefix_fw (dst m2)\n\ngoal (1 subgoal):\n 1. simple_match_valid m", "moreover"], ["proof (state)\nthis:\n  valid_prefix_fw (src m1)\n  valid_prefix_fw (src m2)\n  valid_prefix_fw (dst m1)\n  valid_prefix_fw (dst m2)\n\ngoal (1 subgoal):\n 1. simple_match_valid m", "have \"ipcidr_conjunct (src m1) (src m2) = Some (src m)\"\n                  \"ipcidr_conjunct (dst m1) (dst m2) = Some (dst m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipcidr_conjunct (src m1) (src m2) = Some (src m) &&&\n    ipcidr_conjunct (dst m1) (dst m2) = Some (dst m)", "using mj"], ["proof (prove)\nusing this:\n  simple_match_and m1 m2 = Some m\n\ngoal (1 subgoal):\n 1. ipcidr_conjunct (src m1) (src m2) = Some (src m) &&&\n    ipcidr_conjunct (dst m1) (dst m2) = Some (dst m)", "by(cases m1; cases m2; cases m; simp split: option.splits)+"], ["proof (state)\nthis:\n  ipcidr_conjunct (src m1) (src m2) = Some (src m)\n  ipcidr_conjunct (dst m1) (dst m2) = Some (dst m)\n\ngoal (1 subgoal):\n 1. simple_match_valid m", "ultimately"], ["proof (chain)\npicking this:\n  valid_prefix_fw (src m1)\n  valid_prefix_fw (src m2)\n  valid_prefix_fw (dst m1)\n  valid_prefix_fw (dst m2)\n  ipcidr_conjunct (src m1) (src m2) = Some (src m)\n  ipcidr_conjunct (dst m1) (dst m2) = Some (dst m)", "have pv: \"valid_prefix_fw (src m)\" \"valid_prefix_fw (dst m)\""], ["proof (prove)\nusing this:\n  valid_prefix_fw (src m1)\n  valid_prefix_fw (src m2)\n  valid_prefix_fw (dst m1)\n  valid_prefix_fw (dst m2)\n  ipcidr_conjunct (src m1) (src m2) = Some (src m)\n  ipcidr_conjunct (dst m1) (dst m2) = Some (dst m)\n\ngoal (1 subgoal):\n 1. valid_prefix_fw (src m) &&& valid_prefix_fw (dst m)", "using ipcidr_conjunct_valid"], ["proof (prove)\nusing this:\n  valid_prefix_fw (src m1)\n  valid_prefix_fw (src m2)\n  valid_prefix_fw (dst m1)\n  valid_prefix_fw (dst m2)\n  ipcidr_conjunct (src m1) (src m2) = Some (src m)\n  ipcidr_conjunct (dst m1) (dst m2) = Some (dst m)\n  \\<lbrakk>valid_prefix_fw ?p1.0; valid_prefix_fw ?p2.0;\n   ipcidr_conjunct ?p1.0 ?p2.0 = Some ?p\\<rbrakk>\n  \\<Longrightarrow> valid_prefix_fw ?p\n\ngoal (1 subgoal):\n 1. valid_prefix_fw (src m) &&& valid_prefix_fw (dst m)", "by blast+"], ["proof (state)\nthis:\n  valid_prefix_fw (src m)\n  valid_prefix_fw (dst m)\n\ngoal (1 subgoal):\n 1. simple_match_valid m", "(* now for the source ports\\<dots> *)"], ["proof (state)\nthis:\n  valid_prefix_fw (src m)\n  valid_prefix_fw (dst m)\n\ngoal (1 subgoal):\n 1. simple_match_valid m", "define nmu where \"nmu ps \\<longleftrightarrow> {p. simple_match_port ps p} \\<noteq> UNIV\" for ps"], ["proof (state)\nthis:\n  nmu ?ps = ({p. simple_match_port ?ps p} \\<noteq> UNIV)\n\ngoal (1 subgoal):\n 1. simple_match_valid m", "have \"simpl_ports_conjunct (sports m1) (sports m2) = (sports m)\" (is \"?ph1 sports\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. simpl_ports_conjunct (sports m1) (sports m2) = sports m", "using mj"], ["proof (prove)\nusing this:\n  simple_match_and m1 m2 = Some m\n\ngoal (1 subgoal):\n 1. simpl_ports_conjunct (sports m1) (sports m2) = sports m", "by(cases m1; cases m2; cases m; simp split: option.splits)"], ["proof (state)\nthis:\n  simpl_ports_conjunct (sports m1) (sports m2) = sports m\n\ngoal (1 subgoal):\n 1. simple_match_valid m", "hence sp: \"nmu (sports m) \\<longrightarrow> nmu (sports m1) \\<or> nmu (sports m2)\"\n      (is \"?ph2 sports\")"], ["proof (prove)\nusing this:\n  simpl_ports_conjunct (sports m1) (sports m2) = sports m\n\ngoal (1 subgoal):\n 1. nmu (sports m) \\<longrightarrow> nmu (sports m1) \\<or> nmu (sports m2)", "unfolding nmu_def"], ["proof (prove)\nusing this:\n  simpl_ports_conjunct (sports m1) (sports m2) = sports m\n\ngoal (1 subgoal):\n 1. Collect (simple_match_port (sports m)) \\<noteq> UNIV \\<longrightarrow>\n    Collect (simple_match_port (sports m1)) \\<noteq> UNIV \\<or>\n    Collect (simple_match_port (sports m2)) \\<noteq> UNIV", "using simpl_ports_conjunct_not_UNIV"], ["proof (prove)\nusing this:\n  simpl_ports_conjunct (sports m1) (sports m2) = sports m\n  \\<lbrakk>Collect (simple_match_port ?x) \\<noteq> UNIV;\n   ?x = simpl_ports_conjunct ?p1.0 ?p2.0\\<rbrakk>\n  \\<Longrightarrow> Collect (simple_match_port ?p1.0) \\<noteq> UNIV \\<or>\n                    Collect (simple_match_port ?p2.0) \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. Collect (simple_match_port (sports m)) \\<noteq> UNIV \\<longrightarrow>\n    Collect (simple_match_port (sports m1)) \\<noteq> UNIV \\<or>\n    Collect (simple_match_port (sports m2)) \\<noteq> UNIV", "by metis"], ["proof (state)\nthis:\n  nmu (sports m) \\<longrightarrow> nmu (sports m1) \\<or> nmu (sports m2)\n\ngoal (1 subgoal):\n 1. simple_match_valid m", "(* dst ports: mutatis mutandem *)"], ["proof (state)\nthis:\n  nmu (sports m) \\<longrightarrow> nmu (sports m1) \\<or> nmu (sports m2)\n\ngoal (1 subgoal):\n 1. simple_match_valid m", "have \"?ph1 dports\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simpl_ports_conjunct (dports m1) (dports m2) = dports m", "using mj"], ["proof (prove)\nusing this:\n  simple_match_and m1 m2 = Some m\n\ngoal (1 subgoal):\n 1. simpl_ports_conjunct (dports m1) (dports m2) = dports m", "by(cases m1; cases m2; cases m; simp split: option.splits)"], ["proof (state)\nthis:\n  simpl_ports_conjunct (dports m1) (dports m2) = dports m\n\ngoal (1 subgoal):\n 1. simple_match_valid m", "hence dp: \"?ph2 dports\""], ["proof (prove)\nusing this:\n  simpl_ports_conjunct (dports m1) (dports m2) = dports m\n\ngoal (1 subgoal):\n 1. nmu (dports m) \\<longrightarrow> nmu (dports m1) \\<or> nmu (dports m2)", "unfolding nmu_def"], ["proof (prove)\nusing this:\n  simpl_ports_conjunct (dports m1) (dports m2) = dports m\n\ngoal (1 subgoal):\n 1. Collect (simple_match_port (dports m)) \\<noteq> UNIV \\<longrightarrow>\n    Collect (simple_match_port (dports m1)) \\<noteq> UNIV \\<or>\n    Collect (simple_match_port (dports m2)) \\<noteq> UNIV", "using simpl_ports_conjunct_not_UNIV"], ["proof (prove)\nusing this:\n  simpl_ports_conjunct (dports m1) (dports m2) = dports m\n  \\<lbrakk>Collect (simple_match_port ?x) \\<noteq> UNIV;\n   ?x = simpl_ports_conjunct ?p1.0 ?p2.0\\<rbrakk>\n  \\<Longrightarrow> Collect (simple_match_port ?p1.0) \\<noteq> UNIV \\<or>\n                    Collect (simple_match_port ?p2.0) \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. Collect (simple_match_port (dports m)) \\<noteq> UNIV \\<longrightarrow>\n    Collect (simple_match_port (dports m1)) \\<noteq> UNIV \\<or>\n    Collect (simple_match_port (dports m2)) \\<noteq> UNIV", "by metis"], ["proof (state)\nthis:\n  nmu (dports m) \\<longrightarrow> nmu (dports m1) \\<or> nmu (dports m2)\n\ngoal (1 subgoal):\n 1. simple_match_valid m", "(* And an argument for the protocol. *)"], ["proof (state)\nthis:\n  nmu (dports m) \\<longrightarrow> nmu (dports m1) \\<or> nmu (dports m2)\n\ngoal (1 subgoal):\n 1. simple_match_valid m", "define php where \"php mr \\<longleftrightarrow> proto mr \\<in> Proto ` {TCP, UDP, L4_Protocol.SCTP}\"\n      for mr :: \"'i simple_match\""], ["proof (state)\nthis:\n  php ?mr = (proto ?mr \\<in> Proto ` {TCP, UDP, L4_Protocol.SCTP})\n\ngoal (1 subgoal):\n 1. simple_match_valid m", "have pcj: \"simple_proto_conjunct (proto m1) (proto m2) = Some (proto m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_proto_conjunct (proto m1) (proto m2) = Some (proto m)", "using mj"], ["proof (prove)\nusing this:\n  simple_match_and m1 m2 = Some m\n\ngoal (1 subgoal):\n 1. simple_proto_conjunct (proto m1) (proto m2) = Some (proto m)", "by(cases m1; cases m2; cases m; simp split: option.splits)"], ["proof (state)\nthis:\n  simple_proto_conjunct (proto m1) (proto m2) = Some (proto m)\n\ngoal (1 subgoal):\n 1. simple_match_valid m", "hence p: \"php m1 \\<Longrightarrow> php m\"\n             \"php m2 \\<Longrightarrow> php m\""], ["proof (prove)\nusing this:\n  simple_proto_conjunct (proto m1) (proto m2) = Some (proto m)\n\ngoal (1 subgoal):\n 1. (php m1 \\<Longrightarrow> php m) &&& (php m2 \\<Longrightarrow> php m)", "using conjunctProtoD conjunctProtoD2 pcj"], ["proof (prove)\nusing this:\n  simple_proto_conjunct (proto m1) (proto m2) = Some (proto m)\n  simple_proto_conjunct ?a (Proto ?b) = Some ?x \\<Longrightarrow>\n  ?x = Proto ?b \\<and> (?a = ProtoAny \\<or> ?a = Proto ?b)\n  simple_proto_conjunct (Proto ?b) ?a = Some ?x \\<Longrightarrow>\n  ?x = Proto ?b \\<and> (?a = ProtoAny \\<or> ?a = Proto ?b)\n  simple_proto_conjunct (proto m1) (proto m2) = Some (proto m)\n\ngoal (1 subgoal):\n 1. (php m1 \\<Longrightarrow> php m) &&& (php m2 \\<Longrightarrow> php m)", "unfolding php_def"], ["proof (prove)\nusing this:\n  simple_proto_conjunct (proto m1) (proto m2) = Some (proto m)\n  simple_proto_conjunct ?a (Proto ?b) = Some ?x \\<Longrightarrow>\n  ?x = Proto ?b \\<and> (?a = ProtoAny \\<or> ?a = Proto ?b)\n  simple_proto_conjunct (Proto ?b) ?a = Some ?x \\<Longrightarrow>\n  ?x = Proto ?b \\<and> (?a = ProtoAny \\<or> ?a = Proto ?b)\n  simple_proto_conjunct (proto m1) (proto m2) = Some (proto m)\n\ngoal (1 subgoal):\n 1. (proto m1 \\<in> Proto ` {TCP, UDP, L4_Protocol.SCTP} \\<Longrightarrow>\n     proto m \\<in> Proto ` {TCP, UDP, L4_Protocol.SCTP}) &&&\n    (proto m2 \\<in> Proto ` {TCP, UDP, L4_Protocol.SCTP} \\<Longrightarrow>\n     proto m \\<in> Proto ` {TCP, UDP, L4_Protocol.SCTP})", "by auto"], ["proof (state)\nthis:\n  php m1 \\<Longrightarrow> php m\n  php m2 \\<Longrightarrow> php m\n\ngoal (1 subgoal):\n 1. simple_match_valid m", "(* Since I'm trying to trick the simplifier with these defs, I need these as explicit statements: *)"], ["proof (state)\nthis:\n  php m1 \\<Longrightarrow> php m\n  php m2 \\<Longrightarrow> php m\n\ngoal (1 subgoal):\n 1. simple_match_valid m", "have \"\\<And>mx. simple_match_valid mx \\<Longrightarrow> nmu (sports mx) \\<or> nmu (dports mx) \\<Longrightarrow> php mx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mx.\n       \\<lbrakk>simple_match_valid mx;\n        nmu (sports mx) \\<or> nmu (dports mx)\\<rbrakk>\n       \\<Longrightarrow> php mx", "unfolding nmu_def php_def simple_match_valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mx.\n       \\<lbrakk>({p. simple_match_port (sports mx) p} \\<noteq> UNIV \\<or>\n                 {p. simple_match_port (dports mx) p} \\<noteq>\n                 UNIV \\<longrightarrow>\n                 proto mx \\<in> Proto ` {TCP, UDP, L4_Protocol.SCTP}) \\<and>\n                valid_prefix_fw (src mx) \\<and> valid_prefix_fw (dst mx);\n        Collect (simple_match_port (sports mx)) \\<noteq> UNIV \\<or>\n        Collect (simple_match_port (dports mx)) \\<noteq> UNIV\\<rbrakk>\n       \\<Longrightarrow> proto mx \\<in> Proto ` {TCP, UDP, L4_Protocol.SCTP}", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>simple_match_valid ?mx;\n   nmu (sports ?mx) \\<or> nmu (dports ?mx)\\<rbrakk>\n  \\<Longrightarrow> php ?mx\n\ngoal (1 subgoal):\n 1. simple_match_valid m", "hence mps: \"nmu (sports m1) \\<Longrightarrow> php m1\" \"nmu (dports m1) \\<Longrightarrow> php m1\"\n               \"nmu (sports m2) \\<Longrightarrow> php m2\" \"nmu (dports m2) \\<Longrightarrow> php m2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>simple_match_valid ?mx;\n   nmu (sports ?mx) \\<or> nmu (dports ?mx)\\<rbrakk>\n  \\<Longrightarrow> php ?mx\n\ngoal (1 subgoal):\n 1. ((nmu (sports m1) \\<Longrightarrow> php m1) &&&\n     (nmu (dports m1) \\<Longrightarrow> php m1)) &&&\n    (nmu (sports m2) \\<Longrightarrow> php m2) &&&\n    (nmu (dports m2) \\<Longrightarrow> php m2)", "using mv"], ["proof (prove)\nusing this:\n  \\<lbrakk>simple_match_valid ?mx;\n   nmu (sports ?mx) \\<or> nmu (dports ?mx)\\<rbrakk>\n  \\<Longrightarrow> php ?mx\n  simple_match_valid m1\n  simple_match_valid m2\n\ngoal (1 subgoal):\n 1. ((nmu (sports m1) \\<Longrightarrow> php m1) &&&\n     (nmu (dports m1) \\<Longrightarrow> php m1)) &&&\n    (nmu (sports m2) \\<Longrightarrow> php m2) &&&\n    (nmu (dports m2) \\<Longrightarrow> php m2)", "by blast+"], ["proof (state)\nthis:\n  nmu (sports m1) \\<Longrightarrow> php m1\n  nmu (dports m1) \\<Longrightarrow> php m1\n  nmu (sports m2) \\<Longrightarrow> php m2\n  nmu (dports m2) \\<Longrightarrow> php m2\n\ngoal (1 subgoal):\n 1. simple_match_valid m", "have pa: \"nmu (sports m) \\<or> nmu (dports m) \\<longrightarrow> php m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nmu (sports m) \\<or> nmu (dports m) \\<longrightarrow> php m", "(*  apply(intro impI)\n      apply(elim disjE)\n      apply(drule sp[THEN mp])\n      apply(elim disjE)\n      apply(drule mps)\n      apply(elim p; fail) *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nmu (sports m) \\<or> nmu (dports m) \\<longrightarrow> php m", "using sp dp mps p"], ["proof (prove)\nusing this:\n  nmu (sports m) \\<longrightarrow> nmu (sports m1) \\<or> nmu (sports m2)\n  nmu (dports m) \\<longrightarrow> nmu (dports m1) \\<or> nmu (dports m2)\n  nmu (sports m1) \\<Longrightarrow> php m1\n  nmu (dports m1) \\<Longrightarrow> php m1\n  nmu (sports m2) \\<Longrightarrow> php m2\n  nmu (dports m2) \\<Longrightarrow> php m2\n  php m1 \\<Longrightarrow> php m\n  php m2 \\<Longrightarrow> php m\n\ngoal (1 subgoal):\n 1. nmu (sports m) \\<or> nmu (dports m) \\<longrightarrow> php m", "by fast"], ["proof (state)\nthis:\n  nmu (sports m) \\<or> nmu (dports m) \\<longrightarrow> php m\n\ngoal (1 subgoal):\n 1. simple_match_valid m", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_match_valid m", "unfolding simple_match_valid_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({p. simple_match_port (sports m) p} \\<noteq> UNIV \\<or>\n     {p. simple_match_port (dports m) p} \\<noteq> UNIV \\<longrightarrow>\n     proto m \\<in> Proto ` {TCP, UDP, L4_Protocol.SCTP}) \\<and>\n    valid_prefix_fw (src m) \\<and> valid_prefix_fw (dst m)", "using pv pa[unfolded nmu_def php_def]"], ["proof (prove)\nusing this:\n  valid_prefix_fw (src m)\n  valid_prefix_fw (dst m)\n  Collect (simple_match_port (sports m)) \\<noteq> UNIV \\<or>\n  Collect (simple_match_port (dports m)) \\<noteq> UNIV \\<longrightarrow>\n  proto m \\<in> Proto ` {TCP, UDP, L4_Protocol.SCTP}\n\ngoal (1 subgoal):\n 1. ({p. simple_match_port (sports m) p} \\<noteq> UNIV \\<or>\n     {p. simple_match_port (dports m) p} \\<noteq> UNIV \\<longrightarrow>\n     proto m \\<in> Proto ` {TCP, UDP, L4_Protocol.SCTP}) \\<and>\n    valid_prefix_fw (src m) \\<and> valid_prefix_fw (dst m)", "by blast"], ["proof (state)\nthis:\n  simple_match_valid m\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"simple_fw_valid \\<equiv> list_all (simple_match_valid \\<circ> match_sel)\""], ["", "text\\<open>The simple firewall does not care about tcp flags, payload, or any other packet extensions.\\<close>"], ["", "lemma simple_matches_extended_packet:\n      \"simple_matches m\n        \\<lparr>p_iiface = iifce,\n         oiface = oifce,\n         p_src = s, dst = d,\n         p_proto = prot,\n         p_sport = sport, p_dport = dport,\n         tcp_flags = tcp_flags, p_payload = payload1\\<rparr>\n        \\<longleftrightarrow>\n       simple_matches m\n        \\<lparr>p_iiface = iifce,\n         oiface = oifce,\n         p_src = s, p_dst = d,\n         p_proto = prot,\n         p_sport = sport, p_dport = dport,\n         p_tcp_flags = tcp_flags2, p_payload = payload2, \\<dots> = aux\\<rparr>\n        \""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_matches m\n     \\<lparr>p_iiface = iifce, p_oiface = oifce, p_src = s, p_dst = d,\n        p_proto = prot, p_sport = sport, p_dport = dport,\n        p_tcp_flags = tcp_flags, p_payload = payload1\\<rparr> =\n    simple_matches m\n     \\<lparr>p_iiface = iifce, p_oiface = oifce, p_src = s, p_dst = d,\n        p_proto = prot, p_sport = sport, p_dport = dport,\n        p_tcp_flags = tcp_flags2, p_payload = payload2,\n        \\<dots> = aux\\<rparr>", "by(simp add: simple_matches.simps)"], ["", "end"]]}