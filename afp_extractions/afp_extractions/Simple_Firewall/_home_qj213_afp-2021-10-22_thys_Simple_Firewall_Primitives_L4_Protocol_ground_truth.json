{"file_name": "/home/qj213/afp-2021-10-22/thys/Simple_Firewall/Primitives/L4_Protocol.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Simple_Firewall", "problem_names": ["lemma simple_proto_conjunct_asimp[simp]: \"simple_proto_conjunct proto ProtoAny = Some proto\"", "lemma simple_proto_conjunct_correct: \"match_proto p1 pkt \\<and> match_proto p2 pkt \\<longleftrightarrow> \n    (case simple_proto_conjunct p1 p2 of None \\<Rightarrow> False | Some proto \\<Rightarrow> match_proto proto pkt)\"", "lemma simple_proto_conjunct_Some: \"simple_proto_conjunct p1 p2 = Some proto \\<Longrightarrow> \n    match_proto proto pkt \\<longleftrightarrow> match_proto p1 pkt \\<and> match_proto p2 pkt\"", "lemma simple_proto_conjunct_None: \"simple_proto_conjunct p1 p2 = None \\<Longrightarrow> \n    \\<not> (match_proto p1 pkt \\<and> match_proto p2 pkt)\"", "lemma conjunctProtoD:\n    \"simple_proto_conjunct a (Proto b) = Some x \\<Longrightarrow> x = Proto b \\<and> (a = ProtoAny \\<or> a = Proto b)\"", "lemma conjunctProtoD2:\n    \"simple_proto_conjunct (Proto b) a = Some x \\<Longrightarrow> x = Proto b \\<and> (a = ProtoAny \\<or> a = Proto b)\"", "lemma primitive_protocol_Ex_neq: \"p = Proto pi \\<Longrightarrow> \\<exists>p'. p' \\<noteq> pi\" for pi", "lemma protocol_Ex_neq: \"\\<exists>p'. Proto p' \\<noteq> p\"", "lemma UNIV_tcp_flag: \"UNIV = {TCP_SYN, TCP_ACK, TCP_FIN, TCP_RST, TCP_URG, TCP_PSH}\"", "lemma \"ipt_tcp_flags_toString {TCP_SYN,TCP_SYN,TCP_ACK} = ''[TCP_SYN, TCP_ACK]''\""], "translations": [["", "lemma simple_proto_conjunct_asimp[simp]: \"simple_proto_conjunct proto ProtoAny = Some proto\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_proto_conjunct proto ProtoAny = Some proto", "by(cases proto) simp_all"], ["", "lemma simple_proto_conjunct_correct: \"match_proto p1 pkt \\<and> match_proto p2 pkt \\<longleftrightarrow> \n    (case simple_proto_conjunct p1 p2 of None \\<Rightarrow> False | Some proto \\<Rightarrow> match_proto proto pkt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (match_proto p1 pkt \\<and> match_proto p2 pkt) =\n    (case simple_proto_conjunct p1 p2 of None \\<Rightarrow> False\n     | Some proto \\<Rightarrow> match_proto proto pkt)", "apply(cases p1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p1 = ProtoAny \\<Longrightarrow>\n    (match_proto p1 pkt \\<and> match_proto p2 pkt) =\n    (case simple_proto_conjunct p1 p2 of None \\<Rightarrow> False\n     | Some proto \\<Rightarrow> match_proto proto pkt)\n 2. \\<And>x2.\n       p1 = Proto x2 \\<Longrightarrow>\n       (match_proto p1 pkt \\<and> match_proto p2 pkt) =\n       (case simple_proto_conjunct p1 p2 of None \\<Rightarrow> False\n        | Some proto \\<Rightarrow> match_proto proto pkt)", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       p1 = Proto x2 \\<Longrightarrow>\n       (pkt = x2 \\<and> match_proto p2 pkt) =\n       (case simple_proto_conjunct (Proto x2) p2 of None \\<Rightarrow> False\n        | Some proto \\<Rightarrow> match_proto proto pkt)", "apply(cases p2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x2.\n       \\<lbrakk>p1 = Proto x2; p2 = ProtoAny\\<rbrakk>\n       \\<Longrightarrow> (pkt = x2 \\<and> match_proto p2 pkt) =\n                         (case simple_proto_conjunct (Proto x2) p2 of\n                          None \\<Rightarrow> False\n                          | Some proto \\<Rightarrow> match_proto proto pkt)\n 2. \\<And>x2 x2a.\n       \\<lbrakk>p1 = Proto x2; p2 = Proto x2a\\<rbrakk>\n       \\<Longrightarrow> (pkt = x2 \\<and> match_proto p2 pkt) =\n                         (case simple_proto_conjunct (Proto x2) p2 of\n                          None \\<Rightarrow> False\n                          | Some proto \\<Rightarrow> match_proto proto pkt)", "apply(simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma simple_proto_conjunct_Some: \"simple_proto_conjunct p1 p2 = Some proto \\<Longrightarrow> \n    match_proto proto pkt \\<longleftrightarrow> match_proto p1 pkt \\<and> match_proto p2 pkt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_proto_conjunct p1 p2 = Some proto \\<Longrightarrow>\n    match_proto proto pkt = (match_proto p1 pkt \\<and> match_proto p2 pkt)", "using simple_proto_conjunct_correct"], ["proof (prove)\nusing this:\n  (match_proto ?p1.0 ?pkt \\<and> match_proto ?p2.0 ?pkt) =\n  (case simple_proto_conjunct ?p1.0 ?p2.0 of None \\<Rightarrow> False\n   | Some proto \\<Rightarrow> match_proto proto ?pkt)\n\ngoal (1 subgoal):\n 1. simple_proto_conjunct p1 p2 = Some proto \\<Longrightarrow>\n    match_proto proto pkt = (match_proto p1 pkt \\<and> match_proto p2 pkt)", "by simp"], ["", "lemma simple_proto_conjunct_None: \"simple_proto_conjunct p1 p2 = None \\<Longrightarrow> \n    \\<not> (match_proto p1 pkt \\<and> match_proto p2 pkt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_proto_conjunct p1 p2 = None \\<Longrightarrow>\n    \\<not> (match_proto p1 pkt \\<and> match_proto p2 pkt)", "using simple_proto_conjunct_correct"], ["proof (prove)\nusing this:\n  (match_proto ?p1.0 ?pkt \\<and> match_proto ?p2.0 ?pkt) =\n  (case simple_proto_conjunct ?p1.0 ?p2.0 of None \\<Rightarrow> False\n   | Some proto \\<Rightarrow> match_proto proto ?pkt)\n\ngoal (1 subgoal):\n 1. simple_proto_conjunct p1 p2 = None \\<Longrightarrow>\n    \\<not> (match_proto p1 pkt \\<and> match_proto p2 pkt)", "by simp"], ["", "lemma conjunctProtoD:\n    \"simple_proto_conjunct a (Proto b) = Some x \\<Longrightarrow> x = Proto b \\<and> (a = ProtoAny \\<or> a = Proto b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_proto_conjunct a (Proto b) = Some x \\<Longrightarrow>\n    x = Proto b \\<and> (a = ProtoAny \\<or> a = Proto b)", "by(cases a) (simp_all split: if_splits)"], ["", "lemma conjunctProtoD2:\n    \"simple_proto_conjunct (Proto b) a = Some x \\<Longrightarrow> x = Proto b \\<and> (a = ProtoAny \\<or> a = Proto b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_proto_conjunct (Proto b) a = Some x \\<Longrightarrow>\n    x = Proto b \\<and> (a = ProtoAny \\<or> a = Proto b)", "by(cases a) (simp_all split: if_splits)"], ["", "text\\<open>Originally, there was a @{typ nat} in the protocol definition, allowing infinitely many protocols \n        This was intended behavior. We want to prevent things such as @{term \"\\<not>TCP = UDP\"}.\n        So be careful with what you prove...\\<close>"], ["", "lemma primitive_protocol_Ex_neq: \"p = Proto pi \\<Longrightarrow> \\<exists>p'. p' \\<noteq> pi\" for pi"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = Proto pi \\<Longrightarrow> \\<exists>p'. p' \\<noteq> pi", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. p = Proto pi \\<Longrightarrow> ?p' \\<noteq> pi", "show \"pi + 1 \\<noteq> pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pi + 1 \\<noteq> pi", "by simp"], ["proof (state)\nthis:\n  pi + 1 \\<noteq> pi\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma protocol_Ex_neq: \"\\<exists>p'. Proto p' \\<noteq> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p'. Proto p' \\<noteq> p", "by(cases p) (simp_all add: primitive_protocol_Ex_neq)"], ["", "section\\<open>TCP flags\\<close>"], ["", "datatype tcp_flag = TCP_SYN | TCP_ACK | TCP_FIN | TCP_RST | TCP_URG | TCP_PSH"], ["", "(*| TCP_ALL | TCP_NONE*)"], ["", "lemma UNIV_tcp_flag: \"UNIV = {TCP_SYN, TCP_ACK, TCP_FIN, TCP_RST, TCP_URG, TCP_PSH}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = {TCP_SYN, TCP_ACK, TCP_FIN, TCP_RST, TCP_URG, TCP_PSH}", "using tcp_flag.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>?y = TCP_SYN \\<Longrightarrow> ?P;\n   ?y = TCP_ACK \\<Longrightarrow> ?P; ?y = TCP_FIN \\<Longrightarrow> ?P;\n   ?y = TCP_RST \\<Longrightarrow> ?P; ?y = TCP_URG \\<Longrightarrow> ?P;\n   ?y = TCP_PSH \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. UNIV = {TCP_SYN, TCP_ACK, TCP_FIN, TCP_RST, TCP_URG, TCP_PSH}", "by auto"], ["", "instance tcp_flag :: finite"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(tcp_flag, finite_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. finite UNIV", "from UNIV_tcp_flag"], ["proof (chain)\npicking this:\n  UNIV = {TCP_SYN, TCP_ACK, TCP_FIN, TCP_RST, TCP_URG, TCP_PSH}", "show \"finite (UNIV:: tcp_flag set)\""], ["proof (prove)\nusing this:\n  UNIV = {TCP_SYN, TCP_ACK, TCP_FIN, TCP_RST, TCP_URG, TCP_PSH}\n\ngoal (1 subgoal):\n 1. finite UNIV", "using finite.simps"], ["proof (prove)\nusing this:\n  UNIV = {TCP_SYN, TCP_ACK, TCP_FIN, TCP_RST, TCP_URG, TCP_PSH}\n  finite ?a =\n  (?a = {} \\<or> (\\<exists>A a. ?a = insert a A \\<and> finite A))\n\ngoal (1 subgoal):\n 1. finite UNIV", "by auto"], ["proof (state)\nthis:\n  finite UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "instantiation \"tcp_flag\" :: enum\n  begin"], ["", "definition \"enum_tcp_flag = [TCP_SYN, TCP_ACK, TCP_FIN, TCP_RST, TCP_URG, TCP_PSH]\""], ["", "definition \"enum_all_tcp_flag P \\<longleftrightarrow> P TCP_SYN \\<and> P TCP_ACK \\<and> P TCP_FIN \\<and> P TCP_RST \\<and> P TCP_URG \\<and> P TCP_PSH\""], ["", "definition \"enum_ex_tcp_flag P \\<longleftrightarrow> P TCP_SYN \\<or> P TCP_ACK \\<or> P TCP_FIN \\<or> P TCP_RST \\<or> P TCP_URG \\<or> P TCP_PSH\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(tcp_flag, enum_class)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. UNIV = set enum_class.enum\n 2. distinct enum_class.enum\n 3. \\<And>P. enum_class.enum_all P = Ball UNIV P\n 4. \\<And>P. enum_class.enum_ex P = Bex UNIV P", "show \"UNIV = set (enum_class.enum :: tcp_flag list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UNIV = set enum_class.enum", "by(simp add: UNIV_tcp_flag enum_tcp_flag_def)"], ["proof (state)\nthis:\n  UNIV = set enum_class.enum\n\ngoal (3 subgoals):\n 1. distinct enum_class.enum\n 2. \\<And>P. enum_class.enum_all P = Ball UNIV P\n 3. \\<And>P. enum_class.enum_ex P = Bex UNIV P", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. distinct enum_class.enum\n 2. \\<And>P. enum_class.enum_all P = Ball UNIV P\n 3. \\<And>P. enum_class.enum_ex P = Bex UNIV P", "show \"distinct (enum_class.enum :: tcp_flag list)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct enum_class.enum", "by(simp add: enum_tcp_flag_def)"], ["proof (state)\nthis:\n  distinct enum_class.enum\n\ngoal (2 subgoals):\n 1. \\<And>P. enum_class.enum_all P = Ball UNIV P\n 2. \\<And>P. enum_class.enum_ex P = Bex UNIV P", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P. enum_class.enum_all P = Ball UNIV P\n 2. \\<And>P. enum_class.enum_ex P = Bex UNIV P", "show \"\\<And>P. (enum_class.enum_all :: (tcp_flag \\<Rightarrow> bool) \\<Rightarrow> bool) P = Ball UNIV P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P. enum_class.enum_all P = Ball UNIV P", "by(simp add: UNIV_tcp_flag enum_all_tcp_flag_def)"], ["proof (state)\nthis:\n  enum_class.enum_all ?P = Ball UNIV ?P\n\ngoal (1 subgoal):\n 1. \\<And>P. enum_class.enum_ex P = Bex UNIV P", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P. enum_class.enum_ex P = Bex UNIV P", "show \"\\<And>P. (enum_class.enum_ex :: (tcp_flag \\<Rightarrow> bool) \\<Rightarrow> bool) P = Bex UNIV P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P. enum_class.enum_ex P = Bex UNIV P", "by(simp add: UNIV_tcp_flag enum_ex_tcp_flag_def)"], ["proof (state)\nthis:\n  enum_class.enum_ex ?P = Bex UNIV ?P\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection\\<open>TCP Flags to String\\<close>"], ["", "fun tcp_flag_toString :: \"tcp_flag \\<Rightarrow> string\" where\n    \"tcp_flag_toString TCP_SYN = ''TCP_SYN''\" |\n    \"tcp_flag_toString TCP_ACK = ''TCP_ACK''\" |\n    \"tcp_flag_toString TCP_FIN = ''TCP_FIN''\" |\n    \"tcp_flag_toString TCP_RST = ''TCP_RST''\" |\n    \"tcp_flag_toString TCP_URG = ''TCP_URG''\" |\n    \"tcp_flag_toString TCP_PSH = ''TCP_PSH''\""], ["", "definition ipt_tcp_flags_toString :: \"tcp_flag set \\<Rightarrow> char list\" where\n    \"ipt_tcp_flags_toString flags \\<equiv> list_toString tcp_flag_toString (enum_set_to_list flags)\""], ["", "lemma \"ipt_tcp_flags_toString {TCP_SYN,TCP_SYN,TCP_ACK} = ''[TCP_SYN, TCP_ACK]''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipt_tcp_flags_toString {TCP_SYN, TCP_SYN, TCP_ACK} =\n    ''[TCP_SYN, TCP_ACK]''", "by eval"], ["", "end"]]}