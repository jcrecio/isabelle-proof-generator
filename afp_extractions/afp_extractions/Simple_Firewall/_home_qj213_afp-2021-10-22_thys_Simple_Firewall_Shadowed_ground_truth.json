{"file_name": "/home/qj213/afp-2021-10-22/thys/Simple_Firewall/Shadowed.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Simple_Firewall", "problem_names": ["lemma rmshadow_sound: \n    \"p \\<in> P \\<Longrightarrow> simple_fw (rmshadow rs P) p = simple_fw rs p\"", "lemma rmshadow'_sound: \n    \"p \\<notin> P \\<Longrightarrow> simple_fw (rmshadow' rs P) p = simple_fw rs p\"", "lemma simple_packet_set_toSet_alt: \"simple_packet_set_toSet ms = (\\<Union> m \\<in> set ms. {p. simple_matches m p})\"", "lemma \"simple_packet_set_toSet (simple_packet_set_union ps m) = simple_packet_set_toSet ps \\<union> {p. simple_matches m p}\"", "lemma \"(\\<exists>m' \\<in> set ms.\n        {i. match_iface iif i} \\<subseteq> {i. match_iface (iiface m') i} \\<and>\n        {i. match_iface oif i} \\<subseteq> {i. match_iface (oiface m') i} \\<and>\n        {ip. simple_match_ip sip ip} \\<subseteq> {ip. simple_match_ip (src m') ip} \\<and>\n        {ip. simple_match_ip dip ip} \\<subseteq> {ip. simple_match_ip (dst m') ip} \\<and>\n        {p. match_proto protocol p} \\<subseteq> {p. match_proto (proto m') p} \\<and>\n        {p. simple_match_port sps p} \\<subseteq> {p. simple_match_port (sports m') p} \\<and>\n        {p. simple_match_port dps p} \\<subseteq> {p. simple_match_port (dports m') p}\n      )\n    \\<Longrightarrow> {p. simple_matches \\<lparr>iiface=iif, oiface=oif, src=sip, dst=dip, proto=protocol, sports=sps, dports=dps \\<rparr> p} \\<subseteq> (simple_packet_set_toSet ms)\"", "lemma \"{p:: 'i::len simple_packet. simple_matches m p} \\<subseteq> (simple_packet_set_toSet ms) \\<longleftrightarrow>\n      {p:: 'i::len simple_packet. simple_matches m p} \\<inter> (\\<Inter> m \\<in> set ms. {p. \\<not> simple_matches m p}) = {}\" (is \"?l \\<longleftrightarrow> ?r\")"], "translations": [["", "lemma rmshadow_sound: \n    \"p \\<in> P \\<Longrightarrow> simple_fw (rmshadow rs P) p = simple_fw rs p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> P \\<Longrightarrow> simple_fw (rmshadow rs P) p = simple_fw rs p", "proof(induction rs arbitrary: P)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P.\n       p \\<in> P \\<Longrightarrow>\n       simple_fw (rmshadow [] P) p = simple_fw [] p\n 2. \\<And>a rs P.\n       \\<lbrakk>\\<And>P.\n                   p \\<in> P \\<Longrightarrow>\n                   simple_fw (rmshadow rs P) p = simple_fw rs p;\n        p \\<in> P\\<rbrakk>\n       \\<Longrightarrow> simple_fw (rmshadow (a # rs) P) p =\n                         simple_fw (a # rs) p", "case Nil"], ["proof (state)\nthis:\n  p \\<in> P\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       p \\<in> P \\<Longrightarrow>\n       simple_fw (rmshadow [] P) p = simple_fw [] p\n 2. \\<And>a rs P.\n       \\<lbrakk>\\<And>P.\n                   p \\<in> P \\<Longrightarrow>\n                   simple_fw (rmshadow rs P) p = simple_fw rs p;\n        p \\<in> P\\<rbrakk>\n       \\<Longrightarrow> simple_fw (rmshadow (a # rs) P) p =\n                         simple_fw (a # rs) p", "thus ?case"], ["proof (prove)\nusing this:\n  p \\<in> P\n\ngoal (1 subgoal):\n 1. simple_fw (rmshadow [] P) p = simple_fw [] p", "by simp"], ["proof (state)\nthis:\n  simple_fw (rmshadow [] P) p = simple_fw [] p\n\ngoal (1 subgoal):\n 1. \\<And>a rs P.\n       \\<lbrakk>\\<And>P.\n                   p \\<in> P \\<Longrightarrow>\n                   simple_fw (rmshadow rs P) p = simple_fw rs p;\n        p \\<in> P\\<rbrakk>\n       \\<Longrightarrow> simple_fw (rmshadow (a # rs) P) p =\n                         simple_fw (a # rs) p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a rs P.\n       \\<lbrakk>\\<And>P.\n                   p \\<in> P \\<Longrightarrow>\n                   simple_fw (rmshadow rs P) p = simple_fw rs p;\n        p \\<in> P\\<rbrakk>\n       \\<Longrightarrow> simple_fw (rmshadow (a # rs) P) p =\n                         simple_fw (a # rs) p", "case (Cons r rs)"], ["proof (state)\nthis:\n  p \\<in> ?P \\<Longrightarrow> simple_fw (rmshadow rs ?P) p = simple_fw rs p\n  p \\<in> P\n\ngoal (1 subgoal):\n 1. \\<And>a rs P.\n       \\<lbrakk>\\<And>P.\n                   p \\<in> P \\<Longrightarrow>\n                   simple_fw (rmshadow rs P) p = simple_fw rs p;\n        p \\<in> P\\<rbrakk>\n       \\<Longrightarrow> simple_fw (rmshadow (a # rs) P) p =\n                         simple_fw (a # rs) p", "from Cons.IH Cons.prems"], ["proof (chain)\npicking this:\n  p \\<in> ?P \\<Longrightarrow> simple_fw (rmshadow rs ?P) p = simple_fw rs p\n  p \\<in> P", "have IH1: \"simple_fw (rmshadow rs P) p = simple_fw rs p\""], ["proof (prove)\nusing this:\n  p \\<in> ?P \\<Longrightarrow> simple_fw (rmshadow rs ?P) p = simple_fw rs p\n  p \\<in> P\n\ngoal (1 subgoal):\n 1. simple_fw (rmshadow rs P) p = simple_fw rs p", "by (simp)"], ["proof (state)\nthis:\n  simple_fw (rmshadow rs P) p = simple_fw rs p\n\ngoal (1 subgoal):\n 1. \\<And>a rs P.\n       \\<lbrakk>\\<And>P.\n                   p \\<in> P \\<Longrightarrow>\n                   simple_fw (rmshadow rs P) p = simple_fw rs p;\n        p \\<in> P\\<rbrakk>\n       \\<Longrightarrow> simple_fw (rmshadow (a # rs) P) p =\n                         simple_fw (a # rs) p", "let ?P'=\"{p \\<in> P. \\<not> simple_matches (match_sel r) p}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a rs P.\n       \\<lbrakk>\\<And>P.\n                   p \\<in> P \\<Longrightarrow>\n                   simple_fw (rmshadow rs P) p = simple_fw rs p;\n        p \\<in> P\\<rbrakk>\n       \\<Longrightarrow> simple_fw (rmshadow (a # rs) P) p =\n                         simple_fw (a # rs) p", "from Cons.IH Cons.prems"], ["proof (chain)\npicking this:\n  p \\<in> ?P \\<Longrightarrow> simple_fw (rmshadow rs ?P) p = simple_fw rs p\n  p \\<in> P", "have IH2: \"\\<And>m. p \\<in> ?P' \\<Longrightarrow> simple_fw (rmshadow rs ?P') p = simple_fw rs p\""], ["proof (prove)\nusing this:\n  p \\<in> ?P \\<Longrightarrow> simple_fw (rmshadow rs ?P) p = simple_fw rs p\n  p \\<in> P\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       p \\<in> {p \\<in> P.\n                \\<not> simple_matches (match_sel r) p} \\<Longrightarrow>\n       simple_fw\n        (rmshadow rs {p \\<in> P. \\<not> simple_matches (match_sel r) p}) p =\n       simple_fw rs p", "by simp"], ["proof (state)\nthis:\n  p \\<in> {p \\<in> P.\n           \\<not> simple_matches (match_sel r) p} \\<Longrightarrow>\n  simple_fw (rmshadow rs {p \\<in> P. \\<not> simple_matches (match_sel r) p})\n   p =\n  simple_fw rs p\n\ngoal (1 subgoal):\n 1. \\<And>a rs P.\n       \\<lbrakk>\\<And>P.\n                   p \\<in> P \\<Longrightarrow>\n                   simple_fw (rmshadow rs P) p = simple_fw rs p;\n        p \\<in> P\\<rbrakk>\n       \\<Longrightarrow> simple_fw (rmshadow (a # rs) P) p =\n                         simple_fw (a # rs) p", "from Cons.prems"], ["proof (chain)\npicking this:\n  p \\<in> P", "show ?case"], ["proof (prove)\nusing this:\n  p \\<in> P\n\ngoal (1 subgoal):\n 1. simple_fw (rmshadow (r # rs) P) p = simple_fw (r # rs) p", "apply(cases r, rename_tac m a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>p \\<in> P; r = SimpleRule m a; p \\<in> P\\<rbrakk>\n       \\<Longrightarrow> simple_fw (rmshadow (r # rs) P) p =\n                         simple_fw (r # rs) p", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; p \\<in> P\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>p\\<in>P.\n                              \\<not> simple_matches m p) \\<longrightarrow>\n                          simple_fw (rmshadow rs P) p =\n                          simple_fw (SimpleRule m a # rs) p) \\<and>\n                         ((\\<exists>p\\<in>P.\n                              simple_matches m p) \\<longrightarrow>\n                          simple_fw\n                           (SimpleRule m a #\n                            rmshadow rs\n                             {p \\<in> P. \\<not> simple_matches m p})\n                           p =\n                          simple_fw (SimpleRule m a # rs) p)", "apply(case_tac \"\\<forall>p\\<in>P. \\<not> simple_matches m p\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; p \\<in> P;\n        \\<forall>p\\<in>P. \\<not> simple_matches m p\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>p\\<in>P.\n                              \\<not> simple_matches m p) \\<longrightarrow>\n                          simple_fw (rmshadow rs P) p =\n                          simple_fw (SimpleRule m a # rs) p) \\<and>\n                         ((\\<exists>p\\<in>P.\n                              simple_matches m p) \\<longrightarrow>\n                          simple_fw\n                           (SimpleRule m a #\n                            rmshadow rs\n                             {p \\<in> P. \\<not> simple_matches m p})\n                           p =\n                          simple_fw (SimpleRule m a # rs) p)\n 2. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; p \\<in> P;\n        \\<not> (\\<forall>p\\<in>P. \\<not> simple_matches m p)\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>p\\<in>P.\n                              \\<not> simple_matches m p) \\<longrightarrow>\n                          simple_fw (rmshadow rs P) p =\n                          simple_fw (SimpleRule m a # rs) p) \\<and>\n                         ((\\<exists>p\\<in>P.\n                              simple_matches m p) \\<longrightarrow>\n                          simple_fw\n                           (SimpleRule m a #\n                            rmshadow rs\n                             {p \\<in> P. \\<not> simple_matches m p})\n                           p =\n                          simple_fw (SimpleRule m a # rs) p)", "apply(simp add: IH1 nomatch)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; p \\<in> P;\n        \\<not> (\\<forall>p\\<in>P. \\<not> simple_matches m p)\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>p\\<in>P.\n                              \\<not> simple_matches m p) \\<longrightarrow>\n                          simple_fw (rmshadow rs P) p =\n                          simple_fw (SimpleRule m a # rs) p) \\<and>\n                         ((\\<exists>p\\<in>P.\n                              simple_matches m p) \\<longrightarrow>\n                          simple_fw\n                           (SimpleRule m a #\n                            rmshadow rs\n                             {p \\<in> P. \\<not> simple_matches m p})\n                           p =\n                          simple_fw (SimpleRule m a # rs) p)", "apply(case_tac \"p \\<in> ?P'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; p \\<in> P;\n        \\<not> (\\<forall>p\\<in>P. \\<not> simple_matches m p);\n        p \\<in> {p \\<in> P. \\<not> simple_matches (match_sel r) p}\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>p\\<in>P.\n                              \\<not> simple_matches m p) \\<longrightarrow>\n                          simple_fw (rmshadow rs P) p =\n                          simple_fw (SimpleRule m a # rs) p) \\<and>\n                         ((\\<exists>p\\<in>P.\n                              simple_matches m p) \\<longrightarrow>\n                          simple_fw\n                           (SimpleRule m a #\n                            rmshadow rs\n                             {p \\<in> P. \\<not> simple_matches m p})\n                           p =\n                          simple_fw (SimpleRule m a # rs) p)\n 2. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; p \\<in> P;\n        \\<not> (\\<forall>p\\<in>P. \\<not> simple_matches m p);\n        p \\<notin> {p \\<in> P.\n                    \\<not> simple_matches (match_sel r) p}\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>p\\<in>P.\n                              \\<not> simple_matches m p) \\<longrightarrow>\n                          simple_fw (rmshadow rs P) p =\n                          simple_fw (SimpleRule m a # rs) p) \\<and>\n                         ((\\<exists>p\\<in>P.\n                              simple_matches m p) \\<longrightarrow>\n                          simple_fw\n                           (SimpleRule m a #\n                            rmshadow rs\n                             {p \\<in> P. \\<not> simple_matches m p})\n                           p =\n                          simple_fw (SimpleRule m a # rs) p)", "apply(frule IH2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; p \\<in> P;\n        \\<not> (\\<forall>p\\<in>P. \\<not> simple_matches m p);\n        p \\<in> {p \\<in> P. \\<not> simple_matches (match_sel r) p};\n        simple_fw\n         (rmshadow rs {p \\<in> P. \\<not> simple_matches (match_sel r) p})\n         p =\n        simple_fw rs p\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>p\\<in>P.\n                              \\<not> simple_matches m p) \\<longrightarrow>\n                          simple_fw (rmshadow rs P) p =\n                          simple_fw (SimpleRule m a # rs) p) \\<and>\n                         ((\\<exists>p\\<in>P.\n                              simple_matches m p) \\<longrightarrow>\n                          simple_fw\n                           (SimpleRule m a #\n                            rmshadow rs\n                             {p \\<in> P. \\<not> simple_matches m p})\n                           p =\n                          simple_fw (SimpleRule m a # rs) p)\n 2. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; p \\<in> P;\n        \\<not> (\\<forall>p\\<in>P. \\<not> simple_matches m p);\n        p \\<notin> {p \\<in> P.\n                    \\<not> simple_matches (match_sel r) p}\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>p\\<in>P.\n                              \\<not> simple_matches m p) \\<longrightarrow>\n                          simple_fw (rmshadow rs P) p =\n                          simple_fw (SimpleRule m a # rs) p) \\<and>\n                         ((\\<exists>p\\<in>P.\n                              simple_matches m p) \\<longrightarrow>\n                          simple_fw\n                           (SimpleRule m a #\n                            rmshadow rs\n                             {p \\<in> P. \\<not> simple_matches m p})\n                           p =\n                          simple_fw (SimpleRule m a # rs) p)", "apply(simp add: nomatch IH1)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; p \\<in> P;\n        \\<not> (\\<forall>p\\<in>P. \\<not> simple_matches m p);\n        p \\<notin> {p \\<in> P.\n                    \\<not> simple_matches (match_sel r) p}\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>p\\<in>P.\n                              \\<not> simple_matches m p) \\<longrightarrow>\n                          simple_fw (rmshadow rs P) p =\n                          simple_fw (SimpleRule m a # rs) p) \\<and>\n                         ((\\<exists>p\\<in>P.\n                              simple_matches m p) \\<longrightarrow>\n                          simple_fw\n                           (SimpleRule m a #\n                            rmshadow rs\n                             {p \\<in> P. \\<not> simple_matches m p})\n                           p =\n                          simple_fw (SimpleRule m a # rs) p)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; p \\<in> P;\n        \\<exists>p\\<in>P. simple_matches m p; simple_matches m p\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>p\\<in>P.\n                              \\<not> simple_matches m p) \\<longrightarrow>\n                          simple_fw (rmshadow rs P) p =\n                          simple_fw (SimpleRule m a # rs) p) \\<and>\n                         simple_fw\n                          (SimpleRule m a #\n                           rmshadow rs\n                            {p \\<in> P. \\<not> simple_matches m p})\n                          p =\n                         simple_fw (SimpleRule m a # rs) p", "apply(case_tac a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; p \\<in> P;\n        \\<exists>p\\<in>P. simple_matches m p; simple_matches m p;\n        a = Accept\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>p\\<in>P.\n                              \\<not> simple_matches m p) \\<longrightarrow>\n                          simple_fw (rmshadow rs P) p =\n                          simple_fw (SimpleRule m a # rs) p) \\<and>\n                         simple_fw\n                          (SimpleRule m a #\n                           rmshadow rs\n                            {p \\<in> P. \\<not> simple_matches m p})\n                          p =\n                         simple_fw (SimpleRule m a # rs) p\n 2. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; p \\<in> P;\n        \\<exists>p\\<in>P. simple_matches m p; simple_matches m p;\n        a = Drop\\<rbrakk>\n       \\<Longrightarrow> ((\\<forall>p\\<in>P.\n                              \\<not> simple_matches m p) \\<longrightarrow>\n                          simple_fw (rmshadow rs P) p =\n                          simple_fw (SimpleRule m a # rs) p) \\<and>\n                         simple_fw\n                          (SimpleRule m a #\n                           rmshadow rs\n                            {p \\<in> P. \\<not> simple_matches m p})\n                          p =\n                         simple_fw (SimpleRule m a # rs) p", "apply(simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m Accept; p \\<in> P;\n        \\<exists>p\\<in>P. simple_matches m p; simple_matches m p;\n        a = Accept\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>p\\<in>P.\n                             \\<not> simple_matches m p) \\<longrightarrow>\n                         simple_fw (rmshadow rs P) p = Decision FinalAllow\n 2. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m Drop; p \\<in> P;\n        \\<exists>p\\<in>P. simple_matches m p; simple_matches m p;\n        a = Drop\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>p\\<in>P.\n                             \\<not> simple_matches m p) \\<longrightarrow>\n                         simple_fw (rmshadow rs P) p = Decision FinalDeny", "by fast+"], ["proof (state)\nthis:\n  simple_fw (rmshadow (r # rs) P) p = simple_fw (r # rs) p\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary rmshadow:\n    fixes p :: \"'i::len simple_packet\"\n    shows \"simple_fw (rmshadow rs UNIV) p = simple_fw rs p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_fw (rmshadow rs UNIV) p = simple_fw rs p", "using rmshadow_sound[of p]"], ["proof (prove)\nusing this:\n  p \\<in> ?P \\<Longrightarrow>\n  simple_fw (rmshadow ?rs ?P) p = simple_fw ?rs p\n\ngoal (1 subgoal):\n 1. simple_fw (rmshadow rs UNIV) p = simple_fw rs p", "by simp"], ["", "text\\<open>A different approach where we start with the empty set of packets and collect packets which are already ``matched-away''.\\<close>"], ["", "fun rmshadow' :: \"'i::len simple_rule list \\<Rightarrow> 'i simple_packet set \\<Rightarrow> 'i simple_rule list\" where\n  \"rmshadow' [] _ = []\" |\n  \"rmshadow' ((SimpleRule m a)#rs) P = (if {p. simple_matches m p} \\<subseteq> P\n    then \n      rmshadow' rs P\n    else\n      (SimpleRule m a) # (rmshadow' rs (P \\<union> {p. simple_matches m p})))\""], ["", "lemma rmshadow'_sound: \n    \"p \\<notin> P \\<Longrightarrow> simple_fw (rmshadow' rs P) p = simple_fw rs p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<notin> P \\<Longrightarrow>\n    simple_fw (rmshadow' rs P) p = simple_fw rs p", "proof(induction rs arbitrary: P)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>P.\n       p \\<notin> P \\<Longrightarrow>\n       simple_fw (rmshadow' [] P) p = simple_fw [] p\n 2. \\<And>a rs P.\n       \\<lbrakk>\\<And>P.\n                   p \\<notin> P \\<Longrightarrow>\n                   simple_fw (rmshadow' rs P) p = simple_fw rs p;\n        p \\<notin> P\\<rbrakk>\n       \\<Longrightarrow> simple_fw (rmshadow' (a # rs) P) p =\n                         simple_fw (a # rs) p", "case Nil"], ["proof (state)\nthis:\n  p \\<notin> P\n\ngoal (2 subgoals):\n 1. \\<And>P.\n       p \\<notin> P \\<Longrightarrow>\n       simple_fw (rmshadow' [] P) p = simple_fw [] p\n 2. \\<And>a rs P.\n       \\<lbrakk>\\<And>P.\n                   p \\<notin> P \\<Longrightarrow>\n                   simple_fw (rmshadow' rs P) p = simple_fw rs p;\n        p \\<notin> P\\<rbrakk>\n       \\<Longrightarrow> simple_fw (rmshadow' (a # rs) P) p =\n                         simple_fw (a # rs) p", "thus ?case"], ["proof (prove)\nusing this:\n  p \\<notin> P\n\ngoal (1 subgoal):\n 1. simple_fw (rmshadow' [] P) p = simple_fw [] p", "by simp"], ["proof (state)\nthis:\n  simple_fw (rmshadow' [] P) p = simple_fw [] p\n\ngoal (1 subgoal):\n 1. \\<And>a rs P.\n       \\<lbrakk>\\<And>P.\n                   p \\<notin> P \\<Longrightarrow>\n                   simple_fw (rmshadow' rs P) p = simple_fw rs p;\n        p \\<notin> P\\<rbrakk>\n       \\<Longrightarrow> simple_fw (rmshadow' (a # rs) P) p =\n                         simple_fw (a # rs) p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a rs P.\n       \\<lbrakk>\\<And>P.\n                   p \\<notin> P \\<Longrightarrow>\n                   simple_fw (rmshadow' rs P) p = simple_fw rs p;\n        p \\<notin> P\\<rbrakk>\n       \\<Longrightarrow> simple_fw (rmshadow' (a # rs) P) p =\n                         simple_fw (a # rs) p", "case (Cons r rs)"], ["proof (state)\nthis:\n  p \\<notin> ?P \\<Longrightarrow>\n  simple_fw (rmshadow' rs ?P) p = simple_fw rs p\n  p \\<notin> P\n\ngoal (1 subgoal):\n 1. \\<And>a rs P.\n       \\<lbrakk>\\<And>P.\n                   p \\<notin> P \\<Longrightarrow>\n                   simple_fw (rmshadow' rs P) p = simple_fw rs p;\n        p \\<notin> P\\<rbrakk>\n       \\<Longrightarrow> simple_fw (rmshadow' (a # rs) P) p =\n                         simple_fw (a # rs) p", "from Cons.IH Cons.prems"], ["proof (chain)\npicking this:\n  p \\<notin> ?P \\<Longrightarrow>\n  simple_fw (rmshadow' rs ?P) p = simple_fw rs p\n  p \\<notin> P", "have IH1: \"simple_fw (rmshadow' rs P) p = simple_fw rs p\""], ["proof (prove)\nusing this:\n  p \\<notin> ?P \\<Longrightarrow>\n  simple_fw (rmshadow' rs ?P) p = simple_fw rs p\n  p \\<notin> P\n\ngoal (1 subgoal):\n 1. simple_fw (rmshadow' rs P) p = simple_fw rs p", "by (simp)"], ["proof (state)\nthis:\n  simple_fw (rmshadow' rs P) p = simple_fw rs p\n\ngoal (1 subgoal):\n 1. \\<And>a rs P.\n       \\<lbrakk>\\<And>P.\n                   p \\<notin> P \\<Longrightarrow>\n                   simple_fw (rmshadow' rs P) p = simple_fw rs p;\n        p \\<notin> P\\<rbrakk>\n       \\<Longrightarrow> simple_fw (rmshadow' (a # rs) P) p =\n                         simple_fw (a # rs) p", "let ?P'=\"{p. simple_matches (match_sel r) p}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a rs P.\n       \\<lbrakk>\\<And>P.\n                   p \\<notin> P \\<Longrightarrow>\n                   simple_fw (rmshadow' rs P) p = simple_fw rs p;\n        p \\<notin> P\\<rbrakk>\n       \\<Longrightarrow> simple_fw (rmshadow' (a # rs) P) p =\n                         simple_fw (a # rs) p", "from Cons.IH Cons.prems"], ["proof (chain)\npicking this:\n  p \\<notin> ?P \\<Longrightarrow>\n  simple_fw (rmshadow' rs ?P) p = simple_fw rs p\n  p \\<notin> P", "have IH2: \"\\<And>m. p \\<notin> (Collect (simple_matches m)) \\<Longrightarrow> simple_fw (rmshadow' rs (P \\<union> Collect (simple_matches m))) p = simple_fw rs p\""], ["proof (prove)\nusing this:\n  p \\<notin> ?P \\<Longrightarrow>\n  simple_fw (rmshadow' rs ?P) p = simple_fw rs p\n  p \\<notin> P\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       p \\<notin> Collect (simple_matches m) \\<Longrightarrow>\n       simple_fw (rmshadow' rs (P \\<union> Collect (simple_matches m))) p =\n       simple_fw rs p", "by simp"], ["proof (state)\nthis:\n  p \\<notin> Collect (simple_matches ?m1) \\<Longrightarrow>\n  simple_fw (rmshadow' rs (P \\<union> Collect (simple_matches ?m1))) p =\n  simple_fw rs p\n\ngoal (1 subgoal):\n 1. \\<And>a rs P.\n       \\<lbrakk>\\<And>P.\n                   p \\<notin> P \\<Longrightarrow>\n                   simple_fw (rmshadow' rs P) p = simple_fw rs p;\n        p \\<notin> P\\<rbrakk>\n       \\<Longrightarrow> simple_fw (rmshadow' (a # rs) P) p =\n                         simple_fw (a # rs) p", "have nomatch_m: \"\\<And>m. p \\<notin> P \\<Longrightarrow> {p. simple_matches m p} \\<subseteq> P \\<Longrightarrow> \\<not> simple_matches m p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>p \\<notin> P; {p. simple_matches m p} \\<subseteq> P\\<rbrakk>\n       \\<Longrightarrow> \\<not> simple_matches m p", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>p \\<notin> P; {p. simple_matches ?m1 p} \\<subseteq> P\\<rbrakk>\n  \\<Longrightarrow> \\<not> simple_matches ?m1 p\n\ngoal (1 subgoal):\n 1. \\<And>a rs P.\n       \\<lbrakk>\\<And>P.\n                   p \\<notin> P \\<Longrightarrow>\n                   simple_fw (rmshadow' rs P) p = simple_fw rs p;\n        p \\<notin> P\\<rbrakk>\n       \\<Longrightarrow> simple_fw (rmshadow' (a # rs) P) p =\n                         simple_fw (a # rs) p", "from Cons.prems"], ["proof (chain)\npicking this:\n  p \\<notin> P", "show ?case"], ["proof (prove)\nusing this:\n  p \\<notin> P\n\ngoal (1 subgoal):\n 1. simple_fw (rmshadow' (r # rs) P) p = simple_fw (r # rs) p", "apply(cases r, rename_tac m a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>p \\<notin> P; r = SimpleRule m a; p \\<notin> P\\<rbrakk>\n       \\<Longrightarrow> simple_fw (rmshadow' (r # rs) P) p =\n                         simple_fw (r # rs) p", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; p \\<notin> P\\<rbrakk>\n       \\<Longrightarrow> (Collect (simple_matches m)\n                          \\<subseteq> P \\<longrightarrow>\n                          simple_fw (rmshadow' rs P) p =\n                          simple_fw (SimpleRule m a # rs) p) \\<and>\n                         (\\<not> Collect (simple_matches m)\n                                 \\<subseteq> P \\<longrightarrow>\n                          simple_fw\n                           (SimpleRule m a #\n                            rmshadow' rs\n                             (P \\<union> Collect (simple_matches m)))\n                           p =\n                          simple_fw (SimpleRule m a # rs) p)", "apply(case_tac \"{p. simple_matches m p} \\<subseteq> P\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; p \\<notin> P;\n        {p. simple_matches m p} \\<subseteq> P\\<rbrakk>\n       \\<Longrightarrow> (Collect (simple_matches m)\n                          \\<subseteq> P \\<longrightarrow>\n                          simple_fw (rmshadow' rs P) p =\n                          simple_fw (SimpleRule m a # rs) p) \\<and>\n                         (\\<not> Collect (simple_matches m)\n                                 \\<subseteq> P \\<longrightarrow>\n                          simple_fw\n                           (SimpleRule m a #\n                            rmshadow' rs\n                             (P \\<union> Collect (simple_matches m)))\n                           p =\n                          simple_fw (SimpleRule m a # rs) p)\n 2. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; p \\<notin> P;\n        \\<not> {p. simple_matches m p} \\<subseteq> P\\<rbrakk>\n       \\<Longrightarrow> (Collect (simple_matches m)\n                          \\<subseteq> P \\<longrightarrow>\n                          simple_fw (rmshadow' rs P) p =\n                          simple_fw (SimpleRule m a # rs) p) \\<and>\n                         (\\<not> Collect (simple_matches m)\n                                 \\<subseteq> P \\<longrightarrow>\n                          simple_fw\n                           (SimpleRule m a #\n                            rmshadow' rs\n                             (P \\<union> Collect (simple_matches m)))\n                           p =\n                          simple_fw (SimpleRule m a # rs) p)", "apply(simp add: IH1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; p \\<notin> P;\n        {p. simple_matches m p} \\<subseteq> P\\<rbrakk>\n       \\<Longrightarrow> simple_fw rs p = simple_fw (SimpleRule m a # rs) p\n 2. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; p \\<notin> P;\n        \\<not> {p. simple_matches m p} \\<subseteq> P\\<rbrakk>\n       \\<Longrightarrow> (Collect (simple_matches m)\n                          \\<subseteq> P \\<longrightarrow>\n                          simple_fw (rmshadow' rs P) p =\n                          simple_fw (SimpleRule m a # rs) p) \\<and>\n                         (\\<not> Collect (simple_matches m)\n                                 \\<subseteq> P \\<longrightarrow>\n                          simple_fw\n                           (SimpleRule m a #\n                            rmshadow' rs\n                             (P \\<union> Collect (simple_matches m)))\n                           p =\n                          simple_fw (SimpleRule m a # rs) p)", "apply(drule nomatch_m)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a;\n        {p. simple_matches m p} \\<subseteq> P\\<rbrakk>\n       \\<Longrightarrow> {p. simple_matches (?m8 m a) p} \\<subseteq> P\n 2. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; {p. simple_matches m p} \\<subseteq> P;\n        \\<not> simple_matches (?m8 m a) p\\<rbrakk>\n       \\<Longrightarrow> simple_fw rs p = simple_fw (SimpleRule m a # rs) p\n 3. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; p \\<notin> P;\n        \\<not> {p. simple_matches m p} \\<subseteq> P\\<rbrakk>\n       \\<Longrightarrow> (Collect (simple_matches m)\n                          \\<subseteq> P \\<longrightarrow>\n                          simple_fw (rmshadow' rs P) p =\n                          simple_fw (SimpleRule m a # rs) p) \\<and>\n                         (\\<not> Collect (simple_matches m)\n                                 \\<subseteq> P \\<longrightarrow>\n                          simple_fw\n                           (SimpleRule m a #\n                            rmshadow' rs\n                             (P \\<union> Collect (simple_matches m)))\n                           p =\n                          simple_fw (SimpleRule m a # rs) p)", "apply(assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; {p. simple_matches m p} \\<subseteq> P;\n        \\<not> simple_matches m p\\<rbrakk>\n       \\<Longrightarrow> simple_fw rs p = simple_fw (SimpleRule m a # rs) p\n 2. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; p \\<notin> P;\n        \\<not> {p. simple_matches m p} \\<subseteq> P\\<rbrakk>\n       \\<Longrightarrow> (Collect (simple_matches m)\n                          \\<subseteq> P \\<longrightarrow>\n                          simple_fw (rmshadow' rs P) p =\n                          simple_fw (SimpleRule m a # rs) p) \\<and>\n                         (\\<not> Collect (simple_matches m)\n                                 \\<subseteq> P \\<longrightarrow>\n                          simple_fw\n                           (SimpleRule m a #\n                            rmshadow' rs\n                             (P \\<union> Collect (simple_matches m)))\n                           p =\n                          simple_fw (SimpleRule m a # rs) p)", "apply(simp add: nomatch)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; p \\<notin> P;\n        \\<not> {p. simple_matches m p} \\<subseteq> P\\<rbrakk>\n       \\<Longrightarrow> (Collect (simple_matches m)\n                          \\<subseteq> P \\<longrightarrow>\n                          simple_fw (rmshadow' rs P) p =\n                          simple_fw (SimpleRule m a # rs) p) \\<and>\n                         (\\<not> Collect (simple_matches m)\n                                 \\<subseteq> P \\<longrightarrow>\n                          simple_fw\n                           (SimpleRule m a #\n                            rmshadow' rs\n                             (P \\<union> Collect (simple_matches m)))\n                           p =\n                          simple_fw (SimpleRule m a # rs) p)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; p \\<notin> P;\n        \\<not> {p. simple_matches m p} \\<subseteq> P\\<rbrakk>\n       \\<Longrightarrow> simple_fw\n                          (SimpleRule m a #\n                           rmshadow' rs\n                            (P \\<union> Collect (simple_matches m)))\n                          p =\n                         simple_fw (SimpleRule m a # rs) p", "apply(case_tac a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; p \\<notin> P;\n        \\<not> {p. simple_matches m p} \\<subseteq> P; a = Accept\\<rbrakk>\n       \\<Longrightarrow> simple_fw\n                          (SimpleRule m a #\n                           rmshadow' rs\n                            (P \\<union> Collect (simple_matches m)))\n                          p =\n                         simple_fw (SimpleRule m a # rs) p\n 2. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m a; p \\<notin> P;\n        \\<not> {p. simple_matches m p} \\<subseteq> P; a = Drop\\<rbrakk>\n       \\<Longrightarrow> simple_fw\n                          (SimpleRule m a #\n                           rmshadow' rs\n                            (P \\<union> Collect (simple_matches m)))\n                          p =\n                         simple_fw (SimpleRule m a # rs) p", "apply(simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m Accept; p \\<notin> P;\n        \\<not> {p. simple_matches m p} \\<subseteq> P; a = Accept\\<rbrakk>\n       \\<Longrightarrow> \\<not> simple_matches m p \\<longrightarrow>\n                         simple_fw\n                          (rmshadow' rs\n                            (P \\<union> Collect (simple_matches m)))\n                          p =\n                         simple_fw rs p\n 2. \\<And>m a.\n       \\<lbrakk>r = SimpleRule m Drop; p \\<notin> P;\n        \\<not> {p. simple_matches m p} \\<subseteq> P; a = Drop\\<rbrakk>\n       \\<Longrightarrow> \\<not> simple_matches m p \\<longrightarrow>\n                         simple_fw\n                          (rmshadow' rs\n                            (P \\<union> Collect (simple_matches m)))\n                          p =\n                         simple_fw rs p", "apply(simp_all add: IH2)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  simple_fw (rmshadow' (r # rs) P) p = simple_fw (r # rs) p\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary \n  fixes p :: \"'i::len simple_packet\"\n  shows \"simple_fw (rmshadow rs UNIV) p = simple_fw (rmshadow' rs {}) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_fw (rmshadow rs UNIV) p = simple_fw (rmshadow' rs {}) p", "using rmshadow'_sound[of p] rmshadow_sound[of p]"], ["proof (prove)\nusing this:\n  p \\<notin> ?P \\<Longrightarrow>\n  simple_fw (rmshadow' ?rs ?P) p = simple_fw ?rs p\n  p \\<in> ?P \\<Longrightarrow>\n  simple_fw (rmshadow ?rs ?P) p = simple_fw ?rs p\n\ngoal (1 subgoal):\n 1. simple_fw (rmshadow rs UNIV) p = simple_fw (rmshadow' rs {}) p", "by simp"], ["", "text\\<open>Previous algorithm is not executable because we have no code for @{typ \"'i::len simple_packet set\"}.\n      To get some code, some efficient set operations would be necessary.\n        We either need union and subset or intersection and negation.\n        Both subset and negation are complicated.\n      Probably the BDDs which related work uses is really necessary.\n\\<close>"], ["", "(*Drafting set operations which might be necessary for an executable implementation. But BDDs might just be the thing here.*)"], ["", "context\nbegin"], ["", "private"], ["", "type_synonym 'i simple_packet_set = \"'i simple_match list\""], ["", "private"], ["", "definition simple_packet_set_toSet :: \"'i::len simple_packet_set \\<Rightarrow> 'i simple_packet set\" where\n    \"simple_packet_set_toSet ms = {p. \\<exists>m \\<in> set ms. simple_matches m p}\""], ["", "private"], ["", "lemma simple_packet_set_toSet_alt: \"simple_packet_set_toSet ms = (\\<Union> m \\<in> set ms. {p. simple_matches m p})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_packet_set_toSet ms =\n    (\\<Union>m\\<in>set ms. {p. simple_matches m p})", "unfolding simple_packet_set_toSet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. \\<exists>m\\<in>set ms. simple_matches m p} =\n    (\\<Union>m\\<in>set ms. {p. simple_matches m p})", "by blast"], ["", "private"], ["", "definition simple_packet_set_union :: \"'i::len simple_packet_set \\<Rightarrow>'i  simple_match \\<Rightarrow> 'i simple_packet_set\" where\n    \"simple_packet_set_union ps m = m # ps\""], ["", "private"], ["", "lemma \"simple_packet_set_toSet (simple_packet_set_union ps m) = simple_packet_set_toSet ps \\<union> {p. simple_matches m p}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_packet_set_toSet (simple_packet_set_union ps m) =\n    simple_packet_set_toSet ps \\<union> {p. simple_matches m p}", "unfolding simple_packet_set_toSet_def simple_packet_set_union_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. \\<exists>m\\<in>set (m # ps). simple_matches m p} =\n    {p. \\<exists>m\\<in>set ps. simple_matches m p} \\<union>\n    {p. simple_matches m p}", "by simp blast"], ["", "(*either a sound but not complete executable implementation or a better idea to implement subset*)\n   private"], ["", "lemma \"(\\<exists>m' \\<in> set ms.\n        {i. match_iface iif i} \\<subseteq> {i. match_iface (iiface m') i} \\<and>\n        {i. match_iface oif i} \\<subseteq> {i. match_iface (oiface m') i} \\<and>\n        {ip. simple_match_ip sip ip} \\<subseteq> {ip. simple_match_ip (src m') ip} \\<and>\n        {ip. simple_match_ip dip ip} \\<subseteq> {ip. simple_match_ip (dst m') ip} \\<and>\n        {p. match_proto protocol p} \\<subseteq> {p. match_proto (proto m') p} \\<and>\n        {p. simple_match_port sps p} \\<subseteq> {p. simple_match_port (sports m') p} \\<and>\n        {p. simple_match_port dps p} \\<subseteq> {p. simple_match_port (dports m') p}\n      )\n    \\<Longrightarrow> {p. simple_matches \\<lparr>iiface=iif, oiface=oif, src=sip, dst=dip, proto=protocol, sports=sps, dports=dps \\<rparr> p} \\<subseteq> (simple_packet_set_toSet ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m'\\<in>set ms.\n       {i. match_iface iif i}\n       \\<subseteq> {i. match_iface (iiface m') i} \\<and>\n       {i. match_iface oif i}\n       \\<subseteq> {i. match_iface (oiface m') i} \\<and>\n       {ip. simple_match_ip sip ip}\n       \\<subseteq> {ip. simple_match_ip (src m') ip} \\<and>\n       {ip. simple_match_ip dip ip}\n       \\<subseteq> {ip. simple_match_ip (dst m') ip} \\<and>\n       {p. match_proto protocol p}\n       \\<subseteq> {p. match_proto (proto m') p} \\<and>\n       {p. simple_match_port sps p}\n       \\<subseteq> {p. simple_match_port (sports m') p} \\<and>\n       {p. simple_match_port dps p}\n       \\<subseteq> {p. simple_match_port (dports m') p} \\<Longrightarrow>\n    {p. simple_matches\n         \\<lparr>iiface = iif, oiface = oif, src = sip, dst = dip,\n            proto = protocol, sports = sps, dports = dps\\<rparr>\n         p}\n    \\<subseteq> simple_packet_set_toSet ms", "unfolding simple_packet_set_toSet_def simple_packet_set_union_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m'\\<in>set ms.\n       {i. match_iface iif i}\n       \\<subseteq> {i. match_iface (iiface m') i} \\<and>\n       {i. match_iface oif i}\n       \\<subseteq> {i. match_iface (oiface m') i} \\<and>\n       {ip. simple_match_ip sip ip}\n       \\<subseteq> {ip. simple_match_ip (src m') ip} \\<and>\n       {ip. simple_match_ip dip ip}\n       \\<subseteq> {ip. simple_match_ip (dst m') ip} \\<and>\n       {p. match_proto protocol p}\n       \\<subseteq> {p. match_proto (proto m') p} \\<and>\n       {p. simple_match_port sps p}\n       \\<subseteq> {p. simple_match_port (sports m') p} \\<and>\n       {p. simple_match_port dps p}\n       \\<subseteq> {p. simple_match_port (dports m') p} \\<Longrightarrow>\n    {p. simple_matches\n         \\<lparr>iiface = iif, oiface = oif, src = sip, dst = dip,\n            proto = protocol, sports = sps, dports = dps\\<rparr>\n         p}\n    \\<subseteq> {p. \\<exists>m\\<in>set ms. simple_matches m p}", "apply(simp add: simple_matches.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m'\\<in>set ms.\n       {i. match_iface iif i}\n       \\<subseteq> {i. match_iface (iiface m') i} \\<and>\n       {i. match_iface oif i}\n       \\<subseteq> {i. match_iface (oiface m') i} \\<and>\n       {ip. simple_match_ip sip ip}\n       \\<subseteq> {ip. simple_match_ip (src m') ip} \\<and>\n       {ip. simple_match_ip dip ip}\n       \\<subseteq> {ip. simple_match_ip (dst m') ip} \\<and>\n       {p. match_proto protocol p}\n       \\<subseteq> {p. match_proto (proto m') p} \\<and>\n       {p. simple_match_port sps p}\n       \\<subseteq> {p. simple_match_port (sports m') p} \\<and>\n       {p. simple_match_port dps p}\n       \\<subseteq> {p. simple_match_port (dports m') p} \\<Longrightarrow>\n    {p. match_iface iif (p_iiface p) \\<and>\n        match_iface oif (p_oiface p) \\<and>\n        simple_match_ip sip (p_src p) \\<and>\n        simple_match_ip dip (p_dst p) \\<and>\n        match_proto protocol (p_proto p) \\<and>\n        simple_match_port sps (p_sport p) \\<and>\n        simple_match_port dps (p_dport p)}\n    \\<subseteq> {p. \\<exists>m\\<in>set ms.\n                       match_iface (iiface m) (p_iiface p) \\<and>\n                       match_iface (oiface m) (p_oiface p) \\<and>\n                       simple_match_ip (src m) (p_src p) \\<and>\n                       simple_match_ip (dst m) (p_dst p) \\<and>\n                       match_proto (proto m) (p_proto p) \\<and>\n                       simple_match_port (sports m) (p_sport p) \\<and>\n                       simple_match_port (dports m) (p_dport p)}", "apply(simp add: Set.Collect_mono_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m'\\<in>set ms.\n       (\\<forall>x.\n           match_iface iif x \\<longrightarrow>\n           match_iface (iiface m') x) \\<and>\n       (\\<forall>x.\n           match_iface oif x \\<longrightarrow>\n           match_iface (oiface m') x) \\<and>\n       (\\<forall>x.\n           simple_match_ip sip x \\<longrightarrow>\n           simple_match_ip (src m') x) \\<and>\n       (\\<forall>x.\n           simple_match_ip dip x \\<longrightarrow>\n           simple_match_ip (dst m') x) \\<and>\n       (\\<forall>x.\n           match_proto protocol x \\<longrightarrow>\n           match_proto (proto m') x) \\<and>\n       (\\<forall>x.\n           simple_match_port sps x \\<longrightarrow>\n           simple_match_port (sports m') x) \\<and>\n       (\\<forall>x.\n           simple_match_port dps x \\<longrightarrow>\n           simple_match_port (dports m') x) \\<Longrightarrow>\n    \\<forall>x.\n       match_iface iif (p_iiface x) \\<and>\n       match_iface oif (p_oiface x) \\<and>\n       simple_match_ip sip (p_src x) \\<and>\n       simple_match_ip dip (p_dst x) \\<and>\n       match_proto protocol (p_proto x) \\<and>\n       simple_match_port sps (p_sport x) \\<and>\n       simple_match_port dps (p_dport x) \\<longrightarrow>\n       (\\<exists>m\\<in>set ms.\n           match_iface (iiface m) (p_iiface x) \\<and>\n           match_iface (oiface m) (p_oiface x) \\<and>\n           simple_match_ip (src m) (p_src x) \\<and>\n           simple_match_ip (dst m) (p_dst x) \\<and>\n           match_proto (proto m) (p_proto x) \\<and>\n           simple_match_port (sports m) (p_sport x) \\<and>\n           simple_match_port (dports m) (p_dport x))", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m' x.\n       \\<lbrakk>m' \\<in> set ms;\n        \\<forall>x.\n           match_iface iif x \\<longrightarrow> match_iface (iiface m') x;\n        \\<forall>x.\n           match_iface oif x \\<longrightarrow> match_iface (oiface m') x;\n        \\<forall>x.\n           simple_match_ip sip x \\<longrightarrow>\n           simple_match_ip (src m') x;\n        \\<forall>x.\n           simple_match_ip dip x \\<longrightarrow>\n           simple_match_ip (dst m') x;\n        \\<forall>x.\n           match_proto protocol x \\<longrightarrow>\n           match_proto (proto m') x;\n        \\<forall>x.\n           simple_match_port sps x \\<longrightarrow>\n           simple_match_port (sports m') x;\n        \\<forall>x.\n           simple_match_port dps x \\<longrightarrow>\n           simple_match_port (dports m') x;\n        match_iface iif (p_iiface x); match_iface oif (p_oiface x);\n        simple_match_ip sip (p_src x); simple_match_ip dip (p_dst x);\n        match_proto protocol (p_proto x); simple_match_port sps (p_sport x);\n        simple_match_port dps (p_dport x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>m\\<in>set ms.\n                            match_iface (iiface m) (p_iiface x) \\<and>\n                            match_iface (oiface m) (p_oiface x) \\<and>\n                            simple_match_ip (src m) (p_src x) \\<and>\n                            simple_match_ip (dst m) (p_dst x) \\<and>\n                            match_proto (proto m) (p_proto x) \\<and>\n                            simple_match_port (sports m) (p_sport x) \\<and>\n                            simple_match_port (dports m) (p_dport x)", "apply meson"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>subset or negation ... One efficient implementation would suffice.\\<close>"], ["", "private"], ["", "lemma \"{p:: 'i::len simple_packet. simple_matches m p} \\<subseteq> (simple_packet_set_toSet ms) \\<longleftrightarrow>\n      {p:: 'i::len simple_packet. simple_matches m p} \\<inter> (\\<Inter> m \\<in> set ms. {p. \\<not> simple_matches m p}) = {}\" (is \"?l \\<longleftrightarrow> ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ({p. simple_matches m p} \\<subseteq> simple_packet_set_toSet ms) =\n    ({p. simple_matches m p} \\<inter>\n     (\\<Inter>m\\<in>set ms. {p. \\<not> simple_matches m p}) =\n     {})", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ({p. simple_matches m p} \\<subseteq> simple_packet_set_toSet ms) =\n    ({p. simple_matches m p} \\<inter>\n     (\\<Inter>m\\<in>set ms. {p. \\<not> simple_matches m p}) =\n     {})", "have \"?l \\<longleftrightarrow> {p. simple_matches m p} - (simple_packet_set_toSet ms) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({p. simple_matches m p} \\<subseteq> simple_packet_set_toSet ms) =\n    ({p. simple_matches m p} - simple_packet_set_toSet ms = {})", "by blast"], ["proof (state)\nthis:\n  ({p. simple_matches m p} \\<subseteq> simple_packet_set_toSet ms) =\n  ({p. simple_matches m p} - simple_packet_set_toSet ms = {})\n\ngoal (1 subgoal):\n 1. ({p. simple_matches m p} \\<subseteq> simple_packet_set_toSet ms) =\n    ({p. simple_matches m p} \\<inter>\n     (\\<Inter>m\\<in>set ms. {p. \\<not> simple_matches m p}) =\n     {})", "also"], ["proof (state)\nthis:\n  ({p. simple_matches m p} \\<subseteq> simple_packet_set_toSet ms) =\n  ({p. simple_matches m p} - simple_packet_set_toSet ms = {})\n\ngoal (1 subgoal):\n 1. ({p. simple_matches m p} \\<subseteq> simple_packet_set_toSet ms) =\n    ({p. simple_matches m p} \\<inter>\n     (\\<Inter>m\\<in>set ms. {p. \\<not> simple_matches m p}) =\n     {})", "have \"\\<dots> \\<longleftrightarrow> {p. simple_matches m p} - (\\<Union> m \\<in> set ms. {p:: 'i::len simple_packet. simple_matches m p}) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({p. simple_matches m p} - simple_packet_set_toSet ms = {}) =\n    ({p. simple_matches m p} -\n     (\\<Union>m\\<in>set ms. {p. simple_matches m p}) =\n     {})", "using simple_packet_set_toSet_alt"], ["proof (prove)\nusing this:\n  simple_packet_set_toSet ?ms =\n  (\\<Union>m\\<in>set ?ms. {p. simple_matches m p})\n\ngoal (1 subgoal):\n 1. ({p. simple_matches m p} - simple_packet_set_toSet ms = {}) =\n    ({p. simple_matches m p} -\n     (\\<Union>m\\<in>set ms. {p. simple_matches m p}) =\n     {})", "by blast"], ["proof (state)\nthis:\n  ({p. simple_matches m p} - simple_packet_set_toSet ms = {}) =\n  ({p. simple_matches m p} -\n   (\\<Union>m\\<in>set ms. {p. simple_matches m p}) =\n   {})\n\ngoal (1 subgoal):\n 1. ({p. simple_matches m p} \\<subseteq> simple_packet_set_toSet ms) =\n    ({p. simple_matches m p} \\<inter>\n     (\\<Inter>m\\<in>set ms. {p. \\<not> simple_matches m p}) =\n     {})", "also"], ["proof (state)\nthis:\n  ({p. simple_matches m p} - simple_packet_set_toSet ms = {}) =\n  ({p. simple_matches m p} -\n   (\\<Union>m\\<in>set ms. {p. simple_matches m p}) =\n   {})\n\ngoal (1 subgoal):\n 1. ({p. simple_matches m p} \\<subseteq> simple_packet_set_toSet ms) =\n    ({p. simple_matches m p} \\<inter>\n     (\\<Inter>m\\<in>set ms. {p. \\<not> simple_matches m p}) =\n     {})", "have \"\\<dots> \\<longleftrightarrow> ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ({p. simple_matches m p} -\n     (\\<Union>m\\<in>set ms. {p. simple_matches m p}) =\n     {}) =\n    ({p. simple_matches m p} \\<inter>\n     (\\<Inter>m\\<in>set ms. {p. \\<not> simple_matches m p}) =\n     {})", "by blast"], ["proof (state)\nthis:\n  ({p. simple_matches m p} -\n   (\\<Union>m\\<in>set ms. {p. simple_matches m p}) =\n   {}) =\n  ({p. simple_matches m p} \\<inter>\n   (\\<Inter>m\\<in>set ms. {p. \\<not> simple_matches m p}) =\n   {})\n\ngoal (1 subgoal):\n 1. ({p. simple_matches m p} \\<subseteq> simple_packet_set_toSet ms) =\n    ({p. simple_matches m p} \\<inter>\n     (\\<Inter>m\\<in>set ms. {p. \\<not> simple_matches m p}) =\n     {})", "finally"], ["proof (chain)\npicking this:\n  ({p. simple_matches m p} \\<subseteq> simple_packet_set_toSet ms) =\n  ({p. simple_matches m p} \\<inter>\n   (\\<Inter>m\\<in>set ms. {p. \\<not> simple_matches m p}) =\n   {})", "show ?thesis"], ["proof (prove)\nusing this:\n  ({p. simple_matches m p} \\<subseteq> simple_packet_set_toSet ms) =\n  ({p. simple_matches m p} \\<inter>\n   (\\<Inter>m\\<in>set ms. {p. \\<not> simple_matches m p}) =\n   {})\n\ngoal (1 subgoal):\n 1. ({p. simple_matches m p} \\<subseteq> simple_packet_set_toSet ms) =\n    ({p. simple_matches m p} \\<inter>\n     (\\<Inter>m\\<in>set ms. {p. \\<not> simple_matches m p}) =\n     {})", "."], ["proof (state)\nthis:\n  ({p. simple_matches m p} \\<subseteq> simple_packet_set_toSet ms) =\n  ({p. simple_matches m p} \\<inter>\n   (\\<Inter>m\\<in>set ms. {p. \\<not> simple_matches m p}) =\n   {})\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}