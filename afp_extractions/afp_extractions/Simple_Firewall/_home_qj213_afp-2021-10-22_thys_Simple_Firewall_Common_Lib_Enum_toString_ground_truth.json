{"file_name": "/home/qj213/afp-2021-10-22/thys/Simple_Firewall/Common/Lib_Enum_toString.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Simple_Firewall", "problem_names": ["lemma enum_set_get_one_empty: \"enum_set_get_one ss {} = None\"", "lemma enum_set_get_one_None: \"S \\<subseteq> set ss \\<Longrightarrow> enum_set_get_one ss S = None \\<longleftrightarrow> S = {}\"", "lemma enum_set_get_one_Some: \"S \\<subseteq> set ss \\<Longrightarrow> enum_set_get_one ss S = Some x \\<Longrightarrow> x \\<in> S\"", "lemma enum_set_get_one_Ex_Some: \"S \\<subseteq> set ss \\<Longrightarrow> S \\<noteq> {} \\<Longrightarrow> \\<exists>x. enum_set_get_one ss S = Some x\"", "lemma enum_set_to_list_simps: \"enum_set_to_list S =\n      (case enum_set_get_one (Enum.enum) S of None \\<Rightarrow> []\n                                           |  Some a \\<Rightarrow> a#enum_set_to_list (S - {a}))\"", "lemma enum_set_to_list: \"set (enum_set_to_list A) = A\"", "lemma \"list_toString bool_toString (enum_set_to_list {True, False}) = ''[False, True]''\""], "translations": [["", "lemma enum_set_get_one_empty: \"enum_set_get_one ss {} = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum_set_get_one ss {} = None", "by(induction ss) simp_all"], ["", "lemma enum_set_get_one_None: \"S \\<subseteq> set ss \\<Longrightarrow> enum_set_get_one ss S = None \\<longleftrightarrow> S = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> set ss \\<Longrightarrow>\n    (enum_set_get_one ss S = None) = (S = {})", "apply(induction ss)"], ["proof (prove)\ngoal (2 subgoals):\n 1. S \\<subseteq> set [] \\<Longrightarrow>\n    (enum_set_get_one [] S = None) = (S = {})\n 2. \\<And>a ss.\n       \\<lbrakk>S \\<subseteq> set ss \\<Longrightarrow>\n                (enum_set_get_one ss S = None) = (S = {});\n        S \\<subseteq> set (a # ss)\\<rbrakk>\n       \\<Longrightarrow> (enum_set_get_one (a # ss) S = None) = (S = {})", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ss.\n       \\<lbrakk>S \\<subseteq> set ss \\<Longrightarrow>\n                (enum_set_get_one ss S = None) = (S = {});\n        S \\<subseteq> set (a # ss)\\<rbrakk>\n       \\<Longrightarrow> (enum_set_get_one (a # ss) S = None) = (S = {})", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ss.\n       \\<lbrakk>S \\<subseteq> set ss \\<Longrightarrow>\n                (enum_set_get_one ss S = None) = (S = {});\n        S \\<subseteq> insert a (set ss)\\<rbrakk>\n       \\<Longrightarrow> (a \\<in> S \\<longrightarrow> S \\<noteq> {}) \\<and>\n                         (a \\<notin> S \\<longrightarrow>\n                          (enum_set_get_one ss S = None) = (S = {}))", "apply(intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a ss.\n       \\<lbrakk>S \\<subseteq> set ss \\<Longrightarrow>\n                (enum_set_get_one ss S = None) = (S = {});\n        S \\<subseteq> insert a (set ss)\\<rbrakk>\n       \\<Longrightarrow> a \\<in> S \\<longrightarrow> S \\<noteq> {}\n 2. \\<And>a ss.\n       \\<lbrakk>S \\<subseteq> set ss \\<Longrightarrow>\n                (enum_set_get_one ss S = None) = (S = {});\n        S \\<subseteq> insert a (set ss)\\<rbrakk>\n       \\<Longrightarrow> a \\<notin> S \\<longrightarrow>\n                         (enum_set_get_one ss S = None) = (S = {})", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ss.\n       \\<lbrakk>S \\<subseteq> set ss \\<Longrightarrow>\n                (enum_set_get_one ss S = None) = (S = {});\n        S \\<subseteq> insert a (set ss)\\<rbrakk>\n       \\<Longrightarrow> a \\<notin> S \\<longrightarrow>\n                         (enum_set_get_one ss S = None) = (S = {})", "by fast"], ["", "lemma enum_set_get_one_Some: \"S \\<subseteq> set ss \\<Longrightarrow> enum_set_get_one ss S = Some x \\<Longrightarrow> x \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<subseteq> set ss; enum_set_get_one ss S = Some x\\<rbrakk>\n    \\<Longrightarrow> x \\<in> S", "apply(induction ss)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>S \\<subseteq> set []; enum_set_get_one [] S = Some x\\<rbrakk>\n    \\<Longrightarrow> x \\<in> S\n 2. \\<And>a ss.\n       \\<lbrakk>\\<lbrakk>S \\<subseteq> set ss;\n                 enum_set_get_one ss S = Some x\\<rbrakk>\n                \\<Longrightarrow> x \\<in> S;\n        S \\<subseteq> set (a # ss);\n        enum_set_get_one (a # ss) S = Some x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> S", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ss.\n       \\<lbrakk>\\<lbrakk>S \\<subseteq> set ss;\n                 enum_set_get_one ss S = Some x\\<rbrakk>\n                \\<Longrightarrow> x \\<in> S;\n        S \\<subseteq> set (a # ss);\n        enum_set_get_one (a # ss) S = Some x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> S", "apply(simp split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ss.\n       \\<lbrakk>S \\<subseteq> set ss \\<Longrightarrow> x \\<in> S;\n        S \\<subseteq> insert a (set ss); a \\<notin> S;\n        enum_set_get_one ss S = Some x\\<rbrakk>\n       \\<Longrightarrow> x \\<in> S", "apply(blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary enum_set_get_one_enum_Some: \"enum_set_get_one enum_class.enum S = Some x \\<Longrightarrow> x \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum_set_get_one enum_class.enum S = Some x \\<Longrightarrow> x \\<in> S", "using enum_set_get_one_Some[where ss=enum_class.enum, simplified enum_UNIV]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?S \\<subseteq> UNIV;\n   enum_set_get_one enum_class.enum ?S = Some ?x\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> ?S\n\ngoal (1 subgoal):\n 1. enum_set_get_one enum_class.enum S = Some x \\<Longrightarrow> x \\<in> S", "by auto"], ["", "lemma enum_set_get_one_Ex_Some: \"S \\<subseteq> set ss \\<Longrightarrow> S \\<noteq> {} \\<Longrightarrow> \\<exists>x. enum_set_get_one ss S = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<subseteq> set ss; S \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. enum_set_get_one ss S = Some x", "apply(induction ss)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>S \\<subseteq> set []; S \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x. enum_set_get_one [] S = Some x\n 2. \\<And>a ss.\n       \\<lbrakk>\\<lbrakk>S \\<subseteq> set ss; S \\<noteq> {}\\<rbrakk>\n                \\<Longrightarrow> \\<exists>x.\n                                     enum_set_get_one ss S = Some x;\n        S \\<subseteq> set (a # ss); S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x. enum_set_get_one (a # ss) S = Some x", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ss.\n       \\<lbrakk>\\<lbrakk>S \\<subseteq> set ss; S \\<noteq> {}\\<rbrakk>\n                \\<Longrightarrow> \\<exists>x.\n                                     enum_set_get_one ss S = Some x;\n        S \\<subseteq> set (a # ss); S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x. enum_set_get_one (a # ss) S = Some x", "apply(simp split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ss.\n       \\<lbrakk>S \\<subseteq> set ss \\<Longrightarrow>\n                \\<exists>x. enum_set_get_one ss S = Some x;\n        S \\<subseteq> insert a (set ss); S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> a \\<notin> S \\<longrightarrow>\n                         (\\<exists>x. enum_set_get_one ss S = Some x)", "apply(blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary enum_set_get_one_enum_Ex_Some:\n    \"S \\<noteq> {} \\<Longrightarrow> \\<exists>x. enum_set_get_one enum_class.enum S = Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow>\n    \\<exists>x. enum_set_get_one enum_class.enum S = Some x", "using enum_set_get_one_Ex_Some[where ss=enum_class.enum, simplified enum_UNIV]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?S \\<subseteq> UNIV; ?S \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x. enum_set_get_one enum_class.enum ?S = Some x\n\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<Longrightarrow>\n    \\<exists>x. enum_set_get_one enum_class.enum S = Some x", "by auto"], ["", "function enum_set_to_list :: \"('a::enum) set \\<Rightarrow> 'a list\" where\n    \"enum_set_to_list S = (if S = {} then [] else\n      case enum_set_get_one Enum.enum S of None \\<Rightarrow> []\n                                        |  Some a \\<Rightarrow> a#enum_set_to_list (S - {a}))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>S. x = S \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>S Sa.\n       S = Sa \\<Longrightarrow>\n       (if S = {} then []\n        else case enum_set_get_one enum_class.enum S of\n             None \\<Rightarrow> []\n             | Some a \\<Rightarrow> a # enum_set_to_list_sumC (S - {a})) =\n       (if Sa = {} then []\n        else case enum_set_get_one enum_class.enum Sa of\n             None \\<Rightarrow> []\n             | Some a \\<Rightarrow> a # enum_set_to_list_sumC (Sa - {a}))", "by(pat_completeness) auto"], ["", "termination enum_set_to_list"], ["proof (prove)\ngoal (1 subgoal):\n 1. All enum_set_to_list_dom", "apply(relation \"measure (\\<lambda>(S). card S)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf (measure card)\n 2. \\<And>S x2.\n       \\<lbrakk>S \\<noteq> {};\n        enum_set_get_one enum_class.enum S = Some x2\\<rbrakk>\n       \\<Longrightarrow> (S - {x2}, S) \\<in> measure card", "apply(simp_all add: card_gt_0_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S x2.\n       \\<lbrakk>S \\<noteq> {};\n        enum_set_get_one enum_class.enum S = Some x2\\<rbrakk>\n       \\<Longrightarrow> card (S - {x2}) < card S", "apply(drule enum_set_get_one_enum_Some)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S x2.\n       \\<lbrakk>S \\<noteq> {}; x2 \\<in> S\\<rbrakk>\n       \\<Longrightarrow> card (S - {x2}) < card S", "apply(subgoal_tac \"finite S\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>S x2.\n       \\<lbrakk>S \\<noteq> {}; x2 \\<in> S; finite S\\<rbrakk>\n       \\<Longrightarrow> card (S - {x2}) < card S\n 2. \\<And>S x2.\n       \\<lbrakk>S \\<noteq> {}; x2 \\<in> S\\<rbrakk>\n       \\<Longrightarrow> finite S", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>S x2.\n       \\<lbrakk>S \\<noteq> {}; x2 \\<in> S\\<rbrakk>\n       \\<Longrightarrow> finite S\n 2. \\<And>S x2.\n       \\<lbrakk>S \\<noteq> {}; x2 \\<in> S; finite S\\<rbrakk>\n       \\<Longrightarrow> card (S - {x2}) < card S", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S x2.\n       \\<lbrakk>S \\<noteq> {}; x2 \\<in> S; finite S\\<rbrakk>\n       \\<Longrightarrow> card (S - {x2}) < card S", "apply (meson card_Diff1_less)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*this definition is simpler*)"], ["", "lemma enum_set_to_list_simps: \"enum_set_to_list S =\n      (case enum_set_get_one (Enum.enum) S of None \\<Rightarrow> []\n                                           |  Some a \\<Rightarrow> a#enum_set_to_list (S - {a}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enum_set_to_list S =\n    (case enum_set_get_one enum_class.enum S of None \\<Rightarrow> []\n     | Some a \\<Rightarrow> a # enum_set_to_list (S - {a}))", "by(simp add: enum_set_get_one_empty)"], ["", "declare enum_set_to_list.simps[simp del]"], ["", "lemma enum_set_to_list: \"set (enum_set_to_list A) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (enum_set_to_list A) = A", "apply(induction A rule: enum_set_to_list.induct)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S.\n       (\\<And>x2.\n           \\<lbrakk>S \\<noteq> {};\n            enum_set_get_one enum_class.enum S = Some x2\\<rbrakk>\n           \\<Longrightarrow> set (enum_set_to_list (S - {x2})) =\n                             S - {x2}) \\<Longrightarrow>\n       set (enum_set_to_list S) = S", "apply(case_tac \"S = {}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>S.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>S \\<noteq> {};\n                    enum_set_get_one enum_class.enum S = Some x2\\<rbrakk>\n                   \\<Longrightarrow> set (enum_set_to_list (S - {x2})) =\n                                     S - {x2};\n        S = {}\\<rbrakk>\n       \\<Longrightarrow> set (enum_set_to_list S) = S\n 2. \\<And>S.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>S \\<noteq> {};\n                    enum_set_get_one enum_class.enum S = Some x2\\<rbrakk>\n                   \\<Longrightarrow> set (enum_set_to_list (S - {x2})) =\n                                     S - {x2};\n        S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> set (enum_set_to_list S) = S", "apply(simp add: enum_set_to_list.simps; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>\\<And>x2.\n                   \\<lbrakk>S \\<noteq> {};\n                    enum_set_get_one enum_class.enum S = Some x2\\<rbrakk>\n                   \\<Longrightarrow> set (enum_set_to_list (S - {x2})) =\n                                     S - {x2};\n        S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> set (enum_set_to_list S) = S", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>\\<And>x2.\n                   enum_set_get_one enum_class.enum S =\n                   Some x2 \\<Longrightarrow>\n                   set (enum_set_to_list (S - {x2})) = S - {x2};\n        S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> set (enum_set_to_list S) = S", "apply(subst enum_set_to_list_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>\\<And>x2.\n                   enum_set_get_one enum_class.enum S =\n                   Some x2 \\<Longrightarrow>\n                   set (enum_set_to_list (S - {x2})) = S - {x2};\n        S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> set (case enum_set_get_one enum_class.enum S of\n                              None \\<Rightarrow> []\n                              | Some a \\<Rightarrow>\n                                  a # enum_set_to_list (S - {a})) =\n                         S", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>\\<And>x2.\n                   enum_set_get_one enum_class.enum S =\n                   Some x2 \\<Longrightarrow>\n                   set (enum_set_to_list (S - {x2})) = S - {x2};\n        S \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> {x. \\<exists>uu_.\n                                Some uu_ =\n                                enum_set_get_one enum_class.enum S \\<and>\n                                (x = uu_ \\<or>\n                                 x \\<in> set\n    (enum_set_to_list (S - {uu_})))} =\n                         S", "apply(drule enum_set_get_one_enum_Ex_Some)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S.\n       \\<lbrakk>\\<And>x2.\n                   enum_set_get_one enum_class.enum S =\n                   Some x2 \\<Longrightarrow>\n                   set (enum_set_to_list (S - {x2})) = S - {x2};\n        \\<exists>x. enum_set_get_one enum_class.enum S = Some x\\<rbrakk>\n       \\<Longrightarrow> {x. \\<exists>uu_.\n                                Some uu_ =\n                                enum_set_get_one enum_class.enum S \\<and>\n                                (x = uu_ \\<or>\n                                 x \\<in> set\n    (enum_set_to_list (S - {uu_})))} =\n                         S", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>\\<And>x2.\n                   enum_set_get_one enum_class.enum S =\n                   Some x2 \\<Longrightarrow>\n                   set (enum_set_to_list (S - {x2})) = S - {x2};\n        enum_set_get_one enum_class.enum S = Some x\\<rbrakk>\n       \\<Longrightarrow> {x. \\<exists>uu_.\n                                Some uu_ =\n                                enum_set_get_one enum_class.enum S \\<and>\n                                (x = uu_ \\<or>\n                                 x \\<in> set\n    (enum_set_to_list (S - {uu_})))} =\n                         S", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>set (enum_set_to_list (S - {x})) = S - {x};\n        enum_set_get_one enum_class.enum S = Some x\\<rbrakk>\n       \\<Longrightarrow> {xa.\n                          xa = x \\<or> xa \\<in> S \\<and> xa \\<noteq> x} =\n                         S", "apply(drule enum_set_get_one_enum_Some)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S x.\n       \\<lbrakk>set (enum_set_to_list (S - {x})) = S - {x};\n        x \\<in> S\\<rbrakk>\n       \\<Longrightarrow> {xa.\n                          xa = x \\<or> xa \\<in> S \\<and> xa \\<noteq> x} =\n                         S", "by blast"], ["", "lemma \"list_toString bool_toString (enum_set_to_list {True, False}) = ''[False, True]''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_toString bool_toString (enum_set_to_list {True, False}) =\n    ''[False, True]''", "by eval"], ["", "end"]]}