{"file_name": "/home/qj213/afp-2021-10-22/thys/Simple_Firewall/Service_Matrix.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Simple_Firewall", "problem_names": ["lemma extract_IPSets_generic0_length: \"length (extract_IPSets_generic0 sel rs) = length rs\"", "lemma \"mergesort_remdups [(1::ipv4addr, 2::nat), (8,0), (8,1), (2,2), (2,4), (1,2), (2,2)] =\n        [(1, 2), (2, 2), (2, 4), (8, 0), (8, 1)]\"", "lemma extract_src_dst_ips_length: \"length (extract_src_dst_ips rs acc) = 2*length rs + length acc\"", "lemma extract_IPSets:\n  \"set (extract_IPSets rs) = set (extract_IPSets_generic0 src rs) \\<union> set (extract_IPSets_generic0 dst rs)\"", "lemma \"(a::nat) div 2 + a mod 2 \\<le> a\"", "lemma merge_length: \"length (merge l1 l2) \\<le> length l1 + length l2\"", "lemma merge_list_length: \"length (merge_list as ls) \\<le> length (concat (as @ ls))\"", "lemma mergesort_remdups_length: \"length (mergesort_remdups as) \\<le> length as\"", "lemma extract_IPSets_length: \"length (extract_IPSets rs) \\<le> 2 * length rs\"", "lemma extract_equi0:\n  \"set (map wordinterval_to_set (extract_IPSets_generic0 sel rs)) =\n    (\\<lambda>(base,len). ipset_from_cidr base len) ` sel ` match_sel ` set rs\"", "lemma src_ipPart_motivation:\nfixes   rs\ndefines \"X \\<equiv> (\\<lambda>(base,len). ipset_from_cidr base len) ` src ` match_sel ` set rs\"\nassumes \"\\<forall>A \\<in> X. B \\<subseteq> A \\<or> B \\<inter> A = {}\" and \"s1 \\<in> B\" and \"s2 \\<in> B\"\nshows \"simple_fw rs (p\\<lparr>p_src:=s1\\<rparr>) = simple_fw rs (p\\<lparr>p_src:=s2\\<rparr>)\"", "lemma src_ipPart:\n  assumes \"ipPartition (set (map wordinterval_to_set (extract_IPSets_generic0 src rs))) A\"\n          \"B \\<in> A\" \"s1 \\<in> B\" \"s2 \\<in> B\"\n  shows \"simple_fw rs (p\\<lparr>p_src:=s1\\<rparr>) = simple_fw rs (p\\<lparr>p_src:=s2\\<rparr>)\"", "lemma dst_ipPart:\n  assumes \"ipPartition (set (map wordinterval_to_set (extract_IPSets_generic0 dst rs))) A\"\n          \"B \\<in> A\" \"s1 \\<in> B\" \"s2 \\<in> B\"\n  shows \"simple_fw rs (p\\<lparr>p_dst:=s1\\<rparr>) = simple_fw rs (p\\<lparr>p_dst:=s2\\<rparr>)\"", "lemma wordinterval_list_to_set_compressed:\n  \"wordinterval_to_set (wordinterval_compress (foldr wordinterval_union xs Empty_WordInterval)) =\n          wordinterval_list_to_set xs\"", "lemma \"partIps (WordInterval (1::ipv4addr) 1) [WordInterval 0 1] = [WordInterval 1 1, WordInterval 0 0]\"", "lemma partIps_length: \"length (partIps s ts) \\<le> (length ts) * 2\"", "lemma partitioningIps_length: \"length (partitioningIps ss ts) \\<le> (2^length ss) * length ts\"", "lemma partIps_equi: \"map wordinterval_to_set (partIps s ts) = \n    partList4 (wordinterval_to_set s) (map wordinterval_to_set ts)\"", "lemma partitioningIps_equi: \"map wordinterval_to_set (partitioningIps ss ts)\n       = (partitioning1 (map wordinterval_to_set ss) (map wordinterval_to_set ts))\"", "lemma partitioningIps_foldr: \"partitioningIps ss ts = foldr partIps ss ts\"", "lemma getParts_foldr: \"getParts rs = foldr partIps (extract_IPSets rs) [wordinterval_UNIV]\"", "lemma getParts_length: \"length (getParts rs) \\<le> 2^(2 * length rs)\"", "lemma getParts_ipPartition: \"ipPartition (set (map wordinterval_to_set (extract_IPSets rs)))\n                                         (set (map wordinterval_to_set (getParts rs)))\"", "lemma getParts_complete: \"wordinterval_list_to_set (getParts rs) = UNIV\"", "theorem getParts_samefw: \n  assumes \"A \\<in> set (map wordinterval_to_set (getParts rs))\" \"s1 \\<in> A\" \"s2 \\<in> A\" \n  shows \"simple_fw rs (p\\<lparr>p_src:=s1\\<rparr>) = simple_fw rs (p\\<lparr>p_src:=s2\\<rparr>) \\<and>\n         simple_fw rs (p\\<lparr>p_dst:=s1\\<rparr>) = simple_fw rs (p\\<lparr>p_dst:=s2\\<rparr>)\"", "lemma partIps_nonempty: \"ts \\<noteq> [] \\<Longrightarrow> partIps s ts \\<noteq> []\"", "lemma partitioningIps_nonempty: \"ts \\<noteq> [] \\<Longrightarrow> partitioningIps ss ts \\<noteq> []\"", "lemma getParts_nonempty: \"getParts rs \\<noteq> []\"", "lemma getParts_nonempty_elems: \"\\<forall>w\\<in>set (getParts rs). \\<not> wordinterval_empty w\"", "lemma getOneIp_elem: \"\\<not> wordinterval_empty W \\<Longrightarrow> wordinterval_element (getOneIp W) W\"", "lemma getParts_same_fw_behaviour:\n  \"A \\<in> set (map wordinterval_to_set (getParts rs)) \\<Longrightarrow>  s1 \\<in> A \\<Longrightarrow> s2 \\<in> A \\<Longrightarrow> \n   same_fw_behaviour s1 s2 rs\"", "lemma runFw_scheme: \"runFw s d c rs = runFw_scheme s d c p rs\"", "lemma has_default_policy_runFw: \"has_default_policy rs \\<Longrightarrow> runFw s d c rs = Decision FinalAllow \\<or> runFw s d c rs = Decision FinalDeny\"", "lemma same_fw_spec: \"same_fw_behaviour ip1 ip2 rs \\<Longrightarrow> same_fw_behaviour_one ip1 ip2 c rs\"", "lemma same_fw_behaviour_one_equi:\n  \"same_fw_behaviour_one x x c rs\"\n  \"same_fw_behaviour_one x y c rs = same_fw_behaviour_one y x c rs\"\n  \"same_fw_behaviour_one x y c rs \\<and> same_fw_behaviour_one y z c rs \\<Longrightarrow> same_fw_behaviour_one x z c rs\"", "lemma same_fw_behaviour_equi:\n  \"same_fw_behaviour x x rs\"\n  \"same_fw_behaviour x y rs = same_fw_behaviour y x rs\"\n  \"same_fw_behaviour x y rs \\<and> same_fw_behaviour y z rs \\<Longrightarrow> same_fw_behaviour x z rs\"", "lemma runFw_sameFw_behave: \n       fixes W :: \"'i::len word set set\"\n       shows\n       \"\\<forall>A \\<in> W. \\<forall>a1 \\<in> A. \\<forall>a2 \\<in> A. same_fw_behaviour_one a1 a2 c rs \\<Longrightarrow> \\<Union> W = UNIV \\<Longrightarrow>\n       \\<forall>B \\<in> W. \\<exists>b \\<in> B. runFw ip1 b c rs = runFw ip2 b c rs \\<Longrightarrow>\n       \\<forall>B \\<in> W. \\<exists>b \\<in> B. runFw b ip1 c rs = runFw b ip2 c rs \\<Longrightarrow>\n       same_fw_behaviour_one ip1 ip2 c rs\"", "lemma sameFw_behave_sets:\n  \"\\<forall>w\\<in>set A. \\<forall>a1 \\<in> w. \\<forall>a2 \\<in> w. same_fw_behaviour_one a1 a2 c rs \\<Longrightarrow>\n   \\<forall>w1\\<in>set A. \\<forall>w2\\<in>set A. \\<exists>a1\\<in>w1. \\<exists>a2\\<in>w2. same_fw_behaviour_one a1 a2 c rs \\<Longrightarrow>\n   \\<forall>w1\\<in>set A. \\<forall>w2\\<in>set A.\n     \\<forall>a1\\<in>w1. \\<forall>a2\\<in>w2. same_fw_behaviour_one a1 a2 c rs\"", "lemma groupWIs_not_empty: \"groupWIs c rs \\<noteq> []\"", "lemma groupWIs_not_empty_elem: \"V \\<in> set (groupWIs c rs) \\<Longrightarrow> V \\<noteq> []\"", "lemma groupWIs_not_empty_elems: \n  assumes V: \"V \\<in> set (groupWIs c rs)\" and w: \"w \\<in> set V\"\n  shows \"\\<not> wordinterval_empty w\"", "lemma groupParts_same_fw_wi0:\n    assumes \"V \\<in> set (groupWIs c rs)\"\n    shows \"\\<forall>w \\<in> set (map wordinterval_to_set V). \\<forall>a1 \\<in> w. \\<forall>a2 \\<in> w. same_fw_behaviour_one a1 a2 c rs\"", "lemma groupWIs_same_fw_not: \"A \\<in> set (groupWIs c rs) \\<Longrightarrow> B \\<in> set (groupWIs c rs) \\<Longrightarrow> \n                            A \\<noteq> B \\<Longrightarrow>\n                             \\<forall>aw \\<in> set (map wordinterval_to_set A).\n                             \\<forall>bw \\<in> set (map wordinterval_to_set B).\n                             \\<forall>a \\<in> aw. \\<forall>b \\<in> bw. \\<not> same_fw_behaviour_one a b c rs\"", "lemma groupParts_same_fw_wi1:\n  \"V \\<in> set (groupWIs c rs) \\<Longrightarrow> \\<forall>w1 \\<in> set V. \\<forall>w2 \\<in> set V.\n     \\<forall>a1 \\<in> wordinterval_to_set w1. \\<forall>a2 \\<in> wordinterval_to_set w2. same_fw_behaviour_one a1 a2 c rs\"", "lemma groupParts_same_fw_wi2: \"V \\<in> set (groupWIs c rs) \\<Longrightarrow>\n                               \\<forall>ip1 \\<in> wordinterval_list_to_set V.\n                               \\<forall>ip2 \\<in> wordinterval_list_to_set V.\n                               same_fw_behaviour_one ip1 ip2 c rs\"", "lemma groupWIs_same_fw_not2: \"A \\<in> set (groupWIs c rs) \\<Longrightarrow> B \\<in> set (groupWIs c rs) \\<Longrightarrow> \n                                A \\<noteq> B \\<Longrightarrow>\n                                \\<forall>ip1 \\<in> wordinterval_list_to_set A.\n                                \\<forall>ip2 \\<in> wordinterval_list_to_set B.\n                                \\<not> same_fw_behaviour_one ip1 ip2 c rs\"", "lemma \"A \\<in> set (groupWIs c rs) \\<Longrightarrow> B \\<in> set (groupWIs c rs) \\<Longrightarrow> \n                \\<exists>ip1 \\<in> wordinterval_list_to_set A.\n                \\<exists>ip2 \\<in> wordinterval_list_to_set B. same_fw_behaviour_one ip1 ip2 c rs\n                \\<Longrightarrow> A = B\"", "lemma groupWIs_complete: \"(\\<Union>x\\<in> set (groupWIs c rs). wordinterval_list_to_set x) = (UNIV::'i::len word set)\"", "lemma groupWIs_groupWIs1_equi: \"groupWIs1 c rs = groupWIs c rs\"", "lemma simple_conn_matches_simple_match_any: \"simple_conn_matches simple_match_any c\"", "lemma has_default_policy_simple_conn_matches:\n    \"has_default_policy rs \\<Longrightarrow> has_default_policy [r\\<leftarrow>rs . simple_conn_matches (match_sel r) c]\"", "lemma filter_conn_fw_lem: \n    \"runFw s d c (filter (\\<lambda>r. simple_conn_matches (match_sel r) c) rs) = runFw s d c rs\"", "lemma groupWIs1_groupWIs2_equi: \"groupWIs2 c rs = groupWIs1 c rs\"", "lemma groupWIs_code[code]: \"groupWIs c rs = groupWIs2 c rs\"", "lemma matching_dsts_pull_out_accu:\n    \"wordinterval_to_set (matching_dsts s rs (wordinterval_union a1 a2)) = wordinterval_to_set (matching_dsts s rs a2) - wordinterval_to_set a1\"", "lemma matching_srcs_pull_out_accu:\n    \"wordinterval_to_set (matching_srcs d rs (wordinterval_union a1 a2)) = wordinterval_to_set (matching_srcs d rs a2) - wordinterval_to_set a1\"", "lemma matching_dsts: \"\\<forall>r \\<in> set rs. simple_conn_matches (match_sel r) c \\<Longrightarrow>\n          wordinterval_to_set (matching_dsts s rs Empty_WordInterval) = {d. runFw s d c rs = Decision FinalAllow}\"", "lemma matching_srcs: \"\\<forall>r \\<in> set rs. simple_conn_matches (match_sel r) c \\<Longrightarrow>\n          wordinterval_to_set (matching_srcs d rs Empty_WordInterval) = {s. runFw s d c rs = Decision FinalAllow}\"", "lemma groupWIs3_default_policy_groupWIs2:\n  fixes rs :: \"'i::len simple_rule list\"\n  assumes \"has_default_policy rs\"\n  shows \"groupWIs2 c rs = groupWIs3_default_policy c rs\"", "lemma groupWIs3: \"groupWIs3 = groupWIs\"", "theorem build_ip_partition_same_fw: \"V \\<in> set (build_ip_partition c rs) \\<Longrightarrow>\n                               \\<forall>ip1::'i::len word \\<in> wordinterval_to_set V.\n                               \\<forall>ip2::'i::len word \\<in> wordinterval_to_set V.\n                               same_fw_behaviour_one ip1 ip2 c rs\"", "theorem build_ip_partition_same_fw_min: \"A \\<in> set (build_ip_partition c rs) \\<Longrightarrow> B \\<in> set (build_ip_partition c rs) \\<Longrightarrow> \n                                A \\<noteq> B \\<Longrightarrow>\n                                \\<forall>ip1::'i::len word \\<in> wordinterval_to_set A.\n                                \\<forall>ip2::'i::len word \\<in> wordinterval_to_set B.\n                                \\<not> same_fw_behaviour_one ip1 ip2 c rs\"", "theorem build_ip_partition_complete: \"(\\<Union>x\\<in>set (build_ip_partition c rs). wordinterval_to_set x) = (UNIV :: 'i::len word set)\"", "lemma build_ip_partition_no_empty_elems: \"wi \\<in> set (build_ip_partition c rs) \\<Longrightarrow> \\<not> wordinterval_empty wi\"", "lemma build_ip_partition_disjoint: \n      \"V1 \\<in> set (build_ip_partition c rs) \\<Longrightarrow> V2 \\<in> set (build_ip_partition c rs) \\<Longrightarrow>\n       V1 \\<noteq> V2 \\<Longrightarrow>\n        wordinterval_to_set V1 \\<inter> wordinterval_to_set V2 = {}\"", "lemma map_wordinterval_to_set_distinct:\n  assumes distinct: \"distinct xs\"\n  and disjoint: \"(\\<forall>x1 \\<in> set xs. \\<forall>x2 \\<in> set xs. x1 \\<noteq> x2 \\<longrightarrow> wordinterval_to_set x1 \\<inter> wordinterval_to_set x2 = {})\" \n  and notempty: \"\\<forall>x \\<in> set xs. \\<not> wordinterval_empty x\"\n  shows \"distinct (map wordinterval_to_set xs)\"", "lemma map_getOneIp_distinct: assumes\n  distinct: \"distinct xs\"\n  and disjoint: \"(\\<forall>x1 \\<in> set xs. \\<forall>x2 \\<in> set xs. x1 \\<noteq> x2 \\<longrightarrow> wordinterval_to_set x1 \\<inter> wordinterval_to_set x2 = {})\" \n  and notempty: \"\\<forall>x \\<in> set xs. \\<not> wordinterval_empty x\"\n  shows \"distinct (map getOneIp xs)\"", "lemma getParts_disjoint_list: \"disjoint_list (map wordinterval_to_set (getParts rs))\"", "lemma build_ip_partition_distinct: \"distinct (map wordinterval_to_set (build_ip_partition c rs))\"", "lemma build_ip_partition_distinct': \"distinct (build_ip_partition c rs)\"", "lemma simple_fw_no_interfaces:\n  assumes no_ifaces: \"simple_firewall_without_interfaces rs\"\n  shows \"simple_fw rs p = simple_fw rs (p\\<lparr> p_iiface:= x, p_oiface:= y\\<rparr>)\"", "lemma runFw_no_interfaces:\n  assumes no_ifaces: \"simple_firewall_without_interfaces rs\"\n  shows \"runFw s d c rs = runFw s d (c\\<lparr> pc_iiface:= x, pc_oiface:= y\\<rparr>) rs\"", "lemma[code_unfold]: \"simple_firewall_without_interfaces rs \\<equiv>\n  \\<forall>m \\<in> set rs. iiface (match_sel m) = ifaceAny \\<and> oiface (match_sel m) = ifaceAny\"", "lemma access_matrix_nodes_defined:\n      \"(V,E) = access_matrix c rs \\<Longrightarrow> (s, d) \\<in> set E \\<Longrightarrow> s \\<in> dom (map_of V)\" and\n      \"(V,E) = access_matrix c rs \\<Longrightarrow> (s, d) \\<in> set E \\<Longrightarrow> d \\<in> dom (map_of V)\"", "lemma \"(V,E) = access_matrix c rs \\<Longrightarrow> (s, d) \\<in> set E \\<Longrightarrow> runFw s d c rs = Decision FinalAllow\"", "lemma map_of_zip_map: \"map_of (zip (map f rs) rs) k = Some v \\<Longrightarrow> k = f v\"", "lemma access_matrix_sound: assumes matrix: \"(V,E) = access_matrix c rs\" and\n              repr: \"(s_repr, d_repr) \\<in> set E\" and\n              s_range: \"(map_of V) s_repr = Some s_range\" and s: \"s \\<in> wordinterval_to_set s_range\" and\n              d_range: \"(map_of V) d_repr = Some d_range\" and d: \"d \\<in> wordinterval_to_set d_range\"\n      shows \"runFw s d c rs = Decision FinalAllow\"", "lemma distinct_map_getOneIp_obtain: \"v \\<in> set xs \\<Longrightarrow> distinct (map getOneIp xs) \\<Longrightarrow> \n  \\<exists>s_repr. map_of (zip (map getOneIp xs) xs) s_repr = Some v\"", "lemma access_matrix_complete:\n      fixes rs :: \"'i::len simple_rule list\"\n      assumes matrix: \"(V,E) = access_matrix c rs\" and\n              allow: \"runFw s d c rs = Decision FinalAllow\"\n      shows \"\\<exists>s_repr d_repr s_range d_range. (s_repr, d_repr) \\<in> set E \\<and>\n              (map_of V) s_repr = Some s_range \\<and> s \\<in> wordinterval_to_set s_range \\<and>\n              (map_of V) d_repr = Some d_range \\<and> d \\<in> wordinterval_to_set d_range\"", "theorem access_matrix:\n      fixes rs :: \"'i::len simple_rule list\"\n      assumes matrix: \"(V,E) = access_matrix c rs\"\n      shows \"(\\<exists>s_repr d_repr s_range d_range. (s_repr, d_repr) \\<in> set E \\<and>\n              (map_of V) s_repr = Some s_range \\<and> s \\<in> wordinterval_to_set s_range \\<and>\n              (map_of V) d_repr = Some d_range \\<and> d \\<in> wordinterval_to_set d_range)\n             \\<longleftrightarrow>\n             runFw s d c rs = Decision FinalAllow\"", "lemma access_matrix_pretty_ipv4_code[code]: \"access_matrix_pretty_ipv4 = access_matrix_pretty_ipv4_code\"", "lemma access_matrix_pretty_ipv6_code[code]: \"access_matrix_pretty_ipv6 = access_matrix_pretty_ipv6_code\"", "lemma \"mk_parts_connection_TCP 10000 22 = parts_connection_ssh\"\n      \"mk_parts_connection_TCP 10000 80 = parts_connection_http\""], "translations": [["", "lemma extract_IPSets_generic0_length: \"length (extract_IPSets_generic0 sel rs) = length rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (extract_IPSets_generic0 sel rs) = length rs", "by(induction rs rule: extract_IPSets_generic0.induct) (simp_all)"], ["", "(*\nThe order in which extract_IPSets returns the collected IP ranges heavily influences the running time\nof the subsequent algorithms.\nFor example:\n1) iterating through the ruleset and collecting all source and destination ips:\n   10:10:49 elapsed time, 38:41:17 cpu time, factor 3.80\n2) iterating through the ruleset and first returning all source ips and iterating again and then return all destination ips:\n   3:39:56 elapsed time, 21:08:34 cpu time, factor 5.76\n\nTo get a more deterministic runtime, we are sorting the output. As a performance optimization, we also remove duplicate entries.\nWe use mergesort_remdups, which does a mergesort (i.e sorts!) and removes duplicates and mergesort_by_rel which does a mergesort\n(without removing duplicates) and allows to specify the relation we use to sort.\nIn theory, the largest ip ranges (smallest prefix length) should be put first, the following evaluation shows that this may not\nbe the fastest solution. The reason might be that access_matrix_pretty_ipv4 picks (almost randomly) one IP from the result and\nthere are fast and slower choices. The faster choices are the ones where the firewall ruleset has a decision very early. \nTherefore, the running time is still a bit unpredictable.\n\nHere is the data:\nmap ipcidr_tuple_to_wordinterval (mergesort_by_rel (\\<lambda> (a1,a2) (b1, b2). (a2, a1) \\<le> (b2, b1)) (mergesort_remdups\n                        ((map (src \\<circ> match_sel) rs) @ (map (dst \\<circ> match_sel) rs))))\n (2:47:04 elapsed time, 17:08:01 cpu time, factor 6.15)\n\n\nmap ipcidr_tuple_to_wordinterval (mergesort_remdups ((map (src \\<circ> match_sel) rs) @ (map (dst \\<circ> match_sel) rs)))\n (2:41:03 elapsed time, 16:56:46 cpu time, factor 6.31)\n\n\nmap ipcidr_tuple_to_wordinterval (mergesort_by_rel (\\<lambda> (a1,a2) (b1, b2). (a2, a1) \\<le> (b2, b1)) (\n                         ((map (src \\<circ> match_sel) rs) @ (map (dst \\<circ> match_sel) rs)))\n (5:52:28 elapsed time, 41:50:10 cpu time, factor 7.12)\n\n\nmap ipcidr_tuple_to_wordinterval (mergesort_by_rel (\\<le>)\n                         ((map (src \\<circ> match_sel) rs) @ (map (dst \\<circ> match_sel) rs))))\n  (3:10:57 elapsed time, 19:12:25 cpu time, factor 6.03)\n\n\nmap ipcidr_tuple_to_wordinterval (mergesort_by_rel (\\<lambda> (a1,a2) (b1, b2). (a2, a1) \\<le> (b2, b1)) (mergesort_remdups\n                        (extract_src_dst_ips rs [])))\n (2:49:57 elapsed time, 17:10:49 cpu time, factor 6.06)\n\nmap ipcidr_tuple_to_wordinterval ((mergesort_remdups (extract_src_dst_ips rs [])))\n (2:43:44 elapsed time, 16:57:49 cpu time, factor 6.21)\n\nmap ipcidr_tuple_to_wordinterval (mergesort_by_rel (\\<lambda> (a1,a2) (b1, b2). (a2, a1) \\<ge> (b2, b1)) (mergesort_remdups (extract_src_dst_ips rs [])))\n (2:47:37 elapsed time, 16:54:47 cpu time, factor 6.05)\n\nThere is a clear looser: not using mergesort_remdups\nThere is no clear winner. We will just stick to mergesort_remdups.\n\n*)\n\n(*check the the order of mergesort_remdups did not change*)"], ["", "lemma \"mergesort_remdups [(1::ipv4addr, 2::nat), (8,0), (8,1), (2,2), (2,4), (1,2), (2,2)] =\n        [(1, 2), (2, 2), (2, 4), (8, 0), (8, 1)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mergesort_remdups\n     [(1, 2), (8, 0), (8, 1), (2, 2), (2, 4), (1, 2), (2, 2)] =\n    [(1, 2), (2, 2), (2, 4), (8, 0), (8, 1)]", "by eval"], ["", "(*a tail-recursive implementation*)"], ["", "fun extract_src_dst_ips\n  :: \"'i::len simple_rule list \\<Rightarrow> ('i word \\<times> nat) list \\<Rightarrow> ('i word \\<times> nat) list\" where\n  \"extract_src_dst_ips [] ts = ts\" |\n  \"extract_src_dst_ips ((SimpleRule m _)#ss) ts = extract_src_dst_ips ss  (src m # dst m # ts)\""], ["", "lemma extract_src_dst_ips_length: \"length (extract_src_dst_ips rs acc) = 2*length rs + length acc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (extract_src_dst_ips rs acc) = 2 * length rs + length acc", "proof(induction rs arbitrary: acc)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>acc.\n       length (extract_src_dst_ips [] acc) = 2 * length [] + length acc\n 2. \\<And>a rs acc.\n       (\\<And>acc.\n           length (extract_src_dst_ips rs acc) =\n           2 * length rs + length acc) \\<Longrightarrow>\n       length (extract_src_dst_ips (a # rs) acc) =\n       2 * length (a # rs) + length acc", "case (Cons r rs)"], ["proof (state)\nthis:\n  length (extract_src_dst_ips rs ?acc) = 2 * length rs + length ?acc\n\ngoal (2 subgoals):\n 1. \\<And>acc.\n       length (extract_src_dst_ips [] acc) = 2 * length [] + length acc\n 2. \\<And>a rs acc.\n       (\\<And>acc.\n           length (extract_src_dst_ips rs acc) =\n           2 * length rs + length acc) \\<Longrightarrow>\n       length (extract_src_dst_ips (a # rs) acc) =\n       2 * length (a # rs) + length acc", "thus ?case"], ["proof (prove)\nusing this:\n  length (extract_src_dst_ips rs ?acc) = 2 * length rs + length ?acc\n\ngoal (1 subgoal):\n 1. length (extract_src_dst_ips (r # rs) acc) =\n    2 * length (r # rs) + length acc", "by(cases r, simp)"], ["proof (state)\nthis:\n  length (extract_src_dst_ips (r # rs) acc) =\n  2 * length (r # rs) + length acc\n\ngoal (1 subgoal):\n 1. \\<And>acc.\n       length (extract_src_dst_ips [] acc) = 2 * length [] + length acc", "qed(simp)"], ["", "definition extract_IPSets\n  :: \"'i::len simple_rule list \\<Rightarrow> ('i wordinterval) list\" where\n  \"extract_IPSets rs \\<equiv> map ipcidr_tuple_to_wordinterval (mergesort_remdups (extract_src_dst_ips rs []))\""], ["", "lemma extract_IPSets:\n  \"set (extract_IPSets rs) = set (extract_IPSets_generic0 src rs) \\<union> set (extract_IPSets_generic0 dst rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (extract_IPSets rs) =\n    set (extract_IPSets_generic0 src rs) \\<union>\n    set (extract_IPSets_generic0 dst rs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set (extract_IPSets rs) =\n    set (extract_IPSets_generic0 src rs) \\<union>\n    set (extract_IPSets_generic0 dst rs)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. set (extract_IPSets rs) =\n    set (extract_IPSets_generic0 src rs) \\<union>\n    set (extract_IPSets_generic0 dst rs)", "fix acc"], ["proof (state)\ngoal (1 subgoal):\n 1. set (extract_IPSets rs) =\n    set (extract_IPSets_generic0 src rs) \\<union>\n    set (extract_IPSets_generic0 dst rs)", "have \"ipcidr_tuple_to_wordinterval ` set (extract_src_dst_ips rs acc) =\n            ipcidr_tuple_to_wordinterval ` set acc \\<union> set (extract_IPSets_generic0 src rs) \\<union>\n            set (extract_IPSets_generic0 dst rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipcidr_tuple_to_wordinterval ` set (extract_src_dst_ips rs acc) =\n    ipcidr_tuple_to_wordinterval ` set acc \\<union>\n    set (extract_IPSets_generic0 src rs) \\<union>\n    set (extract_IPSets_generic0 dst rs)", "proof(induction rs arbitrary: acc)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>acc.\n       ipcidr_tuple_to_wordinterval ` set (extract_src_dst_ips [] acc) =\n       ipcidr_tuple_to_wordinterval ` set acc \\<union>\n       set (extract_IPSets_generic0 src []) \\<union>\n       set (extract_IPSets_generic0 dst [])\n 2. \\<And>a rs acc.\n       (\\<And>acc.\n           ipcidr_tuple_to_wordinterval ` set (extract_src_dst_ips rs acc) =\n           ipcidr_tuple_to_wordinterval ` set acc \\<union>\n           set (extract_IPSets_generic0 src rs) \\<union>\n           set (extract_IPSets_generic0 dst rs)) \\<Longrightarrow>\n       ipcidr_tuple_to_wordinterval `\n       set (extract_src_dst_ips (a # rs) acc) =\n       ipcidr_tuple_to_wordinterval ` set acc \\<union>\n       set (extract_IPSets_generic0 src (a # rs)) \\<union>\n       set (extract_IPSets_generic0 dst (a # rs))", "case (Cons r rs )"], ["proof (state)\nthis:\n  ipcidr_tuple_to_wordinterval ` set (extract_src_dst_ips rs ?acc) =\n  ipcidr_tuple_to_wordinterval ` set ?acc \\<union>\n  set (extract_IPSets_generic0 src rs) \\<union>\n  set (extract_IPSets_generic0 dst rs)\n\ngoal (2 subgoals):\n 1. \\<And>acc.\n       ipcidr_tuple_to_wordinterval ` set (extract_src_dst_ips [] acc) =\n       ipcidr_tuple_to_wordinterval ` set acc \\<union>\n       set (extract_IPSets_generic0 src []) \\<union>\n       set (extract_IPSets_generic0 dst [])\n 2. \\<And>a rs acc.\n       (\\<And>acc.\n           ipcidr_tuple_to_wordinterval ` set (extract_src_dst_ips rs acc) =\n           ipcidr_tuple_to_wordinterval ` set acc \\<union>\n           set (extract_IPSets_generic0 src rs) \\<union>\n           set (extract_IPSets_generic0 dst rs)) \\<Longrightarrow>\n       ipcidr_tuple_to_wordinterval `\n       set (extract_src_dst_ips (a # rs) acc) =\n       ipcidr_tuple_to_wordinterval ` set acc \\<union>\n       set (extract_IPSets_generic0 src (a # rs)) \\<union>\n       set (extract_IPSets_generic0 dst (a # rs))", "thus ?case"], ["proof (prove)\nusing this:\n  ipcidr_tuple_to_wordinterval ` set (extract_src_dst_ips rs ?acc) =\n  ipcidr_tuple_to_wordinterval ` set ?acc \\<union>\n  set (extract_IPSets_generic0 src rs) \\<union>\n  set (extract_IPSets_generic0 dst rs)\n\ngoal (1 subgoal):\n 1. ipcidr_tuple_to_wordinterval ` set (extract_src_dst_ips (r # rs) acc) =\n    ipcidr_tuple_to_wordinterval ` set acc \\<union>\n    set (extract_IPSets_generic0 src (r # rs)) \\<union>\n    set (extract_IPSets_generic0 dst (r # rs))", "apply(cases r)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>acc.\n                   ipcidr_tuple_to_wordinterval `\n                   set (extract_src_dst_ips rs acc) =\n                   ipcidr_tuple_to_wordinterval ` set acc \\<union>\n                   set (extract_IPSets_generic0 src rs) \\<union>\n                   set (extract_IPSets_generic0 dst rs);\n        r = SimpleRule x1 x2\\<rbrakk>\n       \\<Longrightarrow> ipcidr_tuple_to_wordinterval `\n                         set (extract_src_dst_ips (r # rs) acc) =\n                         ipcidr_tuple_to_wordinterval ` set acc \\<union>\n                         set (extract_IPSets_generic0 src (r # rs)) \\<union>\n                         set (extract_IPSets_generic0 dst (r # rs))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>\\<And>acc.\n                   ipcidr_tuple_to_wordinterval `\n                   set (extract_src_dst_ips rs acc) =\n                   ipcidr_tuple_to_wordinterval ` set acc \\<union>\n                   set (extract_IPSets_generic0 src rs) \\<union>\n                   set (extract_IPSets_generic0 dst rs);\n        r = SimpleRule x1 x2\\<rbrakk>\n       \\<Longrightarrow> insert (ipcidr_tuple_to_wordinterval (src x1))\n                          (insert (ipcidr_tuple_to_wordinterval (dst x1))\n                            (ipcidr_tuple_to_wordinterval ` set acc \\<union>\n                             set (extract_IPSets_generic0 src rs) \\<union>\n                             set (extract_IPSets_generic0 dst rs))) =\n                         insert (ipcidr_tuple_to_wordinterval (dst x1))\n                          (insert (ipcidr_tuple_to_wordinterval (src x1))\n                            (ipcidr_tuple_to_wordinterval ` set acc \\<union>\n                             set (extract_IPSets_generic0 src rs) \\<union>\n                             set (extract_IPSets_generic0 dst rs)))", "by fast"], ["proof (state)\nthis:\n  ipcidr_tuple_to_wordinterval ` set (extract_src_dst_ips (r # rs) acc) =\n  ipcidr_tuple_to_wordinterval ` set acc \\<union>\n  set (extract_IPSets_generic0 src (r # rs)) \\<union>\n  set (extract_IPSets_generic0 dst (r # rs))\n\ngoal (1 subgoal):\n 1. \\<And>acc.\n       ipcidr_tuple_to_wordinterval ` set (extract_src_dst_ips [] acc) =\n       ipcidr_tuple_to_wordinterval ` set acc \\<union>\n       set (extract_IPSets_generic0 src []) \\<union>\n       set (extract_IPSets_generic0 dst [])", "qed(simp)"], ["proof (state)\nthis:\n  ipcidr_tuple_to_wordinterval ` set (extract_src_dst_ips rs acc) =\n  ipcidr_tuple_to_wordinterval ` set acc \\<union>\n  set (extract_IPSets_generic0 src rs) \\<union>\n  set (extract_IPSets_generic0 dst rs)\n\ngoal (1 subgoal):\n 1. set (extract_IPSets rs) =\n    set (extract_IPSets_generic0 src rs) \\<union>\n    set (extract_IPSets_generic0 dst rs)", "}"], ["proof (state)\nthis:\n  ipcidr_tuple_to_wordinterval ` set (extract_src_dst_ips rs ?acc2) =\n  ipcidr_tuple_to_wordinterval ` set ?acc2 \\<union>\n  set (extract_IPSets_generic0 src rs) \\<union>\n  set (extract_IPSets_generic0 dst rs)\n\ngoal (1 subgoal):\n 1. set (extract_IPSets rs) =\n    set (extract_IPSets_generic0 src rs) \\<union>\n    set (extract_IPSets_generic0 dst rs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ipcidr_tuple_to_wordinterval ` set (extract_src_dst_ips rs ?acc2) =\n  ipcidr_tuple_to_wordinterval ` set ?acc2 \\<union>\n  set (extract_IPSets_generic0 src rs) \\<union>\n  set (extract_IPSets_generic0 dst rs)\n\ngoal (1 subgoal):\n 1. set (extract_IPSets rs) =\n    set (extract_IPSets_generic0 src rs) \\<union>\n    set (extract_IPSets_generic0 dst rs)", "unfolding extract_IPSets_def"], ["proof (prove)\nusing this:\n  ipcidr_tuple_to_wordinterval ` set (extract_src_dst_ips rs ?acc2) =\n  ipcidr_tuple_to_wordinterval ` set ?acc2 \\<union>\n  set (extract_IPSets_generic0 src rs) \\<union>\n  set (extract_IPSets_generic0 dst rs)\n\ngoal (1 subgoal):\n 1. set (map ipcidr_tuple_to_wordinterval\n          (mergesort_remdups (extract_src_dst_ips rs []))) =\n    set (extract_IPSets_generic0 src rs) \\<union>\n    set (extract_IPSets_generic0 dst rs)", "by(simp_all add: extract_IPSets_def mergesort_remdups_correct)"], ["proof (state)\nthis:\n  set (extract_IPSets rs) =\n  set (extract_IPSets_generic0 src rs) \\<union>\n  set (extract_IPSets_generic0 dst rs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \"(a::nat) div 2 + a mod 2 \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a div 2 + a mod 2 \\<le> a", "by fastforce"], ["", "lemma merge_length: \"length (merge l1 l2) \\<le> length l1 + length l2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (merge l1 l2) \\<le> length l1 + length l2", "by(induction l1 l2 rule: merge.induct) auto"], ["", "lemma merge_list_length: \"length (merge_list as ls) \\<le> length (concat (as @ ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (merge_list as ls) \\<le> length (concat (as @ ls))", "proof(induction as ls rule: merge_list.induct)"], ["proof (state)\ngoal (5 subgoals):\n 1. length (merge_list [] []) \\<le> length (concat ([] @ []))\n 2. \\<And>l. length (merge_list [] [l]) \\<le> length (concat ([] @ [l]))\n 3. \\<And>la acc2.\n       length (merge_list [] (la # acc2))\n       \\<le> length (concat ([] @ la # acc2)) \\<Longrightarrow>\n       length (merge_list (la # acc2) [])\n       \\<le> length (concat ((la # acc2) @ []))\n 4. \\<And>la acc2 l.\n       length (merge_list [] (l # la # acc2))\n       \\<le> length (concat ([] @ l # la # acc2)) \\<Longrightarrow>\n       length (merge_list (la # acc2) [l])\n       \\<le> length (concat ((la # acc2) @ [l]))\n 5. \\<And>acc2 l1 l2 ls.\n       length (merge_list (merge l1 l2 # acc2) ls)\n       \\<le> length (concat ((merge l1 l2 # acc2) @ ls)) \\<Longrightarrow>\n       length (merge_list acc2 (l1 # l2 # ls))\n       \\<le> length (concat (acc2 @ l1 # l2 # ls))", "case (5 l1 l2 acc2 ls)"], ["proof (state)\nthis:\n  length (merge_list (merge l2 acc2 # l1) ls)\n  \\<le> length (concat ((merge l2 acc2 # l1) @ ls))\n\ngoal (5 subgoals):\n 1. length (merge_list [] []) \\<le> length (concat ([] @ []))\n 2. \\<And>l. length (merge_list [] [l]) \\<le> length (concat ([] @ [l]))\n 3. \\<And>la acc2.\n       length (merge_list [] (la # acc2))\n       \\<le> length (concat ([] @ la # acc2)) \\<Longrightarrow>\n       length (merge_list (la # acc2) [])\n       \\<le> length (concat ((la # acc2) @ []))\n 4. \\<And>la acc2 l.\n       length (merge_list [] (l # la # acc2))\n       \\<le> length (concat ([] @ l # la # acc2)) \\<Longrightarrow>\n       length (merge_list (la # acc2) [l])\n       \\<le> length (concat ((la # acc2) @ [l]))\n 5. \\<And>acc2 l1 l2 ls.\n       length (merge_list (merge l1 l2 # acc2) ls)\n       \\<le> length (concat ((merge l1 l2 # acc2) @ ls)) \\<Longrightarrow>\n       length (merge_list acc2 (l1 # l2 # ls))\n       \\<le> length (concat (acc2 @ l1 # l2 # ls))", "have \"length (merge l2 acc2) \\<le> length l2 + length acc2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (merge l2 acc2) \\<le> length l2 + length acc2", "using merge_length"], ["proof (prove)\nusing this:\n  length (merge ?l1.0 ?l2.0) \\<le> length ?l1.0 + length ?l2.0\n\ngoal (1 subgoal):\n 1. length (merge l2 acc2) \\<le> length l2 + length acc2", "by blast"], ["proof (state)\nthis:\n  length (merge l2 acc2) \\<le> length l2 + length acc2\n\ngoal (5 subgoals):\n 1. length (merge_list [] []) \\<le> length (concat ([] @ []))\n 2. \\<And>l. length (merge_list [] [l]) \\<le> length (concat ([] @ [l]))\n 3. \\<And>la acc2.\n       length (merge_list [] (la # acc2))\n       \\<le> length (concat ([] @ la # acc2)) \\<Longrightarrow>\n       length (merge_list (la # acc2) [])\n       \\<le> length (concat ((la # acc2) @ []))\n 4. \\<And>la acc2 l.\n       length (merge_list [] (l # la # acc2))\n       \\<le> length (concat ([] @ l # la # acc2)) \\<Longrightarrow>\n       length (merge_list (la # acc2) [l])\n       \\<le> length (concat ((la # acc2) @ [l]))\n 5. \\<And>acc2 l1 l2 ls.\n       length (merge_list (merge l1 l2 # acc2) ls)\n       \\<le> length (concat ((merge l1 l2 # acc2) @ ls)) \\<Longrightarrow>\n       length (merge_list acc2 (l1 # l2 # ls))\n       \\<le> length (concat (acc2 @ l1 # l2 # ls))", "with 5"], ["proof (chain)\npicking this:\n  length (merge_list (merge l2 acc2 # l1) ls)\n  \\<le> length (concat ((merge l2 acc2 # l1) @ ls))\n  length (merge l2 acc2) \\<le> length l2 + length acc2", "show ?case"], ["proof (prove)\nusing this:\n  length (merge_list (merge l2 acc2 # l1) ls)\n  \\<le> length (concat ((merge l2 acc2 # l1) @ ls))\n  length (merge l2 acc2) \\<le> length l2 + length acc2\n\ngoal (1 subgoal):\n 1. length (merge_list l1 (l2 # acc2 # ls))\n    \\<le> length (concat (l1 @ l2 # acc2 # ls))", "by simp"], ["proof (state)\nthis:\n  length (merge_list l1 (l2 # acc2 # ls))\n  \\<le> length (concat (l1 @ l2 # acc2 # ls))\n\ngoal (4 subgoals):\n 1. length (merge_list [] []) \\<le> length (concat ([] @ []))\n 2. \\<And>l. length (merge_list [] [l]) \\<le> length (concat ([] @ [l]))\n 3. \\<And>la acc2.\n       length (merge_list [] (la # acc2))\n       \\<le> length (concat ([] @ la # acc2)) \\<Longrightarrow>\n       length (merge_list (la # acc2) [])\n       \\<le> length (concat ((la # acc2) @ []))\n 4. \\<And>la acc2 l.\n       length (merge_list [] (l # la # acc2))\n       \\<le> length (concat ([] @ l # la # acc2)) \\<Longrightarrow>\n       length (merge_list (la # acc2) [l])\n       \\<le> length (concat ((la # acc2) @ [l]))", "qed(simp_all)"], ["", "lemma mergesort_remdups_length: \"length (mergesort_remdups as) \\<le> length as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (mergesort_remdups as) \\<le> length as", "unfolding mergesort_remdups_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (merge_list [] (map (\\<lambda>x. [x]) as)) \\<le> length as", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (merge_list [] (map (\\<lambda>x. [x]) as)) \\<le> length as", "have \"concat ([] @ (map (\\<lambda>x. [x]) as)) = as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concat ([] @ map (\\<lambda>x. [x]) as) = as", "by simp"], ["proof (state)\nthis:\n  concat ([] @ map (\\<lambda>x. [x]) as) = as\n\ngoal (1 subgoal):\n 1. length (merge_list [] (map (\\<lambda>x. [x]) as)) \\<le> length as", "with merge_list_length"], ["proof (chain)\npicking this:\n  length (merge_list ?as ?ls) \\<le> length (concat (?as @ ?ls))\n  concat ([] @ map (\\<lambda>x. [x]) as) = as", "show \"length (merge_list [] (map (\\<lambda>x. [x]) as)) \\<le> length as\""], ["proof (prove)\nusing this:\n  length (merge_list ?as ?ls) \\<le> length (concat (?as @ ?ls))\n  concat ([] @ map (\\<lambda>x. [x]) as) = as\n\ngoal (1 subgoal):\n 1. length (merge_list [] (map (\\<lambda>x. [x]) as)) \\<le> length as", "by metis"], ["proof (state)\nthis:\n  length (merge_list [] (map (\\<lambda>x. [x]) as)) \\<le> length as\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma extract_IPSets_length: \"length (extract_IPSets rs) \\<le> 2 * length rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (extract_IPSets rs) \\<le> 2 * length rs", "apply(simp add: extract_IPSets_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (mergesort_remdups (extract_src_dst_ips rs []))\n    \\<le> 2 * length rs", "using extract_src_dst_ips_length mergesort_remdups_length"], ["proof (prove)\nusing this:\n  length (extract_src_dst_ips ?rs ?acc) = 2 * length ?rs + length ?acc\n  length (mergesort_remdups ?as) \\<le> length ?as\n\ngoal (1 subgoal):\n 1. length (mergesort_remdups (extract_src_dst_ips rs []))\n    \\<le> 2 * length rs", "by (metis add.right_neutral list.size(3))"], ["", "(*\nexport_code extract_IPSets in SML\nwhy you no work?\n*)"], ["", "lemma extract_equi0:\n  \"set (map wordinterval_to_set (extract_IPSets_generic0 sel rs)) =\n    (\\<lambda>(base,len). ipset_from_cidr base len) ` sel ` match_sel ` set rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (map wordinterval_to_set (extract_IPSets_generic0 sel rs)) =\n    (\\<lambda>(base, len). ipset_from_cidr base len) `\n    sel ` match_sel ` set rs", "proof(induction rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. set (map wordinterval_to_set (extract_IPSets_generic0 sel [])) =\n    (\\<lambda>a.\n        case a of (base, len) \\<Rightarrow> ipset_from_cidr base len) `\n    sel ` match_sel ` set []\n 2. \\<And>a rs.\n       set (map wordinterval_to_set (extract_IPSets_generic0 sel rs)) =\n       (\\<lambda>a.\n           case a of (base, len) \\<Rightarrow> ipset_from_cidr base len) `\n       sel ` match_sel ` set rs \\<Longrightarrow>\n       set (map wordinterval_to_set\n             (extract_IPSets_generic0 sel (a # rs))) =\n       (\\<lambda>a.\n           case a of (base, len) \\<Rightarrow> ipset_from_cidr base len) `\n       sel ` match_sel ` set (a # rs)", "case (Cons r rs)"], ["proof (state)\nthis:\n  set (map wordinterval_to_set (extract_IPSets_generic0 sel rs)) =\n  (\\<lambda>a.\n      case a of (base, len) \\<Rightarrow> ipset_from_cidr base len) `\n  sel ` match_sel ` set rs\n\ngoal (2 subgoals):\n 1. set (map wordinterval_to_set (extract_IPSets_generic0 sel [])) =\n    (\\<lambda>a.\n        case a of (base, len) \\<Rightarrow> ipset_from_cidr base len) `\n    sel ` match_sel ` set []\n 2. \\<And>a rs.\n       set (map wordinterval_to_set (extract_IPSets_generic0 sel rs)) =\n       (\\<lambda>a.\n           case a of (base, len) \\<Rightarrow> ipset_from_cidr base len) `\n       sel ` match_sel ` set rs \\<Longrightarrow>\n       set (map wordinterval_to_set\n             (extract_IPSets_generic0 sel (a # rs))) =\n       (\\<lambda>a.\n           case a of (base, len) \\<Rightarrow> ipset_from_cidr base len) `\n       sel ` match_sel ` set (a # rs)", "thus ?case"], ["proof (prove)\nusing this:\n  set (map wordinterval_to_set (extract_IPSets_generic0 sel rs)) =\n  (\\<lambda>a.\n      case a of (base, len) \\<Rightarrow> ipset_from_cidr base len) `\n  sel ` match_sel ` set rs\n\ngoal (1 subgoal):\n 1. set (map wordinterval_to_set (extract_IPSets_generic0 sel (r # rs))) =\n    (\\<lambda>a.\n        case a of (base, len) \\<Rightarrow> ipset_from_cidr base len) `\n    sel ` match_sel ` set (r # rs)", "apply(cases r, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>wordinterval_to_set ` set (extract_IPSets_generic0 sel rs) =\n                (\\<lambda>a.\n                    case a of\n                    (base, len) \\<Rightarrow> ipset_from_cidr base len) `\n                sel ` match_sel ` set rs;\n        r = SimpleRule x1 x2\\<rbrakk>\n       \\<Longrightarrow> insert\n                          (wordinterval_to_set\n                            (ipcidr_tuple_to_wordinterval (sel x1)))\n                          ((\\<lambda>x.\n                               case x of\n                               (x, xa) \\<Rightarrow> ipset_from_cidr x xa) `\n                           sel ` match_sel ` set rs) =\n                         insert\n                          (case sel x1 of\n                           (x, xa) \\<Rightarrow> ipset_from_cidr x xa)\n                          ((\\<lambda>x.\n                               case x of\n                               (x, xa) \\<Rightarrow> ipset_from_cidr x xa) `\n                           sel ` match_sel ` set rs)", "using wordinterval_to_set_ipcidr_tuple_to_wordinterval"], ["proof (prove)\nusing this:\n  wordinterval_to_set (ipcidr_tuple_to_wordinterval (?b, ?m)) =\n  ipset_from_cidr ?b ?m\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>wordinterval_to_set ` set (extract_IPSets_generic0 sel rs) =\n                (\\<lambda>a.\n                    case a of\n                    (base, len) \\<Rightarrow> ipset_from_cidr base len) `\n                sel ` match_sel ` set rs;\n        r = SimpleRule x1 x2\\<rbrakk>\n       \\<Longrightarrow> insert\n                          (wordinterval_to_set\n                            (ipcidr_tuple_to_wordinterval (sel x1)))\n                          ((\\<lambda>x.\n                               case x of\n                               (x, xa) \\<Rightarrow> ipset_from_cidr x xa) `\n                           sel ` match_sel ` set rs) =\n                         insert\n                          (case sel x1 of\n                           (x, xa) \\<Rightarrow> ipset_from_cidr x xa)\n                          ((\\<lambda>x.\n                               case x of\n                               (x, xa) \\<Rightarrow> ipset_from_cidr x xa) `\n                           sel ` match_sel ` set rs)", "by fastforce"], ["proof (state)\nthis:\n  set (map wordinterval_to_set (extract_IPSets_generic0 sel (r # rs))) =\n  (\\<lambda>a.\n      case a of (base, len) \\<Rightarrow> ipset_from_cidr base len) `\n  sel ` match_sel ` set (r # rs)\n\ngoal (1 subgoal):\n 1. set (map wordinterval_to_set (extract_IPSets_generic0 sel [])) =\n    (\\<lambda>a.\n        case a of (base, len) \\<Rightarrow> ipset_from_cidr base len) `\n    sel ` match_sel ` set []", "qed(simp)"], ["", "lemma src_ipPart_motivation:\nfixes   rs\ndefines \"X \\<equiv> (\\<lambda>(base,len). ipset_from_cidr base len) ` src ` match_sel ` set rs\"\nassumes \"\\<forall>A \\<in> X. B \\<subseteq> A \\<or> B \\<inter> A = {}\" and \"s1 \\<in> B\" and \"s2 \\<in> B\"\nshows \"simple_fw rs (p\\<lparr>p_src:=s1\\<rparr>) = simple_fw rs (p\\<lparr>p_src:=s2\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)", "have \"\\<forall>A \\<in> (\\<lambda>(base,len). ipset_from_cidr base len) ` src ` match_sel ` set rs. B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>(\\<lambda>(base, len). ipset_from_cidr base len) `\n                   src ` match_sel ` set rs.\n       B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n    simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)", "proof(induction rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                   src ` match_sel ` set [].\n       B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n    simple_fw [] (p\\<lparr>p_src := s1\\<rparr>) =\n    simple_fw [] (p\\<lparr>p_src := s2\\<rparr>)\n 2. \\<And>a rs.\n       \\<lbrakk>\\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                               src ` match_sel ` set rs.\n                   B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n                simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_src := s2\\<rparr>);\n        \\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                       src ` match_sel ` set (a # rs).\n           B \\<subseteq> A \\<or> B \\<inter> A = {}\\<rbrakk>\n       \\<Longrightarrow> simple_fw (a # rs) (p\\<lparr>p_src := s1\\<rparr>) =\n                         simple_fw (a # rs) (p\\<lparr>p_src := s2\\<rparr>)", "case Nil"], ["proof (state)\nthis:\n  \\<forall>A\\<in>(\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> ipset_from_cidr a b) `\n                 src ` match_sel ` set [].\n     B \\<subseteq> A \\<or> B \\<inter> A = {}\n\ngoal (2 subgoals):\n 1. \\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                   src ` match_sel ` set [].\n       B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n    simple_fw [] (p\\<lparr>p_src := s1\\<rparr>) =\n    simple_fw [] (p\\<lparr>p_src := s2\\<rparr>)\n 2. \\<And>a rs.\n       \\<lbrakk>\\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                               src ` match_sel ` set rs.\n                   B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n                simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_src := s2\\<rparr>);\n        \\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                       src ` match_sel ` set (a # rs).\n           B \\<subseteq> A \\<or> B \\<inter> A = {}\\<rbrakk>\n       \\<Longrightarrow> simple_fw (a # rs) (p\\<lparr>p_src := s1\\<rparr>) =\n                         simple_fw (a # rs) (p\\<lparr>p_src := s2\\<rparr>)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>(\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> ipset_from_cidr a b) `\n                 src ` match_sel ` set [].\n     B \\<subseteq> A \\<or> B \\<inter> A = {}\n\ngoal (1 subgoal):\n 1. simple_fw [] (p\\<lparr>p_src := s1\\<rparr>) =\n    simple_fw [] (p\\<lparr>p_src := s2\\<rparr>)", "by simp"], ["proof (state)\nthis:\n  simple_fw [] (p\\<lparr>p_src := s1\\<rparr>) =\n  simple_fw [] (p\\<lparr>p_src := s2\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                               src ` match_sel ` set rs.\n                   B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n                simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_src := s2\\<rparr>);\n        \\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                       src ` match_sel ` set (a # rs).\n           B \\<subseteq> A \\<or> B \\<inter> A = {}\\<rbrakk>\n       \\<Longrightarrow> simple_fw (a # rs) (p\\<lparr>p_src := s1\\<rparr>) =\n                         simple_fw (a # rs) (p\\<lparr>p_src := s2\\<rparr>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                               src ` match_sel ` set rs.\n                   B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n                simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_src := s2\\<rparr>);\n        \\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                       src ` match_sel ` set (a # rs).\n           B \\<subseteq> A \\<or> B \\<inter> A = {}\\<rbrakk>\n       \\<Longrightarrow> simple_fw (a # rs) (p\\<lparr>p_src := s1\\<rparr>) =\n                         simple_fw (a # rs) (p\\<lparr>p_src := s2\\<rparr>)", "case (Cons r rs)"], ["proof (state)\nthis:\n  \\<forall>A\\<in>(\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> ipset_from_cidr a b) `\n                 src ` match_sel ` set rs.\n     B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n  simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n  simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)\n  \\<forall>A\\<in>(\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> ipset_from_cidr a b) `\n                 src ` match_sel ` set (r # rs).\n     B \\<subseteq> A \\<or> B \\<inter> A = {}\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                               src ` match_sel ` set rs.\n                   B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n                simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_src := s2\\<rparr>);\n        \\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                       src ` match_sel ` set (a # rs).\n           B \\<subseteq> A \\<or> B \\<inter> A = {}\\<rbrakk>\n       \\<Longrightarrow> simple_fw (a # rs) (p\\<lparr>p_src := s1\\<rparr>) =\n                         simple_fw (a # rs) (p\\<lparr>p_src := s2\\<rparr>)", "{"], ["proof (state)\nthis:\n  \\<forall>A\\<in>(\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> ipset_from_cidr a b) `\n                 src ` match_sel ` set rs.\n     B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n  simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n  simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)\n  \\<forall>A\\<in>(\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> ipset_from_cidr a b) `\n                 src ` match_sel ` set (r # rs).\n     B \\<subseteq> A \\<or> B \\<inter> A = {}\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                               src ` match_sel ` set rs.\n                   B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n                simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_src := s2\\<rparr>);\n        \\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                       src ` match_sel ` set (a # rs).\n           B \\<subseteq> A \\<or> B \\<inter> A = {}\\<rbrakk>\n       \\<Longrightarrow> simple_fw (a # rs) (p\\<lparr>p_src := s1\\<rparr>) =\n                         simple_fw (a # rs) (p\\<lparr>p_src := s2\\<rparr>)", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                               src ` match_sel ` set rs.\n                   B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n                simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_src := s2\\<rparr>);\n        \\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                       src ` match_sel ` set (a # rs).\n           B \\<subseteq> A \\<or> B \\<inter> A = {}\\<rbrakk>\n       \\<Longrightarrow> simple_fw (a # rs) (p\\<lparr>p_src := s1\\<rparr>) =\n                         simple_fw (a # rs) (p\\<lparr>p_src := s2\\<rparr>)", "from \\<open>s1 \\<in> B\\<close> \\<open>s2 \\<in> B\\<close>"], ["proof (chain)\npicking this:\n  s1 \\<in> B\n  s2 \\<in> B", "have \n        \"B \\<subseteq> (case src m of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or> B \\<inter> (case src m of (x, xa) \n                      \\<Rightarrow> ipset_from_cidr x xa) = {} \\<Longrightarrow>\n             simple_matches m (p\\<lparr>p_src := s1\\<rparr>) \\<longleftrightarrow> simple_matches m (p\\<lparr>p_src := s2\\<rparr>)\""], ["proof (prove)\nusing this:\n  s1 \\<in> B\n  s2 \\<in> B\n\ngoal (1 subgoal):\n 1. B \\<subseteq> (case src m of\n                   (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n    B \\<inter> (case src m of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n    {} \\<Longrightarrow>\n    simple_matches m (p\\<lparr>p_src := s1\\<rparr>) =\n    simple_matches m (p\\<lparr>p_src := s2\\<rparr>)", "apply(cases m)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>iiface oiface srca dst proto sports dports.\n       \\<lbrakk>B \\<subseteq> (case src m of\n                               (x, xa) \\<Rightarrow>\n                                 ipset_from_cidr x xa) \\<or>\n                B \\<inter>\n                (case src m of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n                {};\n        s1 \\<in> B; s2 \\<in> B;\n        m =\n        \\<lparr>iiface = iiface, oiface = oiface, src = srca, dst = dst,\n           proto = proto, sports = sports, dports = dports\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> simple_matches m (p\\<lparr>p_src := s1\\<rparr>) =\n                         simple_matches m (p\\<lparr>p_src := s2\\<rparr>)", "apply(rename_tac iiface oiface srca dst proto sports dports)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>iiface oiface srca dst proto sports dports.\n       \\<lbrakk>B \\<subseteq> (case src m of\n                               (x, xa) \\<Rightarrow>\n                                 ipset_from_cidr x xa) \\<or>\n                B \\<inter>\n                (case src m of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n                {};\n        s1 \\<in> B; s2 \\<in> B;\n        m =\n        \\<lparr>iiface = iiface, oiface = oiface, src = srca, dst = dst,\n           proto = proto, sports = sports, dports = dports\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> simple_matches m (p\\<lparr>p_src := s1\\<rparr>) =\n                         simple_matches m (p\\<lparr>p_src := s2\\<rparr>)", "apply(case_tac srca)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>iiface oiface srca dst proto sports dports a b.\n       \\<lbrakk>B \\<subseteq> (case src m of\n                               (x, xa) \\<Rightarrow>\n                                 ipset_from_cidr x xa) \\<or>\n                B \\<inter>\n                (case src m of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n                {};\n        s1 \\<in> B; s2 \\<in> B;\n        m =\n        \\<lparr>iiface = iiface, oiface = oiface, src = srca, dst = dst,\n           proto = proto, sports = sports, dports = dports\\<rparr>;\n        srca = (a, b)\\<rbrakk>\n       \\<Longrightarrow> simple_matches m (p\\<lparr>p_src := s1\\<rparr>) =\n                         simple_matches m (p\\<lparr>p_src := s2\\<rparr>)", "apply(simp add: simple_matches.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>iiface oiface srca dst proto sports dports a b.\n       \\<lbrakk>B \\<subseteq> ipset_from_cidr a b \\<or>\n                B \\<inter> ipset_from_cidr a b = {};\n        s1 \\<in> B; s2 \\<in> B;\n        m =\n        \\<lparr>iiface = iiface, oiface = oiface, src = (a, b), dst = dst,\n           proto = proto, sports = sports, dports = dports\\<rparr>;\n        srca = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (match_iface iiface (p_iiface p) \\<and>\n                          match_iface oiface (p_oiface p) \\<and>\n                          s1 \\<in> ipset_from_cidr a b \\<and>\n                          simple_match_ip dst (p_dst p) \\<and>\n                          match_proto proto (p_proto p) \\<and>\n                          simple_match_port sports (p_sport p) \\<and>\n                          simple_match_port dports (p_dport p)) =\n                         (match_iface iiface (p_iiface p) \\<and>\n                          match_iface oiface (p_oiface p) \\<and>\n                          s2 \\<in> ipset_from_cidr a b \\<and>\n                          simple_match_ip dst (p_dst p) \\<and>\n                          match_proto proto (p_proto p) \\<and>\n                          simple_match_port sports (p_sport p) \\<and>\n                          simple_match_port dports (p_dport p))", "by blast"], ["proof (state)\nthis:\n  B \\<subseteq> (case src m of\n                 (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n  B \\<inter> (case src m of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n  {} \\<Longrightarrow>\n  simple_matches m (p\\<lparr>p_src := s1\\<rparr>) =\n  simple_matches m (p\\<lparr>p_src := s2\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                               src ` match_sel ` set rs.\n                   B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n                simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_src := s2\\<rparr>);\n        \\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                       src ` match_sel ` set (a # rs).\n           B \\<subseteq> A \\<or> B \\<inter> A = {}\\<rbrakk>\n       \\<Longrightarrow> simple_fw (a # rs) (p\\<lparr>p_src := s1\\<rparr>) =\n                         simple_fw (a # rs) (p\\<lparr>p_src := s2\\<rparr>)", "}"], ["proof (state)\nthis:\n  B \\<subseteq> (case src ?m2 of\n                 (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n  B \\<inter> (case src ?m2 of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n  {} \\<Longrightarrow>\n  simple_matches ?m2 (p\\<lparr>p_src := s1\\<rparr>) =\n  simple_matches ?m2 (p\\<lparr>p_src := s2\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                               src ` match_sel ` set rs.\n                   B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n                simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_src := s2\\<rparr>);\n        \\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                       src ` match_sel ` set (a # rs).\n           B \\<subseteq> A \\<or> B \\<inter> A = {}\\<rbrakk>\n       \\<Longrightarrow> simple_fw (a # rs) (p\\<lparr>p_src := s1\\<rparr>) =\n                         simple_fw (a # rs) (p\\<lparr>p_src := s2\\<rparr>)", "note helper=this"], ["proof (state)\nthis:\n  B \\<subseteq> (case src ?m2 of\n                 (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n  B \\<inter> (case src ?m2 of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n  {} \\<Longrightarrow>\n  simple_matches ?m2 (p\\<lparr>p_src := s1\\<rparr>) =\n  simple_matches ?m2 (p\\<lparr>p_src := s2\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                               src ` match_sel ` set rs.\n                   B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n                simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_src := s2\\<rparr>);\n        \\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                       src ` match_sel ` set (a # rs).\n           B \\<subseteq> A \\<or> B \\<inter> A = {}\\<rbrakk>\n       \\<Longrightarrow> simple_fw (a # rs) (p\\<lparr>p_src := s1\\<rparr>) =\n                         simple_fw (a # rs) (p\\<lparr>p_src := s2\\<rparr>)", "from Cons[simplified]"], ["proof (chain)\npicking this:\n  \\<forall>A\\<in>set rs.\n     B \\<subseteq> (case src (match_sel A) of\n                    (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n     B \\<inter>\n     (case src (match_sel A) of\n      (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n     {} \\<Longrightarrow>\n  simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n  simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)\n  (B \\<subseteq> (case src (match_sel r) of\n                  (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n   B \\<inter>\n   (case src (match_sel r) of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n   {}) \\<and>\n  (\\<forall>A\\<in>set rs.\n      B \\<subseteq> (case src (match_sel A) of\n                     (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n      B \\<inter>\n      (case src (match_sel A) of\n       (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n      {})", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>set rs.\n     B \\<subseteq> (case src (match_sel A) of\n                    (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n     B \\<inter>\n     (case src (match_sel A) of\n      (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n     {} \\<Longrightarrow>\n  simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n  simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)\n  (B \\<subseteq> (case src (match_sel r) of\n                  (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n   B \\<inter>\n   (case src (match_sel r) of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n   {}) \\<and>\n  (\\<forall>A\\<in>set rs.\n      B \\<subseteq> (case src (match_sel A) of\n                     (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n      B \\<inter>\n      (case src (match_sel A) of\n       (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n      {})\n\ngoal (1 subgoal):\n 1. simple_fw (r # rs) (p\\<lparr>p_src := s1\\<rparr>) =\n    simple_fw (r # rs) (p\\<lparr>p_src := s2\\<rparr>)", "apply(cases r, rename_tac m a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>\\<forall>A\\<in>set rs.\n                   B \\<subseteq> (case src (match_sel A) of\n                                  (x, xa) \\<Rightarrow>\n                                    ipset_from_cidr x xa) \\<or>\n                   B \\<inter>\n                   (case src (match_sel A) of\n                    (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n                   {} \\<Longrightarrow>\n                simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_src := s2\\<rparr>);\n        (B \\<subseteq> (case src (match_sel r) of\n                        (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n         B \\<inter>\n         (case src (match_sel r) of\n          (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n         {}) \\<and>\n        (\\<forall>A\\<in>set rs.\n            B \\<subseteq> (case src (match_sel A) of\n                           (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n            B \\<inter>\n            (case src (match_sel A) of\n             (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n            {});\n        r = SimpleRule m a;\n        \\<forall>A\\<in>set rs.\n           B \\<subseteq> (case src (match_sel A) of\n                          (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n           B \\<inter>\n           (case src (match_sel A) of\n            (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n           {} \\<Longrightarrow>\n        simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n        simple_fw rs (p\\<lparr>p_src := s2\\<rparr>);\n        (B \\<subseteq> (case src (match_sel r) of\n                        (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n         B \\<inter>\n         (case src (match_sel r) of\n          (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n         {}) \\<and>\n        (\\<forall>A\\<in>set rs.\n            B \\<subseteq> (case src (match_sel A) of\n                           (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n            B \\<inter>\n            (case src (match_sel A) of\n             (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n            {})\\<rbrakk>\n       \\<Longrightarrow> simple_fw (r # rs) (p\\<lparr>p_src := s1\\<rparr>) =\n                         simple_fw (r # rs) (p\\<lparr>p_src := s2\\<rparr>)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>B \\<subseteq> (case src m of\n                               (x, xa) \\<Rightarrow>\n                                 ipset_from_cidr x xa) \\<or>\n                B \\<inter>\n                (case src m of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n                {};\n        r = SimpleRule m a;\n        simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n        simple_fw rs (p\\<lparr>p_src := s2\\<rparr>);\n        \\<forall>A\\<in>set rs.\n           B \\<subseteq> (case src (match_sel A) of\n                          (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n           B \\<inter>\n           (case src (match_sel A) of\n            (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n           {}\\<rbrakk>\n       \\<Longrightarrow> simple_fw (SimpleRule m a # rs)\n                          (p\\<lparr>p_src := s1\\<rparr>) =\n                         simple_fw (SimpleRule m a # rs)\n                          (p\\<lparr>p_src := s2\\<rparr>)", "apply(case_tac a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>B \\<subseteq> (case src m of\n                               (x, xa) \\<Rightarrow>\n                                 ipset_from_cidr x xa) \\<or>\n                B \\<inter>\n                (case src m of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n                {};\n        r = SimpleRule m a;\n        simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n        simple_fw rs (p\\<lparr>p_src := s2\\<rparr>);\n        \\<forall>A\\<in>set rs.\n           B \\<subseteq> (case src (match_sel A) of\n                          (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n           B \\<inter>\n           (case src (match_sel A) of\n            (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n           {};\n        a = Accept\\<rbrakk>\n       \\<Longrightarrow> simple_fw (SimpleRule m a # rs)\n                          (p\\<lparr>p_src := s1\\<rparr>) =\n                         simple_fw (SimpleRule m a # rs)\n                          (p\\<lparr>p_src := s2\\<rparr>)\n 2. \\<And>m a.\n       \\<lbrakk>B \\<subseteq> (case src m of\n                               (x, xa) \\<Rightarrow>\n                                 ipset_from_cidr x xa) \\<or>\n                B \\<inter>\n                (case src m of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n                {};\n        r = SimpleRule m a;\n        simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n        simple_fw rs (p\\<lparr>p_src := s2\\<rparr>);\n        \\<forall>A\\<in>set rs.\n           B \\<subseteq> (case src (match_sel A) of\n                          (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n           B \\<inter>\n           (case src (match_sel A) of\n            (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n           {};\n        a = Drop\\<rbrakk>\n       \\<Longrightarrow> simple_fw (SimpleRule m a # rs)\n                          (p\\<lparr>p_src := s1\\<rparr>) =\n                         simple_fw (SimpleRule m a # rs)\n                          (p\\<lparr>p_src := s2\\<rparr>)", "using helper"], ["proof (prove)\nusing this:\n  B \\<subseteq> (case src ?m2 of\n                 (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n  B \\<inter> (case src ?m2 of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n  {} \\<Longrightarrow>\n  simple_matches ?m2 (p\\<lparr>p_src := s1\\<rparr>) =\n  simple_matches ?m2 (p\\<lparr>p_src := s2\\<rparr>)\n\ngoal (2 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>B \\<subseteq> (case src m of\n                               (x, xa) \\<Rightarrow>\n                                 ipset_from_cidr x xa) \\<or>\n                B \\<inter>\n                (case src m of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n                {};\n        r = SimpleRule m a;\n        simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n        simple_fw rs (p\\<lparr>p_src := s2\\<rparr>);\n        \\<forall>A\\<in>set rs.\n           B \\<subseteq> (case src (match_sel A) of\n                          (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n           B \\<inter>\n           (case src (match_sel A) of\n            (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n           {};\n        a = Accept\\<rbrakk>\n       \\<Longrightarrow> simple_fw (SimpleRule m a # rs)\n                          (p\\<lparr>p_src := s1\\<rparr>) =\n                         simple_fw (SimpleRule m a # rs)\n                          (p\\<lparr>p_src := s2\\<rparr>)\n 2. \\<And>m a.\n       \\<lbrakk>B \\<subseteq> (case src m of\n                               (x, xa) \\<Rightarrow>\n                                 ipset_from_cidr x xa) \\<or>\n                B \\<inter>\n                (case src m of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n                {};\n        r = SimpleRule m a;\n        simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n        simple_fw rs (p\\<lparr>p_src := s2\\<rparr>);\n        \\<forall>A\\<in>set rs.\n           B \\<subseteq> (case src (match_sel A) of\n                          (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n           B \\<inter>\n           (case src (match_sel A) of\n            (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n           {};\n        a = Drop\\<rbrakk>\n       \\<Longrightarrow> simple_fw (SimpleRule m a # rs)\n                          (p\\<lparr>p_src := s1\\<rparr>) =\n                         simple_fw (SimpleRule m a # rs)\n                          (p\\<lparr>p_src := s2\\<rparr>)", "apply force+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  simple_fw (r # rs) (p\\<lparr>p_src := s1\\<rparr>) =\n  simple_fw (r # rs) (p\\<lparr>p_src := s2\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>A\\<in>(\\<lambda>(base, len). ipset_from_cidr base len) `\n                 src ` match_sel ` set rs.\n     B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n  simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n  simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)\n\ngoal (1 subgoal):\n 1. simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)", "with assms"], ["proof (chain)\npicking this:\n  X \\<equiv>\n  (\\<lambda>(base, len). ipset_from_cidr base len) `\n  src ` match_sel ` set rs\n  \\<forall>A\\<in>X. B \\<subseteq> A \\<or> B \\<inter> A = {}\n  s1 \\<in> B\n  s2 \\<in> B\n  \\<forall>A\\<in>(\\<lambda>(base, len). ipset_from_cidr base len) `\n                 src ` match_sel ` set rs.\n     B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n  simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n  simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)", "show ?thesis"], ["proof (prove)\nusing this:\n  X \\<equiv>\n  (\\<lambda>(base, len). ipset_from_cidr base len) `\n  src ` match_sel ` set rs\n  \\<forall>A\\<in>X. B \\<subseteq> A \\<or> B \\<inter> A = {}\n  s1 \\<in> B\n  s2 \\<in> B\n  \\<forall>A\\<in>(\\<lambda>(base, len). ipset_from_cidr base len) `\n                 src ` match_sel ` set rs.\n     B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n  simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n  simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)\n\ngoal (1 subgoal):\n 1. simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)", "by blast"], ["proof (state)\nthis:\n  simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n  simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma src_ipPart:\n  assumes \"ipPartition (set (map wordinterval_to_set (extract_IPSets_generic0 src rs))) A\"\n          \"B \\<in> A\" \"s1 \\<in> B\" \"s2 \\<in> B\"\n  shows \"simple_fw rs (p\\<lparr>p_src:=s1\\<rparr>) = simple_fw rs (p\\<lparr>p_src:=s2\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)", "from src_ipPart_motivation[OF _ assms(3) assms(4)]"], ["proof (chain)\npicking this:\n  \\<forall>A\\<in>(\\<lambda>(base, len). ipset_from_cidr base len) `\n                 src ` match_sel ` set ?rs.\n     B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n  simple_fw ?rs (?p\\<lparr>p_src := s1\\<rparr>) =\n  simple_fw ?rs (?p\\<lparr>p_src := s2\\<rparr>)", "have \"\\<forall>A \\<in> (\\<lambda>(base,len). ipset_from_cidr base len) ` src ` match_sel ` set rs. B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n      simple_fw rs (p\\<lparr>p_src:=s1\\<rparr>) = simple_fw rs (p\\<lparr>p_src:=s2\\<rparr>)\""], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>(\\<lambda>(base, len). ipset_from_cidr base len) `\n                 src ` match_sel ` set ?rs.\n     B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n  simple_fw ?rs (?p\\<lparr>p_src := s1\\<rparr>) =\n  simple_fw ?rs (?p\\<lparr>p_src := s2\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>(\\<lambda>(base, len). ipset_from_cidr base len) `\n                   src ` match_sel ` set rs.\n       B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n    simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)", "by fast"], ["proof (state)\nthis:\n  \\<forall>A\\<in>(\\<lambda>(base, len). ipset_from_cidr base len) `\n                 src ` match_sel ` set rs.\n     B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n  simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n  simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)\n\ngoal (1 subgoal):\n 1. simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>(\\<lambda>(base, len). ipset_from_cidr base len) `\n                 src ` match_sel ` set rs.\n     B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n  simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n  simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)\n\ngoal (1 subgoal):\n 1. simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>(\\<lambda>(base, len). ipset_from_cidr base len) `\n                 src ` match_sel ` set rs.\n     B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n  simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n  simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)\n  ipPartition\n   (set (map wordinterval_to_set (extract_IPSets_generic0 src rs))) A\n  B \\<in> A\n\ngoal (1 subgoal):\n 1. simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)", "unfolding ipPartition_def"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>(\\<lambda>(base, len). ipset_from_cidr base len) `\n                 src ` match_sel ` set rs.\n     B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n  simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n  simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)\n  \\<forall>a\\<in>set (map wordinterval_to_set\n                       (extract_IPSets_generic0 src rs)).\n     \\<forall>b\\<in>A. a \\<inter> b = {} \\<or> b \\<subseteq> a\n  B \\<in> A\n\ngoal (1 subgoal):\n 1. simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)", "by (metis (full_types) Int_commute extract_equi0)"], ["proof (state)\nthis:\n  simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n  simple_fw rs (p\\<lparr>p_src := s2\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*basically a copy of src_ipPart*)"], ["", "lemma dst_ipPart:\n  assumes \"ipPartition (set (map wordinterval_to_set (extract_IPSets_generic0 dst rs))) A\"\n          \"B \\<in> A\" \"s1 \\<in> B\" \"s2 \\<in> B\"\n  shows \"simple_fw rs (p\\<lparr>p_dst:=s1\\<rparr>) = simple_fw rs (p\\<lparr>p_dst:=s2\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)", "have \"\\<forall>A \\<in> (\\<lambda>(base,len). ipset_from_cidr base len) ` dst ` match_sel ` set rs. B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n      simple_fw rs (p\\<lparr>p_dst:=s1\\<rparr>) = simple_fw rs (p\\<lparr>p_dst:=s2\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>(\\<lambda>(base, len). ipset_from_cidr base len) `\n                   dst ` match_sel ` set rs.\n       B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n    simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)", "proof(induction rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                   dst ` match_sel ` set [].\n       B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n    simple_fw [] (p\\<lparr>p_dst := s1\\<rparr>) =\n    simple_fw [] (p\\<lparr>p_dst := s2\\<rparr>)\n 2. \\<And>a rs.\n       \\<lbrakk>\\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                               dst ` match_sel ` set rs.\n                   B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n                simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>);\n        \\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                       dst ` match_sel ` set (a # rs).\n           B \\<subseteq> A \\<or> B \\<inter> A = {}\\<rbrakk>\n       \\<Longrightarrow> simple_fw (a # rs) (p\\<lparr>p_dst := s1\\<rparr>) =\n                         simple_fw (a # rs) (p\\<lparr>p_dst := s2\\<rparr>)", "case Nil"], ["proof (state)\nthis:\n  \\<forall>A\\<in>(\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> ipset_from_cidr a b) `\n                 dst ` match_sel ` set [].\n     B \\<subseteq> A \\<or> B \\<inter> A = {}\n\ngoal (2 subgoals):\n 1. \\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                   dst ` match_sel ` set [].\n       B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n    simple_fw [] (p\\<lparr>p_dst := s1\\<rparr>) =\n    simple_fw [] (p\\<lparr>p_dst := s2\\<rparr>)\n 2. \\<And>a rs.\n       \\<lbrakk>\\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                               dst ` match_sel ` set rs.\n                   B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n                simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>);\n        \\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                       dst ` match_sel ` set (a # rs).\n           B \\<subseteq> A \\<or> B \\<inter> A = {}\\<rbrakk>\n       \\<Longrightarrow> simple_fw (a # rs) (p\\<lparr>p_dst := s1\\<rparr>) =\n                         simple_fw (a # rs) (p\\<lparr>p_dst := s2\\<rparr>)", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>(\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> ipset_from_cidr a b) `\n                 dst ` match_sel ` set [].\n     B \\<subseteq> A \\<or> B \\<inter> A = {}\n\ngoal (1 subgoal):\n 1. simple_fw [] (p\\<lparr>p_dst := s1\\<rparr>) =\n    simple_fw [] (p\\<lparr>p_dst := s2\\<rparr>)", "by simp"], ["proof (state)\nthis:\n  simple_fw [] (p\\<lparr>p_dst := s1\\<rparr>) =\n  simple_fw [] (p\\<lparr>p_dst := s2\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                               dst ` match_sel ` set rs.\n                   B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n                simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>);\n        \\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                       dst ` match_sel ` set (a # rs).\n           B \\<subseteq> A \\<or> B \\<inter> A = {}\\<rbrakk>\n       \\<Longrightarrow> simple_fw (a # rs) (p\\<lparr>p_dst := s1\\<rparr>) =\n                         simple_fw (a # rs) (p\\<lparr>p_dst := s2\\<rparr>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                               dst ` match_sel ` set rs.\n                   B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n                simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>);\n        \\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                       dst ` match_sel ` set (a # rs).\n           B \\<subseteq> A \\<or> B \\<inter> A = {}\\<rbrakk>\n       \\<Longrightarrow> simple_fw (a # rs) (p\\<lparr>p_dst := s1\\<rparr>) =\n                         simple_fw (a # rs) (p\\<lparr>p_dst := s2\\<rparr>)", "case (Cons r rs)"], ["proof (state)\nthis:\n  \\<forall>A\\<in>(\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> ipset_from_cidr a b) `\n                 dst ` match_sel ` set rs.\n     B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n  simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n  simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)\n  \\<forall>A\\<in>(\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> ipset_from_cidr a b) `\n                 dst ` match_sel ` set (r # rs).\n     B \\<subseteq> A \\<or> B \\<inter> A = {}\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                               dst ` match_sel ` set rs.\n                   B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n                simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>);\n        \\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                       dst ` match_sel ` set (a # rs).\n           B \\<subseteq> A \\<or> B \\<inter> A = {}\\<rbrakk>\n       \\<Longrightarrow> simple_fw (a # rs) (p\\<lparr>p_dst := s1\\<rparr>) =\n                         simple_fw (a # rs) (p\\<lparr>p_dst := s2\\<rparr>)", "{"], ["proof (state)\nthis:\n  \\<forall>A\\<in>(\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> ipset_from_cidr a b) `\n                 dst ` match_sel ` set rs.\n     B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n  simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n  simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)\n  \\<forall>A\\<in>(\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> ipset_from_cidr a b) `\n                 dst ` match_sel ` set (r # rs).\n     B \\<subseteq> A \\<or> B \\<inter> A = {}\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                               dst ` match_sel ` set rs.\n                   B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n                simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>);\n        \\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                       dst ` match_sel ` set (a # rs).\n           B \\<subseteq> A \\<or> B \\<inter> A = {}\\<rbrakk>\n       \\<Longrightarrow> simple_fw (a # rs) (p\\<lparr>p_dst := s1\\<rparr>) =\n                         simple_fw (a # rs) (p\\<lparr>p_dst := s2\\<rparr>)", "fix m"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                               dst ` match_sel ` set rs.\n                   B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n                simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>);\n        \\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                       dst ` match_sel ` set (a # rs).\n           B \\<subseteq> A \\<or> B \\<inter> A = {}\\<rbrakk>\n       \\<Longrightarrow> simple_fw (a # rs) (p\\<lparr>p_dst := s1\\<rparr>) =\n                         simple_fw (a # rs) (p\\<lparr>p_dst := s2\\<rparr>)", "from \\<open>s1 \\<in> B\\<close> \\<open>s2 \\<in> B\\<close>"], ["proof (chain)\npicking this:\n  s1 \\<in> B\n  s2 \\<in> B", "have\n        \"B \\<subseteq> (case dst m of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or> B \\<inter> (case dst m of (x, xa) \n                  \\<Rightarrow> ipset_from_cidr x xa) = {} \\<Longrightarrow>\n         simple_matches m (p\\<lparr>p_dst := s1\\<rparr>) \\<longleftrightarrow> simple_matches m (p\\<lparr>p_dst := s2\\<rparr>)\""], ["proof (prove)\nusing this:\n  s1 \\<in> B\n  s2 \\<in> B\n\ngoal (1 subgoal):\n 1. B \\<subseteq> (case dst m of\n                   (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n    B \\<inter> (case dst m of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n    {} \\<Longrightarrow>\n    simple_matches m (p\\<lparr>p_dst := s1\\<rparr>) =\n    simple_matches m (p\\<lparr>p_dst := s2\\<rparr>)", "apply(cases m)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>iiface oiface src dsta proto sports dports.\n       \\<lbrakk>B \\<subseteq> (case dst m of\n                               (x, xa) \\<Rightarrow>\n                                 ipset_from_cidr x xa) \\<or>\n                B \\<inter>\n                (case dst m of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n                {};\n        s1 \\<in> B; s2 \\<in> B;\n        m =\n        \\<lparr>iiface = iiface, oiface = oiface, src = src, dst = dsta,\n           proto = proto, sports = sports, dports = dports\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> simple_matches m (p\\<lparr>p_dst := s1\\<rparr>) =\n                         simple_matches m (p\\<lparr>p_dst := s2\\<rparr>)", "apply(rename_tac iiface oiface src dsta proto sports dports)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>iiface oiface src dsta proto sports dports.\n       \\<lbrakk>B \\<subseteq> (case dst m of\n                               (x, xa) \\<Rightarrow>\n                                 ipset_from_cidr x xa) \\<or>\n                B \\<inter>\n                (case dst m of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n                {};\n        s1 \\<in> B; s2 \\<in> B;\n        m =\n        \\<lparr>iiface = iiface, oiface = oiface, src = src, dst = dsta,\n           proto = proto, sports = sports, dports = dports\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> simple_matches m (p\\<lparr>p_dst := s1\\<rparr>) =\n                         simple_matches m (p\\<lparr>p_dst := s2\\<rparr>)", "apply(case_tac dsta)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>iiface oiface src dsta proto sports dports a b.\n       \\<lbrakk>B \\<subseteq> (case dst m of\n                               (x, xa) \\<Rightarrow>\n                                 ipset_from_cidr x xa) \\<or>\n                B \\<inter>\n                (case dst m of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n                {};\n        s1 \\<in> B; s2 \\<in> B;\n        m =\n        \\<lparr>iiface = iiface, oiface = oiface, src = src, dst = dsta,\n           proto = proto, sports = sports, dports = dports\\<rparr>;\n        dsta = (a, b)\\<rbrakk>\n       \\<Longrightarrow> simple_matches m (p\\<lparr>p_dst := s1\\<rparr>) =\n                         simple_matches m (p\\<lparr>p_dst := s2\\<rparr>)", "apply(simp add: simple_matches.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>iiface oiface src dsta proto sports dports a b.\n       \\<lbrakk>B \\<subseteq> ipset_from_cidr a b \\<or>\n                B \\<inter> ipset_from_cidr a b = {};\n        s1 \\<in> B; s2 \\<in> B;\n        m =\n        \\<lparr>iiface = iiface, oiface = oiface, src = src, dst = (a, b),\n           proto = proto, sports = sports, dports = dports\\<rparr>;\n        dsta = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (match_iface iiface (p_iiface p) \\<and>\n                          match_iface oiface (p_oiface p) \\<and>\n                          simple_match_ip src (p_src p) \\<and>\n                          s1 \\<in> ipset_from_cidr a b \\<and>\n                          match_proto proto (p_proto p) \\<and>\n                          simple_match_port sports (p_sport p) \\<and>\n                          simple_match_port dports (p_dport p)) =\n                         (match_iface iiface (p_iiface p) \\<and>\n                          match_iface oiface (p_oiface p) \\<and>\n                          simple_match_ip src (p_src p) \\<and>\n                          s2 \\<in> ipset_from_cidr a b \\<and>\n                          match_proto proto (p_proto p) \\<and>\n                          simple_match_port sports (p_sport p) \\<and>\n                          simple_match_port dports (p_dport p))", "by blast"], ["proof (state)\nthis:\n  B \\<subseteq> (case dst m of\n                 (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n  B \\<inter> (case dst m of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n  {} \\<Longrightarrow>\n  simple_matches m (p\\<lparr>p_dst := s1\\<rparr>) =\n  simple_matches m (p\\<lparr>p_dst := s2\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                               dst ` match_sel ` set rs.\n                   B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n                simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>);\n        \\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                       dst ` match_sel ` set (a # rs).\n           B \\<subseteq> A \\<or> B \\<inter> A = {}\\<rbrakk>\n       \\<Longrightarrow> simple_fw (a # rs) (p\\<lparr>p_dst := s1\\<rparr>) =\n                         simple_fw (a # rs) (p\\<lparr>p_dst := s2\\<rparr>)", "}"], ["proof (state)\nthis:\n  B \\<subseteq> (case dst ?m2 of\n                 (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n  B \\<inter> (case dst ?m2 of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n  {} \\<Longrightarrow>\n  simple_matches ?m2 (p\\<lparr>p_dst := s1\\<rparr>) =\n  simple_matches ?m2 (p\\<lparr>p_dst := s2\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                               dst ` match_sel ` set rs.\n                   B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n                simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>);\n        \\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                       dst ` match_sel ` set (a # rs).\n           B \\<subseteq> A \\<or> B \\<inter> A = {}\\<rbrakk>\n       \\<Longrightarrow> simple_fw (a # rs) (p\\<lparr>p_dst := s1\\<rparr>) =\n                         simple_fw (a # rs) (p\\<lparr>p_dst := s2\\<rparr>)", "note helper=this"], ["proof (state)\nthis:\n  B \\<subseteq> (case dst ?m2 of\n                 (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n  B \\<inter> (case dst ?m2 of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n  {} \\<Longrightarrow>\n  simple_matches ?m2 (p\\<lparr>p_dst := s1\\<rparr>) =\n  simple_matches ?m2 (p\\<lparr>p_dst := s2\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                               dst ` match_sel ` set rs.\n                   B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n                simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>);\n        \\<forall>A\\<in>(\\<lambda>(x, y). ipset_from_cidr x y) `\n                       dst ` match_sel ` set (a # rs).\n           B \\<subseteq> A \\<or> B \\<inter> A = {}\\<rbrakk>\n       \\<Longrightarrow> simple_fw (a # rs) (p\\<lparr>p_dst := s1\\<rparr>) =\n                         simple_fw (a # rs) (p\\<lparr>p_dst := s2\\<rparr>)", "from Cons"], ["proof (chain)\npicking this:\n  \\<forall>A\\<in>(\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> ipset_from_cidr a b) `\n                 dst ` match_sel ` set rs.\n     B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n  simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n  simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)\n  \\<forall>A\\<in>(\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> ipset_from_cidr a b) `\n                 dst ` match_sel ` set (r # rs).\n     B \\<subseteq> A \\<or> B \\<inter> A = {}", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>(\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> ipset_from_cidr a b) `\n                 dst ` match_sel ` set rs.\n     B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n  simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n  simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)\n  \\<forall>A\\<in>(\\<lambda>a.\n                     case a of (a, b) \\<Rightarrow> ipset_from_cidr a b) `\n                 dst ` match_sel ` set (r # rs).\n     B \\<subseteq> A \\<or> B \\<inter> A = {}\n\ngoal (1 subgoal):\n 1. simple_fw (r # rs) (p\\<lparr>p_dst := s1\\<rparr>) =\n    simple_fw (r # rs) (p\\<lparr>p_dst := s2\\<rparr>)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n             simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>);\n     (B \\<subseteq> (case dst (match_sel r) of\n                     (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n      B \\<inter>\n      (case dst (match_sel r) of\n       (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n      {}) \\<and>\n     (\\<forall>A\\<in>set rs.\n         B \\<subseteq> (case dst (match_sel A) of\n                        (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n         B \\<inter>\n         (case dst (match_sel A) of\n          (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n         {})\\<rbrakk>\n    \\<Longrightarrow> simple_fw (r # rs) (p\\<lparr>p_dst := s1\\<rparr>) =\n                      simple_fw (r # rs) (p\\<lparr>p_dst := s2\\<rparr>)", "apply(case_tac r, rename_tac m a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>);\n        (B \\<subseteq> (case dst (match_sel r) of\n                        (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n         B \\<inter>\n         (case dst (match_sel r) of\n          (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n         {}) \\<and>\n        (\\<forall>A\\<in>set rs.\n            B \\<subseteq> (case dst (match_sel A) of\n                           (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n            B \\<inter>\n            (case dst (match_sel A) of\n             (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n            {});\n        r = SimpleRule m a\\<rbrakk>\n       \\<Longrightarrow> simple_fw (r # rs) (p\\<lparr>p_dst := s1\\<rparr>) =\n                         simple_fw (r # rs) (p\\<lparr>p_dst := s2\\<rparr>)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m a.\n       \\<lbrakk>simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>);\n        (B \\<subseteq> (case dst m of\n                        (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n         B \\<inter>\n         (case dst m of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n         {}) \\<and>\n        (\\<forall>A\\<in>set rs.\n            B \\<subseteq> (case dst (match_sel A) of\n                           (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n            B \\<inter>\n            (case dst (match_sel A) of\n             (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n            {});\n        r = SimpleRule m a\\<rbrakk>\n       \\<Longrightarrow> simple_fw (SimpleRule m a # rs)\n                          (p\\<lparr>p_dst := s1\\<rparr>) =\n                         simple_fw (SimpleRule m a # rs)\n                          (p\\<lparr>p_dst := s2\\<rparr>)", "apply(case_tac a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>);\n        (B \\<subseteq> (case dst m of\n                        (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n         B \\<inter>\n         (case dst m of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n         {}) \\<and>\n        (\\<forall>A\\<in>set rs.\n            B \\<subseteq> (case dst (match_sel A) of\n                           (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n            B \\<inter>\n            (case dst (match_sel A) of\n             (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n            {});\n        r = SimpleRule m a; a = Accept\\<rbrakk>\n       \\<Longrightarrow> simple_fw (SimpleRule m a # rs)\n                          (p\\<lparr>p_dst := s1\\<rparr>) =\n                         simple_fw (SimpleRule m a # rs)\n                          (p\\<lparr>p_dst := s2\\<rparr>)\n 2. \\<And>m a.\n       \\<lbrakk>simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>);\n        (B \\<subseteq> (case dst m of\n                        (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n         B \\<inter>\n         (case dst m of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n         {}) \\<and>\n        (\\<forall>A\\<in>set rs.\n            B \\<subseteq> (case dst (match_sel A) of\n                           (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n            B \\<inter>\n            (case dst (match_sel A) of\n             (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n            {});\n        r = SimpleRule m a; a = Drop\\<rbrakk>\n       \\<Longrightarrow> simple_fw (SimpleRule m a # rs)\n                          (p\\<lparr>p_dst := s1\\<rparr>) =\n                         simple_fw (SimpleRule m a # rs)\n                          (p\\<lparr>p_dst := s2\\<rparr>)", "using helper"], ["proof (prove)\nusing this:\n  B \\<subseteq> (case dst ?m2 of\n                 (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n  B \\<inter> (case dst ?m2 of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n  {} \\<Longrightarrow>\n  simple_matches ?m2 (p\\<lparr>p_dst := s1\\<rparr>) =\n  simple_matches ?m2 (p\\<lparr>p_dst := s2\\<rparr>)\n\ngoal (2 subgoals):\n 1. \\<And>m a.\n       \\<lbrakk>simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>);\n        (B \\<subseteq> (case dst m of\n                        (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n         B \\<inter>\n         (case dst m of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n         {}) \\<and>\n        (\\<forall>A\\<in>set rs.\n            B \\<subseteq> (case dst (match_sel A) of\n                           (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n            B \\<inter>\n            (case dst (match_sel A) of\n             (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n            {});\n        r = SimpleRule m a; a = Accept\\<rbrakk>\n       \\<Longrightarrow> simple_fw (SimpleRule m a # rs)\n                          (p\\<lparr>p_dst := s1\\<rparr>) =\n                         simple_fw (SimpleRule m a # rs)\n                          (p\\<lparr>p_dst := s2\\<rparr>)\n 2. \\<And>m a.\n       \\<lbrakk>simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n                simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>);\n        (B \\<subseteq> (case dst m of\n                        (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n         B \\<inter>\n         (case dst m of (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n         {}) \\<and>\n        (\\<forall>A\\<in>set rs.\n            B \\<subseteq> (case dst (match_sel A) of\n                           (x, xa) \\<Rightarrow> ipset_from_cidr x xa) \\<or>\n            B \\<inter>\n            (case dst (match_sel A) of\n             (x, xa) \\<Rightarrow> ipset_from_cidr x xa) =\n            {});\n        r = SimpleRule m a; a = Drop\\<rbrakk>\n       \\<Longrightarrow> simple_fw (SimpleRule m a # rs)\n                          (p\\<lparr>p_dst := s1\\<rparr>) =\n                         simple_fw (SimpleRule m a # rs)\n                          (p\\<lparr>p_dst := s2\\<rparr>)", "apply force+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  simple_fw (r # rs) (p\\<lparr>p_dst := s1\\<rparr>) =\n  simple_fw (r # rs) (p\\<lparr>p_dst := s2\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>A\\<in>(\\<lambda>(base, len). ipset_from_cidr base len) `\n                 dst ` match_sel ` set rs.\n     B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n  simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n  simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)\n\ngoal (1 subgoal):\n 1. simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>(\\<lambda>(base, len). ipset_from_cidr base len) `\n                 dst ` match_sel ` set rs.\n     B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n  simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n  simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)\n\ngoal (1 subgoal):\n 1. simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)", "using assms(1) assms(2)"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>(\\<lambda>(base, len). ipset_from_cidr base len) `\n                 dst ` match_sel ` set rs.\n     B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n  simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n  simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)\n  ipPartition\n   (set (map wordinterval_to_set (extract_IPSets_generic0 dst rs))) A\n  B \\<in> A\n\ngoal (1 subgoal):\n 1. simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)", "unfolding ipPartition_def"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>(\\<lambda>(base, len). ipset_from_cidr base len) `\n                 dst ` match_sel ` set rs.\n     B \\<subseteq> A \\<or> B \\<inter> A = {} \\<Longrightarrow>\n  simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n  simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)\n  \\<forall>a\\<in>set (map wordinterval_to_set\n                       (extract_IPSets_generic0 dst rs)).\n     \\<forall>b\\<in>A. a \\<inter> b = {} \\<or> b \\<subseteq> a\n  B \\<in> A\n\ngoal (1 subgoal):\n 1. simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)", "by (metis (full_types) Int_commute extract_equi0)"], ["proof (state)\nthis:\n  simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n  simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* OPTIMIZED PARTITIONING *)"], ["", "definition wordinterval_list_to_set :: \"'a::len wordinterval list \\<Rightarrow> 'a::len word set\" where\n  \"wordinterval_list_to_set ws = \\<Union>(set (map wordinterval_to_set ws))\""], ["", "lemma wordinterval_list_to_set_compressed:\n  \"wordinterval_to_set (wordinterval_compress (foldr wordinterval_union xs Empty_WordInterval)) =\n          wordinterval_list_to_set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (wordinterval_compress\n       (foldr wordinterval_union xs Empty_WordInterval)) =\n    wordinterval_list_to_set xs", "proof(induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. wordinterval_to_set\n     (wordinterval_compress\n       (foldr wordinterval_union [] Empty_WordInterval)) =\n    wordinterval_list_to_set []\n 2. \\<And>a xs.\n       wordinterval_to_set\n        (wordinterval_compress\n          (foldr wordinterval_union xs Empty_WordInterval)) =\n       wordinterval_list_to_set xs \\<Longrightarrow>\n       wordinterval_to_set\n        (wordinterval_compress\n          (foldr wordinterval_union (a # xs) Empty_WordInterval)) =\n       wordinterval_list_to_set (a # xs)", "qed(simp_all add: wordinterval_compress wordinterval_list_to_set_def)"], ["", "fun partIps :: \"'a::len wordinterval \\<Rightarrow> 'a::len wordinterval list \n                \\<Rightarrow> 'a::len wordinterval list\" where\n  \"partIps _ [] = []\" |\n  \"partIps s (t#ts) = (if wordinterval_empty s then (t#ts) else\n                        (if wordinterval_empty (wordinterval_intersection s t)\n                          then (t#(partIps s ts))\n                          else\n                            (if wordinterval_empty (wordinterval_setminus t s)\n                              then (t#(partIps (wordinterval_setminus s t) ts))\n                              else (wordinterval_intersection t s)#((wordinterval_setminus t s)#\n                                   (partIps (wordinterval_setminus s t) ts)))))\""], ["", "lemma \"partIps (WordInterval (1::ipv4addr) 1) [WordInterval 0 1] = [WordInterval 1 1, WordInterval 0 0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partIps (WordInterval 1 1) [WordInterval 0 1] =\n    [WordInterval 1 1, WordInterval 0 0]", "by eval"], ["", "lemma partIps_length: \"length (partIps s ts) \\<le> (length ts) * 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (partIps s ts) \\<le> length ts * 2", "proof(induction ts arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s. length (partIps s []) \\<le> length [] * 2\n 2. \\<And>a ts s.\n       (\\<And>s.\n           length (partIps s ts) \\<le> length ts * 2) \\<Longrightarrow>\n       length (partIps s (a # ts)) \\<le> length (a # ts) * 2", "case Cons"], ["proof (state)\nthis:\n  length (partIps ?s ts_) \\<le> length ts_ * 2\n\ngoal (2 subgoals):\n 1. \\<And>s. length (partIps s []) \\<le> length [] * 2\n 2. \\<And>a ts s.\n       (\\<And>s.\n           length (partIps s ts) \\<le> length ts * 2) \\<Longrightarrow>\n       length (partIps s (a # ts)) \\<le> length (a # ts) * 2", "thus ?case"], ["proof (prove)\nusing this:\n  length (partIps ?s ts_) \\<le> length ts_ * 2\n\ngoal (1 subgoal):\n 1. length (partIps s (a_ # ts_)) \\<le> length (a_ # ts_) * 2", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s. length (partIps s ts_) \\<le> length ts_ * 2) \\<Longrightarrow>\n    (wordinterval_to_set a_\n     \\<subseteq> wordinterval_to_set s \\<longrightarrow>\n     (wordinterval_to_set s \\<inter> wordinterval_to_set a_ =\n      {} \\<longrightarrow>\n      wordinterval_to_set s \\<noteq> {} \\<longrightarrow>\n      length (partIps s ts_) \\<le> Suc (length ts_ * 2)) \\<and>\n     (wordinterval_to_set s \\<inter> wordinterval_to_set a_ \\<noteq>\n      {} \\<longrightarrow>\n      wordinterval_to_set s \\<noteq> {} \\<longrightarrow>\n      length (partIps (wordinterval_setminus s a_) ts_)\n      \\<le> Suc (length ts_ * 2))) \\<and>\n    (\\<not> wordinterval_to_set a_\n            \\<subseteq> wordinterval_to_set s \\<longrightarrow>\n     wordinterval_to_set s \\<inter> wordinterval_to_set a_ =\n     {} \\<longrightarrow>\n     wordinterval_to_set s \\<noteq> {} \\<longrightarrow>\n     length (partIps s ts_) \\<le> Suc (length ts_ * 2))", "using le_Suc_eq"], ["proof (prove)\nusing this:\n  (?m \\<le> Suc ?n) = (?m \\<le> ?n \\<or> ?m = Suc ?n)\n\ngoal (1 subgoal):\n 1. (\\<And>s. length (partIps s ts_) \\<le> length ts_ * 2) \\<Longrightarrow>\n    (wordinterval_to_set a_\n     \\<subseteq> wordinterval_to_set s \\<longrightarrow>\n     (wordinterval_to_set s \\<inter> wordinterval_to_set a_ =\n      {} \\<longrightarrow>\n      wordinterval_to_set s \\<noteq> {} \\<longrightarrow>\n      length (partIps s ts_) \\<le> Suc (length ts_ * 2)) \\<and>\n     (wordinterval_to_set s \\<inter> wordinterval_to_set a_ \\<noteq>\n      {} \\<longrightarrow>\n      wordinterval_to_set s \\<noteq> {} \\<longrightarrow>\n      length (partIps (wordinterval_setminus s a_) ts_)\n      \\<le> Suc (length ts_ * 2))) \\<and>\n    (\\<not> wordinterval_to_set a_\n            \\<subseteq> wordinterval_to_set s \\<longrightarrow>\n     wordinterval_to_set s \\<inter> wordinterval_to_set a_ =\n     {} \\<longrightarrow>\n     wordinterval_to_set s \\<noteq> {} \\<longrightarrow>\n     length (partIps s ts_) \\<le> Suc (length ts_ * 2))", "by blast"], ["proof (state)\nthis:\n  length (partIps s (a_ # ts_)) \\<le> length (a_ # ts_) * 2\n\ngoal (1 subgoal):\n 1. \\<And>s. length (partIps s []) \\<le> length [] * 2", "qed(simp)"], ["", "fun partitioningIps :: \"'a::len wordinterval list \\<Rightarrow> 'a::len wordinterval list \\<Rightarrow>\n                        'a::len wordinterval list\" where\n  \"partitioningIps [] ts = ts\" |\n  \"partitioningIps (s#ss) ts = partIps s (partitioningIps ss ts)\""], ["", "lemma partitioningIps_length: \"length (partitioningIps ss ts) \\<le> (2^length ss) * length ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (partitioningIps ss ts) \\<le> 2 ^ length ss * length ts", "proof(induction ss)"], ["proof (state)\ngoal (2 subgoals):\n 1. length (partitioningIps [] ts) \\<le> 2 ^ length [] * length ts\n 2. \\<And>a ss.\n       length (partitioningIps ss ts)\n       \\<le> 2 ^ length ss * length ts \\<Longrightarrow>\n       length (partitioningIps (a # ss) ts)\n       \\<le> 2 ^ length (a # ss) * length ts", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. length (partitioningIps [] ts) \\<le> 2 ^ length [] * length ts\n 2. \\<And>a ss.\n       length (partitioningIps ss ts)\n       \\<le> 2 ^ length ss * length ts \\<Longrightarrow>\n       length (partitioningIps (a # ss) ts)\n       \\<le> 2 ^ length (a # ss) * length ts", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length (partitioningIps [] ts) \\<le> 2 ^ length [] * length ts", "by simp"], ["proof (state)\nthis:\n  length (partitioningIps [] ts) \\<le> 2 ^ length [] * length ts\n\ngoal (1 subgoal):\n 1. \\<And>a ss.\n       length (partitioningIps ss ts)\n       \\<le> 2 ^ length ss * length ts \\<Longrightarrow>\n       length (partitioningIps (a # ss) ts)\n       \\<le> 2 ^ length (a # ss) * length ts", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ss.\n       length (partitioningIps ss ts)\n       \\<le> 2 ^ length ss * length ts \\<Longrightarrow>\n       length (partitioningIps (a # ss) ts)\n       \\<le> 2 ^ length (a # ss) * length ts", "case (Cons s ss)"], ["proof (state)\nthis:\n  length (partitioningIps ss ts) \\<le> 2 ^ length ss * length ts\n\ngoal (1 subgoal):\n 1. \\<And>a ss.\n       length (partitioningIps ss ts)\n       \\<le> 2 ^ length ss * length ts \\<Longrightarrow>\n       length (partitioningIps (a # ss) ts)\n       \\<le> 2 ^ length (a # ss) * length ts", "have \"length (partIps s (partitioningIps ss ts)) \\<le> length (partitioningIps ss ts) * 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (partIps s (partitioningIps ss ts))\n    \\<le> length (partitioningIps ss ts) * 2", "using partIps_length"], ["proof (prove)\nusing this:\n  length (partIps ?s ?ts) \\<le> length ?ts * 2\n\ngoal (1 subgoal):\n 1. length (partIps s (partitioningIps ss ts))\n    \\<le> length (partitioningIps ss ts) * 2", "by fast"], ["proof (state)\nthis:\n  length (partIps s (partitioningIps ss ts))\n  \\<le> length (partitioningIps ss ts) * 2\n\ngoal (1 subgoal):\n 1. \\<And>a ss.\n       length (partitioningIps ss ts)\n       \\<le> 2 ^ length ss * length ts \\<Longrightarrow>\n       length (partitioningIps (a # ss) ts)\n       \\<le> 2 ^ length (a # ss) * length ts", "with Cons"], ["proof (chain)\npicking this:\n  length (partitioningIps ss ts) \\<le> 2 ^ length ss * length ts\n  length (partIps s (partitioningIps ss ts))\n  \\<le> length (partitioningIps ss ts) * 2", "show  ?case"], ["proof (prove)\nusing this:\n  length (partitioningIps ss ts) \\<le> 2 ^ length ss * length ts\n  length (partIps s (partitioningIps ss ts))\n  \\<le> length (partitioningIps ss ts) * 2\n\ngoal (1 subgoal):\n 1. length (partitioningIps (s # ss) ts)\n    \\<le> 2 ^ length (s # ss) * length ts", "by force"], ["proof (state)\nthis:\n  length (partitioningIps (s # ss) ts) \\<le> 2 ^ length (s # ss) * length ts\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma partIps_equi: \"map wordinterval_to_set (partIps s ts) = \n    partList4 (wordinterval_to_set s) (map wordinterval_to_set ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map wordinterval_to_set (partIps s ts) =\n    partList4 (wordinterval_to_set s) (map wordinterval_to_set ts)", "proof(induction ts arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       map wordinterval_to_set (partIps s []) =\n       partList4 (wordinterval_to_set s) (map wordinterval_to_set [])\n 2. \\<And>a ts s.\n       (\\<And>s.\n           map wordinterval_to_set (partIps s ts) =\n           partList4 (wordinterval_to_set s)\n            (map wordinterval_to_set ts)) \\<Longrightarrow>\n       map wordinterval_to_set (partIps s (a # ts)) =\n       partList4 (wordinterval_to_set s) (map wordinterval_to_set (a # ts))", "qed(simp_all)"], ["", "lemma partitioningIps_equi: \"map wordinterval_to_set (partitioningIps ss ts)\n       = (partitioning1 (map wordinterval_to_set ss) (map wordinterval_to_set ts))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map wordinterval_to_set (partitioningIps ss ts) =\n    partitioning1 (map wordinterval_to_set ss) (map wordinterval_to_set ts)", "apply(induction ss arbitrary: ts)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ts.\n       map wordinterval_to_set (partitioningIps [] ts) =\n       partitioning1 (map wordinterval_to_set [])\n        (map wordinterval_to_set ts)\n 2. \\<And>a ss ts.\n       (\\<And>ts.\n           map wordinterval_to_set (partitioningIps ss ts) =\n           partitioning1 (map wordinterval_to_set ss)\n            (map wordinterval_to_set ts)) \\<Longrightarrow>\n       map wordinterval_to_set (partitioningIps (a # ss) ts) =\n       partitioning1 (map wordinterval_to_set (a # ss))\n        (map wordinterval_to_set ts)", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ss ts.\n       (\\<And>ts.\n           map wordinterval_to_set (partitioningIps ss ts) =\n           partitioning1 (map wordinterval_to_set ss)\n            (map wordinterval_to_set ts)) \\<Longrightarrow>\n       map wordinterval_to_set (partitioningIps (a # ss) ts) =\n       partitioning1 (map wordinterval_to_set (a # ss))\n        (map wordinterval_to_set ts)", "apply(simp add: partIps_equi)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition getParts :: \"'i::len simple_rule list \\<Rightarrow> 'i wordinterval list\" where\n   \"getParts rs = partitioningIps (extract_IPSets rs) [wordinterval_UNIV]\""], ["", "lemma partitioningIps_foldr: \"partitioningIps ss ts = foldr partIps ss ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. partitioningIps ss ts = foldr partIps ss ts", "by(induction ss) (simp_all)"], ["", "lemma getParts_foldr: \"getParts rs = foldr partIps (extract_IPSets rs) [wordinterval_UNIV]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getParts rs = foldr partIps (extract_IPSets rs) [wordinterval_UNIV]", "by(simp add: getParts_def partitioningIps_foldr)"], ["", "lemma getParts_length: \"length (getParts rs) \\<le> 2^(2 * length rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (getParts rs) \\<le> 2 ^ (2 * length rs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length (getParts rs) \\<le> 2 ^ (2 * length rs)", "from partitioningIps_length[where ss=\"extract_IPSets rs\" and ts=\"[wordinterval_UNIV]\"]"], ["proof (chain)\npicking this:\n  length (partitioningIps (extract_IPSets rs) [wordinterval_UNIV])\n  \\<le> 2 ^ length (extract_IPSets rs) * length [wordinterval_UNIV]", "have\n    1: \"length (partitioningIps (extract_IPSets rs) [wordinterval_UNIV]) \\<le> 2 ^ length (extract_IPSets rs)\""], ["proof (prove)\nusing this:\n  length (partitioningIps (extract_IPSets rs) [wordinterval_UNIV])\n  \\<le> 2 ^ length (extract_IPSets rs) * length [wordinterval_UNIV]\n\ngoal (1 subgoal):\n 1. length (partitioningIps (extract_IPSets rs) [wordinterval_UNIV])\n    \\<le> 2 ^ length (extract_IPSets rs)", "by simp"], ["proof (state)\nthis:\n  length (partitioningIps (extract_IPSets rs) [wordinterval_UNIV])\n  \\<le> 2 ^ length (extract_IPSets rs)\n\ngoal (1 subgoal):\n 1. length (getParts rs) \\<le> 2 ^ (2 * length rs)", "from extract_IPSets_length"], ["proof (chain)\npicking this:\n  length (extract_IPSets ?rs) \\<le> 2 * length ?rs", "have \"(2::nat) ^ length (extract_IPSets rs) \\<le> 2 ^ (2 * length rs)\""], ["proof (prove)\nusing this:\n  length (extract_IPSets ?rs) \\<le> 2 * length ?rs\n\ngoal (1 subgoal):\n 1. 2 ^ length (extract_IPSets rs) \\<le> 2 ^ (2 * length rs)", "by simp"], ["proof (state)\nthis:\n  2 ^ length (extract_IPSets rs) \\<le> 2 ^ (2 * length rs)\n\ngoal (1 subgoal):\n 1. length (getParts rs) \\<le> 2 ^ (2 * length rs)", "with 1"], ["proof (chain)\npicking this:\n  length (partitioningIps (extract_IPSets rs) [wordinterval_UNIV])\n  \\<le> 2 ^ length (extract_IPSets rs)\n  2 ^ length (extract_IPSets rs) \\<le> 2 ^ (2 * length rs)", "have \"length (partitioningIps (extract_IPSets rs) [wordinterval_UNIV]) \\<le> 2 ^ (2 * length rs)\""], ["proof (prove)\nusing this:\n  length (partitioningIps (extract_IPSets rs) [wordinterval_UNIV])\n  \\<le> 2 ^ length (extract_IPSets rs)\n  2 ^ length (extract_IPSets rs) \\<le> 2 ^ (2 * length rs)\n\ngoal (1 subgoal):\n 1. length (partitioningIps (extract_IPSets rs) [wordinterval_UNIV])\n    \\<le> 2 ^ (2 * length rs)", "by linarith"], ["proof (state)\nthis:\n  length (partitioningIps (extract_IPSets rs) [wordinterval_UNIV])\n  \\<le> 2 ^ (2 * length rs)\n\ngoal (1 subgoal):\n 1. length (getParts rs) \\<le> 2 ^ (2 * length rs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  length (partitioningIps (extract_IPSets rs) [wordinterval_UNIV])\n  \\<le> 2 ^ (2 * length rs)\n\ngoal (1 subgoal):\n 1. length (getParts rs) \\<le> 2 ^ (2 * length rs)", "by(simp add: getParts_def)"], ["proof (state)\nthis:\n  length (getParts rs) \\<le> 2 ^ (2 * length rs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma getParts_ipPartition: \"ipPartition (set (map wordinterval_to_set (extract_IPSets rs)))\n                                         (set (map wordinterval_to_set (getParts rs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipPartition (set (map wordinterval_to_set (extract_IPSets rs)))\n     (set (map wordinterval_to_set (getParts rs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ipPartition (set (map wordinterval_to_set (extract_IPSets rs)))\n     (set (map wordinterval_to_set (getParts rs)))", "have hlp_rule: \"{} \\<notin> set (map wordinterval_to_set ts) \\<Longrightarrow> disjoint_list (map wordinterval_to_set ts) \\<Longrightarrow> \n     (wordinterval_list_to_set ss) \\<subseteq> (wordinterval_list_to_set ts) \\<Longrightarrow> \n     ipPartition (set (map wordinterval_to_set ss)) \n                 (set (map wordinterval_to_set (partitioningIps ss ts)))\" for ts ss::\"'a wordinterval list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{} \\<notin> set (map wordinterval_to_set ts);\n     disjoint_list (map wordinterval_to_set ts);\n     wordinterval_list_to_set ss\n     \\<subseteq> wordinterval_list_to_set ts\\<rbrakk>\n    \\<Longrightarrow> ipPartition (set (map wordinterval_to_set ss))\n                       (set (map wordinterval_to_set\n                              (partitioningIps ss ts)))", "by (metis ipPartitioning_helper_opt partitioningIps_equi wordinterval_list_to_set_def)"], ["proof (state)\nthis:\n  \\<lbrakk>{} \\<notin> set (map wordinterval_to_set ?ts);\n   disjoint_list (map wordinterval_to_set ?ts);\n   wordinterval_list_to_set ?ss\n   \\<subseteq> wordinterval_list_to_set ?ts\\<rbrakk>\n  \\<Longrightarrow> ipPartition (set (map wordinterval_to_set ?ss))\n                     (set (map wordinterval_to_set\n                            (partitioningIps ?ss ?ts)))\n\ngoal (1 subgoal):\n 1. ipPartition (set (map wordinterval_to_set (extract_IPSets rs)))\n     (set (map wordinterval_to_set (getParts rs)))", "have \"disjoint_list [UNIV]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. disjoint_list [UNIV]", "by(simp add: disjoint_list_def disjoint_def)"], ["proof (state)\nthis:\n  disjoint_list [UNIV]\n\ngoal (1 subgoal):\n 1. ipPartition (set (map wordinterval_to_set (extract_IPSets rs)))\n     (set (map wordinterval_to_set (getParts rs)))", "have \"ipPartition (set (map wordinterval_to_set ss)) \n                   (set (map wordinterval_to_set (partitioningIps ss [wordinterval_UNIV])))\"\n     for ss::\"'a wordinterval list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipPartition (set (map wordinterval_to_set ss))\n     (set (map wordinterval_to_set\n            (partitioningIps ss [wordinterval_UNIV])))", "apply(rule hlp_rule)"], ["proof (prove)\ngoal (3 subgoals):\n 1. {} \\<notin> set (map wordinterval_to_set [wordinterval_UNIV])\n 2. disjoint_list (map wordinterval_to_set [wordinterval_UNIV])\n 3. wordinterval_list_to_set ss\n    \\<subseteq> wordinterval_list_to_set [wordinterval_UNIV]", "apply(simp_all add: wordinterval_list_to_set_def \\<open>disjoint_list [UNIV]\\<close>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ipPartition (set (map wordinterval_to_set ?ss1))\n   (set (map wordinterval_to_set\n          (partitioningIps ?ss1 [wordinterval_UNIV])))\n\ngoal (1 subgoal):\n 1. ipPartition (set (map wordinterval_to_set (extract_IPSets rs)))\n     (set (map wordinterval_to_set (getParts rs)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ipPartition (set (map wordinterval_to_set ?ss1))\n   (set (map wordinterval_to_set\n          (partitioningIps ?ss1 [wordinterval_UNIV])))\n\ngoal (1 subgoal):\n 1. ipPartition (set (map wordinterval_to_set (extract_IPSets rs)))\n     (set (map wordinterval_to_set (getParts rs)))", "unfolding getParts_def"], ["proof (prove)\nusing this:\n  ipPartition (set (map wordinterval_to_set ?ss1))\n   (set (map wordinterval_to_set\n          (partitioningIps ?ss1 [wordinterval_UNIV])))\n\ngoal (1 subgoal):\n 1. ipPartition (set (map wordinterval_to_set (extract_IPSets rs)))\n     (set (map wordinterval_to_set\n            (partitioningIps (extract_IPSets rs) [wordinterval_UNIV])))", "by blast"], ["proof (state)\nthis:\n  ipPartition (set (map wordinterval_to_set (extract_IPSets rs)))\n   (set (map wordinterval_to_set (getParts rs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma getParts_complete: \"wordinterval_list_to_set (getParts rs) = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_list_to_set (getParts rs) = UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wordinterval_list_to_set (getParts rs) = UNIV", "have \"{} \\<notin> set (map wordinterval_to_set ts) \\<Longrightarrow>\n     (wordinterval_list_to_set ss) \\<subseteq> (wordinterval_list_to_set ts) \\<Longrightarrow> \n     wordinterval_list_to_set (partitioningIps ss ts) = (wordinterval_list_to_set ts)\"\n     for ss ts::\"'a wordinterval list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{} \\<notin> set (map wordinterval_to_set ts);\n     wordinterval_list_to_set ss\n     \\<subseteq> wordinterval_list_to_set ts\\<rbrakk>\n    \\<Longrightarrow> wordinterval_list_to_set (partitioningIps ss ts) =\n                      wordinterval_list_to_set ts", "using complete_helper"], ["proof (prove)\nusing this:\n  \\<lbrakk>{} \\<notin> set ?ts;\n   \\<Union> (set ?ss) \\<subseteq> \\<Union> (set ?ts)\\<rbrakk>\n  \\<Longrightarrow> \\<Union> (set ?ts) =\n                    \\<Union> (set (partitioning1 ?ss ?ts))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>{} \\<notin> set (map wordinterval_to_set ts);\n     wordinterval_list_to_set ss\n     \\<subseteq> wordinterval_list_to_set ts\\<rbrakk>\n    \\<Longrightarrow> wordinterval_list_to_set (partitioningIps ss ts) =\n                      wordinterval_list_to_set ts", "by (metis partitioningIps_equi wordinterval_list_to_set_def)"], ["proof (state)\nthis:\n  \\<lbrakk>{} \\<notin> set (map wordinterval_to_set ?ts);\n   wordinterval_list_to_set ?ss\n   \\<subseteq> wordinterval_list_to_set ?ts\\<rbrakk>\n  \\<Longrightarrow> wordinterval_list_to_set (partitioningIps ?ss ?ts) =\n                    wordinterval_list_to_set ?ts\n\ngoal (1 subgoal):\n 1. wordinterval_list_to_set (getParts rs) = UNIV", "hence \"wordinterval_list_to_set (getParts rs) = wordinterval_list_to_set [wordinterval_UNIV]\""], ["proof (prove)\nusing this:\n  \\<lbrakk>{} \\<notin> set (map wordinterval_to_set ?ts);\n   wordinterval_list_to_set ?ss\n   \\<subseteq> wordinterval_list_to_set ?ts\\<rbrakk>\n  \\<Longrightarrow> wordinterval_list_to_set (partitioningIps ?ss ?ts) =\n                    wordinterval_list_to_set ?ts\n\ngoal (1 subgoal):\n 1. wordinterval_list_to_set (getParts rs) =\n    wordinterval_list_to_set [wordinterval_UNIV]", "unfolding getParts_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>{} \\<notin> set (map wordinterval_to_set ?ts);\n   wordinterval_list_to_set ?ss\n   \\<subseteq> wordinterval_list_to_set ?ts\\<rbrakk>\n  \\<Longrightarrow> wordinterval_list_to_set (partitioningIps ?ss ?ts) =\n                    wordinterval_list_to_set ?ts\n\ngoal (1 subgoal):\n 1. wordinterval_list_to_set\n     (partitioningIps (extract_IPSets rs) [wordinterval_UNIV]) =\n    wordinterval_list_to_set [wordinterval_UNIV]", "by(simp add: wordinterval_list_to_set_def)"], ["proof (state)\nthis:\n  wordinterval_list_to_set (getParts rs) =\n  wordinterval_list_to_set [wordinterval_UNIV]\n\ngoal (1 subgoal):\n 1. wordinterval_list_to_set (getParts rs) = UNIV", "also"], ["proof (state)\nthis:\n  wordinterval_list_to_set (getParts rs) =\n  wordinterval_list_to_set [wordinterval_UNIV]\n\ngoal (1 subgoal):\n 1. wordinterval_list_to_set (getParts rs) = UNIV", "have \"\\<dots> = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_list_to_set [wordinterval_UNIV] = UNIV", "by (simp add: wordinterval_list_to_set_def)"], ["proof (state)\nthis:\n  wordinterval_list_to_set [wordinterval_UNIV] = UNIV\n\ngoal (1 subgoal):\n 1. wordinterval_list_to_set (getParts rs) = UNIV", "finally"], ["proof (chain)\npicking this:\n  wordinterval_list_to_set (getParts rs) = UNIV", "show ?thesis"], ["proof (prove)\nusing this:\n  wordinterval_list_to_set (getParts rs) = UNIV\n\ngoal (1 subgoal):\n 1. wordinterval_list_to_set (getParts rs) = UNIV", "."], ["proof (state)\nthis:\n  wordinterval_list_to_set (getParts rs) = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem getParts_samefw: \n  assumes \"A \\<in> set (map wordinterval_to_set (getParts rs))\" \"s1 \\<in> A\" \"s2 \\<in> A\" \n  shows \"simple_fw rs (p\\<lparr>p_src:=s1\\<rparr>) = simple_fw rs (p\\<lparr>p_src:=s2\\<rparr>) \\<and>\n         simple_fw rs (p\\<lparr>p_dst:=s1\\<rparr>) = simple_fw rs (p\\<lparr>p_dst:=s2\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_src := s2\\<rparr>) \\<and>\n    simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_src := s2\\<rparr>) \\<and>\n    simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)", "let ?X=\"(set (map wordinterval_to_set (getParts rs)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_src := s2\\<rparr>) \\<and>\n    simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)", "from getParts_ipPartition"], ["proof (chain)\npicking this:\n  ipPartition (set (map wordinterval_to_set (extract_IPSets ?rs)))\n   (set (map wordinterval_to_set (getParts ?rs)))", "have \"ipPartition (set (map wordinterval_to_set (extract_IPSets rs))) ?X\""], ["proof (prove)\nusing this:\n  ipPartition (set (map wordinterval_to_set (extract_IPSets ?rs)))\n   (set (map wordinterval_to_set (getParts ?rs)))\n\ngoal (1 subgoal):\n 1. ipPartition (set (map wordinterval_to_set (extract_IPSets rs)))\n     (set (map wordinterval_to_set (getParts rs)))", "."], ["proof (state)\nthis:\n  ipPartition (set (map wordinterval_to_set (extract_IPSets rs)))\n   (set (map wordinterval_to_set (getParts rs)))\n\ngoal (1 subgoal):\n 1. simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_src := s2\\<rparr>) \\<and>\n    simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)", "hence \"ipPartition (set (map wordinterval_to_set (extract_IPSets_generic0 src rs))) ?X \\<and>\n         ipPartition (set (map wordinterval_to_set (extract_IPSets_generic0 dst rs))) ?X\""], ["proof (prove)\nusing this:\n  ipPartition (set (map wordinterval_to_set (extract_IPSets rs)))\n   (set (map wordinterval_to_set (getParts rs)))\n\ngoal (1 subgoal):\n 1. ipPartition\n     (set (map wordinterval_to_set (extract_IPSets_generic0 src rs)))\n     (set (map wordinterval_to_set (getParts rs))) \\<and>\n    ipPartition\n     (set (map wordinterval_to_set (extract_IPSets_generic0 dst rs)))\n     (set (map wordinterval_to_set (getParts rs)))", "by(simp add: extract_IPSets ipPartitionUnion image_Un)"], ["proof (state)\nthis:\n  ipPartition\n   (set (map wordinterval_to_set (extract_IPSets_generic0 src rs)))\n   (set (map wordinterval_to_set (getParts rs))) \\<and>\n  ipPartition\n   (set (map wordinterval_to_set (extract_IPSets_generic0 dst rs)))\n   (set (map wordinterval_to_set (getParts rs)))\n\ngoal (1 subgoal):\n 1. simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_src := s2\\<rparr>) \\<and>\n    simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ipPartition\n   (set (map wordinterval_to_set (extract_IPSets_generic0 src rs)))\n   (set (map wordinterval_to_set (getParts rs))) \\<and>\n  ipPartition\n   (set (map wordinterval_to_set (extract_IPSets_generic0 dst rs)))\n   (set (map wordinterval_to_set (getParts rs)))\n\ngoal (1 subgoal):\n 1. simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_src := s2\\<rparr>) \\<and>\n    simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)", "using assms dst_ipPart src_ipPart"], ["proof (prove)\nusing this:\n  ipPartition\n   (set (map wordinterval_to_set (extract_IPSets_generic0 src rs)))\n   (set (map wordinterval_to_set (getParts rs))) \\<and>\n  ipPartition\n   (set (map wordinterval_to_set (extract_IPSets_generic0 dst rs)))\n   (set (map wordinterval_to_set (getParts rs)))\n  A \\<in> set (map wordinterval_to_set (getParts rs))\n  s1 \\<in> A\n  s2 \\<in> A\n  \\<lbrakk>ipPartition\n            (set (map wordinterval_to_set\n                   (extract_IPSets_generic0 dst ?rs)))\n            ?A;\n   ?B \\<in> ?A; ?s1.0 \\<in> ?B; ?s2.0 \\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> simple_fw ?rs (?p\\<lparr>p_dst := ?s1.0\\<rparr>) =\n                    simple_fw ?rs (?p\\<lparr>p_dst := ?s2.0\\<rparr>)\n  \\<lbrakk>ipPartition\n            (set (map wordinterval_to_set\n                   (extract_IPSets_generic0 src ?rs)))\n            ?A;\n   ?B \\<in> ?A; ?s1.0 \\<in> ?B; ?s2.0 \\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> simple_fw ?rs (?p\\<lparr>p_src := ?s1.0\\<rparr>) =\n                    simple_fw ?rs (?p\\<lparr>p_src := ?s2.0\\<rparr>)\n\ngoal (1 subgoal):\n 1. simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_src := s2\\<rparr>) \\<and>\n    simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n    simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)", "by blast"], ["proof (state)\nthis:\n  simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n  simple_fw rs (p\\<lparr>p_src := s2\\<rparr>) \\<and>\n  simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n  simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma partIps_nonempty: \"ts \\<noteq> [] \\<Longrightarrow> partIps s ts \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts \\<noteq> [] \\<Longrightarrow> partIps s ts \\<noteq> []", "by(induction ts arbitrary: s) simp_all"], ["", "lemma partitioningIps_nonempty: \"ts \\<noteq> [] \\<Longrightarrow> partitioningIps ss ts \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ts \\<noteq> [] \\<Longrightarrow> partitioningIps ss ts \\<noteq> []", "proof(induction ss arbitrary: ts)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts.\n       ts \\<noteq> [] \\<Longrightarrow> partitioningIps [] ts \\<noteq> []\n 2. \\<And>a ss ts.\n       \\<lbrakk>\\<And>ts.\n                   ts \\<noteq> [] \\<Longrightarrow>\n                   partitioningIps ss ts \\<noteq> [];\n        ts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> partitioningIps (a # ss) ts \\<noteq> []", "case Nil"], ["proof (state)\nthis:\n  ts \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>ts.\n       ts \\<noteq> [] \\<Longrightarrow> partitioningIps [] ts \\<noteq> []\n 2. \\<And>a ss ts.\n       \\<lbrakk>\\<And>ts.\n                   ts \\<noteq> [] \\<Longrightarrow>\n                   partitioningIps ss ts \\<noteq> [];\n        ts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> partitioningIps (a # ss) ts \\<noteq> []", "thus ?case"], ["proof (prove)\nusing this:\n  ts \\<noteq> []\n\ngoal (1 subgoal):\n 1. partitioningIps [] ts \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  partitioningIps [] ts \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a ss ts.\n       \\<lbrakk>\\<And>ts.\n                   ts \\<noteq> [] \\<Longrightarrow>\n                   partitioningIps ss ts \\<noteq> [];\n        ts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> partitioningIps (a # ss) ts \\<noteq> []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ss ts.\n       \\<lbrakk>\\<And>ts.\n                   ts \\<noteq> [] \\<Longrightarrow>\n                   partitioningIps ss ts \\<noteq> [];\n        ts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> partitioningIps (a # ss) ts \\<noteq> []", "case (Cons s ss)"], ["proof (state)\nthis:\n  ?ts \\<noteq> [] \\<Longrightarrow> partitioningIps ss ?ts \\<noteq> []\n  ts \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a ss ts.\n       \\<lbrakk>\\<And>ts.\n                   ts \\<noteq> [] \\<Longrightarrow>\n                   partitioningIps ss ts \\<noteq> [];\n        ts \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> partitioningIps (a # ss) ts \\<noteq> []", "thus ?case"], ["proof (prove)\nusing this:\n  ?ts \\<noteq> [] \\<Longrightarrow> partitioningIps ss ?ts \\<noteq> []\n  ts \\<noteq> []\n\ngoal (1 subgoal):\n 1. partitioningIps (s # ss) ts \\<noteq> []", "apply(cases ts)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>ts.\n                ts \\<noteq> [] \\<Longrightarrow>\n                partitioningIps ss ts \\<noteq> [];\n     ts \\<noteq> []; ts = []\\<rbrakk>\n    \\<Longrightarrow> partitioningIps (s # ss) ts \\<noteq> []\n 2. \\<And>a list.\n       \\<lbrakk>\\<And>ts.\n                   ts \\<noteq> [] \\<Longrightarrow>\n                   partitioningIps ss ts \\<noteq> [];\n        ts \\<noteq> []; ts = a # list\\<rbrakk>\n       \\<Longrightarrow> partitioningIps (s # ss) ts \\<noteq> []", "apply(simp; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<And>ts.\n                   ts \\<noteq> [] \\<Longrightarrow>\n                   partitioningIps ss ts \\<noteq> [];\n        ts \\<noteq> []; ts = a # list\\<rbrakk>\n       \\<Longrightarrow> partitioningIps (s # ss) ts \\<noteq> []", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<And>ts.\n                   ts \\<noteq> [] \\<Longrightarrow>\n                   partitioningIps ss ts \\<noteq> [];\n        ts = a # list\\<rbrakk>\n       \\<Longrightarrow> partIps s (partitioningIps ss (a # list)) \\<noteq>\n                         []", "using partIps_nonempty"], ["proof (prove)\nusing this:\n  ?ts \\<noteq> [] \\<Longrightarrow> partIps ?s ?ts \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<And>ts.\n                   ts \\<noteq> [] \\<Longrightarrow>\n                   partitioningIps ss ts \\<noteq> [];\n        ts = a # list\\<rbrakk>\n       \\<Longrightarrow> partIps s (partitioningIps ss (a # list)) \\<noteq>\n                         []", "by blast"], ["proof (state)\nthis:\n  partitioningIps (s # ss) ts \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\nlemma partIps_nonempty: \"\\<forall>t \\<in> set ts. \\<not> wordinterval_empty t \n       \\<Longrightarrow> {} \\<notin> set (map wordinterval_to_set (partIps s ts))\"\n  apply(induction ts arbitrary: s)\n   apply(simp; fail)\n  apply(simp)\n  by blast\n*)"], ["", "lemma getParts_nonempty: \"getParts rs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getParts rs \\<noteq> []", "by(simp add: getParts_def partitioningIps_nonempty)"], ["", "lemma getParts_nonempty_elems: \"\\<forall>w\\<in>set (getParts rs). \\<not> wordinterval_empty w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set (getParts rs). \\<not> wordinterval_empty w", "unfolding getParts_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set (partitioningIps (extract_IPSets rs)\n                         [wordinterval_UNIV]).\n       \\<not> wordinterval_empty w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set (partitioningIps (extract_IPSets rs)\n                         [wordinterval_UNIV]).\n       \\<not> wordinterval_empty w", "have partitioning_nonempty: \"\\<forall>t \\<in> set ts. \\<not> wordinterval_empty t \\<Longrightarrow>\n      {} \\<notin> set (map wordinterval_to_set (partitioningIps ss ts))\"\n      for ts ss::\"'a wordinterval list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set ts. \\<not> wordinterval_empty t \\<Longrightarrow>\n    {} \\<notin> set (map wordinterval_to_set (partitioningIps ss ts))", "proof(induction ss arbitrary: ts)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts.\n       \\<forall>t\\<in>set ts. \\<not> wordinterval_empty t \\<Longrightarrow>\n       {} \\<notin> set (map wordinterval_to_set (partitioningIps [] ts))\n 2. \\<And>a ss ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<forall>t\\<in>set ts.\n                      \\<not> wordinterval_empty t \\<Longrightarrow>\n                   {} \\<notin> set (map wordinterval_to_set\n                                     (partitioningIps ss ts));\n        \\<forall>t\\<in>set ts. \\<not> wordinterval_empty t\\<rbrakk>\n       \\<Longrightarrow> {} \\<notin> set\n(map wordinterval_to_set (partitioningIps (a # ss) ts))", "case Nil"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set ts. \\<not> wordinterval_empty t\n\ngoal (2 subgoals):\n 1. \\<And>ts.\n       \\<forall>t\\<in>set ts. \\<not> wordinterval_empty t \\<Longrightarrow>\n       {} \\<notin> set (map wordinterval_to_set (partitioningIps [] ts))\n 2. \\<And>a ss ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<forall>t\\<in>set ts.\n                      \\<not> wordinterval_empty t \\<Longrightarrow>\n                   {} \\<notin> set (map wordinterval_to_set\n                                     (partitioningIps ss ts));\n        \\<forall>t\\<in>set ts. \\<not> wordinterval_empty t\\<rbrakk>\n       \\<Longrightarrow> {} \\<notin> set\n(map wordinterval_to_set (partitioningIps (a # ss) ts))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>set ts. \\<not> wordinterval_empty t\n\ngoal (1 subgoal):\n 1. {} \\<notin> set (map wordinterval_to_set (partitioningIps [] ts))", "by auto"], ["proof (state)\nthis:\n  {} \\<notin> set (map wordinterval_to_set (partitioningIps [] ts))\n\ngoal (1 subgoal):\n 1. \\<And>a ss ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<forall>t\\<in>set ts.\n                      \\<not> wordinterval_empty t \\<Longrightarrow>\n                   {} \\<notin> set (map wordinterval_to_set\n                                     (partitioningIps ss ts));\n        \\<forall>t\\<in>set ts. \\<not> wordinterval_empty t\\<rbrakk>\n       \\<Longrightarrow> {} \\<notin> set\n(map wordinterval_to_set (partitioningIps (a # ss) ts))", "case Cons"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set ?ts. \\<not> wordinterval_empty t \\<Longrightarrow>\n  {} \\<notin> set (map wordinterval_to_set (partitioningIps ss_ ?ts))\n  \\<forall>t\\<in>set ts. \\<not> wordinterval_empty t\n\ngoal (1 subgoal):\n 1. \\<And>a ss ts.\n       \\<lbrakk>\\<And>ts.\n                   \\<forall>t\\<in>set ts.\n                      \\<not> wordinterval_empty t \\<Longrightarrow>\n                   {} \\<notin> set (map wordinterval_to_set\n                                     (partitioningIps ss ts));\n        \\<forall>t\\<in>set ts. \\<not> wordinterval_empty t\\<rbrakk>\n       \\<Longrightarrow> {} \\<notin> set\n(map wordinterval_to_set (partitioningIps (a # ss) ts))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>set ?ts. \\<not> wordinterval_empty t \\<Longrightarrow>\n  {} \\<notin> set (map wordinterval_to_set (partitioningIps ss_ ?ts))\n  \\<forall>t\\<in>set ts. \\<not> wordinterval_empty t\n\ngoal (1 subgoal):\n 1. {} \\<notin> set (map wordinterval_to_set\n                      (partitioningIps (a_ # ss_) ts))", "by (simp add: partIps_equi partList4_empty)"], ["proof (state)\nthis:\n  {} \\<notin> set (map wordinterval_to_set (partitioningIps (a_ # ss_) ts))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set ?ts. \\<not> wordinterval_empty t \\<Longrightarrow>\n  {} \\<notin> set (map wordinterval_to_set (partitioningIps ?ss ?ts))\n\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set (partitioningIps (extract_IPSets rs)\n                         [wordinterval_UNIV]).\n       \\<not> wordinterval_empty w", "have \"\\<forall>t \\<in> set [wordinterval_UNIV].\\<not> wordinterval_empty t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set [wordinterval_UNIV]. \\<not> wordinterval_empty t", "by(simp)"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set [wordinterval_UNIV]. \\<not> wordinterval_empty t\n\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set (partitioningIps (extract_IPSets rs)\n                         [wordinterval_UNIV]).\n       \\<not> wordinterval_empty w", "with partitioning_nonempty"], ["proof (chain)\npicking this:\n  \\<forall>t\\<in>set ?ts. \\<not> wordinterval_empty t \\<Longrightarrow>\n  {} \\<notin> set (map wordinterval_to_set (partitioningIps ?ss ?ts))\n  \\<forall>t\\<in>set [wordinterval_UNIV]. \\<not> wordinterval_empty t", "have\n      \"{} \\<notin> set (map wordinterval_to_set (partitioningIps (extract_IPSets rs) [wordinterval_UNIV]))\""], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>set ?ts. \\<not> wordinterval_empty t \\<Longrightarrow>\n  {} \\<notin> set (map wordinterval_to_set (partitioningIps ?ss ?ts))\n  \\<forall>t\\<in>set [wordinterval_UNIV]. \\<not> wordinterval_empty t\n\ngoal (1 subgoal):\n 1. {} \\<notin> set (map wordinterval_to_set\n                      (partitioningIps (extract_IPSets rs)\n                        [wordinterval_UNIV]))", "by blast"], ["proof (state)\nthis:\n  {} \\<notin> set (map wordinterval_to_set\n                    (partitioningIps (extract_IPSets rs)\n                      [wordinterval_UNIV]))\n\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set (partitioningIps (extract_IPSets rs)\n                         [wordinterval_UNIV]).\n       \\<not> wordinterval_empty w", "thus \"\\<forall>w\\<in>set (partitioningIps (extract_IPSets rs) [wordinterval_UNIV]). \\<not> wordinterval_empty w\""], ["proof (prove)\nusing this:\n  {} \\<notin> set (map wordinterval_to_set\n                    (partitioningIps (extract_IPSets rs)\n                      [wordinterval_UNIV]))\n\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set (partitioningIps (extract_IPSets rs)\n                         [wordinterval_UNIV]).\n       \\<not> wordinterval_empty w", "by auto"], ["proof (state)\nthis:\n  \\<forall>w\\<in>set (partitioningIps (extract_IPSets rs)\n                       [wordinterval_UNIV]).\n     \\<not> wordinterval_empty w\n\ngoal:\nNo subgoals!", "qed"], ["", "(* HELPER FUNCTIONS UNIFICATION *)"], ["", "fun getOneIp :: \"'a::len wordinterval \\<Rightarrow> 'a::len word\" where\n  \"getOneIp (WordInterval b _) = b\" |\n  \"getOneIp (RangeUnion r1 r2) = (if wordinterval_empty r1 then getOneIp r2\n                                                           else getOneIp r1)\""], ["", "lemma getOneIp_elem: \"\\<not> wordinterval_empty W \\<Longrightarrow> wordinterval_element (getOneIp W) W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> wordinterval_empty W \\<Longrightarrow>\n    wordinterval_element (getOneIp W) W", "by (induction W) simp_all"], ["", "record parts_connection = pc_iiface :: string\n                          pc_oiface :: string\n                          pc_proto :: primitive_protocol\n                          pc_sport :: \"16 word\"\n                          pc_dport :: \"16 word\""], ["", "(* SAME FW DEFINITIONS AND PROOFS *)"], ["", "definition same_fw_behaviour :: \"\\<^cancel>\\<open>'pkt_ext itself \\<Rightarrow>\\<close> 'i::len word \\<Rightarrow> 'i word \\<Rightarrow> 'i simple_rule list \\<Rightarrow> bool\" where\n  \"same_fw_behaviour \\<^cancel>\\<open>TYPE('pkt_ext)\\<close> a b rs \\<equiv>\n      \\<forall>(p:: 'i::len simple_packet).\n                simple_fw rs (p\\<lparr>p_src:=a\\<rparr>) = simple_fw rs (p\\<lparr>p_src:=b\\<rparr>) \\<and>\n                simple_fw rs (p\\<lparr>p_dst:=a\\<rparr>) = simple_fw rs (p\\<lparr>p_dst:=b\\<rparr>)\""], ["", "lemma getParts_same_fw_behaviour:\n  \"A \\<in> set (map wordinterval_to_set (getParts rs)) \\<Longrightarrow>  s1 \\<in> A \\<Longrightarrow> s2 \\<in> A \\<Longrightarrow> \n   same_fw_behaviour s1 s2 rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> set (map wordinterval_to_set (getParts rs));\n     s1 \\<in> A; s2 \\<in> A\\<rbrakk>\n    \\<Longrightarrow> same_fw_behaviour s1 s2 rs", "unfolding same_fw_behaviour_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> set (map wordinterval_to_set (getParts rs));\n     s1 \\<in> A; s2 \\<in> A\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p.\n                         simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n                         simple_fw rs (p\\<lparr>p_src := s2\\<rparr>) \\<and>\n                         simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n                         simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)", "using getParts_samefw"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> set (map wordinterval_to_set (getParts ?rs));\n   ?s1.0 \\<in> ?A; ?s2.0 \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> simple_fw ?rs (?p\\<lparr>p_src := ?s1.0\\<rparr>) =\n                    simple_fw ?rs (?p\\<lparr>p_src := ?s2.0\\<rparr>) \\<and>\n                    simple_fw ?rs (?p\\<lparr>p_dst := ?s1.0\\<rparr>) =\n                    simple_fw ?rs (?p\\<lparr>p_dst := ?s2.0\\<rparr>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> set (map wordinterval_to_set (getParts rs));\n     s1 \\<in> A; s2 \\<in> A\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p.\n                         simple_fw rs (p\\<lparr>p_src := s1\\<rparr>) =\n                         simple_fw rs (p\\<lparr>p_src := s2\\<rparr>) \\<and>\n                         simple_fw rs (p\\<lparr>p_dst := s1\\<rparr>) =\n                         simple_fw rs (p\\<lparr>p_dst := s2\\<rparr>)", "by blast"], ["", "definition \"runFw s d c rs = simple_fw rs \\<lparr>p_iiface=pc_iiface c,p_oiface=pc_oiface c,\n                          p_src=s,p_dst=d,\n                          p_proto=pc_proto c,\n                          p_sport=pc_sport c,p_dport=pc_dport c,\n                          p_tcp_flags={TCP_SYN},\n                          p_payload=''''\\<rparr>\""], ["", "text\\<open>We use @{const runFw} for executable code, but in general, everything applies to generic packets\\<close>"], ["", "definition runFw_scheme :: \"'i::len word \\<Rightarrow> 'i word \\<Rightarrow> 'b parts_connection_scheme \\<Rightarrow>\n                              ('i, 'a) simple_packet_scheme \\<Rightarrow> 'i simple_rule list \\<Rightarrow> state\"\n  where\n\"runFw_scheme s d c p rs = simple_fw rs\n                        (p\\<lparr>p_iiface:=pc_iiface c,\n                          p_oiface:=pc_oiface c,\n                          p_src:=s,\n                          p_dst:=d,\n                          p_proto:=pc_proto c,\n                          p_sport:=pc_sport c,\n                          p_dport:=pc_dport c\\<rparr>)\""], ["", "lemma runFw_scheme: \"runFw s d c rs = runFw_scheme s d c p rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runFw s d c rs = runFw_scheme s d c p rs", "apply(simp add: runFw_def runFw_scheme_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_fw rs\n     \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n        p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n        p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n        p_payload = []\\<rparr> =\n    simple_fw rs\n     (p\\<lparr>p_iiface := pc_iiface c, p_oiface := pc_oiface c, p_src := s,\n          p_dst := d, p_proto := pc_proto c, p_sport := pc_sport c,\n          p_dport := pc_dport c\\<rparr>)", "apply(case_tac p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p_iiface p_oiface p_src p_dst p_proto p_sport p_dport p_tcp_flags\n       p_payload more.\n       p =\n       \\<lparr>p_iiface = p_iiface, p_oiface = p_oiface, p_src = p_src,\n          p_dst = p_dst, p_proto = p_proto, p_sport = p_sport,\n          p_dport = p_dport, p_tcp_flags = p_tcp_flags,\n          p_payload = p_payload, \\<dots> = more\\<rparr> \\<Longrightarrow>\n       simple_fw rs\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr> =\n       simple_fw rs\n        (p\\<lparr>p_iiface := pc_iiface c, p_oiface := pc_oiface c,\n             p_src := s, p_dst := d, p_proto := pc_proto c,\n             p_sport := pc_sport c, p_dport := pc_dport c\\<rparr>)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p_iiface p_oiface p_src p_dst p_proto p_sport p_dport p_tcp_flags\n       p_payload more.\n       p =\n       \\<lparr>p_iiface = p_iiface, p_oiface = p_oiface, p_src = p_src,\n          p_dst = p_dst, p_proto = p_proto, p_sport = p_sport,\n          p_dport = p_dport, p_tcp_flags = p_tcp_flags,\n          p_payload = p_payload, \\<dots> = more\\<rparr> \\<Longrightarrow>\n       simple_fw rs\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr> =\n       simple_fw rs\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = p_tcp_flags,\n           p_payload = p_payload, \\<dots> = more\\<rparr>", "apply(thin_tac _, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p_tcp_flags p_payload more.\n       simple_fw rs\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr> =\n       simple_fw rs\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = p_tcp_flags,\n           p_payload = p_payload, \\<dots> = more\\<rparr>", "proof(induction rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p_tcp_flags p_payload more.\n       simple_fw []\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr> =\n       simple_fw []\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = p_tcp_flags,\n           p_payload = p_payload, \\<dots> = more\\<rparr>\n 2. \\<And>a rs p_tcp_flags p_payload more.\n       (\\<And>p_tcp_flags p_payload more.\n           simple_fw rs\n            \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n               p_src = s, p_dst = d, p_proto = pc_proto c,\n               p_sport = pc_sport c, p_dport = pc_dport c,\n               p_tcp_flags = {TCP_SYN}, p_payload = []\\<rparr> =\n           simple_fw rs\n            \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n               p_src = s, p_dst = d, p_proto = pc_proto c,\n               p_sport = pc_sport c, p_dport = pc_dport c,\n               p_tcp_flags = p_tcp_flags, p_payload = p_payload,\n               \\<dots> = more\\<rparr>) \\<Longrightarrow>\n       simple_fw (a # rs)\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr> =\n       simple_fw (a # rs)\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = p_tcp_flags,\n           p_payload = p_payload, \\<dots> = more\\<rparr>", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>p_tcp_flags p_payload more.\n       simple_fw []\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr> =\n       simple_fw []\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = p_tcp_flags,\n           p_payload = p_payload, \\<dots> = more\\<rparr>\n 2. \\<And>a rs p_tcp_flags p_payload more.\n       (\\<And>p_tcp_flags p_payload more.\n           simple_fw rs\n            \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n               p_src = s, p_dst = d, p_proto = pc_proto c,\n               p_sport = pc_sport c, p_dport = pc_dport c,\n               p_tcp_flags = {TCP_SYN}, p_payload = []\\<rparr> =\n           simple_fw rs\n            \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n               p_src = s, p_dst = d, p_proto = pc_proto c,\n               p_sport = pc_sport c, p_dport = pc_dport c,\n               p_tcp_flags = p_tcp_flags, p_payload = p_payload,\n               \\<dots> = more\\<rparr>) \\<Longrightarrow>\n       simple_fw (a # rs)\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr> =\n       simple_fw (a # rs)\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = p_tcp_flags,\n           p_payload = p_payload, \\<dots> = more\\<rparr>", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_fw []\n     \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n        p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n        p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n        p_payload = []\\<rparr> =\n    simple_fw []\n     \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n        p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n        p_dport = pc_dport c, p_tcp_flags = p_tcp_flags,\n        p_payload = p_payload, \\<dots> = more\\<rparr>", "by(simp; fail)"], ["proof (state)\nthis:\n  simple_fw []\n   \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n      p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n      p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n      p_payload = []\\<rparr> =\n  simple_fw []\n   \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n      p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n      p_dport = pc_dport c, p_tcp_flags = p_tcp_flags,\n      p_payload = p_payload, \\<dots> = more\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a rs p_tcp_flags p_payload more.\n       (\\<And>p_tcp_flags p_payload more.\n           simple_fw rs\n            \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n               p_src = s, p_dst = d, p_proto = pc_proto c,\n               p_sport = pc_sport c, p_dport = pc_dport c,\n               p_tcp_flags = {TCP_SYN}, p_payload = []\\<rparr> =\n           simple_fw rs\n            \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n               p_src = s, p_dst = d, p_proto = pc_proto c,\n               p_sport = pc_sport c, p_dport = pc_dport c,\n               p_tcp_flags = p_tcp_flags, p_payload = p_payload,\n               \\<dots> = more\\<rparr>) \\<Longrightarrow>\n       simple_fw (a # rs)\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr> =\n       simple_fw (a # rs)\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = p_tcp_flags,\n           p_payload = p_payload, \\<dots> = more\\<rparr>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a rs p_tcp_flags p_payload more.\n       (\\<And>p_tcp_flags p_payload more.\n           simple_fw rs\n            \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n               p_src = s, p_dst = d, p_proto = pc_proto c,\n               p_sport = pc_sport c, p_dport = pc_dport c,\n               p_tcp_flags = {TCP_SYN}, p_payload = []\\<rparr> =\n           simple_fw rs\n            \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n               p_src = s, p_dst = d, p_proto = pc_proto c,\n               p_sport = pc_sport c, p_dport = pc_dport c,\n               p_tcp_flags = p_tcp_flags, p_payload = p_payload,\n               \\<dots> = more\\<rparr>) \\<Longrightarrow>\n       simple_fw (a # rs)\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr> =\n       simple_fw (a # rs)\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = p_tcp_flags,\n           p_payload = p_payload, \\<dots> = more\\<rparr>", "case(Cons r rs)"], ["proof (state)\nthis:\n  simple_fw rs\n   \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n      p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n      p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n      p_payload = []\\<rparr> =\n  simple_fw rs\n   \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n      p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n      p_dport = pc_dport c, p_tcp_flags = ?p_tcp_flags,\n      p_payload = ?p_payload, \\<dots> = ?more\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a rs p_tcp_flags p_payload more.\n       (\\<And>p_tcp_flags p_payload more.\n           simple_fw rs\n            \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n               p_src = s, p_dst = d, p_proto = pc_proto c,\n               p_sport = pc_sport c, p_dport = pc_dport c,\n               p_tcp_flags = {TCP_SYN}, p_payload = []\\<rparr> =\n           simple_fw rs\n            \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n               p_src = s, p_dst = d, p_proto = pc_proto c,\n               p_sport = pc_sport c, p_dport = pc_dport c,\n               p_tcp_flags = p_tcp_flags, p_payload = p_payload,\n               \\<dots> = more\\<rparr>) \\<Longrightarrow>\n       simple_fw (a # rs)\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr> =\n       simple_fw (a # rs)\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = p_tcp_flags,\n           p_payload = p_payload, \\<dots> = more\\<rparr>", "obtain m a where r: \"r = SimpleRule m a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m a.\n        r = SimpleRule m a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases r) simp"], ["proof (state)\nthis:\n  r = SimpleRule m a\n\ngoal (1 subgoal):\n 1. \\<And>a rs p_tcp_flags p_payload more.\n       (\\<And>p_tcp_flags p_payload more.\n           simple_fw rs\n            \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n               p_src = s, p_dst = d, p_proto = pc_proto c,\n               p_sport = pc_sport c, p_dport = pc_dport c,\n               p_tcp_flags = {TCP_SYN}, p_payload = []\\<rparr> =\n           simple_fw rs\n            \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n               p_src = s, p_dst = d, p_proto = pc_proto c,\n               p_sport = pc_sport c, p_dport = pc_dport c,\n               p_tcp_flags = p_tcp_flags, p_payload = p_payload,\n               \\<dots> = more\\<rparr>) \\<Longrightarrow>\n       simple_fw (a # rs)\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr> =\n       simple_fw (a # rs)\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = p_tcp_flags,\n           p_payload = p_payload, \\<dots> = more\\<rparr>", "from simple_matches_extended_packet[symmetric, of _ \"pc_iiface c\" \"pc_oiface c\"\n                                      s d \"pc_proto c\" \"pc_sport c\" \"pc_dport c\" _ _ _ \"{TCP_SYN}\" \"[]\"]"], ["proof (chain)\npicking this:\n  simple_matches ?m\n   \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n      p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n      p_dport = pc_dport c, p_tcp_flags = ?tcp_flags2.0,\n      p_payload = ?payload2.0, \\<dots> = ?aux\\<rparr> =\n  simple_matches ?m\n   \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n      p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n      p_dport = pc_dport c, p_tcp_flags = {TCP_SYN}, p_payload = []\\<rparr>", "have pext: \"simple_matches m\n   \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s, p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c, p_dport = pc_dport c,\n      p_tcp_flags = tcp_flags2, p_payload = payload2, \\<dots> = aux\\<rparr> =\n  simple_matches m\n   \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s, p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c, p_dport = pc_dport c,\n      p_tcp_flags = {TCP_SYN}, p_payload = []\\<rparr>\" for tcp_flags2 payload2 and aux::'c"], ["proof (prove)\nusing this:\n  simple_matches ?m\n   \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n      p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n      p_dport = pc_dport c, p_tcp_flags = ?tcp_flags2.0,\n      p_payload = ?payload2.0, \\<dots> = ?aux\\<rparr> =\n  simple_matches ?m\n   \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n      p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n      p_dport = pc_dport c, p_tcp_flags = {TCP_SYN}, p_payload = []\\<rparr>\n\ngoal (1 subgoal):\n 1. simple_matches m\n     \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n        p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n        p_dport = pc_dport c, p_tcp_flags = tcp_flags2,\n        p_payload = payload2, \\<dots> = aux\\<rparr> =\n    simple_matches m\n     \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n        p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n        p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n        p_payload = []\\<rparr>", "by fast"], ["proof (state)\nthis:\n  simple_matches m\n   \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n      p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n      p_dport = pc_dport c, p_tcp_flags = ?tcp_flags2.0,\n      p_payload = ?payload2.0, \\<dots> = ?aux\\<rparr> =\n  simple_matches m\n   \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n      p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n      p_dport = pc_dport c, p_tcp_flags = {TCP_SYN}, p_payload = []\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a rs p_tcp_flags p_payload more.\n       (\\<And>p_tcp_flags p_payload more.\n           simple_fw rs\n            \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n               p_src = s, p_dst = d, p_proto = pc_proto c,\n               p_sport = pc_sport c, p_dport = pc_dport c,\n               p_tcp_flags = {TCP_SYN}, p_payload = []\\<rparr> =\n           simple_fw rs\n            \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n               p_src = s, p_dst = d, p_proto = pc_proto c,\n               p_sport = pc_sport c, p_dport = pc_dport c,\n               p_tcp_flags = p_tcp_flags, p_payload = p_payload,\n               \\<dots> = more\\<rparr>) \\<Longrightarrow>\n       simple_fw (a # rs)\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr> =\n       simple_fw (a # rs)\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = p_tcp_flags,\n           p_payload = p_payload, \\<dots> = more\\<rparr>", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_fw (r # rs)\n     \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n        p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n        p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n        p_payload = []\\<rparr> =\n    simple_fw (r # rs)\n     \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n        p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n        p_dport = pc_dport c, p_tcp_flags = p_tcp_flags,\n        p_payload = p_payload, \\<dots> = more\\<rparr>", "apply(simp add: r, cases a, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. a = Accept \\<Longrightarrow>\n    (simple_matches m\n      \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n         p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n         p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n         p_payload = []\\<rparr> \\<longrightarrow>\n     \\<not> simple_matches m\n             \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n                p_src = s, p_dst = d, p_proto = pc_proto c,\n                p_sport = pc_sport c, p_dport = pc_dport c,\n                p_tcp_flags = p_tcp_flags, p_payload = p_payload,\n                \\<dots> = more\\<rparr> \\<longrightarrow>\n     Decision FinalAllow =\n     simple_fw rs\n      \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n         p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n         p_dport = pc_dport c, p_tcp_flags = p_tcp_flags,\n         p_payload = p_payload, \\<dots> = more\\<rparr>) \\<and>\n    (\\<not> simple_matches m\n             \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n                p_src = s, p_dst = d, p_proto = pc_proto c,\n                p_sport = pc_sport c, p_dport = pc_dport c,\n                p_tcp_flags = {TCP_SYN},\n                p_payload = []\\<rparr> \\<longrightarrow>\n     (simple_matches m\n       \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n          p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n          p_dport = pc_dport c, p_tcp_flags = p_tcp_flags,\n          p_payload = p_payload, \\<dots> = more\\<rparr> \\<longrightarrow>\n      simple_fw rs\n       \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n          p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n          p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n          p_payload = []\\<rparr> =\n      Decision FinalAllow) \\<and>\n     (\\<not> simple_matches m\n              \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n                 p_src = s, p_dst = d, p_proto = pc_proto c,\n                 p_sport = pc_sport c, p_dport = pc_dport c,\n                 p_tcp_flags = p_tcp_flags, p_payload = p_payload,\n                 \\<dots> = more\\<rparr> \\<longrightarrow>\n      simple_fw rs\n       \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n          p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n          p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n          p_payload = []\\<rparr> =\n      simple_fw rs\n       \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n          p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n          p_dport = pc_dport c, p_tcp_flags = p_tcp_flags,\n          p_payload = p_payload, \\<dots> = more\\<rparr>))\n 2. a = Drop \\<Longrightarrow>\n    simple_fw (SimpleRule m a # rs)\n     \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n        p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n        p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n        p_payload = []\\<rparr> =\n    simple_fw (SimpleRule m a # rs)\n     \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n        p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n        p_dport = pc_dport c, p_tcp_flags = p_tcp_flags,\n        p_payload = p_payload, \\<dots> = more\\<rparr>", "using Cons.IH"], ["proof (prove)\nusing this:\n  simple_fw rs\n   \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n      p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n      p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n      p_payload = []\\<rparr> =\n  simple_fw rs\n   \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n      p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n      p_dport = pc_dport c, p_tcp_flags = ?p_tcp_flags,\n      p_payload = ?p_payload, \\<dots> = ?more\\<rparr>\n\ngoal (2 subgoals):\n 1. a = Accept \\<Longrightarrow>\n    (simple_matches m\n      \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n         p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n         p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n         p_payload = []\\<rparr> \\<longrightarrow>\n     \\<not> simple_matches m\n             \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n                p_src = s, p_dst = d, p_proto = pc_proto c,\n                p_sport = pc_sport c, p_dport = pc_dport c,\n                p_tcp_flags = p_tcp_flags, p_payload = p_payload,\n                \\<dots> = more\\<rparr> \\<longrightarrow>\n     Decision FinalAllow =\n     simple_fw rs\n      \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n         p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n         p_dport = pc_dport c, p_tcp_flags = p_tcp_flags,\n         p_payload = p_payload, \\<dots> = more\\<rparr>) \\<and>\n    (\\<not> simple_matches m\n             \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n                p_src = s, p_dst = d, p_proto = pc_proto c,\n                p_sport = pc_sport c, p_dport = pc_dport c,\n                p_tcp_flags = {TCP_SYN},\n                p_payload = []\\<rparr> \\<longrightarrow>\n     (simple_matches m\n       \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n          p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n          p_dport = pc_dport c, p_tcp_flags = p_tcp_flags,\n          p_payload = p_payload, \\<dots> = more\\<rparr> \\<longrightarrow>\n      simple_fw rs\n       \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n          p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n          p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n          p_payload = []\\<rparr> =\n      Decision FinalAllow) \\<and>\n     (\\<not> simple_matches m\n              \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n                 p_src = s, p_dst = d, p_proto = pc_proto c,\n                 p_sport = pc_sport c, p_dport = pc_dport c,\n                 p_tcp_flags = p_tcp_flags, p_payload = p_payload,\n                 \\<dots> = more\\<rparr> \\<longrightarrow>\n      simple_fw rs\n       \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n          p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n          p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n          p_payload = []\\<rparr> =\n      simple_fw rs\n       \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n          p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n          p_dport = pc_dport c, p_tcp_flags = p_tcp_flags,\n          p_payload = p_payload, \\<dots> = more\\<rparr>))\n 2. a = Drop \\<Longrightarrow>\n    simple_fw (SimpleRule m a # rs)\n     \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n        p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n        p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n        p_payload = []\\<rparr> =\n    simple_fw (SimpleRule m a # rs)\n     \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n        p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n        p_dport = pc_dport c, p_tcp_flags = p_tcp_flags,\n        p_payload = p_payload, \\<dots> = more\\<rparr>", "by(simp add: pext)+"], ["proof (state)\nthis:\n  simple_fw (r # rs)\n   \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n      p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n      p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n      p_payload = []\\<rparr> =\n  simple_fw (r # rs)\n   \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n      p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n      p_dport = pc_dport c, p_tcp_flags = p_tcp_flags,\n      p_payload = p_payload, \\<dots> = more\\<rparr>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_default_policy_runFw: \"has_default_policy rs \\<Longrightarrow> runFw s d c rs = Decision FinalAllow \\<or> runFw s d c rs = Decision FinalDeny\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_default_policy rs \\<Longrightarrow>\n    runFw s d c rs = Decision FinalAllow \\<or>\n    runFw s d c rs = Decision FinalDeny", "by(simp add: runFw_def has_default_policy)"], ["", "definition same_fw_behaviour_one :: \"'i::len word \\<Rightarrow> 'i word \\<Rightarrow> 'a parts_connection_scheme \\<Rightarrow> 'i simple_rule list \\<Rightarrow> bool\" where\n  \"same_fw_behaviour_one ip1 ip2 c rs \\<equiv>\n            \\<forall>d s. runFw ip1 d c rs = runFw ip2 d c rs \\<and> runFw s ip1 c rs = runFw s ip2 c rs\""], ["", "lemma same_fw_spec: \"same_fw_behaviour ip1 ip2 rs \\<Longrightarrow> same_fw_behaviour_one ip1 ip2 c rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. same_fw_behaviour ip1 ip2 rs \\<Longrightarrow>\n    same_fw_behaviour_one ip1 ip2 c rs", "apply(simp add: same_fw_behaviour_def same_fw_behaviour_one_def runFw_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p.\n       simple_fw rs (p\\<lparr>p_src := ip1\\<rparr>) =\n       simple_fw rs (p\\<lparr>p_src := ip2\\<rparr>) \\<and>\n       simple_fw rs (p\\<lparr>p_dst := ip1\\<rparr>) =\n       simple_fw rs (p\\<lparr>p_dst := ip2\\<rparr>) \\<Longrightarrow>\n    (\\<forall>d.\n        simple_fw rs\n         \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n            p_src = ip1, p_dst = d, p_proto = pc_proto c,\n            p_sport = pc_sport c, p_dport = pc_dport c,\n            p_tcp_flags = {TCP_SYN}, p_payload = []\\<rparr> =\n        simple_fw rs\n         \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n            p_src = ip2, p_dst = d, p_proto = pc_proto c,\n            p_sport = pc_sport c, p_dport = pc_dport c,\n            p_tcp_flags = {TCP_SYN}, p_payload = []\\<rparr>) \\<and>\n    (\\<forall>s.\n        simple_fw rs\n         \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n            p_dst = ip1, p_proto = pc_proto c, p_sport = pc_sport c,\n            p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n            p_payload = []\\<rparr> =\n        simple_fw rs\n         \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n            p_dst = ip2, p_proto = pc_proto c, p_sport = pc_sport c,\n            p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n            p_payload = []\\<rparr>)", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>p.\n       simple_fw rs (p\\<lparr>p_src := ip1\\<rparr>) =\n       simple_fw rs (p\\<lparr>p_src := ip2\\<rparr>) \\<and>\n       simple_fw rs (p\\<lparr>p_dst := ip1\\<rparr>) =\n       simple_fw rs (p\\<lparr>p_dst := ip2\\<rparr>) \\<Longrightarrow>\n    \\<forall>d.\n       simple_fw rs\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = ip1,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr> =\n       simple_fw rs\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = ip2,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr>\n 2. \\<forall>p.\n       simple_fw rs (p\\<lparr>p_src := ip1\\<rparr>) =\n       simple_fw rs (p\\<lparr>p_src := ip2\\<rparr>) \\<and>\n       simple_fw rs (p\\<lparr>p_dst := ip1\\<rparr>) =\n       simple_fw rs (p\\<lparr>p_dst := ip2\\<rparr>) \\<Longrightarrow>\n    \\<forall>s.\n       simple_fw rs\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = ip1, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr> =\n       simple_fw rs\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = ip2, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr>", "apply(clarify)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>d.\n       \\<forall>p.\n          simple_fw rs (p\\<lparr>p_src := ip1\\<rparr>) =\n          simple_fw rs (p\\<lparr>p_src := ip2\\<rparr>) \\<and>\n          simple_fw rs (p\\<lparr>p_dst := ip1\\<rparr>) =\n          simple_fw rs (p\\<lparr>p_dst := ip2\\<rparr>) \\<Longrightarrow>\n       simple_fw rs\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = ip1,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr> =\n       simple_fw rs\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = ip2,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr>\n 2. \\<forall>p.\n       simple_fw rs (p\\<lparr>p_src := ip1\\<rparr>) =\n       simple_fw rs (p\\<lparr>p_src := ip2\\<rparr>) \\<and>\n       simple_fw rs (p\\<lparr>p_dst := ip1\\<rparr>) =\n       simple_fw rs (p\\<lparr>p_dst := ip2\\<rparr>) \\<Longrightarrow>\n    \\<forall>s.\n       simple_fw rs\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = ip1, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr> =\n       simple_fw rs\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = ip2, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr>", "apply(erule_tac x=\"\\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = ip1, p_dst= d,\n                       p_proto = pc_proto c, p_sport = pc_sport c, p_dport = pc_dport c,\n                       p_tcp_flags = {TCP_SYN},\n                       p_payload=''''\\<rparr>\" in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>d.\n       simple_fw rs\n        (\\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n            p_src = ip1, p_dst = d, p_proto = pc_proto c,\n            p_sport = pc_sport c, p_dport = pc_dport c,\n            p_tcp_flags = {TCP_SYN}, p_payload = []\\<rparr>\n         \\<lparr>p_src := ip1\\<rparr>) =\n       simple_fw rs\n        (\\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n            p_src = ip1, p_dst = d, p_proto = pc_proto c,\n            p_sport = pc_sport c, p_dport = pc_dport c,\n            p_tcp_flags = {TCP_SYN}, p_payload = []\\<rparr>\n         \\<lparr>p_src := ip2\\<rparr>) \\<and>\n       simple_fw rs\n        (\\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n            p_src = ip1, p_dst = d, p_proto = pc_proto c,\n            p_sport = pc_sport c, p_dport = pc_dport c,\n            p_tcp_flags = {TCP_SYN}, p_payload = []\\<rparr>\n         \\<lparr>p_dst := ip1\\<rparr>) =\n       simple_fw rs\n        (\\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n            p_src = ip1, p_dst = d, p_proto = pc_proto c,\n            p_sport = pc_sport c, p_dport = pc_dport c,\n            p_tcp_flags = {TCP_SYN}, p_payload = []\\<rparr>\n         \\<lparr>p_dst := ip2\\<rparr>) \\<Longrightarrow>\n       simple_fw rs\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = ip1,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr> =\n       simple_fw rs\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = ip2,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr>\n 2. \\<forall>p.\n       simple_fw rs (p\\<lparr>p_src := ip1\\<rparr>) =\n       simple_fw rs (p\\<lparr>p_src := ip2\\<rparr>) \\<and>\n       simple_fw rs (p\\<lparr>p_dst := ip1\\<rparr>) =\n       simple_fw rs (p\\<lparr>p_dst := ip2\\<rparr>) \\<Longrightarrow>\n    \\<forall>s.\n       simple_fw rs\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = ip1, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr> =\n       simple_fw rs\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = ip2, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr>", "apply(simp;fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p.\n       simple_fw rs (p\\<lparr>p_src := ip1\\<rparr>) =\n       simple_fw rs (p\\<lparr>p_src := ip2\\<rparr>) \\<and>\n       simple_fw rs (p\\<lparr>p_dst := ip1\\<rparr>) =\n       simple_fw rs (p\\<lparr>p_dst := ip2\\<rparr>) \\<Longrightarrow>\n    \\<forall>s.\n       simple_fw rs\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = ip1, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr> =\n       simple_fw rs\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = ip2, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr>", "apply(clarify)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<forall>p.\n          simple_fw rs (p\\<lparr>p_src := ip1\\<rparr>) =\n          simple_fw rs (p\\<lparr>p_src := ip2\\<rparr>) \\<and>\n          simple_fw rs (p\\<lparr>p_dst := ip1\\<rparr>) =\n          simple_fw rs (p\\<lparr>p_dst := ip2\\<rparr>) \\<Longrightarrow>\n       simple_fw rs\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = ip1, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr> =\n       simple_fw rs\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = ip2, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr>", "apply(erule_tac x=\"\\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s, p_dst= ip1,\n                       p_proto = pc_proto c, p_sport = pc_sport c, p_dport = pc_dport c,\n                       p_tcp_flags = {TCP_SYN},\n                       p_payload=''''\\<rparr>\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       simple_fw rs\n        (\\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n            p_dst = ip1, p_proto = pc_proto c, p_sport = pc_sport c,\n            p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n            p_payload = []\\<rparr>\n         \\<lparr>p_src := ip1\\<rparr>) =\n       simple_fw rs\n        (\\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n            p_dst = ip1, p_proto = pc_proto c, p_sport = pc_sport c,\n            p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n            p_payload = []\\<rparr>\n         \\<lparr>p_src := ip2\\<rparr>) \\<and>\n       simple_fw rs\n        (\\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n            p_dst = ip1, p_proto = pc_proto c, p_sport = pc_sport c,\n            p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n            p_payload = []\\<rparr>\n         \\<lparr>p_dst := ip1\\<rparr>) =\n       simple_fw rs\n        (\\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n            p_dst = ip1, p_proto = pc_proto c, p_sport = pc_sport c,\n            p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n            p_payload = []\\<rparr>\n         \\<lparr>p_dst := ip2\\<rparr>) \\<Longrightarrow>\n       simple_fw rs\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = ip1, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr> =\n       simple_fw rs\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = ip2, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr>", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>Is an equivalence relation\\<close>"], ["", "lemma same_fw_behaviour_one_equi:\n  \"same_fw_behaviour_one x x c rs\"\n  \"same_fw_behaviour_one x y c rs = same_fw_behaviour_one y x c rs\"\n  \"same_fw_behaviour_one x y c rs \\<and> same_fw_behaviour_one y z c rs \\<Longrightarrow> same_fw_behaviour_one x z c rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. same_fw_behaviour_one x x c rs &&&\n    same_fw_behaviour_one x y c rs = same_fw_behaviour_one y x c rs &&&\n    (same_fw_behaviour_one x y c rs \\<and>\n     same_fw_behaviour_one y z c rs \\<Longrightarrow>\n     same_fw_behaviour_one x z c rs)", "unfolding same_fw_behaviour_one_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>d s.\n       runFw x d c rs = runFw x d c rs \\<and>\n       runFw s x c rs = runFw s x c rs &&&\n    (\\<forall>d s.\n        runFw x d c rs = runFw y d c rs \\<and>\n        runFw s x c rs = runFw s y c rs) =\n    (\\<forall>d s.\n        runFw y d c rs = runFw x d c rs \\<and>\n        runFw s y c rs = runFw s x c rs) &&&\n    ((\\<forall>d s.\n         runFw x d c rs = runFw y d c rs \\<and>\n         runFw s x c rs = runFw s y c rs) \\<and>\n     (\\<forall>d s.\n         runFw y d c rs = runFw z d c rs \\<and>\n         runFw s y c rs = runFw s z c rs) \\<Longrightarrow>\n     \\<forall>d s.\n        runFw x d c rs = runFw z d c rs \\<and>\n        runFw s x c rs = runFw s z c rs)", "by metis+"], ["", "lemma same_fw_behaviour_equi:\n  \"same_fw_behaviour x x rs\"\n  \"same_fw_behaviour x y rs = same_fw_behaviour y x rs\"\n  \"same_fw_behaviour x y rs \\<and> same_fw_behaviour y z rs \\<Longrightarrow> same_fw_behaviour x z rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. same_fw_behaviour x x rs &&&\n    same_fw_behaviour x y rs = same_fw_behaviour y x rs &&&\n    (same_fw_behaviour x y rs \\<and>\n     same_fw_behaviour y z rs \\<Longrightarrow>\n     same_fw_behaviour x z rs)", "unfolding same_fw_behaviour_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p.\n       simple_fw rs (p\\<lparr>p_src := x\\<rparr>) =\n       simple_fw rs (p\\<lparr>p_src := x\\<rparr>) \\<and>\n       simple_fw rs (p\\<lparr>p_dst := x\\<rparr>) =\n       simple_fw rs (p\\<lparr>p_dst := x\\<rparr>) &&&\n    (\\<forall>p.\n        simple_fw rs (p\\<lparr>p_src := x\\<rparr>) =\n        simple_fw rs (p\\<lparr>p_src := y\\<rparr>) \\<and>\n        simple_fw rs (p\\<lparr>p_dst := x\\<rparr>) =\n        simple_fw rs (p\\<lparr>p_dst := y\\<rparr>)) =\n    (\\<forall>p.\n        simple_fw rs (p\\<lparr>p_src := y\\<rparr>) =\n        simple_fw rs (p\\<lparr>p_src := x\\<rparr>) \\<and>\n        simple_fw rs (p\\<lparr>p_dst := y\\<rparr>) =\n        simple_fw rs (p\\<lparr>p_dst := x\\<rparr>)) &&&\n    ((\\<forall>p.\n         simple_fw rs (p\\<lparr>p_src := x\\<rparr>) =\n         simple_fw rs (p\\<lparr>p_src := y\\<rparr>) \\<and>\n         simple_fw rs (p\\<lparr>p_dst := x\\<rparr>) =\n         simple_fw rs (p\\<lparr>p_dst := y\\<rparr>)) \\<and>\n     (\\<forall>p.\n         simple_fw rs (p\\<lparr>p_src := y\\<rparr>) =\n         simple_fw rs (p\\<lparr>p_src := z\\<rparr>) \\<and>\n         simple_fw rs (p\\<lparr>p_dst := y\\<rparr>) =\n         simple_fw rs (p\\<lparr>p_dst := z\\<rparr>)) \\<Longrightarrow>\n     \\<forall>p.\n        simple_fw rs (p\\<lparr>p_src := x\\<rparr>) =\n        simple_fw rs (p\\<lparr>p_src := z\\<rparr>) \\<and>\n        simple_fw rs (p\\<lparr>p_dst := x\\<rparr>) =\n        simple_fw rs (p\\<lparr>p_dst := z\\<rparr>))", "by auto"], ["", "lemma runFw_sameFw_behave: \n       fixes W :: \"'i::len word set set\"\n       shows\n       \"\\<forall>A \\<in> W. \\<forall>a1 \\<in> A. \\<forall>a2 \\<in> A. same_fw_behaviour_one a1 a2 c rs \\<Longrightarrow> \\<Union> W = UNIV \\<Longrightarrow>\n       \\<forall>B \\<in> W. \\<exists>b \\<in> B. runFw ip1 b c rs = runFw ip2 b c rs \\<Longrightarrow>\n       \\<forall>B \\<in> W. \\<exists>b \\<in> B. runFw b ip1 c rs = runFw b ip2 c rs \\<Longrightarrow>\n       same_fw_behaviour_one ip1 ip2 c rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>A\\<in>W.\n                \\<forall>a1\\<in>A.\n                   \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs;\n     \\<Union> W = UNIV;\n     \\<forall>B\\<in>W.\n        \\<exists>b\\<in>B. runFw ip1 b c rs = runFw ip2 b c rs;\n     \\<forall>B\\<in>W.\n        \\<exists>b\\<in>B. runFw b ip1 c rs = runFw b ip2 c rs\\<rbrakk>\n    \\<Longrightarrow> same_fw_behaviour_one ip1 ip2 c rs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>A\\<in>W.\n                \\<forall>a1\\<in>A.\n                   \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs;\n     \\<Union> W = UNIV;\n     \\<forall>B\\<in>W.\n        \\<exists>b\\<in>B. runFw ip1 b c rs = runFw ip2 b c rs;\n     \\<forall>B\\<in>W.\n        \\<exists>b\\<in>B. runFw b ip1 c rs = runFw b ip2 c rs\\<rbrakk>\n    \\<Longrightarrow> same_fw_behaviour_one ip1 ip2 c rs", "assume a1: \"\\<forall>A \\<in> W. \\<forall>a1 \\<in> A. \\<forall>a2 \\<in> A. same_fw_behaviour_one a1 a2 c rs\"\n   and a2: \"\\<Union> W = UNIV \"\n   and a3: \"\\<forall>B \\<in> W. \\<exists>b \\<in> B. runFw ip1 b c rs = runFw ip2 b c rs\"\n   and a4: \"\\<forall>B \\<in> W. \\<exists>b \\<in> B. runFw b ip1 c rs = runFw b ip2 c rs\""], ["proof (state)\nthis:\n  \\<forall>A\\<in>W.\n     \\<forall>a1\\<in>A. \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs\n  \\<Union> W = UNIV\n  \\<forall>B\\<in>W. \\<exists>b\\<in>B. runFw ip1 b c rs = runFw ip2 b c rs\n  \\<forall>B\\<in>W. \\<exists>b\\<in>B. runFw b ip1 c rs = runFw b ip2 c rs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>A\\<in>W.\n                \\<forall>a1\\<in>A.\n                   \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs;\n     \\<Union> W = UNIV;\n     \\<forall>B\\<in>W.\n        \\<exists>b\\<in>B. runFw ip1 b c rs = runFw ip2 b c rs;\n     \\<forall>B\\<in>W.\n        \\<exists>b\\<in>B. runFw b ip1 c rs = runFw b ip2 c rs\\<rbrakk>\n    \\<Longrightarrow> same_fw_behaviour_one ip1 ip2 c rs", "have relation_lem: \"\\<forall>D \\<in> W. \\<forall>d1 \\<in> D. \\<forall>d2 \\<in> D. \\<forall>s. f s d1 = f s d2 \\<Longrightarrow> \\<Union> W = UNIV \\<Longrightarrow>\n                     \\<forall>B \\<in> W. \\<exists>b \\<in> B. f s1 b = f s2 b \\<Longrightarrow>\n                     f s1 d = f s2 d\" for W and f::\"'c \\<Rightarrow> 'b \\<Rightarrow> 'd\" and s1 d s2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>D\\<in>W.\n                \\<forall>d1\\<in>D.\n                   \\<forall>d2\\<in>D. \\<forall>s. f s d1 = f s d2;\n     \\<Union> W = UNIV;\n     \\<forall>B\\<in>W. \\<exists>b\\<in>B. f s1 b = f s2 b\\<rbrakk>\n    \\<Longrightarrow> f s1 d = f s2 d", "by (metis UNIV_I Union_iff)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>D\\<in>?W1.\n              \\<forall>d1\\<in>D.\n                 \\<forall>d2\\<in>D. \\<forall>s. ?f1 s d1 = ?f1 s d2;\n   \\<Union> ?W1 = UNIV;\n   \\<forall>B\\<in>?W1. \\<exists>b\\<in>B. ?f1 ?s1.1 b = ?f1 ?s2.1 b\\<rbrakk>\n  \\<Longrightarrow> ?f1 ?s1.1 ?d1 = ?f1 ?s2.1 ?d1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>A\\<in>W.\n                \\<forall>a1\\<in>A.\n                   \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs;\n     \\<Union> W = UNIV;\n     \\<forall>B\\<in>W.\n        \\<exists>b\\<in>B. runFw ip1 b c rs = runFw ip2 b c rs;\n     \\<forall>B\\<in>W.\n        \\<exists>b\\<in>B. runFw b ip1 c rs = runFw b ip2 c rs\\<rbrakk>\n    \\<Longrightarrow> same_fw_behaviour_one ip1 ip2 c rs", "from a1"], ["proof (chain)\npicking this:\n  \\<forall>A\\<in>W.\n     \\<forall>a1\\<in>A. \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs", "have a1':\"\\<forall>A\\<in>W. \\<forall>a1\\<in>A. \\<forall>a2\\<in>A. \\<forall>s. runFw s a1 c rs = runFw s a2 c rs\""], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>W.\n     \\<forall>a1\\<in>A. \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>W.\n       \\<forall>a1\\<in>A.\n          \\<forall>a2\\<in>A. \\<forall>s. runFw s a1 c rs = runFw s a2 c rs", "unfolding same_fw_behaviour_one_def"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>W.\n     \\<forall>a1\\<in>A.\n        \\<forall>a2\\<in>A.\n           \\<forall>d s.\n              runFw a1 d c rs = runFw a2 d c rs \\<and>\n              runFw s a1 c rs = runFw s a2 c rs\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>W.\n       \\<forall>a1\\<in>A.\n          \\<forall>a2\\<in>A. \\<forall>s. runFw s a1 c rs = runFw s a2 c rs", "by fast"], ["proof (state)\nthis:\n  \\<forall>A\\<in>W.\n     \\<forall>a1\\<in>A.\n        \\<forall>a2\\<in>A. \\<forall>s. runFw s a1 c rs = runFw s a2 c rs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>A\\<in>W.\n                \\<forall>a1\\<in>A.\n                   \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs;\n     \\<Union> W = UNIV;\n     \\<forall>B\\<in>W.\n        \\<exists>b\\<in>B. runFw ip1 b c rs = runFw ip2 b c rs;\n     \\<forall>B\\<in>W.\n        \\<exists>b\\<in>B. runFw b ip1 c rs = runFw b ip2 c rs\\<rbrakk>\n    \\<Longrightarrow> same_fw_behaviour_one ip1 ip2 c rs", "from relation_lem[OF a1' a2 a3]"], ["proof (chain)\npicking this:\n  runFw ip1 ?d1 c rs = runFw ip2 ?d1 c rs", "have s1: \"\\<And> d. runFw ip1 d c rs = runFw ip2 d c rs\""], ["proof (prove)\nusing this:\n  runFw ip1 ?d1 c rs = runFw ip2 ?d1 c rs\n\ngoal (1 subgoal):\n 1. \\<And>d. runFw ip1 d c rs = runFw ip2 d c rs", "by simp"], ["proof (state)\nthis:\n  runFw ip1 ?d1 c rs = runFw ip2 ?d1 c rs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>A\\<in>W.\n                \\<forall>a1\\<in>A.\n                   \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs;\n     \\<Union> W = UNIV;\n     \\<forall>B\\<in>W.\n        \\<exists>b\\<in>B. runFw ip1 b c rs = runFw ip2 b c rs;\n     \\<forall>B\\<in>W.\n        \\<exists>b\\<in>B. runFw b ip1 c rs = runFw b ip2 c rs\\<rbrakk>\n    \\<Longrightarrow> same_fw_behaviour_one ip1 ip2 c rs", "from a1"], ["proof (chain)\npicking this:\n  \\<forall>A\\<in>W.\n     \\<forall>a1\\<in>A. \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs", "have a1'':\"\\<forall>A\\<in>W. \\<forall>a1\\<in>A. \\<forall>a2\\<in>A. \\<forall>d. runFw a1 d c rs = runFw a2 d c rs\""], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>W.\n     \\<forall>a1\\<in>A. \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>W.\n       \\<forall>a1\\<in>A.\n          \\<forall>a2\\<in>A. \\<forall>d. runFw a1 d c rs = runFw a2 d c rs", "unfolding same_fw_behaviour_one_def"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>W.\n     \\<forall>a1\\<in>A.\n        \\<forall>a2\\<in>A.\n           \\<forall>d s.\n              runFw a1 d c rs = runFw a2 d c rs \\<and>\n              runFw s a1 c rs = runFw s a2 c rs\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>W.\n       \\<forall>a1\\<in>A.\n          \\<forall>a2\\<in>A. \\<forall>d. runFw a1 d c rs = runFw a2 d c rs", "by fast"], ["proof (state)\nthis:\n  \\<forall>A\\<in>W.\n     \\<forall>a1\\<in>A.\n        \\<forall>a2\\<in>A. \\<forall>d. runFw a1 d c rs = runFw a2 d c rs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>A\\<in>W.\n                \\<forall>a1\\<in>A.\n                   \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs;\n     \\<Union> W = UNIV;\n     \\<forall>B\\<in>W.\n        \\<exists>b\\<in>B. runFw ip1 b c rs = runFw ip2 b c rs;\n     \\<forall>B\\<in>W.\n        \\<exists>b\\<in>B. runFw b ip1 c rs = runFw b ip2 c rs\\<rbrakk>\n    \\<Longrightarrow> same_fw_behaviour_one ip1 ip2 c rs", "from relation_lem[OF a1'' a2 a4]"], ["proof (chain)\npicking this:\n  runFw ?d1 ip1 c rs = runFw ?d1 ip2 c rs", "have s2: \"\\<And> s. runFw s ip1 c rs = runFw s ip2 c rs\""], ["proof (prove)\nusing this:\n  runFw ?d1 ip1 c rs = runFw ?d1 ip2 c rs\n\ngoal (1 subgoal):\n 1. \\<And>s. runFw s ip1 c rs = runFw s ip2 c rs", "by simp"], ["proof (state)\nthis:\n  runFw ?s1 ip1 c rs = runFw ?s1 ip2 c rs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>A\\<in>W.\n                \\<forall>a1\\<in>A.\n                   \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs;\n     \\<Union> W = UNIV;\n     \\<forall>B\\<in>W.\n        \\<exists>b\\<in>B. runFw ip1 b c rs = runFw ip2 b c rs;\n     \\<forall>B\\<in>W.\n        \\<exists>b\\<in>B. runFw b ip1 c rs = runFw b ip2 c rs\\<rbrakk>\n    \\<Longrightarrow> same_fw_behaviour_one ip1 ip2 c rs", "from s1 s2"], ["proof (chain)\npicking this:\n  runFw ip1 ?d1 c rs = runFw ip2 ?d1 c rs\n  runFw ?s1 ip1 c rs = runFw ?s1 ip2 c rs", "show \"same_fw_behaviour_one ip1 ip2 c rs\""], ["proof (prove)\nusing this:\n  runFw ip1 ?d1 c rs = runFw ip2 ?d1 c rs\n  runFw ?s1 ip1 c rs = runFw ?s1 ip2 c rs\n\ngoal (1 subgoal):\n 1. same_fw_behaviour_one ip1 ip2 c rs", "unfolding same_fw_behaviour_one_def"], ["proof (prove)\nusing this:\n  runFw ip1 ?d1 c rs = runFw ip2 ?d1 c rs\n  runFw ?s1 ip1 c rs = runFw ?s1 ip2 c rs\n\ngoal (1 subgoal):\n 1. \\<forall>d s.\n       runFw ip1 d c rs = runFw ip2 d c rs \\<and>\n       runFw s ip1 c rs = runFw s ip2 c rs", "by fast"], ["proof (state)\nthis:\n  same_fw_behaviour_one ip1 ip2 c rs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sameFw_behave_sets:\n  \"\\<forall>w\\<in>set A. \\<forall>a1 \\<in> w. \\<forall>a2 \\<in> w. same_fw_behaviour_one a1 a2 c rs \\<Longrightarrow>\n   \\<forall>w1\\<in>set A. \\<forall>w2\\<in>set A. \\<exists>a1\\<in>w1. \\<exists>a2\\<in>w2. same_fw_behaviour_one a1 a2 c rs \\<Longrightarrow>\n   \\<forall>w1\\<in>set A. \\<forall>w2\\<in>set A.\n     \\<forall>a1\\<in>w1. \\<forall>a2\\<in>w2. same_fw_behaviour_one a1 a2 c rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>w\\<in>set A.\n                \\<forall>a1\\<in>w.\n                   \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 c rs;\n     \\<forall>w1\\<in>set A.\n        \\<forall>w2\\<in>set A.\n           \\<exists>a1\\<in>w1.\n              \\<exists>a2\\<in>w2. same_fw_behaviour_one a1 a2 c rs\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w1\\<in>set A.\n                         \\<forall>w2\\<in>set A.\n                            \\<forall>a1\\<in>w1.\n                               \\<forall>a2\\<in>w2.\n                                  same_fw_behaviour_one a1 a2 c rs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>w\\<in>set A.\n                \\<forall>a1\\<in>w.\n                   \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 c rs;\n     \\<forall>w1\\<in>set A.\n        \\<forall>w2\\<in>set A.\n           \\<exists>a1\\<in>w1.\n              \\<exists>a2\\<in>w2. same_fw_behaviour_one a1 a2 c rs\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w1\\<in>set A.\n                         \\<forall>w2\\<in>set A.\n                            \\<forall>a1\\<in>w1.\n                               \\<forall>a2\\<in>w2.\n                                  same_fw_behaviour_one a1 a2 c rs", "assume a1: \"\\<forall>w\\<in>set A. \\<forall>a1 \\<in> w. \\<forall>a2 \\<in> w. same_fw_behaviour_one a1 a2 c rs\" and\n         \"\\<forall>w1\\<in>set A. \\<forall>w2\\<in>set A. \\<exists>a1\\<in>w1. \\<exists>a2\\<in>w2.  same_fw_behaviour_one a1 a2 c rs\""], ["proof (state)\nthis:\n  \\<forall>w\\<in>set A.\n     \\<forall>a1\\<in>w. \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 c rs\n  \\<forall>w1\\<in>set A.\n     \\<forall>w2\\<in>set A.\n        \\<exists>a1\\<in>w1.\n           \\<exists>a2\\<in>w2. same_fw_behaviour_one a1 a2 c rs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>w\\<in>set A.\n                \\<forall>a1\\<in>w.\n                   \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 c rs;\n     \\<forall>w1\\<in>set A.\n        \\<forall>w2\\<in>set A.\n           \\<exists>a1\\<in>w1.\n              \\<exists>a2\\<in>w2. same_fw_behaviour_one a1 a2 c rs\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w1\\<in>set A.\n                         \\<forall>w2\\<in>set A.\n                            \\<forall>a1\\<in>w1.\n                               \\<forall>a2\\<in>w2.\n                                  same_fw_behaviour_one a1 a2 c rs", "from this"], ["proof (chain)\npicking this:\n  \\<forall>w\\<in>set A.\n     \\<forall>a1\\<in>w. \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 c rs\n  \\<forall>w1\\<in>set A.\n     \\<forall>w2\\<in>set A.\n        \\<exists>a1\\<in>w1.\n           \\<exists>a2\\<in>w2. same_fw_behaviour_one a1 a2 c rs", "have \"\\<forall>w1\\<in>set A. \\<forall>w2\\<in>set A. \\<exists>a1\\<in>w1. \\<forall>a2\\<in>w2.  same_fw_behaviour_one a1 a2 c rs\""], ["proof (prove)\nusing this:\n  \\<forall>w\\<in>set A.\n     \\<forall>a1\\<in>w. \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 c rs\n  \\<forall>w1\\<in>set A.\n     \\<forall>w2\\<in>set A.\n        \\<exists>a1\\<in>w1.\n           \\<exists>a2\\<in>w2. same_fw_behaviour_one a1 a2 c rs\n\ngoal (1 subgoal):\n 1. \\<forall>w1\\<in>set A.\n       \\<forall>w2\\<in>set A.\n          \\<exists>a1\\<in>w1.\n             \\<forall>a2\\<in>w2. same_fw_behaviour_one a1 a2 c rs", "using same_fw_behaviour_one_equi(3)"], ["proof (prove)\nusing this:\n  \\<forall>w\\<in>set A.\n     \\<forall>a1\\<in>w. \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 c rs\n  \\<forall>w1\\<in>set A.\n     \\<forall>w2\\<in>set A.\n        \\<exists>a1\\<in>w1.\n           \\<exists>a2\\<in>w2. same_fw_behaviour_one a1 a2 c rs\n  same_fw_behaviour_one ?x ?y ?c ?rs \\<and>\n  same_fw_behaviour_one ?y ?z ?c ?rs \\<Longrightarrow>\n  same_fw_behaviour_one ?x ?z ?c ?rs\n\ngoal (1 subgoal):\n 1. \\<forall>w1\\<in>set A.\n       \\<forall>w2\\<in>set A.\n          \\<exists>a1\\<in>w1.\n             \\<forall>a2\\<in>w2. same_fw_behaviour_one a1 a2 c rs", "by metis"], ["proof (state)\nthis:\n  \\<forall>w1\\<in>set A.\n     \\<forall>w2\\<in>set A.\n        \\<exists>a1\\<in>w1.\n           \\<forall>a2\\<in>w2. same_fw_behaviour_one a1 a2 c rs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>w\\<in>set A.\n                \\<forall>a1\\<in>w.\n                   \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 c rs;\n     \\<forall>w1\\<in>set A.\n        \\<forall>w2\\<in>set A.\n           \\<exists>a1\\<in>w1.\n              \\<exists>a2\\<in>w2. same_fw_behaviour_one a1 a2 c rs\\<rbrakk>\n    \\<Longrightarrow> \\<forall>w1\\<in>set A.\n                         \\<forall>w2\\<in>set A.\n                            \\<forall>a1\\<in>w1.\n                               \\<forall>a2\\<in>w2.\n                                  same_fw_behaviour_one a1 a2 c rs", "from a1 this"], ["proof (chain)\npicking this:\n  \\<forall>w\\<in>set A.\n     \\<forall>a1\\<in>w. \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 c rs\n  \\<forall>w1\\<in>set A.\n     \\<forall>w2\\<in>set A.\n        \\<exists>a1\\<in>w1.\n           \\<forall>a2\\<in>w2. same_fw_behaviour_one a1 a2 c rs", "show \"\\<forall>w1\\<in>set A. \\<forall>w2\\<in>set A. \\<forall>a1\\<in>w1. \\<forall>a2\\<in>w2. same_fw_behaviour_one a1 a2 c rs\""], ["proof (prove)\nusing this:\n  \\<forall>w\\<in>set A.\n     \\<forall>a1\\<in>w. \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 c rs\n  \\<forall>w1\\<in>set A.\n     \\<forall>w2\\<in>set A.\n        \\<exists>a1\\<in>w1.\n           \\<forall>a2\\<in>w2. same_fw_behaviour_one a1 a2 c rs\n\ngoal (1 subgoal):\n 1. \\<forall>w1\\<in>set A.\n       \\<forall>w2\\<in>set A.\n          \\<forall>a1\\<in>w1.\n             \\<forall>a2\\<in>w2. same_fw_behaviour_one a1 a2 c rs", "using same_fw_behaviour_one_equi(3)"], ["proof (prove)\nusing this:\n  \\<forall>w\\<in>set A.\n     \\<forall>a1\\<in>w. \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 c rs\n  \\<forall>w1\\<in>set A.\n     \\<forall>w2\\<in>set A.\n        \\<exists>a1\\<in>w1.\n           \\<forall>a2\\<in>w2. same_fw_behaviour_one a1 a2 c rs\n  same_fw_behaviour_one ?x ?y ?c ?rs \\<and>\n  same_fw_behaviour_one ?y ?z ?c ?rs \\<Longrightarrow>\n  same_fw_behaviour_one ?x ?z ?c ?rs\n\ngoal (1 subgoal):\n 1. \\<forall>w1\\<in>set A.\n       \\<forall>w2\\<in>set A.\n          \\<forall>a1\\<in>w1.\n             \\<forall>a2\\<in>w2. same_fw_behaviour_one a1 a2 c rs", "by metis"], ["proof (state)\nthis:\n  \\<forall>w1\\<in>set A.\n     \\<forall>w2\\<in>set A.\n        \\<forall>a1\\<in>w1.\n           \\<forall>a2\\<in>w2. same_fw_behaviour_one a1 a2 c rs\n\ngoal:\nNo subgoals!", "qed"], ["", "definition groupWIs :: \"parts_connection \\<Rightarrow> 'i::len simple_rule list \\<Rightarrow> 'i wordinterval list list\" where\n  \"groupWIs c rs = (let W = getParts rs in \n                       (let f = (\\<lambda>wi. (map (\\<lambda>d. runFw (getOneIp wi) d c rs) (map getOneIp W),\n                                      map (\\<lambda>s. runFw s (getOneIp wi) c rs) (map getOneIp W))) in\n                       groupF f W))\""], ["", "lemma groupWIs_not_empty: \"groupWIs c rs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. groupWIs c rs \\<noteq> []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. groupWIs c rs \\<noteq> []", "have \"getParts rs \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getParts rs \\<noteq> []", "by(simp add: getParts_def partitioningIps_nonempty)"], ["proof (state)\nthis:\n  getParts rs \\<noteq> []\n\ngoal (1 subgoal):\n 1. groupWIs c rs \\<noteq> []", "with groupF_empty"], ["proof (chain)\npicking this:\n  (groupF ?f ?xs \\<noteq> []) = (?xs \\<noteq> [])\n  getParts rs \\<noteq> []", "have \"\\<And>f. groupF f (getParts rs) \\<noteq> []\""], ["proof (prove)\nusing this:\n  (groupF ?f ?xs \\<noteq> []) = (?xs \\<noteq> [])\n  getParts rs \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>f. groupF f (getParts rs) \\<noteq> []", "by blast"], ["proof (state)\nthis:\n  groupF ?f (getParts rs) \\<noteq> []\n\ngoal (1 subgoal):\n 1. groupWIs c rs \\<noteq> []", "thus ?thesis"], ["proof (prove)\nusing this:\n  groupF ?f (getParts rs) \\<noteq> []\n\ngoal (1 subgoal):\n 1. groupWIs c rs \\<noteq> []", "by(simp add: groupWIs_def Let_def) blast"], ["proof (state)\nthis:\n  groupWIs c rs \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma groupWIs_not_empty_elem: \"V \\<in> set (groupWIs c rs) \\<Longrightarrow> V \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<in> set (groupWIs c rs) \\<Longrightarrow> V \\<noteq> []", "by(simp add: groupWIs_def Let_def groupF_empty_elem)"], ["", "lemma groupWIs_not_empty_elems: \n  assumes V: \"V \\<in> set (groupWIs c rs)\" and w: \"w \\<in> set V\"\n  shows \"\\<not> wordinterval_empty w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> wordinterval_empty w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> wordinterval_empty w", "have \"\\<forall>w\\<in>set (concat (groupWIs c rs)). \\<not> wordinterval_empty w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set (concat (groupWIs c rs)). \\<not> wordinterval_empty w", "apply(subst groupWIs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set (concat\n                         (let W = getParts rs;\n                              f = \\<lambda>wi.\n                                     (map\n (\\<lambda>d. runFw (getOneIp wi) d c rs) (map getOneIp W),\nmap (\\<lambda>s. runFw s (getOneIp wi) c rs) (map getOneIp W))\n                          in groupF f W)).\n       \\<not> wordinterval_empty w", "apply(subst Let_def)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set (concat\n                         (groupF\n                           (\\<lambda>wi.\n                               (map (\\<lambda>d. runFw (getOneIp wi) d c rs)\n                                 (map getOneIp (getParts rs)),\n                                map (\\<lambda>s. runFw s (getOneIp wi) c rs)\n                                 (map getOneIp (getParts rs))))\n                           (getParts rs))).\n       \\<not> wordinterval_empty w", "apply(subst groupF_concat_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set (getParts rs). \\<not> wordinterval_empty w", "using getParts_nonempty_elems"], ["proof (prove)\nusing this:\n  \\<forall>w\\<in>set (getParts ?rs). \\<not> wordinterval_empty w\n\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set (getParts rs). \\<not> wordinterval_empty w", "by blast"], ["proof (state)\nthis:\n  \\<forall>w\\<in>set (concat (groupWIs c rs)). \\<not> wordinterval_empty w\n\ngoal (1 subgoal):\n 1. \\<not> wordinterval_empty w", "from this V w"], ["proof (chain)\npicking this:\n  \\<forall>w\\<in>set (concat (groupWIs c rs)). \\<not> wordinterval_empty w\n  V \\<in> set (groupWIs c rs)\n  w \\<in> set V", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>w\\<in>set (concat (groupWIs c rs)). \\<not> wordinterval_empty w\n  V \\<in> set (groupWIs c rs)\n  w \\<in> set V\n\ngoal (1 subgoal):\n 1. \\<not> wordinterval_empty w", "by auto"], ["proof (state)\nthis:\n  \\<not> wordinterval_empty w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma groupParts_same_fw_wi0:\n    assumes \"V \\<in> set (groupWIs c rs)\"\n    shows \"\\<forall>w \\<in> set (map wordinterval_to_set V). \\<forall>a1 \\<in> w. \\<forall>a2 \\<in> w. same_fw_behaviour_one a1 a2 c rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set (map wordinterval_to_set V).\n       \\<forall>a1\\<in>w.\n          \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 c rs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set (map wordinterval_to_set V).\n       \\<forall>a1\\<in>w.\n          \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 c rs", "have \"\\<forall>A\\<in>set (map wordinterval_to_set (concat (groupWIs c rs))). \n        \\<forall>a1\\<in>A. \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>set (map wordinterval_to_set (concat (groupWIs c rs))).\n       \\<forall>a1\\<in>A.\n          \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs", "apply(subst groupWIs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>set (map wordinterval_to_set\n                         (concat\n                           (let W = getParts rs;\n                                f = \\<lambda>wi.\n (map (\\<lambda>d. runFw (getOneIp wi) d c rs) (map getOneIp W),\n  map (\\<lambda>s. runFw s (getOneIp wi) c rs) (map getOneIp W))\n                            in groupF f W))).\n       \\<forall>a1\\<in>A.\n          \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs", "apply(subst Let_def)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>set (map wordinterval_to_set\n                         (concat\n                           (groupF\n                             (\\<lambda>wi.\n                                 (map (\\<lambda>d.\n    runFw (getOneIp wi) d c rs)\n                                   (map getOneIp (getParts rs)),\n                                  map (\\<lambda>s.\n    runFw s (getOneIp wi) c rs)\n                                   (map getOneIp (getParts rs))))\n                             (getParts rs)))).\n       \\<forall>a1\\<in>A.\n          \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs", "apply(subst set_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>wordinterval_to_set `\n                   set (concat\n                         (groupF\n                           (\\<lambda>wi.\n                               (map (\\<lambda>d. runFw (getOneIp wi) d c rs)\n                                 (map getOneIp (getParts rs)),\n                                map (\\<lambda>s. runFw s (getOneIp wi) c rs)\n                                 (map getOneIp (getParts rs))))\n                           (getParts rs))).\n       \\<forall>a1\\<in>A.\n          \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs", "apply(subst groupF_concat_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>wordinterval_to_set ` set (getParts rs).\n       \\<forall>a1\\<in>A.\n          \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs", "using getParts_same_fw_behaviour same_fw_spec"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> set (map wordinterval_to_set (getParts ?rs));\n   ?s1.0 \\<in> ?A; ?s2.0 \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> same_fw_behaviour ?s1.0 ?s2.0 ?rs\n  same_fw_behaviour ?ip1.0 ?ip2.0 ?rs \\<Longrightarrow>\n  same_fw_behaviour_one ?ip1.0 ?ip2.0 ?c ?rs\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>wordinterval_to_set ` set (getParts rs).\n       \\<forall>a1\\<in>A.\n          \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>A\\<in>set (map wordinterval_to_set (concat (groupWIs c rs))).\n     \\<forall>a1\\<in>A. \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs\n\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set (map wordinterval_to_set V).\n       \\<forall>a1\\<in>w.\n          \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 c rs", "from this assms"], ["proof (chain)\npicking this:\n  \\<forall>A\\<in>set (map wordinterval_to_set (concat (groupWIs c rs))).\n     \\<forall>a1\\<in>A. \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs\n  V \\<in> set (groupWIs c rs)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>A\\<in>set (map wordinterval_to_set (concat (groupWIs c rs))).\n     \\<forall>a1\\<in>A. \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs\n  V \\<in> set (groupWIs c rs)\n\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set (map wordinterval_to_set V).\n       \\<forall>a1\\<in>w.\n          \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 c rs", "by force"], ["proof (state)\nthis:\n  \\<forall>w\\<in>set (map wordinterval_to_set V).\n     \\<forall>a1\\<in>w. \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 c rs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma groupWIs_same_fw_not: \"A \\<in> set (groupWIs c rs) \\<Longrightarrow> B \\<in> set (groupWIs c rs) \\<Longrightarrow> \n                            A \\<noteq> B \\<Longrightarrow>\n                             \\<forall>aw \\<in> set (map wordinterval_to_set A).\n                             \\<forall>bw \\<in> set (map wordinterval_to_set B).\n                             \\<forall>a \\<in> aw. \\<forall>b \\<in> bw. \\<not> same_fw_behaviour_one a b c rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> set (groupWIs c rs); B \\<in> set (groupWIs c rs);\n     A \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aw\\<in>set (map wordinterval_to_set A).\n                         \\<forall>bw\\<in>set (map wordinterval_to_set B).\n                            \\<forall>a\\<in>aw.\n                               \\<forall>b\\<in>bw.\n                                  \\<not> same_fw_behaviour_one a b c rs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> set (groupWIs c rs); B \\<in> set (groupWIs c rs);\n     A \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aw\\<in>set (map wordinterval_to_set A).\n                         \\<forall>bw\\<in>set (map wordinterval_to_set B).\n                            \\<forall>a\\<in>aw.\n                               \\<forall>b\\<in>bw.\n                                  \\<not> same_fw_behaviour_one a b c rs", "assume asm: \"A \\<in> set (groupWIs c rs)\" \"B \\<in> set (groupWIs c rs)\" \"A \\<noteq> B\""], ["proof (state)\nthis:\n  A \\<in> set (groupWIs c rs)\n  B \\<in> set (groupWIs c rs)\n  A \\<noteq> B\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> set (groupWIs c rs); B \\<in> set (groupWIs c rs);\n     A \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aw\\<in>set (map wordinterval_to_set A).\n                         \\<forall>bw\\<in>set (map wordinterval_to_set B).\n                            \\<forall>a\\<in>aw.\n                               \\<forall>b\\<in>bw.\n                                  \\<not> same_fw_behaviour_one a b c rs", "from this"], ["proof (chain)\npicking this:\n  A \\<in> set (groupWIs c rs)\n  B \\<in> set (groupWIs c rs)\n  A \\<noteq> B", "have b1: \"\\<forall>aw \\<in> set A. \\<forall>bw \\<in> set B.\n                  (map (\\<lambda>d. runFw (getOneIp aw) d c rs) (map getOneIp (getParts rs)),\n                   map (\\<lambda>s. runFw s (getOneIp aw) c rs) (map getOneIp (getParts rs))) \\<noteq>\n                  (map (\\<lambda>d. runFw (getOneIp bw) d c rs) (map getOneIp (getParts rs)),\n                   map (\\<lambda>s. runFw s (getOneIp bw) c rs) (map getOneIp (getParts rs)))\""], ["proof (prove)\nusing this:\n  A \\<in> set (groupWIs c rs)\n  B \\<in> set (groupWIs c rs)\n  A \\<noteq> B\n\ngoal (1 subgoal):\n 1. \\<forall>aw\\<in>set A.\n       \\<forall>bw\\<in>set B.\n          (map (\\<lambda>d. runFw (getOneIp aw) d c rs)\n            (map getOneIp (getParts rs)),\n           map (\\<lambda>s. runFw s (getOneIp aw) c rs)\n            (map getOneIp (getParts rs))) \\<noteq>\n          (map (\\<lambda>d. runFw (getOneIp bw) d c rs)\n            (map getOneIp (getParts rs)),\n           map (\\<lambda>s. runFw s (getOneIp bw) c rs)\n            (map getOneIp (getParts rs)))", "apply(simp add: groupWIs_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> set (groupF\n                           (\\<lambda>wi.\n                               (map ((\\<lambda>d.\n   runFw (getOneIp wi) d c rs) \\<circ>\n                                     getOneIp)\n                                 (getParts rs),\n                                map ((\\<lambda>s.\n   runFw s (getOneIp wi) c rs) \\<circ>\n                                     getOneIp)\n                                 (getParts rs)))\n                           (getParts rs));\n     B \\<in> set (groupF\n                   (\\<lambda>wi.\n                       (map ((\\<lambda>d.\n                                 runFw (getOneIp wi) d c rs) \\<circ>\n                             getOneIp)\n                         (getParts rs),\n                        map ((\\<lambda>s.\n                                 runFw s (getOneIp wi) c rs) \\<circ>\n                             getOneIp)\n                         (getParts rs)))\n                   (getParts rs));\n     A \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aw\\<in>set A.\n                         \\<forall>bw\\<in>set B.\n                            (\\<exists>x\\<in>set (getParts rs).\n                                runFw (getOneIp aw) (getOneIp x) c\n                                 rs \\<noteq>\n                                runFw (getOneIp bw) (getOneIp x) c rs) \\<or>\n                            (\\<exists>x\\<in>set (getParts rs).\n                                runFw (getOneIp x) (getOneIp aw) c\n                                 rs \\<noteq>\n                                runFw (getOneIp x) (getOneIp bw) c rs)", "using groupF_nequality"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> set (groupF ?f ?xs); ?B \\<in> set (groupF ?f ?xs);\n   ?A \\<noteq> ?B\\<rbrakk>\n  \\<Longrightarrow> \\<forall>a\\<in>set ?A.\n                       \\<forall>b\\<in>set ?B. ?f a \\<noteq> ?f b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> set (groupF\n                           (\\<lambda>wi.\n                               (map ((\\<lambda>d.\n   runFw (getOneIp wi) d c rs) \\<circ>\n                                     getOneIp)\n                                 (getParts rs),\n                                map ((\\<lambda>s.\n   runFw s (getOneIp wi) c rs) \\<circ>\n                                     getOneIp)\n                                 (getParts rs)))\n                           (getParts rs));\n     B \\<in> set (groupF\n                   (\\<lambda>wi.\n                       (map ((\\<lambda>d.\n                                 runFw (getOneIp wi) d c rs) \\<circ>\n                             getOneIp)\n                         (getParts rs),\n                        map ((\\<lambda>s.\n                                 runFw s (getOneIp wi) c rs) \\<circ>\n                             getOneIp)\n                         (getParts rs)))\n                   (getParts rs));\n     A \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aw\\<in>set A.\n                         \\<forall>bw\\<in>set B.\n                            (\\<exists>x\\<in>set (getParts rs).\n                                runFw (getOneIp aw) (getOneIp x) c\n                                 rs \\<noteq>\n                                runFw (getOneIp bw) (getOneIp x) c rs) \\<or>\n                            (\\<exists>x\\<in>set (getParts rs).\n                                runFw (getOneIp x) (getOneIp aw) c\n                                 rs \\<noteq>\n                                runFw (getOneIp x) (getOneIp bw) c rs)", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>aw\\<in>set A.\n     \\<forall>bw\\<in>set B.\n        (map (\\<lambda>d. runFw (getOneIp aw) d c rs)\n          (map getOneIp (getParts rs)),\n         map (\\<lambda>s. runFw s (getOneIp aw) c rs)\n          (map getOneIp (getParts rs))) \\<noteq>\n        (map (\\<lambda>d. runFw (getOneIp bw) d c rs)\n          (map getOneIp (getParts rs)),\n         map (\\<lambda>s. runFw s (getOneIp bw) c rs)\n          (map getOneIp (getParts rs)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> set (groupWIs c rs); B \\<in> set (groupWIs c rs);\n     A \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aw\\<in>set (map wordinterval_to_set A).\n                         \\<forall>bw\\<in>set (map wordinterval_to_set B).\n                            \\<forall>a\\<in>aw.\n                               \\<forall>b\\<in>bw.\n                                  \\<not> same_fw_behaviour_one a b c rs", "have same_behave_runFw_not:\n        \"(map (\\<lambda>d. runFw x1 d c rs) W, map (\\<lambda>s. runFw s x1 c rs) W) \\<noteq>\n         (map (\\<lambda>d. runFw x2 d c rs) W, map (\\<lambda>s. runFw s x2 c rs) W) \\<Longrightarrow>\n         \\<not> same_fw_behaviour_one x1 x2 c rs\" for x1 x2 W"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map (\\<lambda>d. runFw x1 d c rs) W,\n     map (\\<lambda>s. runFw s x1 c rs) W) \\<noteq>\n    (map (\\<lambda>d. runFw x2 d c rs) W,\n     map (\\<lambda>s. runFw s x2 c rs) W) \\<Longrightarrow>\n    \\<not> same_fw_behaviour_one x1 x2 c rs", "by (simp add: same_fw_behaviour_one_def) (blast)"], ["proof (state)\nthis:\n  (map (\\<lambda>d. runFw ?x1.0 d c rs) ?W,\n   map (\\<lambda>s. runFw s ?x1.0 c rs) ?W) \\<noteq>\n  (map (\\<lambda>d. runFw ?x2.0 d c rs) ?W,\n   map (\\<lambda>s. runFw s ?x2.0 c rs) ?W) \\<Longrightarrow>\n  \\<not> same_fw_behaviour_one ?x1.0 ?x2.0 c rs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> set (groupWIs c rs); B \\<in> set (groupWIs c rs);\n     A \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aw\\<in>set (map wordinterval_to_set A).\n                         \\<forall>bw\\<in>set (map wordinterval_to_set B).\n                            \\<forall>a\\<in>aw.\n                               \\<forall>b\\<in>bw.\n                                  \\<not> same_fw_behaviour_one a b c rs", "have \"\\<forall>C \\<in> set (groupWIs c rs). \\<forall>c \\<in> set C. getOneIp c \\<in> wordinterval_to_set c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>set (groupWIs c rs).\n       \\<forall>c\\<in>set C. getOneIp c \\<in> wordinterval_to_set c", "apply(simp add: groupWIs_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>set (groupF\n                         (\\<lambda>wi.\n                             (map ((\\<lambda>d.\n runFw (getOneIp wi) d c rs) \\<circ>\n                                   getOneIp)\n                               (getParts rs),\n                              map ((\\<lambda>s.\n runFw s (getOneIp wi) c rs) \\<circ>\n                                   getOneIp)\n                               (getParts rs)))\n                         (getParts rs)).\n       \\<forall>c\\<in>set C. getOneIp c \\<in> wordinterval_to_set c", "using getParts_nonempty_elems groupF_set getOneIp_elem"], ["proof (prove)\nusing this:\n  \\<forall>w\\<in>set (getParts ?rs). \\<not> wordinterval_empty w\n  \\<forall>X\\<in>set (groupF ?f ?xs). \\<forall>x\\<in>set X. x \\<in> set ?xs\n  \\<not> wordinterval_empty ?W \\<Longrightarrow>\n  wordinterval_element (getOneIp ?W) ?W\n\ngoal (1 subgoal):\n 1. \\<forall>C\\<in>set (groupF\n                         (\\<lambda>wi.\n                             (map ((\\<lambda>d.\n runFw (getOneIp wi) d c rs) \\<circ>\n                                   getOneIp)\n                               (getParts rs),\n                              map ((\\<lambda>s.\n runFw s (getOneIp wi) c rs) \\<circ>\n                                   getOneIp)\n                               (getParts rs)))\n                         (getParts rs)).\n       \\<forall>c\\<in>set C. getOneIp c \\<in> wordinterval_to_set c", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>C\\<in>set (groupWIs c rs).\n     \\<forall>c\\<in>set C. getOneIp c \\<in> wordinterval_to_set c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> set (groupWIs c rs); B \\<in> set (groupWIs c rs);\n     A \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aw\\<in>set (map wordinterval_to_set A).\n                         \\<forall>bw\\<in>set (map wordinterval_to_set B).\n                            \\<forall>a\\<in>aw.\n                               \\<forall>b\\<in>bw.\n                                  \\<not> same_fw_behaviour_one a b c rs", "from this b1 asm"], ["proof (chain)\npicking this:\n  \\<forall>C\\<in>set (groupWIs c rs).\n     \\<forall>c\\<in>set C. getOneIp c \\<in> wordinterval_to_set c\n  \\<forall>aw\\<in>set A.\n     \\<forall>bw\\<in>set B.\n        (map (\\<lambda>d. runFw (getOneIp aw) d c rs)\n          (map getOneIp (getParts rs)),\n         map (\\<lambda>s. runFw s (getOneIp aw) c rs)\n          (map getOneIp (getParts rs))) \\<noteq>\n        (map (\\<lambda>d. runFw (getOneIp bw) d c rs)\n          (map getOneIp (getParts rs)),\n         map (\\<lambda>s. runFw s (getOneIp bw) c rs)\n          (map getOneIp (getParts rs)))\n  A \\<in> set (groupWIs c rs)\n  B \\<in> set (groupWIs c rs)\n  A \\<noteq> B", "have\n  \"\\<forall>aw \\<in> set (map wordinterval_to_set A). \\<forall>bw \\<in> set (map wordinterval_to_set B).\n   \\<exists>a \\<in> aw. \\<exists>b \\<in> bw. (map (\\<lambda>d. runFw a d c rs) (map getOneIp (getParts rs)), map (\\<lambda>s. runFw s a c rs) (map getOneIp (getParts rs))) \\<noteq>\n    (map (\\<lambda>d. runFw b d c rs) (map getOneIp (getParts rs)), map (\\<lambda>s. runFw s b c rs) (map getOneIp (getParts rs)))\""], ["proof (prove)\nusing this:\n  \\<forall>C\\<in>set (groupWIs c rs).\n     \\<forall>c\\<in>set C. getOneIp c \\<in> wordinterval_to_set c\n  \\<forall>aw\\<in>set A.\n     \\<forall>bw\\<in>set B.\n        (map (\\<lambda>d. runFw (getOneIp aw) d c rs)\n          (map getOneIp (getParts rs)),\n         map (\\<lambda>s. runFw s (getOneIp aw) c rs)\n          (map getOneIp (getParts rs))) \\<noteq>\n        (map (\\<lambda>d. runFw (getOneIp bw) d c rs)\n          (map getOneIp (getParts rs)),\n         map (\\<lambda>s. runFw s (getOneIp bw) c rs)\n          (map getOneIp (getParts rs)))\n  A \\<in> set (groupWIs c rs)\n  B \\<in> set (groupWIs c rs)\n  A \\<noteq> B\n\ngoal (1 subgoal):\n 1. \\<forall>aw\\<in>set (map wordinterval_to_set A).\n       \\<forall>bw\\<in>set (map wordinterval_to_set B).\n          \\<exists>a\\<in>aw.\n             \\<exists>b\\<in>bw.\n                (map (\\<lambda>d. runFw a d c rs)\n                  (map getOneIp (getParts rs)),\n                 map (\\<lambda>s. runFw s a c rs)\n                  (map getOneIp (getParts rs))) \\<noteq>\n                (map (\\<lambda>d. runFw b d c rs)\n                  (map getOneIp (getParts rs)),\n                 map (\\<lambda>s. runFw s b c rs)\n                  (map getOneIp (getParts rs)))", "by (simp) (blast)"], ["proof (state)\nthis:\n  \\<forall>aw\\<in>set (map wordinterval_to_set A).\n     \\<forall>bw\\<in>set (map wordinterval_to_set B).\n        \\<exists>a\\<in>aw.\n           \\<exists>b\\<in>bw.\n              (map (\\<lambda>d. runFw a d c rs)\n                (map getOneIp (getParts rs)),\n               map (\\<lambda>s. runFw s a c rs)\n                (map getOneIp (getParts rs))) \\<noteq>\n              (map (\\<lambda>d. runFw b d c rs)\n                (map getOneIp (getParts rs)),\n               map (\\<lambda>s. runFw s b c rs)\n                (map getOneIp (getParts rs)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> set (groupWIs c rs); B \\<in> set (groupWIs c rs);\n     A \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aw\\<in>set (map wordinterval_to_set A).\n                         \\<forall>bw\\<in>set (map wordinterval_to_set B).\n                            \\<forall>a\\<in>aw.\n                               \\<forall>b\\<in>bw.\n                                  \\<not> same_fw_behaviour_one a b c rs", "from this same_behave_runFw_not asm"], ["proof (chain)\npicking this:\n  \\<forall>aw\\<in>set (map wordinterval_to_set A).\n     \\<forall>bw\\<in>set (map wordinterval_to_set B).\n        \\<exists>a\\<in>aw.\n           \\<exists>b\\<in>bw.\n              (map (\\<lambda>d. runFw a d c rs)\n                (map getOneIp (getParts rs)),\n               map (\\<lambda>s. runFw s a c rs)\n                (map getOneIp (getParts rs))) \\<noteq>\n              (map (\\<lambda>d. runFw b d c rs)\n                (map getOneIp (getParts rs)),\n               map (\\<lambda>s. runFw s b c rs)\n                (map getOneIp (getParts rs)))\n  (map (\\<lambda>d. runFw ?x1.0 d c rs) ?W,\n   map (\\<lambda>s. runFw s ?x1.0 c rs) ?W) \\<noteq>\n  (map (\\<lambda>d. runFw ?x2.0 d c rs) ?W,\n   map (\\<lambda>s. runFw s ?x2.0 c rs) ?W) \\<Longrightarrow>\n  \\<not> same_fw_behaviour_one ?x1.0 ?x2.0 c rs\n  A \\<in> set (groupWIs c rs)\n  B \\<in> set (groupWIs c rs)\n  A \\<noteq> B", "have \" \\<forall>aw \\<in> set (map wordinterval_to_set A). \\<forall>bw \\<in> set (map wordinterval_to_set B).\n         \\<exists>a \\<in> aw. \\<exists>b \\<in> bw. \\<not> same_fw_behaviour_one a b c rs\""], ["proof (prove)\nusing this:\n  \\<forall>aw\\<in>set (map wordinterval_to_set A).\n     \\<forall>bw\\<in>set (map wordinterval_to_set B).\n        \\<exists>a\\<in>aw.\n           \\<exists>b\\<in>bw.\n              (map (\\<lambda>d. runFw a d c rs)\n                (map getOneIp (getParts rs)),\n               map (\\<lambda>s. runFw s a c rs)\n                (map getOneIp (getParts rs))) \\<noteq>\n              (map (\\<lambda>d. runFw b d c rs)\n                (map getOneIp (getParts rs)),\n               map (\\<lambda>s. runFw s b c rs)\n                (map getOneIp (getParts rs)))\n  (map (\\<lambda>d. runFw ?x1.0 d c rs) ?W,\n   map (\\<lambda>s. runFw s ?x1.0 c rs) ?W) \\<noteq>\n  (map (\\<lambda>d. runFw ?x2.0 d c rs) ?W,\n   map (\\<lambda>s. runFw s ?x2.0 c rs) ?W) \\<Longrightarrow>\n  \\<not> same_fw_behaviour_one ?x1.0 ?x2.0 c rs\n  A \\<in> set (groupWIs c rs)\n  B \\<in> set (groupWIs c rs)\n  A \\<noteq> B\n\ngoal (1 subgoal):\n 1. \\<forall>aw\\<in>set (map wordinterval_to_set A).\n       \\<forall>bw\\<in>set (map wordinterval_to_set B).\n          \\<exists>a\\<in>aw.\n             \\<exists>b\\<in>bw. \\<not> same_fw_behaviour_one a b c rs", "by fast"], ["proof (state)\nthis:\n  \\<forall>aw\\<in>set (map wordinterval_to_set A).\n     \\<forall>bw\\<in>set (map wordinterval_to_set B).\n        \\<exists>a\\<in>aw.\n           \\<exists>b\\<in>bw. \\<not> same_fw_behaviour_one a b c rs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> set (groupWIs c rs); B \\<in> set (groupWIs c rs);\n     A \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aw\\<in>set (map wordinterval_to_set A).\n                         \\<forall>bw\\<in>set (map wordinterval_to_set B).\n                            \\<forall>a\\<in>aw.\n                               \\<forall>b\\<in>bw.\n                                  \\<not> same_fw_behaviour_one a b c rs", "from this groupParts_same_fw_wi0[of A c rs]  groupParts_same_fw_wi0[of B c rs] asm"], ["proof (chain)\npicking this:\n  \\<forall>aw\\<in>set (map wordinterval_to_set A).\n     \\<forall>bw\\<in>set (map wordinterval_to_set B).\n        \\<exists>a\\<in>aw.\n           \\<exists>b\\<in>bw. \\<not> same_fw_behaviour_one a b c rs\n  A \\<in> set (groupWIs c rs) \\<Longrightarrow>\n  \\<forall>w\\<in>set (map wordinterval_to_set A).\n     \\<forall>a1\\<in>w. \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 c rs\n  B \\<in> set (groupWIs c rs) \\<Longrightarrow>\n  \\<forall>w\\<in>set (map wordinterval_to_set B).\n     \\<forall>a1\\<in>w. \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 c rs\n  A \\<in> set (groupWIs c rs)\n  B \\<in> set (groupWIs c rs)\n  A \\<noteq> B", "have \"\\<forall>aw \\<in> set (map wordinterval_to_set A).\n        \\<forall>bw \\<in> set (map wordinterval_to_set B).\n        \\<forall>a \\<in> aw. \\<exists>b \\<in> bw. \\<not> same_fw_behaviour_one a b c rs\""], ["proof (prove)\nusing this:\n  \\<forall>aw\\<in>set (map wordinterval_to_set A).\n     \\<forall>bw\\<in>set (map wordinterval_to_set B).\n        \\<exists>a\\<in>aw.\n           \\<exists>b\\<in>bw. \\<not> same_fw_behaviour_one a b c rs\n  A \\<in> set (groupWIs c rs) \\<Longrightarrow>\n  \\<forall>w\\<in>set (map wordinterval_to_set A).\n     \\<forall>a1\\<in>w. \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 c rs\n  B \\<in> set (groupWIs c rs) \\<Longrightarrow>\n  \\<forall>w\\<in>set (map wordinterval_to_set B).\n     \\<forall>a1\\<in>w. \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 c rs\n  A \\<in> set (groupWIs c rs)\n  B \\<in> set (groupWIs c rs)\n  A \\<noteq> B\n\ngoal (1 subgoal):\n 1. \\<forall>aw\\<in>set (map wordinterval_to_set A).\n       \\<forall>bw\\<in>set (map wordinterval_to_set B).\n          \\<forall>a\\<in>aw.\n             \\<exists>b\\<in>bw. \\<not> same_fw_behaviour_one a b c rs", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>aw\\<in>set A.\n                \\<forall>bw\\<in>set B.\n                   \\<exists>a\\<in>wordinterval_to_set aw.\n                      \\<exists>b\\<in>wordinterval_to_set bw.\n                         \\<not> same_fw_behaviour_one a b c rs;\n     \\<forall>w\\<in>set A.\n        \\<forall>a1\\<in>wordinterval_to_set w.\n           \\<forall>a2\\<in>wordinterval_to_set w.\n              same_fw_behaviour_one a1 a2 c rs;\n     \\<forall>w\\<in>set B.\n        \\<forall>a1\\<in>wordinterval_to_set w.\n           \\<forall>a2\\<in>wordinterval_to_set w.\n              same_fw_behaviour_one a1 a2 c rs;\n     A \\<in> set (groupWIs c rs); B \\<in> set (groupWIs c rs);\n     A \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aw\\<in>set A.\n                         \\<forall>bw\\<in>set B.\n                            \\<forall>a\\<in>wordinterval_to_set aw.\n                               \\<exists>b\\<in>wordinterval_to_set bw.\n                                  \\<not> same_fw_behaviour_one a b c rs", "using same_fw_behaviour_one_equi(3)"], ["proof (prove)\nusing this:\n  same_fw_behaviour_one ?x ?y ?c ?rs \\<and>\n  same_fw_behaviour_one ?y ?z ?c ?rs \\<Longrightarrow>\n  same_fw_behaviour_one ?x ?z ?c ?rs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>aw\\<in>set A.\n                \\<forall>bw\\<in>set B.\n                   \\<exists>a\\<in>wordinterval_to_set aw.\n                      \\<exists>b\\<in>wordinterval_to_set bw.\n                         \\<not> same_fw_behaviour_one a b c rs;\n     \\<forall>w\\<in>set A.\n        \\<forall>a1\\<in>wordinterval_to_set w.\n           \\<forall>a2\\<in>wordinterval_to_set w.\n              same_fw_behaviour_one a1 a2 c rs;\n     \\<forall>w\\<in>set B.\n        \\<forall>a1\\<in>wordinterval_to_set w.\n           \\<forall>a2\\<in>wordinterval_to_set w.\n              same_fw_behaviour_one a1 a2 c rs;\n     A \\<in> set (groupWIs c rs); B \\<in> set (groupWIs c rs);\n     A \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aw\\<in>set A.\n                         \\<forall>bw\\<in>set B.\n                            \\<forall>a\\<in>wordinterval_to_set aw.\n                               \\<exists>b\\<in>wordinterval_to_set bw.\n                                  \\<not> same_fw_behaviour_one a b c rs", "by blast"], ["proof (state)\nthis:\n  \\<forall>aw\\<in>set (map wordinterval_to_set A).\n     \\<forall>bw\\<in>set (map wordinterval_to_set B).\n        \\<forall>a\\<in>aw.\n           \\<exists>b\\<in>bw. \\<not> same_fw_behaviour_one a b c rs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> set (groupWIs c rs); B \\<in> set (groupWIs c rs);\n     A \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aw\\<in>set (map wordinterval_to_set A).\n                         \\<forall>bw\\<in>set (map wordinterval_to_set B).\n                            \\<forall>a\\<in>aw.\n                               \\<forall>b\\<in>bw.\n                                  \\<not> same_fw_behaviour_one a b c rs", "from this groupParts_same_fw_wi0[of A c rs]  groupParts_same_fw_wi0[of B c rs] asm"], ["proof (chain)\npicking this:\n  \\<forall>aw\\<in>set (map wordinterval_to_set A).\n     \\<forall>bw\\<in>set (map wordinterval_to_set B).\n        \\<forall>a\\<in>aw.\n           \\<exists>b\\<in>bw. \\<not> same_fw_behaviour_one a b c rs\n  A \\<in> set (groupWIs c rs) \\<Longrightarrow>\n  \\<forall>w\\<in>set (map wordinterval_to_set A).\n     \\<forall>a1\\<in>w. \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 c rs\n  B \\<in> set (groupWIs c rs) \\<Longrightarrow>\n  \\<forall>w\\<in>set (map wordinterval_to_set B).\n     \\<forall>a1\\<in>w. \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 c rs\n  A \\<in> set (groupWIs c rs)\n  B \\<in> set (groupWIs c rs)\n  A \\<noteq> B", "show \"\\<forall>aw \\<in> set (map wordinterval_to_set A).\n        \\<forall>bw \\<in> set (map wordinterval_to_set B).\n        \\<forall>a \\<in> aw. \\<forall>b \\<in> bw. \\<not> same_fw_behaviour_one a b c rs\""], ["proof (prove)\nusing this:\n  \\<forall>aw\\<in>set (map wordinterval_to_set A).\n     \\<forall>bw\\<in>set (map wordinterval_to_set B).\n        \\<forall>a\\<in>aw.\n           \\<exists>b\\<in>bw. \\<not> same_fw_behaviour_one a b c rs\n  A \\<in> set (groupWIs c rs) \\<Longrightarrow>\n  \\<forall>w\\<in>set (map wordinterval_to_set A).\n     \\<forall>a1\\<in>w. \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 c rs\n  B \\<in> set (groupWIs c rs) \\<Longrightarrow>\n  \\<forall>w\\<in>set (map wordinterval_to_set B).\n     \\<forall>a1\\<in>w. \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 c rs\n  A \\<in> set (groupWIs c rs)\n  B \\<in> set (groupWIs c rs)\n  A \\<noteq> B\n\ngoal (1 subgoal):\n 1. \\<forall>aw\\<in>set (map wordinterval_to_set A).\n       \\<forall>bw\\<in>set (map wordinterval_to_set B).\n          \\<forall>a\\<in>aw.\n             \\<forall>b\\<in>bw. \\<not> same_fw_behaviour_one a b c rs", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>aw\\<in>set A.\n                \\<forall>bw\\<in>set B.\n                   \\<forall>a\\<in>wordinterval_to_set aw.\n                      \\<exists>b\\<in>wordinterval_to_set bw.\n                         \\<not> same_fw_behaviour_one a b c rs;\n     \\<forall>w\\<in>set A.\n        \\<forall>a1\\<in>wordinterval_to_set w.\n           \\<forall>a2\\<in>wordinterval_to_set w.\n              same_fw_behaviour_one a1 a2 c rs;\n     \\<forall>w\\<in>set B.\n        \\<forall>a1\\<in>wordinterval_to_set w.\n           \\<forall>a2\\<in>wordinterval_to_set w.\n              same_fw_behaviour_one a1 a2 c rs;\n     A \\<in> set (groupWIs c rs); B \\<in> set (groupWIs c rs);\n     A \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aw\\<in>set A.\n                         \\<forall>bw\\<in>set B.\n                            \\<forall>a\\<in>wordinterval_to_set aw.\n                               \\<forall>b\\<in>wordinterval_to_set bw.\n                                  \\<not> same_fw_behaviour_one a b c rs", "using same_fw_behaviour_one_equi(3)"], ["proof (prove)\nusing this:\n  same_fw_behaviour_one ?x ?y ?c ?rs \\<and>\n  same_fw_behaviour_one ?y ?z ?c ?rs \\<Longrightarrow>\n  same_fw_behaviour_one ?x ?z ?c ?rs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>aw\\<in>set A.\n                \\<forall>bw\\<in>set B.\n                   \\<forall>a\\<in>wordinterval_to_set aw.\n                      \\<exists>b\\<in>wordinterval_to_set bw.\n                         \\<not> same_fw_behaviour_one a b c rs;\n     \\<forall>w\\<in>set A.\n        \\<forall>a1\\<in>wordinterval_to_set w.\n           \\<forall>a2\\<in>wordinterval_to_set w.\n              same_fw_behaviour_one a1 a2 c rs;\n     \\<forall>w\\<in>set B.\n        \\<forall>a1\\<in>wordinterval_to_set w.\n           \\<forall>a2\\<in>wordinterval_to_set w.\n              same_fw_behaviour_one a1 a2 c rs;\n     A \\<in> set (groupWIs c rs); B \\<in> set (groupWIs c rs);\n     A \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> \\<forall>aw\\<in>set A.\n                         \\<forall>bw\\<in>set B.\n                            \\<forall>a\\<in>wordinterval_to_set aw.\n                               \\<forall>b\\<in>wordinterval_to_set bw.\n                                  \\<not> same_fw_behaviour_one a b c rs", "by fast"], ["proof (state)\nthis:\n  \\<forall>aw\\<in>set (map wordinterval_to_set A).\n     \\<forall>bw\\<in>set (map wordinterval_to_set B).\n        \\<forall>a\\<in>aw.\n           \\<forall>b\\<in>bw. \\<not> same_fw_behaviour_one a b c rs\n\ngoal:\nNo subgoals!", "qed"], ["", "(*beginning is copy&paste of previous proof*)"], ["", "lemma groupParts_same_fw_wi1:\n  \"V \\<in> set (groupWIs c rs) \\<Longrightarrow> \\<forall>w1 \\<in> set V. \\<forall>w2 \\<in> set V.\n     \\<forall>a1 \\<in> wordinterval_to_set w1. \\<forall>a2 \\<in> wordinterval_to_set w2. same_fw_behaviour_one a1 a2 c rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<in> set (groupWIs c rs) \\<Longrightarrow>\n    \\<forall>w1\\<in>set V.\n       \\<forall>w2\\<in>set V.\n          \\<forall>a1\\<in>wordinterval_to_set w1.\n             \\<forall>a2\\<in>wordinterval_to_set w2.\n                same_fw_behaviour_one a1 a2 c rs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. V \\<in> set (groupWIs c rs) \\<Longrightarrow>\n    \\<forall>w1\\<in>set V.\n       \\<forall>w2\\<in>set V.\n          \\<forall>a1\\<in>wordinterval_to_set w1.\n             \\<forall>a2\\<in>wordinterval_to_set w2.\n                same_fw_behaviour_one a1 a2 c rs", "assume asm: \"V \\<in> set (groupWIs c rs)\""], ["proof (state)\nthis:\n  V \\<in> set (groupWIs c rs)\n\ngoal (1 subgoal):\n 1. V \\<in> set (groupWIs c rs) \\<Longrightarrow>\n    \\<forall>w1\\<in>set V.\n       \\<forall>w2\\<in>set V.\n          \\<forall>a1\\<in>wordinterval_to_set w1.\n             \\<forall>a2\\<in>wordinterval_to_set w2.\n                same_fw_behaviour_one a1 a2 c rs", "from getParts_same_fw_behaviour same_fw_spec"], ["proof (chain)\npicking this:\n  \\<lbrakk>?A \\<in> set (map wordinterval_to_set (getParts ?rs));\n   ?s1.0 \\<in> ?A; ?s2.0 \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> same_fw_behaviour ?s1.0 ?s2.0 ?rs\n  same_fw_behaviour ?ip1.0 ?ip2.0 ?rs \\<Longrightarrow>\n  same_fw_behaviour_one ?ip1.0 ?ip2.0 ?c ?rs", "have b1: \"\\<forall>A \\<in> set (map wordinterval_to_set (getParts rs)) . \\<forall>a1 \\<in> A. \\<forall>a2 \\<in> A.\n              same_fw_behaviour_one a1 a2 c rs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> set (map wordinterval_to_set (getParts ?rs));\n   ?s1.0 \\<in> ?A; ?s2.0 \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> same_fw_behaviour ?s1.0 ?s2.0 ?rs\n  same_fw_behaviour ?ip1.0 ?ip2.0 ?rs \\<Longrightarrow>\n  same_fw_behaviour_one ?ip1.0 ?ip2.0 ?c ?rs\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>set (map wordinterval_to_set (getParts rs)).\n       \\<forall>a1\\<in>A.\n          \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs", "by fast"], ["proof (state)\nthis:\n  \\<forall>A\\<in>set (map wordinterval_to_set (getParts rs)).\n     \\<forall>a1\\<in>A. \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs\n\ngoal (1 subgoal):\n 1. V \\<in> set (groupWIs c rs) \\<Longrightarrow>\n    \\<forall>w1\\<in>set V.\n       \\<forall>w2\\<in>set V.\n          \\<forall>a1\\<in>wordinterval_to_set w1.\n             \\<forall>a2\\<in>wordinterval_to_set w2.\n                same_fw_behaviour_one a1 a2 c rs", "from getParts_complete"], ["proof (chain)\npicking this:\n  wordinterval_list_to_set (getParts ?rs) = UNIV", "have complete: \"\\<Union>(set (map wordinterval_to_set (getParts rs))) = UNIV\""], ["proof (prove)\nusing this:\n  wordinterval_list_to_set (getParts ?rs) = UNIV\n\ngoal (1 subgoal):\n 1. \\<Union> (set (map wordinterval_to_set (getParts rs))) = UNIV", "by(simp add: wordinterval_list_to_set_def)"], ["proof (state)\nthis:\n  \\<Union> (set (map wordinterval_to_set (getParts rs))) = UNIV\n\ngoal (1 subgoal):\n 1. V \\<in> set (groupWIs c rs) \\<Longrightarrow>\n    \\<forall>w1\\<in>set V.\n       \\<forall>w2\\<in>set V.\n          \\<forall>a1\\<in>wordinterval_to_set w1.\n             \\<forall>a2\\<in>wordinterval_to_set w2.\n                same_fw_behaviour_one a1 a2 c rs", "from getParts_nonempty_elems"], ["proof (chain)\npicking this:\n  \\<forall>w\\<in>set (getParts ?rs). \\<not> wordinterval_empty w", "have nonempty: \"\\<forall>w\\<in>set (getParts rs). \\<not> wordinterval_empty w\""], ["proof (prove)\nusing this:\n  \\<forall>w\\<in>set (getParts ?rs). \\<not> wordinterval_empty w\n\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set (getParts rs). \\<not> wordinterval_empty w", "by simp"], ["proof (state)\nthis:\n  \\<forall>w\\<in>set (getParts rs). \\<not> wordinterval_empty w\n\ngoal (1 subgoal):\n 1. V \\<in> set (groupWIs c rs) \\<Longrightarrow>\n    \\<forall>w1\\<in>set V.\n       \\<forall>w2\\<in>set V.\n          \\<forall>a1\\<in>wordinterval_to_set w1.\n             \\<forall>a2\\<in>wordinterval_to_set w2.\n                same_fw_behaviour_one a1 a2 c rs", "{"], ["proof (state)\nthis:\n  \\<forall>w\\<in>set (getParts rs). \\<not> wordinterval_empty w\n\ngoal (1 subgoal):\n 1. V \\<in> set (groupWIs c rs) \\<Longrightarrow>\n    \\<forall>w1\\<in>set V.\n       \\<forall>w2\\<in>set V.\n          \\<forall>a1\\<in>wordinterval_to_set w1.\n             \\<forall>a2\\<in>wordinterval_to_set w2.\n                same_fw_behaviour_one a1 a2 c rs", "fix W x1 x2"], ["proof (state)\ngoal (1 subgoal):\n 1. V \\<in> set (groupWIs c rs) \\<Longrightarrow>\n    \\<forall>w1\\<in>set V.\n       \\<forall>w2\\<in>set V.\n          \\<forall>a1\\<in>wordinterval_to_set w1.\n             \\<forall>a2\\<in>wordinterval_to_set w2.\n                same_fw_behaviour_one a1 a2 c rs", "assume a1: \"\\<forall>A \\<in> set (map wordinterval_to_set W). \\<forall>a1 \\<in> A. \\<forall>a2 \\<in> A. same_fw_behaviour_one a1 a2 c rs\"\n    and a2: \"wordinterval_list_to_set W = UNIV\"\n    and a3: \"\\<forall>w \\<in> set W. \\<not> wordinterval_empty w\"\n    and a4: \"(map (\\<lambda>d. runFw x1 d c rs) (map getOneIp W), map (\\<lambda>s. runFw s x1 c rs) (map getOneIp W)) =\n             (map (\\<lambda>d. runFw x2 d c rs) (map getOneIp W), map (\\<lambda>s. runFw s x2 c rs) (map getOneIp W))\""], ["proof (state)\nthis:\n  \\<forall>A\\<in>set (map wordinterval_to_set W).\n     \\<forall>a1\\<in>A. \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs\n  wordinterval_list_to_set W = UNIV\n  \\<forall>w\\<in>set W. \\<not> wordinterval_empty w\n  (map (\\<lambda>d. runFw x1 d c rs) (map getOneIp W),\n   map (\\<lambda>s. runFw s x1 c rs) (map getOneIp W)) =\n  (map (\\<lambda>d. runFw x2 d c rs) (map getOneIp W),\n   map (\\<lambda>s. runFw s x2 c rs) (map getOneIp W))\n\ngoal (1 subgoal):\n 1. V \\<in> set (groupWIs c rs) \\<Longrightarrow>\n    \\<forall>w1\\<in>set V.\n       \\<forall>w2\\<in>set V.\n          \\<forall>a1\\<in>wordinterval_to_set w1.\n             \\<forall>a2\\<in>wordinterval_to_set w2.\n                same_fw_behaviour_one a1 a2 c rs", "from a3 a4 getOneIp_elem"], ["proof (chain)\npicking this:\n  \\<forall>w\\<in>set W. \\<not> wordinterval_empty w\n  (map (\\<lambda>d. runFw x1 d c rs) (map getOneIp W),\n   map (\\<lambda>s. runFw s x1 c rs) (map getOneIp W)) =\n  (map (\\<lambda>d. runFw x2 d c rs) (map getOneIp W),\n   map (\\<lambda>s. runFw s x2 c rs) (map getOneIp W))\n  \\<not> wordinterval_empty ?W \\<Longrightarrow>\n  wordinterval_element (getOneIp ?W) ?W", "have b1: \"\\<forall>B \\<in> set (map wordinterval_to_set W). \\<exists>b \\<in> B. runFw x1 b c rs = runFw x2 b c rs\""], ["proof (prove)\nusing this:\n  \\<forall>w\\<in>set W. \\<not> wordinterval_empty w\n  (map (\\<lambda>d. runFw x1 d c rs) (map getOneIp W),\n   map (\\<lambda>s. runFw s x1 c rs) (map getOneIp W)) =\n  (map (\\<lambda>d. runFw x2 d c rs) (map getOneIp W),\n   map (\\<lambda>s. runFw s x2 c rs) (map getOneIp W))\n  \\<not> wordinterval_empty ?W \\<Longrightarrow>\n  wordinterval_element (getOneIp ?W) ?W\n\ngoal (1 subgoal):\n 1. \\<forall>B\\<in>set (map wordinterval_to_set W).\n       \\<exists>b\\<in>B. runFw x1 b c rs = runFw x2 b c rs", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>B\\<in>set (map wordinterval_to_set W).\n     \\<exists>b\\<in>B. runFw x1 b c rs = runFw x2 b c rs\n\ngoal (1 subgoal):\n 1. V \\<in> set (groupWIs c rs) \\<Longrightarrow>\n    \\<forall>w1\\<in>set V.\n       \\<forall>w2\\<in>set V.\n          \\<forall>a1\\<in>wordinterval_to_set w1.\n             \\<forall>a2\\<in>wordinterval_to_set w2.\n                same_fw_behaviour_one a1 a2 c rs", "from a3 a4 getOneIp_elem"], ["proof (chain)\npicking this:\n  \\<forall>w\\<in>set W. \\<not> wordinterval_empty w\n  (map (\\<lambda>d. runFw x1 d c rs) (map getOneIp W),\n   map (\\<lambda>s. runFw s x1 c rs) (map getOneIp W)) =\n  (map (\\<lambda>d. runFw x2 d c rs) (map getOneIp W),\n   map (\\<lambda>s. runFw s x2 c rs) (map getOneIp W))\n  \\<not> wordinterval_empty ?W \\<Longrightarrow>\n  wordinterval_element (getOneIp ?W) ?W", "have b2: \"\\<forall>B \\<in> set (map wordinterval_to_set W). \\<exists>b \\<in> B. runFw b x1 c rs = runFw b x2 c rs\""], ["proof (prove)\nusing this:\n  \\<forall>w\\<in>set W. \\<not> wordinterval_empty w\n  (map (\\<lambda>d. runFw x1 d c rs) (map getOneIp W),\n   map (\\<lambda>s. runFw s x1 c rs) (map getOneIp W)) =\n  (map (\\<lambda>d. runFw x2 d c rs) (map getOneIp W),\n   map (\\<lambda>s. runFw s x2 c rs) (map getOneIp W))\n  \\<not> wordinterval_empty ?W \\<Longrightarrow>\n  wordinterval_element (getOneIp ?W) ?W\n\ngoal (1 subgoal):\n 1. \\<forall>B\\<in>set (map wordinterval_to_set W).\n       \\<exists>b\\<in>B. runFw b x1 c rs = runFw b x2 c rs", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>B\\<in>set (map wordinterval_to_set W).\n     \\<exists>b\\<in>B. runFw b x1 c rs = runFw b x2 c rs\n\ngoal (1 subgoal):\n 1. V \\<in> set (groupWIs c rs) \\<Longrightarrow>\n    \\<forall>w1\\<in>set V.\n       \\<forall>w2\\<in>set V.\n          \\<forall>a1\\<in>wordinterval_to_set w1.\n             \\<forall>a2\\<in>wordinterval_to_set w2.\n                same_fw_behaviour_one a1 a2 c rs", "from runFw_sameFw_behave[OF a1 _ b1 b2] a2[unfolded wordinterval_list_to_set_def]"], ["proof (chain)\npicking this:\n  \\<Union> (set (map wordinterval_to_set W)) = UNIV \\<Longrightarrow>\n  same_fw_behaviour_one x1 x2 c rs\n  \\<Union> (set (map wordinterval_to_set W)) = UNIV", "have\n        \"same_fw_behaviour_one x1 x2 c rs\""], ["proof (prove)\nusing this:\n  \\<Union> (set (map wordinterval_to_set W)) = UNIV \\<Longrightarrow>\n  same_fw_behaviour_one x1 x2 c rs\n  \\<Union> (set (map wordinterval_to_set W)) = UNIV\n\ngoal (1 subgoal):\n 1. same_fw_behaviour_one x1 x2 c rs", "by simp"], ["proof (state)\nthis:\n  same_fw_behaviour_one x1 x2 c rs\n\ngoal (1 subgoal):\n 1. V \\<in> set (groupWIs c rs) \\<Longrightarrow>\n    \\<forall>w1\\<in>set V.\n       \\<forall>w2\\<in>set V.\n          \\<forall>a1\\<in>wordinterval_to_set w1.\n             \\<forall>a2\\<in>wordinterval_to_set w2.\n                same_fw_behaviour_one a1 a2 c rs", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>A\\<in>set (map wordinterval_to_set ?W2).\n              \\<forall>a1\\<in>A.\n                 \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs;\n   wordinterval_list_to_set ?W2 = UNIV;\n   \\<forall>w\\<in>set ?W2. \\<not> wordinterval_empty w;\n   (map (\\<lambda>d. runFw ?x1.2 d c rs) (map getOneIp ?W2),\n    map (\\<lambda>s. runFw s ?x1.2 c rs) (map getOneIp ?W2)) =\n   (map (\\<lambda>d. runFw ?x2.2 d c rs) (map getOneIp ?W2),\n    map (\\<lambda>s. runFw s ?x2.2 c rs) (map getOneIp ?W2))\\<rbrakk>\n  \\<Longrightarrow> same_fw_behaviour_one ?x1.2 ?x2.2 c rs\n\ngoal (1 subgoal):\n 1. V \\<in> set (groupWIs c rs) \\<Longrightarrow>\n    \\<forall>w1\\<in>set V.\n       \\<forall>w2\\<in>set V.\n          \\<forall>a1\\<in>wordinterval_to_set w1.\n             \\<forall>a2\\<in>wordinterval_to_set w2.\n                same_fw_behaviour_one a1 a2 c rs", "note same_behave_runFw=this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>A\\<in>set (map wordinterval_to_set ?W2).\n              \\<forall>a1\\<in>A.\n                 \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs;\n   wordinterval_list_to_set ?W2 = UNIV;\n   \\<forall>w\\<in>set ?W2. \\<not> wordinterval_empty w;\n   (map (\\<lambda>d. runFw ?x1.2 d c rs) (map getOneIp ?W2),\n    map (\\<lambda>s. runFw s ?x1.2 c rs) (map getOneIp ?W2)) =\n   (map (\\<lambda>d. runFw ?x2.2 d c rs) (map getOneIp ?W2),\n    map (\\<lambda>s. runFw s ?x2.2 c rs) (map getOneIp ?W2))\\<rbrakk>\n  \\<Longrightarrow> same_fw_behaviour_one ?x1.2 ?x2.2 c rs\n\ngoal (1 subgoal):\n 1. V \\<in> set (groupWIs c rs) \\<Longrightarrow>\n    \\<forall>w1\\<in>set V.\n       \\<forall>w2\\<in>set V.\n          \\<forall>a1\\<in>wordinterval_to_set w1.\n             \\<forall>a2\\<in>wordinterval_to_set w2.\n                same_fw_behaviour_one a1 a2 c rs", "from same_behave_runFw[OF b1 getParts_complete nonempty]\n       groupF_equality[of \"(\\<lambda>wi. (map (\\<lambda>d. runFw (getOneIp wi) d c rs) (map getOneIp (getParts rs)),\n                             map (\\<lambda>s. runFw s (getOneIp wi) c rs) (map getOneIp (getParts rs))))\"\n                     \"(getParts rs)\"] asm"], ["proof (chain)\npicking this:\n  (map (\\<lambda>d. runFw ?x1.2 d c rs) (map getOneIp (getParts rs)),\n   map (\\<lambda>s. runFw s ?x1.2 c rs) (map getOneIp (getParts rs))) =\n  (map (\\<lambda>d. runFw ?x2.2 d c rs) (map getOneIp (getParts rs)),\n   map (\\<lambda>s. runFw s ?x2.2 c rs)\n    (map getOneIp (getParts rs))) \\<Longrightarrow>\n  same_fw_behaviour_one ?x1.2 ?x2.2 c rs\n  \\<forall>A\\<in>set (groupF\n                       (\\<lambda>wi.\n                           (map (\\<lambda>d. runFw (getOneIp wi) d c rs)\n                             (map getOneIp (getParts rs)),\n                            map (\\<lambda>s. runFw s (getOneIp wi) c rs)\n                             (map getOneIp (getParts rs))))\n                       (getParts rs)).\n     \\<forall>a1\\<in>set A.\n        \\<forall>a2\\<in>set A.\n           (map (\\<lambda>d. runFw (getOneIp a1) d c rs)\n             (map getOneIp (getParts rs)),\n            map (\\<lambda>s. runFw s (getOneIp a1) c rs)\n             (map getOneIp (getParts rs))) =\n           (map (\\<lambda>d. runFw (getOneIp a2) d c rs)\n             (map getOneIp (getParts rs)),\n            map (\\<lambda>s. runFw s (getOneIp a2) c rs)\n             (map getOneIp (getParts rs)))\n  V \\<in> set (groupWIs c rs)", "have b2: \"\\<forall>a1\\<in>set V. \\<forall>a2\\<in>set V. same_fw_behaviour_one (getOneIp a1) (getOneIp a2) c rs\""], ["proof (prove)\nusing this:\n  (map (\\<lambda>d. runFw ?x1.2 d c rs) (map getOneIp (getParts rs)),\n   map (\\<lambda>s. runFw s ?x1.2 c rs) (map getOneIp (getParts rs))) =\n  (map (\\<lambda>d. runFw ?x2.2 d c rs) (map getOneIp (getParts rs)),\n   map (\\<lambda>s. runFw s ?x2.2 c rs)\n    (map getOneIp (getParts rs))) \\<Longrightarrow>\n  same_fw_behaviour_one ?x1.2 ?x2.2 c rs\n  \\<forall>A\\<in>set (groupF\n                       (\\<lambda>wi.\n                           (map (\\<lambda>d. runFw (getOneIp wi) d c rs)\n                             (map getOneIp (getParts rs)),\n                            map (\\<lambda>s. runFw s (getOneIp wi) c rs)\n                             (map getOneIp (getParts rs))))\n                       (getParts rs)).\n     \\<forall>a1\\<in>set A.\n        \\<forall>a2\\<in>set A.\n           (map (\\<lambda>d. runFw (getOneIp a1) d c rs)\n             (map getOneIp (getParts rs)),\n            map (\\<lambda>s. runFw s (getOneIp a1) c rs)\n             (map getOneIp (getParts rs))) =\n           (map (\\<lambda>d. runFw (getOneIp a2) d c rs)\n             (map getOneIp (getParts rs)),\n            map (\\<lambda>s. runFw s (getOneIp a2) c rs)\n             (map getOneIp (getParts rs)))\n  V \\<in> set (groupWIs c rs)\n\ngoal (1 subgoal):\n 1. \\<forall>a1\\<in>set V.\n       \\<forall>a2\\<in>set V.\n          same_fw_behaviour_one (getOneIp a1) (getOneIp a2) c rs", "apply(subst (asm) groupWIs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x1 x2.\n                (map (\\<lambda>d. runFw x1 d c rs)\n                  (map getOneIp (getParts rs)),\n                 map (\\<lambda>s. runFw s x1 c rs)\n                  (map getOneIp (getParts rs))) =\n                (map (\\<lambda>d. runFw x2 d c rs)\n                  (map getOneIp (getParts rs)),\n                 map (\\<lambda>s. runFw s x2 c rs)\n                  (map getOneIp (getParts rs))) \\<Longrightarrow>\n                same_fw_behaviour_one x1 x2 c rs;\n     \\<forall>A\\<in>set (groupF\n                          (\\<lambda>wi.\n                              (map (\\<lambda>d. runFw (getOneIp wi) d c rs)\n                                (map getOneIp (getParts rs)),\n                               map (\\<lambda>s. runFw s (getOneIp wi) c rs)\n                                (map getOneIp (getParts rs))))\n                          (getParts rs)).\n        \\<forall>a1\\<in>set A.\n           \\<forall>a2\\<in>set A.\n              (map (\\<lambda>d. runFw (getOneIp a1) d c rs)\n                (map getOneIp (getParts rs)),\n               map (\\<lambda>s. runFw s (getOneIp a1) c rs)\n                (map getOneIp (getParts rs))) =\n              (map (\\<lambda>d. runFw (getOneIp a2) d c rs)\n                (map getOneIp (getParts rs)),\n               map (\\<lambda>s. runFw s (getOneIp a2) c rs)\n                (map getOneIp (getParts rs)));\n     V \\<in> set (let W = getParts rs;\n                      f = \\<lambda>wi.\n                             (map (\\<lambda>d. runFw (getOneIp wi) d c rs)\n                               (map getOneIp W),\n                              map (\\<lambda>s. runFw s (getOneIp wi) c rs)\n                               (map getOneIp W))\n                  in groupF f W)\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a1\\<in>set V.\n                         \\<forall>a2\\<in>set V.\n                            same_fw_behaviour_one (getOneIp a1)\n                             (getOneIp a2) c rs", "apply(subst (asm) Let_def)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>x1 x2.\n                (map (\\<lambda>d. runFw x1 d c rs)\n                  (map getOneIp (getParts rs)),\n                 map (\\<lambda>s. runFw s x1 c rs)\n                  (map getOneIp (getParts rs))) =\n                (map (\\<lambda>d. runFw x2 d c rs)\n                  (map getOneIp (getParts rs)),\n                 map (\\<lambda>s. runFw s x2 c rs)\n                  (map getOneIp (getParts rs))) \\<Longrightarrow>\n                same_fw_behaviour_one x1 x2 c rs;\n     \\<forall>A\\<in>set (groupF\n                          (\\<lambda>wi.\n                              (map (\\<lambda>d. runFw (getOneIp wi) d c rs)\n                                (map getOneIp (getParts rs)),\n                               map (\\<lambda>s. runFw s (getOneIp wi) c rs)\n                                (map getOneIp (getParts rs))))\n                          (getParts rs)).\n        \\<forall>a1\\<in>set A.\n           \\<forall>a2\\<in>set A.\n              (map (\\<lambda>d. runFw (getOneIp a1) d c rs)\n                (map getOneIp (getParts rs)),\n               map (\\<lambda>s. runFw s (getOneIp a1) c rs)\n                (map getOneIp (getParts rs))) =\n              (map (\\<lambda>d. runFw (getOneIp a2) d c rs)\n                (map getOneIp (getParts rs)),\n               map (\\<lambda>s. runFw s (getOneIp a2) c rs)\n                (map getOneIp (getParts rs)));\n     V \\<in> set (groupF\n                   (\\<lambda>wi.\n                       (map (\\<lambda>d. runFw (getOneIp wi) d c rs)\n                         (map getOneIp (getParts rs)),\n                        map (\\<lambda>s. runFw s (getOneIp wi) c rs)\n                         (map getOneIp (getParts rs))))\n                   (getParts rs))\\<rbrakk>\n    \\<Longrightarrow> \\<forall>a1\\<in>set V.\n                         \\<forall>a2\\<in>set V.\n                            same_fw_behaviour_one (getOneIp a1)\n                             (getOneIp a2) c rs", "by fast"], ["proof (state)\nthis:\n  \\<forall>a1\\<in>set V.\n     \\<forall>a2\\<in>set V.\n        same_fw_behaviour_one (getOneIp a1) (getOneIp a2) c rs\n\ngoal (1 subgoal):\n 1. V \\<in> set (groupWIs c rs) \\<Longrightarrow>\n    \\<forall>w1\\<in>set V.\n       \\<forall>w2\\<in>set V.\n          \\<forall>a1\\<in>wordinterval_to_set w1.\n             \\<forall>a2\\<in>wordinterval_to_set w2.\n                same_fw_behaviour_one a1 a2 c rs", "from groupWIs_not_empty_elems asm"], ["proof (chain)\npicking this:\n  \\<lbrakk>?V \\<in> set (groupWIs ?c ?rs); ?w \\<in> set ?V\\<rbrakk>\n  \\<Longrightarrow> \\<not> wordinterval_empty ?w\n  V \\<in> set (groupWIs c rs)", "have \"\\<forall>w \\<in> set V. \\<not> wordinterval_empty w\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?V \\<in> set (groupWIs ?c ?rs); ?w \\<in> set ?V\\<rbrakk>\n  \\<Longrightarrow> \\<not> wordinterval_empty ?w\n  V \\<in> set (groupWIs c rs)\n\ngoal (1 subgoal):\n 1. \\<forall>w\\<in>set V. \\<not> wordinterval_empty w", "by blast"], ["proof (state)\nthis:\n  \\<forall>w\\<in>set V. \\<not> wordinterval_empty w\n\ngoal (1 subgoal):\n 1. V \\<in> set (groupWIs c rs) \\<Longrightarrow>\n    \\<forall>w1\\<in>set V.\n       \\<forall>w2\\<in>set V.\n          \\<forall>a1\\<in>wordinterval_to_set w1.\n             \\<forall>a2\\<in>wordinterval_to_set w2.\n                same_fw_behaviour_one a1 a2 c rs", "from this b2 getOneIp_elem"], ["proof (chain)\npicking this:\n  \\<forall>w\\<in>set V. \\<not> wordinterval_empty w\n  \\<forall>a1\\<in>set V.\n     \\<forall>a2\\<in>set V.\n        same_fw_behaviour_one (getOneIp a1) (getOneIp a2) c rs\n  \\<not> wordinterval_empty ?W \\<Longrightarrow>\n  wordinterval_element (getOneIp ?W) ?W", "have b3: \"\\<forall>w1\\<in>set (map wordinterval_to_set V). \\<forall>w2\\<in>set (map wordinterval_to_set V). \n           \\<exists>ip1\\<in> w1. \\<exists>ip2\\<in>w2.\n           same_fw_behaviour_one ip1 ip2 c rs\""], ["proof (prove)\nusing this:\n  \\<forall>w\\<in>set V. \\<not> wordinterval_empty w\n  \\<forall>a1\\<in>set V.\n     \\<forall>a2\\<in>set V.\n        same_fw_behaviour_one (getOneIp a1) (getOneIp a2) c rs\n  \\<not> wordinterval_empty ?W \\<Longrightarrow>\n  wordinterval_element (getOneIp ?W) ?W\n\ngoal (1 subgoal):\n 1. \\<forall>w1\\<in>set (map wordinterval_to_set V).\n       \\<forall>w2\\<in>set (map wordinterval_to_set V).\n          \\<exists>ip1\\<in>w1.\n             \\<exists>ip2\\<in>w2. same_fw_behaviour_one ip1 ip2 c rs", "by (simp) (blast)"], ["proof (state)\nthis:\n  \\<forall>w1\\<in>set (map wordinterval_to_set V).\n     \\<forall>w2\\<in>set (map wordinterval_to_set V).\n        \\<exists>ip1\\<in>w1.\n           \\<exists>ip2\\<in>w2. same_fw_behaviour_one ip1 ip2 c rs\n\ngoal (1 subgoal):\n 1. V \\<in> set (groupWIs c rs) \\<Longrightarrow>\n    \\<forall>w1\\<in>set V.\n       \\<forall>w2\\<in>set V.\n          \\<forall>a1\\<in>wordinterval_to_set w1.\n             \\<forall>a2\\<in>wordinterval_to_set w2.\n                same_fw_behaviour_one a1 a2 c rs", "from groupParts_same_fw_wi0 asm"], ["proof (chain)\npicking this:\n  ?V \\<in> set (groupWIs ?c ?rs) \\<Longrightarrow>\n  \\<forall>w\\<in>set (map wordinterval_to_set ?V).\n     \\<forall>a1\\<in>w.\n        \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 ?c ?rs\n  V \\<in> set (groupWIs c rs)", "have \"\\<forall>A\\<in>set (map wordinterval_to_set V). \\<forall>a1\\<in> A. \\<forall>a2\\<in> A. same_fw_behaviour_one a1 a2 c rs\""], ["proof (prove)\nusing this:\n  ?V \\<in> set (groupWIs ?c ?rs) \\<Longrightarrow>\n  \\<forall>w\\<in>set (map wordinterval_to_set ?V).\n     \\<forall>a1\\<in>w.\n        \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 ?c ?rs\n  V \\<in> set (groupWIs c rs)\n\ngoal (1 subgoal):\n 1. \\<forall>A\\<in>set (map wordinterval_to_set V).\n       \\<forall>a1\\<in>A.\n          \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs", "by metis"], ["proof (state)\nthis:\n  \\<forall>A\\<in>set (map wordinterval_to_set V).\n     \\<forall>a1\\<in>A. \\<forall>a2\\<in>A. same_fw_behaviour_one a1 a2 c rs\n\ngoal (1 subgoal):\n 1. V \\<in> set (groupWIs c rs) \\<Longrightarrow>\n    \\<forall>w1\\<in>set V.\n       \\<forall>w2\\<in>set V.\n          \\<forall>a1\\<in>wordinterval_to_set w1.\n             \\<forall>a2\\<in>wordinterval_to_set w2.\n                same_fw_behaviour_one a1 a2 c rs", "from sameFw_behave_sets[OF this b3]"], ["proof (chain)\npicking this:\n  \\<forall>w1\\<in>set (map wordinterval_to_set V).\n     \\<forall>w2\\<in>set (map wordinterval_to_set V).\n        \\<forall>a1\\<in>w1.\n           \\<forall>a2\\<in>w2. same_fw_behaviour_one a1 a2 c rs", "show \"\\<forall>w1 \\<in> set V. \\<forall>w2 \\<in> set V.\n   \\<forall>a1 \\<in> wordinterval_to_set w1. \\<forall>a2 \\<in> wordinterval_to_set w2. same_fw_behaviour_one a1 a2 c rs\""], ["proof (prove)\nusing this:\n  \\<forall>w1\\<in>set (map wordinterval_to_set V).\n     \\<forall>w2\\<in>set (map wordinterval_to_set V).\n        \\<forall>a1\\<in>w1.\n           \\<forall>a2\\<in>w2. same_fw_behaviour_one a1 a2 c rs\n\ngoal (1 subgoal):\n 1. \\<forall>w1\\<in>set V.\n       \\<forall>w2\\<in>set V.\n          \\<forall>a1\\<in>wordinterval_to_set w1.\n             \\<forall>a2\\<in>wordinterval_to_set w2.\n                same_fw_behaviour_one a1 a2 c rs", "by force"], ["proof (state)\nthis:\n  \\<forall>w1\\<in>set V.\n     \\<forall>w2\\<in>set V.\n        \\<forall>a1\\<in>wordinterval_to_set w1.\n           \\<forall>a2\\<in>wordinterval_to_set w2.\n              same_fw_behaviour_one a1 a2 c rs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma groupParts_same_fw_wi2: \"V \\<in> set (groupWIs c rs) \\<Longrightarrow>\n                               \\<forall>ip1 \\<in> wordinterval_list_to_set V.\n                               \\<forall>ip2 \\<in> wordinterval_list_to_set V.\n                               same_fw_behaviour_one ip1 ip2 c rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<in> set (groupWIs c rs) \\<Longrightarrow>\n    \\<forall>ip1\\<in>wordinterval_list_to_set V.\n       \\<forall>ip2\\<in>wordinterval_list_to_set V.\n          same_fw_behaviour_one ip1 ip2 c rs", "using groupParts_same_fw_wi0 groupParts_same_fw_wi1"], ["proof (prove)\nusing this:\n  ?V \\<in> set (groupWIs ?c ?rs) \\<Longrightarrow>\n  \\<forall>w\\<in>set (map wordinterval_to_set ?V).\n     \\<forall>a1\\<in>w.\n        \\<forall>a2\\<in>w. same_fw_behaviour_one a1 a2 ?c ?rs\n  ?V \\<in> set (groupWIs ?c ?rs) \\<Longrightarrow>\n  \\<forall>w1\\<in>set ?V.\n     \\<forall>w2\\<in>set ?V.\n        \\<forall>a1\\<in>wordinterval_to_set w1.\n           \\<forall>a2\\<in>wordinterval_to_set w2.\n              same_fw_behaviour_one a1 a2 ?c ?rs\n\ngoal (1 subgoal):\n 1. V \\<in> set (groupWIs c rs) \\<Longrightarrow>\n    \\<forall>ip1\\<in>wordinterval_list_to_set V.\n       \\<forall>ip2\\<in>wordinterval_list_to_set V.\n          same_fw_behaviour_one ip1 ip2 c rs", "apply (simp add: wordinterval_list_to_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>V \\<in> set (groupWIs c rs);\n     \\<And>V c rs.\n        V \\<in> set (groupWIs c rs) \\<Longrightarrow>\n        \\<forall>w\\<in>set V.\n           \\<forall>a1\\<in>wordinterval_to_set w.\n              \\<forall>a2\\<in>wordinterval_to_set w.\n                 same_fw_behaviour_one a1 a2 c rs;\n     \\<And>V c rs.\n        V \\<in> set (groupWIs c rs) \\<Longrightarrow>\n        \\<forall>w1\\<in>set V.\n           \\<forall>w2\\<in>set V.\n              \\<forall>a1\\<in>wordinterval_to_set w1.\n                 \\<forall>a2\\<in>wordinterval_to_set w2.\n                    same_fw_behaviour_one a1 a2 c rs\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y\\<in>set V.\n                         \\<forall>ip1\\<in>wordinterval_to_set y.\n                            \\<forall>y\\<in>set V.\n                               \\<forall>ip2\\<in>wordinterval_to_set y.\n                                  same_fw_behaviour_one ip1 ip2 c rs", "by fast"], ["", "lemma groupWIs_same_fw_not2: \"A \\<in> set (groupWIs c rs) \\<Longrightarrow> B \\<in> set (groupWIs c rs) \\<Longrightarrow> \n                                A \\<noteq> B \\<Longrightarrow>\n                                \\<forall>ip1 \\<in> wordinterval_list_to_set A.\n                                \\<forall>ip2 \\<in> wordinterval_list_to_set B.\n                                \\<not> same_fw_behaviour_one ip1 ip2 c rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> set (groupWIs c rs); B \\<in> set (groupWIs c rs);\n     A \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> \\<forall>ip1\\<in>wordinterval_list_to_set A.\n                         \\<forall>ip2\\<in>wordinterval_list_to_set B.\n                            \\<not> same_fw_behaviour_one ip1 ip2 c rs", "apply(simp add: wordinterval_list_to_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> set (groupWIs c rs); B \\<in> set (groupWIs c rs);\n     A \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y\\<in>set A.\n                         \\<forall>ip1\\<in>wordinterval_to_set y.\n                            \\<forall>y\\<in>set B.\n                               \\<forall>ip2\\<in>wordinterval_to_set y.\n                                  \\<not> same_fw_behaviour_one ip1 ip2 c rs", "using groupWIs_same_fw_not"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> set (groupWIs ?c ?rs); ?B \\<in> set (groupWIs ?c ?rs);\n   ?A \\<noteq> ?B\\<rbrakk>\n  \\<Longrightarrow> \\<forall>aw\\<in>set (map wordinterval_to_set ?A).\n                       \\<forall>bw\\<in>set (map wordinterval_to_set ?B).\n                          \\<forall>a\\<in>aw.\n                             \\<forall>b\\<in>bw.\n                                \\<not> same_fw_behaviour_one a b ?c ?rs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> set (groupWIs c rs); B \\<in> set (groupWIs c rs);\n     A \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> \\<forall>y\\<in>set A.\n                         \\<forall>ip1\\<in>wordinterval_to_set y.\n                            \\<forall>y\\<in>set B.\n                               \\<forall>ip2\\<in>wordinterval_to_set y.\n                                  \\<not> same_fw_behaviour_one ip1 ip2 c rs", "by fastforce"], ["", "(*I like this version -- corny*)"], ["", "lemma \"A \\<in> set (groupWIs c rs) \\<Longrightarrow> B \\<in> set (groupWIs c rs) \\<Longrightarrow> \n                \\<exists>ip1 \\<in> wordinterval_list_to_set A.\n                \\<exists>ip2 \\<in> wordinterval_list_to_set B. same_fw_behaviour_one ip1 ip2 c rs\n                \\<Longrightarrow> A = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> set (groupWIs c rs); B \\<in> set (groupWIs c rs);\n     \\<exists>ip1\\<in>wordinterval_list_to_set A.\n        \\<exists>ip2\\<in>wordinterval_list_to_set B.\n           same_fw_behaviour_one ip1 ip2 c rs\\<rbrakk>\n    \\<Longrightarrow> A = B", "using groupWIs_same_fw_not2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> set (groupWIs ?c ?rs); ?B \\<in> set (groupWIs ?c ?rs);\n   ?A \\<noteq> ?B\\<rbrakk>\n  \\<Longrightarrow> \\<forall>ip1\\<in>wordinterval_list_to_set ?A.\n                       \\<forall>ip2\\<in>wordinterval_list_to_set ?B.\n                          \\<not> same_fw_behaviour_one ip1 ip2 ?c ?rs\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> set (groupWIs c rs); B \\<in> set (groupWIs c rs);\n     \\<exists>ip1\\<in>wordinterval_list_to_set A.\n        \\<exists>ip2\\<in>wordinterval_list_to_set B.\n           same_fw_behaviour_one ip1 ip2 c rs\\<rbrakk>\n    \\<Longrightarrow> A = B", "by blast"], ["", "lemma groupWIs_complete: \"(\\<Union>x\\<in> set (groupWIs c rs). wordinterval_list_to_set x) = (UNIV::'i::len word set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (wordinterval_list_to_set ` set (groupWIs c rs)) = UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Union> (wordinterval_list_to_set ` set (groupWIs c rs)) = UNIV", "have \"(\\<Union> y \\<in> (\\<Union>x\\<in> set (groupWIs c rs). set x). wordinterval_to_set y) = (UNIV::'i word set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (wordinterval_to_set ` \\<Union> (set ` set (groupWIs c rs))) =\n    UNIV", "apply(simp add: groupWIs_def Let_def groupF_Union_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (wordinterval_to_set ` set (getParts rs)) = UNIV", "using getParts_complete wordinterval_list_to_set_def"], ["proof (prove)\nusing this:\n  wordinterval_list_to_set (getParts ?rs) = UNIV\n  wordinterval_list_to_set ?ws =\n  \\<Union> (set (map wordinterval_to_set ?ws))\n\ngoal (1 subgoal):\n 1. \\<Union> (wordinterval_to_set ` set (getParts rs)) = UNIV", "by fastforce"], ["proof (state)\nthis:\n  \\<Union> (wordinterval_to_set ` \\<Union> (set ` set (groupWIs c rs))) =\n  UNIV\n\ngoal (1 subgoal):\n 1. \\<Union> (wordinterval_list_to_set ` set (groupWIs c rs)) = UNIV", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<Union> (wordinterval_to_set ` \\<Union> (set ` set (groupWIs c rs))) =\n  UNIV\n\ngoal (1 subgoal):\n 1. \\<Union> (wordinterval_list_to_set ` set (groupWIs c rs)) = UNIV", "by(simp add: wordinterval_list_to_set_def)"], ["proof (state)\nthis:\n  \\<Union> (wordinterval_list_to_set ` set (groupWIs c rs)) = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "(*begin groupWIs1 and groupWIs2 optimization*)"], ["", "definition groupWIs1 :: \"'a parts_connection_scheme \\<Rightarrow> 'i::len simple_rule list \\<Rightarrow> 'i wordinterval list list\" where\n    \"groupWIs1 c rs = (let P = getParts rs in\n                        (let W = map getOneIp P in \n                         (let f = (\\<lambda>wi. (map (\\<lambda>d. runFw (getOneIp wi) d c rs) W,\n                                         map (\\<lambda>s. runFw s (getOneIp wi) c rs) W)) in\n                        map (map fst) (groupF snd (map (\\<lambda>x. (x, f x)) P)))))\""], ["", "lemma groupWIs_groupWIs1_equi: \"groupWIs1 c rs = groupWIs c rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. groupWIs1 c rs = groupWIs c rs", "apply(subst groupWIs1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let P = getParts rs; W = map getOneIp P;\n         f = \\<lambda>wi.\n                (map (\\<lambda>d. runFw (getOneIp wi) d c rs) W,\n                 map (\\<lambda>s. runFw s (getOneIp wi) c rs) W)\n     in map (map fst) (groupF snd (map (\\<lambda>x. (x, f x)) P))) =\n    groupWIs c rs", "apply(subst groupWIs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let P = getParts rs; W = map getOneIp P;\n         f = \\<lambda>wi.\n                (map (\\<lambda>d. runFw (getOneIp wi) d c rs) W,\n                 map (\\<lambda>s. runFw s (getOneIp wi) c rs) W)\n     in map (map fst) (groupF snd (map (\\<lambda>x. (x, f x)) P))) =\n    (let W = getParts rs;\n         f = \\<lambda>wi.\n                (map (\\<lambda>d. runFw (getOneIp wi) d c rs)\n                  (map getOneIp W),\n                 map (\\<lambda>s. runFw s (getOneIp wi) c rs)\n                  (map getOneIp W))\n     in groupF f W)", "using groupF_tuple"], ["proof (prove)\nusing this:\n  groupF ?f ?xs =\n  map (map fst) (groupF snd (map (\\<lambda>x. (x, ?f x)) ?xs))\n\ngoal (1 subgoal):\n 1. (let P = getParts rs; W = map getOneIp P;\n         f = \\<lambda>wi.\n                (map (\\<lambda>d. runFw (getOneIp wi) d c rs) W,\n                 map (\\<lambda>s. runFw s (getOneIp wi) c rs) W)\n     in map (map fst) (groupF snd (map (\\<lambda>x. (x, f x)) P))) =\n    (let W = getParts rs;\n         f = \\<lambda>wi.\n                (map (\\<lambda>d. runFw (getOneIp wi) d c rs)\n                  (map getOneIp W),\n                 map (\\<lambda>s. runFw s (getOneIp wi) c rs)\n                  (map getOneIp W))\n     in groupF f W)", "by metis"], ["", "definition simple_conn_matches :: \"'i::len simple_match \\<Rightarrow> parts_connection \\<Rightarrow> bool\" where\n      \"simple_conn_matches m c \\<longleftrightarrow>\n        (match_iface (iiface m) (pc_iiface c)) \\<and>\n        (match_iface (oiface m) (pc_oiface c)) \\<and>\n        (match_proto (proto m) (pc_proto c)) \\<and>\n        (simple_match_port (sports m) (pc_sport c)) \\<and>\n        (simple_match_port (dports m) (pc_dport c))\""], ["", "lemma simple_conn_matches_simple_match_any: \"simple_conn_matches simple_match_any c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_conn_matches simple_match_any c", "apply (simp add: simple_conn_matches_def simple_match_any_def match_ifaceAny)"], ["proof (prove)\ngoal (1 subgoal):\n 1. pc_sport c \\<le> 65535 \\<and> pc_dport c \\<le> 65535", "apply (subgoal_tac \"(65535::16 word) = max_word\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. 65535 = - 1 \\<Longrightarrow>\n    pc_sport c \\<le> 65535 \\<and> pc_dport c \\<le> 65535\n 2. 65535 = - 1", "apply (simp only:)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 65535 = - 1 \\<Longrightarrow>\n    pc_sport c \\<le> - 1 \\<and> pc_dport c \\<le> - 1\n 2. 65535 = - 1", "apply simp_all"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma has_default_policy_simple_conn_matches:\n    \"has_default_policy rs \\<Longrightarrow> has_default_policy [r\\<leftarrow>rs . simple_conn_matches (match_sel r) c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_default_policy rs \\<Longrightarrow>\n    has_default_policy\n     (filter (\\<lambda>r. simple_conn_matches (match_sel r) c) rs)", "apply(induction rs rule: has_default_policy.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. has_default_policy [] \\<Longrightarrow>\n    has_default_policy\n     (filter (\\<lambda>r. simple_conn_matches (match_sel r) c) [])\n 2. \\<And>m uu_.\n       has_default_policy [SimpleRule m uu_] \\<Longrightarrow>\n       has_default_policy\n        (filter (\\<lambda>r. simple_conn_matches (match_sel r) c)\n          [SimpleRule m uu_])\n 3. \\<And>uv_ v va.\n       \\<lbrakk>has_default_policy (v # va) \\<Longrightarrow>\n                has_default_policy\n                 (filter (\\<lambda>r. simple_conn_matches (match_sel r) c)\n                   (v # va));\n        has_default_policy (uv_ # v # va)\\<rbrakk>\n       \\<Longrightarrow> has_default_policy\n                          (filter\n                            (\\<lambda>r.\n                                simple_conn_matches (match_sel r) c)\n                            (uv_ # v # va))", "apply(simp; fail)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>m uu_.\n       has_default_policy [SimpleRule m uu_] \\<Longrightarrow>\n       has_default_policy\n        (filter (\\<lambda>r. simple_conn_matches (match_sel r) c)\n          [SimpleRule m uu_])\n 2. \\<And>uv_ v va.\n       \\<lbrakk>has_default_policy (v # va) \\<Longrightarrow>\n                has_default_policy\n                 (filter (\\<lambda>r. simple_conn_matches (match_sel r) c)\n                   (v # va));\n        has_default_policy (uv_ # v # va)\\<rbrakk>\n       \\<Longrightarrow> has_default_policy\n                          (filter\n                            (\\<lambda>r.\n                                simple_conn_matches (match_sel r) c)\n                            (uv_ # v # va))", "apply(simp add: simple_conn_matches_simple_match_any; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uv_ v va.\n       \\<lbrakk>has_default_policy (v # va) \\<Longrightarrow>\n                has_default_policy\n                 (filter (\\<lambda>r. simple_conn_matches (match_sel r) c)\n                   (v # va));\n        has_default_policy (uv_ # v # va)\\<rbrakk>\n       \\<Longrightarrow> has_default_policy\n                          (filter\n                            (\\<lambda>r.\n                                simple_conn_matches (match_sel r) c)\n                            (uv_ # v # va))", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uv_ v va.\n       \\<lbrakk>has_default_policy\n                 (if simple_conn_matches (match_sel v) c\n                  then v #\n                       filter\n                        (\\<lambda>r. simple_conn_matches (match_sel r) c) va\n                  else filter\n                        (\\<lambda>r. simple_conn_matches (match_sel r) c)\n                        va);\n        has_default_policy (v # va)\\<rbrakk>\n       \\<Longrightarrow> (simple_conn_matches (match_sel v)\n                           c \\<longrightarrow>\n                          simple_conn_matches (match_sel uv_)\n                           c \\<longrightarrow>\n                          has_default_policy\n                           (v #\n                            filter\n                             (\\<lambda>r.\n                                 simple_conn_matches (match_sel r) c)\n                             va)) \\<and>\n                         (\\<not> simple_conn_matches (match_sel v)\n                                  c \\<longrightarrow>\n                          simple_conn_matches (match_sel uv_)\n                           c \\<longrightarrow>\n                          has_default_policy\n                           (uv_ #\n                            filter\n                             (\\<lambda>r.\n                                 simple_conn_matches (match_sel r) c)\n                             va))", "apply(intro conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>uv_ v va.\n       \\<lbrakk>has_default_policy\n                 (if simple_conn_matches (match_sel v) c\n                  then v #\n                       filter\n                        (\\<lambda>r. simple_conn_matches (match_sel r) c) va\n                  else filter\n                        (\\<lambda>r. simple_conn_matches (match_sel r) c)\n                        va);\n        has_default_policy (v # va)\\<rbrakk>\n       \\<Longrightarrow> simple_conn_matches (match_sel v)\n                          c \\<longrightarrow>\n                         simple_conn_matches (match_sel uv_)\n                          c \\<longrightarrow>\n                         has_default_policy\n                          (v #\n                           filter\n                            (\\<lambda>r.\n                                simple_conn_matches (match_sel r) c)\n                            va)\n 2. \\<And>uv_ v va.\n       \\<lbrakk>has_default_policy\n                 (if simple_conn_matches (match_sel v) c\n                  then v #\n                       filter\n                        (\\<lambda>r. simple_conn_matches (match_sel r) c) va\n                  else filter\n                        (\\<lambda>r. simple_conn_matches (match_sel r) c)\n                        va);\n        has_default_policy (v # va)\\<rbrakk>\n       \\<Longrightarrow> \\<not> simple_conn_matches (match_sel v)\n                                 c \\<longrightarrow>\n                         simple_conn_matches (match_sel uv_)\n                          c \\<longrightarrow>\n                         has_default_policy\n                          (uv_ #\n                           filter\n                            (\\<lambda>r.\n                                simple_conn_matches (match_sel r) c)\n                            va)", "apply(simp split: if_split_asm; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>uv_ v va.\n       \\<lbrakk>has_default_policy\n                 (if simple_conn_matches (match_sel v) c\n                  then v #\n                       filter\n                        (\\<lambda>r. simple_conn_matches (match_sel r) c) va\n                  else filter\n                        (\\<lambda>r. simple_conn_matches (match_sel r) c)\n                        va);\n        has_default_policy (v # va)\\<rbrakk>\n       \\<Longrightarrow> \\<not> simple_conn_matches (match_sel v)\n                                 c \\<longrightarrow>\n                         simple_conn_matches (match_sel uv_)\n                          c \\<longrightarrow>\n                         has_default_policy\n                          (uv_ #\n                           filter\n                            (\\<lambda>r.\n                                simple_conn_matches (match_sel r) c)\n                            va)", "apply(simp add: has_default_policy_fst split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma filter_conn_fw_lem: \n    \"runFw s d c (filter (\\<lambda>r. simple_conn_matches (match_sel r) c) rs) = runFw s d c rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runFw s d c\n     (filter (\\<lambda>r. simple_conn_matches (match_sel r) c) rs) =\n    runFw s d c rs", "apply(simp add: runFw_def simple_conn_matches_def match_sel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_fw\n     (filter\n       (\\<lambda>r.\n           match_iface\n            (iiface (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n            (pc_iiface c) \\<and>\n           match_iface\n            (oiface (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n            (pc_oiface c) \\<and>\n           match_proto (proto (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n            (pc_proto c) \\<and>\n           simple_match_port\n            (sports (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n            (pc_sport c) \\<and>\n           simple_match_port\n            (dports (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n            (pc_dport c))\n       rs)\n     \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n        p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n        p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n        p_payload = []\\<rparr> =\n    simple_fw rs\n     \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n        p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n        p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n        p_payload = []\\<rparr>", "apply(induction rs \"\\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n                         p_src = s, p_dst = d, p_proto = pc_proto c, \n                         p_sport = pc_sport c, p_dport = pc_dport c,\n                         p_tcp_flags = {TCP_SYN},p_payload=''''\\<rparr>\"\n          rule: simple_fw.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. simple_fw\n     (filter\n       (\\<lambda>r.\n           match_iface\n            (iiface (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n            (pc_iiface c) \\<and>\n           match_iface\n            (oiface (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n            (pc_oiface c) \\<and>\n           match_proto (proto (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n            (pc_proto c) \\<and>\n           simple_match_port\n            (sports (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n            (pc_sport c) \\<and>\n           simple_match_port\n            (dports (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n            (pc_dport c))\n       [])\n     \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n        p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n        p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n        p_payload = []\\<rparr> =\n    simple_fw []\n     \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n        p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n        p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n        p_payload = []\\<rparr>\n 2. \\<And>m rs.\n       (\\<not> simple_matches m\n                \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n                   p_src = s, p_dst = d, p_proto = pc_proto c,\n                   p_sport = pc_sport c, p_dport = pc_dport c,\n                   p_tcp_flags = {TCP_SYN},\n                   p_payload = []\\<rparr> \\<Longrightarrow>\n        simple_fw\n         (filter\n           (\\<lambda>r.\n               match_iface\n                (iiface (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n                (pc_iiface c) \\<and>\n               match_iface\n                (oiface (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n                (pc_oiface c) \\<and>\n               match_proto\n                (proto (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n                (pc_proto c) \\<and>\n               simple_match_port\n                (sports (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n                (pc_sport c) \\<and>\n               simple_match_port\n                (dports (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n                (pc_dport c))\n           rs)\n         \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n            p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n            p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n            p_payload = []\\<rparr> =\n        simple_fw rs\n         \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n            p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n            p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n            p_payload = []\\<rparr>) \\<Longrightarrow>\n       simple_fw\n        (filter\n          (\\<lambda>r.\n              match_iface\n               (iiface (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n               (pc_iiface c) \\<and>\n              match_iface\n               (oiface (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n               (pc_oiface c) \\<and>\n              match_proto\n               (proto (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n               (pc_proto c) \\<and>\n              simple_match_port\n               (sports (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n               (pc_sport c) \\<and>\n              simple_match_port\n               (dports (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n               (pc_dport c))\n          (SimpleRule m Accept # rs))\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr> =\n       simple_fw (SimpleRule m Accept # rs)\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr>\n 3. \\<And>m rs.\n       (\\<not> simple_matches m\n                \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c,\n                   p_src = s, p_dst = d, p_proto = pc_proto c,\n                   p_sport = pc_sport c, p_dport = pc_dport c,\n                   p_tcp_flags = {TCP_SYN},\n                   p_payload = []\\<rparr> \\<Longrightarrow>\n        simple_fw\n         (filter\n           (\\<lambda>r.\n               match_iface\n                (iiface (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n                (pc_iiface c) \\<and>\n               match_iface\n                (oiface (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n                (pc_oiface c) \\<and>\n               match_proto\n                (proto (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n                (pc_proto c) \\<and>\n               simple_match_port\n                (sports (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n                (pc_sport c) \\<and>\n               simple_match_port\n                (dports (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n                (pc_dport c))\n           rs)\n         \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n            p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n            p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n            p_payload = []\\<rparr> =\n        simple_fw rs\n         \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n            p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n            p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n            p_payload = []\\<rparr>) \\<Longrightarrow>\n       simple_fw\n        (filter\n          (\\<lambda>r.\n              match_iface\n               (iiface (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n               (pc_iiface c) \\<and>\n              match_iface\n               (oiface (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n               (pc_oiface c) \\<and>\n              match_proto\n               (proto (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n               (pc_proto c) \\<and>\n              simple_match_port\n               (sports (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n               (pc_sport c) \\<and>\n              simple_match_port\n               (dports (case r of SimpleRule x1 x2 \\<Rightarrow> x1))\n               (pc_dport c))\n          (SimpleRule m Drop # rs))\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr> =\n       simple_fw (SimpleRule m Drop # rs)\n        \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n           p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n           p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n           p_payload = []\\<rparr>", "apply(simp add: simple_matches.simps)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(*performance: despite optimization, this function takes quite long and can be optimized*)"], ["", "definition groupWIs2 :: \"parts_connection \\<Rightarrow> 'i::len simple_rule list \\<Rightarrow> 'i wordinterval list list\" where\n    \"groupWIs2 c rs =  (let P = getParts rs in\n                         (let W = map getOneIp P in \n                         (let filterW = (filter (\\<lambda>r. simple_conn_matches (match_sel r) c) rs) in\n                           (let f = (\\<lambda>wi. (map (\\<lambda>d. runFw (getOneIp wi) d c filterW) W,\n                                           map (\\<lambda>s. runFw s (getOneIp wi) c filterW) W)) in\n                        map (map fst) (groupF snd (map (\\<lambda>x. (x, f x)) P))))))\""], ["", "lemma groupWIs1_groupWIs2_equi: \"groupWIs2 c rs = groupWIs1 c rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. groupWIs2 c rs = groupWIs1 c rs", "by(simp add: groupWIs2_def groupWIs1_def filter_conn_fw_lem)"], ["", "lemma groupWIs_code[code]: \"groupWIs c rs = groupWIs2 c rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. groupWIs c rs = groupWIs2 c rs", "using groupWIs1_groupWIs2_equi groupWIs_groupWIs1_equi"], ["proof (prove)\nusing this:\n  groupWIs2 ?c ?rs = groupWIs1 ?c ?rs\n  groupWIs1 ?c ?rs = groupWIs ?c ?rs\n\ngoal (1 subgoal):\n 1. groupWIs c rs = groupWIs2 c rs", "by metis"], ["", "(*end groupWIs1 and groupWIs2 optimization*)\n\n\n(*begin groupWIs3 optimization*)"], ["", "fun matching_dsts :: \"'i::len word \\<Rightarrow> 'i simple_rule list \\<Rightarrow> 'i wordinterval \\<Rightarrow> 'i wordinterval\" where\n    \"matching_dsts _ [] _ = Empty_WordInterval\" |\n    \"matching_dsts s ((SimpleRule m Accept)#rs) acc_dropped =\n        (if simple_match_ip (src m) s then\n           wordinterval_union (wordinterval_setminus (ipcidr_tuple_to_wordinterval (dst m)) acc_dropped) (matching_dsts s rs acc_dropped)\n         else\n           matching_dsts s rs acc_dropped)\" |\n    \"matching_dsts s ((SimpleRule m Drop)#rs) acc_dropped =\n        (if simple_match_ip (src m) s then\n           matching_dsts s rs (wordinterval_union (ipcidr_tuple_to_wordinterval (dst m)) acc_dropped)\n         else\n           matching_dsts s rs acc_dropped)\""], ["", "lemma matching_dsts_pull_out_accu:\n    \"wordinterval_to_set (matching_dsts s rs (wordinterval_union a1 a2)) = wordinterval_to_set (matching_dsts s rs a2) - wordinterval_to_set a1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (matching_dsts s rs (wordinterval_union a1 a2)) =\n    wordinterval_to_set (matching_dsts s rs a2) - wordinterval_to_set a1", "apply(induction s rs a2 arbitrary: a1 a2 rule: matching_dsts.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_ _ a1 a2.\n       wordinterval_to_set\n        (matching_dsts uu_ [] (wordinterval_union a1 a2)) =\n       wordinterval_to_set (matching_dsts uu_ [] a2) -\n       wordinterval_to_set a1\n 2. \\<And>s m rs acc_dropped a1 a2.\n       \\<lbrakk>\\<And>a1 a2.\n                   simple_match_ip (src m) s \\<Longrightarrow>\n                   wordinterval_to_set\n                    (matching_dsts s rs (wordinterval_union a1 a2)) =\n                   wordinterval_to_set (matching_dsts s rs a2) -\n                   wordinterval_to_set a1;\n        \\<And>a1 a2.\n           \\<not> simple_match_ip (src m) s \\<Longrightarrow>\n           wordinterval_to_set\n            (matching_dsts s rs (wordinterval_union a1 a2)) =\n           wordinterval_to_set (matching_dsts s rs a2) -\n           wordinterval_to_set a1\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_dsts s (SimpleRule m Accept # rs)\n                            (wordinterval_union a1 a2)) =\n                         wordinterval_to_set\n                          (matching_dsts s (SimpleRule m Accept # rs) a2) -\n                         wordinterval_to_set a1\n 3. \\<And>s m rs acc_dropped a1 a2.\n       \\<lbrakk>\\<And>a1 a2.\n                   simple_match_ip (src m) s \\<Longrightarrow>\n                   wordinterval_to_set\n                    (matching_dsts s rs (wordinterval_union a1 a2)) =\n                   wordinterval_to_set (matching_dsts s rs a2) -\n                   wordinterval_to_set a1;\n        \\<And>a1 a2.\n           \\<not> simple_match_ip (src m) s \\<Longrightarrow>\n           wordinterval_to_set\n            (matching_dsts s rs (wordinterval_union a1 a2)) =\n           wordinterval_to_set (matching_dsts s rs a2) -\n           wordinterval_to_set a1\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_dsts s (SimpleRule m Drop # rs)\n                            (wordinterval_union a1 a2)) =\n                         wordinterval_to_set\n                          (matching_dsts s (SimpleRule m Drop # rs) a2) -\n                         wordinterval_to_set a1", "apply(simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s m rs a1 a2.\n       \\<lbrakk>\\<And>a1 a2.\n                   simple_match_ip (src m) s \\<Longrightarrow>\n                   wordinterval_to_set\n                    (matching_dsts s rs (wordinterval_union a1 a2)) =\n                   wordinterval_to_set (matching_dsts s rs a2) -\n                   wordinterval_to_set a1;\n        \\<And>a1 a2.\n           \\<not> simple_match_ip (src m) s \\<Longrightarrow>\n           wordinterval_to_set\n            (matching_dsts s rs (wordinterval_union a1 a2)) =\n           wordinterval_to_set (matching_dsts s rs a2) -\n           wordinterval_to_set a1\\<rbrakk>\n       \\<Longrightarrow> simple_match_ip (src m) s \\<longrightarrow>\n                         wordinterval_to_set\n                          (ipcidr_tuple_to_wordinterval (dst m)) -\n                         (wordinterval_to_set a1 \\<union>\n                          wordinterval_to_set a2) \\<union>\n                         (wordinterval_to_set (matching_dsts s rs a2) -\n                          wordinterval_to_set a1) =\n                         wordinterval_to_set\n                          (ipcidr_tuple_to_wordinterval (dst m)) -\n                         wordinterval_to_set a2 \\<union>\n                         wordinterval_to_set (matching_dsts s rs a2) -\n                         wordinterval_to_set a1\n 2. \\<And>s m rs a1 a2.\n       \\<lbrakk>\\<And>a1 a2.\n                   simple_match_ip (src m) s \\<Longrightarrow>\n                   wordinterval_to_set\n                    (matching_dsts s rs (wordinterval_union a1 a2)) =\n                   wordinterval_to_set (matching_dsts s rs a2) -\n                   wordinterval_to_set a1;\n        \\<And>a1 a2.\n           \\<not> simple_match_ip (src m) s \\<Longrightarrow>\n           wordinterval_to_set\n            (matching_dsts s rs (wordinterval_union a1 a2)) =\n           wordinterval_to_set (matching_dsts s rs a2) -\n           wordinterval_to_set a1\\<rbrakk>\n       \\<Longrightarrow> simple_match_ip (src m) s \\<longrightarrow>\n                         wordinterval_to_set (matching_dsts s rs a2) -\n                         wordinterval_to_set a1 -\n                         wordinterval_to_set\n                          (ipcidr_tuple_to_wordinterval (dst m)) =\n                         wordinterval_to_set (matching_dsts s rs a2) -\n                         wordinterval_to_set\n                          (ipcidr_tuple_to_wordinterval (dst m)) -\n                         wordinterval_to_set a1", "by blast+"], ["", "(*a copy of matching_dsts*)"], ["", "fun matching_srcs :: \"'i::len word \\<Rightarrow> 'i simple_rule list \\<Rightarrow> 'i wordinterval \\<Rightarrow> 'i wordinterval\" where\n    \"matching_srcs _ [] _ = Empty_WordInterval\" |\n    \"matching_srcs d ((SimpleRule m Accept)#rs) acc_dropped =\n        (if simple_match_ip (dst m) d then\n           wordinterval_union (wordinterval_setminus (ipcidr_tuple_to_wordinterval (src m)) acc_dropped) (matching_srcs d rs acc_dropped)\n         else\n           matching_srcs d rs acc_dropped)\" |\n    \"matching_srcs d ((SimpleRule m Drop)#rs) acc_dropped =\n        (if simple_match_ip (dst m) d then\n           matching_srcs d rs (wordinterval_union (ipcidr_tuple_to_wordinterval (src m)) acc_dropped)\n         else\n           matching_srcs d rs acc_dropped)\""], ["", "lemma matching_srcs_pull_out_accu:\n    \"wordinterval_to_set (matching_srcs d rs (wordinterval_union a1 a2)) = wordinterval_to_set (matching_srcs d rs a2) - wordinterval_to_set a1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (matching_srcs d rs (wordinterval_union a1 a2)) =\n    wordinterval_to_set (matching_srcs d rs a2) - wordinterval_to_set a1", "apply(induction d rs a2 arbitrary: a1 a2 rule: matching_srcs.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_ _ a1 a2.\n       wordinterval_to_set\n        (matching_srcs uu_ [] (wordinterval_union a1 a2)) =\n       wordinterval_to_set (matching_srcs uu_ [] a2) -\n       wordinterval_to_set a1\n 2. \\<And>d m rs acc_dropped a1 a2.\n       \\<lbrakk>\\<And>a1 a2.\n                   simple_match_ip (dst m) d \\<Longrightarrow>\n                   wordinterval_to_set\n                    (matching_srcs d rs (wordinterval_union a1 a2)) =\n                   wordinterval_to_set (matching_srcs d rs a2) -\n                   wordinterval_to_set a1;\n        \\<And>a1 a2.\n           \\<not> simple_match_ip (dst m) d \\<Longrightarrow>\n           wordinterval_to_set\n            (matching_srcs d rs (wordinterval_union a1 a2)) =\n           wordinterval_to_set (matching_srcs d rs a2) -\n           wordinterval_to_set a1\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_srcs d (SimpleRule m Accept # rs)\n                            (wordinterval_union a1 a2)) =\n                         wordinterval_to_set\n                          (matching_srcs d (SimpleRule m Accept # rs) a2) -\n                         wordinterval_to_set a1\n 3. \\<And>d m rs acc_dropped a1 a2.\n       \\<lbrakk>\\<And>a1 a2.\n                   simple_match_ip (dst m) d \\<Longrightarrow>\n                   wordinterval_to_set\n                    (matching_srcs d rs (wordinterval_union a1 a2)) =\n                   wordinterval_to_set (matching_srcs d rs a2) -\n                   wordinterval_to_set a1;\n        \\<And>a1 a2.\n           \\<not> simple_match_ip (dst m) d \\<Longrightarrow>\n           wordinterval_to_set\n            (matching_srcs d rs (wordinterval_union a1 a2)) =\n           wordinterval_to_set (matching_srcs d rs a2) -\n           wordinterval_to_set a1\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_srcs d (SimpleRule m Drop # rs)\n                            (wordinterval_union a1 a2)) =\n                         wordinterval_to_set\n                          (matching_srcs d (SimpleRule m Drop # rs) a2) -\n                         wordinterval_to_set a1", "apply(simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>d m rs a1 a2.\n       \\<lbrakk>\\<And>a1 a2.\n                   simple_match_ip (dst m) d \\<Longrightarrow>\n                   wordinterval_to_set\n                    (matching_srcs d rs (wordinterval_union a1 a2)) =\n                   wordinterval_to_set (matching_srcs d rs a2) -\n                   wordinterval_to_set a1;\n        \\<And>a1 a2.\n           \\<not> simple_match_ip (dst m) d \\<Longrightarrow>\n           wordinterval_to_set\n            (matching_srcs d rs (wordinterval_union a1 a2)) =\n           wordinterval_to_set (matching_srcs d rs a2) -\n           wordinterval_to_set a1\\<rbrakk>\n       \\<Longrightarrow> simple_match_ip (dst m) d \\<longrightarrow>\n                         wordinterval_to_set\n                          (ipcidr_tuple_to_wordinterval (src m)) -\n                         (wordinterval_to_set a1 \\<union>\n                          wordinterval_to_set a2) \\<union>\n                         (wordinterval_to_set (matching_srcs d rs a2) -\n                          wordinterval_to_set a1) =\n                         wordinterval_to_set\n                          (ipcidr_tuple_to_wordinterval (src m)) -\n                         wordinterval_to_set a2 \\<union>\n                         wordinterval_to_set (matching_srcs d rs a2) -\n                         wordinterval_to_set a1\n 2. \\<And>d m rs a1 a2.\n       \\<lbrakk>\\<And>a1 a2.\n                   simple_match_ip (dst m) d \\<Longrightarrow>\n                   wordinterval_to_set\n                    (matching_srcs d rs (wordinterval_union a1 a2)) =\n                   wordinterval_to_set (matching_srcs d rs a2) -\n                   wordinterval_to_set a1;\n        \\<And>a1 a2.\n           \\<not> simple_match_ip (dst m) d \\<Longrightarrow>\n           wordinterval_to_set\n            (matching_srcs d rs (wordinterval_union a1 a2)) =\n           wordinterval_to_set (matching_srcs d rs a2) -\n           wordinterval_to_set a1\\<rbrakk>\n       \\<Longrightarrow> simple_match_ip (dst m) d \\<longrightarrow>\n                         wordinterval_to_set (matching_srcs d rs a2) -\n                         wordinterval_to_set a1 -\n                         wordinterval_to_set\n                          (ipcidr_tuple_to_wordinterval (src m)) =\n                         wordinterval_to_set (matching_srcs d rs a2) -\n                         wordinterval_to_set\n                          (ipcidr_tuple_to_wordinterval (src m)) -\n                         wordinterval_to_set a1", "by blast+"], ["", "lemma matching_dsts: \"\\<forall>r \\<in> set rs. simple_conn_matches (match_sel r) c \\<Longrightarrow>\n          wordinterval_to_set (matching_dsts s rs Empty_WordInterval) = {d. runFw s d c rs = Decision FinalAllow}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>set rs.\n       simple_conn_matches (match_sel r) c \\<Longrightarrow>\n    wordinterval_to_set (matching_dsts s rs Empty_WordInterval) =\n    {d. runFw s d c rs = Decision FinalAllow}", "proof(induction rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>r\\<in>set [].\n       simple_conn_matches (match_sel r) c \\<Longrightarrow>\n    wordinterval_to_set (matching_dsts s [] Empty_WordInterval) =\n    {d. runFw s d c [] = Decision FinalAllow}\n 2. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_dsts s rs Empty_WordInterval) =\n                {d. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_dsts s (a # rs) Empty_WordInterval) =\n                         {d. runFw s d c (a # rs) = Decision FinalAllow}", "case Nil"], ["proof (state)\nthis:\n  \\<forall>r\\<in>set []. simple_conn_matches (match_sel r) c\n\ngoal (2 subgoals):\n 1. \\<forall>r\\<in>set [].\n       simple_conn_matches (match_sel r) c \\<Longrightarrow>\n    wordinterval_to_set (matching_dsts s [] Empty_WordInterval) =\n    {d. runFw s d c [] = Decision FinalAllow}\n 2. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_dsts s rs Empty_WordInterval) =\n                {d. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_dsts s (a # rs) Empty_WordInterval) =\n                         {d. runFw s d c (a # rs) = Decision FinalAllow}", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>set []. simple_conn_matches (match_sel r) c\n\ngoal (1 subgoal):\n 1. wordinterval_to_set (matching_dsts s [] Empty_WordInterval) =\n    {d. runFw s d c [] = Decision FinalAllow}", "by (simp add: runFw_def)"], ["proof (state)\nthis:\n  wordinterval_to_set (matching_dsts s [] Empty_WordInterval) =\n  {d. runFw s d c [] = Decision FinalAllow}\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_dsts s rs Empty_WordInterval) =\n                {d. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_dsts s (a # rs) Empty_WordInterval) =\n                         {d. runFw s d c (a # rs) = Decision FinalAllow}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_dsts s rs Empty_WordInterval) =\n                {d. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_dsts s (a # rs) Empty_WordInterval) =\n                         {d. runFw s d c (a # rs) = Decision FinalAllow}", "case (Cons r rs)"], ["proof (state)\nthis:\n  \\<forall>r\\<in>set rs.\n     simple_conn_matches (match_sel r) c \\<Longrightarrow>\n  wordinterval_to_set (matching_dsts s rs Empty_WordInterval) =\n  {d. runFw s d c rs = Decision FinalAllow}\n  \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_dsts s rs Empty_WordInterval) =\n                {d. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_dsts s (a # rs) Empty_WordInterval) =\n                         {d. runFw s d c (a # rs) = Decision FinalAllow}", "obtain m a where r: \"r = SimpleRule m a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m a.\n        r = SimpleRule m a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases r, blast)"], ["proof (state)\nthis:\n  r = SimpleRule m a\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_dsts s rs Empty_WordInterval) =\n                {d. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_dsts s (a # rs) Empty_WordInterval) =\n                         {d. runFw s d c (a # rs) = Decision FinalAllow}", "from Cons.prems r"], ["proof (chain)\npicking this:\n  \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c\n  r = SimpleRule m a", "have simple_match_ip_Accept: \"\\<And>d. simple_match_ip (src m) s \\<Longrightarrow>\n        runFw s d c (SimpleRule m Accept # rs) = Decision FinalAllow \\<longleftrightarrow> simple_match_ip (dst m) d \\<or> runFw s d c rs = Decision FinalAllow\""], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c\n  r = SimpleRule m a\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       simple_match_ip (src m) s \\<Longrightarrow>\n       (runFw s d c (SimpleRule m Accept # rs) = Decision FinalAllow) =\n       (simple_match_ip (dst m) d \\<or>\n        runFw s d c rs = Decision FinalAllow)", "by(simp add: simple_conn_matches_def runFw_def simple_matches.simps)"], ["proof (state)\nthis:\n  simple_match_ip (src m) s \\<Longrightarrow>\n  (runFw s ?d c (SimpleRule m Accept # rs) = Decision FinalAllow) =\n  (simple_match_ip (dst m) ?d \\<or> runFw s ?d c rs = Decision FinalAllow)\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_dsts s rs Empty_WordInterval) =\n                {d. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_dsts s (a # rs) Empty_WordInterval) =\n                         {d. runFw s d c (a # rs) = Decision FinalAllow}", "{"], ["proof (state)\nthis:\n  simple_match_ip (src m) s \\<Longrightarrow>\n  (runFw s ?d c (SimpleRule m Accept # rs) = Decision FinalAllow) =\n  (simple_match_ip (dst m) ?d \\<or> runFw s ?d c rs = Decision FinalAllow)\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_dsts s rs Empty_WordInterval) =\n                {d. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_dsts s (a # rs) Empty_WordInterval) =\n                         {d. runFw s d c (a # rs) = Decision FinalAllow}", "fix d a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_dsts s rs Empty_WordInterval) =\n                {d. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_dsts s (a # rs) Empty_WordInterval) =\n                         {d. runFw s d c (a # rs) = Decision FinalAllow}", "have \"\\<not> simple_match_ip (src m) s \\<Longrightarrow>\n         runFw s d c (SimpleRule m a # rs) = Decision FinalAllow \\<longleftrightarrow> runFw s d c rs = Decision FinalAllow\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> simple_match_ip (src m) s \\<Longrightarrow>\n    (runFw s d c (SimpleRule m a # rs) = Decision FinalAllow) =\n    (runFw s d c rs = Decision FinalAllow)", "apply(cases a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> simple_match_ip (src m) s; a = Accept\\<rbrakk>\n    \\<Longrightarrow> (runFw s d c (SimpleRule m a # rs) =\n                       Decision FinalAllow) =\n                      (runFw s d c rs = Decision FinalAllow)\n 2. \\<lbrakk>\\<not> simple_match_ip (src m) s; a = Drop\\<rbrakk>\n    \\<Longrightarrow> (runFw s d c (SimpleRule m a # rs) =\n                       Decision FinalAllow) =\n                      (runFw s d c rs = Decision FinalAllow)", "by(simp add: simple_conn_matches_def runFw_def simple_matches.simps)+"], ["proof (state)\nthis:\n  \\<not> simple_match_ip (src m) s \\<Longrightarrow>\n  (runFw s d c (SimpleRule m a # rs) = Decision FinalAllow) =\n  (runFw s d c rs = Decision FinalAllow)\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_dsts s rs Empty_WordInterval) =\n                {d. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_dsts s (a # rs) Empty_WordInterval) =\n                         {d. runFw s d c (a # rs) = Decision FinalAllow}", "}"], ["proof (state)\nthis:\n  \\<not> simple_match_ip (src m) s \\<Longrightarrow>\n  (runFw s ?d2 c (SimpleRule m ?aa2 # rs) = Decision FinalAllow) =\n  (runFw s ?d2 c rs = Decision FinalAllow)\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_dsts s rs Empty_WordInterval) =\n                {d. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_dsts s (a # rs) Empty_WordInterval) =\n                         {d. runFw s d c (a # rs) = Decision FinalAllow}", "note not_simple_match_ip=this"], ["proof (state)\nthis:\n  \\<not> simple_match_ip (src m) s \\<Longrightarrow>\n  (runFw s ?d2 c (SimpleRule m ?aa2 # rs) = Decision FinalAllow) =\n  (runFw s ?d2 c rs = Decision FinalAllow)\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_dsts s rs Empty_WordInterval) =\n                {d. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_dsts s (a # rs) Empty_WordInterval) =\n                         {d. runFw s d c (a # rs) = Decision FinalAllow}", "from Cons.prems r"], ["proof (chain)\npicking this:\n  \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c\n  r = SimpleRule m a", "have simple_match_ip_Drop: \"\\<And>d. simple_match_ip (src m) s \\<Longrightarrow>\n             runFw s d c (SimpleRule m Drop # rs) = Decision FinalAllow \\<longleftrightarrow> \\<not> simple_match_ip (dst m) d \\<and> runFw s d c rs = Decision FinalAllow\""], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c\n  r = SimpleRule m a\n\ngoal (1 subgoal):\n 1. \\<And>d.\n       simple_match_ip (src m) s \\<Longrightarrow>\n       (runFw s d c (SimpleRule m Drop # rs) = Decision FinalAllow) =\n       (\\<not> simple_match_ip (dst m) d \\<and>\n        runFw s d c rs = Decision FinalAllow)", "by(simp add: simple_conn_matches_def runFw_def simple_matches.simps)"], ["proof (state)\nthis:\n  simple_match_ip (src m) s \\<Longrightarrow>\n  (runFw s ?d c (SimpleRule m Drop # rs) = Decision FinalAllow) =\n  (\\<not> simple_match_ip (dst m) ?d \\<and>\n   runFw s ?d c rs = Decision FinalAllow)\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_dsts s rs Empty_WordInterval) =\n                {d. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_dsts s (a # rs) Empty_WordInterval) =\n                         {d. runFw s d c (a # rs) = Decision FinalAllow}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (matching_dsts s (r # rs) Empty_WordInterval) =\n    {d. runFw s d c (r # rs) = Decision FinalAllow}", "proof(cases a)"], ["proof (state)\ngoal (2 subgoals):\n 1. a = Accept \\<Longrightarrow>\n    wordinterval_to_set (matching_dsts s (r # rs) Empty_WordInterval) =\n    {d. runFw s d c (r # rs) = Decision FinalAllow}\n 2. a = Drop \\<Longrightarrow>\n    wordinterval_to_set (matching_dsts s (r # rs) Empty_WordInterval) =\n    {d. runFw s d c (r # rs) = Decision FinalAllow}", "case Accept"], ["proof (state)\nthis:\n  a = Accept\n\ngoal (2 subgoals):\n 1. a = Accept \\<Longrightarrow>\n    wordinterval_to_set (matching_dsts s (r # rs) Empty_WordInterval) =\n    {d. runFw s d c (r # rs) = Decision FinalAllow}\n 2. a = Drop \\<Longrightarrow>\n    wordinterval_to_set (matching_dsts s (r # rs) Empty_WordInterval) =\n    {d. runFw s d c (r # rs) = Decision FinalAllow}", "with r Cons"], ["proof (chain)\npicking this:\n  r = SimpleRule m a\n  \\<forall>r\\<in>set rs.\n     simple_conn_matches (match_sel r) c \\<Longrightarrow>\n  wordinterval_to_set (matching_dsts s rs Empty_WordInterval) =\n  {d. runFw s d c rs = Decision FinalAllow}\n  \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c\n  a = Accept", "show ?thesis"], ["proof (prove)\nusing this:\n  r = SimpleRule m a\n  \\<forall>r\\<in>set rs.\n     simple_conn_matches (match_sel r) c \\<Longrightarrow>\n  wordinterval_to_set (matching_dsts s rs Empty_WordInterval) =\n  {d. runFw s d c rs = Decision FinalAllow}\n  \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c\n  a = Accept\n\ngoal (1 subgoal):\n 1. wordinterval_to_set (matching_dsts s (r # rs) Empty_WordInterval) =\n    {d. runFw s d c (r # rs) = Decision FinalAllow}", "apply(simp, intro conjI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r = SimpleRule m Accept;\n     wordinterval_to_set (matching_dsts s rs Empty_WordInterval) =\n     {d. runFw s d c rs = Decision FinalAllow};\n     simple_conn_matches m c \\<and>\n     (\\<forall>r\\<in>set rs. simple_conn_matches (match_sel r) c);\n     a = Accept; r = SimpleRule m a;\n     \\<forall>r\\<in>set rs.\n        simple_conn_matches (match_sel r) c \\<Longrightarrow>\n     wordinterval_to_set (matching_dsts s rs Empty_WordInterval) =\n     {d. runFw s d c rs = Decision FinalAllow};\n     \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c;\n     a = Accept; simple_match_ip (src m) s\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (ipcidr_tuple_to_wordinterval (dst m)) \\<union>\n                      {d. runFw s d c rs = Decision FinalAllow} =\n                      {d. runFw s d c (SimpleRule m Accept # rs) =\n                          Decision FinalAllow}\n 2. \\<lbrakk>r = SimpleRule m Accept;\n     wordinterval_to_set (matching_dsts s rs Empty_WordInterval) =\n     {d. runFw s d c rs = Decision FinalAllow};\n     simple_conn_matches m c \\<and>\n     (\\<forall>r\\<in>set rs. simple_conn_matches (match_sel r) c);\n     a = Accept; r = SimpleRule m a;\n     \\<forall>r\\<in>set rs.\n        simple_conn_matches (match_sel r) c \\<Longrightarrow>\n     wordinterval_to_set (matching_dsts s rs Empty_WordInterval) =\n     {d. runFw s d c rs = Decision FinalAllow};\n     \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c;\n     a = Accept; \\<not> simple_match_ip (src m) s\\<rbrakk>\n    \\<Longrightarrow> {d. runFw s d c rs = Decision FinalAllow} =\n                      {d. runFw s d c (SimpleRule m Accept # rs) =\n                          Decision FinalAllow}", "apply(simp add: simple_match_ip_Accept wordinterval_to_set_ipcidr_tuple_to_wordinterval_simple_match_ip_set)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>simple_conn_matches m c; r = SimpleRule m Accept;\n     wordinterval_to_set (matching_dsts s rs Empty_WordInterval) =\n     {d. runFw s d c rs = Decision FinalAllow};\n     \\<forall>r\\<in>set rs. simple_conn_matches (match_sel r) c; a = Accept;\n     simple_match_ip (src m) s\\<rbrakk>\n    \\<Longrightarrow> Collect (simple_match_ip (dst m)) \\<union>\n                      {d. runFw s d c rs = Decision FinalAllow} =\n                      {d. simple_match_ip (dst m) d \\<or>\n                          runFw s d c rs = Decision FinalAllow}\n 2. \\<lbrakk>r = SimpleRule m Accept;\n     wordinterval_to_set (matching_dsts s rs Empty_WordInterval) =\n     {d. runFw s d c rs = Decision FinalAllow};\n     simple_conn_matches m c \\<and>\n     (\\<forall>r\\<in>set rs. simple_conn_matches (match_sel r) c);\n     a = Accept; r = SimpleRule m a;\n     \\<forall>r\\<in>set rs.\n        simple_conn_matches (match_sel r) c \\<Longrightarrow>\n     wordinterval_to_set (matching_dsts s rs Empty_WordInterval) =\n     {d. runFw s d c rs = Decision FinalAllow};\n     \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c;\n     a = Accept; \\<not> simple_match_ip (src m) s\\<rbrakk>\n    \\<Longrightarrow> {d. runFw s d c rs = Decision FinalAllow} =\n                      {d. runFw s d c (SimpleRule m Accept # rs) =\n                          Decision FinalAllow}", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = SimpleRule m Accept;\n     wordinterval_to_set (matching_dsts s rs Empty_WordInterval) =\n     {d. runFw s d c rs = Decision FinalAllow};\n     simple_conn_matches m c \\<and>\n     (\\<forall>r\\<in>set rs. simple_conn_matches (match_sel r) c);\n     a = Accept; r = SimpleRule m a;\n     \\<forall>r\\<in>set rs.\n        simple_conn_matches (match_sel r) c \\<Longrightarrow>\n     wordinterval_to_set (matching_dsts s rs Empty_WordInterval) =\n     {d. runFw s d c rs = Decision FinalAllow};\n     \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c;\n     a = Accept; \\<not> simple_match_ip (src m) s\\<rbrakk>\n    \\<Longrightarrow> {d. runFw s d c rs = Decision FinalAllow} =\n                      {d. runFw s d c (SimpleRule m Accept # rs) =\n                          Decision FinalAllow}", "apply(simp add: not_simple_match_ip; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wordinterval_to_set (matching_dsts s (r # rs) Empty_WordInterval) =\n  {d. runFw s d c (r # rs) = Decision FinalAllow}\n\ngoal (1 subgoal):\n 1. a = Drop \\<Longrightarrow>\n    wordinterval_to_set (matching_dsts s (r # rs) Empty_WordInterval) =\n    {d. runFw s d c (r # rs) = Decision FinalAllow}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a = Drop \\<Longrightarrow>\n    wordinterval_to_set (matching_dsts s (r # rs) Empty_WordInterval) =\n    {d. runFw s d c (r # rs) = Decision FinalAllow}", "case Drop"], ["proof (state)\nthis:\n  a = Drop\n\ngoal (1 subgoal):\n 1. a = Drop \\<Longrightarrow>\n    wordinterval_to_set (matching_dsts s (r # rs) Empty_WordInterval) =\n    {d. runFw s d c (r # rs) = Decision FinalAllow}", "with r Cons"], ["proof (chain)\npicking this:\n  r = SimpleRule m a\n  \\<forall>r\\<in>set rs.\n     simple_conn_matches (match_sel r) c \\<Longrightarrow>\n  wordinterval_to_set (matching_dsts s rs Empty_WordInterval) =\n  {d. runFw s d c rs = Decision FinalAllow}\n  \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c\n  a = Drop", "show ?thesis"], ["proof (prove)\nusing this:\n  r = SimpleRule m a\n  \\<forall>r\\<in>set rs.\n     simple_conn_matches (match_sel r) c \\<Longrightarrow>\n  wordinterval_to_set (matching_dsts s rs Empty_WordInterval) =\n  {d. runFw s d c rs = Decision FinalAllow}\n  \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c\n  a = Drop\n\ngoal (1 subgoal):\n 1. wordinterval_to_set (matching_dsts s (r # rs) Empty_WordInterval) =\n    {d. runFw s d c (r # rs) = Decision FinalAllow}", "apply(simp,intro conjI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r = SimpleRule m Drop;\n     wordinterval_to_set (matching_dsts s rs Empty_WordInterval) =\n     {d. runFw s d c rs = Decision FinalAllow};\n     simple_conn_matches m c \\<and>\n     (\\<forall>r\\<in>set rs. simple_conn_matches (match_sel r) c);\n     a = Drop; r = SimpleRule m a;\n     \\<forall>r\\<in>set rs.\n        simple_conn_matches (match_sel r) c \\<Longrightarrow>\n     wordinterval_to_set (matching_dsts s rs Empty_WordInterval) =\n     {d. runFw s d c rs = Decision FinalAllow};\n     \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c;\n     a = Drop; simple_match_ip (src m) s\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (matching_dsts s rs\n                         (wordinterval_union\n                           (ipcidr_tuple_to_wordinterval (dst m))\n                           Empty_WordInterval)) =\n                      {d. runFw s d c (SimpleRule m Drop # rs) =\n                          Decision FinalAllow}\n 2. \\<lbrakk>r = SimpleRule m Drop;\n     wordinterval_to_set (matching_dsts s rs Empty_WordInterval) =\n     {d. runFw s d c rs = Decision FinalAllow};\n     simple_conn_matches m c \\<and>\n     (\\<forall>r\\<in>set rs. simple_conn_matches (match_sel r) c);\n     a = Drop; r = SimpleRule m a;\n     \\<forall>r\\<in>set rs.\n        simple_conn_matches (match_sel r) c \\<Longrightarrow>\n     wordinterval_to_set (matching_dsts s rs Empty_WordInterval) =\n     {d. runFw s d c rs = Decision FinalAllow};\n     \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c;\n     a = Drop; \\<not> simple_match_ip (src m) s\\<rbrakk>\n    \\<Longrightarrow> {d. runFw s d c rs = Decision FinalAllow} =\n                      {d. runFw s d c (SimpleRule m Drop # rs) =\n                          Decision FinalAllow}", "apply(simp add: simple_match_ip_Drop matching_dsts_pull_out_accu wordinterval_to_set_ipcidr_tuple_to_wordinterval_simple_match_ip_set)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>simple_conn_matches m c; r = SimpleRule m Drop;\n     wordinterval_to_set (matching_dsts s rs Empty_WordInterval) =\n     {d. runFw s d c rs = Decision FinalAllow};\n     \\<forall>r\\<in>set rs. simple_conn_matches (match_sel r) c; a = Drop;\n     simple_match_ip (src m) s\\<rbrakk>\n    \\<Longrightarrow> {d. runFw s d c rs = Decision FinalAllow} -\n                      Collect (simple_match_ip (dst m)) =\n                      {d. \\<not> simple_match_ip (dst m) d \\<and>\n                          runFw s d c rs = Decision FinalAllow}\n 2. \\<lbrakk>r = SimpleRule m Drop;\n     wordinterval_to_set (matching_dsts s rs Empty_WordInterval) =\n     {d. runFw s d c rs = Decision FinalAllow};\n     simple_conn_matches m c \\<and>\n     (\\<forall>r\\<in>set rs. simple_conn_matches (match_sel r) c);\n     a = Drop; r = SimpleRule m a;\n     \\<forall>r\\<in>set rs.\n        simple_conn_matches (match_sel r) c \\<Longrightarrow>\n     wordinterval_to_set (matching_dsts s rs Empty_WordInterval) =\n     {d. runFw s d c rs = Decision FinalAllow};\n     \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c;\n     a = Drop; \\<not> simple_match_ip (src m) s\\<rbrakk>\n    \\<Longrightarrow> {d. runFw s d c rs = Decision FinalAllow} =\n                      {d. runFw s d c (SimpleRule m Drop # rs) =\n                          Decision FinalAllow}", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = SimpleRule m Drop;\n     wordinterval_to_set (matching_dsts s rs Empty_WordInterval) =\n     {d. runFw s d c rs = Decision FinalAllow};\n     simple_conn_matches m c \\<and>\n     (\\<forall>r\\<in>set rs. simple_conn_matches (match_sel r) c);\n     a = Drop; r = SimpleRule m a;\n     \\<forall>r\\<in>set rs.\n        simple_conn_matches (match_sel r) c \\<Longrightarrow>\n     wordinterval_to_set (matching_dsts s rs Empty_WordInterval) =\n     {d. runFw s d c rs = Decision FinalAllow};\n     \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c;\n     a = Drop; \\<not> simple_match_ip (src m) s\\<rbrakk>\n    \\<Longrightarrow> {d. runFw s d c rs = Decision FinalAllow} =\n                      {d. runFw s d c (SimpleRule m Drop # rs) =\n                          Decision FinalAllow}", "apply(simp add: not_simple_match_ip; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wordinterval_to_set (matching_dsts s (r # rs) Empty_WordInterval) =\n  {d. runFw s d c (r # rs) = Decision FinalAllow}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wordinterval_to_set (matching_dsts s (r # rs) Empty_WordInterval) =\n  {d. runFw s d c (r # rs) = Decision FinalAllow}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matching_srcs: \"\\<forall>r \\<in> set rs. simple_conn_matches (match_sel r) c \\<Longrightarrow>\n          wordinterval_to_set (matching_srcs d rs Empty_WordInterval) = {s. runFw s d c rs = Decision FinalAllow}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>set rs.\n       simple_conn_matches (match_sel r) c \\<Longrightarrow>\n    wordinterval_to_set (matching_srcs d rs Empty_WordInterval) =\n    {s. runFw s d c rs = Decision FinalAllow}", "proof(induction rs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>r\\<in>set [].\n       simple_conn_matches (match_sel r) c \\<Longrightarrow>\n    wordinterval_to_set (matching_srcs d [] Empty_WordInterval) =\n    {s. runFw s d c [] = Decision FinalAllow}\n 2. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_srcs d rs Empty_WordInterval) =\n                {s. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_srcs d (a # rs) Empty_WordInterval) =\n                         {s. runFw s d c (a # rs) = Decision FinalAllow}", "case Nil"], ["proof (state)\nthis:\n  \\<forall>r\\<in>set []. simple_conn_matches (match_sel r) c\n\ngoal (2 subgoals):\n 1. \\<forall>r\\<in>set [].\n       simple_conn_matches (match_sel r) c \\<Longrightarrow>\n    wordinterval_to_set (matching_srcs d [] Empty_WordInterval) =\n    {s. runFw s d c [] = Decision FinalAllow}\n 2. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_srcs d rs Empty_WordInterval) =\n                {s. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_srcs d (a # rs) Empty_WordInterval) =\n                         {s. runFw s d c (a # rs) = Decision FinalAllow}", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>set []. simple_conn_matches (match_sel r) c\n\ngoal (1 subgoal):\n 1. wordinterval_to_set (matching_srcs d [] Empty_WordInterval) =\n    {s. runFw s d c [] = Decision FinalAllow}", "by (simp add: runFw_def)"], ["proof (state)\nthis:\n  wordinterval_to_set (matching_srcs d [] Empty_WordInterval) =\n  {s. runFw s d c [] = Decision FinalAllow}\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_srcs d rs Empty_WordInterval) =\n                {s. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_srcs d (a # rs) Empty_WordInterval) =\n                         {s. runFw s d c (a # rs) = Decision FinalAllow}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_srcs d rs Empty_WordInterval) =\n                {s. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_srcs d (a # rs) Empty_WordInterval) =\n                         {s. runFw s d c (a # rs) = Decision FinalAllow}", "case (Cons r rs)"], ["proof (state)\nthis:\n  \\<forall>r\\<in>set rs.\n     simple_conn_matches (match_sel r) c \\<Longrightarrow>\n  wordinterval_to_set (matching_srcs d rs Empty_WordInterval) =\n  {s. runFw s d c rs = Decision FinalAllow}\n  \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_srcs d rs Empty_WordInterval) =\n                {s. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_srcs d (a # rs) Empty_WordInterval) =\n                         {s. runFw s d c (a # rs) = Decision FinalAllow}", "obtain m a where r: \"r = SimpleRule m a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m a.\n        r = SimpleRule m a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases r, blast)"], ["proof (state)\nthis:\n  r = SimpleRule m a\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_srcs d rs Empty_WordInterval) =\n                {s. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_srcs d (a # rs) Empty_WordInterval) =\n                         {s. runFw s d c (a # rs) = Decision FinalAllow}", "from Cons.prems r"], ["proof (chain)\npicking this:\n  \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c\n  r = SimpleRule m a", "have simple_match_ip_Accept: \"\\<And>s. simple_match_ip (dst m) d \\<Longrightarrow>\n         runFw s d c (SimpleRule m Accept # rs) = Decision FinalAllow \\<longleftrightarrow>\n          simple_match_ip (src m) s \\<or> runFw s d c rs = Decision FinalAllow\""], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c\n  r = SimpleRule m a\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       simple_match_ip (dst m) d \\<Longrightarrow>\n       (runFw s d c (SimpleRule m Accept # rs) = Decision FinalAllow) =\n       (simple_match_ip (src m) s \\<or>\n        runFw s d c rs = Decision FinalAllow)", "by(simp add: simple_conn_matches_def runFw_def simple_matches.simps)"], ["proof (state)\nthis:\n  simple_match_ip (dst m) d \\<Longrightarrow>\n  (runFw ?s d c (SimpleRule m Accept # rs) = Decision FinalAllow) =\n  (simple_match_ip (src m) ?s \\<or> runFw ?s d c rs = Decision FinalAllow)\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_srcs d rs Empty_WordInterval) =\n                {s. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_srcs d (a # rs) Empty_WordInterval) =\n                         {s. runFw s d c (a # rs) = Decision FinalAllow}", "{"], ["proof (state)\nthis:\n  simple_match_ip (dst m) d \\<Longrightarrow>\n  (runFw ?s d c (SimpleRule m Accept # rs) = Decision FinalAllow) =\n  (simple_match_ip (src m) ?s \\<or> runFw ?s d c rs = Decision FinalAllow)\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_srcs d rs Empty_WordInterval) =\n                {s. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_srcs d (a # rs) Empty_WordInterval) =\n                         {s. runFw s d c (a # rs) = Decision FinalAllow}", "fix s a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_srcs d rs Empty_WordInterval) =\n                {s. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_srcs d (a # rs) Empty_WordInterval) =\n                         {s. runFw s d c (a # rs) = Decision FinalAllow}", "have \"\\<not> simple_match_ip (dst m) d \\<Longrightarrow>\n         runFw s d c (SimpleRule m a # rs) = Decision FinalAllow \\<longleftrightarrow> runFw s d c rs = Decision FinalAllow\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> simple_match_ip (dst m) d \\<Longrightarrow>\n    (runFw s d c (SimpleRule m a # rs) = Decision FinalAllow) =\n    (runFw s d c rs = Decision FinalAllow)", "apply(cases a)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> simple_match_ip (dst m) d; a = Accept\\<rbrakk>\n    \\<Longrightarrow> (runFw s d c (SimpleRule m a # rs) =\n                       Decision FinalAllow) =\n                      (runFw s d c rs = Decision FinalAllow)\n 2. \\<lbrakk>\\<not> simple_match_ip (dst m) d; a = Drop\\<rbrakk>\n    \\<Longrightarrow> (runFw s d c (SimpleRule m a # rs) =\n                       Decision FinalAllow) =\n                      (runFw s d c rs = Decision FinalAllow)", "by(simp add: simple_conn_matches_def runFw_def simple_matches.simps)+"], ["proof (state)\nthis:\n  \\<not> simple_match_ip (dst m) d \\<Longrightarrow>\n  (runFw s d c (SimpleRule m a # rs) = Decision FinalAllow) =\n  (runFw s d c rs = Decision FinalAllow)\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_srcs d rs Empty_WordInterval) =\n                {s. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_srcs d (a # rs) Empty_WordInterval) =\n                         {s. runFw s d c (a # rs) = Decision FinalAllow}", "}"], ["proof (state)\nthis:\n  \\<not> simple_match_ip (dst m) d \\<Longrightarrow>\n  (runFw ?s2 d c (SimpleRule m ?aa2 # rs) = Decision FinalAllow) =\n  (runFw ?s2 d c rs = Decision FinalAllow)\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_srcs d rs Empty_WordInterval) =\n                {s. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_srcs d (a # rs) Empty_WordInterval) =\n                         {s. runFw s d c (a # rs) = Decision FinalAllow}", "note not_simple_match_ip=this"], ["proof (state)\nthis:\n  \\<not> simple_match_ip (dst m) d \\<Longrightarrow>\n  (runFw ?s2 d c (SimpleRule m ?aa2 # rs) = Decision FinalAllow) =\n  (runFw ?s2 d c rs = Decision FinalAllow)\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_srcs d rs Empty_WordInterval) =\n                {s. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_srcs d (a # rs) Empty_WordInterval) =\n                         {s. runFw s d c (a # rs) = Decision FinalAllow}", "from Cons.prems r"], ["proof (chain)\npicking this:\n  \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c\n  r = SimpleRule m a", "have simple_match_ip_Drop: \"\\<And>s. simple_match_ip (dst m) d \\<Longrightarrow>\n         runFw s d c (SimpleRule m Drop # rs) = Decision FinalAllow \\<longleftrightarrow>\n          \\<not> simple_match_ip (src m) s \\<and> runFw s d c rs = Decision FinalAllow\""], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c\n  r = SimpleRule m a\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       simple_match_ip (dst m) d \\<Longrightarrow>\n       (runFw s d c (SimpleRule m Drop # rs) = Decision FinalAllow) =\n       (\\<not> simple_match_ip (src m) s \\<and>\n        runFw s d c rs = Decision FinalAllow)", "by(simp add: simple_conn_matches_def runFw_def simple_matches.simps)"], ["proof (state)\nthis:\n  simple_match_ip (dst m) d \\<Longrightarrow>\n  (runFw ?s d c (SimpleRule m Drop # rs) = Decision FinalAllow) =\n  (\\<not> simple_match_ip (src m) ?s \\<and>\n   runFw ?s d c rs = Decision FinalAllow)\n\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>\\<forall>r\\<in>set rs.\n                   simple_conn_matches (match_sel r) c \\<Longrightarrow>\n                wordinterval_to_set\n                 (matching_srcs d rs Empty_WordInterval) =\n                {s. runFw s d c rs = Decision FinalAllow};\n        \\<forall>r\\<in>set (a # rs).\n           simple_conn_matches (match_sel r) c\\<rbrakk>\n       \\<Longrightarrow> wordinterval_to_set\n                          (matching_srcs d (a # rs) Empty_WordInterval) =\n                         {s. runFw s d c (a # rs) = Decision FinalAllow}", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (matching_srcs d (r # rs) Empty_WordInterval) =\n    {s. runFw s d c (r # rs) = Decision FinalAllow}", "proof(cases a)"], ["proof (state)\ngoal (2 subgoals):\n 1. a = Accept \\<Longrightarrow>\n    wordinterval_to_set (matching_srcs d (r # rs) Empty_WordInterval) =\n    {s. runFw s d c (r # rs) = Decision FinalAllow}\n 2. a = Drop \\<Longrightarrow>\n    wordinterval_to_set (matching_srcs d (r # rs) Empty_WordInterval) =\n    {s. runFw s d c (r # rs) = Decision FinalAllow}", "case Accept"], ["proof (state)\nthis:\n  a = Accept\n\ngoal (2 subgoals):\n 1. a = Accept \\<Longrightarrow>\n    wordinterval_to_set (matching_srcs d (r # rs) Empty_WordInterval) =\n    {s. runFw s d c (r # rs) = Decision FinalAllow}\n 2. a = Drop \\<Longrightarrow>\n    wordinterval_to_set (matching_srcs d (r # rs) Empty_WordInterval) =\n    {s. runFw s d c (r # rs) = Decision FinalAllow}", "with r Cons"], ["proof (chain)\npicking this:\n  r = SimpleRule m a\n  \\<forall>r\\<in>set rs.\n     simple_conn_matches (match_sel r) c \\<Longrightarrow>\n  wordinterval_to_set (matching_srcs d rs Empty_WordInterval) =\n  {s. runFw s d c rs = Decision FinalAllow}\n  \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c\n  a = Accept", "show ?thesis"], ["proof (prove)\nusing this:\n  r = SimpleRule m a\n  \\<forall>r\\<in>set rs.\n     simple_conn_matches (match_sel r) c \\<Longrightarrow>\n  wordinterval_to_set (matching_srcs d rs Empty_WordInterval) =\n  {s. runFw s d c rs = Decision FinalAllow}\n  \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c\n  a = Accept\n\ngoal (1 subgoal):\n 1. wordinterval_to_set (matching_srcs d (r # rs) Empty_WordInterval) =\n    {s. runFw s d c (r # rs) = Decision FinalAllow}", "apply(simp, intro conjI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r = SimpleRule m Accept;\n     wordinterval_to_set (matching_srcs d rs Empty_WordInterval) =\n     {s. runFw s d c rs = Decision FinalAllow};\n     simple_conn_matches m c \\<and>\n     (\\<forall>r\\<in>set rs. simple_conn_matches (match_sel r) c);\n     a = Accept; r = SimpleRule m a;\n     \\<forall>r\\<in>set rs.\n        simple_conn_matches (match_sel r) c \\<Longrightarrow>\n     wordinterval_to_set (matching_srcs d rs Empty_WordInterval) =\n     {s. runFw s d c rs = Decision FinalAllow};\n     \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c;\n     a = Accept; simple_match_ip (dst m) d\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (ipcidr_tuple_to_wordinterval (src m)) \\<union>\n                      {s. runFw s d c rs = Decision FinalAllow} =\n                      {s. runFw s d c (SimpleRule m Accept # rs) =\n                          Decision FinalAllow}\n 2. \\<lbrakk>r = SimpleRule m Accept;\n     wordinterval_to_set (matching_srcs d rs Empty_WordInterval) =\n     {s. runFw s d c rs = Decision FinalAllow};\n     simple_conn_matches m c \\<and>\n     (\\<forall>r\\<in>set rs. simple_conn_matches (match_sel r) c);\n     a = Accept; r = SimpleRule m a;\n     \\<forall>r\\<in>set rs.\n        simple_conn_matches (match_sel r) c \\<Longrightarrow>\n     wordinterval_to_set (matching_srcs d rs Empty_WordInterval) =\n     {s. runFw s d c rs = Decision FinalAllow};\n     \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c;\n     a = Accept; \\<not> simple_match_ip (dst m) d\\<rbrakk>\n    \\<Longrightarrow> {s. runFw s d c rs = Decision FinalAllow} =\n                      {s. runFw s d c (SimpleRule m Accept # rs) =\n                          Decision FinalAllow}", "apply(simp add: simple_match_ip_Accept wordinterval_to_set_ipcidr_tuple_to_wordinterval_simple_match_ip_set)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>simple_conn_matches m c; r = SimpleRule m Accept;\n     wordinterval_to_set (matching_srcs d rs Empty_WordInterval) =\n     {s. runFw s d c rs = Decision FinalAllow};\n     \\<forall>r\\<in>set rs. simple_conn_matches (match_sel r) c; a = Accept;\n     simple_match_ip (dst m) d\\<rbrakk>\n    \\<Longrightarrow> Collect (simple_match_ip (src m)) \\<union>\n                      {s. runFw s d c rs = Decision FinalAllow} =\n                      {s. simple_match_ip (src m) s \\<or>\n                          runFw s d c rs = Decision FinalAllow}\n 2. \\<lbrakk>r = SimpleRule m Accept;\n     wordinterval_to_set (matching_srcs d rs Empty_WordInterval) =\n     {s. runFw s d c rs = Decision FinalAllow};\n     simple_conn_matches m c \\<and>\n     (\\<forall>r\\<in>set rs. simple_conn_matches (match_sel r) c);\n     a = Accept; r = SimpleRule m a;\n     \\<forall>r\\<in>set rs.\n        simple_conn_matches (match_sel r) c \\<Longrightarrow>\n     wordinterval_to_set (matching_srcs d rs Empty_WordInterval) =\n     {s. runFw s d c rs = Decision FinalAllow};\n     \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c;\n     a = Accept; \\<not> simple_match_ip (dst m) d\\<rbrakk>\n    \\<Longrightarrow> {s. runFw s d c rs = Decision FinalAllow} =\n                      {s. runFw s d c (SimpleRule m Accept # rs) =\n                          Decision FinalAllow}", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = SimpleRule m Accept;\n     wordinterval_to_set (matching_srcs d rs Empty_WordInterval) =\n     {s. runFw s d c rs = Decision FinalAllow};\n     simple_conn_matches m c \\<and>\n     (\\<forall>r\\<in>set rs. simple_conn_matches (match_sel r) c);\n     a = Accept; r = SimpleRule m a;\n     \\<forall>r\\<in>set rs.\n        simple_conn_matches (match_sel r) c \\<Longrightarrow>\n     wordinterval_to_set (matching_srcs d rs Empty_WordInterval) =\n     {s. runFw s d c rs = Decision FinalAllow};\n     \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c;\n     a = Accept; \\<not> simple_match_ip (dst m) d\\<rbrakk>\n    \\<Longrightarrow> {s. runFw s d c rs = Decision FinalAllow} =\n                      {s. runFw s d c (SimpleRule m Accept # rs) =\n                          Decision FinalAllow}", "apply(simp add: not_simple_match_ip; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wordinterval_to_set (matching_srcs d (r # rs) Empty_WordInterval) =\n  {s. runFw s d c (r # rs) = Decision FinalAllow}\n\ngoal (1 subgoal):\n 1. a = Drop \\<Longrightarrow>\n    wordinterval_to_set (matching_srcs d (r # rs) Empty_WordInterval) =\n    {s. runFw s d c (r # rs) = Decision FinalAllow}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a = Drop \\<Longrightarrow>\n    wordinterval_to_set (matching_srcs d (r # rs) Empty_WordInterval) =\n    {s. runFw s d c (r # rs) = Decision FinalAllow}", "case Drop"], ["proof (state)\nthis:\n  a = Drop\n\ngoal (1 subgoal):\n 1. a = Drop \\<Longrightarrow>\n    wordinterval_to_set (matching_srcs d (r # rs) Empty_WordInterval) =\n    {s. runFw s d c (r # rs) = Decision FinalAllow}", "with r Cons"], ["proof (chain)\npicking this:\n  r = SimpleRule m a\n  \\<forall>r\\<in>set rs.\n     simple_conn_matches (match_sel r) c \\<Longrightarrow>\n  wordinterval_to_set (matching_srcs d rs Empty_WordInterval) =\n  {s. runFw s d c rs = Decision FinalAllow}\n  \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c\n  a = Drop", "show ?thesis"], ["proof (prove)\nusing this:\n  r = SimpleRule m a\n  \\<forall>r\\<in>set rs.\n     simple_conn_matches (match_sel r) c \\<Longrightarrow>\n  wordinterval_to_set (matching_srcs d rs Empty_WordInterval) =\n  {s. runFw s d c rs = Decision FinalAllow}\n  \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c\n  a = Drop\n\ngoal (1 subgoal):\n 1. wordinterval_to_set (matching_srcs d (r # rs) Empty_WordInterval) =\n    {s. runFw s d c (r # rs) = Decision FinalAllow}", "apply(simp,intro conjI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>r = SimpleRule m Drop;\n     wordinterval_to_set (matching_srcs d rs Empty_WordInterval) =\n     {s. runFw s d c rs = Decision FinalAllow};\n     simple_conn_matches m c \\<and>\n     (\\<forall>r\\<in>set rs. simple_conn_matches (match_sel r) c);\n     a = Drop; r = SimpleRule m a;\n     \\<forall>r\\<in>set rs.\n        simple_conn_matches (match_sel r) c \\<Longrightarrow>\n     wordinterval_to_set (matching_srcs d rs Empty_WordInterval) =\n     {s. runFw s d c rs = Decision FinalAllow};\n     \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c;\n     a = Drop; simple_match_ip (dst m) d\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set\n                       (matching_srcs d rs\n                         (wordinterval_union\n                           (ipcidr_tuple_to_wordinterval (src m))\n                           Empty_WordInterval)) =\n                      {s. runFw s d c (SimpleRule m Drop # rs) =\n                          Decision FinalAllow}\n 2. \\<lbrakk>r = SimpleRule m Drop;\n     wordinterval_to_set (matching_srcs d rs Empty_WordInterval) =\n     {s. runFw s d c rs = Decision FinalAllow};\n     simple_conn_matches m c \\<and>\n     (\\<forall>r\\<in>set rs. simple_conn_matches (match_sel r) c);\n     a = Drop; r = SimpleRule m a;\n     \\<forall>r\\<in>set rs.\n        simple_conn_matches (match_sel r) c \\<Longrightarrow>\n     wordinterval_to_set (matching_srcs d rs Empty_WordInterval) =\n     {s. runFw s d c rs = Decision FinalAllow};\n     \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c;\n     a = Drop; \\<not> simple_match_ip (dst m) d\\<rbrakk>\n    \\<Longrightarrow> {s. runFw s d c rs = Decision FinalAllow} =\n                      {s. runFw s d c (SimpleRule m Drop # rs) =\n                          Decision FinalAllow}", "apply(simp add: simple_match_ip_Drop matching_srcs_pull_out_accu wordinterval_to_set_ipcidr_tuple_to_wordinterval_simple_match_ip_set)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>simple_conn_matches m c; r = SimpleRule m Drop;\n     wordinterval_to_set (matching_srcs d rs Empty_WordInterval) =\n     {s. runFw s d c rs = Decision FinalAllow};\n     \\<forall>r\\<in>set rs. simple_conn_matches (match_sel r) c; a = Drop;\n     simple_match_ip (dst m) d\\<rbrakk>\n    \\<Longrightarrow> {s. runFw s d c rs = Decision FinalAllow} -\n                      Collect (simple_match_ip (src m)) =\n                      {s. \\<not> simple_match_ip (src m) s \\<and>\n                          runFw s d c rs = Decision FinalAllow}\n 2. \\<lbrakk>r = SimpleRule m Drop;\n     wordinterval_to_set (matching_srcs d rs Empty_WordInterval) =\n     {s. runFw s d c rs = Decision FinalAllow};\n     simple_conn_matches m c \\<and>\n     (\\<forall>r\\<in>set rs. simple_conn_matches (match_sel r) c);\n     a = Drop; r = SimpleRule m a;\n     \\<forall>r\\<in>set rs.\n        simple_conn_matches (match_sel r) c \\<Longrightarrow>\n     wordinterval_to_set (matching_srcs d rs Empty_WordInterval) =\n     {s. runFw s d c rs = Decision FinalAllow};\n     \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c;\n     a = Drop; \\<not> simple_match_ip (dst m) d\\<rbrakk>\n    \\<Longrightarrow> {s. runFw s d c rs = Decision FinalAllow} =\n                      {s. runFw s d c (SimpleRule m Drop # rs) =\n                          Decision FinalAllow}", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>r = SimpleRule m Drop;\n     wordinterval_to_set (matching_srcs d rs Empty_WordInterval) =\n     {s. runFw s d c rs = Decision FinalAllow};\n     simple_conn_matches m c \\<and>\n     (\\<forall>r\\<in>set rs. simple_conn_matches (match_sel r) c);\n     a = Drop; r = SimpleRule m a;\n     \\<forall>r\\<in>set rs.\n        simple_conn_matches (match_sel r) c \\<Longrightarrow>\n     wordinterval_to_set (matching_srcs d rs Empty_WordInterval) =\n     {s. runFw s d c rs = Decision FinalAllow};\n     \\<forall>r\\<in>set (r # rs). simple_conn_matches (match_sel r) c;\n     a = Drop; \\<not> simple_match_ip (dst m) d\\<rbrakk>\n    \\<Longrightarrow> {s. runFw s d c rs = Decision FinalAllow} =\n                      {s. runFw s d c (SimpleRule m Drop # rs) =\n                          Decision FinalAllow}", "apply(simp add: not_simple_match_ip; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wordinterval_to_set (matching_srcs d (r # rs) Empty_WordInterval) =\n  {s. runFw s d c (r # rs) = Decision FinalAllow}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wordinterval_to_set (matching_srcs d (r # rs) Empty_WordInterval) =\n  {s. runFw s d c (r # rs) = Decision FinalAllow}\n\ngoal:\nNo subgoals!", "qed"], ["", "(*TODO: if we can get wordinterval_element to log runtime ...*)"], ["", "definition groupWIs3_default_policy :: \"parts_connection \\<Rightarrow> 'i::len simple_rule list \\<Rightarrow> 'i wordinterval list list\" where\n    \"groupWIs3_default_policy c rs =  (let P = getParts rs in\n                         (let W = map getOneIp P in \n                         (let filterW = (filter (\\<lambda>r. simple_conn_matches (match_sel r) c) rs) in\n                           (let f = (\\<lambda>wi. let mtch_dsts = (matching_dsts (getOneIp wi) filterW Empty_WordInterval);\n                                              mtch_srcs = (matching_srcs (getOneIp wi) filterW Empty_WordInterval) in \n                                          (map (\\<lambda>d. wordinterval_element d mtch_dsts) W,\n                                           map (\\<lambda>s. wordinterval_element s mtch_srcs) W)) in\n                        map (map fst) (groupF snd (map (\\<lambda>x. (x, f x)) P))))))\""], ["", "lemma groupWIs3_default_policy_groupWIs2:\n  fixes rs :: \"'i::len simple_rule list\"\n  assumes \"has_default_policy rs\"\n  shows \"groupWIs2 c rs = groupWIs3_default_policy c rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. groupWIs2 c rs = groupWIs3_default_policy c rs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. groupWIs2 c rs = groupWIs3_default_policy c rs", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. groupWIs2 c rs = groupWIs3_default_policy c rs", "fix filterW s d"], ["proof (state)\ngoal (1 subgoal):\n 1. groupWIs2 c rs = groupWIs3_default_policy c rs", "from matching_dsts[where c=c]"], ["proof (chain)\npicking this:\n  \\<forall>r\\<in>set ?rs.\n     simple_conn_matches (match_sel r) c \\<Longrightarrow>\n  wordinterval_to_set (matching_dsts ?s ?rs Empty_WordInterval) =\n  {d. runFw ?s d c ?rs = Decision FinalAllow}", "have \"filterW = filter (\\<lambda>r. simple_conn_matches (match_sel r) c) rs \\<Longrightarrow>\n           wordinterval_element d (matching_dsts s filterW Empty_WordInterval) \\<longleftrightarrow> runFw s d c filterW = Decision FinalAllow\""], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>set ?rs.\n     simple_conn_matches (match_sel r) c \\<Longrightarrow>\n  wordinterval_to_set (matching_dsts ?s ?rs Empty_WordInterval) =\n  {d. runFw ?s d c ?rs = Decision FinalAllow}\n\ngoal (1 subgoal):\n 1. filterW =\n    filter (\\<lambda>r. simple_conn_matches (match_sel r) c)\n     rs \\<Longrightarrow>\n    wordinterval_element d (matching_dsts s filterW Empty_WordInterval) =\n    (runFw s d c filterW = Decision FinalAllow)", "by force"], ["proof (state)\nthis:\n  filterW =\n  filter (\\<lambda>r. simple_conn_matches (match_sel r) c)\n   rs \\<Longrightarrow>\n  wordinterval_element d (matching_dsts s filterW Empty_WordInterval) =\n  (runFw s d c filterW = Decision FinalAllow)\n\ngoal (1 subgoal):\n 1. groupWIs2 c rs = groupWIs3_default_policy c rs", "}"], ["proof (state)\nthis:\n  ?filterW2 =\n  filter (\\<lambda>r. simple_conn_matches (match_sel r) c)\n   rs \\<Longrightarrow>\n  wordinterval_element ?d2\n   (matching_dsts ?s2 ?filterW2 Empty_WordInterval) =\n  (runFw ?s2 ?d2 c ?filterW2 = Decision FinalAllow)\n\ngoal (1 subgoal):\n 1. groupWIs2 c rs = groupWIs3_default_policy c rs", "note matching_dsts_filterW=this[simplified]"], ["proof (state)\nthis:\n  ?filterW2 =\n  filter (\\<lambda>r. simple_conn_matches (match_sel r) c)\n   rs \\<Longrightarrow>\n  (?d2\n   \\<in> wordinterval_to_set\n          (matching_dsts ?s2 ?filterW2 Empty_WordInterval)) =\n  (runFw ?s2 ?d2 c ?filterW2 = Decision FinalAllow)\n\ngoal (1 subgoal):\n 1. groupWIs2 c rs = groupWIs3_default_policy c rs", "{"], ["proof (state)\nthis:\n  ?filterW2 =\n  filter (\\<lambda>r. simple_conn_matches (match_sel r) c)\n   rs \\<Longrightarrow>\n  (?d2\n   \\<in> wordinterval_to_set\n          (matching_dsts ?s2 ?filterW2 Empty_WordInterval)) =\n  (runFw ?s2 ?d2 c ?filterW2 = Decision FinalAllow)\n\ngoal (1 subgoal):\n 1. groupWIs2 c rs = groupWIs3_default_policy c rs", "fix filterW s d"], ["proof (state)\ngoal (1 subgoal):\n 1. groupWIs2 c rs = groupWIs3_default_policy c rs", "from matching_srcs[where c=c]"], ["proof (chain)\npicking this:\n  \\<forall>r\\<in>set ?rs.\n     simple_conn_matches (match_sel r) c \\<Longrightarrow>\n  wordinterval_to_set (matching_srcs ?d ?rs Empty_WordInterval) =\n  {s. runFw s ?d c ?rs = Decision FinalAllow}", "have \"filterW = filter (\\<lambda>r. simple_conn_matches (match_sel r) c) rs \\<Longrightarrow>\n            wordinterval_element s (matching_srcs d filterW Empty_WordInterval) \\<longleftrightarrow> runFw s d c filterW = Decision FinalAllow\""], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>set ?rs.\n     simple_conn_matches (match_sel r) c \\<Longrightarrow>\n  wordinterval_to_set (matching_srcs ?d ?rs Empty_WordInterval) =\n  {s. runFw s ?d c ?rs = Decision FinalAllow}\n\ngoal (1 subgoal):\n 1. filterW =\n    filter (\\<lambda>r. simple_conn_matches (match_sel r) c)\n     rs \\<Longrightarrow>\n    wordinterval_element s (matching_srcs d filterW Empty_WordInterval) =\n    (runFw s d c filterW = Decision FinalAllow)", "by force"], ["proof (state)\nthis:\n  filterW =\n  filter (\\<lambda>r. simple_conn_matches (match_sel r) c)\n   rs \\<Longrightarrow>\n  wordinterval_element s (matching_srcs d filterW Empty_WordInterval) =\n  (runFw s d c filterW = Decision FinalAllow)\n\ngoal (1 subgoal):\n 1. groupWIs2 c rs = groupWIs3_default_policy c rs", "}"], ["proof (state)\nthis:\n  ?filterW2 =\n  filter (\\<lambda>r. simple_conn_matches (match_sel r) c)\n   rs \\<Longrightarrow>\n  wordinterval_element ?s2\n   (matching_srcs ?d2 ?filterW2 Empty_WordInterval) =\n  (runFw ?s2 ?d2 c ?filterW2 = Decision FinalAllow)\n\ngoal (1 subgoal):\n 1. groupWIs2 c rs = groupWIs3_default_policy c rs", "note matching_srcs_filterW=this[simplified]"], ["proof (state)\nthis:\n  ?filterW2 =\n  filter (\\<lambda>r. simple_conn_matches (match_sel r) c)\n   rs \\<Longrightarrow>\n  (?s2\n   \\<in> wordinterval_to_set\n          (matching_srcs ?d2 ?filterW2 Empty_WordInterval)) =\n  (runFw ?s2 ?d2 c ?filterW2 = Decision FinalAllow)\n\ngoal (1 subgoal):\n 1. groupWIs2 c rs = groupWIs3_default_policy c rs", "{"], ["proof (state)\nthis:\n  ?filterW2 =\n  filter (\\<lambda>r. simple_conn_matches (match_sel r) c)\n   rs \\<Longrightarrow>\n  (?s2\n   \\<in> wordinterval_to_set\n          (matching_srcs ?d2 ?filterW2 Empty_WordInterval)) =\n  (runFw ?s2 ?d2 c ?filterW2 = Decision FinalAllow)\n\ngoal (1 subgoal):\n 1. groupWIs2 c rs = groupWIs3_default_policy c rs", "fix W and rs :: \"'i::len simple_rule list\""], ["proof (state)\ngoal (1 subgoal):\n 1. groupWIs2 c rs = groupWIs3_default_policy c rs", "assume assms': \"has_default_policy rs\""], ["proof (state)\nthis:\n  has_default_policy rs\n\ngoal (1 subgoal):\n 1. groupWIs2 c rs = groupWIs3_default_policy c rs", "have \"groupF (\\<lambda>wi. (map (\\<lambda>d. runFw (getOneIp wi) d c rs = Decision FinalAllow) (map getOneIp W),\n                           map (\\<lambda>s. runFw s (getOneIp wi) c rs = Decision FinalAllow) (map getOneIp W))) W =\n             groupF (\\<lambda>wi. (map (\\<lambda>d. runFw (getOneIp wi) d c rs) (map getOneIp W),\n                           map (\\<lambda>s. runFw s (getOneIp wi) c rs) (map getOneIp W))) W\""], ["proof (prove)\ngoal (1 subgoal):\n 1. groupF\n     (\\<lambda>wi.\n         (map (\\<lambda>d. runFw (getOneIp wi) d c rs = Decision FinalAllow)\n           (map getOneIp W),\n          map (\\<lambda>s. runFw s (getOneIp wi) c rs = Decision FinalAllow)\n           (map getOneIp W)))\n     W =\n    groupF\n     (\\<lambda>wi.\n         (map (\\<lambda>d. runFw (getOneIp wi) d c rs) (map getOneIp W),\n          map (\\<lambda>s. runFw s (getOneIp wi) c rs) (map getOneIp W)))\n     W", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. groupF\n     (\\<lambda>wi.\n         (map (\\<lambda>d. runFw (getOneIp wi) d c rs = Decision FinalAllow)\n           (map getOneIp W),\n          map (\\<lambda>s. runFw s (getOneIp wi) c rs = Decision FinalAllow)\n           (map getOneIp W)))\n     W =\n    groupF\n     (\\<lambda>wi.\n         (map (\\<lambda>d. runFw (getOneIp wi) d c rs) (map getOneIp W),\n          map (\\<lambda>s. runFw s (getOneIp wi) c rs) (map getOneIp W)))\n     W", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. groupF\n     (\\<lambda>wi.\n         (map (\\<lambda>d. runFw (getOneIp wi) d c rs = Decision FinalAllow)\n           (map getOneIp W),\n          map (\\<lambda>s. runFw s (getOneIp wi) c rs = Decision FinalAllow)\n           (map getOneIp W)))\n     W =\n    groupF\n     (\\<lambda>wi.\n         (map (\\<lambda>d. runFw (getOneIp wi) d c rs) (map getOneIp W),\n          map (\\<lambda>s. runFw s (getOneIp wi) c rs) (map getOneIp W)))\n     W", "(*unused fresh generic variables. 'a is used for the tuple already*)"], ["proof (state)\ngoal (1 subgoal):\n 1. groupF\n     (\\<lambda>wi.\n         (map (\\<lambda>d. runFw (getOneIp wi) d c rs = Decision FinalAllow)\n           (map getOneIp W),\n          map (\\<lambda>s. runFw s (getOneIp wi) c rs = Decision FinalAllow)\n           (map getOneIp W)))\n     W =\n    groupF\n     (\\<lambda>wi.\n         (map (\\<lambda>d. runFw (getOneIp wi) d c rs) (map getOneIp W),\n          map (\\<lambda>s. runFw s (getOneIp wi) c rs) (map getOneIp W)))\n     W", "fix f1::\"'w \\<Rightarrow> 'u \\<Rightarrow> 'v\" and f2::\" 'w \\<Rightarrow> 'u \\<Rightarrow> 'x\" and x and y and g1::\"'w \\<Rightarrow> 'u \\<Rightarrow> 'y\" and g2::\"'w \\<Rightarrow> 'u \\<Rightarrow> 'z\" and W::\"'u list\""], ["proof (state)\ngoal (1 subgoal):\n 1. groupF\n     (\\<lambda>wi.\n         (map (\\<lambda>d. runFw (getOneIp wi) d c rs = Decision FinalAllow)\n           (map getOneIp W__),\n          map (\\<lambda>s. runFw s (getOneIp wi) c rs = Decision FinalAllow)\n           (map getOneIp W__)))\n     W__ =\n    groupF\n     (\\<lambda>wi.\n         (map (\\<lambda>d. runFw (getOneIp wi) d c rs) (map getOneIp W__),\n          map (\\<lambda>s. runFw s (getOneIp wi) c rs) (map getOneIp W__)))\n     W__", "assume 1: \"\\<forall>w \\<in> set W. (f1 x) w = (f1 y) w \\<longleftrightarrow> (f2 x) w =  (f2 y) w\"\n               and 2: \"\\<forall>w \\<in> set W. (g1 x) w = (g1 y) w \\<longleftrightarrow> (g2 x) w =  (g2 y) w\""], ["proof (state)\nthis:\n  \\<forall>w\\<in>set W. (f1 x w = f1 y w) = (f2 x w = f2 y w)\n  \\<forall>w\\<in>set W. (g1 x w = g1 y w) = (g2 x w = g2 y w)\n\ngoal (1 subgoal):\n 1. groupF\n     (\\<lambda>wi.\n         (map (\\<lambda>d. runFw (getOneIp wi) d c rs = Decision FinalAllow)\n           (map getOneIp W__),\n          map (\\<lambda>s. runFw s (getOneIp wi) c rs = Decision FinalAllow)\n           (map getOneIp W__)))\n     W__ =\n    groupF\n     (\\<lambda>wi.\n         (map (\\<lambda>d. runFw (getOneIp wi) d c rs) (map getOneIp W__),\n          map (\\<lambda>s. runFw s (getOneIp wi) c rs) (map getOneIp W__)))\n     W__", "have \"\n                 ((map (f1 x) W, map (g1 x) W) = (map (f1 y) W, map (g1 y) W)) \n                 \\<longleftrightarrow>\n                 ((map (f2 x) W, map (g2 x) W) = (map (f2 y) W, map (g2 y) W))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((map (f1 x) W, map (g1 x) W) = (map (f1 y) W, map (g1 y) W)) =\n    ((map (f2 x) W, map (g2 x) W) = (map (f2 y) W, map (g2 y) W))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ((map (f1 x) W, map (g1 x) W) = (map (f1 y) W, map (g1 y) W)) =\n    ((map (f2 x) W, map (g2 x) W) = (map (f2 y) W, map (g2 y) W))", "from 1"], ["proof (chain)\npicking this:\n  \\<forall>w\\<in>set W. (f1 x w = f1 y w) = (f2 x w = f2 y w)", "have p1: \"(map (f1 x) W = map (f1 y) W \\<longleftrightarrow> map (f2 x) W = map (f2 y) W)\""], ["proof (prove)\nusing this:\n  \\<forall>w\\<in>set W. (f1 x w = f1 y w) = (f2 x w = f2 y w)\n\ngoal (1 subgoal):\n 1. (map (f1 x) W = map (f1 y) W) = (map (f2 x) W = map (f2 y) W)", "by(induction W)(simp_all)"], ["proof (state)\nthis:\n  (map (f1 x) W = map (f1 y) W) = (map (f2 x) W = map (f2 y) W)\n\ngoal (1 subgoal):\n 1. ((map (f1 x) W, map (g1 x) W) = (map (f1 y) W, map (g1 y) W)) =\n    ((map (f2 x) W, map (g2 x) W) = (map (f2 y) W, map (g2 y) W))", "from 2"], ["proof (chain)\npicking this:\n  \\<forall>w\\<in>set W. (g1 x w = g1 y w) = (g2 x w = g2 y w)", "have p2: \"(map (g1 x) W = map (g1 y) W \\<longleftrightarrow> map (g2 x) W = map (g2 y) W)\""], ["proof (prove)\nusing this:\n  \\<forall>w\\<in>set W. (g1 x w = g1 y w) = (g2 x w = g2 y w)\n\ngoal (1 subgoal):\n 1. (map (g1 x) W = map (g1 y) W) = (map (g2 x) W = map (g2 y) W)", "by(induction W)(simp_all)"], ["proof (state)\nthis:\n  (map (g1 x) W = map (g1 y) W) = (map (g2 x) W = map (g2 y) W)\n\ngoal (1 subgoal):\n 1. ((map (f1 x) W, map (g1 x) W) = (map (f1 y) W, map (g1 y) W)) =\n    ((map (f2 x) W, map (g2 x) W) = (map (f2 y) W, map (g2 y) W))", "from p1 p2"], ["proof (chain)\npicking this:\n  (map (f1 x) W = map (f1 y) W) = (map (f2 x) W = map (f2 y) W)\n  (map (g1 x) W = map (g1 y) W) = (map (g2 x) W = map (g2 y) W)", "show ?thesis"], ["proof (prove)\nusing this:\n  (map (f1 x) W = map (f1 y) W) = (map (f2 x) W = map (f2 y) W)\n  (map (g1 x) W = map (g1 y) W) = (map (g2 x) W = map (g2 y) W)\n\ngoal (1 subgoal):\n 1. ((map (f1 x) W, map (g1 x) W) = (map (f1 y) W, map (g1 y) W)) =\n    ((map (f2 x) W, map (g2 x) W) = (map (f2 y) W, map (g2 y) W))", "by fast"], ["proof (state)\nthis:\n  ((map (f1 x) W, map (g1 x) W) = (map (f1 y) W, map (g1 y) W)) =\n  ((map (f2 x) W, map (g2 x) W) = (map (f2 y) W, map (g2 y) W))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((map (f1 x) W, map (g1 x) W) = (map (f1 y) W, map (g1 y) W)) =\n  ((map (f2 x) W, map (g2 x) W) = (map (f2 y) W, map (g2 y) W))\n\ngoal (1 subgoal):\n 1. groupF\n     (\\<lambda>wi.\n         (map (\\<lambda>d. runFw (getOneIp wi) d c rs = Decision FinalAllow)\n           (map getOneIp W__),\n          map (\\<lambda>s. runFw s (getOneIp wi) c rs = Decision FinalAllow)\n           (map getOneIp W__)))\n     W__ =\n    groupF\n     (\\<lambda>wi.\n         (map (\\<lambda>d. runFw (getOneIp wi) d c rs) (map getOneIp W__),\n          map (\\<lambda>s. runFw s (getOneIp wi) c rs) (map getOneIp W__)))\n     W__", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>w\\<in>set ?Wa2.\n              (?f1.2 ?x2 w = ?f1.2 ?y2 w) = (?f2.2 ?x2 w = ?f2.2 ?y2 w);\n   \\<forall>w\\<in>set ?Wa2.\n      (?g1.2 ?x2 w = ?g1.2 ?y2 w) = (?g2.2 ?x2 w = ?g2.2 ?y2 w)\\<rbrakk>\n  \\<Longrightarrow> ((map (?f1.2 ?x2) ?Wa2, map (?g1.2 ?x2) ?Wa2) =\n                     (map (?f1.2 ?y2) ?Wa2, map (?g1.2 ?y2) ?Wa2)) =\n                    ((map (?f2.2 ?x2) ?Wa2, map (?g2.2 ?x2) ?Wa2) =\n                     (map (?f2.2 ?y2) ?Wa2, map (?g2.2 ?y2) ?Wa2))\n\ngoal (1 subgoal):\n 1. groupF\n     (\\<lambda>wi.\n         (map (\\<lambda>d. runFw (getOneIp wi) d c rs = Decision FinalAllow)\n           (map getOneIp W),\n          map (\\<lambda>s. runFw s (getOneIp wi) c rs = Decision FinalAllow)\n           (map getOneIp W)))\n     W =\n    groupF\n     (\\<lambda>wi.\n         (map (\\<lambda>d. runFw (getOneIp wi) d c rs) (map getOneIp W),\n          map (\\<lambda>s. runFw s (getOneIp wi) c rs) (map getOneIp W)))\n     W", "note map_over_tuples_equal_helper=this"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>w\\<in>set ?Wa2.\n              (?f1.2 ?x2 w = ?f1.2 ?y2 w) = (?f2.2 ?x2 w = ?f2.2 ?y2 w);\n   \\<forall>w\\<in>set ?Wa2.\n      (?g1.2 ?x2 w = ?g1.2 ?y2 w) = (?g2.2 ?x2 w = ?g2.2 ?y2 w)\\<rbrakk>\n  \\<Longrightarrow> ((map (?f1.2 ?x2) ?Wa2, map (?g1.2 ?x2) ?Wa2) =\n                     (map (?f1.2 ?y2) ?Wa2, map (?g1.2 ?y2) ?Wa2)) =\n                    ((map (?f2.2 ?x2) ?Wa2, map (?g2.2 ?x2) ?Wa2) =\n                     (map (?f2.2 ?y2) ?Wa2, map (?g2.2 ?y2) ?Wa2))\n\ngoal (1 subgoal):\n 1. groupF\n     (\\<lambda>wi.\n         (map (\\<lambda>d. runFw (getOneIp wi) d c rs = Decision FinalAllow)\n           (map getOneIp W),\n          map (\\<lambda>s. runFw s (getOneIp wi) c rs = Decision FinalAllow)\n           (map getOneIp W)))\n     W =\n    groupF\n     (\\<lambda>wi.\n         (map (\\<lambda>d. runFw (getOneIp wi) d c rs) (map getOneIp W),\n          map (\\<lambda>s. runFw s (getOneIp wi) c rs) (map getOneIp W)))\n     W", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. groupF\n     (\\<lambda>wi.\n         (map (\\<lambda>d. runFw (getOneIp wi) d c rs = Decision FinalAllow)\n           (map getOneIp W),\n          map (\\<lambda>s. runFw s (getOneIp wi) c rs = Decision FinalAllow)\n           (map getOneIp W)))\n     W =\n    groupF\n     (\\<lambda>wi.\n         (map (\\<lambda>d. runFw (getOneIp wi) d c rs) (map getOneIp W),\n          map (\\<lambda>s. runFw s (getOneIp wi) c rs) (map getOneIp W)))\n     W", "apply(rule groupF_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set W.\n       \\<forall>y\\<in>set W.\n          ((map (\\<lambda>d.\n                    runFw (getOneIp x) d c rs = Decision FinalAllow)\n             (map getOneIp W),\n            map (\\<lambda>s.\n                    runFw s (getOneIp x) c rs = Decision FinalAllow)\n             (map getOneIp W)) =\n           (map (\\<lambda>d.\n                    runFw (getOneIp y) d c rs = Decision FinalAllow)\n             (map getOneIp W),\n            map (\\<lambda>s.\n                    runFw s (getOneIp y) c rs = Decision FinalAllow)\n             (map getOneIp W))) =\n          ((map (\\<lambda>d. runFw (getOneIp x) d c rs) (map getOneIp W),\n            map (\\<lambda>s. runFw s (getOneIp x) c rs) (map getOneIp W)) =\n           (map (\\<lambda>d. runFw (getOneIp y) d c rs) (map getOneIp W),\n            map (\\<lambda>s. runFw s (getOneIp y) c rs) (map getOneIp W)))", "apply(intro ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set W; y \\<in> set W\\<rbrakk>\n       \\<Longrightarrow> ((map (\\<lambda>d.\n                                   runFw (getOneIp x) d c rs =\n                                   Decision FinalAllow)\n                            (map getOneIp W),\n                           map (\\<lambda>s.\n                                   runFw s (getOneIp x) c rs =\n                                   Decision FinalAllow)\n                            (map getOneIp W)) =\n                          (map (\\<lambda>d.\n                                   runFw (getOneIp y) d c rs =\n                                   Decision FinalAllow)\n                            (map getOneIp W),\n                           map (\\<lambda>s.\n                                   runFw s (getOneIp y) c rs =\n                                   Decision FinalAllow)\n                            (map getOneIp W))) =\n                         ((map (\\<lambda>d. runFw (getOneIp x) d c rs)\n                            (map getOneIp W),\n                           map (\\<lambda>s. runFw s (getOneIp x) c rs)\n                            (map getOneIp W)) =\n                          (map (\\<lambda>d. runFw (getOneIp y) d c rs)\n                            (map getOneIp W),\n                           map (\\<lambda>s. runFw s (getOneIp y) c rs)\n                            (map getOneIp W)))", "apply(rule map_over_tuples_equal_helper)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set W; y \\<in> set W\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w\\<in>set (map getOneIp W).\n                            ((runFw (getOneIp x) w c rs =\n                              Decision FinalAllow) =\n                             (runFw (getOneIp y) w c rs =\n                              Decision FinalAllow)) =\n                            (runFw (getOneIp x) w c rs =\n                             runFw (getOneIp y) w c rs)\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> set W; y \\<in> set W\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w\\<in>set (map getOneIp W).\n                            ((runFw w (getOneIp x) c rs =\n                              Decision FinalAllow) =\n                             (runFw w (getOneIp y) c rs =\n                              Decision FinalAllow)) =\n                            (runFw w (getOneIp x) c rs =\n                             runFw w (getOneIp y) c rs)", "using has_default_policy_runFw[OF assms']"], ["proof (prove)\nusing this:\n  runFw ?s ?d ?c rs = Decision FinalAllow \\<or>\n  runFw ?s ?d ?c rs = Decision FinalDeny\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> set W; y \\<in> set W\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w\\<in>set (map getOneIp W).\n                            ((runFw (getOneIp x) w c rs =\n                              Decision FinalAllow) =\n                             (runFw (getOneIp y) w c rs =\n                              Decision FinalAllow)) =\n                            (runFw (getOneIp x) w c rs =\n                             runFw (getOneIp y) w c rs)\n 2. \\<And>x y.\n       \\<lbrakk>x \\<in> set W; y \\<in> set W\\<rbrakk>\n       \\<Longrightarrow> \\<forall>w\\<in>set (map getOneIp W).\n                            ((runFw w (getOneIp x) c rs =\n                              Decision FinalAllow) =\n                             (runFw w (getOneIp y) c rs =\n                              Decision FinalAllow)) =\n                            (runFw w (getOneIp x) c rs =\n                             runFw w (getOneIp y) c rs)", "by metis+"], ["proof (state)\nthis:\n  groupF\n   (\\<lambda>wi.\n       (map (\\<lambda>d. runFw (getOneIp wi) d c rs = Decision FinalAllow)\n         (map getOneIp W),\n        map (\\<lambda>s. runFw s (getOneIp wi) c rs = Decision FinalAllow)\n         (map getOneIp W)))\n   W =\n  groupF\n   (\\<lambda>wi.\n       (map (\\<lambda>d. runFw (getOneIp wi) d c rs) (map getOneIp W),\n        map (\\<lambda>s. runFw s (getOneIp wi) c rs) (map getOneIp W)))\n   W\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  groupF\n   (\\<lambda>wi.\n       (map (\\<lambda>d. runFw (getOneIp wi) d c rs = Decision FinalAllow)\n         (map getOneIp W),\n        map (\\<lambda>s. runFw s (getOneIp wi) c rs = Decision FinalAllow)\n         (map getOneIp W)))\n   W =\n  groupF\n   (\\<lambda>wi.\n       (map (\\<lambda>d. runFw (getOneIp wi) d c rs) (map getOneIp W),\n        map (\\<lambda>s. runFw s (getOneIp wi) c rs) (map getOneIp W)))\n   W\n\ngoal (1 subgoal):\n 1. groupWIs2 c rs = groupWIs3_default_policy c rs", "}"], ["proof (state)\nthis:\n  has_default_policy ?rsa2 \\<Longrightarrow>\n  groupF\n   (\\<lambda>wi.\n       (map (\\<lambda>d.\n                runFw (getOneIp wi) d c ?rsa2 = Decision FinalAllow)\n         (map getOneIp ?W2),\n        map (\\<lambda>s.\n                runFw s (getOneIp wi) c ?rsa2 = Decision FinalAllow)\n         (map getOneIp ?W2)))\n   ?W2 =\n  groupF\n   (\\<lambda>wi.\n       (map (\\<lambda>d. runFw (getOneIp wi) d c ?rsa2) (map getOneIp ?W2),\n        map (\\<lambda>s. runFw s (getOneIp wi) c ?rsa2) (map getOneIp ?W2)))\n   ?W2\n\ngoal (1 subgoal):\n 1. groupWIs2 c rs = groupWIs3_default_policy c rs", "note has_default_policy_groupF=this[simplified]"], ["proof (state)\nthis:\n  has_default_policy ?rsa2 \\<Longrightarrow>\n  groupF\n   (\\<lambda>wi.\n       (map ((\\<lambda>d.\n                 runFw (getOneIp wi) d c ?rsa2 =\n                 Decision FinalAllow) \\<circ>\n             getOneIp)\n         ?W2,\n        map ((\\<lambda>s.\n                 runFw s (getOneIp wi) c ?rsa2 =\n                 Decision FinalAllow) \\<circ>\n             getOneIp)\n         ?W2))\n   ?W2 =\n  groupF\n   (\\<lambda>wi.\n       (map ((\\<lambda>d. runFw (getOneIp wi) d c ?rsa2) \\<circ> getOneIp)\n         ?W2,\n        map ((\\<lambda>s. runFw s (getOneIp wi) c ?rsa2) \\<circ> getOneIp)\n         ?W2))\n   ?W2\n\ngoal (1 subgoal):\n 1. groupWIs2 c rs = groupWIs3_default_policy c rs", "from assms"], ["proof (chain)\npicking this:\n  has_default_policy rs", "show ?thesis"], ["proof (prove)\nusing this:\n  has_default_policy rs\n\ngoal (1 subgoal):\n 1. groupWIs2 c rs = groupWIs3_default_policy c rs", "apply(simp add: groupWIs3_default_policy_def groupWIs_code[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_default_policy rs \\<Longrightarrow>\n    groupWIs c rs =\n    (let P = getParts rs;\n         filterW =\n           filter (\\<lambda>r. simple_conn_matches (match_sel r) c) rs\n     in map (map fst)\n         (groupF snd\n           (map (\\<lambda>x.\n                    (x, map ((\\<lambda>d.\n                                 d \\<in> wordinterval_to_set\n    (matching_dsts (getOneIp x) filterW Empty_WordInterval)) \\<circ>\n                             getOneIp)\n                         P,\n                     map ((\\<lambda>s.\n                              s \\<in> wordinterval_to_set\n (matching_srcs (getOneIp x) filterW Empty_WordInterval)) \\<circ>\n                          getOneIp)\n                      P))\n             P)))", "apply(subst groupF_tuple[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_default_policy rs \\<Longrightarrow>\n    groupWIs c rs =\n    (let P = getParts rs;\n         filterW =\n           filter (\\<lambda>r. simple_conn_matches (match_sel r) c) rs\n     in groupF\n         (\\<lambda>x.\n             (map ((\\<lambda>d.\n                       d \\<in> wordinterval_to_set\n                                (matching_dsts (getOneIp x) filterW\n                                  Empty_WordInterval)) \\<circ>\n                   getOneIp)\n               P,\n              map ((\\<lambda>s.\n                       s \\<in> wordinterval_to_set\n                                (matching_srcs (getOneIp x) filterW\n                                  Empty_WordInterval)) \\<circ>\n                   getOneIp)\n               P))\n         P)", "apply(simp add: Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_default_policy rs \\<Longrightarrow>\n    groupWIs c rs =\n    groupF\n     (\\<lambda>x.\n         (map ((\\<lambda>d.\n                   d \\<in> wordinterval_to_set\n                            (matching_dsts (getOneIp x)\n                              (filter\n                                (\\<lambda>r.\n                                    simple_conn_matches (match_sel r) c)\n                                rs)\n                              Empty_WordInterval)) \\<circ>\n               getOneIp)\n           (getParts rs),\n          map ((\\<lambda>s.\n                   s \\<in> wordinterval_to_set\n                            (matching_srcs (getOneIp x)\n                              (filter\n                                (\\<lambda>r.\n                                    simple_conn_matches (match_sel r) c)\n                                rs)\n                              Empty_WordInterval)) \\<circ>\n               getOneIp)\n           (getParts rs)))\n     (getParts rs)", "apply(simp add: matching_srcs_filterW matching_dsts_filterW)"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_default_policy rs \\<Longrightarrow>\n    groupWIs c rs =\n    groupF\n     (\\<lambda>x.\n         (map ((\\<lambda>d.\n                   runFw (getOneIp x) d c\n                    (filter\n                      (\\<lambda>r. simple_conn_matches (match_sel r) c)\n                      rs) =\n                   Decision FinalAllow) \\<circ>\n               getOneIp)\n           (getParts rs),\n          map ((\\<lambda>s.\n                   runFw s (getOneIp x) c\n                    (filter\n                      (\\<lambda>r. simple_conn_matches (match_sel r) c)\n                      rs) =\n                   Decision FinalAllow) \\<circ>\n               getOneIp)\n           (getParts rs)))\n     (getParts rs)", "apply(subst has_default_policy_groupF)"], ["proof (prove)\ngoal (2 subgoals):\n 1. has_default_policy rs \\<Longrightarrow>\n    has_default_policy\n     (filter (\\<lambda>r. simple_conn_matches (match_sel r) c) rs)\n 2. has_default_policy rs \\<Longrightarrow>\n    groupWIs c rs =\n    groupF\n     (\\<lambda>wi.\n         (map ((\\<lambda>d.\n                   runFw (getOneIp wi) d c\n                    (filter\n                      (\\<lambda>r. simple_conn_matches (match_sel r) c)\n                      rs)) \\<circ>\n               getOneIp)\n           (getParts rs),\n          map ((\\<lambda>s.\n                   runFw s (getOneIp wi) c\n                    (filter\n                      (\\<lambda>r. simple_conn_matches (match_sel r) c)\n                      rs)) \\<circ>\n               getOneIp)\n           (getParts rs)))\n     (getParts rs)", "apply(simp add: has_default_policy_simple_conn_matches; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. has_default_policy rs \\<Longrightarrow>\n    groupWIs c rs =\n    groupF\n     (\\<lambda>wi.\n         (map ((\\<lambda>d.\n                   runFw (getOneIp wi) d c\n                    (filter\n                      (\\<lambda>r. simple_conn_matches (match_sel r) c)\n                      rs)) \\<circ>\n               getOneIp)\n           (getParts rs),\n          map ((\\<lambda>s.\n                   runFw s (getOneIp wi) c\n                    (filter\n                      (\\<lambda>r. simple_conn_matches (match_sel r) c)\n                      rs)) \\<circ>\n               getOneIp)\n           (getParts rs)))\n     (getParts rs)", "apply(simp add: groupWIs_def Let_def filter_conn_fw_lem)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  groupWIs2 c rs = groupWIs3_default_policy c rs\n\ngoal:\nNo subgoals!", "qed"], ["", "definition groupWIs3 :: \"parts_connection \\<Rightarrow> 'i::len simple_rule list \\<Rightarrow> 'i wordinterval list list\" where\n    \"groupWIs3 c rs = (if has_default_policy rs then groupWIs3_default_policy c rs else groupWIs2 c rs)\""], ["", "lemma groupWIs3: \"groupWIs3 = groupWIs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. groupWIs3 = groupWIs", "by(simp add: fun_eq_iff groupWIs3_def groupWIs_code groupWIs3_default_policy_groupWIs2)"], ["", "(*end groupWIs3 optimization*)\n\n(*construct partitions. main function!*)"], ["", "definition build_ip_partition :: \"parts_connection \\<Rightarrow> 'i::len simple_rule list \\<Rightarrow> 'i wordinterval list\" where\n  \"build_ip_partition c rs = map\n    (\\<lambda>xs. wordinterval_sort (wordinterval_compress (foldr wordinterval_union xs Empty_WordInterval)))\n      (groupWIs3 c rs)\""], ["", "theorem build_ip_partition_same_fw: \"V \\<in> set (build_ip_partition c rs) \\<Longrightarrow>\n                               \\<forall>ip1::'i::len word \\<in> wordinterval_to_set V.\n                               \\<forall>ip2::'i::len word \\<in> wordinterval_to_set V.\n                               same_fw_behaviour_one ip1 ip2 c rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<in> set (build_ip_partition c rs) \\<Longrightarrow>\n    \\<forall>ip1\\<in>wordinterval_to_set V.\n       \\<forall>ip2\\<in>wordinterval_to_set V.\n          same_fw_behaviour_one ip1 ip2 c rs", "apply(simp add: build_ip_partition_def groupWIs3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<in> (\\<lambda>xs.\n                wordinterval_sort\n                 (wordinterval_compress\n                   (foldr wordinterval_union xs Empty_WordInterval))) `\n            set (groupWIs c rs) \\<Longrightarrow>\n    \\<forall>ip1\\<in>wordinterval_to_set V.\n       \\<forall>ip2\\<in>wordinterval_to_set V.\n          same_fw_behaviour_one ip1 ip2 c rs", "using wordinterval_list_to_set_compressed groupParts_same_fw_wi2 wordinterval_sort"], ["proof (prove)\nusing this:\n  wordinterval_to_set\n   (wordinterval_compress\n     (foldr wordinterval_union ?xs Empty_WordInterval)) =\n  wordinterval_list_to_set ?xs\n  ?V \\<in> set (groupWIs ?c ?rs) \\<Longrightarrow>\n  \\<forall>ip1\\<in>wordinterval_list_to_set ?V.\n     \\<forall>ip2\\<in>wordinterval_list_to_set ?V.\n        same_fw_behaviour_one ip1 ip2 ?c ?rs\n  wordinterval_to_set (wordinterval_sort ?w) = wordinterval_to_set ?w\n\ngoal (1 subgoal):\n 1. V \\<in> (\\<lambda>xs.\n                wordinterval_sort\n                 (wordinterval_compress\n                   (foldr wordinterval_union xs Empty_WordInterval))) `\n            set (groupWIs c rs) \\<Longrightarrow>\n    \\<forall>ip1\\<in>wordinterval_to_set V.\n       \\<forall>ip2\\<in>wordinterval_to_set V.\n          same_fw_behaviour_one ip1 ip2 c rs", "by blast"], ["", "theorem build_ip_partition_same_fw_min: \"A \\<in> set (build_ip_partition c rs) \\<Longrightarrow> B \\<in> set (build_ip_partition c rs) \\<Longrightarrow> \n                                A \\<noteq> B \\<Longrightarrow>\n                                \\<forall>ip1::'i::len word \\<in> wordinterval_to_set A.\n                                \\<forall>ip2::'i::len word \\<in> wordinterval_to_set B.\n                                \\<not> same_fw_behaviour_one ip1 ip2 c rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> set (build_ip_partition c rs);\n     B \\<in> set (build_ip_partition c rs); A \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> \\<forall>ip1\\<in>wordinterval_to_set A.\n                         \\<forall>ip2\\<in>wordinterval_to_set B.\n                            \\<not> same_fw_behaviour_one ip1 ip2 c rs", "apply(simp add: build_ip_partition_def groupWIs3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> (\\<lambda>xs.\n                         wordinterval_sort\n                          (wordinterval_compress\n                            (foldr wordinterval_union xs\n                              Empty_WordInterval))) `\n                     set (groupWIs c rs);\n     B \\<in> (\\<lambda>xs.\n                 wordinterval_sort\n                  (wordinterval_compress\n                    (foldr wordinterval_union xs Empty_WordInterval))) `\n             set (groupWIs c rs);\n     A \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> \\<forall>ip1\\<in>wordinterval_to_set A.\n                         \\<forall>ip2\\<in>wordinterval_to_set B.\n                            \\<not> same_fw_behaviour_one ip1 ip2 c rs", "using  groupWIs_same_fw_not2 wordinterval_list_to_set_compressed wordinterval_sort"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<in> set (groupWIs ?c ?rs); ?B \\<in> set (groupWIs ?c ?rs);\n   ?A \\<noteq> ?B\\<rbrakk>\n  \\<Longrightarrow> \\<forall>ip1\\<in>wordinterval_list_to_set ?A.\n                       \\<forall>ip2\\<in>wordinterval_list_to_set ?B.\n                          \\<not> same_fw_behaviour_one ip1 ip2 ?c ?rs\n  wordinterval_to_set\n   (wordinterval_compress\n     (foldr wordinterval_union ?xs Empty_WordInterval)) =\n  wordinterval_list_to_set ?xs\n  wordinterval_to_set (wordinterval_sort ?w) = wordinterval_to_set ?w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<in> (\\<lambda>xs.\n                         wordinterval_sort\n                          (wordinterval_compress\n                            (foldr wordinterval_union xs\n                              Empty_WordInterval))) `\n                     set (groupWIs c rs);\n     B \\<in> (\\<lambda>xs.\n                 wordinterval_sort\n                  (wordinterval_compress\n                    (foldr wordinterval_union xs Empty_WordInterval))) `\n             set (groupWIs c rs);\n     A \\<noteq> B\\<rbrakk>\n    \\<Longrightarrow> \\<forall>ip1\\<in>wordinterval_to_set A.\n                         \\<forall>ip2\\<in>wordinterval_to_set B.\n                            \\<not> same_fw_behaviour_one ip1 ip2 c rs", "by blast"], ["", "theorem build_ip_partition_complete: \"(\\<Union>x\\<in>set (build_ip_partition c rs). wordinterval_to_set x) = (UNIV :: 'i::len word set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> (wordinterval_to_set ` set (build_ip_partition c rs)) = UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Union> (wordinterval_to_set ` set (build_ip_partition c rs)) = UNIV", "have \"wordinterval_to_set (foldr wordinterval_union x Empty_WordInterval) = \\<Union>(set (map wordinterval_to_set x))\"\n    for x::\"'i wordinterval list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wordinterval_to_set (foldr wordinterval_union x Empty_WordInterval) =\n    \\<Union> (set (map wordinterval_to_set x))", "by(induction x) simp_all"], ["proof (state)\nthis:\n  wordinterval_to_set (foldr wordinterval_union ?x Empty_WordInterval) =\n  \\<Union> (set (map wordinterval_to_set ?x))\n\ngoal (1 subgoal):\n 1. \\<Union> (wordinterval_to_set ` set (build_ip_partition c rs)) = UNIV", "thus ?thesis"], ["proof (prove)\nusing this:\n  wordinterval_to_set (foldr wordinterval_union ?x Empty_WordInterval) =\n  \\<Union> (set (map wordinterval_to_set ?x))\n\ngoal (1 subgoal):\n 1. \\<Union> (wordinterval_to_set ` set (build_ip_partition c rs)) = UNIV", "apply(simp add: build_ip_partition_def groupWIs3 wordinterval_compress wordinterval_sort)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        wordinterval_to_set\n         (foldr wordinterval_union x Empty_WordInterval) =\n        \\<Union> (wordinterval_to_set ` set x)) \\<Longrightarrow>\n    (\\<Union>x\\<in>set (groupWIs c rs).\n        \\<Union> (wordinterval_to_set ` set x)) =\n    UNIV", "using groupWIs_complete[simplified wordinterval_list_to_set_def]"], ["proof (prove)\nusing this:\n  (\\<Union>x\\<in>set (groupWIs ?c ?rs).\n      \\<Union> (set (map wordinterval_to_set x))) =\n  UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        wordinterval_to_set\n         (foldr wordinterval_union x Empty_WordInterval) =\n        \\<Union> (wordinterval_to_set ` set x)) \\<Longrightarrow>\n    (\\<Union>x\\<in>set (groupWIs c rs).\n        \\<Union> (wordinterval_to_set ` set x)) =\n    UNIV", "by simp"], ["proof (state)\nthis:\n  \\<Union> (wordinterval_to_set ` set (build_ip_partition c rs)) = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma build_ip_partition_no_empty_elems: \"wi \\<in> set (build_ip_partition c rs) \\<Longrightarrow> \\<not> wordinterval_empty wi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wi \\<in> set (build_ip_partition c rs) \\<Longrightarrow>\n    \\<not> wordinterval_empty wi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wi \\<in> set (build_ip_partition c rs) \\<Longrightarrow>\n    \\<not> wordinterval_empty wi", "assume \"wi \\<in> set (build_ip_partition c rs)\""], ["proof (state)\nthis:\n  wi \\<in> set (build_ip_partition c rs)\n\ngoal (1 subgoal):\n 1. wi \\<in> set (build_ip_partition c rs) \\<Longrightarrow>\n    \\<not> wordinterval_empty wi", "hence assm: \"wi \\<in> (\\<lambda>xs. wordinterval_sort (wordinterval_compress (foldr wordinterval_union xs Empty_WordInterval))) ` set (groupWIs c rs)\""], ["proof (prove)\nusing this:\n  wi \\<in> set (build_ip_partition c rs)\n\ngoal (1 subgoal):\n 1. wi \\<in> (\\<lambda>xs.\n                 wordinterval_sort\n                  (wordinterval_compress\n                    (foldr wordinterval_union xs Empty_WordInterval))) `\n             set (groupWIs c rs)", "by(simp add: build_ip_partition_def groupWIs3)"], ["proof (state)\nthis:\n  wi \\<in> (\\<lambda>xs.\n               wordinterval_sort\n                (wordinterval_compress\n                  (foldr wordinterval_union xs Empty_WordInterval))) `\n           set (groupWIs c rs)\n\ngoal (1 subgoal):\n 1. wi \\<in> set (build_ip_partition c rs) \\<Longrightarrow>\n    \\<not> wordinterval_empty wi", "from assm"], ["proof (chain)\npicking this:\n  wi \\<in> (\\<lambda>xs.\n               wordinterval_sort\n                (wordinterval_compress\n                  (foldr wordinterval_union xs Empty_WordInterval))) `\n           set (groupWIs c rs)", "obtain wi_orig where 1: \"wi_orig \\<in>  set (groupWIs c rs)\" and\n       2: \"wi = wordinterval_sort (wordinterval_compress (foldr wordinterval_union wi_orig Empty_WordInterval))\""], ["proof (prove)\nusing this:\n  wi \\<in> (\\<lambda>xs.\n               wordinterval_sort\n                (wordinterval_compress\n                  (foldr wordinterval_union xs Empty_WordInterval))) `\n           set (groupWIs c rs)\n\ngoal (1 subgoal):\n 1. (\\<And>wi_orig.\n        \\<lbrakk>wi_orig \\<in> set (groupWIs c rs);\n         wi =\n         wordinterval_sort\n          (wordinterval_compress\n            (foldr wordinterval_union wi_orig Empty_WordInterval))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  wi_orig \\<in> set (groupWIs c rs)\n  wi =\n  wordinterval_sort\n   (wordinterval_compress\n     (foldr wordinterval_union wi_orig Empty_WordInterval))\n\ngoal (1 subgoal):\n 1. wi \\<in> set (build_ip_partition c rs) \\<Longrightarrow>\n    \\<not> wordinterval_empty wi", "from 1 groupWIs_not_empty_elem"], ["proof (chain)\npicking this:\n  wi_orig \\<in> set (groupWIs c rs)\n  ?V \\<in> set (groupWIs ?c ?rs) \\<Longrightarrow> ?V \\<noteq> []", "have i1: \"wi_orig \\<noteq> []\""], ["proof (prove)\nusing this:\n  wi_orig \\<in> set (groupWIs c rs)\n  ?V \\<in> set (groupWIs ?c ?rs) \\<Longrightarrow> ?V \\<noteq> []\n\ngoal (1 subgoal):\n 1. wi_orig \\<noteq> []", "by blast"], ["proof (state)\nthis:\n  wi_orig \\<noteq> []\n\ngoal (1 subgoal):\n 1. wi \\<in> set (build_ip_partition c rs) \\<Longrightarrow>\n    \\<not> wordinterval_empty wi", "from 1 groupWIs_not_empty_elems"], ["proof (chain)\npicking this:\n  wi_orig \\<in> set (groupWIs c rs)\n  \\<lbrakk>?V \\<in> set (groupWIs ?c ?rs); ?w \\<in> set ?V\\<rbrakk>\n  \\<Longrightarrow> \\<not> wordinterval_empty ?w", "have i2: \"\\<And>w. w \\<in> set wi_orig \\<Longrightarrow> \\<not> wordinterval_empty w\""], ["proof (prove)\nusing this:\n  wi_orig \\<in> set (groupWIs c rs)\n  \\<lbrakk>?V \\<in> set (groupWIs ?c ?rs); ?w \\<in> set ?V\\<rbrakk>\n  \\<Longrightarrow> \\<not> wordinterval_empty ?w\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       w \\<in> set wi_orig \\<Longrightarrow> \\<not> wordinterval_empty w", "by simp"], ["proof (state)\nthis:\n  ?w \\<in> set wi_orig \\<Longrightarrow> \\<not> wordinterval_empty ?w\n\ngoal (1 subgoal):\n 1. wi \\<in> set (build_ip_partition c rs) \\<Longrightarrow>\n    \\<not> wordinterval_empty wi", "from i1 i2"], ["proof (chain)\npicking this:\n  wi_orig \\<noteq> []\n  ?w \\<in> set wi_orig \\<Longrightarrow> \\<not> wordinterval_empty ?w", "have \"wordinterval_to_set (foldr wordinterval_union wi_orig Empty_WordInterval) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  wi_orig \\<noteq> []\n  ?w \\<in> set wi_orig \\<Longrightarrow> \\<not> wordinterval_empty ?w\n\ngoal (1 subgoal):\n 1. wordinterval_to_set\n     (foldr wordinterval_union wi_orig Empty_WordInterval) \\<noteq>\n    {}", "by(induction wi_orig) simp_all"], ["proof (state)\nthis:\n  wordinterval_to_set\n   (foldr wordinterval_union wi_orig Empty_WordInterval) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. wi \\<in> set (build_ip_partition c rs) \\<Longrightarrow>\n    \\<not> wordinterval_empty wi", "with 2"], ["proof (chain)\npicking this:\n  wi =\n  wordinterval_sort\n   (wordinterval_compress\n     (foldr wordinterval_union wi_orig Empty_WordInterval))\n  wordinterval_to_set\n   (foldr wordinterval_union wi_orig Empty_WordInterval) \\<noteq>\n  {}", "show ?thesis"], ["proof (prove)\nusing this:\n  wi =\n  wordinterval_sort\n   (wordinterval_compress\n     (foldr wordinterval_union wi_orig Empty_WordInterval))\n  wordinterval_to_set\n   (foldr wordinterval_union wi_orig Empty_WordInterval) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<not> wordinterval_empty wi", "by(simp add: wordinterval_compress wordinterval_sort)"], ["proof (state)\nthis:\n  \\<not> wordinterval_empty wi\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma build_ip_partition_disjoint: \n      \"V1 \\<in> set (build_ip_partition c rs) \\<Longrightarrow> V2 \\<in> set (build_ip_partition c rs) \\<Longrightarrow>\n       V1 \\<noteq> V2 \\<Longrightarrow>\n        wordinterval_to_set V1 \\<inter> wordinterval_to_set V2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>V1 \\<in> set (build_ip_partition c rs);\n     V2 \\<in> set (build_ip_partition c rs); V1 \\<noteq> V2\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set V1 \\<inter>\n                      wordinterval_to_set V2 =\n                      {}", "by (metis build_ip_partition_same_fw build_ip_partition_same_fw_min disjoint_iff)"], ["", "lemma map_wordinterval_to_set_distinct:\n  assumes distinct: \"distinct xs\"\n  and disjoint: \"(\\<forall>x1 \\<in> set xs. \\<forall>x2 \\<in> set xs. x1 \\<noteq> x2 \\<longrightarrow> wordinterval_to_set x1 \\<inter> wordinterval_to_set x2 = {})\" \n  and notempty: \"\\<forall>x \\<in> set xs. \\<not> wordinterval_empty x\"\n  shows \"distinct (map wordinterval_to_set xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map wordinterval_to_set xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (map wordinterval_to_set xs)", "have \"\\<not> wordinterval_empty x1 \\<Longrightarrow> \n        wordinterval_to_set x1 \\<inter> wordinterval_to_set x2 = {} \\<Longrightarrow> \n        wordinterval_to_set x1 \\<noteq> wordinterval_to_set x2\" for x1::\"('b::len) wordinterval\" and x2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> wordinterval_empty x1;\n     wordinterval_to_set x1 \\<inter> wordinterval_to_set x2 = {}\\<rbrakk>\n    \\<Longrightarrow> wordinterval_to_set x1 \\<noteq> wordinterval_to_set x2", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> wordinterval_empty ?x1.1;\n   wordinterval_to_set ?x1.1 \\<inter> wordinterval_to_set ?x2.1 =\n   {}\\<rbrakk>\n  \\<Longrightarrow> wordinterval_to_set ?x1.1 \\<noteq>\n                    wordinterval_to_set ?x2.1\n\ngoal (1 subgoal):\n 1. distinct (map wordinterval_to_set xs)", "with disjoint notempty"], ["proof (chain)\npicking this:\n  \\<forall>x1\\<in>set xs.\n     \\<forall>x2\\<in>set xs.\n        x1 \\<noteq> x2 \\<longrightarrow>\n        wordinterval_to_set x1 \\<inter> wordinterval_to_set x2 = {}\n  \\<forall>x\\<in>set xs. \\<not> wordinterval_empty x\n  \\<lbrakk>\\<not> wordinterval_empty ?x1.1;\n   wordinterval_to_set ?x1.1 \\<inter> wordinterval_to_set ?x2.1 =\n   {}\\<rbrakk>\n  \\<Longrightarrow> wordinterval_to_set ?x1.1 \\<noteq>\n                    wordinterval_to_set ?x2.1", "have \"(\\<forall>x1 \\<in> set xs. \\<forall>x2 \\<in> set xs. x1 \\<noteq> x2 \\<longrightarrow> wordinterval_to_set x1 \\<noteq> wordinterval_to_set x2)\""], ["proof (prove)\nusing this:\n  \\<forall>x1\\<in>set xs.\n     \\<forall>x2\\<in>set xs.\n        x1 \\<noteq> x2 \\<longrightarrow>\n        wordinterval_to_set x1 \\<inter> wordinterval_to_set x2 = {}\n  \\<forall>x\\<in>set xs. \\<not> wordinterval_empty x\n  \\<lbrakk>\\<not> wordinterval_empty ?x1.1;\n   wordinterval_to_set ?x1.1 \\<inter> wordinterval_to_set ?x2.1 =\n   {}\\<rbrakk>\n  \\<Longrightarrow> wordinterval_to_set ?x1.1 \\<noteq>\n                    wordinterval_to_set ?x2.1\n\ngoal (1 subgoal):\n 1. \\<forall>x1\\<in>set xs.\n       \\<forall>x2\\<in>set xs.\n          x1 \\<noteq> x2 \\<longrightarrow>\n          wordinterval_to_set x1 \\<noteq> wordinterval_to_set x2", "by force"], ["proof (state)\nthis:\n  \\<forall>x1\\<in>set xs.\n     \\<forall>x2\\<in>set xs.\n        x1 \\<noteq> x2 \\<longrightarrow>\n        wordinterval_to_set x1 \\<noteq> wordinterval_to_set x2\n\ngoal (1 subgoal):\n 1. distinct (map wordinterval_to_set xs)", "with distinct"], ["proof (chain)\npicking this:\n  distinct xs\n  \\<forall>x1\\<in>set xs.\n     \\<forall>x2\\<in>set xs.\n        x1 \\<noteq> x2 \\<longrightarrow>\n        wordinterval_to_set x1 \\<noteq> wordinterval_to_set x2", "show \"distinct (map wordinterval_to_set xs)\""], ["proof (prove)\nusing this:\n  distinct xs\n  \\<forall>x1\\<in>set xs.\n     \\<forall>x2\\<in>set xs.\n        x1 \\<noteq> x2 \\<longrightarrow>\n        wordinterval_to_set x1 \\<noteq> wordinterval_to_set x2\n\ngoal (1 subgoal):\n 1. distinct (map wordinterval_to_set xs)", "proof(induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct [];\n     \\<forall>x1\\<in>set [].\n        \\<forall>x2\\<in>set [].\n           x1 \\<noteq> x2 \\<longrightarrow>\n           wordinterval_to_set x1 \\<noteq> wordinterval_to_set x2\\<rbrakk>\n    \\<Longrightarrow> distinct (map wordinterval_to_set [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct xs;\n                 \\<forall>x1\\<in>set xs.\n                    \\<forall>x2\\<in>set xs.\n                       x1 \\<noteq> x2 \\<longrightarrow>\n                       wordinterval_to_set x1 \\<noteq>\n                       wordinterval_to_set x2\\<rbrakk>\n                \\<Longrightarrow> distinct (map wordinterval_to_set xs);\n        distinct (a # xs);\n        \\<forall>x1\\<in>set (a # xs).\n           \\<forall>x2\\<in>set (a # xs).\n              x1 \\<noteq> x2 \\<longrightarrow>\n              wordinterval_to_set x1 \\<noteq>\n              wordinterval_to_set x2\\<rbrakk>\n       \\<Longrightarrow> distinct (map wordinterval_to_set (a # xs))", "case Cons"], ["proof (state)\nthis:\n  \\<lbrakk>distinct xs_;\n   \\<forall>x1\\<in>set xs_.\n      \\<forall>x2\\<in>set xs_.\n         x1 \\<noteq> x2 \\<longrightarrow>\n         wordinterval_to_set x1 \\<noteq> wordinterval_to_set x2\\<rbrakk>\n  \\<Longrightarrow> distinct (map wordinterval_to_set xs_)\n  distinct (a_ # xs_)\n  \\<forall>x1\\<in>set (a_ # xs_).\n     \\<forall>x2\\<in>set (a_ # xs_).\n        x1 \\<noteq> x2 \\<longrightarrow>\n        wordinterval_to_set x1 \\<noteq> wordinterval_to_set x2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct [];\n     \\<forall>x1\\<in>set [].\n        \\<forall>x2\\<in>set [].\n           x1 \\<noteq> x2 \\<longrightarrow>\n           wordinterval_to_set x1 \\<noteq> wordinterval_to_set x2\\<rbrakk>\n    \\<Longrightarrow> distinct (map wordinterval_to_set [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct xs;\n                 \\<forall>x1\\<in>set xs.\n                    \\<forall>x2\\<in>set xs.\n                       x1 \\<noteq> x2 \\<longrightarrow>\n                       wordinterval_to_set x1 \\<noteq>\n                       wordinterval_to_set x2\\<rbrakk>\n                \\<Longrightarrow> distinct (map wordinterval_to_set xs);\n        distinct (a # xs);\n        \\<forall>x1\\<in>set (a # xs).\n           \\<forall>x2\\<in>set (a # xs).\n              x1 \\<noteq> x2 \\<longrightarrow>\n              wordinterval_to_set x1 \\<noteq>\n              wordinterval_to_set x2\\<rbrakk>\n       \\<Longrightarrow> distinct (map wordinterval_to_set (a # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct xs_;\n   \\<forall>x1\\<in>set xs_.\n      \\<forall>x2\\<in>set xs_.\n         x1 \\<noteq> x2 \\<longrightarrow>\n         wordinterval_to_set x1 \\<noteq> wordinterval_to_set x2\\<rbrakk>\n  \\<Longrightarrow> distinct (map wordinterval_to_set xs_)\n  distinct (a_ # xs_)\n  \\<forall>x1\\<in>set (a_ # xs_).\n     \\<forall>x2\\<in>set (a_ # xs_).\n        x1 \\<noteq> x2 \\<longrightarrow>\n        wordinterval_to_set x1 \\<noteq> wordinterval_to_set x2\n\ngoal (1 subgoal):\n 1. distinct (map wordinterval_to_set (a_ # xs_))", "by simp fast"], ["proof (state)\nthis:\n  distinct (map wordinterval_to_set (a_ # xs_))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct [];\n     \\<forall>x1\\<in>set [].\n        \\<forall>x2\\<in>set [].\n           x1 \\<noteq> x2 \\<longrightarrow>\n           wordinterval_to_set x1 \\<noteq> wordinterval_to_set x2\\<rbrakk>\n    \\<Longrightarrow> distinct (map wordinterval_to_set [])", "qed(simp)"], ["proof (state)\nthis:\n  distinct (map wordinterval_to_set xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_getOneIp_distinct: assumes\n  distinct: \"distinct xs\"\n  and disjoint: \"(\\<forall>x1 \\<in> set xs. \\<forall>x2 \\<in> set xs. x1 \\<noteq> x2 \\<longrightarrow> wordinterval_to_set x1 \\<inter> wordinterval_to_set x2 = {})\" \n  and notempty: \"\\<forall>x \\<in> set xs. \\<not> wordinterval_empty x\"\n  shows \"distinct (map getOneIp xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map getOneIp xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (map getOneIp xs)", "have \"\\<not> wordinterval_empty x \\<Longrightarrow> \\<not> wordinterval_empty xa \\<Longrightarrow> \n          wordinterval_to_set x \\<inter> wordinterval_to_set xa = {} \\<Longrightarrow> getOneIp x \\<noteq> getOneIp xa\"\n     for x xa::\"'b::len wordinterval\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> wordinterval_empty x; \\<not> wordinterval_empty xa;\n     wordinterval_to_set x \\<inter> wordinterval_to_set xa = {}\\<rbrakk>\n    \\<Longrightarrow> getOneIp x \\<noteq> getOneIp xa", "by(fastforce dest: getOneIp_elem)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> wordinterval_empty ?x1; \\<not> wordinterval_empty ?xa1;\n   wordinterval_to_set ?x1 \\<inter> wordinterval_to_set ?xa1 = {}\\<rbrakk>\n  \\<Longrightarrow> getOneIp ?x1 \\<noteq> getOneIp ?xa1\n\ngoal (1 subgoal):\n 1. distinct (map getOneIp xs)", "with disjoint notempty"], ["proof (chain)\npicking this:\n  \\<forall>x1\\<in>set xs.\n     \\<forall>x2\\<in>set xs.\n        x1 \\<noteq> x2 \\<longrightarrow>\n        wordinterval_to_set x1 \\<inter> wordinterval_to_set x2 = {}\n  \\<forall>x\\<in>set xs. \\<not> wordinterval_empty x\n  \\<lbrakk>\\<not> wordinterval_empty ?x1; \\<not> wordinterval_empty ?xa1;\n   wordinterval_to_set ?x1 \\<inter> wordinterval_to_set ?xa1 = {}\\<rbrakk>\n  \\<Longrightarrow> getOneIp ?x1 \\<noteq> getOneIp ?xa1", "have \"(\\<forall>x1 \\<in> set xs. \\<forall>x2 \\<in> set xs. x1 \\<noteq> x2 \\<longrightarrow> getOneIp x1 \\<noteq> getOneIp x2)\""], ["proof (prove)\nusing this:\n  \\<forall>x1\\<in>set xs.\n     \\<forall>x2\\<in>set xs.\n        x1 \\<noteq> x2 \\<longrightarrow>\n        wordinterval_to_set x1 \\<inter> wordinterval_to_set x2 = {}\n  \\<forall>x\\<in>set xs. \\<not> wordinterval_empty x\n  \\<lbrakk>\\<not> wordinterval_empty ?x1; \\<not> wordinterval_empty ?xa1;\n   wordinterval_to_set ?x1 \\<inter> wordinterval_to_set ?xa1 = {}\\<rbrakk>\n  \\<Longrightarrow> getOneIp ?x1 \\<noteq> getOneIp ?xa1\n\ngoal (1 subgoal):\n 1. \\<forall>x1\\<in>set xs.\n       \\<forall>x2\\<in>set xs.\n          x1 \\<noteq> x2 \\<longrightarrow> getOneIp x1 \\<noteq> getOneIp x2", "by metis"], ["proof (state)\nthis:\n  \\<forall>x1\\<in>set xs.\n     \\<forall>x2\\<in>set xs.\n        x1 \\<noteq> x2 \\<longrightarrow> getOneIp x1 \\<noteq> getOneIp x2\n\ngoal (1 subgoal):\n 1. distinct (map getOneIp xs)", "with distinct"], ["proof (chain)\npicking this:\n  distinct xs\n  \\<forall>x1\\<in>set xs.\n     \\<forall>x2\\<in>set xs.\n        x1 \\<noteq> x2 \\<longrightarrow> getOneIp x1 \\<noteq> getOneIp x2", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct xs\n  \\<forall>x1\\<in>set xs.\n     \\<forall>x2\\<in>set xs.\n        x1 \\<noteq> x2 \\<longrightarrow> getOneIp x1 \\<noteq> getOneIp x2\n\ngoal (1 subgoal):\n 1. distinct (map getOneIp xs)", "proof(induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct [];\n     \\<forall>x1\\<in>set [].\n        \\<forall>x2\\<in>set [].\n           x1 \\<noteq> x2 \\<longrightarrow>\n           getOneIp x1 \\<noteq> getOneIp x2\\<rbrakk>\n    \\<Longrightarrow> distinct (map getOneIp [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct xs;\n                 \\<forall>x1\\<in>set xs.\n                    \\<forall>x2\\<in>set xs.\n                       x1 \\<noteq> x2 \\<longrightarrow>\n                       getOneIp x1 \\<noteq> getOneIp x2\\<rbrakk>\n                \\<Longrightarrow> distinct (map getOneIp xs);\n        distinct (a # xs);\n        \\<forall>x1\\<in>set (a # xs).\n           \\<forall>x2\\<in>set (a # xs).\n              x1 \\<noteq> x2 \\<longrightarrow>\n              getOneIp x1 \\<noteq> getOneIp x2\\<rbrakk>\n       \\<Longrightarrow> distinct (map getOneIp (a # xs))", "case Cons"], ["proof (state)\nthis:\n  \\<lbrakk>distinct xs_;\n   \\<forall>x1\\<in>set xs_.\n      \\<forall>x2\\<in>set xs_.\n         x1 \\<noteq> x2 \\<longrightarrow>\n         getOneIp x1 \\<noteq> getOneIp x2\\<rbrakk>\n  \\<Longrightarrow> distinct (map getOneIp xs_)\n  distinct (a_ # xs_)\n  \\<forall>x1\\<in>set (a_ # xs_).\n     \\<forall>x2\\<in>set (a_ # xs_).\n        x1 \\<noteq> x2 \\<longrightarrow> getOneIp x1 \\<noteq> getOneIp x2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>distinct [];\n     \\<forall>x1\\<in>set [].\n        \\<forall>x2\\<in>set [].\n           x1 \\<noteq> x2 \\<longrightarrow>\n           getOneIp x1 \\<noteq> getOneIp x2\\<rbrakk>\n    \\<Longrightarrow> distinct (map getOneIp [])\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>distinct xs;\n                 \\<forall>x1\\<in>set xs.\n                    \\<forall>x2\\<in>set xs.\n                       x1 \\<noteq> x2 \\<longrightarrow>\n                       getOneIp x1 \\<noteq> getOneIp x2\\<rbrakk>\n                \\<Longrightarrow> distinct (map getOneIp xs);\n        distinct (a # xs);\n        \\<forall>x1\\<in>set (a # xs).\n           \\<forall>x2\\<in>set (a # xs).\n              x1 \\<noteq> x2 \\<longrightarrow>\n              getOneIp x1 \\<noteq> getOneIp x2\\<rbrakk>\n       \\<Longrightarrow> distinct (map getOneIp (a # xs))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>distinct xs_;\n   \\<forall>x1\\<in>set xs_.\n      \\<forall>x2\\<in>set xs_.\n         x1 \\<noteq> x2 \\<longrightarrow>\n         getOneIp x1 \\<noteq> getOneIp x2\\<rbrakk>\n  \\<Longrightarrow> distinct (map getOneIp xs_)\n  distinct (a_ # xs_)\n  \\<forall>x1\\<in>set (a_ # xs_).\n     \\<forall>x2\\<in>set (a_ # xs_).\n        x1 \\<noteq> x2 \\<longrightarrow> getOneIp x1 \\<noteq> getOneIp x2\n\ngoal (1 subgoal):\n 1. distinct (map getOneIp (a_ # xs_))", "by simp fast"], ["proof (state)\nthis:\n  distinct (map getOneIp (a_ # xs_))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>distinct [];\n     \\<forall>x1\\<in>set [].\n        \\<forall>x2\\<in>set [].\n           x1 \\<noteq> x2 \\<longrightarrow>\n           getOneIp x1 \\<noteq> getOneIp x2\\<rbrakk>\n    \\<Longrightarrow> distinct (map getOneIp [])", "qed(simp)"], ["proof (state)\nthis:\n  distinct (map getOneIp xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma getParts_disjoint_list: \"disjoint_list (map wordinterval_to_set (getParts rs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. disjoint_list (map wordinterval_to_set (getParts rs))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. disjoint_list (map wordinterval_to_set (getParts rs))", "have disjoint_list_partitioningIps: \n    \"{} \\<notin> set (map wordinterval_to_set ts) \\<Longrightarrow> disjoint_list (map wordinterval_to_set ts) \\<Longrightarrow> \n     (wordinterval_list_to_set ss) \\<subseteq> (wordinterval_list_to_set ts) \\<Longrightarrow>\n     disjoint_list (map wordinterval_to_set (partitioningIps ss ts))\"\n     for ts::\"'a::len wordinterval list\" and ss"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{} \\<notin> set (map wordinterval_to_set ts);\n     disjoint_list (map wordinterval_to_set ts);\n     wordinterval_list_to_set ss\n     \\<subseteq> wordinterval_list_to_set ts\\<rbrakk>\n    \\<Longrightarrow> disjoint_list\n                       (map wordinterval_to_set (partitioningIps ss ts))", "by (simp add: partitioning1_disjoint_list partitioningIps_equi wordinterval_list_to_set_def)"], ["proof (state)\nthis:\n  \\<lbrakk>{} \\<notin> set (map wordinterval_to_set ?ts);\n   disjoint_list (map wordinterval_to_set ?ts);\n   wordinterval_list_to_set ?ss\n   \\<subseteq> wordinterval_list_to_set ?ts\\<rbrakk>\n  \\<Longrightarrow> disjoint_list\n                     (map wordinterval_to_set (partitioningIps ?ss ?ts))\n\ngoal (1 subgoal):\n 1. disjoint_list (map wordinterval_to_set (getParts rs))", "have \"{} \\<notin> set (map wordinterval_to_set [wordinterval_UNIV])\"\n  and \"disjoint_list (map wordinterval_to_set [wordinterval_UNIV])\"\n  and \"wordinterval_list_to_set (extract_IPSets rs) \\<subseteq> wordinterval_list_to_set [wordinterval_UNIV]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<notin> set (map wordinterval_to_set [wordinterval_UNIV]) &&&\n    disjoint_list (map wordinterval_to_set [wordinterval_UNIV]) &&&\n    wordinterval_list_to_set (extract_IPSets rs)\n    \\<subseteq> wordinterval_list_to_set [wordinterval_UNIV]", "by(simp add: wordinterval_list_to_set_def disjoint_list_def disjoint_def)+"], ["proof (state)\nthis:\n  {} \\<notin> set (map wordinterval_to_set [wordinterval_UNIV])\n  disjoint_list (map wordinterval_to_set [wordinterval_UNIV])\n  wordinterval_list_to_set (extract_IPSets rs)\n  \\<subseteq> wordinterval_list_to_set [wordinterval_UNIV]\n\ngoal (1 subgoal):\n 1. disjoint_list (map wordinterval_to_set (getParts rs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  {} \\<notin> set (map wordinterval_to_set [wordinterval_UNIV])\n  disjoint_list (map wordinterval_to_set [wordinterval_UNIV])\n  wordinterval_list_to_set (extract_IPSets rs)\n  \\<subseteq> wordinterval_list_to_set [wordinterval_UNIV]\n\ngoal (1 subgoal):\n 1. disjoint_list (map wordinterval_to_set (getParts rs))", "unfolding getParts_def"], ["proof (prove)\nusing this:\n  {} \\<notin> set (map wordinterval_to_set [wordinterval_UNIV])\n  disjoint_list (map wordinterval_to_set [wordinterval_UNIV])\n  wordinterval_list_to_set (extract_IPSets rs)\n  \\<subseteq> wordinterval_list_to_set [wordinterval_UNIV]\n\ngoal (1 subgoal):\n 1. disjoint_list\n     (map wordinterval_to_set\n       (partitioningIps (extract_IPSets rs) [wordinterval_UNIV]))", "by(rule disjoint_list_partitioningIps)"], ["proof (state)\nthis:\n  disjoint_list (map wordinterval_to_set (getParts rs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma build_ip_partition_distinct: \"distinct (map wordinterval_to_set (build_ip_partition c rs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map wordinterval_to_set (build_ip_partition c rs))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (map wordinterval_to_set (build_ip_partition c rs))", "have  \n  \"(wordinterval_to_set \\<circ> (\\<lambda>xs. wordinterval_sort (wordinterval_compress (foldr wordinterval_union xs Empty_WordInterval)))) ws\n       = \\<Union>(set (map wordinterval_to_set ws))\" for ws::\"'a::len wordinterval list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (wordinterval_to_set \\<circ>\n     (\\<lambda>xs.\n         wordinterval_sort\n          (wordinterval_compress\n            (foldr wordinterval_union xs Empty_WordInterval))))\n     ws =\n    \\<Union> (set (map wordinterval_to_set ws))", "proof(induction ws)"], ["proof (state)\ngoal (2 subgoals):\n 1. (wordinterval_to_set \\<circ>\n     (\\<lambda>xs.\n         wordinterval_sort\n          (wordinterval_compress\n            (foldr wordinterval_union xs Empty_WordInterval))))\n     [] =\n    \\<Union> (set (map wordinterval_to_set []))\n 2. \\<And>a ws.\n       (wordinterval_to_set \\<circ>\n        (\\<lambda>xs.\n            wordinterval_sort\n             (wordinterval_compress\n               (foldr wordinterval_union xs Empty_WordInterval))))\n        ws =\n       \\<Union> (set (map wordinterval_to_set ws)) \\<Longrightarrow>\n       (wordinterval_to_set \\<circ>\n        (\\<lambda>xs.\n            wordinterval_sort\n             (wordinterval_compress\n               (foldr wordinterval_union xs Empty_WordInterval))))\n        (a # ws) =\n       \\<Union> (set (map wordinterval_to_set (a # ws)))", "qed(simp_all add: wordinterval_compress wordinterval_sort)"], ["proof (state)\nthis:\n  (wordinterval_to_set \\<circ>\n   (\\<lambda>xs.\n       wordinterval_sort\n        (wordinterval_compress\n          (foldr wordinterval_union xs Empty_WordInterval))))\n   ?ws =\n  \\<Union> (set (map wordinterval_to_set ?ws))\n\ngoal (1 subgoal):\n 1. distinct (map wordinterval_to_set (build_ip_partition c rs))", "hence hlp1: \"map wordinterval_to_set (build_ip_partition c rs) =\n                   map (\\<lambda>x. \\<Union>(set (map wordinterval_to_set x))) (groupWIs c rs)\""], ["proof (prove)\nusing this:\n  (wordinterval_to_set \\<circ>\n   (\\<lambda>xs.\n       wordinterval_sort\n        (wordinterval_compress\n          (foldr wordinterval_union xs Empty_WordInterval))))\n   ?ws =\n  \\<Union> (set (map wordinterval_to_set ?ws))\n\ngoal (1 subgoal):\n 1. map wordinterval_to_set (build_ip_partition c rs) =\n    map (\\<lambda>x. \\<Union> (set (map wordinterval_to_set x)))\n     (groupWIs c rs)", "unfolding build_ip_partition_def groupWIs3"], ["proof (prove)\nusing this:\n  (wordinterval_to_set \\<circ>\n   (\\<lambda>xs.\n       wordinterval_sort\n        (wordinterval_compress\n          (foldr wordinterval_union xs Empty_WordInterval))))\n   ?ws =\n  \\<Union> (set (map wordinterval_to_set ?ws))\n\ngoal (1 subgoal):\n 1. map wordinterval_to_set\n     (map (\\<lambda>xs.\n              wordinterval_sort\n               (wordinterval_compress\n                 (foldr wordinterval_union xs Empty_WordInterval)))\n       (groupWIs c rs)) =\n    map (\\<lambda>x. \\<Union> (set (map wordinterval_to_set x)))\n     (groupWIs c rs)", "by auto\n\n  \\<comment> \\<open>generic rule\\<close>"], ["proof (state)\nthis:\n  map wordinterval_to_set (build_ip_partition c rs) =\n  map (\\<lambda>x. \\<Union> (set (map wordinterval_to_set x)))\n   (groupWIs c rs)\n\ngoal (1 subgoal):\n 1. distinct (map wordinterval_to_set (build_ip_partition c rs))", "have \"\\<forall>x \\<in> set xs. \\<not> wordinterval_empty x \\<Longrightarrow>\n         disjoint_list (map wordinterval_to_set xs) \\<Longrightarrow>\n         distinct (map (\\<lambda>x. \\<Union>(set (map wordinterval_to_set x))) (groupF f xs))\"\n         for f::\"'x::len wordinterval \\<Rightarrow> 'y\" and xs::\"'x::len wordinterval list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>set xs. \\<not> wordinterval_empty x;\n     disjoint_list (map wordinterval_to_set xs)\\<rbrakk>\n    \\<Longrightarrow> distinct\n                       (map (\\<lambda>x.\n                                \\<Union> (set (map wordinterval_to_set x)))\n                         (groupF f xs))", "proof(induction f xs rule: groupF.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<forall>x\\<in>set []. \\<not> wordinterval_empty x;\n        disjoint_list (map wordinterval_to_set [])\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>x.\n                                   \\<Union>\n                                    (set (map wordinterval_to_set x)))\n                            (groupF f []))\n 2. \\<And>f x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set\n   (filter (\\<lambda>y. f x \\<noteq> f y) xs).\n                            \\<not> wordinterval_empty x;\n                 disjoint_list\n                  (map wordinterval_to_set\n                    (filter (\\<lambda>y. f x \\<noteq> f y) xs))\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map (\\<lambda>x.\n      \\<Union> (set (map wordinterval_to_set x)))\n                                     (groupF f\n (filter (\\<lambda>y. f x \\<noteq> f y) xs)));\n        \\<forall>x\\<in>set (x # xs). \\<not> wordinterval_empty x;\n        disjoint_list (map wordinterval_to_set (x # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>x.\n                                   \\<Union>\n                                    (set (map wordinterval_to_set x)))\n                            (groupF f (x # xs)))", "case 1"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set []. \\<not> wordinterval_empty x\n  disjoint_list (map wordinterval_to_set [])\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<forall>x\\<in>set []. \\<not> wordinterval_empty x;\n        disjoint_list (map wordinterval_to_set [])\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>x.\n                                   \\<Union>\n                                    (set (map wordinterval_to_set x)))\n                            (groupF f []))\n 2. \\<And>f x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set\n   (filter (\\<lambda>y. f x \\<noteq> f y) xs).\n                            \\<not> wordinterval_empty x;\n                 disjoint_list\n                  (map wordinterval_to_set\n                    (filter (\\<lambda>y. f x \\<noteq> f y) xs))\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map (\\<lambda>x.\n      \\<Union> (set (map wordinterval_to_set x)))\n                                     (groupF f\n (filter (\\<lambda>y. f x \\<noteq> f y) xs)));\n        \\<forall>x\\<in>set (x # xs). \\<not> wordinterval_empty x;\n        disjoint_list (map wordinterval_to_set (x # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>x.\n                                   \\<Union>\n                                    (set (map wordinterval_to_set x)))\n                            (groupF f (x # xs)))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set []. \\<not> wordinterval_empty x\n  disjoint_list (map wordinterval_to_set [])\n\ngoal (1 subgoal):\n 1. distinct\n     (map (\\<lambda>x. \\<Union> (set (map wordinterval_to_set x)))\n       (groupF f_ []))", "by simp"], ["proof (state)\nthis:\n  distinct\n   (map (\\<lambda>x. \\<Union> (set (map wordinterval_to_set x)))\n     (groupF f_ []))\n\ngoal (1 subgoal):\n 1. \\<And>f x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set\n   (filter (\\<lambda>y. f x \\<noteq> f y) xs).\n                            \\<not> wordinterval_empty x;\n                 disjoint_list\n                  (map wordinterval_to_set\n                    (filter (\\<lambda>y. f x \\<noteq> f y) xs))\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map (\\<lambda>x.\n      \\<Union> (set (map wordinterval_to_set x)))\n                                     (groupF f\n (filter (\\<lambda>y. f x \\<noteq> f y) xs)));\n        \\<forall>x\\<in>set (x # xs). \\<not> wordinterval_empty x;\n        disjoint_list (map wordinterval_to_set (x # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>x.\n                                   \\<Union>\n                                    (set (map wordinterval_to_set x)))\n                            (groupF f (x # xs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set\n   (filter (\\<lambda>y. f x \\<noteq> f y) xs).\n                            \\<not> wordinterval_empty x;\n                 disjoint_list\n                  (map wordinterval_to_set\n                    (filter (\\<lambda>y. f x \\<noteq> f y) xs))\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map (\\<lambda>x.\n      \\<Union> (set (map wordinterval_to_set x)))\n                                     (groupF f\n (filter (\\<lambda>y. f x \\<noteq> f y) xs)));\n        \\<forall>x\\<in>set (x # xs). \\<not> wordinterval_empty x;\n        disjoint_list (map wordinterval_to_set (x # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>x.\n                                   \\<Union>\n                                    (set (map wordinterval_to_set x)))\n                            (groupF f (x # xs)))", "case (2 f x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x\\<in>set (filter (\\<lambda>y. f x \\<noteq> f y) xs).\n              \\<not> wordinterval_empty x;\n   disjoint_list\n    (map wordinterval_to_set\n      (filter (\\<lambda>y. f x \\<noteq> f y) xs))\\<rbrakk>\n  \\<Longrightarrow> distinct\n                     (map (\\<lambda>x.\n                              \\<Union> (set (map wordinterval_to_set x)))\n                       (groupF f\n                         (filter (\\<lambda>y. f x \\<noteq> f y) xs)))\n  \\<forall>x\\<in>set (x # xs). \\<not> wordinterval_empty x\n  disjoint_list (map wordinterval_to_set (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>f x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set\n   (filter (\\<lambda>y. f x \\<noteq> f y) xs).\n                            \\<not> wordinterval_empty x;\n                 disjoint_list\n                  (map wordinterval_to_set\n                    (filter (\\<lambda>y. f x \\<noteq> f y) xs))\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map (\\<lambda>x.\n      \\<Union> (set (map wordinterval_to_set x)))\n                                     (groupF f\n (filter (\\<lambda>y. f x \\<noteq> f y) xs)));\n        \\<forall>x\\<in>set (x # xs). \\<not> wordinterval_empty x;\n        disjoint_list (map wordinterval_to_set (x # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>x.\n                                   \\<Union>\n                                    (set (map wordinterval_to_set x)))\n                            (groupF f (x # xs)))", "have hlp_internal:\n          \"\\<Union> (set (map (\\<lambda>x. \\<Union>(set (map wordinterval_to_set x))) (groupF f xs))) =\n           \\<Union> (set (map wordinterval_to_set xs))\" for f::\"'x wordinterval \\<Rightarrow> 'y\" and xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union>\n     (set (map (\\<lambda>x. \\<Union> (set (map wordinterval_to_set x)))\n            (groupF f xs))) =\n    \\<Union> (set (map wordinterval_to_set xs))", "by(induction f xs rule: groupF.induct) (auto)"], ["proof (state)\nthis:\n  \\<Union>\n   (set (map (\\<lambda>x. \\<Union> (set (map wordinterval_to_set x)))\n          (groupF ?f ?xs))) =\n  \\<Union> (set (map wordinterval_to_set ?xs))\n\ngoal (1 subgoal):\n 1. \\<And>f x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set\n   (filter (\\<lambda>y. f x \\<noteq> f y) xs).\n                            \\<not> wordinterval_empty x;\n                 disjoint_list\n                  (map wordinterval_to_set\n                    (filter (\\<lambda>y. f x \\<noteq> f y) xs))\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map (\\<lambda>x.\n      \\<Union> (set (map wordinterval_to_set x)))\n                                     (groupF f\n (filter (\\<lambda>y. f x \\<noteq> f y) xs)));\n        \\<forall>x\\<in>set (x # xs). \\<not> wordinterval_empty x;\n        disjoint_list (map wordinterval_to_set (x # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>x.\n                                   \\<Union>\n                                    (set (map wordinterval_to_set x)))\n                            (groupF f (x # xs)))", "from 2(2,3)"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>set (x # xs). \\<not> wordinterval_empty x\n  disjoint_list (map wordinterval_to_set (x # xs))", "have \"wordinterval_to_set x \\<inter> \\<Union>(wordinterval_to_set ` set xs) = {}\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>set (x # xs). \\<not> wordinterval_empty x\n  disjoint_list (map wordinterval_to_set (x # xs))\n\ngoal (1 subgoal):\n 1. wordinterval_to_set x \\<inter> \\<Union> (wordinterval_to_set ` set xs) =\n    {}", "by(auto simp add: disjoint_def disjoint_list_def)"], ["proof (state)\nthis:\n  wordinterval_to_set x \\<inter> \\<Union> (wordinterval_to_set ` set xs) =\n  {}\n\ngoal (1 subgoal):\n 1. \\<And>f x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set\n   (filter (\\<lambda>y. f x \\<noteq> f y) xs).\n                            \\<not> wordinterval_empty x;\n                 disjoint_list\n                  (map wordinterval_to_set\n                    (filter (\\<lambda>y. f x \\<noteq> f y) xs))\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map (\\<lambda>x.\n      \\<Union> (set (map wordinterval_to_set x)))\n                                     (groupF f\n (filter (\\<lambda>y. f x \\<noteq> f y) xs)));\n        \\<forall>x\\<in>set (x # xs). \\<not> wordinterval_empty x;\n        disjoint_list (map wordinterval_to_set (x # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>x.\n                                   \\<Union>\n                                    (set (map wordinterval_to_set x)))\n                            (groupF f (x # xs)))", "hence \"\\<not> (wordinterval_to_set x) \\<subseteq> \\<Union>(wordinterval_to_set ` set xs)\""], ["proof (prove)\nusing this:\n  wordinterval_to_set x \\<inter> \\<Union> (wordinterval_to_set ` set xs) =\n  {}\n\ngoal (1 subgoal):\n 1. \\<not> wordinterval_to_set x\n           \\<subseteq> \\<Union> (wordinterval_to_set ` set xs)", "using 2(2)"], ["proof (prove)\nusing this:\n  wordinterval_to_set x \\<inter> \\<Union> (wordinterval_to_set ` set xs) =\n  {}\n  \\<forall>x\\<in>set (x # xs). \\<not> wordinterval_empty x\n\ngoal (1 subgoal):\n 1. \\<not> wordinterval_to_set x\n           \\<subseteq> \\<Union> (wordinterval_to_set ` set xs)", "by auto"], ["proof (state)\nthis:\n  \\<not> wordinterval_to_set x\n         \\<subseteq> \\<Union> (wordinterval_to_set ` set xs)\n\ngoal (1 subgoal):\n 1. \\<And>f x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set\n   (filter (\\<lambda>y. f x \\<noteq> f y) xs).\n                            \\<not> wordinterval_empty x;\n                 disjoint_list\n                  (map wordinterval_to_set\n                    (filter (\\<lambda>y. f x \\<noteq> f y) xs))\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map (\\<lambda>x.\n      \\<Union> (set (map wordinterval_to_set x)))\n                                     (groupF f\n (filter (\\<lambda>y. f x \\<noteq> f y) xs)));\n        \\<forall>x\\<in>set (x # xs). \\<not> wordinterval_empty x;\n        disjoint_list (map wordinterval_to_set (x # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>x.\n                                   \\<Union>\n                                    (set (map wordinterval_to_set x)))\n                            (groupF f (x # xs)))", "hence \"\\<not> wordinterval_to_set x \\<subseteq> \\<Union>(set (map wordinterval_to_set [y\\<leftarrow>xs . f x \\<noteq> f y]))\""], ["proof (prove)\nusing this:\n  \\<not> wordinterval_to_set x\n         \\<subseteq> \\<Union> (wordinterval_to_set ` set xs)\n\ngoal (1 subgoal):\n 1. \\<not> wordinterval_to_set x\n           \\<subseteq> \\<Union>\n                        (set (map wordinterval_to_set\n                               (filter (\\<lambda>y. f x \\<noteq> f y) xs)))", "by auto"], ["proof (state)\nthis:\n  \\<not> wordinterval_to_set x\n         \\<subseteq> \\<Union>\n                      (set (map wordinterval_to_set\n                             (filter (\\<lambda>y. f x \\<noteq> f y) xs)))\n\ngoal (1 subgoal):\n 1. \\<And>f x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set\n   (filter (\\<lambda>y. f x \\<noteq> f y) xs).\n                            \\<not> wordinterval_empty x;\n                 disjoint_list\n                  (map wordinterval_to_set\n                    (filter (\\<lambda>y. f x \\<noteq> f y) xs))\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map (\\<lambda>x.\n      \\<Union> (set (map wordinterval_to_set x)))\n                                     (groupF f\n (filter (\\<lambda>y. f x \\<noteq> f y) xs)));\n        \\<forall>x\\<in>set (x # xs). \\<not> wordinterval_empty x;\n        disjoint_list (map wordinterval_to_set (x # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>x.\n                                   \\<Union>\n                                    (set (map wordinterval_to_set x)))\n                            (groupF f (x # xs)))", "hence \"\\<not> wordinterval_to_set x \\<union> (\\<Union>x\\<in>{xa \\<in> set xs. f x = f xa}.\n         wordinterval_to_set x) \\<subseteq> \\<Union> (set (map (\\<lambda>x. \\<Union>(set (map wordinterval_to_set x))) (groupF f [y\\<leftarrow>xs . f x \\<noteq> f y])))\""], ["proof (prove)\nusing this:\n  \\<not> wordinterval_to_set x\n         \\<subseteq> \\<Union>\n                      (set (map wordinterval_to_set\n                             (filter (\\<lambda>y. f x \\<noteq> f y) xs)))\n\ngoal (1 subgoal):\n 1. \\<not> wordinterval_to_set x \\<union>\n           \\<Union> (wordinterval_to_set ` {xa \\<in> set xs. f x = f xa})\n           \\<subseteq> \\<Union>\n                        (set (map (\\<lambda>x.\n\\<Union> (set (map wordinterval_to_set x)))\n                               (groupF f\n                                 (filter (\\<lambda>y. f x \\<noteq> f y)\n                                   xs))))", "unfolding hlp_internal"], ["proof (prove)\nusing this:\n  \\<not> wordinterval_to_set x\n         \\<subseteq> \\<Union>\n                      (set (map wordinterval_to_set\n                             (filter (\\<lambda>y. f x \\<noteq> f y) xs)))\n\ngoal (1 subgoal):\n 1. \\<not> wordinterval_to_set x \\<union>\n           \\<Union> (wordinterval_to_set ` {xa \\<in> set xs. f x = f xa})\n           \\<subseteq> \\<Union>\n                        (set (map wordinterval_to_set\n                               (filter (\\<lambda>y. f x \\<noteq> f y) xs)))", "by blast"], ["proof (state)\nthis:\n  \\<not> wordinterval_to_set x \\<union>\n         \\<Union> (wordinterval_to_set ` {xa \\<in> set xs. f x = f xa})\n         \\<subseteq> \\<Union>\n                      (set (map (\\<lambda>x.\n                                    \\<Union>\n                                     (set (map wordinterval_to_set x)))\n                             (groupF f\n                               (filter (\\<lambda>y. f x \\<noteq> f y) xs))))\n\ngoal (1 subgoal):\n 1. \\<And>f x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set\n   (filter (\\<lambda>y. f x \\<noteq> f y) xs).\n                            \\<not> wordinterval_empty x;\n                 disjoint_list\n                  (map wordinterval_to_set\n                    (filter (\\<lambda>y. f x \\<noteq> f y) xs))\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map (\\<lambda>x.\n      \\<Union> (set (map wordinterval_to_set x)))\n                                     (groupF f\n (filter (\\<lambda>y. f x \\<noteq> f y) xs)));\n        \\<forall>x\\<in>set (x # xs). \\<not> wordinterval_empty x;\n        disjoint_list (map wordinterval_to_set (x # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>x.\n                                   \\<Union>\n                                    (set (map wordinterval_to_set x)))\n                            (groupF f (x # xs)))", "hence g1: \"wordinterval_to_set x \\<union> (\\<Union>x\\<in>{xa \\<in> set xs. f x = f xa}. wordinterval_to_set x)\n        \\<notin> (\\<lambda>x. \\<Union>x\\<in>set x. wordinterval_to_set x) ` set (groupF f [y\\<leftarrow>xs . f x \\<noteq> f y])\""], ["proof (prove)\nusing this:\n  \\<not> wordinterval_to_set x \\<union>\n         \\<Union> (wordinterval_to_set ` {xa \\<in> set xs. f x = f xa})\n         \\<subseteq> \\<Union>\n                      (set (map (\\<lambda>x.\n                                    \\<Union>\n                                     (set (map wordinterval_to_set x)))\n                             (groupF f\n                               (filter (\\<lambda>y. f x \\<noteq> f y) xs))))\n\ngoal (1 subgoal):\n 1. wordinterval_to_set x \\<union>\n    \\<Union> (wordinterval_to_set ` {xa \\<in> set xs. f x = f xa})\n    \\<notin> (\\<lambda>x. \\<Union> (wordinterval_to_set ` set x)) `\n             set (groupF f (filter (\\<lambda>y. f x \\<noteq> f y) xs))", "by force"], ["proof (state)\nthis:\n  wordinterval_to_set x \\<union>\n  \\<Union> (wordinterval_to_set ` {xa \\<in> set xs. f x = f xa})\n  \\<notin> (\\<lambda>x. \\<Union> (wordinterval_to_set ` set x)) `\n           set (groupF f (filter (\\<lambda>y. f x \\<noteq> f y) xs))\n\ngoal (1 subgoal):\n 1. \\<And>f x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set\n   (filter (\\<lambda>y. f x \\<noteq> f y) xs).\n                            \\<not> wordinterval_empty x;\n                 disjoint_list\n                  (map wordinterval_to_set\n                    (filter (\\<lambda>y. f x \\<noteq> f y) xs))\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map (\\<lambda>x.\n      \\<Union> (set (map wordinterval_to_set x)))\n                                     (groupF f\n (filter (\\<lambda>y. f x \\<noteq> f y) xs)));\n        \\<forall>x\\<in>set (x # xs). \\<not> wordinterval_empty x;\n        disjoint_list (map wordinterval_to_set (x # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>x.\n                                   \\<Union>\n                                    (set (map wordinterval_to_set x)))\n                            (groupF f (x # xs)))", "from 2(3)"], ["proof (chain)\npicking this:\n  disjoint_list (map wordinterval_to_set (x # xs))", "have \"distinct (map wordinterval_to_set [y\\<leftarrow>xs . f x \\<noteq> f y])\""], ["proof (prove)\nusing this:\n  disjoint_list (map wordinterval_to_set (x # xs))\n\ngoal (1 subgoal):\n 1. distinct\n     (map wordinterval_to_set (filter (\\<lambda>y. f x \\<noteq> f y) xs))", "by (simp add: disjoint_list_def  distinct_map_filter)"], ["proof (state)\nthis:\n  distinct\n   (map wordinterval_to_set (filter (\\<lambda>y. f x \\<noteq> f y) xs))\n\ngoal (1 subgoal):\n 1. \\<And>f x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set\n   (filter (\\<lambda>y. f x \\<noteq> f y) xs).\n                            \\<not> wordinterval_empty x;\n                 disjoint_list\n                  (map wordinterval_to_set\n                    (filter (\\<lambda>y. f x \\<noteq> f y) xs))\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map (\\<lambda>x.\n      \\<Union> (set (map wordinterval_to_set x)))\n                                     (groupF f\n (filter (\\<lambda>y. f x \\<noteq> f y) xs)));\n        \\<forall>x\\<in>set (x # xs). \\<not> wordinterval_empty x;\n        disjoint_list (map wordinterval_to_set (x # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>x.\n                                   \\<Union>\n                                    (set (map wordinterval_to_set x)))\n                            (groupF f (x # xs)))", "moreover"], ["proof (state)\nthis:\n  distinct\n   (map wordinterval_to_set (filter (\\<lambda>y. f x \\<noteq> f y) xs))\n\ngoal (1 subgoal):\n 1. \\<And>f x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set\n   (filter (\\<lambda>y. f x \\<noteq> f y) xs).\n                            \\<not> wordinterval_empty x;\n                 disjoint_list\n                  (map wordinterval_to_set\n                    (filter (\\<lambda>y. f x \\<noteq> f y) xs))\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map (\\<lambda>x.\n      \\<Union> (set (map wordinterval_to_set x)))\n                                     (groupF f\n (filter (\\<lambda>y. f x \\<noteq> f y) xs)));\n        \\<forall>x\\<in>set (x # xs). \\<not> wordinterval_empty x;\n        disjoint_list (map wordinterval_to_set (x # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>x.\n                                   \\<Union>\n                                    (set (map wordinterval_to_set x)))\n                            (groupF f (x # xs)))", "from 2"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>x\\<in>set (filter (\\<lambda>y. f x \\<noteq> f y) xs).\n              \\<not> wordinterval_empty x;\n   disjoint_list\n    (map wordinterval_to_set\n      (filter (\\<lambda>y. f x \\<noteq> f y) xs))\\<rbrakk>\n  \\<Longrightarrow> distinct\n                     (map (\\<lambda>x.\n                              \\<Union> (set (map wordinterval_to_set x)))\n                       (groupF f\n                         (filter (\\<lambda>y. f x \\<noteq> f y) xs)))\n  \\<forall>x\\<in>set (x # xs). \\<not> wordinterval_empty x\n  disjoint_list (map wordinterval_to_set (x # xs))", "have \"disjoint (wordinterval_to_set ` {xa \\<in> set xs. f x \\<noteq> f xa})\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>x\\<in>set (filter (\\<lambda>y. f x \\<noteq> f y) xs).\n              \\<not> wordinterval_empty x;\n   disjoint_list\n    (map wordinterval_to_set\n      (filter (\\<lambda>y. f x \\<noteq> f y) xs))\\<rbrakk>\n  \\<Longrightarrow> distinct\n                     (map (\\<lambda>x.\n                              \\<Union> (set (map wordinterval_to_set x)))\n                       (groupF f\n                         (filter (\\<lambda>y. f x \\<noteq> f y) xs)))\n  \\<forall>x\\<in>set (x # xs). \\<not> wordinterval_empty x\n  disjoint_list (map wordinterval_to_set (x # xs))\n\ngoal (1 subgoal):\n 1. disjoint (wordinterval_to_set ` {xa \\<in> set xs. f x \\<noteq> f xa})", "by(simp add: disjoint_def disjoint_list_def)"], ["proof (state)\nthis:\n  disjoint (wordinterval_to_set ` {xa \\<in> set xs. f x \\<noteq> f xa})\n\ngoal (1 subgoal):\n 1. \\<And>f x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set\n   (filter (\\<lambda>y. f x \\<noteq> f y) xs).\n                            \\<not> wordinterval_empty x;\n                 disjoint_list\n                  (map wordinterval_to_set\n                    (filter (\\<lambda>y. f x \\<noteq> f y) xs))\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map (\\<lambda>x.\n      \\<Union> (set (map wordinterval_to_set x)))\n                                     (groupF f\n (filter (\\<lambda>y. f x \\<noteq> f y) xs)));\n        \\<forall>x\\<in>set (x # xs). \\<not> wordinterval_empty x;\n        disjoint_list (map wordinterval_to_set (x # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>x.\n                                   \\<Union>\n                                    (set (map wordinterval_to_set x)))\n                            (groupF f (x # xs)))", "ultimately"], ["proof (chain)\npicking this:\n  distinct\n   (map wordinterval_to_set (filter (\\<lambda>y. f x \\<noteq> f y) xs))\n  disjoint (wordinterval_to_set ` {xa \\<in> set xs. f x \\<noteq> f xa})", "have g2: \"distinct (map (\\<lambda>x. \\<Union>x\\<in>set x. wordinterval_to_set x) (groupF f [y\\<leftarrow>xs . f x \\<noteq> f y]))\""], ["proof (prove)\nusing this:\n  distinct\n   (map wordinterval_to_set (filter (\\<lambda>y. f x \\<noteq> f y) xs))\n  disjoint (wordinterval_to_set ` {xa \\<in> set xs. f x \\<noteq> f xa})\n\ngoal (1 subgoal):\n 1. distinct\n     (map (\\<lambda>x. \\<Union> (wordinterval_to_set ` set x))\n       (groupF f (filter (\\<lambda>y. f x \\<noteq> f y) xs)))", "using 2(1,2)"], ["proof (prove)\nusing this:\n  distinct\n   (map wordinterval_to_set (filter (\\<lambda>y. f x \\<noteq> f y) xs))\n  disjoint (wordinterval_to_set ` {xa \\<in> set xs. f x \\<noteq> f xa})\n  \\<lbrakk>\\<forall>x\\<in>set (filter (\\<lambda>y. f x \\<noteq> f y) xs).\n              \\<not> wordinterval_empty x;\n   disjoint_list\n    (map wordinterval_to_set\n      (filter (\\<lambda>y. f x \\<noteq> f y) xs))\\<rbrakk>\n  \\<Longrightarrow> distinct\n                     (map (\\<lambda>x.\n                              \\<Union> (set (map wordinterval_to_set x)))\n                       (groupF f\n                         (filter (\\<lambda>y. f x \\<noteq> f y) xs)))\n  \\<forall>x\\<in>set (x # xs). \\<not> wordinterval_empty x\n\ngoal (1 subgoal):\n 1. distinct\n     (map (\\<lambda>x. \\<Union> (wordinterval_to_set ` set x))\n       (groupF f (filter (\\<lambda>y. f x \\<noteq> f y) xs)))", "unfolding disjoint_list_def"], ["proof (prove)\nusing this:\n  distinct\n   (map wordinterval_to_set (filter (\\<lambda>y. f x \\<noteq> f y) xs))\n  disjoint (wordinterval_to_set ` {xa \\<in> set xs. f x \\<noteq> f xa})\n  \\<lbrakk>\\<forall>x\\<in>set (filter (\\<lambda>y. f x \\<noteq> f y) xs).\n              \\<not> wordinterval_empty x;\n   distinct\n    (map wordinterval_to_set\n      (filter (\\<lambda>y. f x \\<noteq> f y) xs)) \\<and>\n   disjoint\n    (set (map wordinterval_to_set\n           (filter (\\<lambda>y. f x \\<noteq> f y) xs)))\\<rbrakk>\n  \\<Longrightarrow> distinct\n                     (map (\\<lambda>x.\n                              \\<Union> (set (map wordinterval_to_set x)))\n                       (groupF f\n                         (filter (\\<lambda>y. f x \\<noteq> f y) xs)))\n  \\<forall>x\\<in>set (x # xs). \\<not> wordinterval_empty x\n\ngoal (1 subgoal):\n 1. distinct\n     (map (\\<lambda>x. \\<Union> (wordinterval_to_set ` set x))\n       (groupF f (filter (\\<lambda>y. f x \\<noteq> f y) xs)))", "by(simp)"], ["proof (state)\nthis:\n  distinct\n   (map (\\<lambda>x. \\<Union> (wordinterval_to_set ` set x))\n     (groupF f (filter (\\<lambda>y. f x \\<noteq> f y) xs)))\n\ngoal (1 subgoal):\n 1. \\<And>f x xs.\n       \\<lbrakk>\\<lbrakk>\\<forall>x\\<in>set\n   (filter (\\<lambda>y. f x \\<noteq> f y) xs).\n                            \\<not> wordinterval_empty x;\n                 disjoint_list\n                  (map wordinterval_to_set\n                    (filter (\\<lambda>y. f x \\<noteq> f y) xs))\\<rbrakk>\n                \\<Longrightarrow> distinct\n                                   (map (\\<lambda>x.\n      \\<Union> (set (map wordinterval_to_set x)))\n                                     (groupF f\n (filter (\\<lambda>y. f x \\<noteq> f y) xs)));\n        \\<forall>x\\<in>set (x # xs). \\<not> wordinterval_empty x;\n        disjoint_list (map wordinterval_to_set (x # xs))\\<rbrakk>\n       \\<Longrightarrow> distinct\n                          (map (\\<lambda>x.\n                                   \\<Union>\n                                    (set (map wordinterval_to_set x)))\n                            (groupF f (x # xs)))", "from g1 g2"], ["proof (chain)\npicking this:\n  wordinterval_to_set x \\<union>\n  \\<Union> (wordinterval_to_set ` {xa \\<in> set xs. f x = f xa})\n  \\<notin> (\\<lambda>x. \\<Union> (wordinterval_to_set ` set x)) `\n           set (groupF f (filter (\\<lambda>y. f x \\<noteq> f y) xs))\n  distinct\n   (map (\\<lambda>x. \\<Union> (wordinterval_to_set ` set x))\n     (groupF f (filter (\\<lambda>y. f x \\<noteq> f y) xs)))", "show ?case"], ["proof (prove)\nusing this:\n  wordinterval_to_set x \\<union>\n  \\<Union> (wordinterval_to_set ` {xa \\<in> set xs. f x = f xa})\n  \\<notin> (\\<lambda>x. \\<Union> (wordinterval_to_set ` set x)) `\n           set (groupF f (filter (\\<lambda>y. f x \\<noteq> f y) xs))\n  distinct\n   (map (\\<lambda>x. \\<Union> (wordinterval_to_set ` set x))\n     (groupF f (filter (\\<lambda>y. f x \\<noteq> f y) xs)))\n\ngoal (1 subgoal):\n 1. distinct\n     (map (\\<lambda>x. \\<Union> (set (map wordinterval_to_set x)))\n       (groupF f (x # xs)))", "by simp"], ["proof (state)\nthis:\n  distinct\n   (map (\\<lambda>x. \\<Union> (set (map wordinterval_to_set x)))\n     (groupF f (x # xs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x\\<in>set ?xs1. \\<not> wordinterval_empty x;\n   disjoint_list (map wordinterval_to_set ?xs1)\\<rbrakk>\n  \\<Longrightarrow> distinct\n                     (map (\\<lambda>x.\n                              \\<Union> (set (map wordinterval_to_set x)))\n                       (groupF ?f1 ?xs1))\n\ngoal (1 subgoal):\n 1. distinct (map wordinterval_to_set (build_ip_partition c rs))", "with getParts_disjoint_list getParts_nonempty_elems"], ["proof (chain)\npicking this:\n  disjoint_list (map wordinterval_to_set (getParts ?rs))\n  \\<forall>w\\<in>set (getParts ?rs). \\<not> wordinterval_empty w\n  \\<lbrakk>\\<forall>x\\<in>set ?xs1. \\<not> wordinterval_empty x;\n   disjoint_list (map wordinterval_to_set ?xs1)\\<rbrakk>\n  \\<Longrightarrow> distinct\n                     (map (\\<lambda>x.\n                              \\<Union> (set (map wordinterval_to_set x)))\n                       (groupF ?f1 ?xs1))", "have\n      \"distinct\n     (map (\\<lambda>x. \\<Union>(set (map wordinterval_to_set x)))\n       (groupF (\\<lambda>wi. (map (\\<lambda>d. runFw (getOneIp wi) d c rs) (map getOneIp (getParts rs)),\n                      map (\\<lambda>s. runFw s (getOneIp wi) c rs) (map getOneIp (getParts rs))))\n         (getParts rs)))\""], ["proof (prove)\nusing this:\n  disjoint_list (map wordinterval_to_set (getParts ?rs))\n  \\<forall>w\\<in>set (getParts ?rs). \\<not> wordinterval_empty w\n  \\<lbrakk>\\<forall>x\\<in>set ?xs1. \\<not> wordinterval_empty x;\n   disjoint_list (map wordinterval_to_set ?xs1)\\<rbrakk>\n  \\<Longrightarrow> distinct\n                     (map (\\<lambda>x.\n                              \\<Union> (set (map wordinterval_to_set x)))\n                       (groupF ?f1 ?xs1))\n\ngoal (1 subgoal):\n 1. distinct\n     (map (\\<lambda>x. \\<Union> (set (map wordinterval_to_set x)))\n       (groupF\n         (\\<lambda>wi.\n             (map (\\<lambda>d. runFw (getOneIp wi) d c rs)\n               (map getOneIp (getParts rs)),\n              map (\\<lambda>s. runFw s (getOneIp wi) c rs)\n               (map getOneIp (getParts rs))))\n         (getParts rs)))", "by blast"], ["proof (state)\nthis:\n  distinct\n   (map (\\<lambda>x. \\<Union> (set (map wordinterval_to_set x)))\n     (groupF\n       (\\<lambda>wi.\n           (map (\\<lambda>d. runFw (getOneIp wi) d c rs)\n             (map getOneIp (getParts rs)),\n            map (\\<lambda>s. runFw s (getOneIp wi) c rs)\n             (map getOneIp (getParts rs))))\n       (getParts rs)))\n\ngoal (1 subgoal):\n 1. distinct (map wordinterval_to_set (build_ip_partition c rs))", "thus ?thesis"], ["proof (prove)\nusing this:\n  distinct\n   (map (\\<lambda>x. \\<Union> (set (map wordinterval_to_set x)))\n     (groupF\n       (\\<lambda>wi.\n           (map (\\<lambda>d. runFw (getOneIp wi) d c rs)\n             (map getOneIp (getParts rs)),\n            map (\\<lambda>s. runFw s (getOneIp wi) c rs)\n             (map getOneIp (getParts rs))))\n       (getParts rs)))\n\ngoal (1 subgoal):\n 1. distinct (map wordinterval_to_set (build_ip_partition c rs))", "unfolding hlp1 groupWIs_def Let_def"], ["proof (prove)\nusing this:\n  distinct\n   (map (\\<lambda>x. \\<Union> (set (map wordinterval_to_set x)))\n     (groupF\n       (\\<lambda>wi.\n           (map (\\<lambda>d. runFw (getOneIp wi) d c rs)\n             (map getOneIp (getParts rs)),\n            map (\\<lambda>s. runFw s (getOneIp wi) c rs)\n             (map getOneIp (getParts rs))))\n       (getParts rs)))\n\ngoal (1 subgoal):\n 1. distinct\n     (map (\\<lambda>x. \\<Union> (set (map wordinterval_to_set x)))\n       (groupF\n         (\\<lambda>wi.\n             (map (\\<lambda>d. runFw (getOneIp wi) d c rs)\n               (map getOneIp (getParts rs)),\n              map (\\<lambda>s. runFw s (getOneIp wi) c rs)\n               (map getOneIp (getParts rs))))\n         (getParts rs)))", "by presburger"], ["proof (state)\nthis:\n  distinct (map wordinterval_to_set (build_ip_partition c rs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma build_ip_partition_distinct': \"distinct (build_ip_partition c rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (build_ip_partition c rs)", "using build_ip_partition_distinct distinct_mapI"], ["proof (prove)\nusing this:\n  distinct (map wordinterval_to_set (build_ip_partition ?c ?rs))\n  distinct (map ?f ?l) \\<Longrightarrow> distinct ?l\n\ngoal (1 subgoal):\n 1. distinct (build_ip_partition c rs)", "by blast"], ["", "subsection\\<open>Service Matrix over an IP Address Space Partition\\<close>"], ["", "definition simple_firewall_without_interfaces :: \"'i::len simple_rule list \\<Rightarrow> bool\" where\n  \"simple_firewall_without_interfaces rs \\<equiv> \\<forall>m \\<in> match_sel ` set rs. iiface m = ifaceAny \\<and> oiface m = ifaceAny\""], ["", "lemma simple_fw_no_interfaces:\n  assumes no_ifaces: \"simple_firewall_without_interfaces rs\"\n  shows \"simple_fw rs p = simple_fw rs (p\\<lparr> p_iiface:= x, p_oiface:= y\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_fw rs p =\n    simple_fw rs (p\\<lparr>p_iiface := x, p_oiface := y\\<rparr>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. simple_fw rs p =\n    simple_fw rs (p\\<lparr>p_iiface := x, p_oiface := y\\<rparr>)", "from no_ifaces"], ["proof (chain)\npicking this:\n  simple_firewall_without_interfaces rs", "have \"\\<forall>r\\<in>set rs. iiface (match_sel r) = ifaceAny \\<and> oiface (match_sel r) = ifaceAny\""], ["proof (prove)\nusing this:\n  simple_firewall_without_interfaces rs\n\ngoal (1 subgoal):\n 1. \\<forall>r\\<in>set rs.\n       iiface (match_sel r) = ifaceAny \\<and>\n       oiface (match_sel r) = ifaceAny", "by(simp add: simple_firewall_without_interfaces_def)"], ["proof (state)\nthis:\n  \\<forall>r\\<in>set rs.\n     iiface (match_sel r) = ifaceAny \\<and> oiface (match_sel r) = ifaceAny\n\ngoal (1 subgoal):\n 1. simple_fw rs p =\n    simple_fw rs (p\\<lparr>p_iiface := x, p_oiface := y\\<rparr>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>r\\<in>set rs.\n     iiface (match_sel r) = ifaceAny \\<and> oiface (match_sel r) = ifaceAny\n\ngoal (1 subgoal):\n 1. simple_fw rs p =\n    simple_fw rs (p\\<lparr>p_iiface := x, p_oiface := y\\<rparr>)", "apply(induction rs p rule:simple_fw.induct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_.\n       \\<forall>r\\<in>set [].\n          iiface (match_sel r) = ifaceAny \\<and>\n          oiface (match_sel r) = ifaceAny \\<Longrightarrow>\n       simple_fw [] uu_ =\n       simple_fw [] (uu_\\<lparr>p_iiface := x, p_oiface := y\\<rparr>)\n 2. \\<And>m rs p.\n       \\<lbrakk>\\<lbrakk>\\<not> simple_matches m p;\n                 \\<forall>r\\<in>set rs.\n                    iiface (match_sel r) = ifaceAny \\<and>\n                    oiface (match_sel r) = ifaceAny\\<rbrakk>\n                \\<Longrightarrow> simple_fw rs p =\n                                  simple_fw rs\n                                   (p\\<lparr>p_iiface := x,\n  p_oiface := y\\<rparr>);\n        \\<forall>r\\<in>set (SimpleRule m Accept # rs).\n           iiface (match_sel r) = ifaceAny \\<and>\n           oiface (match_sel r) = ifaceAny\\<rbrakk>\n       \\<Longrightarrow> simple_fw (SimpleRule m Accept # rs) p =\n                         simple_fw (SimpleRule m Accept # rs)\n                          (p\\<lparr>p_iiface := x, p_oiface := y\\<rparr>)\n 3. \\<And>m rs p.\n       \\<lbrakk>\\<lbrakk>\\<not> simple_matches m p;\n                 \\<forall>r\\<in>set rs.\n                    iiface (match_sel r) = ifaceAny \\<and>\n                    oiface (match_sel r) = ifaceAny\\<rbrakk>\n                \\<Longrightarrow> simple_fw rs p =\n                                  simple_fw rs\n                                   (p\\<lparr>p_iiface := x,\n  p_oiface := y\\<rparr>);\n        \\<forall>r\\<in>set (SimpleRule m Drop # rs).\n           iiface (match_sel r) = ifaceAny \\<and>\n           oiface (match_sel r) = ifaceAny\\<rbrakk>\n       \\<Longrightarrow> simple_fw (SimpleRule m Drop # rs) p =\n                         simple_fw (SimpleRule m Drop # rs)\n                          (p\\<lparr>p_iiface := x, p_oiface := y\\<rparr>)", "by(simp_all add: simple_matches.simps match_ifaceAny)"], ["proof (state)\nthis:\n  simple_fw rs p =\n  simple_fw rs (p\\<lparr>p_iiface := x, p_oiface := y\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma runFw_no_interfaces:\n  assumes no_ifaces: \"simple_firewall_without_interfaces rs\"\n  shows \"runFw s d c rs = runFw s d (c\\<lparr> pc_iiface:= x, pc_oiface:= y\\<rparr>) rs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runFw s d c rs =\n    runFw s d (c\\<lparr>pc_iiface := x, pc_oiface := y\\<rparr>) rs", "apply(simp add: runFw_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_fw rs\n     \\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n        p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n        p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n        p_payload = []\\<rparr> =\n    simple_fw rs\n     \\<lparr>p_iiface = x, p_oiface = y, p_src = s, p_dst = d,\n        p_proto = pc_proto c, p_sport = pc_sport c, p_dport = pc_dport c,\n        p_tcp_flags = {TCP_SYN}, p_payload = []\\<rparr>", "apply(subst simple_fw_no_interfaces[OF no_ifaces])"], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_fw rs\n     (\\<lparr>p_iiface = pc_iiface c, p_oiface = pc_oiface c, p_src = s,\n         p_dst = d, p_proto = pc_proto c, p_sport = pc_sport c,\n         p_dport = pc_dport c, p_tcp_flags = {TCP_SYN},\n         p_payload = []\\<rparr>\n      \\<lparr>p_iiface := ?x, p_oiface := ?y\\<rparr>) =\n    simple_fw rs\n     \\<lparr>p_iiface = x, p_oiface = y, p_src = s, p_dst = d,\n        p_proto = pc_proto c, p_sport = pc_sport c, p_dport = pc_dport c,\n        p_tcp_flags = {TCP_SYN}, p_payload = []\\<rparr>", "by(simp)"], ["", "lemma[code_unfold]: \"simple_firewall_without_interfaces rs \\<equiv>\n  \\<forall>m \\<in> set rs. iiface (match_sel m) = ifaceAny \\<and> oiface (match_sel m) = ifaceAny\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simple_firewall_without_interfaces rs \\<equiv>\n    \\<forall>m\\<in>set rs.\n       iiface (match_sel m) = ifaceAny \\<and>\n       oiface (match_sel m) = ifaceAny", "by(simp add: simple_firewall_without_interfaces_def)"], ["", "(*only defined for simple_firewall_without_interfaces*)"], ["", "definition access_matrix \n  :: \"parts_connection \\<Rightarrow> 'i::len simple_rule list \\<Rightarrow> ('i word \\<times> 'i wordinterval) list \\<times> ('i word \\<times> 'i word) list\" \n  where\n  \"access_matrix c rs \\<equiv>\n    (let W = build_ip_partition c rs;\n         R = map getOneIp W\n     in\n     (zip R W, [(s, d)\\<leftarrow>all_pairs R. runFw s d c rs = Decision FinalAllow]))\""], ["", "lemma access_matrix_nodes_defined:\n      \"(V,E) = access_matrix c rs \\<Longrightarrow> (s, d) \\<in> set E \\<Longrightarrow> s \\<in> dom (map_of V)\" and\n      \"(V,E) = access_matrix c rs \\<Longrightarrow> (s, d) \\<in> set E \\<Longrightarrow> d \\<in> dom (map_of V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>(V, E) = access_matrix c rs; (s, d) \\<in> set E\\<rbrakk>\n     \\<Longrightarrow> s \\<in> dom (map_of V)) &&&\n    (\\<lbrakk>(V, E) = access_matrix c rs; (s, d) \\<in> set E\\<rbrakk>\n     \\<Longrightarrow> d \\<in> dom (map_of V))", "by(auto simp add: access_matrix_def Let_def all_pairs_def)"], ["", "text\\<open>For all the entries @{term E} of the matrix, the access is allowed\\<close>"], ["", "lemma \"(V,E) = access_matrix c rs \\<Longrightarrow> (s, d) \\<in> set E \\<Longrightarrow> runFw s d c rs = Decision FinalAllow\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(V, E) = access_matrix c rs; (s, d) \\<in> set E\\<rbrakk>\n    \\<Longrightarrow> runFw s d c rs = Decision FinalAllow", "by(auto simp add: access_matrix_def Let_def)"], ["", "text\\<open>However, the entries are only a representation of a whole set of IP addresses. \n      For all IP addresses which the entries represent, the access must be allowed.\\<close>"], ["", "(*TODO: move to generic library*)"], ["", "lemma map_of_zip_map: \"map_of (zip (map f rs) rs) k = Some v \\<Longrightarrow> k = f v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (zip (map f rs) rs) k = Some v \\<Longrightarrow> k = f v", "apply(induction rs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_of (zip (map f []) []) k = Some v \\<Longrightarrow> k = f v\n 2. \\<And>a rs.\n       \\<lbrakk>map_of (zip (map f rs) rs) k = Some v \\<Longrightarrow>\n                k = f v;\n        map_of (zip (map f (a # rs)) (a # rs)) k = Some v\\<rbrakk>\n       \\<Longrightarrow> k = f v", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a rs.\n       \\<lbrakk>map_of (zip (map f rs) rs) k = Some v \\<Longrightarrow>\n                k = f v;\n        map_of (zip (map f (a # rs)) (a # rs)) k = Some v\\<rbrakk>\n       \\<Longrightarrow> k = f v", "apply(simp split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma access_matrix_sound: assumes matrix: \"(V,E) = access_matrix c rs\" and\n              repr: \"(s_repr, d_repr) \\<in> set E\" and\n              s_range: \"(map_of V) s_repr = Some s_range\" and s: \"s \\<in> wordinterval_to_set s_range\" and\n              d_range: \"(map_of V) d_repr = Some d_range\" and d: \"d \\<in> wordinterval_to_set d_range\"\n      shows \"runFw s d c rs = Decision FinalAllow\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runFw s d c rs = Decision FinalAllow", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. runFw s d c rs = Decision FinalAllow", "let ?part=\"(build_ip_partition c rs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. runFw s d c rs = Decision FinalAllow", "have V: \"V = (zip (map getOneIp ?part) ?part)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V =\n    zip (map getOneIp (build_ip_partition c rs)) (build_ip_partition c rs)", "using matrix"], ["proof (prove)\nusing this:\n  (V, E) = access_matrix c rs\n\ngoal (1 subgoal):\n 1. V =\n    zip (map getOneIp (build_ip_partition c rs)) (build_ip_partition c rs)", "by(simp add: access_matrix_def Let_def)"], ["proof (state)\nthis:\n  V = zip (map getOneIp (build_ip_partition c rs)) (build_ip_partition c rs)\n\ngoal (1 subgoal):\n 1. runFw s d c rs = Decision FinalAllow", "(*have \"E = [(s, d)\\<leftarrow>all_pairs (map getOneIp ?part). runFw s d c rs = Decision FinalAllow]\"\n      using matrix by(simp add: access_matrix_def Let_def)\n    with repr have \"(s_repr, d_repr) \\<in> set (all_pairs (map getOneIp ?part))\" by simp\n    hence \"s_repr \\<in> set (map getOneIp ?part)\" and\n          \"d_repr \\<in> set (map getOneIp ?part)\"\n      by(simp add: all_pairs_set)+*)\n    (*from s_range have \"(s_repr, s_range) \\<in> set V\" by (simp add: map_of_SomeD)*)"], ["proof (state)\nthis:\n  V = zip (map getOneIp (build_ip_partition c rs)) (build_ip_partition c rs)\n\ngoal (1 subgoal):\n 1. runFw s d c rs = Decision FinalAllow", "from matrix repr"], ["proof (chain)\npicking this:\n  (V, E) = access_matrix c rs\n  (s_repr, d_repr) \\<in> set E", "have repr_Allow: \"runFw s_repr d_repr c rs = Decision FinalAllow\""], ["proof (prove)\nusing this:\n  (V, E) = access_matrix c rs\n  (s_repr, d_repr) \\<in> set E\n\ngoal (1 subgoal):\n 1. runFw s_repr d_repr c rs = Decision FinalAllow", "by(auto simp add: access_matrix_def Let_def)"], ["proof (state)\nthis:\n  runFw s_repr d_repr c rs = Decision FinalAllow\n\ngoal (1 subgoal):\n 1. runFw s d c rs = Decision FinalAllow", "have s_range_in_part: \"s_range \\<in> set ?part\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s_range \\<in> set (build_ip_partition c rs)", "using V s_range"], ["proof (prove)\nusing this:\n  V = zip (map getOneIp (build_ip_partition c rs)) (build_ip_partition c rs)\n  map_of V s_repr = Some s_range\n\ngoal (1 subgoal):\n 1. s_range \\<in> set (build_ip_partition c rs)", "by (fastforce elim: in_set_zipE dest: map_of_SomeD)"], ["proof (state)\nthis:\n  s_range \\<in> set (build_ip_partition c rs)\n\ngoal (1 subgoal):\n 1. runFw s d c rs = Decision FinalAllow", "with build_ip_partition_no_empty_elems"], ["proof (chain)\npicking this:\n  ?wi \\<in> set (build_ip_partition ?c ?rs) \\<Longrightarrow>\n  \\<not> wordinterval_empty ?wi\n  s_range \\<in> set (build_ip_partition c rs)", "have \"\\<not> wordinterval_empty s_range\""], ["proof (prove)\nusing this:\n  ?wi \\<in> set (build_ip_partition ?c ?rs) \\<Longrightarrow>\n  \\<not> wordinterval_empty ?wi\n  s_range \\<in> set (build_ip_partition c rs)\n\ngoal (1 subgoal):\n 1. \\<not> wordinterval_empty s_range", "by simp"], ["proof (state)\nthis:\n  \\<not> wordinterval_empty s_range\n\ngoal (1 subgoal):\n 1. runFw s d c rs = Decision FinalAllow", "have d_range_in_part: \"d_range \\<in> set ?part\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_range \\<in> set (build_ip_partition c rs)", "using V d_range"], ["proof (prove)\nusing this:\n  V = zip (map getOneIp (build_ip_partition c rs)) (build_ip_partition c rs)\n  map_of V d_repr = Some d_range\n\ngoal (1 subgoal):\n 1. d_range \\<in> set (build_ip_partition c rs)", "by (fastforce elim: in_set_zipE dest: map_of_SomeD)"], ["proof (state)\nthis:\n  d_range \\<in> set (build_ip_partition c rs)\n\ngoal (1 subgoal):\n 1. runFw s d c rs = Decision FinalAllow", "with build_ip_partition_no_empty_elems"], ["proof (chain)\npicking this:\n  ?wi \\<in> set (build_ip_partition ?c ?rs) \\<Longrightarrow>\n  \\<not> wordinterval_empty ?wi\n  d_range \\<in> set (build_ip_partition c rs)", "have \"\\<not> wordinterval_empty d_range\""], ["proof (prove)\nusing this:\n  ?wi \\<in> set (build_ip_partition ?c ?rs) \\<Longrightarrow>\n  \\<not> wordinterval_empty ?wi\n  d_range \\<in> set (build_ip_partition c rs)\n\ngoal (1 subgoal):\n 1. \\<not> wordinterval_empty d_range", "by simp"], ["proof (state)\nthis:\n  \\<not> wordinterval_empty d_range\n\ngoal (1 subgoal):\n 1. runFw s d c rs = Decision FinalAllow", "from map_of_zip_map V s_range"], ["proof (chain)\npicking this:\n  map_of (zip (map ?f ?rs) ?rs) ?k = Some ?v \\<Longrightarrow> ?k = ?f ?v\n  V = zip (map getOneIp (build_ip_partition c rs)) (build_ip_partition c rs)\n  map_of V s_repr = Some s_range", "have \"s_repr = getOneIp s_range\""], ["proof (prove)\nusing this:\n  map_of (zip (map ?f ?rs) ?rs) ?k = Some ?v \\<Longrightarrow> ?k = ?f ?v\n  V = zip (map getOneIp (build_ip_partition c rs)) (build_ip_partition c rs)\n  map_of V s_repr = Some s_range\n\ngoal (1 subgoal):\n 1. s_repr = getOneIp s_range", "by fast"], ["proof (state)\nthis:\n  s_repr = getOneIp s_range\n\ngoal (1 subgoal):\n 1. runFw s d c rs = Decision FinalAllow", "with \\<open>\\<not> wordinterval_empty s_range\\<close> getOneIp_elem wordinterval_element_set_eq"], ["proof (chain)\npicking this:\n  \\<not> wordinterval_empty s_range\n  \\<not> wordinterval_empty ?W \\<Longrightarrow>\n  wordinterval_element (getOneIp ?W) ?W\n  wordinterval_element ?el ?rg = (?el \\<in> wordinterval_to_set ?rg)\n  s_repr = getOneIp s_range", "have \"s_repr \\<in> wordinterval_to_set s_range\""], ["proof (prove)\nusing this:\n  \\<not> wordinterval_empty s_range\n  \\<not> wordinterval_empty ?W \\<Longrightarrow>\n  wordinterval_element (getOneIp ?W) ?W\n  wordinterval_element ?el ?rg = (?el \\<in> wordinterval_to_set ?rg)\n  s_repr = getOneIp s_range\n\ngoal (1 subgoal):\n 1. s_repr \\<in> wordinterval_to_set s_range", "by blast"], ["proof (state)\nthis:\n  s_repr \\<in> wordinterval_to_set s_range\n\ngoal (1 subgoal):\n 1. runFw s d c rs = Decision FinalAllow", "from map_of_zip_map V d_range"], ["proof (chain)\npicking this:\n  map_of (zip (map ?f ?rs) ?rs) ?k = Some ?v \\<Longrightarrow> ?k = ?f ?v\n  V = zip (map getOneIp (build_ip_partition c rs)) (build_ip_partition c rs)\n  map_of V d_repr = Some d_range", "have \"d_repr = getOneIp d_range\""], ["proof (prove)\nusing this:\n  map_of (zip (map ?f ?rs) ?rs) ?k = Some ?v \\<Longrightarrow> ?k = ?f ?v\n  V = zip (map getOneIp (build_ip_partition c rs)) (build_ip_partition c rs)\n  map_of V d_repr = Some d_range\n\ngoal (1 subgoal):\n 1. d_repr = getOneIp d_range", "by fast"], ["proof (state)\nthis:\n  d_repr = getOneIp d_range\n\ngoal (1 subgoal):\n 1. runFw s d c rs = Decision FinalAllow", "with \\<open>\\<not> wordinterval_empty d_range\\<close> getOneIp_elem wordinterval_element_set_eq"], ["proof (chain)\npicking this:\n  \\<not> wordinterval_empty d_range\n  \\<not> wordinterval_empty ?W \\<Longrightarrow>\n  wordinterval_element (getOneIp ?W) ?W\n  wordinterval_element ?el ?rg = (?el \\<in> wordinterval_to_set ?rg)\n  d_repr = getOneIp d_range", "have \"d_repr \\<in> wordinterval_to_set d_range\""], ["proof (prove)\nusing this:\n  \\<not> wordinterval_empty d_range\n  \\<not> wordinterval_empty ?W \\<Longrightarrow>\n  wordinterval_element (getOneIp ?W) ?W\n  wordinterval_element ?el ?rg = (?el \\<in> wordinterval_to_set ?rg)\n  d_repr = getOneIp d_range\n\ngoal (1 subgoal):\n 1. d_repr \\<in> wordinterval_to_set d_range", "by blast"], ["proof (state)\nthis:\n  d_repr \\<in> wordinterval_to_set d_range\n\ngoal (1 subgoal):\n 1. runFw s d c rs = Decision FinalAllow", "from s_range_in_part"], ["proof (chain)\npicking this:\n  s_range \\<in> set (build_ip_partition c rs)", "have s_range_in_part': \"s_range \\<in> set (build_ip_partition c rs)\""], ["proof (prove)\nusing this:\n  s_range \\<in> set (build_ip_partition c rs)\n\ngoal (1 subgoal):\n 1. s_range \\<in> set (build_ip_partition c rs)", "by simp"], ["proof (state)\nthis:\n  s_range \\<in> set (build_ip_partition c rs)\n\ngoal (1 subgoal):\n 1. runFw s d c rs = Decision FinalAllow", "from d_range_in_part"], ["proof (chain)\npicking this:\n  d_range \\<in> set (build_ip_partition c rs)", "have d_range_in_part': \"d_range \\<in> set (build_ip_partition c rs)\""], ["proof (prove)\nusing this:\n  d_range \\<in> set (build_ip_partition c rs)\n\ngoal (1 subgoal):\n 1. d_range \\<in> set (build_ip_partition c rs)", "by simp"], ["proof (state)\nthis:\n  d_range \\<in> set (build_ip_partition c rs)\n\ngoal (1 subgoal):\n 1. runFw s d c rs = Decision FinalAllow", "from build_ip_partition_same_fw[OF s_range_in_part', unfolded same_fw_behaviour_one_def] s\n                                                        \\<open>s_repr \\<in> wordinterval_to_set s_range\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>ip1\\<in>wordinterval_to_set s_range.\n     \\<forall>ip2\\<in>wordinterval_to_set s_range.\n        \\<forall>d s.\n           runFw ip1 d c rs = runFw ip2 d c rs \\<and>\n           runFw s ip1 c rs = runFw s ip2 c rs\n  s \\<in> wordinterval_to_set s_range\n  s_repr \\<in> wordinterval_to_set s_range", "have \n      \"\\<forall>d. runFw s_repr d c rs = runFw s d c rs\""], ["proof (prove)\nusing this:\n  \\<forall>ip1\\<in>wordinterval_to_set s_range.\n     \\<forall>ip2\\<in>wordinterval_to_set s_range.\n        \\<forall>d s.\n           runFw ip1 d c rs = runFw ip2 d c rs \\<and>\n           runFw s ip1 c rs = runFw s ip2 c rs\n  s \\<in> wordinterval_to_set s_range\n  s_repr \\<in> wordinterval_to_set s_range\n\ngoal (1 subgoal):\n 1. \\<forall>d. runFw s_repr d c rs = runFw s d c rs", "by blast"], ["proof (state)\nthis:\n  \\<forall>d. runFw s_repr d c rs = runFw s d c rs\n\ngoal (1 subgoal):\n 1. runFw s d c rs = Decision FinalAllow", "with repr_Allow"], ["proof (chain)\npicking this:\n  runFw s_repr d_repr c rs = Decision FinalAllow\n  \\<forall>d. runFw s_repr d c rs = runFw s d c rs", "have 1: \"runFw s d_repr c rs = Decision FinalAllow\""], ["proof (prove)\nusing this:\n  runFw s_repr d_repr c rs = Decision FinalAllow\n  \\<forall>d. runFw s_repr d c rs = runFw s d c rs\n\ngoal (1 subgoal):\n 1. runFw s d_repr c rs = Decision FinalAllow", "by simp"], ["proof (state)\nthis:\n  runFw s d_repr c rs = Decision FinalAllow\n\ngoal (1 subgoal):\n 1. runFw s d c rs = Decision FinalAllow", "from build_ip_partition_same_fw[OF d_range_in_part', unfolded same_fw_behaviour_one_def] d\n                                                        \\<open>d_repr \\<in> wordinterval_to_set d_range\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>ip1\\<in>wordinterval_to_set d_range.\n     \\<forall>ip2\\<in>wordinterval_to_set d_range.\n        \\<forall>d s.\n           runFw ip1 d c rs = runFw ip2 d c rs \\<and>\n           runFw s ip1 c rs = runFw s ip2 c rs\n  d \\<in> wordinterval_to_set d_range\n  d_repr \\<in> wordinterval_to_set d_range", "have \n      \"\\<forall>s. runFw s d_repr c rs = runFw s d c rs\""], ["proof (prove)\nusing this:\n  \\<forall>ip1\\<in>wordinterval_to_set d_range.\n     \\<forall>ip2\\<in>wordinterval_to_set d_range.\n        \\<forall>d s.\n           runFw ip1 d c rs = runFw ip2 d c rs \\<and>\n           runFw s ip1 c rs = runFw s ip2 c rs\n  d \\<in> wordinterval_to_set d_range\n  d_repr \\<in> wordinterval_to_set d_range\n\ngoal (1 subgoal):\n 1. \\<forall>s. runFw s d_repr c rs = runFw s d c rs", "by blast"], ["proof (state)\nthis:\n  \\<forall>s. runFw s d_repr c rs = runFw s d c rs\n\ngoal (1 subgoal):\n 1. runFw s d c rs = Decision FinalAllow", "with 1"], ["proof (chain)\npicking this:\n  runFw s d_repr c rs = Decision FinalAllow\n  \\<forall>s. runFw s d_repr c rs = runFw s d c rs", "have 2: \"runFw s d c rs = Decision FinalAllow\""], ["proof (prove)\nusing this:\n  runFw s d_repr c rs = Decision FinalAllow\n  \\<forall>s. runFw s d_repr c rs = runFw s d c rs\n\ngoal (1 subgoal):\n 1. runFw s d c rs = Decision FinalAllow", "by simp"], ["proof (state)\nthis:\n  runFw s d c rs = Decision FinalAllow\n\ngoal (1 subgoal):\n 1. runFw s d c rs = Decision FinalAllow", "thus ?thesis"], ["proof (prove)\nusing this:\n  runFw s d c rs = Decision FinalAllow\n\ngoal (1 subgoal):\n 1. runFw s d c rs = Decision FinalAllow", "."], ["proof (state)\nthis:\n  runFw s d c rs = Decision FinalAllow\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_map_getOneIp_obtain: \"v \\<in> set xs \\<Longrightarrow> distinct (map getOneIp xs) \\<Longrightarrow> \n  \\<exists>s_repr. map_of (zip (map getOneIp xs) xs) s_repr = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> set xs; distinct (map getOneIp xs)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s_repr.\n                         map_of (zip (map getOneIp xs) xs) s_repr = Some v", "proof(induction xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set []; distinct (map getOneIp [])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s_repr.\n                         map_of (zip (map getOneIp []) []) s_repr = Some v\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>v \\<in> set xs; distinct (map getOneIp xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>s_repr.\n                                     map_of (zip (map getOneIp xs) xs)\ns_repr =\n                                     Some v;\n        v \\<in> set (a # xs); distinct (map getOneIp (a # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s_repr.\n                            map_of (zip (map getOneIp (a # xs)) (a # xs))\n                             s_repr =\n                            Some v", "case Nil"], ["proof (state)\nthis:\n  v \\<in> set []\n  distinct (map getOneIp [])\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v \\<in> set []; distinct (map getOneIp [])\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s_repr.\n                         map_of (zip (map getOneIp []) []) s_repr = Some v\n 2. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>v \\<in> set xs; distinct (map getOneIp xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>s_repr.\n                                     map_of (zip (map getOneIp xs) xs)\ns_repr =\n                                     Some v;\n        v \\<in> set (a # xs); distinct (map getOneIp (a # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s_repr.\n                            map_of (zip (map getOneIp (a # xs)) (a # xs))\n                             s_repr =\n                            Some v", "thus ?case"], ["proof (prove)\nusing this:\n  v \\<in> set []\n  distinct (map getOneIp [])\n\ngoal (1 subgoal):\n 1. \\<exists>s_repr. map_of (zip (map getOneIp []) []) s_repr = Some v", "by simp"], ["proof (state)\nthis:\n  \\<exists>s_repr. map_of (zip (map getOneIp []) []) s_repr = Some v\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>v \\<in> set xs; distinct (map getOneIp xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>s_repr.\n                                     map_of (zip (map getOneIp xs) xs)\ns_repr =\n                                     Some v;\n        v \\<in> set (a # xs); distinct (map getOneIp (a # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s_repr.\n                            map_of (zip (map getOneIp (a # xs)) (a # xs))\n                             s_repr =\n                            Some v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>v \\<in> set xs; distinct (map getOneIp xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>s_repr.\n                                     map_of (zip (map getOneIp xs) xs)\ns_repr =\n                                     Some v;\n        v \\<in> set (a # xs); distinct (map getOneIp (a # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s_repr.\n                            map_of (zip (map getOneIp (a # xs)) (a # xs))\n                             s_repr =\n                            Some v", "case (Cons x xs)"], ["proof (state)\nthis:\n  \\<lbrakk>v \\<in> set xs; distinct (map getOneIp xs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s_repr.\n                       map_of (zip (map getOneIp xs) xs) s_repr = Some v\n  v \\<in> set (x # xs)\n  distinct (map getOneIp (x # xs))\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>v \\<in> set xs; distinct (map getOneIp xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>s_repr.\n                                     map_of (zip (map getOneIp xs) xs)\ns_repr =\n                                     Some v;\n        v \\<in> set (a # xs); distinct (map getOneIp (a # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s_repr.\n                            map_of (zip (map getOneIp (a # xs)) (a # xs))\n                             s_repr =\n                            Some v", "consider \"v = x\" | \"v \\<in> set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v = x \\<Longrightarrow> thesis;\n     v \\<in> set xs \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  v \\<in> set (x # xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v = x \\<Longrightarrow> thesis;\n     v \\<in> set xs \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>v = x \\<Longrightarrow> ?thesis;\n   v \\<in> set xs \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>a xs.\n       \\<lbrakk>\\<lbrakk>v \\<in> set xs; distinct (map getOneIp xs)\\<rbrakk>\n                \\<Longrightarrow> \\<exists>s_repr.\n                                     map_of (zip (map getOneIp xs) xs)\ns_repr =\n                                     Some v;\n        v \\<in> set (a # xs); distinct (map getOneIp (a # xs))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s_repr.\n                            map_of (zip (map getOneIp (a # xs)) (a # xs))\n                             s_repr =\n                            Some v", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>v = x \\<Longrightarrow> ?thesis;\n   v \\<in> set xs \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>s_repr.\n       map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v", "proof(cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. v = x \\<Longrightarrow>\n    \\<exists>s_repr.\n       map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v\n 2. v \\<in> set xs \\<Longrightarrow>\n    \\<exists>s_repr.\n       map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v", "case 1"], ["proof (state)\nthis:\n  v = x\n\ngoal (2 subgoals):\n 1. v = x \\<Longrightarrow>\n    \\<exists>s_repr.\n       map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v\n 2. v \\<in> set xs \\<Longrightarrow>\n    \\<exists>s_repr.\n       map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v", "thus ?thesis"], ["proof (prove)\nusing this:\n  v = x\n\ngoal (1 subgoal):\n 1. \\<exists>s_repr.\n       map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v", "by simp blast"], ["proof (state)\nthis:\n  \\<exists>s_repr.\n     map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v\n\ngoal (1 subgoal):\n 1. v \\<in> set xs \\<Longrightarrow>\n    \\<exists>s_repr.\n       map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<in> set xs \\<Longrightarrow>\n    \\<exists>s_repr.\n       map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v", "case 2"], ["proof (state)\nthis:\n  v \\<in> set xs\n\ngoal (1 subgoal):\n 1. v \\<in> set xs \\<Longrightarrow>\n    \\<exists>s_repr.\n       map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v", "with Cons.IH Cons.prems(2)"], ["proof (chain)\npicking this:\n  \\<lbrakk>v \\<in> set xs; distinct (map getOneIp xs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s_repr.\n                       map_of (zip (map getOneIp xs) xs) s_repr = Some v\n  distinct (map getOneIp (x # xs))\n  v \\<in> set xs", "obtain s_repr where\n      s_repr: \"map_of (zip (map getOneIp xs) xs) s_repr = Some v\""], ["proof (prove)\nusing this:\n  \\<lbrakk>v \\<in> set xs; distinct (map getOneIp xs)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s_repr.\n                       map_of (zip (map getOneIp xs) xs) s_repr = Some v\n  distinct (map getOneIp (x # xs))\n  v \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>s_repr.\n        map_of (zip (map getOneIp xs) xs) s_repr = Some v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  map_of (zip (map getOneIp xs) xs) s_repr = Some v\n\ngoal (1 subgoal):\n 1. v \\<in> set xs \\<Longrightarrow>\n    \\<exists>s_repr.\n       map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s_repr.\n       map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v", "proof(cases \"s_repr \\<noteq> getOneIp x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s_repr \\<noteq> getOneIp x \\<Longrightarrow>\n    \\<exists>s_repr.\n       map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v\n 2. \\<not> s_repr \\<noteq> getOneIp x \\<Longrightarrow>\n    \\<exists>s_repr.\n       map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v", "case True"], ["proof (state)\nthis:\n  s_repr \\<noteq> getOneIp x\n\ngoal (2 subgoals):\n 1. s_repr \\<noteq> getOneIp x \\<Longrightarrow>\n    \\<exists>s_repr.\n       map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v\n 2. \\<not> s_repr \\<noteq> getOneIp x \\<Longrightarrow>\n    \\<exists>s_repr.\n       map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v", "with Cons.prems s_repr"], ["proof (chain)\npicking this:\n  v \\<in> set (x # xs)\n  distinct (map getOneIp (x # xs))\n  map_of (zip (map getOneIp xs) xs) s_repr = Some v\n  s_repr \\<noteq> getOneIp x", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> set (x # xs)\n  distinct (map getOneIp (x # xs))\n  map_of (zip (map getOneIp xs) xs) s_repr = Some v\n  s_repr \\<noteq> getOneIp x\n\ngoal (1 subgoal):\n 1. \\<exists>s_repr.\n       map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v", "by(rule_tac x=s_repr in exI, simp)"], ["proof (state)\nthis:\n  \\<exists>s_repr.\n     map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v\n\ngoal (1 subgoal):\n 1. \\<not> s_repr \\<noteq> getOneIp x \\<Longrightarrow>\n    \\<exists>s_repr.\n       map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> s_repr \\<noteq> getOneIp x \\<Longrightarrow>\n    \\<exists>s_repr.\n       map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v", "case False"], ["proof (state)\nthis:\n  \\<not> s_repr \\<noteq> getOneIp x\n\ngoal (1 subgoal):\n 1. \\<not> s_repr \\<noteq> getOneIp x \\<Longrightarrow>\n    \\<exists>s_repr.\n       map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v", "with Cons.prems s_repr"], ["proof (chain)\npicking this:\n  v \\<in> set (x # xs)\n  distinct (map getOneIp (x # xs))\n  map_of (zip (map getOneIp xs) xs) s_repr = Some v\n  \\<not> s_repr \\<noteq> getOneIp x", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> set (x # xs)\n  distinct (map getOneIp (x # xs))\n  map_of (zip (map getOneIp xs) xs) s_repr = Some v\n  \\<not> s_repr \\<noteq> getOneIp x\n\ngoal (1 subgoal):\n 1. \\<exists>s_repr.\n       map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v", "by(fastforce elim: in_set_zipE)"], ["proof (state)\nthis:\n  \\<exists>s_repr.\n     map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s_repr.\n     map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s_repr.\n     map_of (zip (map getOneIp (x # xs)) (x # xs)) s_repr = Some v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma access_matrix_complete:\n      fixes rs :: \"'i::len simple_rule list\"\n      assumes matrix: \"(V,E) = access_matrix c rs\" and\n              allow: \"runFw s d c rs = Decision FinalAllow\"\n      shows \"\\<exists>s_repr d_repr s_range d_range. (s_repr, d_repr) \\<in> set E \\<and>\n              (map_of V) s_repr = Some s_range \\<and> s \\<in> wordinterval_to_set s_range \\<and>\n              (map_of V) d_repr = Some d_range \\<and> d \\<in> wordinterval_to_set d_range\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s_repr d_repr s_range d_range.\n       (s_repr, d_repr) \\<in> set E \\<and>\n       map_of V s_repr = Some s_range \\<and>\n       s \\<in> wordinterval_to_set s_range \\<and>\n       map_of V d_repr = Some d_range \\<and>\n       d \\<in> wordinterval_to_set d_range", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s_repr d_repr s_range d_range.\n       (s_repr, d_repr) \\<in> set E \\<and>\n       map_of V s_repr = Some s_range \\<and>\n       s \\<in> wordinterval_to_set s_range \\<and>\n       map_of V d_repr = Some d_range \\<and>\n       d \\<in> wordinterval_to_set d_range", "let ?part=\"(build_ip_partition c rs)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s_repr d_repr s_range d_range.\n       (s_repr, d_repr) \\<in> set E \\<and>\n       map_of V s_repr = Some s_range \\<and>\n       s \\<in> wordinterval_to_set s_range \\<and>\n       map_of V d_repr = Some d_range \\<and>\n       d \\<in> wordinterval_to_set d_range", "have V: \"V = zip (map getOneIp ?part) ?part\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V =\n    zip (map getOneIp (build_ip_partition c rs)) (build_ip_partition c rs)", "using matrix"], ["proof (prove)\nusing this:\n  (V, E) = access_matrix c rs\n\ngoal (1 subgoal):\n 1. V =\n    zip (map getOneIp (build_ip_partition c rs)) (build_ip_partition c rs)", "by(simp add: access_matrix_def Let_def)"], ["proof (state)\nthis:\n  V = zip (map getOneIp (build_ip_partition c rs)) (build_ip_partition c rs)\n\ngoal (1 subgoal):\n 1. \\<exists>s_repr d_repr s_range d_range.\n       (s_repr, d_repr) \\<in> set E \\<and>\n       map_of V s_repr = Some s_range \\<and>\n       s \\<in> wordinterval_to_set s_range \\<and>\n       map_of V d_repr = Some d_range \\<and>\n       d \\<in> wordinterval_to_set d_range", "have E: \"E = [(s, d)\\<leftarrow>all_pairs (map getOneIp ?part). runFw s d c rs = Decision FinalAllow]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E =\n    filter (\\<lambda>(s, d). runFw s d c rs = Decision FinalAllow)\n     (all_pairs (map getOneIp (build_ip_partition c rs)))", "using matrix"], ["proof (prove)\nusing this:\n  (V, E) = access_matrix c rs\n\ngoal (1 subgoal):\n 1. E =\n    filter (\\<lambda>(s, d). runFw s d c rs = Decision FinalAllow)\n     (all_pairs (map getOneIp (build_ip_partition c rs)))", "by(simp add: access_matrix_def Let_def)"], ["proof (state)\nthis:\n  E =\n  filter (\\<lambda>(s, d). runFw s d c rs = Decision FinalAllow)\n   (all_pairs (map getOneIp (build_ip_partition c rs)))\n\ngoal (1 subgoal):\n 1. \\<exists>s_repr d_repr s_range d_range.\n       (s_repr, d_repr) \\<in> set E \\<and>\n       map_of V s_repr = Some s_range \\<and>\n       s \\<in> wordinterval_to_set s_range \\<and>\n       map_of V d_repr = Some d_range \\<and>\n       d \\<in> wordinterval_to_set d_range", "have build_ip_partition_obtain:\n      \"\\<exists>V. V \\<in> set (build_ip_partition c rs) \\<and> s \\<in> wordinterval_to_set V\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>V.\n       V \\<in> set (build_ip_partition c rs) \\<and>\n       s \\<in> wordinterval_to_set V", "using build_ip_partition_complete"], ["proof (prove)\nusing this:\n  \\<Union> (wordinterval_to_set ` set (build_ip_partition ?c ?rs)) = UNIV\n\ngoal (1 subgoal):\n 1. \\<exists>V.\n       V \\<in> set (build_ip_partition c rs) \\<and>\n       s \\<in> wordinterval_to_set V", "by blast"], ["proof (state)\nthis:\n  \\<exists>V.\n     V \\<in> set (build_ip_partition c rs) \\<and>\n     ?s \\<in> wordinterval_to_set V\n\ngoal (1 subgoal):\n 1. \\<exists>s_repr d_repr s_range d_range.\n       (s_repr, d_repr) \\<in> set E \\<and>\n       map_of V s_repr = Some s_range \\<and>\n       s \\<in> wordinterval_to_set s_range \\<and>\n       map_of V d_repr = Some d_range \\<and>\n       d \\<in> wordinterval_to_set d_range", "have distinct_map_getOneIp_build_ip_partition_obtain:\n        \"v \\<in> set (build_ip_partition c rs) \\<Longrightarrow>\n           \\<exists>s_repr. map_of (zip (map getOneIp (build_ip_partition c rs)) (build_ip_partition c rs)) s_repr = Some v\"\n      for v and rs :: \"'i::len simple_rule list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> set (build_ip_partition c rs) \\<Longrightarrow>\n    \\<exists>s_repr.\n       map_of\n        (zip (map getOneIp (build_ip_partition c rs))\n          (build_ip_partition c rs))\n        s_repr =\n       Some v", "proof(erule distinct_map_getOneIp_obtain)"], ["proof (state)\ngoal (1 subgoal):\n 1. distinct (map getOneIp (build_ip_partition c rs))", "show \"distinct (map getOneIp (build_ip_partition c rs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map getOneIp (build_ip_partition c rs))", "apply(rule map_getOneIp_distinct)"], ["proof (prove)\ngoal (3 subgoals):\n 1. distinct (build_ip_partition c rs)\n 2. \\<forall>x1\\<in>set (build_ip_partition c rs).\n       \\<forall>x2\\<in>set (build_ip_partition c rs).\n          x1 \\<noteq> x2 \\<longrightarrow>\n          wordinterval_to_set x1 \\<inter> wordinterval_to_set x2 = {}\n 3. \\<forall>x\\<in>set (build_ip_partition c rs).\n       \\<not> wordinterval_empty x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (build_ip_partition c rs)", "using build_ip_partition_distinct'"], ["proof (prove)\nusing this:\n  distinct (build_ip_partition ?c ?rs)\n\ngoal (1 subgoal):\n 1. distinct (build_ip_partition c rs)", "by blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x1\\<in>set (build_ip_partition c rs).\n       \\<forall>x2\\<in>set (build_ip_partition c rs).\n          x1 \\<noteq> x2 \\<longrightarrow>\n          wordinterval_to_set x1 \\<inter> wordinterval_to_set x2 = {}\n 2. \\<forall>x\\<in>set (build_ip_partition c rs).\n       \\<not> wordinterval_empty x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x1\\<in>set (build_ip_partition c rs).\n       \\<forall>x2\\<in>set (build_ip_partition c rs).\n          x1 \\<noteq> x2 \\<longrightarrow>\n          wordinterval_to_set x1 \\<inter> wordinterval_to_set x2 = {}", "using build_ip_partition_disjoint build_ip_partition_distinct'"], ["proof (prove)\nusing this:\n  \\<lbrakk>?V1.0 \\<in> set (build_ip_partition ?c ?rs);\n   ?V2.0 \\<in> set (build_ip_partition ?c ?rs);\n   ?V1.0 \\<noteq> ?V2.0\\<rbrakk>\n  \\<Longrightarrow> wordinterval_to_set ?V1.0 \\<inter>\n                    wordinterval_to_set ?V2.0 =\n                    {}\n  distinct (build_ip_partition ?c ?rs)\n\ngoal (1 subgoal):\n 1. \\<forall>x1\\<in>set (build_ip_partition c rs).\n       \\<forall>x2\\<in>set (build_ip_partition c rs).\n          x1 \\<noteq> x2 \\<longrightarrow>\n          wordinterval_to_set x1 \\<inter> wordinterval_to_set x2 = {}", "by blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (build_ip_partition c rs).\n       \\<not> wordinterval_empty x", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (build_ip_partition c rs).\n       \\<not> wordinterval_empty x", "using build_ip_partition_no_empty_elems[simplified]"], ["proof (prove)\nusing this:\n  ?wi \\<in> set (build_ip_partition ?c ?rs) \\<Longrightarrow>\n  wordinterval_to_set ?wi \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (build_ip_partition c rs).\n       \\<not> wordinterval_empty x", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  distinct (map getOneIp (build_ip_partition c rs))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?v \\<in> set (build_ip_partition c ?rs) \\<Longrightarrow>\n  \\<exists>s_repr.\n     map_of\n      (zip (map getOneIp (build_ip_partition c ?rs))\n        (build_ip_partition c ?rs))\n      s_repr =\n     Some ?v\n\ngoal (1 subgoal):\n 1. \\<exists>s_repr d_repr s_range d_range.\n       (s_repr, d_repr) \\<in> set E \\<and>\n       map_of V s_repr = Some s_range \\<and>\n       s \\<in> wordinterval_to_set s_range \\<and>\n       map_of V d_repr = Some d_range \\<and>\n       d \\<in> wordinterval_to_set d_range", "from build_ip_partition_obtain"], ["proof (chain)\npicking this:\n  \\<exists>V.\n     V \\<in> set (build_ip_partition c rs) \\<and>\n     ?s \\<in> wordinterval_to_set V", "obtain s_range where\n      \"s_range \\<in> set ?part\" and \"s \\<in> wordinterval_to_set s_range\""], ["proof (prove)\nusing this:\n  \\<exists>V.\n     V \\<in> set (build_ip_partition c rs) \\<and>\n     ?s \\<in> wordinterval_to_set V\n\ngoal (1 subgoal):\n 1. (\\<And>s_range.\n        \\<lbrakk>s_range \\<in> set (build_ip_partition c rs);\n         s \\<in> wordinterval_to_set s_range\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  s_range \\<in> set (build_ip_partition c rs)\n  s \\<in> wordinterval_to_set s_range\n\ngoal (1 subgoal):\n 1. \\<exists>s_repr d_repr s_range d_range.\n       (s_repr, d_repr) \\<in> set E \\<and>\n       map_of V s_repr = Some s_range \\<and>\n       s \\<in> wordinterval_to_set s_range \\<and>\n       map_of V d_repr = Some d_range \\<and>\n       d \\<in> wordinterval_to_set d_range", "from this distinct_map_getOneIp_build_ip_partition_obtain V"], ["proof (chain)\npicking this:\n  s_range \\<in> set (build_ip_partition c rs)\n  s \\<in> wordinterval_to_set s_range\n  ?v \\<in> set (build_ip_partition c ?rs) \\<Longrightarrow>\n  \\<exists>s_repr.\n     map_of\n      (zip (map getOneIp (build_ip_partition c ?rs))\n        (build_ip_partition c ?rs))\n      s_repr =\n     Some ?v\n  V = zip (map getOneIp (build_ip_partition c rs)) (build_ip_partition c rs)", "obtain s_repr where\n      ex_s1: \"(map_of V) s_repr = Some s_range\" and ex_s2: \"s \\<in> wordinterval_to_set s_range\""], ["proof (prove)\nusing this:\n  s_range \\<in> set (build_ip_partition c rs)\n  s \\<in> wordinterval_to_set s_range\n  ?v \\<in> set (build_ip_partition c ?rs) \\<Longrightarrow>\n  \\<exists>s_repr.\n     map_of\n      (zip (map getOneIp (build_ip_partition c ?rs))\n        (build_ip_partition c ?rs))\n      s_repr =\n     Some ?v\n  V = zip (map getOneIp (build_ip_partition c rs)) (build_ip_partition c rs)\n\ngoal (1 subgoal):\n 1. (\\<And>s_repr.\n        \\<lbrakk>map_of V s_repr = Some s_range;\n         s \\<in> wordinterval_to_set s_range\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  map_of V s_repr = Some s_range\n  s \\<in> wordinterval_to_set s_range\n\ngoal (1 subgoal):\n 1. \\<exists>s_repr d_repr s_range d_range.\n       (s_repr, d_repr) \\<in> set E \\<and>\n       map_of V s_repr = Some s_range \\<and>\n       s \\<in> wordinterval_to_set s_range \\<and>\n       map_of V d_repr = Some d_range \\<and>\n       d \\<in> wordinterval_to_set d_range", "from build_ip_partition_obtain"], ["proof (chain)\npicking this:\n  \\<exists>V.\n     V \\<in> set (build_ip_partition c rs) \\<and>\n     ?s \\<in> wordinterval_to_set V", "obtain d_range where\n      \"d_range \\<in> set ?part\" and \"d \\<in> wordinterval_to_set d_range\""], ["proof (prove)\nusing this:\n  \\<exists>V.\n     V \\<in> set (build_ip_partition c rs) \\<and>\n     ?s \\<in> wordinterval_to_set V\n\ngoal (1 subgoal):\n 1. (\\<And>d_range.\n        \\<lbrakk>d_range \\<in> set (build_ip_partition c rs);\n         d \\<in> wordinterval_to_set d_range\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  d_range \\<in> set (build_ip_partition c rs)\n  d \\<in> wordinterval_to_set d_range\n\ngoal (1 subgoal):\n 1. \\<exists>s_repr d_repr s_range d_range.\n       (s_repr, d_repr) \\<in> set E \\<and>\n       map_of V s_repr = Some s_range \\<and>\n       s \\<in> wordinterval_to_set s_range \\<and>\n       map_of V d_repr = Some d_range \\<and>\n       d \\<in> wordinterval_to_set d_range", "from this distinct_map_getOneIp_build_ip_partition_obtain V"], ["proof (chain)\npicking this:\n  d_range \\<in> set (build_ip_partition c rs)\n  d \\<in> wordinterval_to_set d_range\n  ?v \\<in> set (build_ip_partition c ?rs) \\<Longrightarrow>\n  \\<exists>s_repr.\n     map_of\n      (zip (map getOneIp (build_ip_partition c ?rs))\n        (build_ip_partition c ?rs))\n      s_repr =\n     Some ?v\n  V = zip (map getOneIp (build_ip_partition c rs)) (build_ip_partition c rs)", "obtain d_repr where\n      ex_d1: \"(map_of V) d_repr = Some d_range\" and ex_d2: \"d \\<in> wordinterval_to_set d_range\""], ["proof (prove)\nusing this:\n  d_range \\<in> set (build_ip_partition c rs)\n  d \\<in> wordinterval_to_set d_range\n  ?v \\<in> set (build_ip_partition c ?rs) \\<Longrightarrow>\n  \\<exists>s_repr.\n     map_of\n      (zip (map getOneIp (build_ip_partition c ?rs))\n        (build_ip_partition c ?rs))\n      s_repr =\n     Some ?v\n  V = zip (map getOneIp (build_ip_partition c rs)) (build_ip_partition c rs)\n\ngoal (1 subgoal):\n 1. (\\<And>d_repr.\n        \\<lbrakk>map_of V d_repr = Some d_range;\n         d \\<in> wordinterval_to_set d_range\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  map_of V d_repr = Some d_range\n  d \\<in> wordinterval_to_set d_range\n\ngoal (1 subgoal):\n 1. \\<exists>s_repr d_repr s_range d_range.\n       (s_repr, d_repr) \\<in> set E \\<and>\n       map_of V s_repr = Some s_range \\<and>\n       s \\<in> wordinterval_to_set s_range \\<and>\n       map_of V d_repr = Some d_range \\<and>\n       d \\<in> wordinterval_to_set d_range", "have 1: \"s_repr \\<in> getOneIp ` set (build_ip_partition c rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s_repr \\<in> getOneIp ` set (build_ip_partition c rs)", "using V \\<open>map_of V s_repr = Some s_range\\<close>"], ["proof (prove)\nusing this:\n  V = zip (map getOneIp (build_ip_partition c rs)) (build_ip_partition c rs)\n  map_of V s_repr = Some s_range\n\ngoal (1 subgoal):\n 1. s_repr \\<in> getOneIp ` set (build_ip_partition c rs)", "by (fastforce elim: in_set_zipE dest: map_of_SomeD)"], ["proof (state)\nthis:\n  s_repr \\<in> getOneIp ` set (build_ip_partition c rs)\n\ngoal (1 subgoal):\n 1. \\<exists>s_repr d_repr s_range d_range.\n       (s_repr, d_repr) \\<in> set E \\<and>\n       map_of V s_repr = Some s_range \\<and>\n       s \\<in> wordinterval_to_set s_range \\<and>\n       map_of V d_repr = Some d_range \\<and>\n       d \\<in> wordinterval_to_set d_range", "have 2: \"d_repr \\<in> getOneIp ` set (build_ip_partition c rs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_repr \\<in> getOneIp ` set (build_ip_partition c rs)", "using V \\<open>map_of V d_repr = Some d_range\\<close>"], ["proof (prove)\nusing this:\n  V = zip (map getOneIp (build_ip_partition c rs)) (build_ip_partition c rs)\n  map_of V d_repr = Some d_range\n\ngoal (1 subgoal):\n 1. d_repr \\<in> getOneIp ` set (build_ip_partition c rs)", "by (fastforce elim: in_set_zipE dest: map_of_SomeD)"], ["proof (state)\nthis:\n  d_repr \\<in> getOneIp ` set (build_ip_partition c rs)\n\ngoal (1 subgoal):\n 1. \\<exists>s_repr d_repr s_range d_range.\n       (s_repr, d_repr) \\<in> set E \\<and>\n       map_of V s_repr = Some s_range \\<and>\n       s \\<in> wordinterval_to_set s_range \\<and>\n       map_of V d_repr = Some d_range \\<and>\n       d \\<in> wordinterval_to_set d_range", "have \"runFw s_repr d_repr c rs = Decision FinalAllow\""], ["proof (prove)\ngoal (1 subgoal):\n 1. runFw s_repr d_repr c rs = Decision FinalAllow", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. runFw s_repr d_repr c rs = Decision FinalAllow", "have f1: \"(\\<forall>w wa p ss. \\<not> same_fw_behaviour_one w wa (p::parts_connection) ss \\<or>\n              (\\<forall>wb wc. runFw w wb p ss = runFw wa wb p ss \\<and> runFw wc w p ss = runFw wc wa p ss)) \\<and>\n              (\\<forall>w wa p ss. (\\<exists>wb wc. runFw w wb (p::parts_connection) ss \\<noteq> runFw wa wb p ss \\<or> runFw wc w p ss \\<noteq> runFw wc wa p ss) \\<or>\n              same_fw_behaviour_one w wa p ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>w wa p ss.\n        \\<not> same_fw_behaviour_one w wa p ss \\<or>\n        (\\<forall>wb wc.\n            runFw w wb p ss = runFw wa wb p ss \\<and>\n            runFw wc w p ss = runFw wc wa p ss)) \\<and>\n    (\\<forall>w wa p ss.\n        (\\<exists>wb wc.\n            runFw w wb p ss \\<noteq> runFw wa wb p ss \\<or>\n            runFw wc w p ss \\<noteq> runFw wc wa p ss) \\<or>\n        same_fw_behaviour_one w wa p ss)", "unfolding same_fw_behaviour_one_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>w wa p ss.\n        \\<not> (\\<forall>d s.\n                   runFw w d p ss = runFw wa d p ss \\<and>\n                   runFw s w p ss = runFw s wa p ss) \\<or>\n        (\\<forall>wb wc.\n            runFw w wb p ss = runFw wa wb p ss \\<and>\n            runFw wc w p ss = runFw wc wa p ss)) \\<and>\n    (\\<forall>w wa p ss.\n        (\\<exists>wb wc.\n            runFw w wb p ss \\<noteq> runFw wa wb p ss \\<or>\n            runFw wc w p ss \\<noteq> runFw wc wa p ss) \\<or>\n        (\\<forall>d s.\n            runFw w d p ss = runFw wa d p ss \\<and>\n            runFw s w p ss = runFw s wa p ss))", "by blast"], ["proof (state)\nthis:\n  (\\<forall>w wa p ss.\n      \\<not> same_fw_behaviour_one w wa p ss \\<or>\n      (\\<forall>wb wc.\n          runFw w wb p ss = runFw wa wb p ss \\<and>\n          runFw wc w p ss = runFw wc wa p ss)) \\<and>\n  (\\<forall>w wa p ss.\n      (\\<exists>wb wc.\n          runFw w wb p ss \\<noteq> runFw wa wb p ss \\<or>\n          runFw wc w p ss \\<noteq> runFw wc wa p ss) \\<or>\n      same_fw_behaviour_one w wa p ss)\n\ngoal (1 subgoal):\n 1. runFw s_repr d_repr c rs = Decision FinalAllow", "from \\<open>s_range \\<in> set (build_ip_partition c rs)\\<close>"], ["proof (chain)\npicking this:\n  s_range \\<in> set (build_ip_partition c rs)", "have f2: \"same_fw_behaviour_one s s_repr c rs\""], ["proof (prove)\nusing this:\n  s_range \\<in> set (build_ip_partition c rs)\n\ngoal (1 subgoal):\n 1. same_fw_behaviour_one s s_repr c rs", "by (metis (no_types) map_of_zip_map V build_ip_partition_no_empty_elems\n            build_ip_partition_same_fw ex_s1 ex_s2 getOneIp_elem wordinterval_element_set_eq)"], ["proof (state)\nthis:\n  same_fw_behaviour_one s s_repr c rs\n\ngoal (1 subgoal):\n 1. runFw s_repr d_repr c rs = Decision FinalAllow", "from \\<open>d_range \\<in> set (build_ip_partition c rs)\\<close>"], ["proof (chain)\npicking this:\n  d_range \\<in> set (build_ip_partition c rs)", "have \"same_fw_behaviour_one d_repr d c rs\""], ["proof (prove)\nusing this:\n  d_range \\<in> set (build_ip_partition c rs)\n\ngoal (1 subgoal):\n 1. same_fw_behaviour_one d_repr d c rs", "by (metis (no_types) map_of_zip_map V build_ip_partition_no_empty_elems\n            build_ip_partition_same_fw ex_d1 ex_d2 getOneIp_elem wordinterval_element_set_eq)"], ["proof (state)\nthis:\n  same_fw_behaviour_one d_repr d c rs\n\ngoal (1 subgoal):\n 1. runFw s_repr d_repr c rs = Decision FinalAllow", "with f1 f2"], ["proof (chain)\npicking this:\n  (\\<forall>w wa p ss.\n      \\<not> same_fw_behaviour_one w wa p ss \\<or>\n      (\\<forall>wb wc.\n          runFw w wb p ss = runFw wa wb p ss \\<and>\n          runFw wc w p ss = runFw wc wa p ss)) \\<and>\n  (\\<forall>w wa p ss.\n      (\\<exists>wb wc.\n          runFw w wb p ss \\<noteq> runFw wa wb p ss \\<or>\n          runFw wc w p ss \\<noteq> runFw wc wa p ss) \\<or>\n      same_fw_behaviour_one w wa p ss)\n  same_fw_behaviour_one s s_repr c rs\n  same_fw_behaviour_one d_repr d c rs", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<forall>w wa p ss.\n      \\<not> same_fw_behaviour_one w wa p ss \\<or>\n      (\\<forall>wb wc.\n          runFw w wb p ss = runFw wa wb p ss \\<and>\n          runFw wc w p ss = runFw wc wa p ss)) \\<and>\n  (\\<forall>w wa p ss.\n      (\\<exists>wb wc.\n          runFw w wb p ss \\<noteq> runFw wa wb p ss \\<or>\n          runFw wc w p ss \\<noteq> runFw wc wa p ss) \\<or>\n      same_fw_behaviour_one w wa p ss)\n  same_fw_behaviour_one s s_repr c rs\n  same_fw_behaviour_one d_repr d c rs\n\ngoal (1 subgoal):\n 1. runFw s_repr d_repr c rs = Decision FinalAllow", "using allow"], ["proof (prove)\nusing this:\n  (\\<forall>w wa p ss.\n      \\<not> same_fw_behaviour_one w wa p ss \\<or>\n      (\\<forall>wb wc.\n          runFw w wb p ss = runFw wa wb p ss \\<and>\n          runFw wc w p ss = runFw wc wa p ss)) \\<and>\n  (\\<forall>w wa p ss.\n      (\\<exists>wb wc.\n          runFw w wb p ss \\<noteq> runFw wa wb p ss \\<or>\n          runFw wc w p ss \\<noteq> runFw wc wa p ss) \\<or>\n      same_fw_behaviour_one w wa p ss)\n  same_fw_behaviour_one s s_repr c rs\n  same_fw_behaviour_one d_repr d c rs\n  runFw s d c rs = Decision FinalAllow\n\ngoal (1 subgoal):\n 1. runFw s_repr d_repr c rs = Decision FinalAllow", "by metis"], ["proof (state)\nthis:\n  runFw s_repr d_repr c rs = Decision FinalAllow\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  runFw s_repr d_repr c rs = Decision FinalAllow\n\ngoal (1 subgoal):\n 1. \\<exists>s_repr d_repr s_range d_range.\n       (s_repr, d_repr) \\<in> set E \\<and>\n       map_of V s_repr = Some s_range \\<and>\n       s \\<in> wordinterval_to_set s_range \\<and>\n       map_of V d_repr = Some d_range \\<and>\n       d \\<in> wordinterval_to_set d_range", "hence ex1: \"(s_repr, d_repr) \\<in> set E\""], ["proof (prove)\nusing this:\n  runFw s_repr d_repr c rs = Decision FinalAllow\n\ngoal (1 subgoal):\n 1. (s_repr, d_repr) \\<in> set E", "by(simp add: E all_pairs_set 1 2)"], ["proof (state)\nthis:\n  (s_repr, d_repr) \\<in> set E\n\ngoal (1 subgoal):\n 1. \\<exists>s_repr d_repr s_range d_range.\n       (s_repr, d_repr) \\<in> set E \\<and>\n       map_of V s_repr = Some s_range \\<and>\n       s \\<in> wordinterval_to_set s_range \\<and>\n       map_of V d_repr = Some d_range \\<and>\n       d \\<in> wordinterval_to_set d_range", "thus ?thesis"], ["proof (prove)\nusing this:\n  (s_repr, d_repr) \\<in> set E\n\ngoal (1 subgoal):\n 1. \\<exists>s_repr d_repr s_range d_range.\n       (s_repr, d_repr) \\<in> set E \\<and>\n       map_of V s_repr = Some s_range \\<and>\n       s \\<in> wordinterval_to_set s_range \\<and>\n       map_of V d_repr = Some d_range \\<and>\n       d \\<in> wordinterval_to_set d_range", "using ex1 ex_s1 ex_s2 ex_d1 ex_d2"], ["proof (prove)\nusing this:\n  (s_repr, d_repr) \\<in> set E\n  (s_repr, d_repr) \\<in> set E\n  map_of V s_repr = Some s_range\n  s \\<in> wordinterval_to_set s_range\n  map_of V d_repr = Some d_range\n  d \\<in> wordinterval_to_set d_range\n\ngoal (1 subgoal):\n 1. \\<exists>s_repr d_repr s_range d_range.\n       (s_repr, d_repr) \\<in> set E \\<and>\n       map_of V s_repr = Some s_range \\<and>\n       s \\<in> wordinterval_to_set s_range \\<and>\n       map_of V d_repr = Some d_range \\<and>\n       d \\<in> wordinterval_to_set d_range", "by blast"], ["proof (state)\nthis:\n  \\<exists>s_repr d_repr s_range d_range.\n     (s_repr, d_repr) \\<in> set E \\<and>\n     map_of V s_repr = Some s_range \\<and>\n     s \\<in> wordinterval_to_set s_range \\<and>\n     map_of V d_repr = Some d_range \\<and>\n     d \\<in> wordinterval_to_set d_range\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem access_matrix:\n      fixes rs :: \"'i::len simple_rule list\"\n      assumes matrix: \"(V,E) = access_matrix c rs\"\n      shows \"(\\<exists>s_repr d_repr s_range d_range. (s_repr, d_repr) \\<in> set E \\<and>\n              (map_of V) s_repr = Some s_range \\<and> s \\<in> wordinterval_to_set s_range \\<and>\n              (map_of V) d_repr = Some d_range \\<and> d \\<in> wordinterval_to_set d_range)\n             \\<longleftrightarrow>\n             runFw s d c rs = Decision FinalAllow\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>s_repr d_repr s_range d_range.\n        (s_repr, d_repr) \\<in> set E \\<and>\n        map_of V s_repr = Some s_range \\<and>\n        s \\<in> wordinterval_to_set s_range \\<and>\n        map_of V d_repr = Some d_range \\<and>\n        d \\<in> wordinterval_to_set d_range) =\n    (runFw s d c rs = Decision FinalAllow)", "using matrix access_matrix_sound access_matrix_complete"], ["proof (prove)\nusing this:\n  (V, E) = access_matrix c rs\n  \\<lbrakk>(?V, ?E) = access_matrix ?c ?rs; (?s_repr, ?d_repr) \\<in> set ?E;\n   map_of ?V ?s_repr = Some ?s_range; ?s \\<in> wordinterval_to_set ?s_range;\n   map_of ?V ?d_repr = Some ?d_range;\n   ?d \\<in> wordinterval_to_set ?d_range\\<rbrakk>\n  \\<Longrightarrow> runFw ?s ?d ?c ?rs = Decision FinalAllow\n  \\<lbrakk>(?V, ?E) = access_matrix ?c ?rs;\n   runFw ?s ?d ?c ?rs = Decision FinalAllow\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s_repr d_repr s_range d_range.\n                       (s_repr, d_repr) \\<in> set ?E \\<and>\n                       map_of ?V s_repr = Some s_range \\<and>\n                       ?s \\<in> wordinterval_to_set s_range \\<and>\n                       map_of ?V d_repr = Some d_range \\<and>\n                       ?d \\<in> wordinterval_to_set d_range\n\ngoal (1 subgoal):\n 1. (\\<exists>s_repr d_repr s_range d_range.\n        (s_repr, d_repr) \\<in> set E \\<and>\n        map_of V s_repr = Some s_range \\<and>\n        s \\<in> wordinterval_to_set s_range \\<and>\n        map_of V d_repr = Some d_range \\<and>\n        d \\<in> wordinterval_to_set d_range) =\n    (runFw s d c rs = Decision FinalAllow)", "by blast"], ["", "text\\<open>\nFor a @{typ \"'i::len simple_rule list\"} and a fixed @{typ parts_connection}, \nwe support to partition the IP address space; for IP addresses of arbitrary length (eg., IPv4, IPv6).\n\nAll members of a partition have the same access rights:\n@{thm build_ip_partition_same_fw [no_vars]}\n\nMinimal:\n@{thm build_ip_partition_same_fw_min [no_vars]}\n\n\nThe resulting access control matrix is sound and complete:\n\n@{thm access_matrix [no_vars]}\n\nTheorem reads: \nFor a fixed connection, you can look up IP addresses (source and destination pairs) in the matrix \nif and only if the firewall accepts this src,dst IP address pair for the fixed connection.\nNote: The matrix is actually a graph (nice visualization!), you need to look up IP addresses \nin the Vertices and check the access of the representants in the edges. If you want to visualize\nthe graph (e.g. with Graphviz or tkiz): The vertices are the node description (i.e. header; \n  @{term \"dom V\"} is the label for each node which will also be referenced in the edges,\n  @{term \"ran V\"} is the human-readable description for each node (i.e. the full IP range it represents)), \nthe edges are the edges. Result looks nice. Theorem also tells us that this visualization is correct.\n\\<close>"], ["", "(*construct an ip partition and print it in some usable format\n  returns:\n  (vertices, edges) where\n  vertices = (name, list of ip addresses this vertex corresponds to)\n  and edges = (name \\<times> name) list\n\n  Note that the WordInterval is already sorted, which is important for prettyness!\n*)"], ["", "text\\<open>Only defined for @{const simple_firewall_without_interfaces}\\<close>"], ["", "definition access_matrix_pretty_ipv4\n  :: \"parts_connection \\<Rightarrow> 32 simple_rule list \\<Rightarrow> (string \\<times> string) list \\<times> (string \\<times> string) list\" \n  where\n  \"access_matrix_pretty_ipv4 c rs \\<equiv>\n    if \\<not> simple_firewall_without_interfaces rs then undefined else\n    (let (V,E) = (access_matrix c rs);\n         formatted_nodes =\n              map (\\<lambda>(v_repr, v_range). (ipv4addr_toString v_repr, ipv4addr_wordinterval_toString v_range)) V;\n         formatted_edges =\n              map (\\<lambda>(s,d). (ipv4addr_toString s, ipv4addr_toString d)) E\n     in\n      (formatted_nodes, formatted_edges)\n    )\""], ["", "definition access_matrix_pretty_ipv4_code\n  :: \"parts_connection \\<Rightarrow> 32 simple_rule list \\<Rightarrow> (string \\<times> string) list \\<times> (string \\<times> string) list\" \n  where\n  \"access_matrix_pretty_ipv4_code c rs \\<equiv>\n    if \\<not> simple_firewall_without_interfaces rs then undefined else\n    (let W = build_ip_partition c rs;\n         R = map getOneIp W;\n         U = all_pairs R\n     in\n     (zip (map ipv4addr_toString R) (map ipv4addr_wordinterval_toString W), \n      map (\\<lambda>(x,y). (ipv4addr_toString x, ipv4addr_toString y)) [(s, d)\\<leftarrow>all_pairs R. runFw s d c rs = Decision FinalAllow]))\""], ["", "lemma access_matrix_pretty_ipv4_code[code]: \"access_matrix_pretty_ipv4 = access_matrix_pretty_ipv4_code\""], ["proof (prove)\ngoal (1 subgoal):\n 1. access_matrix_pretty_ipv4 = access_matrix_pretty_ipv4_code", "by(simp add: fun_eq_iff access_matrix_pretty_ipv4_def access_matrix_pretty_ipv4_code_def Let_def access_matrix_def map_prod_fun_zip)"], ["", "definition access_matrix_pretty_ipv6\n  :: \"parts_connection \\<Rightarrow> 128 simple_rule list \\<Rightarrow> (string \\<times> string) list \\<times> (string \\<times> string) list\" \n  where\n  \"access_matrix_pretty_ipv6 c rs \\<equiv>\n    if \\<not> simple_firewall_without_interfaces rs then undefined else\n    (let (V,E) = (access_matrix c rs);\n         formatted_nodes =\n              map (\\<lambda>(v_repr, v_range). (ipv6addr_toString v_repr, ipv6addr_wordinterval_toString v_range)) V;\n         formatted_edges =\n              map (\\<lambda>(s,d). (ipv6addr_toString s, ipv6addr_toString d)) E\n     in\n      (formatted_nodes, formatted_edges)\n    )\""], ["", "definition access_matrix_pretty_ipv6_code\n  :: \"parts_connection \\<Rightarrow> 128 simple_rule list \\<Rightarrow> (string \\<times> string) list \\<times> (string \\<times> string) list\" \n  where\n  \"access_matrix_pretty_ipv6_code c rs \\<equiv>\n    if \\<not> simple_firewall_without_interfaces rs then undefined else\n    (let W = build_ip_partition c rs;\n         R = map getOneIp W;\n         U = all_pairs R\n     in\n     (zip (map ipv6addr_toString R) (map ipv6addr_wordinterval_toString W), \n      map (\\<lambda>(x,y). (ipv6addr_toString x, ipv6addr_toString y)) [(s, d)\\<leftarrow>all_pairs R. runFw s d c rs = Decision FinalAllow]))\""], ["", "lemma access_matrix_pretty_ipv6_code[code]: \"access_matrix_pretty_ipv6 = access_matrix_pretty_ipv6_code\""], ["proof (prove)\ngoal (1 subgoal):\n 1. access_matrix_pretty_ipv6 = access_matrix_pretty_ipv6_code", "by(simp add: fun_eq_iff access_matrix_pretty_ipv6_def access_matrix_pretty_ipv6_code_def Let_def access_matrix_def map_prod_fun_zip)"], ["", "definition parts_connection_ssh where\n  \"parts_connection_ssh \\<equiv> \\<lparr>pc_iiface=''1'', pc_oiface=''1'', pc_proto=TCP, pc_sport=10000, pc_dport=22\\<rparr>\""], ["", "definition parts_connection_http where\n  \"parts_connection_http \\<equiv> \\<lparr>pc_iiface=''1'', pc_oiface=''1'', pc_proto=TCP, pc_sport=10000, pc_dport=80\\<rparr>\""], ["", "definition mk_parts_connection_TCP :: \"16 word \\<Rightarrow> 16 word \\<Rightarrow> parts_connection\" where\n  \"mk_parts_connection_TCP sport dport = \\<lparr>pc_iiface=''1'', pc_oiface=''1'', pc_proto=TCP,\n                               pc_sport=sport, pc_dport=dport\\<rparr>\""], ["", "lemma \"mk_parts_connection_TCP 10000 22 = parts_connection_ssh\"\n      \"mk_parts_connection_TCP 10000 80 = parts_connection_http\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk_parts_connection_TCP 10000 22 = parts_connection_ssh &&&\n    mk_parts_connection_TCP 10000 80 = parts_connection_http", "by(simp_all add: mk_parts_connection_TCP_def parts_connection_ssh_def parts_connection_http_def)"], ["", "value[code] \"partitioningIps [WordInterval (0::ipv4addr) 0] [WordInterval 0 2, WordInterval 0 2]\""], ["", "text_raw\\<open>\nHere is an example of a really large and complicated firewall:\n\n\n\\begin{figure}\n\\centering\n\\resizebox{\\linewidth}{!}{%\n\\tikzset{every loop/.style={looseness=1}}\n\\tikzset{myptr/.style={decoration={markings,mark=at position 1 with %\n    {\\arrow[scale=2,>=latex]{>}}},shorten >=0.1cm,shorten <=0.2cm, postaction={decorate}}}%\n\\tikzset{myloop/.style={-to}}%\n\\begin{tikzpicture}\n\\node (m) at (2,-2) {$\\{224.0.0.0 .. 239.255.255.255\\}$};\n\n\\node[align=left] (inet) at (-3,8.5) {$\\{0.0.0.0 .. 126.255.255.255\\} \\cup \\{128.0.0.0 .. 131.159.13.255\\} \\cup $ \\\\ \n\t\t\t\t\t\t\t\t\t $ \\{131.159.16.0 .. 131.159.19.255\\} \\cup \\{131.159.22.0 .. 138.246.253.4\\} \\cup $ \\\\ \n\t\t\t\t\t\t\t\t\t $ \\{138.246.253.11 .. 185.86.231.255\\} \\cup \\{185.86.236.0 .. 188.1.239.85\\} \\cup $ \\\\ \n\t\t\t\t\t\t\t\t\t $ \\{188.1.239.87 .. 188.95.232.63\\} \\cup \\{188.95.232.224 .. 188.95.232.255\\} \\cup $\\\\\n\t\t\t\t\t\t\t\t\t $ \\{188.95.240.0 .. 192.48.106.255\\} \\cup \\{192.48.108.0 .. 223.255.255.255\\} \\cup $\\\\\n\t\t\t\t\t\t\t\t\t $ \\{240.0.0.0 .. 255.255.255.255\\}$};\n\\node[align=left] (internal) at (-5,-10) {$\\{131.159.14.0 .. 131.159.14.7\\} \\cup \\{131.159.14.12 .. 131.159.14.25\\} \\cup $ \\\\ \n$ 131.159.14.27 \\cup \\{131.159.14.29 .. 131.159.14.33\\} \\cup $ \\\\ \n$ \\{131.159.14.38 .. 131.159.14.39\\} \\cup 131.159.14.41 \\cup $ \\\\ \n$ \\{131.159.14.43 .. 131.159.14.51\\} \\cup \\{131.159.14.53 .. 131.159.14.55\\} \\cup $ \\\\ \n$ \\{131.159.14.57 .. 131.159.14.59\\} \\cup \\{131.159.14.61 .. 131.159.14.68\\} \\cup $ \\\\ \n$ 131.159.14.70 .. 131.159.14.82\\} \\cup \\{131.159.14.84 .. 131.159.14.103\\} \\cup $ \\\\ \n$ \\{131.159.14.105 .. 131.159.14.124\\} \\cup \\{131.159.14.126 .. 131.159.14.136\\} \\cup $ \\\\  \n$ \\{131.159.14.138 .. 131.159.14.139\\} \\cup \\{131.159.14.141 .. 131.159.14.144\\} \\cup $ \\\\ \n$ \\{131.159.14.147 .. 131.159.14.154\\} \\cup \\{131.159.14.157 .. 131.159.14.162\\} \\cup $ \\\\ \n$ \\{131.159.14.164 .. 131.159.14.168\\} \\cup \\{131.159.14.170 .. 131.159.14.200\\} \\cup $ \\\\ \n$ \\{131.159.14.202 .. 131.159.14.213\\} \\cup \\{131.159.14.215 .. 131.159.15.4\\} \\cup $ \\\\ \n$ 131.159.15.6 \\cup \\{131.159.15.14 .. 131.159.15.15\\} \\cup $ \\\\ \n$ \\{131.159.15.21 .. 131.159.15.22\\} \\cup 131.159.15.26 \\cup 131.159.15.28 \\cup $ \\\\ \n$ 131.159.15.30 \\cup \\{131.159.15.33 .. 131.159.15.35\\} \\cup $ \\\\ \n$ \\{131.159.15.37 .. 131.159.15.38\\} \\cup 131.159.15.40 \\cup $ \\\\ \n$ \\{131.159.15.45 .. 131.159.15.46\\} \\cup \\{131.159.15.48 .. 131.159.15.49\\} \\cup $ \\\\ \n$ \\{131.159.15.52 .. 131.159.15.55\\} \\cup 131.159.15.57 \\cup 131.159.15.59 \\cup $ \\\\ \n$ \\{131.159.15.61 .. 131.159.15.67\\} \\cup \\{131.159.15.70 .. 131.159.15.196\\} \\cup $ \\\\ \n$ \\{131.159.15.198 .. 131.159.15.227\\} \\cup \\{131.159.15.229 .. 131.159.15.233\\} \\cup $ \\\\ \n$ \\{131.159.15.235 .. 131.159.15.246\\} \\cup \\{131.159.15.250 .. 131.159.15.255\\} \\cup $ \\\\ \n$ \\{131.159.20.0 .. 131.159.20.20\\} \\cup \\{131.159.20.22 .. 131.159.20.28\\} \\cup $ \\\\ \n$ \\{131.159.20.30 .. 131.159.20.35\\} \\cup \\{131.159.20.37 .. 131.159.20.44\\} \\cup $ \\\\ \n$ \\{131.159.20.46 .. 131.159.20.51\\} \\cup \\{131.159.20.53 .. 131.159.20.58\\} \\cup $ \\\\ \n$ \\{131.159.20.60 .. 131.159.20.62\\} \\cup \\{131.159.20.64 .. 131.159.20.70\\} \\cup $ \\\\ \n$ \\{131.159.20.72 .. 131.159.20.73\\} \\cup \\{131.159.20.75 .. 131.159.20.84\\} \\cup $ \\\\ \n$ \\{131.159.20.86 .. 131.159.20.96\\} \\cup \\{131.159.20.98 .. 131.159.20.119\\} \\cup $ \\\\ \n$ \\{131.159.20.121 .. 131.159.20.138\\} \\cup \\{131.159.20.140 .. 131.159.20.149\\} \\cup $ \\\\ \n$ \\{131.159.20.152 .. 131.159.20.154\\} \\cup \\{131.159.20.156 .. 131.159.20.159\\} \\cup $ \\\\ \n$ \\{131.159.20.161 .. 131.159.20.164\\} \\cup \\{131.159.20.167 .. 131.159.20.179\\} \\cup $ \\\\ \n$ \\{131.159.20.181 .. 131.159.20.184\\} \\cup \\{131.159.20.186 .. 131.159.20.199\\} \\cup $ \\\\ \n$ \\{131.159.20.201 .. 131.159.20.232\\} \\cup \\{131.159.20.235 .. 131.159.20.255\\} \\cup $ \\\\ \n$ \\{185.86.232.0 .. 185.86.235.255\\} \\cup \\{188.95.233.0 .. 188.95.233.3\\} \\cup $ \\\\ \n$ \\{188.95.233.5 .. 188.95.233.8\\} \\cup \\{188.95.233.10 .. 188.95.233.255\\} \\cup $ \\\\ \n$ \\{192.48.107.0 .. 192.48.107.255\\}$}; \n\n\\node[align=left] (srvs) at (10,0) {$\\{131.159.14.8 .. 131.159.14.11\\} \\cup 131.159.14.26 \\cup 131.159.14.28 \\cup $ \\\\ \n$ \\{131.159.14.34 .. 131.159.14.37\\} \\cup 131.159.14.40 \\cup 131.159.14.42 \\cup $ \\\\ \n$ 131.159.14.52 \\cup 131.159.14.56 \\cup 131.159.14.60 \\cup 131.159.14.69 \\cup $ \\\\ \n$ 131.159.14.83 \\cup 131.159.14.104 \\cup 131.159.14.125 \\cup 131.159.14.137 \\cup $ \\\\ \n$ 131.159.14.140 \\cup \\{131.159.14.145 .. 131.159.14.146\\} \\cup $ \\\\ \n$ \\{131.159.14.155 .. 131.159.14.156\\} \\cup 131.159.14.163 \\cup 131.159.14.169 \\cup $ \\\\ \n$ 131.159.14.201 \\cup 131.159.14.214 \\cup 131.159.15.5 \\cup $ \\\\ \n$ \\{131.159.15.7 .. 131.159.15.13\\} \\cup \\{131.159.15.16 .. 131.159.15.20\\} \\cup $ \\\\ \n$ \\{131.159.15.23 .. 131.159.15.25\\} \\cup 131.159.15.27 \\cup 131.159.15.29 \\cup $ \\\\ \n$ \\{131.159.15.31 .. 131.159.15.32\\} \\cup 131.159.15.36 \\cup 131.159.15.39 \\cup $ \\\\ \n$ \\{131.159.15.41 .. 131.159.15.44\\} \\cup 131.159.15.47 \\cup 131.159.15.51 \\cup $ \\\\ \n$ 131.159.15.56 \\cup 131.159.15.58 \\cup 131.159.15.60 \\cup $ \\\\ \n$ \\{131.159.15.68 .. 131.159.15.69\\} \\cup 131.159.15.197 \\cup 131.159.15.228 \\cup $ \\\\ \n$ 131.159.15.234 \\cup \\{131.159.15.247 .. 131.159.15.249\\} \\cup 131.159.20.21 \\cup $ \\\\ \n$ 131.159.20.29 \\cup 131.159.20.36 \\cup 131.159.20.45 \\cup 131.159.20.52 \\cup $ \\\\ \n$ 131.159.20.59 \\cup 131.159.20.63 \\cup 131.159.20.71 \\cup 131.159.20.74 \\cup $ \\\\ \n$ 131.159.20.85 \\cup 131.159.20.97 \\cup 131.159.20.120 \\cup 131.159.20.139 \\cup $ \\\\ \n$ \\{131.159.20.150 .. 131.159.20.151\\} \\cup 131.159.20.155 \\cup 131.159.20.160 \\cup $ \\\\ \n$ \\{131.159.20.165 .. 131.159.20.166\\} \\cup 131.159.20.180 \\cup 131.159.20.185 \\cup $ \\\\ \n$ 131.159.20.200 \\cup \\{131.159.20.233 .. 131.159.20.234\\} \\cup $ \\\\ \n$ \\{131.159.21.0 .. 131.159.21.255\\} \\cup \\{188.95.232.192 .. 188.95.232.223\\} \\cup $ \\\\ \n$ 188.95.233.4 \\cup 188.95.233.9 \\cup \\{188.95.234.0 .. 188.95.239.255\\}$}; \n\n\\node[align=left] (ips1) at (-3,-1) {$188.1.239.86 \\cup \\{188.95.232.64 .. 188.95.232.191\\}$};\n\n\\node[align=left] (ips2) at (10,-8) {$\\{138.246.253.6 .. 138.246.253.10\\}$};\n\n\\node[align=left] (ip3) at (5,-6) {$138.246.253.5$};\n\n\\node[align=left] (ip4) at (4.5,-8) {$131.159.15.50$};\n\n\\node[align=left] (l) at (8,-10) {$\\{127.0.0.0 .. 127.255.255.255\\}$};\n\n\n\n\\draw[myloop] (m) to[loop above] (m);\n\\draw[myptr] (m) to (srvs);\n\\draw[myptr] (inet) to (m);\n\\draw[myptr] (inet) to (srvs);\n\\draw[myptr,shorten <=-0.8cm] (internal) to (m);\n\\draw[myptr] (internal) to (inet);\n\\draw[myloop] (internal) to[loop above] (internal);\n\\draw[myptr] (internal) to (srvs);\n\\draw[myptr] (internal) to (ips1);\n\\draw[myptr] (internal) to (ips2);\n\\draw[myptr] (internal) to (ip3);\n\\draw[myptr] (internal) to (ip4);\n\\draw[myptr] (internal) to (l);\n\\draw[myptr] (srvs) to (m);\n\\draw[myptr] (srvs) to (inet);\n\\draw[myptr] (srvs) to (internal);\n\\draw[myloop] (srvs) to[loop above] (srvs);\n\\draw[myptr] (srvs) to (ips1);\n\\draw[myptr] (srvs) to (ips2);\n\\draw[myptr] (srvs) to (ip3);\n\\draw[myptr] (srvs) to (ip4);\n\\draw[myptr] (srvs) to (l);\n\\draw[myptr] (ips1) to (m);\n\\draw[myptr] (ips1) to (inet);\n\\draw[myptr] (ips1) to (internal);\n\\draw[myptr] (ips1) to (srvs);\n\\draw[myloop] (ips1.west) to[loop left] (ips1);\n\\draw[myptr] (ips1) to (ips2);\n\\draw[myptr] (ips1) to (ip3);\n\\draw[myptr] (ips1) to (ip4);\n\\draw[myptr] (ips1) to (l);\n\\draw[myptr] (ips2) to (m);\n\\draw[myptr] (ips2) to (srvs);\n\\draw[myptr] (ips2) to (ip4);\n\\draw[myptr] (ip3) to (m);\n\\draw[myptr] (ip3) to (internal);\n\\draw[myptr] (ip3) to (srvs);\n\\draw[myptr] (ip3) to (ip4);\n\\draw[myptr] (ip4) to (m);\n\\draw[myptr] (ip4) to (inet);\n\\draw[myptr] (ip4) to (internal);\n\\draw[myptr] (ip4) to (srvs);\n\\draw[myptr] (ip4) to (ips1);\n\\draw[myptr] (ip4) to (ips2);\n\\draw[myptr] (ip4) to (ip3);\n\\draw[myloop] (ip4) to[loop below] (ip4);\n\\draw[myptr] (ip4) to (l);\n\n\\end{tikzpicture}%\n}\n\\caption{TUM ssh Service Matrix}\n\\label{fig:tumssh}\n\\end{figure}\n\n\\<close>"], ["", "end"]]}