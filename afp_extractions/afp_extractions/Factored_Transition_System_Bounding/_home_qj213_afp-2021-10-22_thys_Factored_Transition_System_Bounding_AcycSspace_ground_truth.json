{"file_name": "/home/qj213/afp-2021-10-22/thys/Factored_Transition_System_Bounding/AcycSspace.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Factored_Transition_System_Bounding", "problem_names": ["lemma vars_change_cat:\n  fixes s\n  shows \"\n    vars_change (as1 @ as2) vs s\n    = (vars_change as1 vs s @ vars_change as2 vs (exec_plan s as1))\n  \"", "lemma empty_change_no_change:\n  fixes s\n  assumes \"(vars_change as vs s = [])\"\n  shows \"(fmrestrict_set vs (exec_plan s as) = fmrestrict_set vs s)\"", "lemma zero_change_imp_all_effects_submap:\n  fixes s s'\n  assumes \"(vars_change as vs s = [])\" \"(sat_precond_as s as)\" \"(ListMem b as)\"\n    \"(fmrestrict_set vs s = fmrestrict_set vs s')\"\n  shows \"(fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f fmrestrict_set vs s')\"", "lemma zero_change_imp_all_preconds_submap:\n  fixes s s'\n  assumes \"(vars_change as vs s = [])\" \"(sat_precond_as s as)\" \"(ListMem b as)\"\n    \"(fmrestrict_set vs s = fmrestrict_set vs s')\"\n  shows \"(fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f fmrestrict_set vs s')\"", "lemma no_vs_change_valid_in_snapshot:\n  assumes \"(as \\<in> valid_plans PROB)\" \"(sat_precond_as s as)\" \"(vars_change as vs s = [])\"\n  shows \"(as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s)))\"", "lemma no_vs_change_obtain_snapshot_bound_1st_step:\n  fixes PROB :: \"'a problem\"\n  assumes \"finite PROB\" \"(vars_change as vs s = [])\" \"(sat_precond_as s as)\"\n    \"(s \\<in> valid_states PROB)\" \"(as \\<in> valid_plans PROB)\"\n  shows \"(\\<exists>as'.\n    (\n      exec_plan (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as\n      = exec_plan (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as'\n    )\n    \\<and> (subseq as' as)\n    \\<and> (length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s)))\n  )\"", "lemma no_vs_change_obtain_snapshot_bound_2nd_step:\n  fixes PROB :: \"'a problem\"\n  assumes \"finite PROB\" \"(vars_change as vs s = [])\" \"(sat_precond_as s as)\"\n    \"(s \\<in> valid_states PROB)\" \"(as \\<in> valid_plans PROB)\"\n  shows \"(\\<exists>as'.\n    (\n      exec_plan (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))  s) as\n      = exec_plan (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as'\n    )\n    \\<and> (subseq as' as)\n    \\<and> (sat_precond_as s as')\n    \\<and> (length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s)))\n  )\"", "lemma no_vs_change_obtain_snapshot_bound_3rd_step:\n  assumes \"finite (PROB :: 'a problem)\" \"(vars_change as vs s = [])\" \"(no_effectless_act as)\"\n    \"(sat_precond_as s as)\" \"(s \\<in> valid_states PROB)\" \"(as \\<in> valid_plans PROB)\"\n  shows \"(\\<exists>as'.\n    (\n      fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) (exec_plan s as)\n      = fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) (exec_plan s as')\n    )\n    \\<and> (subseq as' as)\n    \\<and> (length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s)))\n  )\"", "lemma no_vs_change_snapshot_s_vs_is_valid_bound_i:\n  fixes PROB :: \"'a problem\"\n  assumes  \"finite PROB\" \"(vars_change as vs s = [])\" \"(no_effectless_act as)\"\n    \"(sat_precond_as s as)\" \"(s \\<in> valid_states PROB)\" \"(as \\<in> valid_plans PROB)\"\n    \"fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) (exec_plan s as) =\n        fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) (exec_plan s as')\"\n    \"subseq as' as\" \"length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\"\n  shows\n    \"fmrestrict_set (fmdom' (exec_plan s as) - prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (exec_plan s as)\n      = fmrestrict_set (fmdom' (exec_plan s as) - prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        s\n    \\<and> fmrestrict_set (fmdom' (exec_plan s as') - prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (exec_plan s as')\n      = fmrestrict_set (fmdom' (exec_plan s as') - prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        s\"", "lemma no_vs_change_snapshot_s_vs_is_valid_bound:\n  fixes PROB :: \"'a problem\"\n  assumes \"finite PROB\" \"(vars_change as vs s = [])\" \"(no_effectless_act as)\"\n    \"(sat_precond_as s as)\" \"(s \\<in> valid_states PROB)\" \"(as \\<in> valid_plans PROB)\"\n  shows \"(\\<exists>as'.\n    (exec_plan s as = exec_plan s as')\n    \\<and> (subseq as' as)\n    \\<and> (length as' <= problem_plan_bound (snapshot PROB (fmrestrict_set vs s)))\n  )\"", "lemma snapshot_bound_leq_S:\n  shows \"\n    problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n    \\<le> S vs lss PROB (fmrestrict_set vs s)\n  \"", "lemma S_geq_S_succ_plus_ell:\n  assumes \"(s \\<in> valid_states PROB)\"\n    \"(top_sorted_abs (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss)\"\n    \"(s' \\<in> state_successors (prob_proj PROB vs) s)\" \"(set lss = valid_states (prob_proj PROB vs))\"\n  shows \"(\n    problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n      + S vs lss PROB (fmrestrict_set vs s')\n      + (1 :: nat)\n    \\<le> S vs lss PROB (fmrestrict_set vs s)\n  )\"", "lemma vars_change_cons:\n  fixes s s'\n  assumes \"(vars_change as vs s = (s' # ss))\"\n  shows \"(\\<exists>as1 act as2.\n    (as = as1 @ (act # as2))\n    \\<and> (vars_change as1 vs s = [])\n    \\<and> (state_succ (exec_plan s as1) act = s')\n    \\<and> (vars_change as2 vs (state_succ (exec_plan s as1) act) = ss)\n  )\"", "lemma vars_change_cons_2:\n  fixes s s'\n  assumes \"(vars_change as vs s = (s' # ss))\"\n  shows \"(fmrestrict_set vs s' \\<noteq> fmrestrict_set vs s)\"", "lemma problem_plan_bound_S_bound_1st_step:\n  fixes PROB :: \"'a problem\"\n  assumes \"finite PROB\" \"(top_sorted_abs (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss)\"\n    \"(set lss = valid_states (prob_proj PROB vs))\" \"(s \\<in> valid_states PROB)\"\n    \"(as \\<in> valid_plans PROB)\" \"(no_effectless_act as)\" \"(sat_precond_as s as)\"\n  shows \"(\\<exists>as'.\n      (exec_plan s as' = exec_plan s as)\n      \\<and> (subseq as' as)\n      \\<and> (length as' <= S vs lss PROB (fmrestrict_set vs s))\n    )\"", "lemma problem_plan_bound_S_bound_2nd_step:\n  assumes \"finite (PROB :: 'a problem)\"\n    \"(top_sorted_abs (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss)\"\n    \"(set lss = valid_states (prob_proj PROB vs))\" \"(s \\<in> valid_states PROB)\"\n    \"(as \\<in> valid_plans PROB)\"\n  shows \"(\\<exists>as'.\n    (exec_plan s as' = exec_plan s as)\n    \\<and> (subseq as' as)\n    \\<and> (length as' \\<le> S vs lss PROB (fmrestrict_set vs s))\n  )\"", "lemma S_in_MPLS_leq_2_pow_n:\n  assumes \"finite (PROB :: 'a problem)\"\n    \"(top_sorted_abs (\\<lambda> x y. y \\<in> state_successors (prob_proj PROB vs) x) lss)\"\n    \"(set lss = valid_states (prob_proj PROB vs))\" \"(s \\<in> valid_states PROB)\"\n    \"(as \\<in> valid_plans PROB)\"\n  shows \"(\\<exists>as'.\n      (exec_plan s as' = exec_plan s as)\n      \\<and> (subseq as' as)\n      \\<and> (length as' \\<le> Sup {S vs lss PROB s' | s'. s' \\<in> valid_states (prob_proj PROB  vs)})\n    )\"", "lemma problem_plan_bound_S_bound:\n  fixes PROB :: \"'a problem\"\n  assumes \"finite PROB\" \"(top_sorted_abs (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss)\"\n    \"(set lss = valid_states (prob_proj PROB vs))\"\n  shows \"\n    problem_plan_bound PROB\n    \\<le> Sup {S vs lss PROB (s' :: 'a state) | s'. s' \\<in> valid_states (prob_proj PROB vs)}\n  \"", "lemma problem_plan_bound_S_bound_2nd_step_thesis:\n  assumes \"finite (PROB :: 'a problem)\" \"(sspace_DAG (prob_proj PROB vs) lss)\"\n    \"(s \\<in> valid_states PROB)\" \"(as \\<in> valid_plans PROB)\"\n  shows \"(\\<exists>as'.   (exec_plan s as' = exec_plan s as)\n    \\<and> (subseq as' as)\n    \\<and> (length as' \\<le> S vs lss PROB (fmrestrict_set vs s))\n  )\"", "theorem problem_plan_bound_S_bound_thesis:\n  assumes \"finite (PROB :: 'a problem)\" \"(sspace_DAG (prob_proj PROB vs) lss)\"\n  shows \"(\n    problem_plan_bound PROB\n    \\<le> Sup {S vs lss PROB s' | s'. s' \\<in> valid_states (prob_proj PROB vs)}\n  )\""], "translations": [["", "lemma vars_change_cat:\n  fixes s\n  shows \"\n    vars_change (as1 @ as2) vs s\n    = (vars_change as1 vs s @ vars_change as2 vs (exec_plan s as1))\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_change (as1 @ as2) vs s =\n    vars_change as1 vs s @ vars_change as2 vs (exec_plan s as1)", "by (induction as1 arbitrary: s as2 vs) auto"], ["", "lemma empty_change_no_change:\n  fixes s\n  assumes \"(vars_change as vs s = [])\"\n  shows \"(fmrestrict_set vs (exec_plan s as) = fmrestrict_set vs s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrestrict_set vs (exec_plan s as) = fmrestrict_set vs s", "using assms"], ["proof (prove)\nusing this:\n  vars_change as vs s = []\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (exec_plan s as) = fmrestrict_set vs s", "proof (induction as arbitrary: s vs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s vs.\n       vars_change [] vs s = [] \\<Longrightarrow>\n       fmrestrict_set vs (exec_plan s []) = fmrestrict_set vs s\n 2. \\<And>a as s vs.\n       \\<lbrakk>\\<And>s vs.\n                   vars_change as vs s = [] \\<Longrightarrow>\n                   fmrestrict_set vs (exec_plan s as) = fmrestrict_set vs s;\n        vars_change (a # as) vs s = []\\<rbrakk>\n       \\<Longrightarrow> fmrestrict_set vs (exec_plan s (a # as)) =\n                         fmrestrict_set vs s", "case (Cons a as)"], ["proof (state)\nthis:\n  vars_change as ?vs ?s = [] \\<Longrightarrow>\n  fmrestrict_set ?vs (exec_plan ?s as) = fmrestrict_set ?vs ?s\n  vars_change (a # as) vs s = []\n\ngoal (2 subgoals):\n 1. \\<And>s vs.\n       vars_change [] vs s = [] \\<Longrightarrow>\n       fmrestrict_set vs (exec_plan s []) = fmrestrict_set vs s\n 2. \\<And>a as s vs.\n       \\<lbrakk>\\<And>s vs.\n                   vars_change as vs s = [] \\<Longrightarrow>\n                   fmrestrict_set vs (exec_plan s as) = fmrestrict_set vs s;\n        vars_change (a # as) vs s = []\\<rbrakk>\n       \\<Longrightarrow> fmrestrict_set vs (exec_plan s (a # as)) =\n                         fmrestrict_set vs s", "then"], ["proof (chain)\npicking this:\n  vars_change as ?vs ?s = [] \\<Longrightarrow>\n  fmrestrict_set ?vs (exec_plan ?s as) = fmrestrict_set ?vs ?s\n  vars_change (a # as) vs s = []", "show ?case"], ["proof (prove)\nusing this:\n  vars_change as ?vs ?s = [] \\<Longrightarrow>\n  fmrestrict_set ?vs (exec_plan ?s as) = fmrestrict_set ?vs ?s\n  vars_change (a # as) vs s = []\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (exec_plan s (a # as)) = fmrestrict_set vs s", "proof (cases \"fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>vs s.\n                vars_change as vs s = [] \\<Longrightarrow>\n                fmrestrict_set vs (exec_plan s as) = fmrestrict_set vs s;\n     vars_change (a # as) vs s = [];\n     fmrestrict_set vs (state_succ s a) \\<noteq>\n     fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (exec_plan s (a # as)) =\n                      fmrestrict_set vs s\n 2. \\<lbrakk>\\<And>vs s.\n                vars_change as vs s = [] \\<Longrightarrow>\n                fmrestrict_set vs (exec_plan s as) = fmrestrict_set vs s;\n     vars_change (a # as) vs s = [];\n     \\<not> fmrestrict_set vs (state_succ s a) \\<noteq>\n            fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (exec_plan s (a # as)) =\n                      fmrestrict_set vs s", "case True\n      \\<comment> \\<open>NOTE This case violates the induction premise @{term \"vars_change (a # as) vs s = []\"} since the\n        empty list is impossible.\\<close>"], ["proof (state)\nthis:\n  fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>vs s.\n                vars_change as vs s = [] \\<Longrightarrow>\n                fmrestrict_set vs (exec_plan s as) = fmrestrict_set vs s;\n     vars_change (a # as) vs s = [];\n     fmrestrict_set vs (state_succ s a) \\<noteq>\n     fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (exec_plan s (a # as)) =\n                      fmrestrict_set vs s\n 2. \\<lbrakk>\\<And>vs s.\n                vars_change as vs s = [] \\<Longrightarrow>\n                fmrestrict_set vs (exec_plan s as) = fmrestrict_set vs s;\n     vars_change (a # as) vs s = [];\n     \\<not> fmrestrict_set vs (state_succ s a) \\<noteq>\n            fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (exec_plan s (a # as)) =\n                      fmrestrict_set vs s", "then"], ["proof (chain)\npicking this:\n  fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s", "have \"state_succ s a # vars_change as vs (state_succ s a) = []\""], ["proof (prove)\nusing this:\n  fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s\n\ngoal (1 subgoal):\n 1. state_succ s a # vars_change as vs (state_succ s a) = []", "using Cons.prems True"], ["proof (prove)\nusing this:\n  fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s\n  vars_change (a # as) vs s = []\n  fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s\n\ngoal (1 subgoal):\n 1. state_succ s a # vars_change as vs (state_succ s a) = []", "by simp"], ["proof (state)\nthis:\n  state_succ s a # vars_change as vs (state_succ s a) = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>vs s.\n                vars_change as vs s = [] \\<Longrightarrow>\n                fmrestrict_set vs (exec_plan s as) = fmrestrict_set vs s;\n     vars_change (a # as) vs s = [];\n     fmrestrict_set vs (state_succ s a) \\<noteq>\n     fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (exec_plan s (a # as)) =\n                      fmrestrict_set vs s\n 2. \\<lbrakk>\\<And>vs s.\n                vars_change as vs s = [] \\<Longrightarrow>\n                fmrestrict_set vs (exec_plan s as) = fmrestrict_set vs s;\n     vars_change (a # as) vs s = [];\n     \\<not> fmrestrict_set vs (state_succ s a) \\<noteq>\n            fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (exec_plan s (a # as)) =\n                      fmrestrict_set vs s", "then"], ["proof (chain)\npicking this:\n  state_succ s a # vars_change as vs (state_succ s a) = []", "show \"fmrestrict_set vs (exec_plan s (a # as)) = fmrestrict_set vs s\""], ["proof (prove)\nusing this:\n  state_succ s a # vars_change as vs (state_succ s a) = []\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (exec_plan s (a # as)) = fmrestrict_set vs s", "by blast"], ["proof (state)\nthis:\n  fmrestrict_set vs (exec_plan s (a # as)) = fmrestrict_set vs s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>vs s.\n                vars_change as vs s = [] \\<Longrightarrow>\n                fmrestrict_set vs (exec_plan s as) = fmrestrict_set vs s;\n     vars_change (a # as) vs s = [];\n     \\<not> fmrestrict_set vs (state_succ s a) \\<noteq>\n            fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (exec_plan s (a # as)) =\n                      fmrestrict_set vs s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>vs s.\n                vars_change as vs s = [] \\<Longrightarrow>\n                fmrestrict_set vs (exec_plan s as) = fmrestrict_set vs s;\n     vars_change (a # as) vs s = [];\n     \\<not> fmrestrict_set vs (state_succ s a) \\<noteq>\n            fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (exec_plan s (a # as)) =\n                      fmrestrict_set vs s", "case False"], ["proof (state)\nthis:\n  \\<not> fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>vs s.\n                vars_change as vs s = [] \\<Longrightarrow>\n                fmrestrict_set vs (exec_plan s as) = fmrestrict_set vs s;\n     vars_change (a # as) vs s = [];\n     \\<not> fmrestrict_set vs (state_succ s a) \\<noteq>\n            fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (exec_plan s (a # as)) =\n                      fmrestrict_set vs s", "then"], ["proof (chain)\npicking this:\n  \\<not> fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s", "have \"vars_change as vs (state_succ s a) = []\""], ["proof (prove)\nusing this:\n  \\<not> fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s\n\ngoal (1 subgoal):\n 1. vars_change as vs (state_succ s a) = []", "using Cons.prems False"], ["proof (prove)\nusing this:\n  \\<not> fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s\n  vars_change (a # as) vs s = []\n  \\<not> fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s\n\ngoal (1 subgoal):\n 1. vars_change as vs (state_succ s a) = []", "by force"], ["proof (state)\nthis:\n  vars_change as vs (state_succ s a) = []\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>vs s.\n                vars_change as vs s = [] \\<Longrightarrow>\n                fmrestrict_set vs (exec_plan s as) = fmrestrict_set vs s;\n     vars_change (a # as) vs s = [];\n     \\<not> fmrestrict_set vs (state_succ s a) \\<noteq>\n            fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (exec_plan s (a # as)) =\n                      fmrestrict_set vs s", "then"], ["proof (chain)\npicking this:\n  vars_change as vs (state_succ s a) = []", "have\n      \"fmrestrict_set vs (exec_plan (state_succ s a) as) = fmrestrict_set vs (state_succ s a)\""], ["proof (prove)\nusing this:\n  vars_change as vs (state_succ s a) = []\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (exec_plan (state_succ s a) as) =\n    fmrestrict_set vs (state_succ s a)", "using Cons.IH[of vs \"(state_succ s a)\"]"], ["proof (prove)\nusing this:\n  vars_change as vs (state_succ s a) = []\n  vars_change as vs (state_succ s a) = [] \\<Longrightarrow>\n  fmrestrict_set vs (exec_plan (state_succ s a) as) =\n  fmrestrict_set vs (state_succ s a)\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (exec_plan (state_succ s a) as) =\n    fmrestrict_set vs (state_succ s a)", "by blast"], ["proof (state)\nthis:\n  fmrestrict_set vs (exec_plan (state_succ s a) as) =\n  fmrestrict_set vs (state_succ s a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>vs s.\n                vars_change as vs s = [] \\<Longrightarrow>\n                fmrestrict_set vs (exec_plan s as) = fmrestrict_set vs s;\n     vars_change (a # as) vs s = [];\n     \\<not> fmrestrict_set vs (state_succ s a) \\<noteq>\n            fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (exec_plan s (a # as)) =\n                      fmrestrict_set vs s", "then"], ["proof (chain)\npicking this:\n  fmrestrict_set vs (exec_plan (state_succ s a) as) =\n  fmrestrict_set vs (state_succ s a)", "show \"fmrestrict_set vs (exec_plan s (a # as)) = fmrestrict_set vs s\""], ["proof (prove)\nusing this:\n  fmrestrict_set vs (exec_plan (state_succ s a) as) =\n  fmrestrict_set vs (state_succ s a)\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (exec_plan s (a # as)) = fmrestrict_set vs s", "using False"], ["proof (prove)\nusing this:\n  fmrestrict_set vs (exec_plan (state_succ s a) as) =\n  fmrestrict_set vs (state_succ s a)\n  \\<not> fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (exec_plan s (a # as)) = fmrestrict_set vs s", "by simp"], ["proof (state)\nthis:\n  fmrestrict_set vs (exec_plan s (a # as)) = fmrestrict_set vs s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fmrestrict_set vs (exec_plan s (a # as)) = fmrestrict_set vs s\n\ngoal (1 subgoal):\n 1. \\<And>s vs.\n       vars_change [] vs s = [] \\<Longrightarrow>\n       fmrestrict_set vs (exec_plan s []) = fmrestrict_set vs s", "qed auto\n\n\n\\<comment> \\<open>NOTE renamed variable `a` to `b` to not conflict with naming for list head in induction step.\\<close>"], ["", "lemma zero_change_imp_all_effects_submap:\n  fixes s s'\n  assumes \"(vars_change as vs s = [])\" \"(sat_precond_as s as)\" \"(ListMem b as)\"\n    \"(fmrestrict_set vs s = fmrestrict_set vs s')\"\n  shows \"(fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f fmrestrict_set vs s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'", "using assms"], ["proof (prove)\nusing this:\n  vars_change as vs s = []\n  sat_precond_as s as\n  ListMem b as\n  fmrestrict_set vs s = fmrestrict_set vs s'\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'", "proof (induction as arbitrary: s s' vs b)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s s' vs b.\n       \\<lbrakk>vars_change [] vs s = []; sat_precond_as s []; ListMem b [];\n        fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n       \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                         fmrestrict_set vs s'\n 2. \\<And>a as s s' vs b.\n       \\<lbrakk>\\<And>s s' vs b.\n                   \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                    ListMem b as;\n                    fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                   \\<Longrightarrow> fmrestrict_set vs\n(snd b) \\<subseteq>\\<^sub>f\n                                     fmrestrict_set vs s';\n        vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n        ListMem b (a # as);\n        fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n       \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                         fmrestrict_set vs s'", "case (Cons a as)\n    \\<comment> \\<open>NOTE Having either @{term \"fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s\"} or\n    @{term \"\\<not>ListMem b as\"} leads to simpler propositions so we split here.\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>vars_change as ?vs ?s = []; sat_precond_as ?s as; ListMem ?b as;\n   fmrestrict_set ?vs ?s = fmrestrict_set ?vs ?s'\\<rbrakk>\n  \\<Longrightarrow> fmrestrict_set ?vs (snd ?b) \\<subseteq>\\<^sub>f\n                    fmrestrict_set ?vs ?s'\n  vars_change (a # as) vs s = []\n  sat_precond_as s (a # as)\n  ListMem b (a # as)\n  fmrestrict_set vs s = fmrestrict_set vs s'\n\ngoal (2 subgoals):\n 1. \\<And>s s' vs b.\n       \\<lbrakk>vars_change [] vs s = []; sat_precond_as s []; ListMem b [];\n        fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n       \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                         fmrestrict_set vs s'\n 2. \\<And>a as s s' vs b.\n       \\<lbrakk>\\<And>s s' vs b.\n                   \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                    ListMem b as;\n                    fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                   \\<Longrightarrow> fmrestrict_set vs\n(snd b) \\<subseteq>\\<^sub>f\n                                     fmrestrict_set vs s';\n        vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n        ListMem b (a # as);\n        fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n       \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                         fmrestrict_set vs s'", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>vars_change as ?vs ?s = []; sat_precond_as ?s as; ListMem ?b as;\n   fmrestrict_set ?vs ?s = fmrestrict_set ?vs ?s'\\<rbrakk>\n  \\<Longrightarrow> fmrestrict_set ?vs (snd ?b) \\<subseteq>\\<^sub>f\n                    fmrestrict_set ?vs ?s'\n  vars_change (a # as) vs s = []\n  sat_precond_as s (a # as)\n  ListMem b (a # as)\n  fmrestrict_set vs s = fmrestrict_set vs s'", "show \"(fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f fmrestrict_set vs s')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>vars_change as ?vs ?s = []; sat_precond_as ?s as; ListMem ?b as;\n   fmrestrict_set ?vs ?s = fmrestrict_set ?vs ?s'\\<rbrakk>\n  \\<Longrightarrow> fmrestrict_set ?vs (snd ?b) \\<subseteq>\\<^sub>f\n                    fmrestrict_set ?vs ?s'\n  vars_change (a # as) vs s = []\n  sat_precond_as s (a # as)\n  ListMem b (a # as)\n  fmrestrict_set vs s = fmrestrict_set vs s'\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>vars_change as ?vs ?s = []; sat_precond_as ?s as; ListMem ?b as;\n   fmrestrict_set ?vs ?s = fmrestrict_set ?vs ?s'\\<rbrakk>\n  \\<Longrightarrow> fmrestrict_set ?vs (snd ?b) \\<subseteq>\\<^sub>f\n                    fmrestrict_set ?vs ?s'\n  vars_change (a # as) vs s = []\n  sat_precond_as s (a # as)\n  ListMem b (a # as)\n  fmrestrict_set vs s = fmrestrict_set vs s'\n  vars_change (a # as) vs s = []\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'", "proof (cases \"fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and> ListMem b as\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>vs s b s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (snd b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n     ListMem b as\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'\n 2. \\<lbrakk>\\<And>vs s b s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (snd b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n             ListMem b as)\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "case True"], ["proof (state)\nthis:\n  fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n  ListMem b as\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>vs s b s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (snd b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n     ListMem b as\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'\n 2. \\<lbrakk>\\<And>vs s b s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (snd b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n             ListMem b as)\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "let ?s=\"state_succ s a\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>vs s b s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (snd b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n     ListMem b as\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'\n 2. \\<lbrakk>\\<And>vs s b s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (snd b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n             ListMem b as)\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "have \"vars_change as vs ?s = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_change as vs (state_succ s a) = []", "using True Cons.prems(1)"], ["proof (prove)\nusing this:\n  fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n  ListMem b as\n  vars_change (a # as) vs s = []\n\ngoal (1 subgoal):\n 1. vars_change as vs (state_succ s a) = []", "by auto"], ["proof (state)\nthis:\n  vars_change as vs (state_succ s a) = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>vs s b s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (snd b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n     ListMem b as\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'\n 2. \\<lbrakk>\\<And>vs s b s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (snd b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n             ListMem b as)\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "moreover"], ["proof (state)\nthis:\n  vars_change as vs (state_succ s a) = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>vs s b s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (snd b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n     ListMem b as\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'\n 2. \\<lbrakk>\\<And>vs s b s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (snd b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n             ListMem b as)\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "have \"sat_precond_as ?s as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat_precond_as (state_succ s a) as", "using Cons.prems(2) sat_precond_as.simps(2)"], ["proof (prove)\nusing this:\n  sat_precond_as s (a # as)\n  sat_precond_as ?s (?a # ?as) =\n  (fst ?a \\<subseteq>\\<^sub>f ?s \\<and>\n   sat_precond_as (state_succ ?s ?a) ?as)\n\ngoal (1 subgoal):\n 1. sat_precond_as (state_succ s a) as", "by blast"], ["proof (state)\nthis:\n  sat_precond_as (state_succ s a) as\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>vs s b s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (snd b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n     ListMem b as\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'\n 2. \\<lbrakk>\\<And>vs s b s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (snd b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n             ListMem b as)\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "ultimately"], ["proof (chain)\npicking this:\n  vars_change as vs (state_succ s a) = []\n  sat_precond_as (state_succ s a) as", "show ?thesis"], ["proof (prove)\nusing this:\n  vars_change as vs (state_succ s a) = []\n  sat_precond_as (state_succ s a) as\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'", "using True Cons.prems(4) Cons.IH"], ["proof (prove)\nusing this:\n  vars_change as vs (state_succ s a) = []\n  sat_precond_as (state_succ s a) as\n  fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n  ListMem b as\n  fmrestrict_set vs s = fmrestrict_set vs s'\n  \\<lbrakk>vars_change as ?vs ?s = []; sat_precond_as ?s as; ListMem ?b as;\n   fmrestrict_set ?vs ?s = fmrestrict_set ?vs ?s'\\<rbrakk>\n  \\<Longrightarrow> fmrestrict_set ?vs (snd ?b) \\<subseteq>\\<^sub>f\n                    fmrestrict_set ?vs ?s'\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'", "by auto"], ["proof (state)\nthis:\n  fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>vs s b s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (snd b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n             ListMem b as)\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>vs s b s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (snd b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n             ListMem b as)\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "case False"], ["proof (state)\nthis:\n  \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n          ListMem b as)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>vs s b s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (snd b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n             ListMem b as)\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "then"], ["proof (chain)\npicking this:\n  \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n          ListMem b as)", "consider\n      (i) \"fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s\"\n      | (ii) \"\\<not>ListMem b as\""], ["proof (prove)\nusing this:\n  \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n          ListMem b as)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fmrestrict_set vs (state_succ s a) \\<noteq>\n             fmrestrict_set vs s \\<Longrightarrow>\n             thesis;\n     \\<not> ListMem b as \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>fmrestrict_set vs (state_succ s a) \\<noteq>\n           fmrestrict_set vs s \\<Longrightarrow>\n           ?thesis;\n   \\<not> ListMem b as \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>vs s b s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (snd b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n             ListMem b as)\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>fmrestrict_set vs (state_succ s a) \\<noteq>\n           fmrestrict_set vs s \\<Longrightarrow>\n           ?thesis;\n   \\<not> ListMem b as \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>fmrestrict_set vs (state_succ s a) \\<noteq>\n           fmrestrict_set vs s \\<Longrightarrow>\n           ?thesis;\n   \\<not> ListMem b as \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>fmrestrict_set vs (state_succ s a) \\<noteq>\n           fmrestrict_set vs s \\<Longrightarrow>\n           ?thesis;\n   \\<not> ListMem b as \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  vars_change (a # as) vs s = []\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>vars_change (a # as) vs s = [];\n     fmrestrict_set vs (state_succ s a) \\<noteq>\n     fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'\n 2. \\<lbrakk>vars_change (a # as) vs s = []; \\<not> ListMem b as\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "case ii"], ["proof (state)\nthis:\n  \\<not> ListMem b as\n\ngoal (2 subgoals):\n 1. \\<lbrakk>vars_change (a # as) vs s = [];\n     fmrestrict_set vs (state_succ s a) \\<noteq>\n     fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'\n 2. \\<lbrakk>vars_change (a # as) vs s = []; \\<not> ListMem b as\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "then"], ["proof (chain)\npicking this:\n  \\<not> ListMem b as", "have \"a = b\""], ["proof (prove)\nusing this:\n  \\<not> ListMem b as\n\ngoal (1 subgoal):\n 1. a = b", "using Cons.prems(3) ListMem_iff set_ConsD"], ["proof (prove)\nusing this:\n  \\<not> ListMem b as\n  ListMem b (a # as)\n  ListMem ?x ?xs = (?x \\<in> set ?xs)\n  ?y \\<in> set (?x # ?xs) \\<Longrightarrow> ?y = ?x \\<or> ?y \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. a = b", "by metis\n          \\<comment> \\<open>NOTE Mysteriously sledgehammer finds a proof here while the premises of\n            `no\\_change\\_vs\\_eff\\_submap` cannot be proven individually.\\<close>"], ["proof (state)\nthis:\n  a = b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>vars_change (a # as) vs s = [];\n     fmrestrict_set vs (state_succ s a) \\<noteq>\n     fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'\n 2. \\<lbrakk>vars_change (a # as) vs s = []; \\<not> ListMem b as\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "then"], ["proof (chain)\npicking this:\n  a = b", "show ?thesis"], ["proof (prove)\nusing this:\n  a = b\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'", "using Cons.prems(1, 2, 4) no_change_vs_eff_submap"], ["proof (prove)\nusing this:\n  a = b\n  vars_change (a # as) vs s = []\n  sat_precond_as s (a # as)\n  fmrestrict_set vs s = fmrestrict_set vs s'\n  \\<lbrakk>fmrestrict_set ?vs ?s = fmrestrict_set ?vs (state_succ ?s ?a);\n   fst ?a \\<subseteq>\\<^sub>f ?s\\<rbrakk>\n  \\<Longrightarrow> fmrestrict_set ?vs (snd ?a) \\<subseteq>\\<^sub>f\n                    fmrestrict_set ?vs ?s\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'", "by (metis list.distinct(1) sat_precond_as.simps(2) vars_change.simps(2))"], ["proof (state)\nthis:\n  fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vars_change (a # as) vs s = [];\n     fmrestrict_set vs (state_succ s a) \\<noteq>\n     fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "qed simp"], ["proof (state)\nthis:\n  fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'\n\ngoal (1 subgoal):\n 1. \\<And>s s' vs b.\n       \\<lbrakk>vars_change [] vs s = []; sat_precond_as s []; ListMem b [];\n        fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n       \\<Longrightarrow> fmrestrict_set vs (snd b) \\<subseteq>\\<^sub>f\n                         fmrestrict_set vs s'", "qed (simp add: ListMem_iff)"], ["", "lemma zero_change_imp_all_preconds_submap:\n  fixes s s'\n  assumes \"(vars_change as vs s = [])\" \"(sat_precond_as s as)\" \"(ListMem b as)\"\n    \"(fmrestrict_set vs s = fmrestrict_set vs s')\"\n  shows \"(fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f fmrestrict_set vs s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'", "using assms"], ["proof (prove)\nusing this:\n  vars_change as vs s = []\n  sat_precond_as s as\n  ListMem b as\n  fmrestrict_set vs s = fmrestrict_set vs s'\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'", "proof (induction as arbitrary: vs s s')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>vs s s'.\n       \\<lbrakk>vars_change [] vs s = []; sat_precond_as s []; ListMem b [];\n        fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n       \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                         fmrestrict_set vs s'\n 2. \\<And>a as vs s s'.\n       \\<lbrakk>\\<And>vs s s'.\n                   \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                    ListMem b as;\n                    fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                   \\<Longrightarrow> fmrestrict_set vs\n(fst b) \\<subseteq>\\<^sub>f\n                                     fmrestrict_set vs s';\n        vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n        ListMem b (a # as);\n        fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n       \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                         fmrestrict_set vs s'", "case (Cons a as)\n    \\<comment> \\<open>NOTE Having either @{term \"fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s\"} or\n    @{term \"\\<not>ListMem b as\"} leads to simpler propositions so we split here.\\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>vars_change as ?vs ?s = []; sat_precond_as ?s as; ListMem b as;\n   fmrestrict_set ?vs ?s = fmrestrict_set ?vs ?s'\\<rbrakk>\n  \\<Longrightarrow> fmrestrict_set ?vs (fst b) \\<subseteq>\\<^sub>f\n                    fmrestrict_set ?vs ?s'\n  vars_change (a # as) vs s = []\n  sat_precond_as s (a # as)\n  ListMem b (a # as)\n  fmrestrict_set vs s = fmrestrict_set vs s'\n\ngoal (2 subgoals):\n 1. \\<And>vs s s'.\n       \\<lbrakk>vars_change [] vs s = []; sat_precond_as s []; ListMem b [];\n        fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n       \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                         fmrestrict_set vs s'\n 2. \\<And>a as vs s s'.\n       \\<lbrakk>\\<And>vs s s'.\n                   \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                    ListMem b as;\n                    fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                   \\<Longrightarrow> fmrestrict_set vs\n(fst b) \\<subseteq>\\<^sub>f\n                                     fmrestrict_set vs s';\n        vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n        ListMem b (a # as);\n        fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n       \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                         fmrestrict_set vs s'", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>vars_change as ?vs ?s = []; sat_precond_as ?s as; ListMem b as;\n   fmrestrict_set ?vs ?s = fmrestrict_set ?vs ?s'\\<rbrakk>\n  \\<Longrightarrow> fmrestrict_set ?vs (fst b) \\<subseteq>\\<^sub>f\n                    fmrestrict_set ?vs ?s'\n  vars_change (a # as) vs s = []\n  sat_precond_as s (a # as)\n  ListMem b (a # as)\n  fmrestrict_set vs s = fmrestrict_set vs s'", "show \"(fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f fmrestrict_set vs s')\""], ["proof (prove)\nusing this:\n  \\<lbrakk>vars_change as ?vs ?s = []; sat_precond_as ?s as; ListMem b as;\n   fmrestrict_set ?vs ?s = fmrestrict_set ?vs ?s'\\<rbrakk>\n  \\<Longrightarrow> fmrestrict_set ?vs (fst b) \\<subseteq>\\<^sub>f\n                    fmrestrict_set ?vs ?s'\n  vars_change (a # as) vs s = []\n  sat_precond_as s (a # as)\n  ListMem b (a # as)\n  fmrestrict_set vs s = fmrestrict_set vs s'\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>vars_change as ?vs ?s = []; sat_precond_as ?s as; ListMem b as;\n   fmrestrict_set ?vs ?s = fmrestrict_set ?vs ?s'\\<rbrakk>\n  \\<Longrightarrow> fmrestrict_set ?vs (fst b) \\<subseteq>\\<^sub>f\n                    fmrestrict_set ?vs ?s'\n  vars_change (a # as) vs s = []\n  sat_precond_as s (a # as)\n  ListMem b (a # as)\n  fmrestrict_set vs s = fmrestrict_set vs s'\n  vars_change (a # as) vs s = []\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'", "proof (cases \"fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and> ListMem b as\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>vs s s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (fst b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n     ListMem b as\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'\n 2. \\<lbrakk>\\<And>vs s s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (fst b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n             ListMem b as)\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "case True"], ["proof (state)\nthis:\n  fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n  ListMem b as\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>vs s s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (fst b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n     ListMem b as\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'\n 2. \\<lbrakk>\\<And>vs s s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (fst b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n             ListMem b as)\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "let ?s=\"state_succ s a\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>vs s s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (fst b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n     ListMem b as\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'\n 2. \\<lbrakk>\\<And>vs s s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (fst b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n             ListMem b as)\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "have \"vars_change as vs ?s = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_change as vs (state_succ s a) = []", "using True Cons.prems(1)"], ["proof (prove)\nusing this:\n  fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n  ListMem b as\n  vars_change (a # as) vs s = []\n\ngoal (1 subgoal):\n 1. vars_change as vs (state_succ s a) = []", "by auto"], ["proof (state)\nthis:\n  vars_change as vs (state_succ s a) = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>vs s s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (fst b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n     ListMem b as\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'\n 2. \\<lbrakk>\\<And>vs s s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (fst b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n             ListMem b as)\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "moreover"], ["proof (state)\nthis:\n  vars_change as vs (state_succ s a) = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>vs s s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (fst b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n     ListMem b as\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'\n 2. \\<lbrakk>\\<And>vs s s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (fst b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n             ListMem b as)\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "have \"sat_precond_as ?s as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat_precond_as (state_succ s a) as", "using Cons.prems(2) sat_precond_as.simps(2)"], ["proof (prove)\nusing this:\n  sat_precond_as s (a # as)\n  sat_precond_as ?s (?a # ?as) =\n  (fst ?a \\<subseteq>\\<^sub>f ?s \\<and>\n   sat_precond_as (state_succ ?s ?a) ?as)\n\ngoal (1 subgoal):\n 1. sat_precond_as (state_succ s a) as", "by blast"], ["proof (state)\nthis:\n  sat_precond_as (state_succ s a) as\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>vs s s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (fst b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n     ListMem b as\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'\n 2. \\<lbrakk>\\<And>vs s s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (fst b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n             ListMem b as)\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "ultimately"], ["proof (chain)\npicking this:\n  vars_change as vs (state_succ s a) = []\n  sat_precond_as (state_succ s a) as", "show ?thesis"], ["proof (prove)\nusing this:\n  vars_change as vs (state_succ s a) = []\n  sat_precond_as (state_succ s a) as\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'", "using True Cons.prems(4) Cons.IH"], ["proof (prove)\nusing this:\n  vars_change as vs (state_succ s a) = []\n  sat_precond_as (state_succ s a) as\n  fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n  ListMem b as\n  fmrestrict_set vs s = fmrestrict_set vs s'\n  \\<lbrakk>vars_change as ?vs ?s = []; sat_precond_as ?s as; ListMem b as;\n   fmrestrict_set ?vs ?s = fmrestrict_set ?vs ?s'\\<rbrakk>\n  \\<Longrightarrow> fmrestrict_set ?vs (fst b) \\<subseteq>\\<^sub>f\n                    fmrestrict_set ?vs ?s'\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'", "by auto"], ["proof (state)\nthis:\n  fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>vs s s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (fst b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n             ListMem b as)\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>vs s s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (fst b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n             ListMem b as)\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "case False"], ["proof (state)\nthis:\n  \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n          ListMem b as)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>vs s s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (fst b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n             ListMem b as)\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "then"], ["proof (chain)\npicking this:\n  \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n          ListMem b as)", "consider\n      (i) \"fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s\"\n      | (ii) \"\\<not>ListMem b as\""], ["proof (prove)\nusing this:\n  \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n          ListMem b as)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fmrestrict_set vs (state_succ s a) \\<noteq>\n             fmrestrict_set vs s \\<Longrightarrow>\n             thesis;\n     \\<not> ListMem b as \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>fmrestrict_set vs (state_succ s a) \\<noteq>\n           fmrestrict_set vs s \\<Longrightarrow>\n           ?thesis;\n   \\<not> ListMem b as \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>vs s s'.\n                \\<lbrakk>vars_change as vs s = []; sat_precond_as s as;\n                 ListMem b as;\n                 fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n                \\<Longrightarrow> fmrestrict_set vs\n                                   (fst b) \\<subseteq>\\<^sub>f\n                                  fmrestrict_set vs s';\n     vars_change (a # as) vs s = []; sat_precond_as s (a # as);\n     ListMem b (a # as); fmrestrict_set vs s = fmrestrict_set vs s';\n     vars_change (a # as) vs s = [];\n     \\<not> (fmrestrict_set vs (state_succ s a) = fmrestrict_set vs s \\<and>\n             ListMem b as)\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>fmrestrict_set vs (state_succ s a) \\<noteq>\n           fmrestrict_set vs s \\<Longrightarrow>\n           ?thesis;\n   \\<not> ListMem b as \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>fmrestrict_set vs (state_succ s a) \\<noteq>\n           fmrestrict_set vs s \\<Longrightarrow>\n           ?thesis;\n   \\<not> ListMem b as \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'", "using Cons.prems(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>fmrestrict_set vs (state_succ s a) \\<noteq>\n           fmrestrict_set vs s \\<Longrightarrow>\n           ?thesis;\n   \\<not> ListMem b as \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  vars_change (a # as) vs s = []\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>vars_change (a # as) vs s = [];\n     fmrestrict_set vs (state_succ s a) \\<noteq>\n     fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'\n 2. \\<lbrakk>vars_change (a # as) vs s = []; \\<not> ListMem b as\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "case ii"], ["proof (state)\nthis:\n  \\<not> ListMem b as\n\ngoal (2 subgoals):\n 1. \\<lbrakk>vars_change (a # as) vs s = [];\n     fmrestrict_set vs (state_succ s a) \\<noteq>\n     fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'\n 2. \\<lbrakk>vars_change (a # as) vs s = []; \\<not> ListMem b as\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "then"], ["proof (chain)\npicking this:\n  \\<not> ListMem b as", "have \"a = b\""], ["proof (prove)\nusing this:\n  \\<not> ListMem b as\n\ngoal (1 subgoal):\n 1. a = b", "using Cons.prems(3) ListMem_iff set_ConsD"], ["proof (prove)\nusing this:\n  \\<not> ListMem b as\n  ListMem b (a # as)\n  ListMem ?x ?xs = (?x \\<in> set ?xs)\n  ?y \\<in> set (?x # ?xs) \\<Longrightarrow> ?y = ?x \\<or> ?y \\<in> set ?xs\n\ngoal (1 subgoal):\n 1. a = b", "by metis"], ["proof (state)\nthis:\n  a = b\n\ngoal (2 subgoals):\n 1. \\<lbrakk>vars_change (a # as) vs s = [];\n     fmrestrict_set vs (state_succ s a) \\<noteq>\n     fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'\n 2. \\<lbrakk>vars_change (a # as) vs s = []; \\<not> ListMem b as\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "then"], ["proof (chain)\npicking this:\n  a = b", "show ?thesis"], ["proof (prove)\nusing this:\n  a = b\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'", "using Cons.prems(2, 4) fmsubset_restrict_set_mono"], ["proof (prove)\nusing this:\n  a = b\n  sat_precond_as s (a # as)\n  fmrestrict_set vs s = fmrestrict_set vs s'\n  ?m \\<subseteq>\\<^sub>f ?n \\<Longrightarrow>\n  fmrestrict_set ?A ?m \\<subseteq>\\<^sub>f fmrestrict_set ?A ?n\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'", "by (metis sat_precond_as.simps(2))"], ["proof (state)\nthis:\n  fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vars_change (a # as) vs s = [];\n     fmrestrict_set vs (state_succ s a) \\<noteq>\n     fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                      fmrestrict_set vs s'", "qed simp"], ["proof (state)\nthis:\n  fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f fmrestrict_set vs s'\n\ngoal (1 subgoal):\n 1. \\<And>vs s s'.\n       \\<lbrakk>vars_change [] vs s = []; sat_precond_as s []; ListMem b [];\n        fmrestrict_set vs s = fmrestrict_set vs s'\\<rbrakk>\n       \\<Longrightarrow> fmrestrict_set vs (fst b) \\<subseteq>\\<^sub>f\n                         fmrestrict_set vs s'", "qed (simp add: ListMem_iff)"], ["", "lemma no_vs_change_valid_in_snapshot:\n  assumes \"(as \\<in> valid_plans PROB)\" \"(sat_precond_as s as)\" \"(vars_change as vs s = [])\"\n  shows \"(as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))", "assume P: \"ListMem a as\""], ["proof (state)\nthis:\n  ListMem a as\n\ngoal (1 subgoal):\n 1. as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))", "then"], ["proof (chain)\npicking this:\n  ListMem a as", "have \"agree (fst a) (fmrestrict_set vs s)\""], ["proof (prove)\nusing this:\n  ListMem a as\n\ngoal (1 subgoal):\n 1. agree (fst a) (fmrestrict_set vs s)", "by (metis agree_imp_submap assms(2) assms(3) fmdom'_restrict_set\n          restricted_agree_imp_agree zero_change_imp_all_preconds_submap)"], ["proof (state)\nthis:\n  agree (fst a) (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))", "moreover"], ["proof (state)\nthis:\n  agree (fst a) (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))", "have \"agree (snd a) (fmrestrict_set vs s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. agree (snd a) (fmrestrict_set vs s)", "by (metis (no_types) P agree_imp_submap assms(2) assms(3) fmdom'_restrict_set\n          restricted_agree_imp_agree zero_change_imp_all_effects_submap)"], ["proof (state)\nthis:\n  agree (snd a) (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))", "ultimately"], ["proof (chain)\npicking this:\n  agree (fst a) (fmrestrict_set vs s)\n  agree (snd a) (fmrestrict_set vs s)", "have \"agree (fst a) (fmrestrict_set vs s)\" \"agree (snd a) (fmrestrict_set vs s)\""], ["proof (prove)\nusing this:\n  agree (fst a) (fmrestrict_set vs s)\n  agree (snd a) (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. agree (fst a) (fmrestrict_set vs s) &&&\n    agree (snd a) (fmrestrict_set vs s)", "by simp+"], ["proof (state)\nthis:\n  agree (fst a) (fmrestrict_set vs s)\n  agree (snd a) (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))", "}"], ["proof (state)\nthis:\n  ListMem ?a2 as \\<Longrightarrow> agree (fst ?a2) (fmrestrict_set vs s)\n  ListMem ?a2 as \\<Longrightarrow> agree (snd ?a2) (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))", "then"], ["proof (chain)\npicking this:\n  ListMem ?a2 as \\<Longrightarrow> agree (fst ?a2) (fmrestrict_set vs s)\n  ListMem ?a2 as \\<Longrightarrow> agree (snd ?a2) (fmrestrict_set vs s)", "show ?thesis"], ["proof (prove)\nusing this:\n  ListMem ?a2 as \\<Longrightarrow> agree (fst ?a2) (fmrestrict_set vs s)\n  ListMem ?a2 as \\<Longrightarrow> agree (snd ?a2) (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))", "using assms(1) as_mem_agree_valid_in_snapshot"], ["proof (prove)\nusing this:\n  ListMem ?a2 as \\<Longrightarrow> agree (fst ?a2) (fmrestrict_set vs s)\n  ListMem ?a2 as \\<Longrightarrow> agree (snd ?a2) (fmrestrict_set vs s)\n  as \\<in> valid_plans PROB\n  \\<lbrakk>\\<forall>a.\n              ListMem a ?as \\<longrightarrow>\n              agree (fst a) ?s \\<and> agree (snd a) ?s;\n   ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> ?as \\<in> valid_plans (snapshot ?PROB ?s)\n\ngoal (1 subgoal):\n 1. as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))", "by blast"], ["proof (state)\nthis:\n  as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open>NOTE type of `PROB` had to be fixed for `problem\\_plan\\_bound\\_works`.\\<close>"], ["", "lemma no_vs_change_obtain_snapshot_bound_1st_step:\n  fixes PROB :: \"'a problem\"\n  assumes \"finite PROB\" \"(vars_change as vs s = [])\" \"(sat_precond_as s as)\"\n    \"(s \\<in> valid_states PROB)\" \"(as \\<in> valid_plans PROB)\"\n  shows \"(\\<exists>as'.\n    (\n      exec_plan (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as\n      = exec_plan (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as'\n    )\n    \\<and> (subseq as' as)\n    \\<and> (length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s)))\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "let ?s=\"(fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "let ?PROB=\"(snapshot PROB (fmrestrict_set vs s))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "have \"finite (snapshot PROB (fmrestrict_set vs s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (snapshot PROB (fmrestrict_set vs s))", "using assms(1) FINITE_snapshot"], ["proof (prove)\nusing this:\n  finite PROB\n  finite ?PROB \\<Longrightarrow> finite (snapshot ?PROB ?s)\n\ngoal (1 subgoal):\n 1. finite (snapshot PROB (fmrestrict_set vs s))", "by blast"], ["proof (state)\nthis:\n  finite (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "}"], ["proof (state)\nthis:\n  finite (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "moreover"], ["proof (state)\nthis:\n  finite (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "{"], ["proof (state)\nthis:\n  finite (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "have \"\n      fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s\n      \\<in> valid_states (snapshot PROB (fmrestrict_set vs s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s\n    \\<in> valid_states (snapshot PROB (fmrestrict_set vs s))", "using assms(4) graph_plan_not_eq_last_diff_paths valid_states_snapshot"], ["proof (prove)\nusing this:\n  s \\<in> valid_states PROB\n  ?s \\<in> valid_states ?PROB \\<Longrightarrow>\n  fmrestrict_set ?vs ?s \\<in> valid_states (prob_proj ?PROB ?vs)\n  valid_states (prob_proj ?PROB (prob_dom (snapshot ?PROB ?s))) =\n  valid_states (snapshot ?PROB ?s)\n\ngoal (1 subgoal):\n 1. fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s\n    \\<in> valid_states (snapshot PROB (fmrestrict_set vs s))", "by blast"], ["proof (state)\nthis:\n  fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s\n  \\<in> valid_states (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "}"], ["proof (state)\nthis:\n  fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s\n  \\<in> valid_states (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "moreover"], ["proof (state)\nthis:\n  fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s\n  \\<in> valid_states (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "{"], ["proof (state)\nthis:\n  fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s\n  \\<in> valid_states (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "have \"as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))", "using assms(2, 3, 5) no_vs_change_valid_in_snapshot"], ["proof (prove)\nusing this:\n  vars_change as vs s = []\n  sat_precond_as s as\n  as \\<in> valid_plans PROB\n  \\<lbrakk>?as \\<in> valid_plans ?PROB; sat_precond_as ?s ?as;\n   vars_change ?as ?vs ?s = []\\<rbrakk>\n  \\<Longrightarrow> ?as\n                    \\<in> valid_plans\n                           (snapshot ?PROB (fmrestrict_set ?vs ?s))\n\ngoal (1 subgoal):\n 1. as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))", "by blast"], ["proof (state)\nthis:\n  as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "}"], ["proof (state)\nthis:\n  as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "ultimately"], ["proof (chain)\npicking this:\n  finite (snapshot PROB (fmrestrict_set vs s))\n  fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s\n  \\<in> valid_states (snapshot PROB (fmrestrict_set vs s))\n  as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (snapshot PROB (fmrestrict_set vs s))\n  fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s\n  \\<in> valid_states (snapshot PROB (fmrestrict_set vs s))\n  as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "using problem_plan_bound_works[of ?PROB ?s as]"], ["proof (prove)\nusing this:\n  finite (snapshot PROB (fmrestrict_set vs s))\n  fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s\n  \\<in> valid_states (snapshot PROB (fmrestrict_set vs s))\n  as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\n  \\<lbrakk>finite (snapshot PROB (fmrestrict_set vs s));\n   fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s\n   \\<in> valid_states (snapshot PROB (fmrestrict_set vs s));\n   as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan\n                        (fmrestrict_set\n                          (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n                          s)\n                        as =\n                       exec_plan\n                        (fmrestrict_set\n                          (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n                          s)\n                        as' \\<and>\n                       subseq as' as \\<and>\n                       length as'\n                       \\<le> problem_plan_bound\n                              (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan\n      (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n      as =\n     exec_plan\n      (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n      as' \\<and>\n     subseq as' as \\<and>\n     length as'\n     \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open>NOTE type of `PROB` had to be fixed for `no\\_vs\\_change\\_obtain\\_snapshot\\_bound\\_1st\\_step`.\\<close>"], ["", "lemma no_vs_change_obtain_snapshot_bound_2nd_step:\n  fixes PROB :: \"'a problem\"\n  assumes \"finite PROB\" \"(vars_change as vs s = [])\" \"(sat_precond_as s as)\"\n    \"(s \\<in> valid_states PROB)\" \"(as \\<in> valid_plans PROB)\"\n  shows \"(\\<exists>as'.\n    (\n      exec_plan (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))  s) as\n      = exec_plan (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as'\n    )\n    \\<and> (subseq as' as)\n    \\<and> (sat_precond_as s as')\n    \\<and> (length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s)))\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       sat_precond_as s as' \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       sat_precond_as s as' \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "obtain as'' where 1:\n    \"\n      exec_plan (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as\n      = exec_plan (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as''\"\n    \"subseq as'' as\" \"length as'' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as''.\n        \\<lbrakk>exec_plan\n                  (fmrestrict_set\n                    (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n                  as =\n                 exec_plan\n                  (fmrestrict_set\n                    (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n                  as'';\n         subseq as'' as;\n         length as''\n         \\<le> problem_plan_bound\n                (snapshot PROB (fmrestrict_set vs s))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms no_vs_change_obtain_snapshot_bound_1st_step"], ["proof (prove)\nusing this:\n  finite PROB\n  vars_change as vs s = []\n  sat_precond_as s as\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  \\<lbrakk>finite ?PROB; vars_change ?as ?vs ?s = []; sat_precond_as ?s ?as;\n   ?s \\<in> valid_states ?PROB; ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan\n                        (fmrestrict_set\n                          (prob_dom\n                            (snapshot ?PROB (fmrestrict_set ?vs ?s)))\n                          ?s)\n                        ?as =\n                       exec_plan\n                        (fmrestrict_set\n                          (prob_dom\n                            (snapshot ?PROB (fmrestrict_set ?vs ?s)))\n                          ?s)\n                        as' \\<and>\n                       subseq as' ?as \\<and>\n                       length as'\n                       \\<le> problem_plan_bound\n                              (snapshot ?PROB (fmrestrict_set ?vs ?s))\n\ngoal (1 subgoal):\n 1. (\\<And>as''.\n        \\<lbrakk>exec_plan\n                  (fmrestrict_set\n                    (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n                  as =\n                 exec_plan\n                  (fmrestrict_set\n                    (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n                  as'';\n         subseq as'' as;\n         length as''\n         \\<le> problem_plan_bound\n                (snapshot PROB (fmrestrict_set vs s))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as =\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as''\n  subseq as'' as\n  length as'' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       sat_precond_as s as' \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "let ?s'=\"(fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       sat_precond_as s as' \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "let ?as'=\"rem_condless_act ?s' [] as''\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       sat_precond_as s as' \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "have \"exec_plan ?s' as = exec_plan ?s' as''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_plan\n     (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n     as =\n    exec_plan\n     (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n     as''", "using 1(1) rem_condless_valid_1"], ["proof (prove)\nusing this:\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as =\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as''\n  exec_plan ?s ?as = exec_plan ?s (rem_condless_act ?s [] ?as)\n\ngoal (1 subgoal):\n 1. exec_plan\n     (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n     as =\n    exec_plan\n     (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n     as''", "by blast"], ["proof (state)\nthis:\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as =\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as''\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       sat_precond_as s as' \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "moreover"], ["proof (state)\nthis:\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as =\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as''\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       sat_precond_as s as' \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "have \"subseq ?as' as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subseq\n     (rem_condless_act\n       (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n       [] as'')\n     as", "using 1(2) rem_condless_valid_8 sublist_trans"], ["proof (prove)\nusing this:\n  subseq as'' as\n  subseq (rem_condless_act ?s [] ?as) ?as\n  \\<lbrakk>subseq ?l1.0 ?l2.0; subseq ?l2.0 ?l3.0\\<rbrakk>\n  \\<Longrightarrow> subseq ?l1.0 ?l3.0\n\ngoal (1 subgoal):\n 1. subseq\n     (rem_condless_act\n       (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n       [] as'')\n     as", "by blast"], ["proof (state)\nthis:\n  subseq\n   (rem_condless_act\n     (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) []\n     as'')\n   as\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       sat_precond_as s as' \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "moreover"], ["proof (state)\nthis:\n  subseq\n   (rem_condless_act\n     (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) []\n     as'')\n   as\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       sat_precond_as s as' \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "have \"sat_precond_as s ?as'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat_precond_as s\n     (rem_condless_act\n       (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n       [] as'')", "using sat_precond_drest_sat_precond rem_condless_valid_2"], ["proof (prove)\nusing this:\n  sat_precond_as (fmrestrict_set ?vs ?s) ?as \\<Longrightarrow>\n  sat_precond_as ?s ?as\n  sat_precond_as ?s (rem_condless_act ?s [] ?as)\n\ngoal (1 subgoal):\n 1. sat_precond_as s\n     (rem_condless_act\n       (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n       [] as'')", "by fast"], ["proof (state)\nthis:\n  sat_precond_as s\n   (rem_condless_act\n     (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) []\n     as'')\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       sat_precond_as s as' \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "moreover"], ["proof (state)\nthis:\n  sat_precond_as s\n   (rem_condless_act\n     (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) []\n     as'')\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       sat_precond_as s as' \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "have \"(length ?as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (rem_condless_act\n       (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n       [] as'')\n    \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "using 1 rem_condless_valid_3 le_trans"], ["proof (prove)\nusing this:\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as =\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as''\n  subseq as'' as\n  length as'' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n  length (rem_condless_act ?s [] ?as) \\<le> length ?as\n  \\<lbrakk>?i \\<le> ?j; ?j \\<le> ?k\\<rbrakk> \\<Longrightarrow> ?i \\<le> ?k\n\ngoal (1 subgoal):\n 1. length\n     (rem_condless_act\n       (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n       [] as'')\n    \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "by blast"], ["proof (state)\nthis:\n  length\n   (rem_condless_act\n     (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) []\n     as'')\n  \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       sat_precond_as s as' \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "ultimately"], ["proof (chain)\npicking this:\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as =\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as''\n  subseq\n   (rem_condless_act\n     (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) []\n     as'')\n   as\n  sat_precond_as s\n   (rem_condless_act\n     (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) []\n     as'')\n  length\n   (rem_condless_act\n     (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) []\n     as'')\n  \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "show ?thesis"], ["proof (prove)\nusing this:\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as =\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as''\n  subseq\n   (rem_condless_act\n     (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) []\n     as'')\n   as\n  sat_precond_as s\n   (rem_condless_act\n     (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) []\n     as'')\n  length\n   (rem_condless_act\n     (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) []\n     as'')\n  \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       sat_precond_as s as' \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "using 1 rem_condless_valid_1"], ["proof (prove)\nusing this:\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as =\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as''\n  subseq\n   (rem_condless_act\n     (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) []\n     as'')\n   as\n  sat_precond_as s\n   (rem_condless_act\n     (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) []\n     as'')\n  length\n   (rem_condless_act\n     (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) []\n     as'')\n  \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as =\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as''\n  subseq as'' as\n  length as'' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n  exec_plan ?s ?as = exec_plan ?s (rem_condless_act ?s [] ?as)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as =\n       exec_plan\n        (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n        as' \\<and>\n       subseq as' as \\<and>\n       sat_precond_as s as' \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "by auto"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan\n      (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n      as =\n     exec_plan\n      (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n      as' \\<and>\n     subseq as' as \\<and>\n     sat_precond_as s as' \\<and>\n     length as'\n     \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_vs_change_obtain_snapshot_bound_3rd_step:\n  assumes \"finite (PROB :: 'a problem)\" \"(vars_change as vs s = [])\" \"(no_effectless_act as)\"\n    \"(sat_precond_as s as)\" \"(s \\<in> valid_states PROB)\" \"(as \\<in> valid_plans PROB)\"\n  shows \"(\\<exists>as'.\n    (\n      fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) (exec_plan s as)\n      = fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) (exec_plan s as')\n    )\n    \\<and> (subseq as' as)\n    \\<and> (length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s)))\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (exec_plan s as) =\n       fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (exec_plan s as') \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (exec_plan s as) =\n       fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (exec_plan s as') \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "obtain as' :: \"(('a, bool) fmap \\<times> ('a, bool) fmap) list\" where\n    \"(\n      exec_plan (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as\n      = exec_plan (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as'\n    )\" \"subseq as' as\" \"sat_precond_as s as'\"\n    \"length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan\n                  (fmrestrict_set\n                    (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n                  as =\n                 exec_plan\n                  (fmrestrict_set\n                    (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n                  as';\n         subseq as' as; sat_precond_as s as';\n         length as'\n         \\<le> problem_plan_bound\n                (snapshot PROB (fmrestrict_set vs s))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1, 2, 4, 5, 6) no_vs_change_obtain_snapshot_bound_2nd_step"], ["proof (prove)\nusing this:\n  finite PROB\n  vars_change as vs s = []\n  sat_precond_as s as\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  \\<lbrakk>finite ?PROB; vars_change ?as ?vs ?s = []; sat_precond_as ?s ?as;\n   ?s \\<in> valid_states ?PROB; ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan\n                        (fmrestrict_set\n                          (prob_dom\n                            (snapshot ?PROB (fmrestrict_set ?vs ?s)))\n                          ?s)\n                        ?as =\n                       exec_plan\n                        (fmrestrict_set\n                          (prob_dom\n                            (snapshot ?PROB (fmrestrict_set ?vs ?s)))\n                          ?s)\n                        as' \\<and>\n                       subseq as' ?as \\<and>\n                       sat_precond_as ?s as' \\<and>\n                       length as'\n                       \\<le> problem_plan_bound\n                              (snapshot ?PROB (fmrestrict_set ?vs ?s))\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan\n                  (fmrestrict_set\n                    (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n                  as =\n                 exec_plan\n                  (fmrestrict_set\n                    (prob_dom (snapshot PROB (fmrestrict_set vs s))) s)\n                  as';\n         subseq as' as; sat_precond_as s as';\n         length as'\n         \\<le> problem_plan_bound\n                (snapshot PROB (fmrestrict_set vs s))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as =\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as'\n  subseq as' as\n  sat_precond_as s as'\n  length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (exec_plan s as) =\n       fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (exec_plan s as') \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "moreover"], ["proof (state)\nthis:\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as =\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as'\n  subseq as' as\n  sat_precond_as s as'\n  length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (exec_plan s as) =\n       fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (exec_plan s as') \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "have\n    \"exec_plan (fmrestrict_set vs s) (as_proj as vs) = fmrestrict_set vs (exec_plan s as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_plan (fmrestrict_set vs s) (as_proj as vs) =\n    fmrestrict_set vs (exec_plan s as)", "using assms(4) sat_precond_exec_as_proj_eq_proj_exec"], ["proof (prove)\nusing this:\n  sat_precond_as s as\n  sat_precond_as ?s ?as \\<Longrightarrow>\n  exec_plan (fmrestrict_set ?vs ?s) (as_proj ?as ?vs) =\n  fmrestrict_set ?vs (exec_plan ?s ?as)\n\ngoal (1 subgoal):\n 1. exec_plan (fmrestrict_set vs s) (as_proj as vs) =\n    fmrestrict_set vs (exec_plan s as)", "by blast"], ["proof (state)\nthis:\n  exec_plan (fmrestrict_set vs s) (as_proj as vs) =\n  fmrestrict_set vs (exec_plan s as)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (exec_plan s as) =\n       fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (exec_plan s as') \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "moreover"], ["proof (state)\nthis:\n  exec_plan (fmrestrict_set vs s) (as_proj as vs) =\n  fmrestrict_set vs (exec_plan s as)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (exec_plan s as) =\n       fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (exec_plan s as') \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "have \"as_proj as (prob_dom (snapshot PROB (fmrestrict_set vs s))) = as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as_proj as (prob_dom (snapshot PROB (fmrestrict_set vs s))) = as", "using assms(2, 3, 4, 6) as_proj_eq_as no_vs_change_valid_in_snapshot"], ["proof (prove)\nusing this:\n  vars_change as vs s = []\n  no_effectless_act as\n  sat_precond_as s as\n  as \\<in> valid_plans PROB\n  \\<lbrakk>no_effectless_act ?as; ?as \\<in> valid_plans ?PROB;\n   prob_dom ?PROB \\<subseteq> ?vs\\<rbrakk>\n  \\<Longrightarrow> as_proj ?as ?vs = ?as\n  \\<lbrakk>?as \\<in> valid_plans ?PROB; sat_precond_as ?s ?as;\n   vars_change ?as ?vs ?s = []\\<rbrakk>\n  \\<Longrightarrow> ?as\n                    \\<in> valid_plans\n                           (snapshot ?PROB (fmrestrict_set ?vs ?s))\n\ngoal (1 subgoal):\n 1. as_proj as (prob_dom (snapshot PROB (fmrestrict_set vs s))) = as", "by blast"], ["proof (state)\nthis:\n  as_proj as (prob_dom (snapshot PROB (fmrestrict_set vs s))) = as\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (exec_plan s as) =\n       fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (exec_plan s as') \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "ultimately"], ["proof (chain)\npicking this:\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as =\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as'\n  subseq as' as\n  sat_precond_as s as'\n  length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n  exec_plan (fmrestrict_set vs s) (as_proj as vs) =\n  fmrestrict_set vs (exec_plan s as)\n  as_proj as (prob_dom (snapshot PROB (fmrestrict_set vs s))) = as", "show ?thesis"], ["proof (prove)\nusing this:\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as =\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as'\n  subseq as' as\n  sat_precond_as s as'\n  length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n  exec_plan (fmrestrict_set vs s) (as_proj as vs) =\n  fmrestrict_set vs (exec_plan s as)\n  as_proj as (prob_dom (snapshot PROB (fmrestrict_set vs s))) = as\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (exec_plan s as) =\n       fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (exec_plan s as') \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "using sublist_as_proj_eq_as proj_exec_proj_eq_exec_proj'"], ["proof (prove)\nusing this:\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as =\n  exec_plan\n   (fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) s) as'\n  subseq as' as\n  sat_precond_as s as'\n  length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n  exec_plan (fmrestrict_set vs s) (as_proj as vs) =\n  fmrestrict_set vs (exec_plan s as)\n  as_proj as (prob_dom (snapshot PROB (fmrestrict_set vs s))) = as\n  subseq ?as' (as_proj ?as ?vs) \\<Longrightarrow> as_proj ?as' ?vs = ?as'\n  fmrestrict_set ?vs (exec_plan (fmrestrict_set ?vs ?s) (as_proj ?as ?vs)) =\n  fmrestrict_set ?vs (exec_plan ?s (as_proj ?as ?vs))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (exec_plan s as) =\n       fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (exec_plan s as') \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "by metis"], ["proof (state)\nthis:\n  \\<exists>as'.\n     fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n      (exec_plan s as) =\n     fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n      (exec_plan s as') \\<and>\n     subseq as' as \\<and>\n     length as'\n     \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>NOTE added lemma.\\<close>\n\\<comment> \\<open>TODO remove unused assumptions.\\<close>"], ["", "lemma no_vs_change_snapshot_s_vs_is_valid_bound_i:\n  fixes PROB :: \"'a problem\"\n  assumes  \"finite PROB\" \"(vars_change as vs s = [])\" \"(no_effectless_act as)\"\n    \"(sat_precond_as s as)\" \"(s \\<in> valid_states PROB)\" \"(as \\<in> valid_plans PROB)\"\n    \"fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) (exec_plan s as) =\n        fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) (exec_plan s as')\"\n    \"subseq as' as\" \"length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\"\n  shows\n    \"fmrestrict_set (fmdom' (exec_plan s as) - prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (exec_plan s as)\n      = fmrestrict_set (fmdom' (exec_plan s as) - prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        s\n    \\<and> fmrestrict_set (fmdom' (exec_plan s as') - prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (exec_plan s as')\n      = fmrestrict_set (fmdom' (exec_plan s as') - prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "let ?vs=\"(prob_dom (snapshot PROB (fmrestrict_set vs s)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "let ?vs'=\"(fmdom' (exec_plan s as) - prob_dom (snapshot PROB (fmrestrict_set vs s)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "let ?vs''=\"(fmdom' (exec_plan s as') - prob_dom (snapshot PROB (fmrestrict_set vs s)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "let ?s=\"(exec_plan s as)\""], ["proof (state)\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "let ?s'=\"(exec_plan s as')\""], ["proof (state)\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "have 1: \"as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))", "using assms(2, 4, 6) no_vs_change_valid_in_snapshot"], ["proof (prove)\nusing this:\n  vars_change as vs s = []\n  sat_precond_as s as\n  as \\<in> valid_plans PROB\n  \\<lbrakk>?as \\<in> valid_plans ?PROB; sat_precond_as ?s ?as;\n   vars_change ?as ?vs ?s = []\\<rbrakk>\n  \\<Longrightarrow> ?as\n                    \\<in> valid_plans\n                           (snapshot ?PROB (fmrestrict_set ?vs ?s))\n\ngoal (1 subgoal):\n 1. as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))", "by blast"], ["proof (state)\nthis:\n  as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "{"], ["proof (state)\nthis:\n  as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "{"], ["proof (state)\nthis:\n  as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "assume \"ListMem a as\""], ["proof (state)\nthis:\n  ListMem a as\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "then"], ["proof (chain)\npicking this:\n  ListMem a as", "have \"fmdom' (snd a) \\<subseteq> prob_dom (snapshot PROB (fmrestrict_set vs s))\""], ["proof (prove)\nusing this:\n  ListMem a as\n\ngoal (1 subgoal):\n 1. fmdom' (snd a)\n    \\<subseteq> prob_dom (snapshot PROB (fmrestrict_set vs s))", "using 1 FDOM_eff_subset_prob_dom_pair valid_plan_mems"], ["proof (prove)\nusing this:\n  ListMem a as\n  as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\n  ?a \\<in> ?PROB \\<Longrightarrow>\n  fmdom' (snd ?a) \\<subseteq> prob_dom ?PROB\n  \\<lbrakk>?as \\<in> valid_plans ?PROB; ListMem ?a ?as\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> ?PROB\n\ngoal (1 subgoal):\n 1. fmdom' (snd a)\n    \\<subseteq> prob_dom (snapshot PROB (fmrestrict_set vs s))", "by metis"], ["proof (state)\nthis:\n  fmdom' (snd a) \\<subseteq> prob_dom (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "then"], ["proof (chain)\npicking this:\n  fmdom' (snd a) \\<subseteq> prob_dom (snapshot PROB (fmrestrict_set vs s))", "have \"fmdom' (fmrestrict_set (fmdom' (exec_plan s as)\n          - prob_dom (snapshot PROB (fmrestrict_set vs s))) (snd a))\n        = {}\""], ["proof (prove)\nusing this:\n  fmdom' (snd a) \\<subseteq> prob_dom (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. fmdom'\n     (fmrestrict_set\n       (fmdom' (exec_plan s as) -\n        prob_dom (snapshot PROB (fmrestrict_set vs s)))\n       (snd a)) =\n    {}", "using subset_inter_diff_empty[of \"fmdom' (snd a)\"\n            \"prob_dom (snapshot PROB (fmrestrict_set vs s))\"] fmdom'_restrict_set_precise"], ["proof (prove)\nusing this:\n  fmdom' (snd a) \\<subseteq> prob_dom (snapshot PROB (fmrestrict_set vs s))\n  fmdom' (snd a)\n  \\<subseteq> prob_dom\n               (snapshot PROB (fmrestrict_set vs s)) \\<Longrightarrow>\n  fmdom' (snd a) \\<inter>\n  (?u - prob_dom (snapshot PROB (fmrestrict_set vs s))) =\n  {}\n  fmdom' (fmrestrict_set ?A ?m) = fmdom' ?m \\<inter> ?A\n\ngoal (1 subgoal):\n 1. fmdom'\n     (fmrestrict_set\n       (fmdom' (exec_plan s as) -\n        prob_dom (snapshot PROB (fmrestrict_set vs s)))\n       (snd a)) =\n    {}", "by metis"], ["proof (state)\nthis:\n  fmdom'\n   (fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (snd a)) =\n  {}\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "}"], ["proof (state)\nthis:\n  ListMem ?a2 as \\<Longrightarrow>\n  fmdom'\n   (fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (snd ?a2)) =\n  {}\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "then"], ["proof (chain)\npicking this:\n  ListMem ?a2 as \\<Longrightarrow>\n  fmdom'\n   (fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (snd ?a2)) =\n  {}", "have\n      \"fmrestrict_set ?vs' (exec_plan s as) = fmrestrict_set ?vs' s\""], ["proof (prove)\nusing this:\n  ListMem ?a2 as \\<Longrightarrow>\n  fmdom'\n   (fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (snd ?a2)) =\n  {}\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "using disjoint_effects_no_effects[of as ?vs' s]"], ["proof (prove)\nusing this:\n  ListMem ?a2 as \\<Longrightarrow>\n  fmdom'\n   (fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (snd ?a2)) =\n  {}\n  \\<forall>a.\n     ListMem a as \\<longrightarrow>\n     fmdom'\n      (fmrestrict_set\n        (fmdom' (exec_plan s as) -\n         prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (snd a)) =\n     {} \\<Longrightarrow>\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as) =\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "by blast"], ["proof (state)\nthis:\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as) =\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "}"], ["proof (state)\nthis:\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as) =\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "moreover"], ["proof (state)\nthis:\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as) =\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "{"], ["proof (state)\nthis:\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as) =\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "{"], ["proof (state)\nthis:\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as) =\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "assume P: \"ListMem a as'\""], ["proof (state)\nthis:\n  ListMem a as'\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "moreover"], ["proof (state)\nthis:\n  ListMem a as'\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "have \\<alpha>: \"as' \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as' \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))", "using assms(8) 1 sublist_valid_plan"], ["proof (prove)\nusing this:\n  subseq as' as\n  as \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\n  \\<lbrakk>subseq ?as' ?as; ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> ?as' \\<in> valid_plans ?PROB\n\ngoal (1 subgoal):\n 1. as' \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))", "by blast"], ["proof (state)\nthis:\n  as' \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "moreover"], ["proof (state)\nthis:\n  as' \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "have \"a \\<in> PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> PROB", "using P \\<alpha> snapshot_subset subsetCE valid_plan_mems"], ["proof (prove)\nusing this:\n  ListMem a as'\n  as' \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\n  snapshot ?PROB ?s \\<subseteq> ?PROB\n  \\<lbrakk>?A \\<subseteq> ?B; ?c \\<notin> ?A \\<Longrightarrow> ?P;\n   ?c \\<in> ?B \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  \\<lbrakk>?as \\<in> valid_plans ?PROB; ListMem ?a ?as\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> ?PROB\n\ngoal (1 subgoal):\n 1. a \\<in> PROB", "by fast"], ["proof (state)\nthis:\n  a \\<in> PROB\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "ultimately"], ["proof (chain)\npicking this:\n  ListMem a as'\n  as' \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\n  a \\<in> PROB", "have \"fmdom' (snd a) \\<subseteq> prob_dom (snapshot PROB (fmrestrict_set vs s))\""], ["proof (prove)\nusing this:\n  ListMem a as'\n  as' \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\n  a \\<in> PROB\n\ngoal (1 subgoal):\n 1. fmdom' (snd a)\n    \\<subseteq> prob_dom (snapshot PROB (fmrestrict_set vs s))", "using FDOM_eff_subset_prob_dom_pair valid_plan_mems"], ["proof (prove)\nusing this:\n  ListMem a as'\n  as' \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\n  a \\<in> PROB\n  ?a \\<in> ?PROB \\<Longrightarrow>\n  fmdom' (snd ?a) \\<subseteq> prob_dom ?PROB\n  \\<lbrakk>?as \\<in> valid_plans ?PROB; ListMem ?a ?as\\<rbrakk>\n  \\<Longrightarrow> ?a \\<in> ?PROB\n\ngoal (1 subgoal):\n 1. fmdom' (snd a)\n    \\<subseteq> prob_dom (snapshot PROB (fmrestrict_set vs s))", "by metis"], ["proof (state)\nthis:\n  fmdom' (snd a) \\<subseteq> prob_dom (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "then"], ["proof (chain)\npicking this:\n  fmdom' (snd a) \\<subseteq> prob_dom (snapshot PROB (fmrestrict_set vs s))", "have \"fmdom' (fmrestrict_set (fmdom' (exec_plan s as')\n          - prob_dom (snapshot PROB (fmrestrict_set vs s))) (snd a))\n        = {}\""], ["proof (prove)\nusing this:\n  fmdom' (snd a) \\<subseteq> prob_dom (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. fmdom'\n     (fmrestrict_set\n       (fmdom' (exec_plan s as') -\n        prob_dom (snapshot PROB (fmrestrict_set vs s)))\n       (snd a)) =\n    {}", "using subset_inter_diff_empty[of \"fmdom' (snd a)\"\n            \"prob_dom (snapshot PROB (fmrestrict_set vs s))\"] fmdom'_restrict_set_precise"], ["proof (prove)\nusing this:\n  fmdom' (snd a) \\<subseteq> prob_dom (snapshot PROB (fmrestrict_set vs s))\n  fmdom' (snd a)\n  \\<subseteq> prob_dom\n               (snapshot PROB (fmrestrict_set vs s)) \\<Longrightarrow>\n  fmdom' (snd a) \\<inter>\n  (?u - prob_dom (snapshot PROB (fmrestrict_set vs s))) =\n  {}\n  fmdom' (fmrestrict_set ?A ?m) = fmdom' ?m \\<inter> ?A\n\ngoal (1 subgoal):\n 1. fmdom'\n     (fmrestrict_set\n       (fmdom' (exec_plan s as') -\n        prob_dom (snapshot PROB (fmrestrict_set vs s)))\n       (snd a)) =\n    {}", "by metis"], ["proof (state)\nthis:\n  fmdom'\n   (fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (snd a)) =\n  {}\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "}"], ["proof (state)\nthis:\n  ListMem ?a2 as' \\<Longrightarrow>\n  fmdom'\n   (fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (snd ?a2)) =\n  {}\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "then"], ["proof (chain)\npicking this:\n  ListMem ?a2 as' \\<Longrightarrow>\n  fmdom'\n   (fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (snd ?a2)) =\n  {}", "have\n      \"fmrestrict_set ?vs'' (exec_plan s as') = fmrestrict_set ?vs'' s\""], ["proof (prove)\nusing this:\n  ListMem ?a2 as' \\<Longrightarrow>\n  fmdom'\n   (fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (snd ?a2)) =\n  {}\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "using disjoint_effects_no_effects[of as' ?vs'' s]"], ["proof (prove)\nusing this:\n  ListMem ?a2 as' \\<Longrightarrow>\n  fmdom'\n   (fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (snd ?a2)) =\n  {}\n  \\<forall>a.\n     ListMem a as' \\<longrightarrow>\n     fmdom'\n      (fmrestrict_set\n        (fmdom' (exec_plan s as') -\n         prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (snd a)) =\n     {} \\<Longrightarrow>\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as') =\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "by blast"], ["proof (state)\nthis:\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as') =\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "}"], ["proof (state)\nthis:\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as') =\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "ultimately"], ["proof (chain)\npicking this:\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as) =\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as') =\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s", "show ?thesis"], ["proof (prove)\nusing this:\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as) =\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as') =\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s \\<and>\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "by blast"], ["proof (state)\nthis:\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as) =\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s \\<and>\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as') =\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n\ngoal:\nNo subgoals!", "qed\n\n\\<comment> \\<open>NOTE type for `PROB` had to be fixed.\\<close>"], ["", "lemma no_vs_change_snapshot_s_vs_is_valid_bound:\n  fixes PROB :: \"'a problem\"\n  assumes \"finite PROB\" \"(vars_change as vs s = [])\" \"(no_effectless_act as)\"\n    \"(sat_precond_as s as)\" \"(s \\<in> valid_states PROB)\" \"(as \\<in> valid_plans PROB)\"\n  shows \"(\\<exists>as'.\n    (exec_plan s as = exec_plan s as')\n    \\<and> (subseq as' as)\n    \\<and> (length as' <= problem_plan_bound (snapshot PROB (fmrestrict_set vs s)))\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "obtain as' where 1:\n    \"fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) (exec_plan s as) =\n      fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s))) (exec_plan s as')\"\n    \"subseq as' as\" \"length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>fmrestrict_set\n                  (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n                  (exec_plan s as) =\n                 fmrestrict_set\n                  (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n                  (exec_plan s as');\n         subseq as' as;\n         length as'\n         \\<le> problem_plan_bound\n                (snapshot PROB (fmrestrict_set vs s))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms no_vs_change_obtain_snapshot_bound_3rd_step"], ["proof (prove)\nusing this:\n  finite PROB\n  vars_change as vs s = []\n  no_effectless_act as\n  sat_precond_as s as\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  \\<lbrakk>finite ?PROB; vars_change ?as ?vs ?s = []; no_effectless_act ?as;\n   sat_precond_as ?s ?as; ?s \\<in> valid_states ?PROB;\n   ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       fmrestrict_set\n                        (prob_dom (snapshot ?PROB (fmrestrict_set ?vs ?s)))\n                        (exec_plan ?s ?as) =\n                       fmrestrict_set\n                        (prob_dom (snapshot ?PROB (fmrestrict_set ?vs ?s)))\n                        (exec_plan ?s as') \\<and>\n                       subseq as' ?as \\<and>\n                       length as'\n                       \\<le> problem_plan_bound\n                              (snapshot ?PROB (fmrestrict_set ?vs ?s))\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>fmrestrict_set\n                  (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n                  (exec_plan s as) =\n                 fmrestrict_set\n                  (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n                  (exec_plan s as');\n         subseq as' as;\n         length as'\n         \\<le> problem_plan_bound\n                (snapshot PROB (fmrestrict_set vs s))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as) =\n  fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as')\n  subseq as' as\n  length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "{"], ["proof (state)\nthis:\n  fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as) =\n  fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as')\n  subseq as' as\n  length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "have a: \"fmrestrict_set (fmdom' (exec_plan s as) - prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (exec_plan s as)\n      = fmrestrict_set (fmdom' (exec_plan s as) - prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        s \"\n      \"fmrestrict_set (fmdom' (exec_plan s as') - prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        (exec_plan s as')\n      = fmrestrict_set (fmdom' (exec_plan s as') - prob_dom (snapshot PROB (fmrestrict_set vs s)))\n        s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s &&&\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "using assms 1 no_vs_change_snapshot_s_vs_is_valid_bound_i"], ["proof (prove)\nusing this:\n  finite PROB\n  vars_change as vs s = []\n  no_effectless_act as\n  sat_precond_as s as\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as) =\n  fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as')\n  subseq as' as\n  length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n  \\<lbrakk>finite ?PROB; vars_change ?as ?vs ?s = []; no_effectless_act ?as;\n   sat_precond_as ?s ?as; ?s \\<in> valid_states ?PROB;\n   ?as \\<in> valid_plans ?PROB;\n   fmrestrict_set (prob_dom (snapshot ?PROB (fmrestrict_set ?vs ?s)))\n    (exec_plan ?s ?as) =\n   fmrestrict_set (prob_dom (snapshot ?PROB (fmrestrict_set ?vs ?s)))\n    (exec_plan ?s ?as');\n   subseq ?as' ?as;\n   length ?as'\n   \\<le> problem_plan_bound\n          (snapshot ?PROB (fmrestrict_set ?vs ?s))\\<rbrakk>\n  \\<Longrightarrow> fmrestrict_set\n                     (fmdom' (exec_plan ?s ?as) -\n                      prob_dom (snapshot ?PROB (fmrestrict_set ?vs ?s)))\n                     (exec_plan ?s ?as) =\n                    fmrestrict_set\n                     (fmdom' (exec_plan ?s ?as) -\n                      prob_dom (snapshot ?PROB (fmrestrict_set ?vs ?s)))\n                     ?s \\<and>\n                    fmrestrict_set\n                     (fmdom' (exec_plan ?s ?as') -\n                      prob_dom (snapshot ?PROB (fmrestrict_set ?vs ?s)))\n                     (exec_plan ?s ?as') =\n                    fmrestrict_set\n                     (fmdom' (exec_plan ?s ?as') -\n                      prob_dom (snapshot ?PROB (fmrestrict_set ?vs ?s)))\n                     ?s\n\ngoal (1 subgoal):\n 1. fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as) =\n    fmrestrict_set\n     (fmdom' (exec_plan s as) -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s &&&\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     (exec_plan s as') =\n    fmrestrict_set\n     (fmdom' (exec_plan s as') -\n      prob_dom (snapshot PROB (fmrestrict_set vs s)))\n     s", "by blast+"], ["proof (state)\nthis:\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as) =\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as') =\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "moreover"], ["proof (state)\nthis:\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as) =\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as') =\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "have \"as' \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as' \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))", "using \"1\"(2) assms(2) assms(4) assms(6) no_vs_change_valid_in_snapshot sublist_valid_plan"], ["proof (prove)\nusing this:\n  subseq as' as\n  vars_change as vs s = []\n  sat_precond_as s as\n  as \\<in> valid_plans PROB\n  \\<lbrakk>?as \\<in> valid_plans ?PROB; sat_precond_as ?s ?as;\n   vars_change ?as ?vs ?s = []\\<rbrakk>\n  \\<Longrightarrow> ?as\n                    \\<in> valid_plans\n                           (snapshot ?PROB (fmrestrict_set ?vs ?s))\n  \\<lbrakk>subseq ?as' ?as; ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> ?as' \\<in> valid_plans ?PROB\n\ngoal (1 subgoal):\n 1. as' \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))", "by blast"], ["proof (state)\nthis:\n  as' \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "moreover"], ["proof (state)\nthis:\n  as' \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "have \"(exec_plan s as) \\<in> valid_states PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_plan s as \\<in> valid_states PROB", "using assms(5, 6) valid_as_valid_exec"], ["proof (prove)\nusing this:\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  \\<lbrakk>?as \\<in> valid_plans ?PROB; ?s \\<in> valid_states ?PROB\\<rbrakk>\n  \\<Longrightarrow> exec_plan ?s ?as \\<in> valid_states ?PROB\n\ngoal (1 subgoal):\n 1. exec_plan s as \\<in> valid_states PROB", "by blast"], ["proof (state)\nthis:\n  exec_plan s as \\<in> valid_states PROB\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "moreover"], ["proof (state)\nthis:\n  exec_plan s as \\<in> valid_states PROB\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "have \"(exec_plan s as') \\<in> valid_states PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_plan s as' \\<in> valid_states PROB", "using assms(5, 6) 1 valid_as_valid_exec sublist_valid_plan"], ["proof (prove)\nusing this:\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as) =\n  fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as')\n  subseq as' as\n  length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n  \\<lbrakk>?as \\<in> valid_plans ?PROB; ?s \\<in> valid_states ?PROB\\<rbrakk>\n  \\<Longrightarrow> exec_plan ?s ?as \\<in> valid_states ?PROB\n  \\<lbrakk>subseq ?as' ?as; ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> ?as' \\<in> valid_plans ?PROB\n\ngoal (1 subgoal):\n 1. exec_plan s as' \\<in> valid_states PROB", "by blast"], ["proof (state)\nthis:\n  exec_plan s as' \\<in> valid_states PROB\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "ultimately"], ["proof (chain)\npicking this:\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as) =\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as') =\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n  as' \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\n  exec_plan s as \\<in> valid_states PROB\n  exec_plan s as' \\<in> valid_states PROB", "have \"exec_plan s as = exec_plan s as'\""], ["proof (prove)\nusing this:\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as) =\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as') =\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n  as' \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\n  exec_plan s as \\<in> valid_states PROB\n  exec_plan s as' \\<in> valid_states PROB\n\ngoal (1 subgoal):\n 1. exec_plan s as = exec_plan s as'", "using assms"], ["proof (prove)\nusing this:\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as) =\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as') =\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n  as' \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\n  exec_plan s as \\<in> valid_states PROB\n  exec_plan s as' \\<in> valid_states PROB\n  finite PROB\n  vars_change as vs s = []\n  no_effectless_act as\n  sat_precond_as s as\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. exec_plan s as = exec_plan s as'", "unfolding valid_states_def"], ["proof (prove)\nusing this:\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as) =\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as') =\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n  as' \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\n  exec_plan s as \\<in> {s. fmdom' s = prob_dom PROB}\n  exec_plan s as' \\<in> {s. fmdom' s = prob_dom PROB}\n  finite PROB\n  vars_change as vs s = []\n  no_effectless_act as\n  sat_precond_as s as\n  s \\<in> {s. fmdom' s = prob_dom PROB}\n  as \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. exec_plan s as = exec_plan s as'", "using graph_plan_lemma_5[where vs=\"prob_dom (snapshot PROB (fmrestrict_set vs s))\", OF _ 1(1)]"], ["proof (prove)\nusing this:\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as) =\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as') =\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   s\n  as' \\<in> valid_plans (snapshot PROB (fmrestrict_set vs s))\n  exec_plan s as \\<in> {s. fmdom' s = prob_dom PROB}\n  exec_plan s as' \\<in> {s. fmdom' s = prob_dom PROB}\n  finite PROB\n  vars_change as vs s = []\n  no_effectless_act as\n  sat_precond_as s as\n  s \\<in> {s. fmdom' s = prob_dom PROB}\n  as \\<in> valid_plans PROB\n  fmrestrict_set\n   (fmdom' (exec_plan s as) -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as) =\n  fmrestrict_set\n   (fmdom' (exec_plan s as') -\n    prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as') \\<Longrightarrow>\n  exec_plan s as = exec_plan s as'\n\ngoal (1 subgoal):\n 1. exec_plan s as = exec_plan s as'", "by force"], ["proof (state)\nthis:\n  exec_plan s as = exec_plan s as'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "}"], ["proof (state)\nthis:\n  exec_plan s as = exec_plan s as'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "then"], ["proof (chain)\npicking this:\n  exec_plan s as = exec_plan s as'", "show ?thesis"], ["proof (prove)\nusing this:\n  exec_plan s as = exec_plan s as'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "using 1"], ["proof (prove)\nusing this:\n  exec_plan s as = exec_plan s as'\n  fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as) =\n  fmrestrict_set (prob_dom (snapshot PROB (fmrestrict_set vs s)))\n   (exec_plan s as')\n  subseq as' as\n  length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and>\n     length as'\n     \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open>TODO showcase (problems with stronger typing: Isabelle requires strict typing for `max`; whereas\nin HOL4 this is not required, possible because 'MAX' is natural number specific.\\<close>"], ["", "lemma snapshot_bound_leq_S:\n  shows \"\n    problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n    \\<le> S vs lss PROB (fmrestrict_set vs s)\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "have \"geq_arg (max :: nat \\<Rightarrow> nat \\<Rightarrow> nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geq_arg max", "unfolding geq_arg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. x \\<le> max x y \\<and> y \\<le> max x y", "using max.cobounded1"], ["proof (prove)\nusing this:\n  ?a \\<le> max ?a ?b\n\ngoal (1 subgoal):\n 1. \\<forall>x y. x \\<le> max x y \\<and> y \\<le> max x y", "by simp"], ["proof (state)\nthis:\n  geq_arg max\n\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "then"], ["proof (chain)\npicking this:\n  geq_arg max", "show ?thesis"], ["proof (prove)\nusing this:\n  geq_arg max\n\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "unfolding S_def"], ["proof (prove)\nusing this:\n  geq_arg max\n\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n    \\<le> wlp (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x)\n           (\\<lambda>s. problem_plan_bound (snapshot PROB s)) max\n           (\\<lambda>x y. x + y + 1) (fmrestrict_set vs s) lss", "using individual_weight_less_eq_lp[where\n        g=\"max :: nat \\<Rightarrow> nat \\<Rightarrow> nat\"\n        and x=\"(fmrestrict_set vs s)\" and R=\"(\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x)\"\n        and w=\"(\\<lambda>s. problem_plan_bound (snapshot PROB s))\" and f=\"(\\<lambda>x y. x + y + 1)\" and l=lss]"], ["proof (prove)\nusing this:\n  geq_arg max\n  geq_arg max \\<Longrightarrow>\n  problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n  \\<le> wlp (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x)\n         (\\<lambda>s. problem_plan_bound (snapshot PROB s)) max\n         (\\<lambda>x y. x + y + 1) (fmrestrict_set vs s) lss\n\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n    \\<le> wlp (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x)\n           (\\<lambda>s. problem_plan_bound (snapshot PROB s)) max\n           (\\<lambda>x y. x + y + 1) (fmrestrict_set vs s) lss", "by blast"], ["proof (state)\nthis:\n  problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n  \\<le> S vs lss PROB (fmrestrict_set vs s)\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open>NOTE first argument of `top\\_sorted\\_abs` had to be wrapped into lambda.\\<close>\n\\<comment> \\<open>NOTE the type of `1` had to be restricted to `nat` to ensure the proofs for `geq\\_arg` work.\\<close>"], ["", "lemma S_geq_S_succ_plus_ell:\n  assumes \"(s \\<in> valid_states PROB)\"\n    \"(top_sorted_abs (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss)\"\n    \"(s' \\<in> state_successors (prob_proj PROB vs) s)\" \"(set lss = valid_states (prob_proj PROB vs))\"\n  shows \"(\n    problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n      + S vs lss PROB (fmrestrict_set vs s')\n      + (1 :: nat)\n    \\<le> S vs lss PROB (fmrestrict_set vs s)\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    S vs lss PROB (fmrestrict_set vs s') +\n    1\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    S vs lss PROB (fmrestrict_set vs s') +\n    1\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "let ?f=\"\\<lambda>x y. x + y + (1 :: nat)\""], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    S vs lss PROB (fmrestrict_set vs s') +\n    1\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "let ?R=\"(\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    S vs lss PROB (fmrestrict_set vs s') +\n    1\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "let ?w=\"(\\<lambda>s. problem_plan_bound (snapshot PROB s))\""], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    S vs lss PROB (fmrestrict_set vs s') +\n    1\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "let ?g=\"max :: nat \\<Rightarrow> nat \\<Rightarrow> nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    S vs lss PROB (fmrestrict_set vs s') +\n    1\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "let ?vtx1=\"(fmrestrict_set vs s')\""], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    S vs lss PROB (fmrestrict_set vs s') +\n    1\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "let ?G=\"lss\""], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    S vs lss PROB (fmrestrict_set vs s') +\n    1\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "let ?vtx2=\"(fmrestrict_set vs s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    S vs lss PROB (fmrestrict_set vs s') +\n    1\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "have \"geq_arg ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geq_arg (\\<lambda>x y. x + y + 1)", "unfolding geq_arg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. x \\<le> x + y + 1 \\<and> y \\<le> x + y + 1", "by simp"], ["proof (state)\nthis:\n  geq_arg (\\<lambda>x y. x + y + 1)\n\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    S vs lss PROB (fmrestrict_set vs s') +\n    1\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "moreover"], ["proof (state)\nthis:\n  geq_arg (\\<lambda>x y. x + y + 1)\n\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    S vs lss PROB (fmrestrict_set vs s') +\n    1\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "have \"geq_arg ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. geq_arg max", "unfolding geq_arg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y. x \\<le> max x y \\<and> y \\<le> max x y", "by simp"], ["proof (state)\nthis:\n  geq_arg max\n\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    S vs lss PROB (fmrestrict_set vs s') +\n    1\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "moreover"], ["proof (state)\nthis:\n  geq_arg max\n\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    S vs lss PROB (fmrestrict_set vs s') +\n    1\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "have \"\\<forall>x. ListMem x lss \\<longrightarrow> \\<not>?R x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ListMem x lss \\<longrightarrow>\n       x \\<notin> state_successors (prob_proj PROB vs) x", "unfolding state_successors_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       ListMem x lss \\<longrightarrow>\n       x \\<notin> state_succ x ` prob_proj PROB vs - {x}", "by blast"], ["proof (state)\nthis:\n  \\<forall>x.\n     ListMem x lss \\<longrightarrow>\n     x \\<notin> state_successors (prob_proj PROB vs) x\n\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    S vs lss PROB (fmrestrict_set vs s') +\n    1\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "moreover"], ["proof (state)\nthis:\n  \\<forall>x.\n     ListMem x lss \\<longrightarrow>\n     x \\<notin> state_successors (prob_proj PROB vs) x\n\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    S vs lss PROB (fmrestrict_set vs s') +\n    1\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "have \"?R ?vtx2 ?vtx1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrestrict_set vs s'\n    \\<in> state_successors (prob_proj PROB vs) (fmrestrict_set vs s)", "unfolding state_successors_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrestrict_set vs s'\n    \\<in> state_succ (fmrestrict_set vs s) ` prob_proj PROB vs -\n          {fmrestrict_set vs s}", "using assms(3) state_in_successor_proj_in_state_in_successor state_successors_def"], ["proof (prove)\nusing this:\n  s' \\<in> state_successors (prob_proj PROB vs) s\n  ?s' \\<in> state_successors (prob_proj ?PROB ?vs) ?s \\<Longrightarrow>\n  fmrestrict_set ?vs ?s'\n  \\<in> state_successors (prob_proj ?PROB ?vs) (fmrestrict_set ?vs ?s)\n  state_successors ?PROB ?s \\<equiv> state_succ ?s ` ?PROB - {?s}\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs s'\n    \\<in> state_succ (fmrestrict_set vs s) ` prob_proj PROB vs -\n          {fmrestrict_set vs s}", "by blast"], ["proof (state)\nthis:\n  fmrestrict_set vs s'\n  \\<in> state_successors (prob_proj PROB vs) (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    S vs lss PROB (fmrestrict_set vs s') +\n    1\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "moreover"], ["proof (state)\nthis:\n  fmrestrict_set vs s'\n  \\<in> state_successors (prob_proj PROB vs) (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    S vs lss PROB (fmrestrict_set vs s') +\n    1\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "have\n    \"ListMem ?vtx1 ?G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ListMem (fmrestrict_set vs s') lss", "using assms(1, 3, 4)"], ["proof (prove)\nusing this:\n  s \\<in> valid_states PROB\n  s' \\<in> state_successors (prob_proj PROB vs) s\n  set lss = valid_states (prob_proj PROB vs)\n\ngoal (1 subgoal):\n 1. ListMem (fmrestrict_set vs s') lss", "by (metis ListMem_iff contra_subsetD graph_plan_not_eq_last_diff_paths proj_successors_of_valid_are_valid)"], ["proof (state)\nthis:\n  ListMem (fmrestrict_set vs s') lss\n\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    S vs lss PROB (fmrestrict_set vs s') +\n    1\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "moreover"], ["proof (state)\nthis:\n  ListMem (fmrestrict_set vs s') lss\n\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    S vs lss PROB (fmrestrict_set vs s') +\n    1\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "have \"top_sorted_abs ?R ?G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top_sorted_abs\n     (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss", "using assms(2)"], ["proof (prove)\nusing this:\n  top_sorted_abs\n   (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss\n\ngoal (1 subgoal):\n 1. top_sorted_abs\n     (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss", "by simp"], ["proof (state)\nthis:\n  top_sorted_abs\n   (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss\n\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    S vs lss PROB (fmrestrict_set vs s') +\n    1\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "ultimately"], ["proof (chain)\npicking this:\n  geq_arg (\\<lambda>x y. x + y + 1)\n  geq_arg max\n  \\<forall>x.\n     ListMem x lss \\<longrightarrow>\n     x \\<notin> state_successors (prob_proj PROB vs) x\n  fmrestrict_set vs s'\n  \\<in> state_successors (prob_proj PROB vs) (fmrestrict_set vs s)\n  ListMem (fmrestrict_set vs s') lss\n  top_sorted_abs\n   (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss", "show ?thesis"], ["proof (prove)\nusing this:\n  geq_arg (\\<lambda>x y. x + y + 1)\n  geq_arg max\n  \\<forall>x.\n     ListMem x lss \\<longrightarrow>\n     x \\<notin> state_successors (prob_proj PROB vs) x\n  fmrestrict_set vs s'\n  \\<in> state_successors (prob_proj PROB vs) (fmrestrict_set vs s)\n  ListMem (fmrestrict_set vs s') lss\n  top_sorted_abs\n   (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss\n\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    S vs lss PROB (fmrestrict_set vs s') +\n    1\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "unfolding S_def"], ["proof (prove)\nusing this:\n  geq_arg (\\<lambda>x y. x + y + 1)\n  geq_arg max\n  \\<forall>x.\n     ListMem x lss \\<longrightarrow>\n     x \\<notin> state_successors (prob_proj PROB vs) x\n  fmrestrict_set vs s'\n  \\<in> state_successors (prob_proj PROB vs) (fmrestrict_set vs s)\n  ListMem (fmrestrict_set vs s') lss\n  top_sorted_abs\n   (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss\n\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    wlp (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x)\n     (\\<lambda>s. problem_plan_bound (snapshot PROB s)) max\n     (\\<lambda>x y. x + y + 1) (fmrestrict_set vs s') lss +\n    1\n    \\<le> wlp (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x)\n           (\\<lambda>s. problem_plan_bound (snapshot PROB s)) max\n           (\\<lambda>x y. x + y + 1) (fmrestrict_set vs s) lss", "using lp_geq_lp_from_successor[of ?f ?g ?G ?R ?vtx2 ?vtx1 ?w]"], ["proof (prove)\nusing this:\n  geq_arg (\\<lambda>x y. x + y + 1)\n  geq_arg max\n  \\<forall>x.\n     ListMem x lss \\<longrightarrow>\n     x \\<notin> state_successors (prob_proj PROB vs) x\n  fmrestrict_set vs s'\n  \\<in> state_successors (prob_proj PROB vs) (fmrestrict_set vs s)\n  ListMem (fmrestrict_set vs s') lss\n  top_sorted_abs\n   (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss\n  \\<lbrakk>geq_arg (\\<lambda>x y. x + y + 1); geq_arg max;\n   \\<forall>vtx.\n      ListMem vtx lss \\<longrightarrow>\n      vtx \\<notin> state_successors (prob_proj PROB vs) vtx;\n   fmrestrict_set vs s'\n   \\<in> state_successors (prob_proj PROB vs) (fmrestrict_set vs s);\n   ListMem (fmrestrict_set vs s') lss;\n   top_sorted_abs\n    (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x)\n    lss\\<rbrakk>\n  \\<Longrightarrow> problem_plan_bound\n                     (snapshot PROB (fmrestrict_set vs s)) +\n                    wlp (\\<lambda>x y.\n                            y \\<in> state_successors (prob_proj PROB vs) x)\n                     (\\<lambda>s. problem_plan_bound (snapshot PROB s)) max\n                     (\\<lambda>x y. x + y + 1) (fmrestrict_set vs s') lss +\n                    1\n                    \\<le> wlp (\\<lambda>x y.\n                                  y \\<in> state_successors\n     (prob_proj PROB vs) x)\n                           (\\<lambda>s.\n                               problem_plan_bound (snapshot PROB s))\n                           max (\\<lambda>x y. x + y + 1)\n                           (fmrestrict_set vs s) lss\n\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    wlp (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x)\n     (\\<lambda>s. problem_plan_bound (snapshot PROB s)) max\n     (\\<lambda>x y. x + y + 1) (fmrestrict_set vs s') lss +\n    1\n    \\<le> wlp (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x)\n           (\\<lambda>s. problem_plan_bound (snapshot PROB s)) max\n           (\\<lambda>x y. x + y + 1) (fmrestrict_set vs s) lss", "by blast"], ["proof (state)\nthis:\n  problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n  S vs lss PROB (fmrestrict_set vs s') +\n  1\n  \\<le> S vs lss PROB (fmrestrict_set vs s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vars_change_cons:\n  fixes s s'\n  assumes \"(vars_change as vs s = (s' # ss))\"\n  shows \"(\\<exists>as1 act as2.\n    (as = as1 @ (act # as2))\n    \\<and> (vars_change as1 vs s = [])\n    \\<and> (state_succ (exec_plan s as1) act = s')\n    \\<and> (vars_change as2 vs (state_succ (exec_plan s as1) act) = ss)\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as1 act as2.\n       as = as1 @ act # as2 \\<and>\n       vars_change as1 vs s = [] \\<and>\n       state_succ (exec_plan s as1) act = s' \\<and>\n       vars_change as2 vs (state_succ (exec_plan s as1) act) = ss", "using assms"], ["proof (prove)\nusing this:\n  vars_change as vs s = s' # ss\n\ngoal (1 subgoal):\n 1. \\<exists>as1 act as2.\n       as = as1 @ act # as2 \\<and>\n       vars_change as1 vs s = [] \\<and>\n       state_succ (exec_plan s as1) act = s' \\<and>\n       vars_change as2 vs (state_succ (exec_plan s as1) act) = ss", "proof (induction as arbitrary: s s' vs ss)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s s' vs ss.\n       vars_change [] vs s = s' # ss \\<Longrightarrow>\n       \\<exists>as1 act as2.\n          [] = as1 @ act # as2 \\<and>\n          vars_change as1 vs s = [] \\<and>\n          state_succ (exec_plan s as1) act = s' \\<and>\n          vars_change as2 vs (state_succ (exec_plan s as1) act) = ss\n 2. \\<And>a as s s' vs ss.\n       \\<lbrakk>\\<And>s s' vs ss.\n                   vars_change as vs s = s' # ss \\<Longrightarrow>\n                   \\<exists>as1 act as2.\n                      as = as1 @ act # as2 \\<and>\n                      vars_change as1 vs s = [] \\<and>\n                      state_succ (exec_plan s as1) act = s' \\<and>\n                      vars_change as2 vs\n                       (state_succ (exec_plan s as1) act) =\n                      ss;\n        vars_change (a # as) vs s = s' # ss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as1 act as2.\n                            a # as = as1 @ act # as2 \\<and>\n                            vars_change as1 vs s = [] \\<and>\n                            state_succ (exec_plan s as1) act = s' \\<and>\n                            vars_change as2 vs\n                             (state_succ (exec_plan s as1) act) =\n                            ss", "case (Cons a as)"], ["proof (state)\nthis:\n  vars_change as ?vs ?s = ?s' # ?ss \\<Longrightarrow>\n  \\<exists>as1 act as2.\n     as = as1 @ act # as2 \\<and>\n     vars_change as1 ?vs ?s = [] \\<and>\n     state_succ (exec_plan ?s as1) act = ?s' \\<and>\n     vars_change as2 ?vs (state_succ (exec_plan ?s as1) act) = ?ss\n  vars_change (a # as) vs s = s' # ss\n\ngoal (2 subgoals):\n 1. \\<And>s s' vs ss.\n       vars_change [] vs s = s' # ss \\<Longrightarrow>\n       \\<exists>as1 act as2.\n          [] = as1 @ act # as2 \\<and>\n          vars_change as1 vs s = [] \\<and>\n          state_succ (exec_plan s as1) act = s' \\<and>\n          vars_change as2 vs (state_succ (exec_plan s as1) act) = ss\n 2. \\<And>a as s s' vs ss.\n       \\<lbrakk>\\<And>s s' vs ss.\n                   vars_change as vs s = s' # ss \\<Longrightarrow>\n                   \\<exists>as1 act as2.\n                      as = as1 @ act # as2 \\<and>\n                      vars_change as1 vs s = [] \\<and>\n                      state_succ (exec_plan s as1) act = s' \\<and>\n                      vars_change as2 vs\n                       (state_succ (exec_plan s as1) act) =\n                      ss;\n        vars_change (a # as) vs s = s' # ss\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as1 act as2.\n                            a # as = as1 @ act # as2 \\<and>\n                            vars_change as1 vs s = [] \\<and>\n                            state_succ (exec_plan s as1) act = s' \\<and>\n                            vars_change as2 vs\n                             (state_succ (exec_plan s as1) act) =\n                            ss", "then"], ["proof (chain)\npicking this:\n  vars_change as ?vs ?s = ?s' # ?ss \\<Longrightarrow>\n  \\<exists>as1 act as2.\n     as = as1 @ act # as2 \\<and>\n     vars_change as1 ?vs ?s = [] \\<and>\n     state_succ (exec_plan ?s as1) act = ?s' \\<and>\n     vars_change as2 ?vs (state_succ (exec_plan ?s as1) act) = ?ss\n  vars_change (a # as) vs s = s' # ss", "show ?case"], ["proof (prove)\nusing this:\n  vars_change as ?vs ?s = ?s' # ?ss \\<Longrightarrow>\n  \\<exists>as1 act as2.\n     as = as1 @ act # as2 \\<and>\n     vars_change as1 ?vs ?s = [] \\<and>\n     state_succ (exec_plan ?s as1) act = ?s' \\<and>\n     vars_change as2 ?vs (state_succ (exec_plan ?s as1) act) = ?ss\n  vars_change (a # as) vs s = s' # ss\n\ngoal (1 subgoal):\n 1. \\<exists>as1 act as2.\n       a # as = as1 @ act # as2 \\<and>\n       vars_change as1 vs s = [] \\<and>\n       state_succ (exec_plan s as1) act = s' \\<and>\n       vars_change as2 vs (state_succ (exec_plan s as1) act) = ss", "proof (cases \"fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>vs s s' ss.\n                vars_change as vs s = s' # ss \\<Longrightarrow>\n                \\<exists>as1 act as2.\n                   as = as1 @ act # as2 \\<and>\n                   vars_change as1 vs s = [] \\<and>\n                   state_succ (exec_plan s as1) act = s' \\<and>\n                   vars_change as2 vs (state_succ (exec_plan s as1) act) =\n                   ss;\n     vars_change (a # as) vs s = s' # ss;\n     fmrestrict_set vs (state_succ s a) \\<noteq>\n     fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as1 act as2.\n                         a # as = as1 @ act # as2 \\<and>\n                         vars_change as1 vs s = [] \\<and>\n                         state_succ (exec_plan s as1) act = s' \\<and>\n                         vars_change as2 vs\n                          (state_succ (exec_plan s as1) act) =\n                         ss\n 2. \\<lbrakk>\\<And>vs s s' ss.\n                vars_change as vs s = s' # ss \\<Longrightarrow>\n                \\<exists>as1 act as2.\n                   as = as1 @ act # as2 \\<and>\n                   vars_change as1 vs s = [] \\<and>\n                   state_succ (exec_plan s as1) act = s' \\<and>\n                   vars_change as2 vs (state_succ (exec_plan s as1) act) =\n                   ss;\n     vars_change (a # as) vs s = s' # ss;\n     \\<not> fmrestrict_set vs (state_succ s a) \\<noteq>\n            fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as1 act as2.\n                         a # as = as1 @ act # as2 \\<and>\n                         vars_change as1 vs s = [] \\<and>\n                         state_succ (exec_plan s as1) act = s' \\<and>\n                         vars_change as2 vs\n                          (state_succ (exec_plan s as1) act) =\n                         ss", "case True"], ["proof (state)\nthis:\n  fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>vs s s' ss.\n                vars_change as vs s = s' # ss \\<Longrightarrow>\n                \\<exists>as1 act as2.\n                   as = as1 @ act # as2 \\<and>\n                   vars_change as1 vs s = [] \\<and>\n                   state_succ (exec_plan s as1) act = s' \\<and>\n                   vars_change as2 vs (state_succ (exec_plan s as1) act) =\n                   ss;\n     vars_change (a # as) vs s = s' # ss;\n     fmrestrict_set vs (state_succ s a) \\<noteq>\n     fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as1 act as2.\n                         a # as = as1 @ act # as2 \\<and>\n                         vars_change as1 vs s = [] \\<and>\n                         state_succ (exec_plan s as1) act = s' \\<and>\n                         vars_change as2 vs\n                          (state_succ (exec_plan s as1) act) =\n                         ss\n 2. \\<lbrakk>\\<And>vs s s' ss.\n                vars_change as vs s = s' # ss \\<Longrightarrow>\n                \\<exists>as1 act as2.\n                   as = as1 @ act # as2 \\<and>\n                   vars_change as1 vs s = [] \\<and>\n                   state_succ (exec_plan s as1) act = s' \\<and>\n                   vars_change as2 vs (state_succ (exec_plan s as1) act) =\n                   ss;\n     vars_change (a # as) vs s = s' # ss;\n     \\<not> fmrestrict_set vs (state_succ s a) \\<noteq>\n            fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as1 act as2.\n                         a # as = as1 @ act # as2 \\<and>\n                         vars_change as1 vs s = [] \\<and>\n                         state_succ (exec_plan s as1) act = s' \\<and>\n                         vars_change as2 vs\n                          (state_succ (exec_plan s as1) act) =\n                         ss", "then"], ["proof (chain)\npicking this:\n  fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s", "have \"state_succ s a = s'\" \"vars_change as vs (state_succ s a) = ss\""], ["proof (prove)\nusing this:\n  fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s\n\ngoal (1 subgoal):\n 1. state_succ s a = s' &&& vars_change as vs (state_succ s a) = ss", "using Cons.prems"], ["proof (prove)\nusing this:\n  fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s\n  vars_change (a # as) vs s = s' # ss\n\ngoal (1 subgoal):\n 1. state_succ s a = s' &&& vars_change as vs (state_succ s a) = ss", "by simp+"], ["proof (state)\nthis:\n  state_succ s a = s'\n  vars_change as vs (state_succ s a) = ss\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>vs s s' ss.\n                vars_change as vs s = s' # ss \\<Longrightarrow>\n                \\<exists>as1 act as2.\n                   as = as1 @ act # as2 \\<and>\n                   vars_change as1 vs s = [] \\<and>\n                   state_succ (exec_plan s as1) act = s' \\<and>\n                   vars_change as2 vs (state_succ (exec_plan s as1) act) =\n                   ss;\n     vars_change (a # as) vs s = s' # ss;\n     fmrestrict_set vs (state_succ s a) \\<noteq>\n     fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as1 act as2.\n                         a # as = as1 @ act # as2 \\<and>\n                         vars_change as1 vs s = [] \\<and>\n                         state_succ (exec_plan s as1) act = s' \\<and>\n                         vars_change as2 vs\n                          (state_succ (exec_plan s as1) act) =\n                         ss\n 2. \\<lbrakk>\\<And>vs s s' ss.\n                vars_change as vs s = s' # ss \\<Longrightarrow>\n                \\<exists>as1 act as2.\n                   as = as1 @ act # as2 \\<and>\n                   vars_change as1 vs s = [] \\<and>\n                   state_succ (exec_plan s as1) act = s' \\<and>\n                   vars_change as2 vs (state_succ (exec_plan s as1) act) =\n                   ss;\n     vars_change (a # as) vs s = s' # ss;\n     \\<not> fmrestrict_set vs (state_succ s a) \\<noteq>\n            fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as1 act as2.\n                         a # as = as1 @ act # as2 \\<and>\n                         vars_change as1 vs s = [] \\<and>\n                         state_succ (exec_plan s as1) act = s' \\<and>\n                         vars_change as2 vs\n                          (state_succ (exec_plan s as1) act) =\n                         ss", "then"], ["proof (chain)\npicking this:\n  state_succ s a = s'\n  vars_change as vs (state_succ s a) = ss", "show ?thesis"], ["proof (prove)\nusing this:\n  state_succ s a = s'\n  vars_change as vs (state_succ s a) = ss\n\ngoal (1 subgoal):\n 1. \\<exists>as1 act as2.\n       a # as = as1 @ act # as2 \\<and>\n       vars_change as1 vs s = [] \\<and>\n       state_succ (exec_plan s as1) act = s' \\<and>\n       vars_change as2 vs (state_succ (exec_plan s as1) act) = ss", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as1 act as2.\n     a # as = as1 @ act # as2 \\<and>\n     vars_change as1 vs s = [] \\<and>\n     state_succ (exec_plan s as1) act = s' \\<and>\n     vars_change as2 vs (state_succ (exec_plan s as1) act) = ss\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>vs s s' ss.\n                vars_change as vs s = s' # ss \\<Longrightarrow>\n                \\<exists>as1 act as2.\n                   as = as1 @ act # as2 \\<and>\n                   vars_change as1 vs s = [] \\<and>\n                   state_succ (exec_plan s as1) act = s' \\<and>\n                   vars_change as2 vs (state_succ (exec_plan s as1) act) =\n                   ss;\n     vars_change (a # as) vs s = s' # ss;\n     \\<not> fmrestrict_set vs (state_succ s a) \\<noteq>\n            fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as1 act as2.\n                         a # as = as1 @ act # as2 \\<and>\n                         vars_change as1 vs s = [] \\<and>\n                         state_succ (exec_plan s as1) act = s' \\<and>\n                         vars_change as2 vs\n                          (state_succ (exec_plan s as1) act) =\n                         ss", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>vs s s' ss.\n                vars_change as vs s = s' # ss \\<Longrightarrow>\n                \\<exists>as1 act as2.\n                   as = as1 @ act # as2 \\<and>\n                   vars_change as1 vs s = [] \\<and>\n                   state_succ (exec_plan s as1) act = s' \\<and>\n                   vars_change as2 vs (state_succ (exec_plan s as1) act) =\n                   ss;\n     vars_change (a # as) vs s = s' # ss;\n     \\<not> fmrestrict_set vs (state_succ s a) \\<noteq>\n            fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as1 act as2.\n                         a # as = as1 @ act # as2 \\<and>\n                         vars_change as1 vs s = [] \\<and>\n                         state_succ (exec_plan s as1) act = s' \\<and>\n                         vars_change as2 vs\n                          (state_succ (exec_plan s as1) act) =\n                         ss", "case False"], ["proof (state)\nthis:\n  \\<not> fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>vs s s' ss.\n                vars_change as vs s = s' # ss \\<Longrightarrow>\n                \\<exists>as1 act as2.\n                   as = as1 @ act # as2 \\<and>\n                   vars_change as1 vs s = [] \\<and>\n                   state_succ (exec_plan s as1) act = s' \\<and>\n                   vars_change as2 vs (state_succ (exec_plan s as1) act) =\n                   ss;\n     vars_change (a # as) vs s = s' # ss;\n     \\<not> fmrestrict_set vs (state_succ s a) \\<noteq>\n            fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as1 act as2.\n                         a # as = as1 @ act # as2 \\<and>\n                         vars_change as1 vs s = [] \\<and>\n                         state_succ (exec_plan s as1) act = s' \\<and>\n                         vars_change as2 vs\n                          (state_succ (exec_plan s as1) act) =\n                         ss", "then"], ["proof (chain)\npicking this:\n  \\<not> fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s", "have \"vars_change as vs (state_succ s a) = s' # ss\""], ["proof (prove)\nusing this:\n  \\<not> fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s\n\ngoal (1 subgoal):\n 1. vars_change as vs (state_succ s a) = s' # ss", "using Cons.prems"], ["proof (prove)\nusing this:\n  \\<not> fmrestrict_set vs (state_succ s a) \\<noteq> fmrestrict_set vs s\n  vars_change (a # as) vs s = s' # ss\n\ngoal (1 subgoal):\n 1. vars_change as vs (state_succ s a) = s' # ss", "by simp"], ["proof (state)\nthis:\n  vars_change as vs (state_succ s a) = s' # ss\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>vs s s' ss.\n                vars_change as vs s = s' # ss \\<Longrightarrow>\n                \\<exists>as1 act as2.\n                   as = as1 @ act # as2 \\<and>\n                   vars_change as1 vs s = [] \\<and>\n                   state_succ (exec_plan s as1) act = s' \\<and>\n                   vars_change as2 vs (state_succ (exec_plan s as1) act) =\n                   ss;\n     vars_change (a # as) vs s = s' # ss;\n     \\<not> fmrestrict_set vs (state_succ s a) \\<noteq>\n            fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as1 act as2.\n                         a # as = as1 @ act # as2 \\<and>\n                         vars_change as1 vs s = [] \\<and>\n                         state_succ (exec_plan s as1) act = s' \\<and>\n                         vars_change as2 vs\n                          (state_succ (exec_plan s as1) act) =\n                         ss", "then"], ["proof (chain)\npicking this:\n  vars_change as vs (state_succ s a) = s' # ss", "obtain as1 act as2 where\n      \"as = as1 @ act # as2\" \"vars_change as1 vs (state_succ s a) = []\"\n      \"state_succ (exec_plan (state_succ s a) as1) act = s'\"\n      \"vars_change as2 vs (state_succ (exec_plan (state_succ s a) as1) act) = ss\""], ["proof (prove)\nusing this:\n  vars_change as vs (state_succ s a) = s' # ss\n\ngoal (1 subgoal):\n 1. (\\<And>as1 act as2.\n        \\<lbrakk>as = as1 @ act # as2;\n         vars_change as1 vs (state_succ s a) = [];\n         state_succ (exec_plan (state_succ s a) as1) act = s';\n         vars_change as2 vs\n          (state_succ (exec_plan (state_succ s a) as1) act) =\n         ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons.IH"], ["proof (prove)\nusing this:\n  vars_change as vs (state_succ s a) = s' # ss\n  vars_change as ?vs ?s = ?s' # ?ss \\<Longrightarrow>\n  \\<exists>as1 act as2.\n     as = as1 @ act # as2 \\<and>\n     vars_change as1 ?vs ?s = [] \\<and>\n     state_succ (exec_plan ?s as1) act = ?s' \\<and>\n     vars_change as2 ?vs (state_succ (exec_plan ?s as1) act) = ?ss\n\ngoal (1 subgoal):\n 1. (\\<And>as1 act as2.\n        \\<lbrakk>as = as1 @ act # as2;\n         vars_change as1 vs (state_succ s a) = [];\n         state_succ (exec_plan (state_succ s a) as1) act = s';\n         vars_change as2 vs\n          (state_succ (exec_plan (state_succ s a) as1) act) =\n         ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  as = as1 @ act # as2\n  vars_change as1 vs (state_succ s a) = []\n  state_succ (exec_plan (state_succ s a) as1) act = s'\n  vars_change as2 vs (state_succ (exec_plan (state_succ s a) as1) act) = ss\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>vs s s' ss.\n                vars_change as vs s = s' # ss \\<Longrightarrow>\n                \\<exists>as1 act as2.\n                   as = as1 @ act # as2 \\<and>\n                   vars_change as1 vs s = [] \\<and>\n                   state_succ (exec_plan s as1) act = s' \\<and>\n                   vars_change as2 vs (state_succ (exec_plan s as1) act) =\n                   ss;\n     vars_change (a # as) vs s = s' # ss;\n     \\<not> fmrestrict_set vs (state_succ s a) \\<noteq>\n            fmrestrict_set vs s\\<rbrakk>\n    \\<Longrightarrow> \\<exists>as1 act as2.\n                         a # as = as1 @ act # as2 \\<and>\n                         vars_change as1 vs s = [] \\<and>\n                         state_succ (exec_plan s as1) act = s' \\<and>\n                         vars_change as2 vs\n                          (state_succ (exec_plan s as1) act) =\n                         ss", "then"], ["proof (chain)\npicking this:\n  as = as1 @ act # as2\n  vars_change as1 vs (state_succ s a) = []\n  state_succ (exec_plan (state_succ s a) as1) act = s'\n  vars_change as2 vs (state_succ (exec_plan (state_succ s a) as1) act) = ss", "show ?thesis"], ["proof (prove)\nusing this:\n  as = as1 @ act # as2\n  vars_change as1 vs (state_succ s a) = []\n  state_succ (exec_plan (state_succ s a) as1) act = s'\n  vars_change as2 vs (state_succ (exec_plan (state_succ s a) as1) act) = ss\n\ngoal (1 subgoal):\n 1. \\<exists>as1 act as2.\n       a # as = as1 @ act # as2 \\<and>\n       vars_change as1 vs s = [] \\<and>\n       state_succ (exec_plan s as1) act = s' \\<and>\n       vars_change as2 vs (state_succ (exec_plan s as1) act) = ss", "by (metis False append_Cons exec_plan.simps(2) vars_change.simps(2))"], ["proof (state)\nthis:\n  \\<exists>as1 act as2.\n     a # as = as1 @ act # as2 \\<and>\n     vars_change as1 vs s = [] \\<and>\n     state_succ (exec_plan s as1) act = s' \\<and>\n     vars_change as2 vs (state_succ (exec_plan s as1) act) = ss\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>as1 act as2.\n     a # as = as1 @ act # as2 \\<and>\n     vars_change as1 vs s = [] \\<and>\n     state_succ (exec_plan s as1) act = s' \\<and>\n     vars_change as2 vs (state_succ (exec_plan s as1) act) = ss\n\ngoal (1 subgoal):\n 1. \\<And>s s' vs ss.\n       vars_change [] vs s = s' # ss \\<Longrightarrow>\n       \\<exists>as1 act as2.\n          [] = as1 @ act # as2 \\<and>\n          vars_change as1 vs s = [] \\<and>\n          state_succ (exec_plan s as1) act = s' \\<and>\n          vars_change as2 vs (state_succ (exec_plan s as1) act) = ss", "qed simp"], ["", "lemma vars_change_cons_2:\n  fixes s s'\n  assumes \"(vars_change as vs s = (s' # ss))\"\n  shows \"(fmrestrict_set vs s' \\<noteq> fmrestrict_set vs s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrestrict_set vs s' \\<noteq> fmrestrict_set vs s", "using assms"], ["proof (prove)\nusing this:\n  vars_change as vs s = s' # ss\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs s' \\<noteq> fmrestrict_set vs s", "apply(induction as arbitrary: s s' vs ss)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s s' vs ss.\n       vars_change [] vs s = s' # ss \\<Longrightarrow>\n       fmrestrict_set vs s' \\<noteq> fmrestrict_set vs s\n 2. \\<And>a as s s' vs ss.\n       \\<lbrakk>\\<And>s s' vs ss.\n                   vars_change as vs s = s' # ss \\<Longrightarrow>\n                   fmrestrict_set vs s' \\<noteq> fmrestrict_set vs s;\n        vars_change (a # as) vs s = s' # ss\\<rbrakk>\n       \\<Longrightarrow> fmrestrict_set vs s' \\<noteq> fmrestrict_set vs s", "apply(auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b as s s' vs ss.\n       \\<lbrakk>\\<And>s s' vs ss.\n                   vars_change as vs s = s' # ss \\<Longrightarrow>\n                   fmrestrict_set vs s' \\<noteq> fmrestrict_set vs s;\n        (if fmrestrict_set vs (state_succ s (a, b)) \\<noteq>\n            fmrestrict_set vs s\n         then state_succ s (a, b) # vars_change as vs (state_succ s (a, b))\n         else vars_change as vs (state_succ s (a, b))) =\n        s' # ss;\n        fmrestrict_set vs s' = fmrestrict_set vs s\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis list.inject)\n\n\n\\<comment> \\<open>NOTE first argument of `top\\_sorted\\_abs had to be wrapped into lambda.\\<close>"], ["", "lemma problem_plan_bound_S_bound_1st_step:\n  fixes PROB :: \"'a problem\"\n  assumes \"finite PROB\" \"(top_sorted_abs (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss)\"\n    \"(set lss = valid_states (prob_proj PROB vs))\" \"(s \\<in> valid_states PROB)\"\n    \"(as \\<in> valid_plans PROB)\" \"(no_effectless_act as)\" \"(sat_precond_as s as)\"\n  shows \"(\\<exists>as'.\n      (exec_plan s as' = exec_plan s as)\n      \\<and> (subseq as' as)\n      \\<and> (length as' <= S vs lss PROB (fmrestrict_set vs s))\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "using assms"], ["proof (prove)\nusing this:\n  finite PROB\n  top_sorted_abs\n   (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss\n  set lss = valid_states (prob_proj PROB vs)\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  no_effectless_act as\n  sat_precond_as s as\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "proof (induction \"vars_change as vs s\" arbitrary: PROB as vs s lss)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as vs s PROB lss.\n       \\<lbrakk>[] = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)\n 2. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "case Nil"], ["proof (state)\nthis:\n  [] = vars_change as vs s\n  finite PROB\n  top_sorted_abs\n   (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss\n  set lss = valid_states (prob_proj PROB vs)\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  no_effectless_act as\n  sat_precond_as s as\n\ngoal (2 subgoals):\n 1. \\<And>as vs s PROB lss.\n       \\<lbrakk>[] = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)\n 2. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "then"], ["proof (chain)\npicking this:\n  [] = vars_change as vs s\n  finite PROB\n  top_sorted_abs\n   (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss\n  set lss = valid_states (prob_proj PROB vs)\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  no_effectless_act as\n  sat_precond_as s as", "obtain as' where\n    \"exec_plan s as = exec_plan s as'\" \"subseq as' as\"\n    \"length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\""], ["proof (prove)\nusing this:\n  [] = vars_change as vs s\n  finite PROB\n  top_sorted_abs\n   (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss\n  set lss = valid_states (prob_proj PROB vs)\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  no_effectless_act as\n  sat_precond_as s as\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan s as = exec_plan s as'; subseq as' as;\n         length as'\n         \\<le> problem_plan_bound\n                (snapshot PROB (fmrestrict_set vs s))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Nil(1) Nil.prems(1,4,5,6,7) no_vs_change_snapshot_s_vs_is_valid_bound"], ["proof (prove)\nusing this:\n  [] = vars_change as vs s\n  finite PROB\n  top_sorted_abs\n   (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss\n  set lss = valid_states (prob_proj PROB vs)\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  no_effectless_act as\n  sat_precond_as s as\n  [] = vars_change as vs s\n  finite PROB\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  no_effectless_act as\n  sat_precond_as s as\n  \\<lbrakk>finite ?PROB; vars_change ?as ?vs ?s = []; no_effectless_act ?as;\n   sat_precond_as ?s ?as; ?s \\<in> valid_states ?PROB;\n   ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s ?as = exec_plan ?s as' \\<and>\n                       subseq as' ?as \\<and>\n                       length as'\n                       \\<le> problem_plan_bound\n                              (snapshot ?PROB (fmrestrict_set ?vs ?s))\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan s as = exec_plan s as'; subseq as' as;\n         length as'\n         \\<le> problem_plan_bound\n                (snapshot PROB (fmrestrict_set vs s))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n\ngoal (2 subgoals):\n 1. \\<And>as vs s PROB lss.\n       \\<lbrakk>[] = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)\n 2. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "moreover"], ["proof (state)\nthis:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n\ngoal (2 subgoals):\n 1. \\<And>as vs s PROB lss.\n       \\<lbrakk>[] = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)\n 2. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "have \"\n      problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n      \\<le> S vs lss PROB (fmrestrict_set vs s)\n    \""], ["proof (prove)\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "using snapshot_bound_leq_S le_trans"], ["proof (prove)\nusing this:\n  problem_plan_bound (snapshot ?PROB (fmrestrict_set ?vs ?s))\n  \\<le> S ?vs ?lss ?PROB (fmrestrict_set ?vs ?s)\n  \\<lbrakk>?i \\<le> ?j; ?j \\<le> ?k\\<rbrakk> \\<Longrightarrow> ?i \\<le> ?k\n\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "by fast"], ["proof (state)\nthis:\n  problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n  \\<le> S vs lss PROB (fmrestrict_set vs s)\n\ngoal (2 subgoals):\n 1. \\<And>as vs s PROB lss.\n       \\<lbrakk>[] = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)\n 2. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "ultimately"], ["proof (chain)\npicking this:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n  problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n  \\<le> S vs lss PROB (fmrestrict_set vs s)", "show ?case"], ["proof (prove)\nusing this:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n  problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n  \\<le> S vs lss PROB (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "using le_trans"], ["proof (prove)\nusing this:\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n  length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n  problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n  \\<le> S vs lss PROB (fmrestrict_set vs s)\n  \\<lbrakk>?i \\<le> ?j; ?j \\<le> ?k\\<rbrakk> \\<Longrightarrow> ?i \\<le> ?k\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan s as' = exec_plan s as \\<and>\n     subseq as' as \\<and>\n     length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "case (Cons s' ss)"], ["proof (state)\nthis:\n  \\<lbrakk>ss = vars_change ?as ?vs ?s; finite ?PROB;\n   top_sorted_abs\n    (\\<lambda>x y. y \\<in> state_successors (prob_proj ?PROB ?vs) x) ?lss;\n   set ?lss = valid_states (prob_proj ?PROB ?vs);\n   ?s \\<in> valid_states ?PROB; ?as \\<in> valid_plans ?PROB;\n   no_effectless_act ?as; sat_precond_as ?s ?as\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s as' = exec_plan ?s ?as \\<and>\n                       subseq as' ?as \\<and>\n                       length as'\n                       \\<le> S ?vs ?lss ?PROB (fmrestrict_set ?vs ?s)\n  s' # ss = vars_change as vs s\n  finite PROB\n  top_sorted_abs\n   (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss\n  set lss = valid_states (prob_proj PROB vs)\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  no_effectless_act as\n  sat_precond_as s as\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>ss = vars_change ?as ?vs ?s; finite ?PROB;\n   top_sorted_abs\n    (\\<lambda>x y. y \\<in> state_successors (prob_proj ?PROB ?vs) x) ?lss;\n   set ?lss = valid_states (prob_proj ?PROB ?vs);\n   ?s \\<in> valid_states ?PROB; ?as \\<in> valid_plans ?PROB;\n   no_effectless_act ?as; sat_precond_as ?s ?as\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s as' = exec_plan ?s ?as \\<and>\n                       subseq as' ?as \\<and>\n                       length as'\n                       \\<le> S ?vs ?lss ?PROB (fmrestrict_set ?vs ?s)\n  s' # ss = vars_change as vs s\n  finite PROB\n  top_sorted_abs\n   (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss\n  set lss = valid_states (prob_proj PROB vs)\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  no_effectless_act as\n  sat_precond_as s as", "obtain as1 act as2 where 1:\n    \"as = as1 @ act # as2\" \"vars_change as1 vs s = []\" \"state_succ (exec_plan s as1) act = s'\"\n    \"vars_change as2 vs (state_succ (exec_plan s as1) act) = ss\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ss = vars_change ?as ?vs ?s; finite ?PROB;\n   top_sorted_abs\n    (\\<lambda>x y. y \\<in> state_successors (prob_proj ?PROB ?vs) x) ?lss;\n   set ?lss = valid_states (prob_proj ?PROB ?vs);\n   ?s \\<in> valid_states ?PROB; ?as \\<in> valid_plans ?PROB;\n   no_effectless_act ?as; sat_precond_as ?s ?as\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s as' = exec_plan ?s ?as \\<and>\n                       subseq as' ?as \\<and>\n                       length as'\n                       \\<le> S ?vs ?lss ?PROB (fmrestrict_set ?vs ?s)\n  s' # ss = vars_change as vs s\n  finite PROB\n  top_sorted_abs\n   (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss\n  set lss = valid_states (prob_proj PROB vs)\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  no_effectless_act as\n  sat_precond_as s as\n\ngoal (1 subgoal):\n 1. (\\<And>as1 act as2.\n        \\<lbrakk>as = as1 @ act # as2; vars_change as1 vs s = [];\n         state_succ (exec_plan s as1) act = s';\n         vars_change as2 vs (state_succ (exec_plan s as1) act) = ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using vars_change_cons"], ["proof (prove)\nusing this:\n  \\<lbrakk>ss = vars_change ?as ?vs ?s; finite ?PROB;\n   top_sorted_abs\n    (\\<lambda>x y. y \\<in> state_successors (prob_proj ?PROB ?vs) x) ?lss;\n   set ?lss = valid_states (prob_proj ?PROB ?vs);\n   ?s \\<in> valid_states ?PROB; ?as \\<in> valid_plans ?PROB;\n   no_effectless_act ?as; sat_precond_as ?s ?as\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s as' = exec_plan ?s ?as \\<and>\n                       subseq as' ?as \\<and>\n                       length as'\n                       \\<le> S ?vs ?lss ?PROB (fmrestrict_set ?vs ?s)\n  s' # ss = vars_change as vs s\n  finite PROB\n  top_sorted_abs\n   (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss\n  set lss = valid_states (prob_proj PROB vs)\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  no_effectless_act as\n  sat_precond_as s as\n  vars_change ?as ?vs ?s = ?s' # ?ss \\<Longrightarrow>\n  \\<exists>as1 act as2.\n     ?as = as1 @ act # as2 \\<and>\n     vars_change as1 ?vs ?s = [] \\<and>\n     state_succ (exec_plan ?s as1) act = ?s' \\<and>\n     vars_change as2 ?vs (state_succ (exec_plan ?s as1) act) = ?ss\n\ngoal (1 subgoal):\n 1. (\\<And>as1 act as2.\n        \\<lbrakk>as = as1 @ act # as2; vars_change as1 vs s = [];\n         state_succ (exec_plan s as1) act = s';\n         vars_change as2 vs (state_succ (exec_plan s as1) act) = ss\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by smt"], ["proof (state)\nthis:\n  as = as1 @ act # as2\n  vars_change as1 vs s = []\n  state_succ (exec_plan s as1) act = s'\n  vars_change as2 vs (state_succ (exec_plan s as1) act) = ss\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "text\\<open> Obtain conclusion of induction hypothesis for 'as2' and\n      '(state\\_succ (exec\\_plan s as1) act)'. \\<close>"], ["proof (state)\nthis:\n  as = as1 @ act # as2\n  vars_change as1 vs s = []\n  state_succ (exec_plan s as1) act = s'\n  vars_change as2 vs (state_succ (exec_plan s as1) act) = ss\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "{"], ["proof (state)\nthis:\n  as = as1 @ act # as2\n  vars_change as1 vs s = []\n  state_succ (exec_plan s as1) act = s'\n  vars_change as2 vs (state_succ (exec_plan s as1) act) = ss\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "{"], ["proof (state)\nthis:\n  as = as1 @ act # as2\n  vars_change as1 vs s = []\n  state_succ (exec_plan s as1) act = s'\n  vars_change as2 vs (state_succ (exec_plan s as1) act) = ss\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "have \"as1 \\<in> valid_plans PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as1 \\<in> valid_plans PROB", "using Cons.prems(5) 1(1) valid_append_valid_pref"], ["proof (prove)\nusing this:\n  as \\<in> valid_plans PROB\n  as = as1 @ act # as2\n  ?as1.0 @ ?as2.0 \\<in> valid_plans ?PROB \\<Longrightarrow>\n  ?as1.0 \\<in> valid_plans ?PROB\n\ngoal (1 subgoal):\n 1. as1 \\<in> valid_plans PROB", "by blast"], ["proof (state)\nthis:\n  as1 \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "moreover"], ["proof (state)\nthis:\n  as1 \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "have \"act \\<in> PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. act \\<in> PROB", "using Cons.prems(5) 1 valid_append_valid_suff valid_plan_valid_head"], ["proof (prove)\nusing this:\n  as \\<in> valid_plans PROB\n  as = as1 @ act # as2\n  vars_change as1 vs s = []\n  state_succ (exec_plan s as1) act = s'\n  vars_change as2 vs (state_succ (exec_plan s as1) act) = ss\n  ?as1.0 @ ?as2.0 \\<in> valid_plans ?PROB \\<Longrightarrow>\n  ?as2.0 \\<in> valid_plans ?PROB\n  ?h # ?as \\<in> valid_plans ?PROB \\<Longrightarrow> ?h \\<in> ?PROB\n\ngoal (1 subgoal):\n 1. act \\<in> PROB", "by fast"], ["proof (state)\nthis:\n  act \\<in> PROB\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "ultimately"], ["proof (chain)\npicking this:\n  as1 \\<in> valid_plans PROB\n  act \\<in> PROB", "have \"state_succ (exec_plan s as1) act \\<in> valid_states PROB\""], ["proof (prove)\nusing this:\n  as1 \\<in> valid_plans PROB\n  act \\<in> PROB\n\ngoal (1 subgoal):\n 1. state_succ (exec_plan s as1) act \\<in> valid_states PROB", "using Cons.prems(4) valid_as_valid_exec lemma_1_i"], ["proof (prove)\nusing this:\n  as1 \\<in> valid_plans PROB\n  act \\<in> PROB\n  s \\<in> valid_states PROB\n  \\<lbrakk>?as \\<in> valid_plans ?PROB; ?s \\<in> valid_states ?PROB\\<rbrakk>\n  \\<Longrightarrow> exec_plan ?s ?as \\<in> valid_states ?PROB\n  \\<lbrakk>?s \\<in> valid_states ?PROB; ?a \\<in> ?PROB\\<rbrakk>\n  \\<Longrightarrow> state_succ ?s ?a \\<in> valid_states ?PROB\n\ngoal (1 subgoal):\n 1. state_succ (exec_plan s as1) act \\<in> valid_states PROB", "by blast"], ["proof (state)\nthis:\n  state_succ (exec_plan s as1) act \\<in> valid_states PROB\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "}"], ["proof (state)\nthis:\n  state_succ (exec_plan s as1) act \\<in> valid_states PROB\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "moreover"], ["proof (state)\nthis:\n  state_succ (exec_plan s as1) act \\<in> valid_states PROB\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "have \"as2 \\<in> valid_plans PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as2 \\<in> valid_plans PROB", "using Cons.prems(5) 1(1) valid_append_valid_suff valid_plan_valid_tail"], ["proof (prove)\nusing this:\n  as \\<in> valid_plans PROB\n  as = as1 @ act # as2\n  ?as1.0 @ ?as2.0 \\<in> valid_plans ?PROB \\<Longrightarrow>\n  ?as2.0 \\<in> valid_plans ?PROB\n  ?h # ?as \\<in> valid_plans ?PROB \\<Longrightarrow>\n  ?as \\<in> valid_plans ?PROB\n\ngoal (1 subgoal):\n 1. as2 \\<in> valid_plans PROB", "by fast"], ["proof (state)\nthis:\n  as2 \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "moreover"], ["proof (state)\nthis:\n  as2 \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "have \"no_effectless_act as2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_effectless_act as2", "using Cons.prems(6) 1(1) rem_effectless_works_13 sublist_append_back"], ["proof (prove)\nusing this:\n  no_effectless_act as\n  as = as1 @ act # as2\n  \\<lbrakk>subseq ?as1.0 ?as2.0; no_effectless_act ?as2.0\\<rbrakk>\n  \\<Longrightarrow> no_effectless_act ?as1.0\n  subseq ?l1.0 (?l2.0 @ ?l1.0)\n\ngoal (1 subgoal):\n 1. no_effectless_act as2", "by blast"], ["proof (state)\nthis:\n  no_effectless_act as2\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "moreover"], ["proof (state)\nthis:\n  no_effectless_act as2\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "have \"sat_precond_as (state_succ (exec_plan s as1) act) as2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat_precond_as (state_succ (exec_plan s as1) act) as2", "using Cons.prems(7) 1(1) graph_plan_lemma_17 sat_precond_as.simps(2)"], ["proof (prove)\nusing this:\n  sat_precond_as s as\n  as = as1 @ act # as2\n  \\<lbrakk>?as_1.0 @ ?as_2.0 = ?as; sat_precond_as ?s ?as\\<rbrakk>\n  \\<Longrightarrow> sat_precond_as ?s ?as_1.0 \\<and>\n                    sat_precond_as (exec_plan ?s ?as_1.0) ?as_2.0\n  sat_precond_as ?s (?a # ?as) =\n  (fst ?a \\<subseteq>\\<^sub>f ?s \\<and>\n   sat_precond_as (state_succ ?s ?a) ?as)\n\ngoal (1 subgoal):\n 1. sat_precond_as (state_succ (exec_plan s as1) act) as2", "by blast"], ["proof (state)\nthis:\n  sat_precond_as (state_succ (exec_plan s as1) act) as2\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "ultimately"], ["proof (chain)\npicking this:\n  state_succ (exec_plan s as1) act \\<in> valid_states PROB\n  as2 \\<in> valid_plans PROB\n  no_effectless_act as2\n  sat_precond_as (state_succ (exec_plan s as1) act) as2", "have \"\\<exists>as'.\n          exec_plan (state_succ (exec_plan s as1) act) as'\n          = exec_plan (state_succ (exec_plan s as1) act) as2\n        \\<and> subseq as' as2\n        \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs (state_succ (exec_plan s as1) act))\""], ["proof (prove)\nusing this:\n  state_succ (exec_plan s as1) act \\<in> valid_states PROB\n  as2 \\<in> valid_plans PROB\n  no_effectless_act as2\n  sat_precond_as (state_succ (exec_plan s as1) act) as2\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan (state_succ (exec_plan s as1) act) as' =\n       exec_plan (state_succ (exec_plan s as1) act) as2 \\<and>\n       subseq as' as2 \\<and>\n       length as'\n       \\<le> S vs lss PROB\n              (fmrestrict_set vs (state_succ (exec_plan s as1) act))", "using Cons.prems(1, 2, 3) 1(4)\n        Cons(1)[where as=\"as2\" and s=\"(state_succ (exec_plan s as1) act)\"]"], ["proof (prove)\nusing this:\n  state_succ (exec_plan s as1) act \\<in> valid_states PROB\n  as2 \\<in> valid_plans PROB\n  no_effectless_act as2\n  sat_precond_as (state_succ (exec_plan s as1) act) as2\n  finite PROB\n  top_sorted_abs\n   (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss\n  set lss = valid_states (prob_proj PROB vs)\n  vars_change as2 vs (state_succ (exec_plan s as1) act) = ss\n  \\<lbrakk>ss = vars_change as2 ?vs (state_succ (exec_plan s as1) act);\n   finite ?PROB;\n   top_sorted_abs\n    (\\<lambda>x y. y \\<in> state_successors (prob_proj ?PROB ?vs) x) ?lss;\n   set ?lss = valid_states (prob_proj ?PROB ?vs);\n   state_succ (exec_plan s as1) act \\<in> valid_states ?PROB;\n   as2 \\<in> valid_plans ?PROB; no_effectless_act as2;\n   sat_precond_as (state_succ (exec_plan s as1) act) as2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan (state_succ (exec_plan s as1) act) as' =\n                       exec_plan (state_succ (exec_plan s as1) act)\n                        as2 \\<and>\n                       subseq as' as2 \\<and>\n                       length as'\n                       \\<le> S ?vs ?lss ?PROB\n                              (fmrestrict_set ?vs\n                                (state_succ (exec_plan s as1) act))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan (state_succ (exec_plan s as1) act) as' =\n       exec_plan (state_succ (exec_plan s as1) act) as2 \\<and>\n       subseq as' as2 \\<and>\n       length as'\n       \\<le> S vs lss PROB\n              (fmrestrict_set vs (state_succ (exec_plan s as1) act))", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan (state_succ (exec_plan s as1) act) as' =\n     exec_plan (state_succ (exec_plan s as1) act) as2 \\<and>\n     subseq as' as2 \\<and>\n     length as'\n     \\<le> S vs lss PROB\n            (fmrestrict_set vs (state_succ (exec_plan s as1) act))\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "}"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan (state_succ (exec_plan s as1) act) as' =\n     exec_plan (state_succ (exec_plan s as1) act) as2 \\<and>\n     subseq as' as2 \\<and>\n     length as'\n     \\<le> S vs lss PROB\n            (fmrestrict_set vs (state_succ (exec_plan s as1) act))\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "note a=this"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan (state_succ (exec_plan s as1) act) as' =\n     exec_plan (state_succ (exec_plan s as1) act) as2 \\<and>\n     subseq as' as2 \\<and>\n     length as'\n     \\<le> S vs lss PROB\n            (fmrestrict_set vs (state_succ (exec_plan s as1) act))\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "{"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan (state_succ (exec_plan s as1) act) as' =\n     exec_plan (state_succ (exec_plan s as1) act) as2 \\<and>\n     subseq as' as2 \\<and>\n     length as'\n     \\<le> S vs lss PROB\n            (fmrestrict_set vs (state_succ (exec_plan s as1) act))\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "have \"no_effectless_act as1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_effectless_act as1", "using Cons.prems(6) 1(1) rem_effectless_works_12"], ["proof (prove)\nusing this:\n  no_effectless_act as\n  as = as1 @ act # as2\n  no_effectless_act (?as1.0 @ ?as2.0) =\n  (no_effectless_act ?as1.0 \\<and> no_effectless_act ?as2.0)\n\ngoal (1 subgoal):\n 1. no_effectless_act as1", "by blast"], ["proof (state)\nthis:\n  no_effectless_act as1\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "moreover"], ["proof (state)\nthis:\n  no_effectless_act as1\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "have \"sat_precond_as s as1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat_precond_as s as1", "using Cons.prems(7) 1(1) sat_precond_as_pfx"], ["proof (prove)\nusing this:\n  sat_precond_as s as\n  as = as1 @ act # as2\n  sat_precond_as ?s (?as @ ?as') \\<Longrightarrow> sat_precond_as ?s ?as\n\ngoal (1 subgoal):\n 1. sat_precond_as s as1", "by blast"], ["proof (state)\nthis:\n  sat_precond_as s as1\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "moreover"], ["proof (state)\nthis:\n  sat_precond_as s as1\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "have \"as1 \\<in> valid_plans PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. as1 \\<in> valid_plans PROB", "using Cons.prems(5) 1(1) valid_append_valid_pref"], ["proof (prove)\nusing this:\n  as \\<in> valid_plans PROB\n  as = as1 @ act # as2\n  ?as1.0 @ ?as2.0 \\<in> valid_plans ?PROB \\<Longrightarrow>\n  ?as1.0 \\<in> valid_plans ?PROB\n\ngoal (1 subgoal):\n 1. as1 \\<in> valid_plans PROB", "by blast"], ["proof (state)\nthis:\n  as1 \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "ultimately"], ["proof (chain)\npicking this:\n  no_effectless_act as1\n  sat_precond_as s as1\n  as1 \\<in> valid_plans PROB", "have \"\\<exists>as'. exec_plan s as1 = exec_plan s as' \\<and>\n        subseq as' as1 \\<and> length as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\""], ["proof (prove)\nusing this:\n  no_effectless_act as1\n  sat_precond_as s as1\n  as1 \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as1 = exec_plan s as' \\<and>\n       subseq as' as1 \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "using no_vs_change_snapshot_s_vs_is_valid_bound[of _ as1]"], ["proof (prove)\nusing this:\n  no_effectless_act as1\n  sat_precond_as s as1\n  as1 \\<in> valid_plans PROB\n  \\<lbrakk>finite ?PROB; vars_change as1 ?vs ?s = []; no_effectless_act as1;\n   sat_precond_as ?s as1; ?s \\<in> valid_states ?PROB;\n   as1 \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s as1 = exec_plan ?s as' \\<and>\n                       subseq as' as1 \\<and>\n                       length as'\n                       \\<le> problem_plan_bound\n                              (snapshot ?PROB (fmrestrict_set ?vs ?s))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as1 = exec_plan s as' \\<and>\n       subseq as' as1 \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "using Cons.prems(1, 4) 1(2)"], ["proof (prove)\nusing this:\n  no_effectless_act as1\n  sat_precond_as s as1\n  as1 \\<in> valid_plans PROB\n  \\<lbrakk>finite ?PROB; vars_change as1 ?vs ?s = []; no_effectless_act as1;\n   sat_precond_as ?s as1; ?s \\<in> valid_states ?PROB;\n   as1 \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s as1 = exec_plan ?s as' \\<and>\n                       subseq as' as1 \\<and>\n                       length as'\n                       \\<le> problem_plan_bound\n                              (snapshot ?PROB (fmrestrict_set ?vs ?s))\n  finite PROB\n  s \\<in> valid_states PROB\n  vars_change as1 vs s = []\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as1 = exec_plan s as' \\<and>\n       subseq as' as1 \\<and>\n       length as'\n       \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan s as1 = exec_plan s as' \\<and>\n     subseq as' as1 \\<and>\n     length as'\n     \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "}"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan s as1 = exec_plan s as' \\<and>\n     subseq as' as1 \\<and>\n     length as'\n     \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "then"], ["proof (chain)\npicking this:\n  \\<exists>as'.\n     exec_plan s as1 = exec_plan s as' \\<and>\n     subseq as' as1 \\<and>\n     length as'\n     \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))", "obtain as'' where b:\n    \"exec_plan s as1 = exec_plan s as''\" \"subseq as'' as1\"\n    \"length as'' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\""], ["proof (prove)\nusing this:\n  \\<exists>as'.\n     exec_plan s as1 = exec_plan s as' \\<and>\n     subseq as' as1 \\<and>\n     length as'\n     \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. (\\<And>as''.\n        \\<lbrakk>exec_plan s as1 = exec_plan s as''; subseq as'' as1;\n         length as''\n         \\<le> problem_plan_bound\n                (snapshot PROB (fmrestrict_set vs s))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  exec_plan s as1 = exec_plan s as''\n  subseq as'' as1\n  length as'' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "{"], ["proof (state)\nthis:\n  exec_plan s as1 = exec_plan s as''\n  subseq as'' as1\n  length as'' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "obtain as' where i:\n      \"exec_plan (state_succ (exec_plan s as1) act) as'\n          = exec_plan (state_succ (exec_plan s as1) act) as2\"\n      \"subseq as' as2\"\n      \"length as' \\<le> S vs lss PROB (fmrestrict_set vs (state_succ (exec_plan s as1) act))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan (state_succ (exec_plan s as1) act) as' =\n                 exec_plan (state_succ (exec_plan s as1) act) as2;\n         subseq as' as2;\n         length as'\n         \\<le> S vs lss PROB\n                (fmrestrict_set vs\n                  (state_succ (exec_plan s as1) act))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using a"], ["proof (prove)\nusing this:\n  \\<exists>as'.\n     exec_plan (state_succ (exec_plan s as1) act) as' =\n     exec_plan (state_succ (exec_plan s as1) act) as2 \\<and>\n     subseq as' as2 \\<and>\n     length as'\n     \\<le> S vs lss PROB\n            (fmrestrict_set vs (state_succ (exec_plan s as1) act))\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan (state_succ (exec_plan s as1) act) as' =\n                 exec_plan (state_succ (exec_plan s as1) act) as2;\n         subseq as' as2;\n         length as'\n         \\<le> S vs lss PROB\n                (fmrestrict_set vs\n                  (state_succ (exec_plan s as1) act))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  exec_plan (state_succ (exec_plan s as1) act) as' =\n  exec_plan (state_succ (exec_plan s as1) act) as2\n  subseq as' as2\n  length as'\n  \\<le> S vs lss PROB (fmrestrict_set vs (state_succ (exec_plan s as1) act))\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "let ?as'=\"as'' @ act # as'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "have \"exec_plan s ?as' = exec_plan s as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_plan s (as'' @ act # as') = exec_plan s as", "using 1(1) b(1) i(1) exec_plan_Append exec_plan.simps(2)"], ["proof (prove)\nusing this:\n  as = as1 @ act # as2\n  exec_plan s as1 = exec_plan s as''\n  exec_plan (state_succ (exec_plan s as1) act) as' =\n  exec_plan (state_succ (exec_plan s as1) act) as2\n  exec_plan ?s (?as_a @ ?as_b) = exec_plan (exec_plan ?s ?as_a) ?as_b\n  exec_plan ?s (?a # ?as) = exec_plan (state_succ ?s ?a) ?as\n\ngoal (1 subgoal):\n 1. exec_plan s (as'' @ act # as') = exec_plan s as", "by metis"], ["proof (state)\nthis:\n  exec_plan s (as'' @ act # as') = exec_plan s as\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "moreover"], ["proof (state)\nthis:\n  exec_plan s (as'' @ act # as') = exec_plan s as\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "have \"subseq ?as' as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subseq (as'' @ act # as') as", "using 1(1) b(2) i(2) subseq_append_iff"], ["proof (prove)\nusing this:\n  as = as1 @ act # as2\n  subseq as'' as1\n  subseq as' as2\n  subseq ?xs (?ys @ ?zs) =\n  (\\<exists>xs1 xs2.\n      ?xs = xs1 @ xs2 \\<and> subseq xs1 ?ys \\<and> subseq xs2 ?zs)\n\ngoal (1 subgoal):\n 1. subseq (as'' @ act # as') as", "by blast"], ["proof (state)\nthis:\n  subseq (as'' @ act # as') as\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "moreover"], ["proof (state)\nthis:\n  subseq (as'' @ act # as') as\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "{"], ["proof (state)\nthis:\n  subseq (as'' @ act # as') as\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "{\n        \\<comment> \\<open>NOTE this is proved earlier in the original proof script. Moved here to improve\n            transparency.\\<close>"], ["proof (state)\nthis:\n  subseq (as'' @ act # as') as\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "have \"sat_precond_as (exec_plan s as1) (act # as2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat_precond_as (exec_plan s as1) (act # as2)", "using empty_replace_proj_dual7"], ["proof (prove)\nusing this:\n  sat_precond_as ?s (?as @ ?as') \\<Longrightarrow>\n  sat_precond_as (exec_plan ?s ?as) ?as'\n\ngoal (1 subgoal):\n 1. sat_precond_as (exec_plan s as1) (act # as2)", "using 1(1) Cons.prems(7)"], ["proof (prove)\nusing this:\n  sat_precond_as ?s (?as @ ?as') \\<Longrightarrow>\n  sat_precond_as (exec_plan ?s ?as) ?as'\n  as = as1 @ act # as2\n  sat_precond_as s as\n\ngoal (1 subgoal):\n 1. sat_precond_as (exec_plan s as1) (act # as2)", "by blast"], ["proof (state)\nthis:\n  sat_precond_as (exec_plan s as1) (act # as2)\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "then"], ["proof (chain)\npicking this:\n  sat_precond_as (exec_plan s as1) (act # as2)", "have \"fst act \\<subseteq>\\<^sub>f (exec_plan s as1)\""], ["proof (prove)\nusing this:\n  sat_precond_as (exec_plan s as1) (act # as2)\n\ngoal (1 subgoal):\n 1. fst act \\<subseteq>\\<^sub>f exec_plan s as1", "by simp"], ["proof (state)\nthis:\n  fst act \\<subseteq>\\<^sub>f exec_plan s as1\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "}"], ["proof (state)\nthis:\n  fst act \\<subseteq>\\<^sub>f exec_plan s as1\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "note A = this"], ["proof (state)\nthis:\n  fst act \\<subseteq>\\<^sub>f exec_plan s as1\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "{"], ["proof (state)\nthis:\n  fst act \\<subseteq>\\<^sub>f exec_plan s as1\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "have\n          \"fmrestrict_set vs (state_succ (exec_plan s as1) act)\n              = (state_succ (fmrestrict_set vs (exec_plan s as'')) (action_proj act vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrestrict_set vs (state_succ (exec_plan s as1) act) =\n    state_succ (fmrestrict_set vs (exec_plan s as'')) (action_proj act vs)", "using b(1) A drest_succ_proj_eq_drest_succ[where s=\"exec_plan s as1\", symmetric]"], ["proof (prove)\nusing this:\n  exec_plan s as1 = exec_plan s as''\n  fst act \\<subseteq>\\<^sub>f exec_plan s as1\n  fst ?a \\<subseteq>\\<^sub>f exec_plan s as1 \\<Longrightarrow>\n  fmrestrict_set ?vs (state_succ (exec_plan s as1) ?a) =\n  state_succ (fmrestrict_set ?vs (exec_plan s as1)) (action_proj ?a ?vs)\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (state_succ (exec_plan s as1) act) =\n    state_succ (fmrestrict_set vs (exec_plan s as'')) (action_proj act vs)", "by simp"], ["proof (state)\nthis:\n  fmrestrict_set vs (state_succ (exec_plan s as1) act) =\n  state_succ (fmrestrict_set vs (exec_plan s as'')) (action_proj act vs)\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "also"], ["proof (state)\nthis:\n  fmrestrict_set vs (state_succ (exec_plan s as1) act) =\n  state_succ (fmrestrict_set vs (exec_plan s as'')) (action_proj act vs)\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "have \"\\<dots> = (state_succ (fmrestrict_set vs s) (action_proj act vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. state_succ (fmrestrict_set vs (exec_plan s as'')) (action_proj act vs) =\n    state_succ (fmrestrict_set vs s) (action_proj act vs)", "using 1(2) b(1) empty_change_no_change"], ["proof (prove)\nusing this:\n  vars_change as1 vs s = []\n  exec_plan s as1 = exec_plan s as''\n  vars_change ?as ?vs ?s = [] \\<Longrightarrow>\n  fmrestrict_set ?vs (exec_plan ?s ?as) = fmrestrict_set ?vs ?s\n\ngoal (1 subgoal):\n 1. state_succ (fmrestrict_set vs (exec_plan s as'')) (action_proj act vs) =\n    state_succ (fmrestrict_set vs s) (action_proj act vs)", "by fastforce"], ["proof (state)\nthis:\n  state_succ (fmrestrict_set vs (exec_plan s as'')) (action_proj act vs) =\n  state_succ (fmrestrict_set vs s) (action_proj act vs)\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "finally"], ["proof (chain)\npicking this:\n  fmrestrict_set vs (state_succ (exec_plan s as1) act) =\n  state_succ (fmrestrict_set vs s) (action_proj act vs)", "have \"\\<dots> = fmrestrict_set  vs (state_succ s (action_proj act vs))\""], ["proof (prove)\nusing this:\n  fmrestrict_set vs (state_succ (exec_plan s as1) act) =\n  state_succ (fmrestrict_set vs s) (action_proj act vs)\n\ngoal (1 subgoal):\n 1. state_succ (fmrestrict_set vs s) (action_proj act vs) =\n    fmrestrict_set vs (state_succ s (action_proj act vs))", "using  succ_drest_eq_drest_succ"], ["proof (prove)\nusing this:\n  fmrestrict_set vs (state_succ (exec_plan s as1) act) =\n  state_succ (fmrestrict_set vs s) (action_proj act vs)\n  state_succ (fmrestrict_set ?vs ?s) (action_proj ?a ?vs) =\n  fmrestrict_set ?vs (state_succ ?s (action_proj ?a ?vs))\n\ngoal (1 subgoal):\n 1. state_succ (fmrestrict_set vs s) (action_proj act vs) =\n    fmrestrict_set vs (state_succ s (action_proj act vs))", "by blast"], ["proof (state)\nthis:\n  state_succ (fmrestrict_set vs s) (action_proj act vs) =\n  fmrestrict_set vs (state_succ s (action_proj act vs))\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "}"], ["proof (state)\nthis:\n  state_succ (fmrestrict_set vs s) (action_proj act vs) =\n  fmrestrict_set vs (state_succ s (action_proj act vs))\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "note B = this"], ["proof (state)\nthis:\n  state_succ (fmrestrict_set vs s) (action_proj act vs) =\n  fmrestrict_set vs (state_succ s (action_proj act vs))\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "have C: \"fmrestrict_set vs (exec_plan s as'') = fmrestrict_set vs s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrestrict_set vs (exec_plan s as'') = fmrestrict_set vs s", "using 1(2) b(1) empty_change_no_change"], ["proof (prove)\nusing this:\n  vars_change as1 vs s = []\n  exec_plan s as1 = exec_plan s as''\n  vars_change ?as ?vs ?s = [] \\<Longrightarrow>\n  fmrestrict_set ?vs (exec_plan ?s ?as) = fmrestrict_set ?vs ?s\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs (exec_plan s as'') = fmrestrict_set vs s", "by fastforce"], ["proof (state)\nthis:\n  fmrestrict_set vs (exec_plan s as'') = fmrestrict_set vs s\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "{"], ["proof (state)\nthis:\n  fmrestrict_set vs (exec_plan s as'') = fmrestrict_set vs s\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "have \"act \\<in> PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. act \\<in> PROB", "using Cons.prems(5) 1 valid_append_valid_suff valid_plan_valid_head"], ["proof (prove)\nusing this:\n  as \\<in> valid_plans PROB\n  as = as1 @ act # as2\n  vars_change as1 vs s = []\n  state_succ (exec_plan s as1) act = s'\n  vars_change as2 vs (state_succ (exec_plan s as1) act) = ss\n  ?as1.0 @ ?as2.0 \\<in> valid_plans ?PROB \\<Longrightarrow>\n  ?as2.0 \\<in> valid_plans ?PROB\n  ?h # ?as \\<in> valid_plans ?PROB \\<Longrightarrow> ?h \\<in> ?PROB\n\ngoal (1 subgoal):\n 1. act \\<in> PROB", "by fast"], ["proof (state)\nthis:\n  act \\<in> PROB\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "then"], ["proof (chain)\npicking this:\n  act \\<in> PROB", "have \\<aleph>: \"action_proj act vs \\<in> prob_proj PROB vs\""], ["proof (prove)\nusing this:\n  act \\<in> PROB\n\ngoal (1 subgoal):\n 1. action_proj act vs \\<in> prob_proj PROB vs", "using action_proj_in_prob_proj"], ["proof (prove)\nusing this:\n  act \\<in> PROB\n  ?a \\<in> ?PROB \\<Longrightarrow>\n  action_proj ?a ?vs \\<in> prob_proj ?PROB ?vs\n\ngoal (1 subgoal):\n 1. action_proj act vs \\<in> prob_proj PROB vs", "by blast"], ["proof (state)\nthis:\n  action_proj act vs \\<in> prob_proj PROB vs\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "then"], ["proof (chain)\npicking this:\n  action_proj act vs \\<in> prob_proj PROB vs", "have \"(state_succ s (action_proj act vs)) \\<in> (state_successors (prob_proj PROB vs) s)\""], ["proof (prove)\nusing this:\n  action_proj act vs \\<in> prob_proj PROB vs\n\ngoal (1 subgoal):\n 1. state_succ s (action_proj act vs)\n    \\<in> state_successors (prob_proj PROB vs) s", "proof (cases \"fst (action_proj act vs) \\<subseteq>\\<^sub>f s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>action_proj act vs \\<in> prob_proj PROB vs;\n     fst (action_proj act vs) \\<subseteq>\\<^sub>f s\\<rbrakk>\n    \\<Longrightarrow> state_succ s (action_proj act vs)\n                      \\<in> state_successors (prob_proj PROB vs) s\n 2. \\<lbrakk>action_proj act vs \\<in> prob_proj PROB vs;\n     \\<not> fst (action_proj act vs) \\<subseteq>\\<^sub>f s\\<rbrakk>\n    \\<Longrightarrow> state_succ s (action_proj act vs)\n                      \\<in> state_successors (prob_proj PROB vs) s", "case True"], ["proof (state)\nthis:\n  fst (action_proj act vs) \\<subseteq>\\<^sub>f s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>action_proj act vs \\<in> prob_proj PROB vs;\n     fst (action_proj act vs) \\<subseteq>\\<^sub>f s\\<rbrakk>\n    \\<Longrightarrow> state_succ s (action_proj act vs)\n                      \\<in> state_successors (prob_proj PROB vs) s\n 2. \\<lbrakk>action_proj act vs \\<in> prob_proj PROB vs;\n     \\<not> fst (action_proj act vs) \\<subseteq>\\<^sub>f s\\<rbrakk>\n    \\<Longrightarrow> state_succ s (action_proj act vs)\n                      \\<in> state_successors (prob_proj PROB vs) s", "then"], ["proof (chain)\npicking this:\n  fst (action_proj act vs) \\<subseteq>\\<^sub>f s", "show ?thesis"], ["proof (prove)\nusing this:\n  fst (action_proj act vs) \\<subseteq>\\<^sub>f s\n\ngoal (1 subgoal):\n 1. state_succ s (action_proj act vs)\n    \\<in> state_successors (prob_proj PROB vs) s", "unfolding state_successors_def"], ["proof (prove)\nusing this:\n  fst (action_proj act vs) \\<subseteq>\\<^sub>f s\n\ngoal (1 subgoal):\n 1. state_succ s (action_proj act vs)\n    \\<in> state_succ s ` prob_proj PROB vs - {s}", "using Cons.hyps(2) 1(3) b(1) A B C \\<aleph> DiffI imageI singletonD vars_change_cons_2\n              drest_succ_proj_eq_drest_succ"], ["proof (prove)\nusing this:\n  fst (action_proj act vs) \\<subseteq>\\<^sub>f s\n  s' # ss = vars_change as vs s\n  state_succ (exec_plan s as1) act = s'\n  exec_plan s as1 = exec_plan s as''\n  fst act \\<subseteq>\\<^sub>f exec_plan s as1\n  state_succ (fmrestrict_set vs s) (action_proj act vs) =\n  fmrestrict_set vs (state_succ s (action_proj act vs))\n  fmrestrict_set vs (exec_plan s as'') = fmrestrict_set vs s\n  action_proj act vs \\<in> prob_proj PROB vs\n  \\<lbrakk>?c \\<in> ?A; ?c \\<notin> ?B\\<rbrakk>\n  \\<Longrightarrow> ?c \\<in> ?A - ?B\n  ?x \\<in> ?A \\<Longrightarrow> ?f ?x \\<in> ?f ` ?A\n  ?b \\<in> {?a} \\<Longrightarrow> ?b = ?a\n  vars_change ?as ?vs ?s = ?s' # ?ss \\<Longrightarrow>\n  fmrestrict_set ?vs ?s' \\<noteq> fmrestrict_set ?vs ?s\n  fst ?a \\<subseteq>\\<^sub>f ?s \\<Longrightarrow>\n  state_succ (fmrestrict_set ?vs ?s) (action_proj ?a ?vs) =\n  fmrestrict_set ?vs (state_succ ?s ?a)\n\ngoal (1 subgoal):\n 1. state_succ s (action_proj act vs)\n    \\<in> state_succ s ` prob_proj PROB vs - {s}", "by metis"], ["proof (state)\nthis:\n  state_succ s (action_proj act vs)\n  \\<in> state_successors (prob_proj PROB vs) s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>action_proj act vs \\<in> prob_proj PROB vs;\n     \\<not> fst (action_proj act vs) \\<subseteq>\\<^sub>f s\\<rbrakk>\n    \\<Longrightarrow> state_succ s (action_proj act vs)\n                      \\<in> state_successors (prob_proj PROB vs) s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>action_proj act vs \\<in> prob_proj PROB vs;\n     \\<not> fst (action_proj act vs) \\<subseteq>\\<^sub>f s\\<rbrakk>\n    \\<Longrightarrow> state_succ s (action_proj act vs)\n                      \\<in> state_successors (prob_proj PROB vs) s", "case False"], ["proof (state)\nthis:\n  \\<not> fst (action_proj act vs) \\<subseteq>\\<^sub>f s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>action_proj act vs \\<in> prob_proj PROB vs;\n     \\<not> fst (action_proj act vs) \\<subseteq>\\<^sub>f s\\<rbrakk>\n    \\<Longrightarrow> state_succ s (action_proj act vs)\n                      \\<in> state_successors (prob_proj PROB vs) s", "then"], ["proof (chain)\npicking this:\n  \\<not> fst (action_proj act vs) \\<subseteq>\\<^sub>f s", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> fst (action_proj act vs) \\<subseteq>\\<^sub>f s\n\ngoal (1 subgoal):\n 1. state_succ s (action_proj act vs)\n    \\<in> state_successors (prob_proj PROB vs) s", "unfolding state_successors_def"], ["proof (prove)\nusing this:\n  \\<not> fst (action_proj act vs) \\<subseteq>\\<^sub>f s\n\ngoal (1 subgoal):\n 1. state_succ s (action_proj act vs)\n    \\<in> state_succ s ` prob_proj PROB vs - {s}", "using Cons.hyps(2) 1(3) b(1) A B C \\<aleph> DiffI imageI singletonD\n              drest_succ_proj_eq_drest_succ vars_change_cons_2"], ["proof (prove)\nusing this:\n  \\<not> fst (action_proj act vs) \\<subseteq>\\<^sub>f s\n  s' # ss = vars_change as vs s\n  state_succ (exec_plan s as1) act = s'\n  exec_plan s as1 = exec_plan s as''\n  fst act \\<subseteq>\\<^sub>f exec_plan s as1\n  state_succ (fmrestrict_set vs s) (action_proj act vs) =\n  fmrestrict_set vs (state_succ s (action_proj act vs))\n  fmrestrict_set vs (exec_plan s as'') = fmrestrict_set vs s\n  action_proj act vs \\<in> prob_proj PROB vs\n  \\<lbrakk>?c \\<in> ?A; ?c \\<notin> ?B\\<rbrakk>\n  \\<Longrightarrow> ?c \\<in> ?A - ?B\n  ?x \\<in> ?A \\<Longrightarrow> ?f ?x \\<in> ?f ` ?A\n  ?b \\<in> {?a} \\<Longrightarrow> ?b = ?a\n  fst ?a \\<subseteq>\\<^sub>f ?s \\<Longrightarrow>\n  state_succ (fmrestrict_set ?vs ?s) (action_proj ?a ?vs) =\n  fmrestrict_set ?vs (state_succ ?s ?a)\n  vars_change ?as ?vs ?s = ?s' # ?ss \\<Longrightarrow>\n  fmrestrict_set ?vs ?s' \\<noteq> fmrestrict_set ?vs ?s\n\ngoal (1 subgoal):\n 1. state_succ s (action_proj act vs)\n    \\<in> state_succ s ` prob_proj PROB vs - {s}", "by metis"], ["proof (state)\nthis:\n  state_succ s (action_proj act vs)\n  \\<in> state_successors (prob_proj PROB vs) s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  state_succ s (action_proj act vs)\n  \\<in> state_successors (prob_proj PROB vs) s\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "}"], ["proof (state)\nthis:\n  state_succ s (action_proj act vs)\n  \\<in> state_successors (prob_proj PROB vs) s\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "then"], ["proof (chain)\npicking this:\n  state_succ s (action_proj act vs)\n  \\<in> state_successors (prob_proj PROB vs) s", "have D:\n        \"problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n                + S vs lss PROB (fmrestrict_set vs (state_succ s (action_proj act vs)))\n                + 1\n              \\<le> S vs lss PROB (fmrestrict_set vs s)\""], ["proof (prove)\nusing this:\n  state_succ s (action_proj act vs)\n  \\<in> state_successors (prob_proj PROB vs) s\n\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    S vs lss PROB (fmrestrict_set vs (state_succ s (action_proj act vs))) +\n    1\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "using Cons.prems(2, 3, 4) S_geq_S_succ_plus_ell[where s'=\"state_succ s (action_proj act vs)\"]"], ["proof (prove)\nusing this:\n  state_succ s (action_proj act vs)\n  \\<in> state_successors (prob_proj PROB vs) s\n  top_sorted_abs\n   (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss\n  set lss = valid_states (prob_proj PROB vs)\n  s \\<in> valid_states PROB\n  \\<lbrakk>?s \\<in> valid_states ?PROB;\n   top_sorted_abs\n    (\\<lambda>x y. y \\<in> state_successors (prob_proj ?PROB ?vs) x) ?lss;\n   state_succ s (action_proj act vs)\n   \\<in> state_successors (prob_proj ?PROB ?vs) ?s;\n   set ?lss = valid_states (prob_proj ?PROB ?vs)\\<rbrakk>\n  \\<Longrightarrow> problem_plan_bound\n                     (snapshot ?PROB (fmrestrict_set ?vs ?s)) +\n                    S ?vs ?lss ?PROB\n                     (fmrestrict_set ?vs\n                       (state_succ s (action_proj act vs))) +\n                    1\n                    \\<le> S ?vs ?lss ?PROB (fmrestrict_set ?vs ?s)\n\ngoal (1 subgoal):\n 1. problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n    S vs lss PROB (fmrestrict_set vs (state_succ s (action_proj act vs))) +\n    1\n    \\<le> S vs lss PROB (fmrestrict_set vs s)", "by blast"], ["proof (state)\nthis:\n  problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n  S vs lss PROB (fmrestrict_set vs (state_succ s (action_proj act vs))) +\n  1\n  \\<le> S vs lss PROB (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "{"], ["proof (state)\nthis:\n  problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n  S vs lss PROB (fmrestrict_set vs (state_succ s (action_proj act vs))) +\n  1\n  \\<le> S vs lss PROB (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "have\n          \"length ?as' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n                + 1 + S vs lss PROB (fmrestrict_set vs (state_succ (exec_plan s as1) act))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (as'' @ act # as')\n    \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) + 1 +\n          S vs lss PROB\n           (fmrestrict_set vs (state_succ (exec_plan s as1) act))", "using b i"], ["proof (prove)\nusing this:\n  exec_plan s as1 = exec_plan s as''\n  subseq as'' as1\n  length as'' \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s))\n  exec_plan (state_succ (exec_plan s as1) act) as' =\n  exec_plan (state_succ (exec_plan s as1) act) as2\n  subseq as' as2\n  length as'\n  \\<le> S vs lss PROB (fmrestrict_set vs (state_succ (exec_plan s as1) act))\n\ngoal (1 subgoal):\n 1. length (as'' @ act # as')\n    \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) + 1 +\n          S vs lss PROB\n           (fmrestrict_set vs (state_succ (exec_plan s as1) act))", "by fastforce"], ["proof (state)\nthis:\n  length (as'' @ act # as')\n  \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) + 1 +\n        S vs lss PROB (fmrestrict_set vs (state_succ (exec_plan s as1) act))\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "then"], ["proof (chain)\npicking this:\n  length (as'' @ act # as')\n  \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) + 1 +\n        S vs lss PROB (fmrestrict_set vs (state_succ (exec_plan s as1) act))", "have \"length ?as' \\<le> S vs lss PROB (fmrestrict_set vs s)\""], ["proof (prove)\nusing this:\n  length (as'' @ act # as')\n  \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) + 1 +\n        S vs lss PROB (fmrestrict_set vs (state_succ (exec_plan s as1) act))\n\ngoal (1 subgoal):\n 1. length (as'' @ act # as') \\<le> S vs lss PROB (fmrestrict_set vs s)", "using b(1) A B C D drest_succ_proj_eq_drest_succ"], ["proof (prove)\nusing this:\n  length (as'' @ act # as')\n  \\<le> problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) + 1 +\n        S vs lss PROB (fmrestrict_set vs (state_succ (exec_plan s as1) act))\n  exec_plan s as1 = exec_plan s as''\n  fst act \\<subseteq>\\<^sub>f exec_plan s as1\n  state_succ (fmrestrict_set vs s) (action_proj act vs) =\n  fmrestrict_set vs (state_succ s (action_proj act vs))\n  fmrestrict_set vs (exec_plan s as'') = fmrestrict_set vs s\n  problem_plan_bound (snapshot PROB (fmrestrict_set vs s)) +\n  S vs lss PROB (fmrestrict_set vs (state_succ s (action_proj act vs))) +\n  1\n  \\<le> S vs lss PROB (fmrestrict_set vs s)\n  fst ?a \\<subseteq>\\<^sub>f ?s \\<Longrightarrow>\n  state_succ (fmrestrict_set ?vs ?s) (action_proj ?a ?vs) =\n  fmrestrict_set ?vs (state_succ ?s ?a)\n\ngoal (1 subgoal):\n 1. length (as'' @ act # as') \\<le> S vs lss PROB (fmrestrict_set vs s)", "by (smt Suc_eq_plus1 add_Suc dual_order.trans)"], ["proof (state)\nthis:\n  length (as'' @ act # as') \\<le> S vs lss PROB (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "}"], ["proof (state)\nthis:\n  length (as'' @ act # as') \\<le> S vs lss PROB (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "}"], ["proof (state)\nthis:\n  length (as'' @ act # as') \\<le> S vs lss PROB (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "ultimately"], ["proof (chain)\npicking this:\n  exec_plan s (as'' @ act # as') = exec_plan s as\n  subseq (as'' @ act # as') as\n  length (as'' @ act # as') \\<le> S vs lss PROB (fmrestrict_set vs s)", "have ?case"], ["proof (prove)\nusing this:\n  exec_plan s (as'' @ act # as') = exec_plan s as\n  subseq (as'' @ act # as') as\n  length (as'' @ act # as') \\<le> S vs lss PROB (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan s as' = exec_plan s as \\<and>\n     subseq as' as \\<and>\n     length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "}"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan s as' = exec_plan s as \\<and>\n     subseq as' as \\<and>\n     length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. \\<And>a x as vs s PROB lss.\n       \\<lbrakk>\\<And>as vs s PROB lss.\n                   \\<lbrakk>x = vars_change as vs s; finite PROB;\n                    top_sorted_abs\n                     (\\<lambda>x y.\n                         y \\<in> state_successors (prob_proj PROB vs) x)\n                     lss;\n                    set lss = valid_states (prob_proj PROB vs);\n                    s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n                    no_effectless_act as; sat_precond_as s as\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>as'.\n  exec_plan s as' = exec_plan s as \\<and>\n  subseq as' as \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s);\n        a # x = vars_change as vs s; finite PROB;\n        top_sorted_abs\n         (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss;\n        set lss = valid_states (prob_proj PROB vs);\n        s \\<in> valid_states PROB; as \\<in> valid_plans PROB;\n        no_effectless_act as; sat_precond_as s as\\<rbrakk>\n       \\<Longrightarrow> \\<exists>as'.\n                            exec_plan s as' = exec_plan s as \\<and>\n                            subseq as' as \\<and>\n                            length as'\n                            \\<le> S vs lss PROB (fmrestrict_set vs s)", "then"], ["proof (chain)\npicking this:\n  \\<exists>as'.\n     exec_plan s as' = exec_plan s as \\<and>\n     subseq as' as \\<and>\n     length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>as'.\n     exec_plan s as' = exec_plan s as \\<and>\n     subseq as' as \\<and>\n     length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan s as' = exec_plan s as \\<and>\n     subseq as' as \\<and>\n     length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open>NOTE first argument of `top\\_sorted\\_abs` had to be wrapped into lambda.\\<close>"], ["", "lemma problem_plan_bound_S_bound_2nd_step:\n  assumes \"finite (PROB :: 'a problem)\"\n    \"(top_sorted_abs (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss)\"\n    \"(set lss = valid_states (prob_proj PROB vs))\" \"(s \\<in> valid_states PROB)\"\n    \"(as \\<in> valid_plans PROB)\"\n  shows \"(\\<exists>as'.\n    (exec_plan s as' = exec_plan s as)\n    \\<and> (subseq as' as)\n    \\<and> (length as' \\<le> S vs lss PROB (fmrestrict_set vs s))\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "proof -\n  \\<comment> \\<open>NOTE Proof premises and obtain conclusion of `problem\\_plan\\_bound\\_S\\_bound\\_1st\\_step`.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "have a: \"rem_condless_act s [] (rem_effectless_act as) \\<in> valid_plans PROB\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rem_condless_act s [] (rem_effectless_act as) \\<in> valid_plans PROB", "using assms(5) rem_effectless_works_4' rem_condless_valid_10"], ["proof (prove)\nusing this:\n  as \\<in> valid_plans PROB\n  ?as \\<in> valid_plans ?A \\<Longrightarrow>\n  rem_effectless_act ?as \\<in> valid_plans ?A\n  ?as \\<in> valid_plans ?PROB \\<Longrightarrow>\n  rem_condless_act ?s [] ?as \\<in> valid_plans ?PROB\n\ngoal (1 subgoal):\n 1. rem_condless_act s [] (rem_effectless_act as) \\<in> valid_plans PROB", "by blast"], ["proof (state)\nthis:\n  rem_condless_act s [] (rem_effectless_act as) \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "then"], ["proof (chain)\npicking this:\n  rem_condless_act s [] (rem_effectless_act as) \\<in> valid_plans PROB", "have b: \"no_effectless_act (rem_condless_act s [] (rem_effectless_act as))\""], ["proof (prove)\nusing this:\n  rem_condless_act s [] (rem_effectless_act as) \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. no_effectless_act (rem_condless_act s [] (rem_effectless_act as))", "using assms rem_effectless_works_6 rem_condless_valid_9"], ["proof (prove)\nusing this:\n  rem_condless_act s [] (rem_effectless_act as) \\<in> valid_plans PROB\n  finite PROB\n  top_sorted_abs\n   (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss\n  set lss = valid_states (prob_proj PROB vs)\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  no_effectless_act (rem_effectless_act ?as)\n  no_effectless_act ?as \\<Longrightarrow>\n  no_effectless_act (rem_condless_act ?s [] ?as)\n\ngoal (1 subgoal):\n 1. no_effectless_act (rem_condless_act s [] (rem_effectless_act as))", "by fast"], ["proof (state)\nthis:\n  no_effectless_act (rem_condless_act s [] (rem_effectless_act as))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "then"], ["proof (chain)\npicking this:\n  no_effectless_act (rem_condless_act s [] (rem_effectless_act as))", "have \"sat_precond_as s (rem_condless_act s [] (rem_effectless_act as))\""], ["proof (prove)\nusing this:\n  no_effectless_act (rem_condless_act s [] (rem_effectless_act as))\n\ngoal (1 subgoal):\n 1. sat_precond_as s (rem_condless_act s [] (rem_effectless_act as))", "using assms rem_condless_valid_2"], ["proof (prove)\nusing this:\n  no_effectless_act (rem_condless_act s [] (rem_effectless_act as))\n  finite PROB\n  top_sorted_abs\n   (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss\n  set lss = valid_states (prob_proj PROB vs)\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  sat_precond_as ?s (rem_condless_act ?s [] ?as)\n\ngoal (1 subgoal):\n 1. sat_precond_as s (rem_condless_act s [] (rem_effectless_act as))", "by blast"], ["proof (state)\nthis:\n  sat_precond_as s (rem_condless_act s [] (rem_effectless_act as))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "then"], ["proof (chain)\npicking this:\n  sat_precond_as s (rem_condless_act s [] (rem_effectless_act as))", "have \"\\<exists>as'.\n      exec_plan s as' = exec_plan s (rem_condless_act s [] (rem_effectless_act as))\n      \\<and> subseq as' (rem_condless_act s [] (rem_effectless_act as))\n      \\<and> length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\n    \""], ["proof (prove)\nusing this:\n  sat_precond_as s (rem_condless_act s [] (rem_effectless_act as))\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' =\n       exec_plan s (rem_condless_act s [] (rem_effectless_act as)) \\<and>\n       subseq as' (rem_condless_act s [] (rem_effectless_act as)) \\<and>\n       length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "using assms a b problem_plan_bound_S_bound_1st_step"], ["proof (prove)\nusing this:\n  sat_precond_as s (rem_condless_act s [] (rem_effectless_act as))\n  finite PROB\n  top_sorted_abs\n   (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss\n  set lss = valid_states (prob_proj PROB vs)\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  rem_condless_act s [] (rem_effectless_act as) \\<in> valid_plans PROB\n  no_effectless_act (rem_condless_act s [] (rem_effectless_act as))\n  \\<lbrakk>finite ?PROB;\n   top_sorted_abs\n    (\\<lambda>x y. y \\<in> state_successors (prob_proj ?PROB ?vs) x) ?lss;\n   set ?lss = valid_states (prob_proj ?PROB ?vs);\n   ?s \\<in> valid_states ?PROB; ?as \\<in> valid_plans ?PROB;\n   no_effectless_act ?as; sat_precond_as ?s ?as\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s as' = exec_plan ?s ?as \\<and>\n                       subseq as' ?as \\<and>\n                       length as'\n                       \\<le> S ?vs ?lss ?PROB (fmrestrict_set ?vs ?s)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' =\n       exec_plan s (rem_condless_act s [] (rem_effectless_act as)) \\<and>\n       subseq as' (rem_condless_act s [] (rem_effectless_act as)) \\<and>\n       length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan s as' =\n     exec_plan s (rem_condless_act s [] (rem_effectless_act as)) \\<and>\n     subseq as' (rem_condless_act s [] (rem_effectless_act as)) \\<and>\n     length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "}"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan s as' =\n     exec_plan s (rem_condless_act s [] (rem_effectless_act as)) \\<and>\n     subseq as' (rem_condless_act s [] (rem_effectless_act as)) \\<and>\n     length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "then"], ["proof (chain)\npicking this:\n  \\<exists>as'.\n     exec_plan s as' =\n     exec_plan s (rem_condless_act s [] (rem_effectless_act as)) \\<and>\n     subseq as' (rem_condless_act s [] (rem_effectless_act as)) \\<and>\n     length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "obtain as' where 1:\n    \"exec_plan s as' = exec_plan s (rem_condless_act s [] (rem_effectless_act as))\"\n    \"subseq as' (rem_condless_act s [] (rem_effectless_act as))\"\n    \"length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\""], ["proof (prove)\nusing this:\n  \\<exists>as'.\n     exec_plan s as' =\n     exec_plan s (rem_condless_act s [] (rem_effectless_act as)) \\<and>\n     subseq as' (rem_condless_act s [] (rem_effectless_act as)) \\<and>\n     length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan s as' =\n                 exec_plan s\n                  (rem_condless_act s [] (rem_effectless_act as));\n         subseq as' (rem_condless_act s [] (rem_effectless_act as));\n         length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  exec_plan s as' =\n  exec_plan s (rem_condless_act s [] (rem_effectless_act as))\n  subseq as' (rem_condless_act s [] (rem_effectless_act as))\n  length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "then"], ["proof (chain)\npicking this:\n  exec_plan s as' =\n  exec_plan s (rem_condless_act s [] (rem_effectless_act as))\n  subseq as' (rem_condless_act s [] (rem_effectless_act as))\n  length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "have 2: \"exec_plan s as' = exec_plan s as\""], ["proof (prove)\nusing this:\n  exec_plan s as' =\n  exec_plan s (rem_condless_act s [] (rem_effectless_act as))\n  subseq as' (rem_condless_act s [] (rem_effectless_act as))\n  length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. exec_plan s as' = exec_plan s as", "using rem_condless_valid_1 rem_effectless_works_14"], ["proof (prove)\nusing this:\n  exec_plan s as' =\n  exec_plan s (rem_condless_act s [] (rem_effectless_act as))\n  subseq as' (rem_condless_act s [] (rem_effectless_act as))\n  length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\n  exec_plan ?s ?as = exec_plan ?s (rem_condless_act ?s [] ?as)\n  exec_plan ?s ?as = exec_plan ?s (rem_effectless_act ?as)\n\ngoal (1 subgoal):\n 1. exec_plan s as' = exec_plan s as", "by metis"], ["proof (state)\nthis:\n  exec_plan s as' = exec_plan s as\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "then"], ["proof (chain)\npicking this:\n  exec_plan s as' = exec_plan s as", "have \"subseq as' as\""], ["proof (prove)\nusing this:\n  exec_plan s as' = exec_plan s as\n\ngoal (1 subgoal):\n 1. subseq as' as", "using 1(2) rem_condless_valid_8 rem_effectless_works_9 sublist_trans"], ["proof (prove)\nusing this:\n  exec_plan s as' = exec_plan s as\n  subseq as' (rem_condless_act s [] (rem_effectless_act as))\n  subseq (rem_condless_act ?s [] ?as) ?as\n  subseq (rem_effectless_act ?as) ?as\n  \\<lbrakk>subseq ?l1.0 ?l2.0; subseq ?l2.0 ?l3.0\\<rbrakk>\n  \\<Longrightarrow> subseq ?l1.0 ?l3.0\n\ngoal (1 subgoal):\n 1. subseq as' as", "by metis"], ["proof (state)\nthis:\n  subseq as' as\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "then"], ["proof (chain)\npicking this:\n  subseq as' as", "show ?thesis"], ["proof (prove)\nusing this:\n  subseq as' as\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "using 1(3) 2"], ["proof (prove)\nusing this:\n  subseq as' as\n  length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\n  exec_plan s as' = exec_plan s as\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan s as' = exec_plan s as \\<and>\n     subseq as' as \\<and>\n     length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open>NOTE first argument of `top\\_sorted\\_abs` had to be wrapped into lambda.\\<close>"], ["", "lemma S_in_MPLS_leq_2_pow_n:\n  assumes \"finite (PROB :: 'a problem)\"\n    \"(top_sorted_abs (\\<lambda> x y. y \\<in> state_successors (prob_proj PROB vs) x) lss)\"\n    \"(set lss = valid_states (prob_proj PROB vs))\" \"(s \\<in> valid_states PROB)\"\n    \"(as \\<in> valid_plans PROB)\"\n  shows \"(\\<exists>as'.\n      (exec_plan s as' = exec_plan s as)\n      \\<and> (subseq as' as)\n      \\<and> (length as' \\<le> Sup {S vs lss PROB s' | s'. s' \\<in> valid_states (prob_proj PROB  vs)})\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> Sup {S vs lss PROB s' |s'.\n                  s' \\<in> valid_states (prob_proj PROB vs)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> Sup {S vs lss PROB s' |s'.\n                  s' \\<in> valid_states (prob_proj PROB vs)}", "obtain as' where\n    \"exec_plan s as' = exec_plan s as\" \"subseq as' as\"\n    \"length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan s as' = exec_plan s as; subseq as' as;\n         length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms problem_plan_bound_S_bound_2nd_step"], ["proof (prove)\nusing this:\n  finite PROB\n  top_sorted_abs\n   (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss\n  set lss = valid_states (prob_proj PROB vs)\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  \\<lbrakk>finite ?PROB;\n   top_sorted_abs\n    (\\<lambda>x y. y \\<in> state_successors (prob_proj ?PROB ?vs) x) ?lss;\n   set ?lss = valid_states (prob_proj ?PROB ?vs);\n   ?s \\<in> valid_states ?PROB; ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s as' = exec_plan ?s ?as \\<and>\n                       subseq as' ?as \\<and>\n                       length as'\n                       \\<le> S ?vs ?lss ?PROB (fmrestrict_set ?vs ?s)\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan s as' = exec_plan s as; subseq as' as;\n         length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  exec_plan s as' = exec_plan s as\n  subseq as' as\n  length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> Sup {S vs lss PROB s' |s'.\n                  s' \\<in> valid_states (prob_proj PROB vs)}", "moreover"], ["proof (state)\nthis:\n  exec_plan s as' = exec_plan s as\n  subseq as' as\n  length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> Sup {S vs lss PROB s' |s'.\n                  s' \\<in> valid_states (prob_proj PROB vs)}", "{\n    \\<comment> \\<open>NOTE Derive sufficient conditions for inferring that `S vs lss PROB` is smaller or equal to\n    the supremum of the set @{term \"{S vs lss PROB s' | s'. s' \\<in> valid_states (prob_proj PROB vs)}\"}: i.e.\n    being contained and that the supremum is contained as well.\\<close>"], ["proof (state)\nthis:\n  exec_plan s as' = exec_plan s as\n  subseq as' as\n  length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> Sup {S vs lss PROB s' |s'.\n                  s' \\<in> valid_states (prob_proj PROB vs)}", "let ?S=\"{S vs lss PROB s' | s'. s' \\<in> valid_states (prob_proj PROB vs)}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> Sup {S vs lss PROB s' |s'.\n                  s' \\<in> valid_states (prob_proj PROB vs)}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> Sup {S vs lss PROB s' |s'.\n                  s' \\<in> valid_states (prob_proj PROB vs)}", "have \"fmrestrict_set vs s \\<in> valid_states (prob_proj PROB vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fmrestrict_set vs s \\<in> valid_states (prob_proj PROB vs)", "using assms(4) graph_plan_not_eq_last_diff_paths"], ["proof (prove)\nusing this:\n  s \\<in> valid_states PROB\n  ?s \\<in> valid_states ?PROB \\<Longrightarrow>\n  fmrestrict_set ?vs ?s \\<in> valid_states (prob_proj ?PROB ?vs)\n\ngoal (1 subgoal):\n 1. fmrestrict_set vs s \\<in> valid_states (prob_proj PROB vs)", "by blast"], ["proof (state)\nthis:\n  fmrestrict_set vs s \\<in> valid_states (prob_proj PROB vs)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> Sup {S vs lss PROB s' |s'.\n                  s' \\<in> valid_states (prob_proj PROB vs)}", "then"], ["proof (chain)\npicking this:\n  fmrestrict_set vs s \\<in> valid_states (prob_proj PROB vs)", "have \"S vs lss PROB (fmrestrict_set vs s) \\<in> ?S\""], ["proof (prove)\nusing this:\n  fmrestrict_set vs s \\<in> valid_states (prob_proj PROB vs)\n\ngoal (1 subgoal):\n 1. S vs lss PROB (fmrestrict_set vs s)\n    \\<in> {S vs lss PROB s' |s'. s' \\<in> valid_states (prob_proj PROB vs)}", "using calculation(1)"], ["proof (prove)\nusing this:\n  fmrestrict_set vs s \\<in> valid_states (prob_proj PROB vs)\n  exec_plan s as' = exec_plan s as\n\ngoal (1 subgoal):\n 1. S vs lss PROB (fmrestrict_set vs s)\n    \\<in> {S vs lss PROB s' |s'. s' \\<in> valid_states (prob_proj PROB vs)}", "by blast"], ["proof (state)\nthis:\n  S vs lss PROB (fmrestrict_set vs s)\n  \\<in> {S vs lss PROB s' |s'. s' \\<in> valid_states (prob_proj PROB vs)}\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> Sup {S vs lss PROB s' |s'.\n                  s' \\<in> valid_states (prob_proj PROB vs)}", "}"], ["proof (state)\nthis:\n  S vs lss PROB (fmrestrict_set vs s)\n  \\<in> {S vs lss PROB s' |s'. s' \\<in> valid_states (prob_proj PROB vs)}\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> Sup {S vs lss PROB s' |s'.\n                  s' \\<in> valid_states (prob_proj PROB vs)}", "moreover"], ["proof (state)\nthis:\n  S vs lss PROB (fmrestrict_set vs s)\n  \\<in> {S vs lss PROB s' |s'. s' \\<in> valid_states (prob_proj PROB vs)}\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> Sup {S vs lss PROB s' |s'.\n                  s' \\<in> valid_states (prob_proj PROB vs)}", "{"], ["proof (state)\nthis:\n  S vs lss PROB (fmrestrict_set vs s)\n  \\<in> {S vs lss PROB s' |s'. s' \\<in> valid_states (prob_proj PROB vs)}\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> Sup {S vs lss PROB s' |s'.\n                  s' \\<in> valid_states (prob_proj PROB vs)}", "have \"finite (prob_proj PROB vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (prob_proj PROB vs)", "by (simp add: assms(1) prob_proj_def)"], ["proof (state)\nthis:\n  finite (prob_proj PROB vs)\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> Sup {S vs lss PROB s' |s'.\n                  s' \\<in> valid_states (prob_proj PROB vs)}", "then"], ["proof (chain)\npicking this:\n  finite (prob_proj PROB vs)", "have \"finite ?S\""], ["proof (prove)\nusing this:\n  finite (prob_proj PROB vs)\n\ngoal (1 subgoal):\n 1. finite {S vs lss PROB s' |s'. s' \\<in> valid_states (prob_proj PROB vs)}", "using Setcompr_eq_image assms(3)"], ["proof (prove)\nusing this:\n  finite (prob_proj PROB vs)\n  {?f x |x. x \\<in> ?A} = ?f ` ?A\n  set lss = valid_states (prob_proj PROB vs)\n\ngoal (1 subgoal):\n 1. finite {S vs lss PROB s' |s'. s' \\<in> valid_states (prob_proj PROB vs)}", "by (metis List.finite_set finite_imageI)"], ["proof (state)\nthis:\n  finite {S vs lss PROB s' |s'. s' \\<in> valid_states (prob_proj PROB vs)}\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> Sup {S vs lss PROB s' |s'.\n                  s' \\<in> valid_states (prob_proj PROB vs)}", "}"], ["proof (state)\nthis:\n  finite {S vs lss PROB s' |s'. s' \\<in> valid_states (prob_proj PROB vs)}\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> Sup {S vs lss PROB s' |s'.\n                  s' \\<in> valid_states (prob_proj PROB vs)}", "ultimately"], ["proof (chain)\npicking this:\n  S vs lss PROB (fmrestrict_set vs s)\n  \\<in> {S vs lss PROB s' |s'. s' \\<in> valid_states (prob_proj PROB vs)}\n  finite {S vs lss PROB s' |s'. s' \\<in> valid_states (prob_proj PROB vs)}", "have \"S vs lss PROB (fmrestrict_set vs s) \\<le> Sup ?S\""], ["proof (prove)\nusing this:\n  S vs lss PROB (fmrestrict_set vs s)\n  \\<in> {S vs lss PROB s' |s'. s' \\<in> valid_states (prob_proj PROB vs)}\n  finite {S vs lss PROB s' |s'. s' \\<in> valid_states (prob_proj PROB vs)}\n\ngoal (1 subgoal):\n 1. S vs lss PROB (fmrestrict_set vs s)\n    \\<le> Sup {S vs lss PROB s' |s'.\n               s' \\<in> valid_states (prob_proj PROB vs)}", "using le_cSup_finite"], ["proof (prove)\nusing this:\n  S vs lss PROB (fmrestrict_set vs s)\n  \\<in> {S vs lss PROB s' |s'. s' \\<in> valid_states (prob_proj PROB vs)}\n  finite {S vs lss PROB s' |s'. s' \\<in> valid_states (prob_proj PROB vs)}\n  \\<lbrakk>finite ?X; ?x \\<in> ?X\\<rbrakk> \\<Longrightarrow> ?x \\<le> Sup ?X\n\ngoal (1 subgoal):\n 1. S vs lss PROB (fmrestrict_set vs s)\n    \\<le> Sup {S vs lss PROB s' |s'.\n               s' \\<in> valid_states (prob_proj PROB vs)}", "by blast"], ["proof (state)\nthis:\n  S vs lss PROB (fmrestrict_set vs s)\n  \\<le> Sup {S vs lss PROB s' |s'.\n             s' \\<in> valid_states (prob_proj PROB vs)}\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> Sup {S vs lss PROB s' |s'.\n                  s' \\<in> valid_states (prob_proj PROB vs)}", "}"], ["proof (state)\nthis:\n  S vs lss PROB (fmrestrict_set vs s)\n  \\<le> Sup {S vs lss PROB s' |s'.\n             s' \\<in> valid_states (prob_proj PROB vs)}\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> Sup {S vs lss PROB s' |s'.\n                  s' \\<in> valid_states (prob_proj PROB vs)}", "ultimately"], ["proof (chain)\npicking this:\n  exec_plan s as' = exec_plan s as\n  subseq as' as\n  length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\n  S vs lss PROB (fmrestrict_set vs s)\n  \\<le> Sup {S vs lss PROB s' |s'.\n             s' \\<in> valid_states (prob_proj PROB vs)}", "show ?thesis"], ["proof (prove)\nusing this:\n  exec_plan s as' = exec_plan s as\n  subseq as' as\n  length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\n  S vs lss PROB (fmrestrict_set vs s)\n  \\<le> Sup {S vs lss PROB s' |s'.\n             s' \\<in> valid_states (prob_proj PROB vs)}\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> Sup {S vs lss PROB s' |s'.\n                  s' \\<in> valid_states (prob_proj PROB vs)}", "using le_trans"], ["proof (prove)\nusing this:\n  exec_plan s as' = exec_plan s as\n  subseq as' as\n  length as' \\<le> S vs lss PROB (fmrestrict_set vs s)\n  S vs lss PROB (fmrestrict_set vs s)\n  \\<le> Sup {S vs lss PROB s' |s'.\n             s' \\<in> valid_states (prob_proj PROB vs)}\n  \\<lbrakk>?i \\<le> ?j; ?j \\<le> ?k\\<rbrakk> \\<Longrightarrow> ?i \\<le> ?k\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as'\n       \\<le> Sup {S vs lss PROB s' |s'.\n                  s' \\<in> valid_states (prob_proj PROB vs)}", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan s as' = exec_plan s as \\<and>\n     subseq as' as \\<and>\n     length as'\n     \\<le> Sup {S vs lss PROB s' |s'.\n                s' \\<in> valid_states (prob_proj PROB vs)}\n\ngoal:\nNo subgoals!", "qed\n\n\n\\<comment> \\<open>NOTE first argument of `top\\_sorted\\_abs` had to be wrapped into lambda.\\<close>"], ["", "lemma problem_plan_bound_S_bound:\n  fixes PROB :: \"'a problem\"\n  assumes \"finite PROB\" \"(top_sorted_abs (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss)\"\n    \"(set lss = valid_states (prob_proj PROB vs))\"\n  shows \"\n    problem_plan_bound PROB\n    \\<le> Sup {S vs lss PROB (s' :: 'a state) | s'. s' \\<in> valid_states (prob_proj PROB vs)}\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB\n    \\<le> Sup {S vs lss PROB s' |s'.\n               s' \\<in> valid_states (prob_proj PROB vs)}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB\n    \\<le> Sup {S vs lss PROB s' |s'.\n               s' \\<in> valid_states (prob_proj PROB vs)}", "let ?f=\"\\<lambda>PROB.\n    Sup {S vs lss PROB (s' :: 'a state) | s'. s' \\<in> valid_states (prob_proj PROB vs)} + 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB\n    \\<le> Sup {S vs lss PROB s' |s'.\n               s' \\<in> valid_states (prob_proj PROB vs)}", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB\n    \\<le> Sup {S vs lss PROB s' |s'.\n               s' \\<in> valid_states (prob_proj PROB vs)}", "fix as and s :: \"'a state\""], ["proof (state)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB\n    \\<le> Sup {S vs lss PROB s' |s'.\n               s' \\<in> valid_states (prob_proj PROB vs)}", "assume \"s \\<in> valid_states PROB\" \"as \\<in> valid_plans PROB\""], ["proof (state)\nthis:\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB\n    \\<le> Sup {S vs lss PROB s' |s'.\n               s' \\<in> valid_states (prob_proj PROB vs)}", "then"], ["proof (chain)\npicking this:\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB", "obtain as' where a:\n      \"exec_plan s as' = exec_plan s as\" \"subseq as' as\"\n      \"length as' \\<le> Sup {S vs lss PROB s' |s'. s' \\<in> valid_states (prob_proj PROB vs)}\""], ["proof (prove)\nusing this:\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan s as' = exec_plan s as; subseq as' as;\n         length as'\n         \\<le> Sup {S vs lss PROB s' |s'.\n                    s' \\<in> valid_states (prob_proj PROB vs)}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms S_in_MPLS_leq_2_pow_n"], ["proof (prove)\nusing this:\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  finite PROB\n  top_sorted_abs\n   (\\<lambda>x y. y \\<in> state_successors (prob_proj PROB vs) x) lss\n  set lss = valid_states (prob_proj PROB vs)\n  \\<lbrakk>finite ?PROB;\n   top_sorted_abs\n    (\\<lambda>x y. y \\<in> state_successors (prob_proj ?PROB ?vs) x) ?lss;\n   set ?lss = valid_states (prob_proj ?PROB ?vs);\n   ?s \\<in> valid_states ?PROB; ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s as' = exec_plan ?s ?as \\<and>\n                       subseq as' ?as \\<and>\n                       length as'\n                       \\<le> Sup {S ?vs ?lss ?PROB s' |s'.\n                                  s' \\<in> valid_states\n      (prob_proj ?PROB ?vs)}\n\ngoal (1 subgoal):\n 1. (\\<And>as'.\n        \\<lbrakk>exec_plan s as' = exec_plan s as; subseq as' as;\n         length as'\n         \\<le> Sup {S vs lss PROB s' |s'.\n                    s' \\<in> valid_states (prob_proj PROB vs)}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  exec_plan s as' = exec_plan s as\n  subseq as' as\n  length as'\n  \\<le> Sup {S vs lss PROB s' |s'.\n             s' \\<in> valid_states (prob_proj PROB vs)}\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB\n    \\<le> Sup {S vs lss PROB s' |s'.\n               s' \\<in> valid_states (prob_proj PROB vs)}", "then"], ["proof (chain)\npicking this:\n  exec_plan s as' = exec_plan s as\n  subseq as' as\n  length as'\n  \\<le> Sup {S vs lss PROB s' |s'.\n             s' \\<in> valid_states (prob_proj PROB vs)}", "have \"length as' < ?f PROB\""], ["proof (prove)\nusing this:\n  exec_plan s as' = exec_plan s as\n  subseq as' as\n  length as'\n  \\<le> Sup {S vs lss PROB s' |s'.\n             s' \\<in> valid_states (prob_proj PROB vs)}\n\ngoal (1 subgoal):\n 1. length as'\n    < Sup {S vs lss PROB s' |s'.\n           s' \\<in> valid_states (prob_proj PROB vs)} +\n      1", "by linarith"], ["proof (state)\nthis:\n  length as'\n  < Sup {S vs lss PROB s' |s'. s' \\<in> valid_states (prob_proj PROB vs)} +\n    1\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB\n    \\<le> Sup {S vs lss PROB s' |s'.\n               s' \\<in> valid_states (prob_proj PROB vs)}", "moreover"], ["proof (state)\nthis:\n  length as'\n  < Sup {S vs lss PROB s' |s'. s' \\<in> valid_states (prob_proj PROB vs)} +\n    1\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB\n    \\<le> Sup {S vs lss PROB s' |s'.\n               s' \\<in> valid_states (prob_proj PROB vs)}", "have \"exec_plan s as = exec_plan s as'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exec_plan s as = exec_plan s as'", "using a(1)"], ["proof (prove)\nusing this:\n  exec_plan s as' = exec_plan s as\n\ngoal (1 subgoal):\n 1. exec_plan s as = exec_plan s as'", "by simp"], ["proof (state)\nthis:\n  exec_plan s as = exec_plan s as'\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB\n    \\<le> Sup {S vs lss PROB s' |s'.\n               s' \\<in> valid_states (prob_proj PROB vs)}", "ultimately"], ["proof (chain)\npicking this:\n  length as'\n  < Sup {S vs lss PROB s' |s'. s' \\<in> valid_states (prob_proj PROB vs)} +\n    1\n  exec_plan s as = exec_plan s as'", "have\n      \"\\<exists>as'. exec_plan s as = exec_plan s as' \\<and> subseq as' as \\<and> length as' < ?f PROB\""], ["proof (prove)\nusing this:\n  length as'\n  < Sup {S vs lss PROB s' |s'. s' \\<in> valid_states (prob_proj PROB vs)} +\n    1\n  exec_plan s as = exec_plan s as'\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       < Sup {S vs lss PROB s' |s'.\n              s' \\<in> valid_states (prob_proj PROB vs)} +\n         1", "using a(2)"], ["proof (prove)\nusing this:\n  length as'\n  < Sup {S vs lss PROB s' |s'. s' \\<in> valid_states (prob_proj PROB vs)} +\n    1\n  exec_plan s as = exec_plan s as'\n  subseq as' as\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as = exec_plan s as' \\<and>\n       subseq as' as \\<and>\n       length as'\n       < Sup {S vs lss PROB s' |s'.\n              s' \\<in> valid_states (prob_proj PROB vs)} +\n         1", "by blast"], ["proof (state)\nthis:\n  \\<exists>as'.\n     exec_plan s as = exec_plan s as' \\<and>\n     subseq as' as \\<and>\n     length as'\n     < Sup {S vs lss PROB s' |s'.\n            s' \\<in> valid_states (prob_proj PROB vs)} +\n       1\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB\n    \\<le> Sup {S vs lss PROB s' |s'.\n               s' \\<in> valid_states (prob_proj PROB vs)}", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?s2 \\<in> valid_states PROB; ?as2 \\<in> valid_plans PROB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n                       subseq as' ?as2 \\<and>\n                       length as'\n                       < Sup {S vs lss PROB s' |s'.\n                              s' \\<in> valid_states (prob_proj PROB vs)} +\n                         1\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB\n    \\<le> Sup {S vs lss PROB s' |s'.\n               s' \\<in> valid_states (prob_proj PROB vs)}", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>?s2 \\<in> valid_states PROB; ?as2 \\<in> valid_plans PROB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n                       subseq as' ?as2 \\<and>\n                       length as'\n                       < Sup {S vs lss PROB s' |s'.\n                              s' \\<in> valid_states (prob_proj PROB vs)} +\n                         1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s2 \\<in> valid_states PROB; ?as2 \\<in> valid_plans PROB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n                       subseq as' ?as2 \\<and>\n                       length as'\n                       < Sup {S vs lss PROB s' |s'.\n                              s' \\<in> valid_states (prob_proj PROB vs)} +\n                         1\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB\n    \\<le> Sup {S vs lss PROB s' |s'.\n               s' \\<in> valid_states (prob_proj PROB vs)}", "using assms(1) problem_plan_bound_UBound[where f=\"?f\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s2 \\<in> valid_states PROB; ?as2 \\<in> valid_plans PROB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s2 ?as2 = exec_plan ?s2 as' \\<and>\n                       subseq as' ?as2 \\<and>\n                       length as'\n                       < Sup {S vs lss PROB s' |s'.\n                              s' \\<in> valid_states (prob_proj PROB vs)} +\n                         1\n  finite PROB\n  \\<lbrakk>\\<forall>as s.\n              s \\<in> valid_states ?PROB \\<and>\n              as \\<in> valid_plans ?PROB \\<longrightarrow>\n              (\\<exists>as'.\n                  exec_plan s as = exec_plan s as' \\<and>\n                  subseq as' as \\<and>\n                  length as'\n                  < Sup {S vs lss ?PROB s' |s'.\n                         s' \\<in> valid_states (prob_proj ?PROB vs)} +\n                    1);\n   finite ?PROB\\<rbrakk>\n  \\<Longrightarrow> problem_plan_bound ?PROB\n                    < Sup {S vs lss ?PROB s' |s'.\n                           s' \\<in> valid_states (prob_proj ?PROB vs)} +\n                      1\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB\n    \\<le> Sup {S vs lss PROB s' |s'.\n               s' \\<in> valid_states (prob_proj PROB vs)}", "by fastforce"], ["proof (state)\nthis:\n  problem_plan_bound PROB\n  \\<le> Sup {S vs lss PROB s' |s'.\n             s' \\<in> valid_states (prob_proj PROB vs)}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"State Space Acyclicity\""], ["", "text \\<open> State space acyclicity is again formalized using graphs to model the state space. However\nthe relation inducing the graph is the successor relation on states. [Abdulaziz et al.,\nDefinition 15, HOL4 Definition 15, p.27]\n\nWith this, the acyclic system compositional bound `S` can be shown to be an upper bound on the\nsublist diameter (lemma `problem\\_plan\\_bound\\_S\\_bound\\_thesis`). [Abdulaziz et al., p.29] \\<close>\n\n\\<comment> \\<open>NOTE name shortened.\\<close>\n\\<comment> \\<open>NOTE first argument of 'top\\_sorted\\_abs' had to be wrapped into lambda.\\<close>"], ["", "definition sspace_DAG where\n  \"sspace_DAG PROB lss \\<equiv> (\n    (set lss = valid_states PROB)\n    \\<and> (top_sorted_abs (\\<lambda>x y. y \\<in> state_successors PROB x) lss)\n  )\""], ["", "lemma problem_plan_bound_S_bound_2nd_step_thesis:\n  assumes \"finite (PROB :: 'a problem)\" \"(sspace_DAG (prob_proj PROB vs) lss)\"\n    \"(s \\<in> valid_states PROB)\" \"(as \\<in> valid_plans PROB)\"\n  shows \"(\\<exists>as'.   (exec_plan s as' = exec_plan s as)\n    \\<and> (subseq as' as)\n    \\<and> (length as' \\<le> S vs lss PROB (fmrestrict_set vs s))\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "using assms problem_plan_bound_S_bound_2nd_step sspace_DAG_def"], ["proof (prove)\nusing this:\n  finite PROB\n  sspace_DAG (prob_proj PROB vs) lss\n  s \\<in> valid_states PROB\n  as \\<in> valid_plans PROB\n  \\<lbrakk>finite ?PROB;\n   top_sorted_abs\n    (\\<lambda>x y. y \\<in> state_successors (prob_proj ?PROB ?vs) x) ?lss;\n   set ?lss = valid_states (prob_proj ?PROB ?vs);\n   ?s \\<in> valid_states ?PROB; ?as \\<in> valid_plans ?PROB\\<rbrakk>\n  \\<Longrightarrow> \\<exists>as'.\n                       exec_plan ?s as' = exec_plan ?s ?as \\<and>\n                       subseq as' ?as \\<and>\n                       length as'\n                       \\<le> S ?vs ?lss ?PROB (fmrestrict_set ?vs ?s)\n  sspace_DAG ?PROB ?lss \\<equiv>\n  set ?lss = valid_states ?PROB \\<and>\n  top_sorted_abs (\\<lambda>x y. y \\<in> state_successors ?PROB x) ?lss\n\ngoal (1 subgoal):\n 1. \\<exists>as'.\n       exec_plan s as' = exec_plan s as \\<and>\n       subseq as' as \\<and>\n       length as' \\<le> S vs lss PROB (fmrestrict_set vs s)", "by fast"], ["", "text \\<open>And finally, this is the main lemma about the upper bounding algorithm.\\<close>"], ["", "theorem problem_plan_bound_S_bound_thesis:\n  assumes \"finite (PROB :: 'a problem)\" \"(sspace_DAG (prob_proj PROB vs) lss)\"\n  shows \"(\n    problem_plan_bound PROB\n    \\<le> Sup {S vs lss PROB s' | s'. s' \\<in> valid_states (prob_proj PROB vs)}\n  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. problem_plan_bound PROB\n    \\<le> Sup {S vs lss PROB s' |s'.\n               s' \\<in> valid_states (prob_proj PROB vs)}", "using assms problem_plan_bound_S_bound sspace_DAG_def"], ["proof (prove)\nusing this:\n  finite PROB\n  sspace_DAG (prob_proj PROB vs) lss\n  \\<lbrakk>finite ?PROB;\n   top_sorted_abs\n    (\\<lambda>x y. y \\<in> state_successors (prob_proj ?PROB ?vs) x) ?lss;\n   set ?lss = valid_states (prob_proj ?PROB ?vs)\\<rbrakk>\n  \\<Longrightarrow> problem_plan_bound ?PROB\n                    \\<le> Sup {S ?vs ?lss ?PROB s' |s'.\n                               s' \\<in> valid_states (prob_proj ?PROB ?vs)}\n  sspace_DAG ?PROB ?lss \\<equiv>\n  set ?lss = valid_states ?PROB \\<and>\n  top_sorted_abs (\\<lambda>x y. y \\<in> state_successors ?PROB x) ?lss\n\ngoal (1 subgoal):\n 1. problem_plan_bound PROB\n    \\<le> Sup {S vs lss PROB s' |s'.\n               s' \\<in> valid_states (prob_proj PROB vs)}", "by fast"], ["", "end"]]}